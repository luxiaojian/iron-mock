/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(26);
	
	__webpack_require__(33);
	
	__webpack_require__(36);
	
	__webpack_require__(40);
	
	__webpack_require__(41);
	
	__webpack_require__(42);
	
	__webpack_require__(45);
	
	__webpack_require__(47);
	
	__webpack_require__(49);
	
	__webpack_require__(51);
	
	__webpack_require__(53);
	
	__webpack_require__(55);
	
	__webpack_require__(57);
	
	__webpack_require__(59);
	
	__webpack_require__(61);

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}
	
	function createLinkElement() {
		var linkElement = document.createElement("link");
		var head = getHeadElement();
		linkElement.rel = "stylesheet";
		head.appendChild(linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement();
			update = updateLink.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				styleElement.parentNode.removeChild(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(JSON.stringify(sourceMap)) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(34);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!./../../../node_modules/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./../../../node_modules/style-loader/index.js!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./sweetalert.css", function() {
			var newContent = require("!!./../../../node_modules/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./../../../node_modules/style-loader/index.js!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./sweetalert.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 34 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 35 */,
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(37);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!./../../../node_modules/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./../../../node_modules/style-loader/index.js!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./jsoneditor.min.css", function() {
			var newContent = require("!!./../../../node_modules/extract-text-webpack-plugin/loader.js?{\"omit\":1,\"extract\":true,\"remove\":true}!./../../../node_modules/style-loader/index.js!./../../../node_modules/css-loader/index.js!./../../../node_modules/postcss-loader/index.js!./jsoneditor.min.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 37 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 38 */,
/* 39 */,
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2014 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */
	
	// vim: ts=4 sts=4 sw=4 expandtab
	
	
	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/returnExports.js
	// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
	;(function (root, factory) {
	    'use strict';
	    /*global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	    }
	}(this, function () {
	
	/**
	 * Brings an environment as close to ECMAScript 5 compliance
	 * as is possible with the facilities of erstwhile engines.
	 *
	 * Annotated ES5: http://es5.github.com/ (specific links below)
	 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
	 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
	 */
	
	// Shortcut to an often accessed properties, in order to avoid multiple
	// dereference that costs universally.
	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var NumberPrototype = Number.prototype;
	var array_slice = ArrayPrototype.slice;
	var array_splice = ArrayPrototype.splice;
	var array_push = ArrayPrototype.push;
	var array_unshift = ArrayPrototype.unshift;
	var call = FunctionPrototype.call;
	
	// Having a toString local variable name breaks in Opera so use to_string.
	var to_string = ObjectPrototype.toString;
	
	var isFunction = function (val) {
	    return to_string.call(val) === '[object Function]';
	};
	var isRegex = function (val) {
	    return to_string.call(val) === '[object RegExp]';
	};
	var isArray = function isArray(obj) {
	    return to_string.call(obj) === '[object Array]';
	};
	var isString = function isString(obj) {
	    return to_string.call(obj) === '[object String]';
	};
	var isArguments = function isArguments(value) {
	    var str = to_string.call(value);
	    var isArgs = str === '[object Arguments]';
	    if (!isArgs) {
	        isArgs = !isArray(value) &&
	          value !== null &&
	          typeof value === 'object' &&
	          typeof value.length === 'number' &&
	          value.length >= 0 &&
	          isFunction(value.callee);
	    }
	    return isArgs;
	};
	
	var supportsDescriptors = Object.defineProperty && (function () {
	    try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	    } catch (e) { /* this is ES3 */
	        return false;
	    }
	}());
	
	// Define configurable, writable and non-enumerable props
	// if they don't exist.
	var defineProperty;
	if (supportsDescriptors) {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        Object.defineProperty(object, name, {
	            configurable: true,
	            enumerable: false,
	            writable: true,
	            value: method
	        });
	    };
	} else {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        object[name] = method;
	    };
	}
	var defineProperties = function (object, map, forceAssign) {
	    for (var name in map) {
	        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
	          defineProperty(object, name, map[name], forceAssign);
	        }
	    }
	};
	
	//
	// Util
	// ======
	//
	
	// ES5 9.4
	// http://es5.github.com/#x9.4
	// http://jsperf.com/to-integer
	
	function toInteger(num) {
	    var n = +num;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}
	
	function isPrimitive(input) {
	    var type = typeof input;
	    return input === null ||
	        type === 'undefined' ||
	        type === 'boolean' ||
	        type === 'number' ||
	        type === 'string';
	}
	
	function toPrimitive(input) {
	    var val, valueOf, toStr;
	    if (isPrimitive(input)) {
	        return input;
	    }
	    valueOf = input.valueOf;
	    if (isFunction(valueOf)) {
	        val = valueOf.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    toStr = input.toString;
	    if (isFunction(toStr)) {
	        val = toStr.call(input);
	        if (isPrimitive(val)) {
	            return val;
	        }
	    }
	    throw new TypeError();
	}
	
	var ES = {
	    // ES5 9.9
	    // http://es5.github.com/#x9.9
	    ToObject: function (o) {
	        /*jshint eqnull: true */
	        if (o == null) { // this matches both null and undefined
	            throw new TypeError("can't convert " + o + ' to object');
	        }
	        return Object(o);
	    },
	    ToUint32: function ToUint32(x) {
	        return x >>> 0;
	    }
	};
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	var Empty = function Empty() {};
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isFunction(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var bound;
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    args.concat(array_slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    args.concat(array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = Math.max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            boundArgs.push('$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
	// us it in defining shortcuts.
	var owns = call.bind(ObjectPrototype.hasOwnProperty);
	
	//
	// Array
	// =====
	//
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.12
	var spliceNoopReturnsEmptyArray = (function () {
	    var a = [1, 2];
	    var result = a.splice();
	    return a.length === 2 && isArray(result) && result.length === 0;
	}());
	defineProperties(ArrayPrototype, {
	    // Safari 5.0 bug where .splice() returns undefined
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) {
	            return [];
	        } else {
	            return array_splice.apply(this, arguments);
	        }
	    }
	}, spliceNoopReturnsEmptyArray);
	
	var spliceWorksWithEmptyObject = (function () {
	    var obj = {};
	    ArrayPrototype.splice.call(obj, 0, 0, 1);
	    return obj.length === 1;
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) { return []; }
	        var args = arguments;
	        this.length = Math.max(toInteger(this.length), 0);
	        if (arguments.length > 0 && typeof deleteCount !== 'number') {
	            args = array_slice.call(arguments);
	            if (args.length < 2) {
	                args.push(this.length - start);
	            } else {
	                args[1] = toInteger(deleteCount);
	            }
	        }
	        return array_splice.apply(this, args);
	    }
	}, !spliceWorksWithEmptyObject);
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.13
	// Return len+argCount.
	// [bugfix, ielt8]
	// IE < 8 bug: [].unshift(0) === undefined but should be "1"
	var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
	defineProperties(ArrayPrototype, {
	    unshift: function () {
	        array_unshift.apply(this, arguments);
	        return this.length;
	    }
	}, hasUnshiftReturnValueBug);
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties(Array, { isArray: isArray });
	
	// The IsCallable() check in the Array functions
	// has been replaced with a strict check on the
	// internal class of the object to trap cases where
	// the provided function was actually a regular
	// expression literal, which in V8 and
	// JavaScriptCore is a typeof "function".  Only in
	// V8 are regular expression literals permitted as
	// reduce parameters, so it is desirable in the
	// general case for the shim to match the more
	// strict and common behavior of rejecting regular
	// expressions.
	
	// ES5 15.4.4.18
	// http://es5.github.com/#x15.4.4.18
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
	
	// Check failure of by-index access of string characters (IE < 9)
	// and failure of `0 in boxedString` (Rhino)
	var boxedString = Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(fun /*, thisp*/) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(); // TODO message
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                // context
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.19
	// http://es5.github.com/#x15.4.4.19
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
	defineProperties(ArrayPrototype, {
	    map: function map(fun /*, thisp*/) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            length = self.length >>> 0,
	            result = Array(length),
	            thisp = arguments[1];
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(fun + ' is not a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                result[i] = fun.call(thisp, self[i], i, object);
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.map));
	
	// ES5 15.4.4.20
	// http://es5.github.com/#x15.4.4.20
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
	defineProperties(ArrayPrototype, {
	    filter: function filter(fun /*, thisp */) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            length = self.length >>> 0,
	            result = [],
	            value,
	            thisp = arguments[1];
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(fun + ' is not a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (fun.call(thisp, value, i, object)) {
	                    result.push(value);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.filter));
	
	// ES5 15.4.4.16
	// http://es5.github.com/#x15.4.4.16
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
	defineProperties(ArrayPrototype, {
	    every: function every(fun /*, thisp */) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(fun + ' is not a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && !fun.call(thisp, self[i], i, object)) {
	                return false;
	            }
	        }
	        return true;
	    }
	}, !properlyBoxesContext(ArrayPrototype.every));
	
	// ES5 15.4.4.17
	// http://es5.github.com/#x15.4.4.17
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
	defineProperties(ArrayPrototype, {
	    some: function some(fun /*, thisp */) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            length = self.length >>> 0,
	            thisp = arguments[1];
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(fun + ' is not a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && fun.call(thisp, self[i], i, object)) {
	                return true;
	            }
	        }
	        return false;
	    }
	}, !properlyBoxesContext(ArrayPrototype.some));
	
	// ES5 15.4.4.21
	// http://es5.github.com/#x15.4.4.21
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
	var reduceCoercesToObject = false;
	if (ArrayPrototype.reduce) {
	    reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduce: function reduce(fun /*, initial*/) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(fun + ' is not a function');
	        }
	
	        // no value to return if no initial value and an empty array
	        if (!length && arguments.length === 1) {
	            throw new TypeError('reduce of empty array with no initial value');
	        }
	
	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (++i >= length) {
	                    throw new TypeError('reduce of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        for (; i < length; i++) {
	            if (i in self) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        }
	
	        return result;
	    }
	}, !reduceCoercesToObject);
	
	// ES5 15.4.4.22
	// http://es5.github.com/#x15.4.4.22
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
	var reduceRightCoercesToObject = false;
	if (ArrayPrototype.reduceRight) {
	    reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduceRight: function reduceRight(fun /*, initial*/) {
	        var object = ES.ToObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(fun + ' is not a function');
	        }
	
	        // no value to return if no initial value, empty array
	        if (!length && arguments.length === 1) {
	            throw new TypeError('reduceRight of empty array with no initial value');
	        }
	
	        var result, i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (--i < 0) {
	                    throw new TypeError('reduceRight of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        if (i < 0) {
	            return result;
	        }
	
	        do {
	            if (i in self) {
	                result = fun.call(void 0, result, self[i], i, object);
	            }
	        } while (i--);
	
	        return result;
	    }
	}, !reduceRightCoercesToObject);
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(sought /*, fromIndex */) {
	        var self = splitString && isString(this) ? this.split('') : ES.ToObject(this),
	            length = self.length >>> 0;
	
	        if (!length) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	// ES5 15.4.4.15
	// http://es5.github.com/#x15.4.4.15
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
	var hasFirefox2LastIndexOfBug = Array.prototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
	defineProperties(ArrayPrototype, {
	    lastIndexOf: function lastIndexOf(sought /*, fromIndex */) {
	        var self = splitString && isString(this) ? this.split('') : ES.ToObject(this),
	            length = self.length >>> 0;
	
	        if (!length) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = Math.min(i, toInteger(arguments[1]));
	        }
	        // handle negative indices
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && sought === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2LastIndexOfBug);
	
	//
	// Object
	// ======
	//
	
	// ES5 15.2.3.14
	// http://es5.github.com/#x15.2.3.14
	
	// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
	var hasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),
	    hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype'),
	    dontEnums = [
	        'toString',
	        'toLocaleString',
	        'valueOf',
	        'hasOwnProperty',
	        'isPrototypeOf',
	        'propertyIsEnumerable',
	        'constructor'
	    ],
	    dontEnumsLength = dontEnums.length;
	
	defineProperties(Object, {
	    keys: function keys(object) {
	        var isFn = isFunction(object),
	            isArgs = isArguments(object),
	            isObject = object !== null && typeof object === 'object',
	            isStr = isObject && isString(object);
	
	        if (!isObject && !isFn && !isArgs) {
	            throw new TypeError('Object.keys called on a non-object');
	        }
	
	        var theKeys = [];
	        var skipProto = hasProtoEnumBug && isFn;
	        if (isStr || isArgs) {
	            for (var i = 0; i < object.length; ++i) {
	                theKeys.push(String(i));
	            }
	        } else {
	            for (var name in object) {
	                if (!(skipProto && name === 'prototype') && owns(object, name)) {
	                    theKeys.push(String(name));
	                }
	            }
	        }
	
	        if (hasDontEnumBug) {
	            var ctor = object.constructor,
	                skipConstructor = ctor && ctor.prototype === object;
	            for (var j = 0; j < dontEnumsLength; j++) {
	                var dontEnum = dontEnums[j];
	                if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
	                    theKeys.push(dontEnum);
	                }
	            }
	        }
	        return theKeys;
	    }
	});
	
	var keysWorksWithArguments = Object.keys && (function () {
	    // Safari 5.0 bug
	    return Object.keys(arguments).length === 2;
	}(1, 2));
	var originalKeys = Object.keys;
	defineProperties(Object, {
	    keys: function keys(object) {
	        if (isArguments(object)) {
	            return originalKeys(ArrayPrototype.slice.call(object));
	        } else {
	            return originalKeys(object);
	        }
	    }
	}, !keysWorksWithArguments);
	
	//
	// Date
	// ====
	//
	
	// ES5 15.9.5.43
	// http://es5.github.com/#x15.9.5.43
	// This function returns a String value represent the instance in time
	// represented by this Date object. The format of the String is the Date Time
	// string format defined in 15.9.1.15. All fields are present in the String.
	// The time zone is always UTC, denoted by the suffix Z. If the time value of
	// this object is not a finite Number a RangeError exception is thrown.
	var negativeDate = -62198755200000;
	var negativeYearString = '-000001';
	var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
	
	defineProperties(Date.prototype, {
	    toISOString: function toISOString() {
	        var result, length, value, year, month;
	        if (!isFinite(this)) {
	            throw new RangeError('Date.prototype.toISOString called on non-finite value.');
	        }
	
	        year = this.getUTCFullYear();
	
	        month = this.getUTCMonth();
	        // see https://github.com/es-shims/es5-shim/issues/111
	        year += Math.floor(month / 12);
	        month = (month % 12 + 12) % 12;
	
	        // the date time string format is specified in 15.9.1.15.
	        result = [month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
	        year = (
	            (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
	            ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6)
	        );
	
	        length = result.length;
	        while (length--) {
	            value = result[length];
	            // pad months, days, hours, minutes, and seconds to have two
	            // digits.
	            if (value < 10) {
	                result[length] = '0' + value;
	            }
	        }
	        // pad milliseconds to have three digits.
	        return (
	            year + '-' + result.slice(0, 2).join('-') +
	            'T' + result.slice(2).join(':') + '.' +
	            ('000' + this.getUTCMilliseconds()).slice(-3) + 'Z'
	        );
	    }
	}, hasNegativeDateBug);
	
	
	// ES5 15.9.5.44
	// http://es5.github.com/#x15.9.5.44
	// This function provides a String representation of a Date object for use by
	// JSON.stringify (15.12.3).
	var dateToJSONIsSupported = false;
	try {
	    dateToJSONIsSupported = (
	        Date.prototype.toJSON &&
	        new Date(NaN).toJSON() === null &&
	        new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
	        Date.prototype.toJSON.call({ // generic
	            toISOString: function () {
	                return true;
	            }
	        })
	    );
	} catch (e) {
	}
	if (!dateToJSONIsSupported) {
	    Date.prototype.toJSON = function toJSON(key) {
	        // When the toJSON method is called with argument key, the following
	        // steps are taken:
	
	        // 1.  Let O be the result of calling ToObject, giving it the this
	        // value as its argument.
	        // 2. Let tv be toPrimitive(O, hint Number).
	        var o = Object(this),
	            tv = toPrimitive(o),
	            toISO;
	        // 3. If tv is a Number and is not finite, return null.
	        if (typeof tv === 'number' && !isFinite(tv)) {
	            return null;
	        }
	        // 4. Let toISO be the result of calling the [[Get]] internal method of
	        // O with argument "toISOString".
	        toISO = o.toISOString;
	        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
	        if (typeof toISO !== 'function') {
	            throw new TypeError('toISOString property is not callable');
	        }
	        // 6. Return the result of calling the [[Call]] internal method of
	        //  toISO with O as the this value and an empty argument list.
	        return toISO.call(o);
	
	        // NOTE 1 The argument is ignored.
	
	        // NOTE 2 The toJSON function is intentionally generic; it does not
	        // require that its this value be a Date object. Therefore, it can be
	        // transferred to other kinds of objects for use as a method. However,
	        // it does require that any such object have a toISOString method. An
	        // object is free to use the argument key to filter its
	        // stringification.
	    };
	}
	
	// ES5 15.9.4.2
	// http://es5.github.com/#x15.9.4.2
	// based on work shared by Daniel Friesen (dantman)
	// http://gist.github.com/303249
	var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
	var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z'));
	var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
	if (!Date.parse || doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
	    // XXX global assignment won't work in embeddings that use
	    // an alternate object for the context.
	    /*global Date: true */
	    Date = (function (NativeDate) {
	
	        // Date.length === 7
	        function Date(Y, M, D, h, m, s, ms) {
	            var length = arguments.length;
	            if (this instanceof NativeDate) {
	                var date = length === 1 && String(Y) === Y ? // isString(Y)
	                    // We explicitly pass it through parse:
	                    new NativeDate(Date.parse(Y)) :
	                    // We have to manually make calls depending on argument
	                    // length here
	                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :
	                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :
	                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
	                    length >= 4 ? new NativeDate(Y, M, D, h) :
	                    length >= 3 ? new NativeDate(Y, M, D) :
	                    length >= 2 ? new NativeDate(Y, M) :
	                    length >= 1 ? new NativeDate(Y) :
	                                  new NativeDate();
	                // Prevent mixups with unfixed Date object
	                date.constructor = Date;
	                return date;
	            }
	            return NativeDate.apply(this, arguments);
	        }
	
	        // 15.9.1.15 Date Time String Format.
	        var isoDateExpression = new RegExp('^' +
	            '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
	                                      // 6-digit extended year
	            '(?:-(\\d{2})' + // optional month capture
	            '(?:-(\\d{2})' + // optional day capture
	            '(?:' + // capture hours:minutes:seconds.milliseconds
	                'T(\\d{2})' + // hours capture
	                ':(\\d{2})' + // minutes capture
	                '(?:' + // optional :seconds.milliseconds
	                    ':(\\d{2})' + // seconds capture
	                    '(?:(\\.\\d{1,}))?' + // milliseconds capture
	                ')?' +
	            '(' + // capture UTC offset component
	                'Z|' + // UTC capture
	                '(?:' + // offset specifier +/-hours:minutes
	                    '([-+])' + // sign capture
	                    '(\\d{2})' + // hours offset capture
	                    ':(\\d{2})' + // minutes offset capture
	                ')' +
	            ')?)?)?)?' +
	        '$');
	
	        var months = [
	            0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
	        ];
	
	        function dayFromMonth(year, month) {
	            var t = month > 1 ? 1 : 0;
	            return (
	                months[month] +
	                Math.floor((year - 1969 + t) / 4) -
	                Math.floor((year - 1901 + t) / 100) +
	                Math.floor((year - 1601 + t) / 400) +
	                365 * (year - 1970)
	            );
	        }
	
	        function toUTC(t) {
	            return Number(new NativeDate(1970, 0, 1, 0, 0, 0, t));
	        }
	
	        // Copy any custom methods a 3rd party library may have added
	        for (var key in NativeDate) {
	            Date[key] = NativeDate[key];
	        }
	
	        // Copy "native" methods explicitly; they may be non-enumerable
	        Date.now = NativeDate.now;
	        Date.UTC = NativeDate.UTC;
	        Date.prototype = NativeDate.prototype;
	        Date.prototype.constructor = Date;
	
	        // Upgrade Date.parse to handle simplified ISO 8601 strings
	        Date.parse = function parse(string) {
	            var match = isoDateExpression.exec(string);
	            if (match) {
	                // parse months, days, hours, minutes, seconds, and milliseconds
	                // provide default values if necessary
	                // parse the UTC offset component
	                var year = Number(match[1]),
	                    month = Number(match[2] || 1) - 1,
	                    day = Number(match[3] || 1) - 1,
	                    hour = Number(match[4] || 0),
	                    minute = Number(match[5] || 0),
	                    second = Number(match[6] || 0),
	                    millisecond = Math.floor(Number(match[7] || 0) * 1000),
	                    // When time zone is missed, local offset should be used
	                    // (ES 5.1 bug)
	                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
	                    isLocalTime = Boolean(match[4] && !match[8]),
	                    signOffset = match[9] === '-' ? 1 : -1,
	                    hourOffset = Number(match[10] || 0),
	                    minuteOffset = Number(match[11] || 0),
	                    result;
	                if (
	                    hour < (
	                        minute > 0 || second > 0 || millisecond > 0 ?
	                        24 : 25
	                    ) &&
	                    minute < 60 && second < 60 && millisecond < 1000 &&
	                    month > -1 && month < 12 && hourOffset < 24 &&
	                    minuteOffset < 60 && // detect invalid offsets
	                    day > -1 &&
	                    day < (
	                        dayFromMonth(year, month + 1) -
	                        dayFromMonth(year, month)
	                    )
	                ) {
	                    result = (
	                        (dayFromMonth(year, month) + day) * 24 +
	                        hour +
	                        hourOffset * signOffset
	                    ) * 60;
	                    result = (
	                        (result + minute + minuteOffset * signOffset) * 60 +
	                        second
	                    ) * 1000 + millisecond;
	                    if (isLocalTime) {
	                        result = toUTC(result);
	                    }
	                    if (-8.64e15 <= result && result <= 8.64e15) {
	                        return result;
	                    }
	                }
	                return NaN;
	            }
	            return NativeDate.parse.apply(this, arguments);
	        };
	
	        return Date;
	    }(Date));
	    /*global Date: false */
	}
	
	// ES5 15.9.4.4
	// http://es5.github.com/#x15.9.4.4
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	
	
	//
	// Number
	// ======
	//
	
	// ES5.1 15.7.4.5
	// http://es5.github.com/#x15.7.4.5
	var hasToFixedBugs = NumberPrototype.toFixed && (
	  (0.00008).toFixed(3) !== '0.000' ||
	  (0.9).toFixed(0) !== '1' ||
	  (1.255).toFixed(2) !== '1.25' ||
	  (1000000000000000128).toFixed(0) !== '1000000000000000128'
	);
	
	var toFixedHelpers = {
	  base: 1e7,
	  size: 6,
	  data: [0, 0, 0, 0, 0, 0],
	  multiply: function multiply(n, c) {
	      var i = -1;
	      while (++i < toFixedHelpers.size) {
	          c += n * toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = c % toFixedHelpers.base;
	          c = Math.floor(c / toFixedHelpers.base);
	      }
	  },
	  divide: function divide(n) {
	      var i = toFixedHelpers.size, c = 0;
	      while (--i >= 0) {
	          c += toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = Math.floor(c / n);
	          c = (c % n) * toFixedHelpers.base;
	      }
	  },
	  numToString: function numToString() {
	      var i = toFixedHelpers.size;
	      var s = '';
	      while (--i >= 0) {
	          if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
	              var t = String(toFixedHelpers.data[i]);
	              if (s === '') {
	                  s = t;
	              } else {
	                  s += '0000000'.slice(0, 7 - t.length) + t;
	              }
	          }
	      }
	      return s;
	  },
	  pow: function pow(x, n, acc) {
	      return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
	  },
	  log: function log(x) {
	      var n = 0;
	      while (x >= 4096) {
	          n += 12;
	          x /= 4096;
	      }
	      while (x >= 2) {
	          n += 1;
	          x /= 2;
	      }
	      return n;
	  }
	};
	
	defineProperties(NumberPrototype, {
	    toFixed: function toFixed(fractionDigits) {
	        var f, x, s, m, e, z, j, k;
	
	        // Test for NaN and round fractionDigits down
	        f = Number(fractionDigits);
	        f = f !== f ? 0 : Math.floor(f);
	
	        if (f < 0 || f > 20) {
	            throw new RangeError('Number.toFixed called with invalid number of decimals');
	        }
	
	        x = Number(this);
	
	        // Test for NaN
	        if (x !== x) {
	            return 'NaN';
	        }
	
	        // If it is too big or small, return the string value of the number
	        if (x <= -1e21 || x >= 1e21) {
	            return String(x);
	        }
	
	        s = '';
	
	        if (x < 0) {
	            s = '-';
	            x = -x;
	        }
	
	        m = '0';
	
	        if (x > 1e-21) {
	            // 1e-21 < x < 1e21
	            // -70 < log2(x) < 70
	            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
	            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
	            z *= 0x10000000000000; // Math.pow(2, 52);
	            e = 52 - e;
	
	            // -18 < e < 122
	            // x = z / 2 ^ e
	            if (e > 0) {
	                toFixedHelpers.multiply(0, z);
	                j = f;
	
	                while (j >= 7) {
	                    toFixedHelpers.multiply(1e7, 0);
	                    j -= 7;
	                }
	
	                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
	                j = e - 1;
	
	                while (j >= 23) {
	                    toFixedHelpers.divide(1 << 23);
	                    j -= 23;
	                }
	
	                toFixedHelpers.divide(1 << j);
	                toFixedHelpers.multiply(1, 1);
	                toFixedHelpers.divide(2);
	                m = toFixedHelpers.numToString();
	            } else {
	                toFixedHelpers.multiply(0, z);
	                toFixedHelpers.multiply(1 << (-e), 0);
	                m = toFixedHelpers.numToString() + '0.00000000000000000000'.slice(2, 2 + f);
	            }
	        }
	
	        if (f > 0) {
	            k = m.length;
	
	            if (k <= f) {
	                m = s + '0.0000000000000000000'.slice(0, f - k + 2) + m;
	            } else {
	                m = s + m.slice(0, k - f) + '.' + m.slice(k - f);
	            }
	        } else {
	            m = s + m;
	        }
	
	        return m;
	    }
	}, hasToFixedBugs);
	
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	var string_split = StringPrototype.split;
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
	
	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (typeof separator === 'undefined' && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (to_string.call(separator) !== '[object RegExp]') {
	                return string_split.call(this, separator, limit);
	            }
	
	            var output = [],
	                flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline ? 'm' : '') +
	                        (separator.extended ? 'x' : '') + // Proposed for ES6
	                        (separator.sticky ? 'y' : ''), // Firefox 3+
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            separator = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // Math.pow(2, 32) - 1
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            limit = typeof limit === 'undefined' ?
	                -1 >>> 0 : // Math.pow(2, 32) - 1
	                ES.ToUint32(limit);
	            while (match = separator.exec(string)) {
	                // `separator.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    output.push(string.slice(lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (typeof arguments[i] === 'undefined') {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        array_push.apply(output, match.slice(1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= limit) {
	                        break;
	                    }
	                }
	                if (separator.lastIndex === match.index) {
	                    separator.lastIndex++; // Avoid an infinite loop
	                }
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separator.test('')) {
	                    output.push('');
	                }
	            } else {
	                output.push(string.slice(lastLastIndex));
	            }
	            return output.length > limit ? output.slice(0, limit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (typeof separator === 'undefined' && limit === 0) { return []; }
	        return string_split.call(this, separator, limit);
	    };
	}
	
	var str_replace = StringPrototype.replace;
	var replaceReportsGroupsCorrectly = (function () {
	    var groups = [];
	    'x'.replace(/x(.)?/g, function (match, group) {
	        groups.push(group);
	    });
	    return groups.length === 1 && typeof groups[0] === 'undefined';
	}());
	
	if (!replaceReportsGroupsCorrectly) {
	    StringPrototype.replace = function replace(searchValue, replaceValue) {
	        var isFn = isFunction(replaceValue);
	        var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
	        if (!isFn || !hasCapturingGroups) {
	            return str_replace.call(this, searchValue, replaceValue);
	        } else {
	            var wrappedReplaceValue = function (match) {
	                var length = arguments.length;
	                var originalLastIndex = searchValue.lastIndex;
	                searchValue.lastIndex = 0;
	                var args = searchValue.exec(match) || [];
	                searchValue.lastIndex = originalLastIndex;
	                args.push(arguments[length - 2], arguments[length - 1]);
	                return replaceValue.apply(this, args);
	            };
	            return str_replace.call(this, searchValue, wrappedReplaceValue);
	        }
	    };
	}
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        return string_substr.call(
	            this,
	            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
	            length
	        );
	    }
	}, hasNegativeSubstrBug);
	
	// ES5 15.5.4.20
	// whitespace from: http://es5.github.io/#x15.5.4.20
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	    '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var wsRegexChars = '[' + ws + ']';
	var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	defineProperties(StringPrototype, {
	    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	    // http://perfectionkills.com/whitespace-deviations/
	    trim: function trim() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	    }
	}, hasTrimWhitespaceBug);
	
	// ES-5 15.1.2.2
	if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
	    /*global parseInt: true */
	    parseInt = (function (origParseInt) {
	        var hexRegex = /^0[xX]/;
	        return function parseIntES5(str, radix) {
	            str = String(str).trim();
	            if (!Number(radix)) {
	                radix = hexRegex.test(str) ? 16 : 10;
	            }
	            return origParseInt(str, radix);
	        };
	    }(parseInt));
	}
	
	}));


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2014 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */
	
	// vim: ts=4 sts=4 sw=4 expandtab
	
	//Add semicolon to prevent IIFE from being passed as argument to concated code.
	;
	
	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/returnExports.js
	(function (root, factory) {
	    'use strict';
	    /*global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	  }
	}(this, function () {
	
	var call = Function.prototype.call;
	var prototypeOfObject = Object.prototype;
	var owns = call.bind(prototypeOfObject.hasOwnProperty);
	
	// If JS engine supports accessors creating shortcuts.
	var defineGetter;
	var defineSetter;
	var lookupGetter;
	var lookupSetter;
	var supportsAccessors = owns(prototypeOfObject, '__defineGetter__');
	if (supportsAccessors) {
	    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
	    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
	    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
	    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
	}
	
	// ES5 15.2.3.2
	// http://es5.github.com/#x15.2.3.2
	if (!Object.getPrototypeOf) {
	    // https://github.com/es-shims/es5-shim/issues#issue/2
	    // http://ejohn.org/blog/objectgetprototypeof/
	    // recommended by fschaefer on github
	    //
	    // sure, and webreflection says ^_^
	    // ... this will nerever possibly return null
	    // ... Opera Mini breaks here with infinite loops
	    Object.getPrototypeOf = function getPrototypeOf(object) {
	        var proto = object.__proto__;
	        if (proto || proto === null) {
	            return proto;
	        } else if (object.constructor) {
	            return object.constructor.prototype;
	        } else {
	            return prototypeOfObject;
	        }
	    };
	}
	
	//ES5 15.2.3.3
	//http://es5.github.com/#x15.2.3.3
	
	function doesGetOwnPropertyDescriptorWork(object) {
	    try {
	        object.sentinel = 0;
	        return Object.getOwnPropertyDescriptor(object, 'sentinel').value === 0;
	    } catch (exception) {
	        // returns falsy
	    }
	}
	
	//check whether getOwnPropertyDescriptor works if it's given. Otherwise,
	//shim partially.
	if (Object.defineProperty) {
	    var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
	    var getOwnPropertyDescriptorWorksOnDom = typeof document === 'undefined' ||
	    doesGetOwnPropertyDescriptorWork(document.createElement('div'));
	    if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
	        var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
	    }
	}
	
	if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
	    var ERR_NON_OBJECT = 'Object.getOwnPropertyDescriptor called on a non-object: ';
	
	    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
	        if ((typeof object !== 'object' && typeof object !== 'function') || object === null) {
	            throw new TypeError(ERR_NON_OBJECT + object);
	        }
	
	        // make a valiant attempt to use the real getOwnPropertyDescriptor
	        // for I8's DOM elements.
	        if (getOwnPropertyDescriptorFallback) {
	            try {
	                return getOwnPropertyDescriptorFallback.call(Object, object, property);
	            } catch (exception) {
	                // try the shim if the real one doesn't work
	            }
	        }
	
	        // If object does not owns property return undefined immediately.
	        if (!owns(object, property)) {
	            return;
	        }
	
	        // If object has a property then it's for sure both `enumerable` and
	        // `configurable`.
	        var descriptor = { enumerable: true, configurable: true };
	
	        // If JS engine supports accessor properties then property may be a
	        // getter or setter.
	        if (supportsAccessors) {
	            // Unfortunately `__lookupGetter__` will return a getter even
	            // if object has own non getter property along with a same named
	            // inherited getter. To avoid misbehavior we temporary remove
	            // `__proto__` so that `__lookupGetter__` will return getter only
	            // if it's owned by an object.
	            var prototype = object.__proto__;
	            var notPrototypeOfObject = object !== prototypeOfObject;
	            // avoid recursion problem, breaking in Opera Mini when
	            // Object.getOwnPropertyDescriptor(Object.prototype, 'toString')
	            // or any other Object.prototype accessor
	            if (notPrototypeOfObject) {
	                object.__proto__ = prototypeOfObject;
	            }
	
	            var getter = lookupGetter(object, property);
	            var setter = lookupSetter(object, property);
	
	            if (notPrototypeOfObject) {
	                // Once we have getter and setter we can put values back.
	                object.__proto__ = prototype;
	            }
	
	            if (getter || setter) {
	                if (getter) {
	                    descriptor.get = getter;
	                }
	                if (setter) {
	                    descriptor.set = setter;
	                }
	                // If it was accessor property we're done and return here
	                // in order to avoid adding `value` to the descriptor.
	                return descriptor;
	            }
	        }
	
	        // If we got this far we know that object has an own property that is
	        // not an accessor so we set it as a value and return descriptor.
	        descriptor.value = object[property];
	        descriptor.writable = true;
	        return descriptor;
	    };
	}
	
	// ES5 15.2.3.4
	// http://es5.github.com/#x15.2.3.4
	if (!Object.getOwnPropertyNames) {
	    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
	        return Object.keys(object);
	    };
	}
	
	// ES5 15.2.3.5
	// http://es5.github.com/#x15.2.3.5
	if (!Object.create) {
	
	    // Contributed by Brandon Benvie, October, 2012
	    var createEmpty;
	    var supportsProto = !({ __proto__: null } instanceof Object);
	                        // the following produces false positives
	                        // in Opera Mini => not a reliable check
	                        // Object.prototype.__proto__ === null
	    /*global document */
	    if (supportsProto || typeof document === 'undefined') {
	        createEmpty = function () {
	            return { __proto__: null };
	        };
	    } else {
	        // In old IE __proto__ can't be used to manually set `null`, nor does
	        // any other method exist to make an object that inherits from nothing,
	        // aside from Object.prototype itself. Instead, create a new global
	        // object and *steal* its Object.prototype and strip it bare. This is
	        // used as the prototype to create nullary objects.
	        createEmpty = function () {
	            var iframe = document.createElement('iframe');
	            var parent = document.body || document.documentElement;
	            iframe.style.display = 'none';
	            parent.appendChild(iframe);
	            iframe.src = 'javascript:';
	            var empty = iframe.contentWindow.Object.prototype;
	            parent.removeChild(iframe);
	            iframe = null;
	            delete empty.constructor;
	            delete empty.hasOwnProperty;
	            delete empty.propertyIsEnumerable;
	            delete empty.isPrototypeOf;
	            delete empty.toLocaleString;
	            delete empty.toString;
	            delete empty.valueOf;
	            empty.__proto__ = null;
	
	            function Empty() {}
	            Empty.prototype = empty;
	            // short-circuit future calls
	            createEmpty = function () {
	                return new Empty();
	            };
	            return new Empty();
	        };
	    }
	
	    Object.create = function create(prototype, properties) {
	
	        var object;
	        function Type() {}  // An empty constructor.
	
	        if (prototype === null) {
	            object = createEmpty();
	        } else {
	            if (typeof prototype !== 'object' && typeof prototype !== 'function') {
	                // In the native implementation `parent` can be `null`
	                // OR *any* `instanceof Object`  (Object|Function|Array|RegExp|etc)
	                // Use `typeof` tho, b/c in old IE, DOM elements are not `instanceof Object`
	                // like they are in modern browsers. Using `Object.create` on DOM elements
	                // is...err...probably inappropriate, but the native version allows for it.
	                throw new TypeError('Object prototype may only be an Object or null'); // same msg as Chrome
	            }
	            Type.prototype = prototype;
	            object = new Type();
	            // IE has no built-in implementation of `Object.getPrototypeOf`
	            // neither `__proto__`, but this manually setting `__proto__` will
	            // guarantee that `Object.getPrototypeOf` will work as expected with
	            // objects created using `Object.create`
	            object.__proto__ = prototype;
	        }
	
	        if (properties !== void 0) {
	            Object.defineProperties(object, properties);
	        }
	
	        return object;
	    };
	}
	
	// ES5 15.2.3.6
	// http://es5.github.com/#x15.2.3.6
	
	// Patch for WebKit and IE8 standard mode
	// Designed by hax <hax.github.com>
	// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
	// IE8 Reference:
	//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
	//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
	// WebKit Bugs:
	//     https://bugs.webkit.org/show_bug.cgi?id=36423
	
	function doesDefinePropertyWork(object) {
	    try {
	        Object.defineProperty(object, 'sentinel', {});
	        return 'sentinel' in object;
	    } catch (exception) {
	        // returns falsy
	    }
	}
	
	// check whether defineProperty works if it's given. Otherwise,
	// shim partially.
	if (Object.defineProperty) {
	    var definePropertyWorksOnObject = doesDefinePropertyWork({});
	    var definePropertyWorksOnDom = typeof document === 'undefined' ||
	        doesDefinePropertyWork(document.createElement('div'));
	    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
	        var definePropertyFallback = Object.defineProperty,
	            definePropertiesFallback = Object.defineProperties;
	    }
	}
	
	if (!Object.defineProperty || definePropertyFallback) {
	    var ERR_NON_OBJECT_DESCRIPTOR = 'Property description must be an object: ';
	    var ERR_NON_OBJECT_TARGET = 'Object.defineProperty called on non-object: ';
	    var ERR_ACCESSORS_NOT_SUPPORTED = 'getters & setters can not be defined on this javascript engine';
	
	    Object.defineProperty = function defineProperty(object, property, descriptor) {
	        if ((typeof object !== 'object' && typeof object !== 'function') || object === null) {
	            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
	        }
	        if ((typeof descriptor !== 'object' && typeof descriptor !== 'function') || descriptor === null) {
	            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
	        }
	        // make a valiant attempt to use the real defineProperty
	        // for I8's DOM elements.
	        if (definePropertyFallback) {
	            try {
	                return definePropertyFallback.call(Object, object, property, descriptor);
	            } catch (exception) {
	                // try the shim if the real one doesn't work
	            }
	        }
	
	        // If it's a data property.
	        if (owns(descriptor, 'value')) {
	            // fail silently if 'writable', 'enumerable', or 'configurable'
	            // are requested but not supported
	            /*
	            // alternate approach:
	            if ( // can't implement these features; allow false but not true
	                !(owns(descriptor, 'writable') ? descriptor.writable : true) ||
	                !(owns(descriptor, 'enumerable') ? descriptor.enumerable : true) ||
	                !(owns(descriptor, 'configurable') ? descriptor.configurable : true)
	            )
	                throw new RangeError(
	                    'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
	                );
	            */
	
	            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
	                // As accessors are supported only on engines implementing
	                // `__proto__` we can safely override `__proto__` while defining
	                // a property to make sure that we don't hit an inherited
	                // accessor.
	                var prototype = object.__proto__;
	                object.__proto__ = prototypeOfObject;
	                // Deleting a property anyway since getter / setter may be
	                // defined on object itself.
	                delete object[property];
	                object[property] = descriptor.value;
	                // Setting original `__proto__` back now.
	                object.__proto__ = prototype;
	            } else {
	                object[property] = descriptor.value;
	            }
	        } else {
	            if (!supportsAccessors) {
	                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
	            }
	            // If we got that far then getters and setters can be defined !!
	            if (owns(descriptor, 'get')) {
	                defineGetter(object, property, descriptor.get);
	            }
	            if (owns(descriptor, 'set')) {
	                defineSetter(object, property, descriptor.set);
	            }
	        }
	        return object;
	    };
	}
	
	// ES5 15.2.3.7
	// http://es5.github.com/#x15.2.3.7
	if (!Object.defineProperties || definePropertiesFallback) {
	    Object.defineProperties = function defineProperties(object, properties) {
	        // make a valiant attempt to use the real defineProperties
	        if (definePropertiesFallback) {
	            try {
	                return definePropertiesFallback.call(Object, object, properties);
	            } catch (exception) {
	                // try the shim if the real one doesn't work
	            }
	        }
	
	        for (var property in properties) {
	            if (owns(properties, property) && property !== '__proto__') {
	                Object.defineProperty(object, property, properties[property]);
	            }
	        }
	        return object;
	    };
	}
	
	// ES5 15.2.3.8
	// http://es5.github.com/#x15.2.3.8
	if (!Object.seal) {
	    Object.seal = function seal(object) {
	        // this is misleading and breaks feature-detection, but
	        // allows "securable" code to "gracefully" degrade to working
	        // but insecure code.
	        return object;
	    };
	}
	
	// ES5 15.2.3.9
	// http://es5.github.com/#x15.2.3.9
	if (!Object.freeze) {
	    Object.freeze = function freeze(object) {
	        // this is misleading and breaks feature-detection, but
	        // allows "securable" code to "gracefully" degrade to working
	        // but insecure code.
	        return object;
	    };
	}
	
	// detect a Rhino bug and patch it
	try {
	    Object.freeze(function () {});
	} catch (exception) {
	    Object.freeze = (function freeze(freezeObject) {
	        return function freeze(object) {
	            if (typeof object === 'function') {
	                return object;
	            } else {
	                return freezeObject(object);
	            }
	        };
	    }(Object.freeze));
	}
	
	// ES5 15.2.3.10
	// http://es5.github.com/#x15.2.3.10
	if (!Object.preventExtensions) {
	    Object.preventExtensions = function preventExtensions(object) {
	        // this is misleading and breaks feature-detection, but
	        // allows "securable" code to "gracefully" degrade to working
	        // but insecure code.
	        return object;
	    };
	}
	
	// ES5 15.2.3.11
	// http://es5.github.com/#x15.2.3.11
	if (!Object.isSealed) {
	    Object.isSealed = function isSealed(object) {
	        return false;
	    };
	}
	
	// ES5 15.2.3.12
	// http://es5.github.com/#x15.2.3.12
	if (!Object.isFrozen) {
	    Object.isFrozen = function isFrozen(object) {
	        return false;
	    };
	}
	
	// ES5 15.2.3.13
	// http://es5.github.com/#x15.2.3.13
	if (!Object.isExtensible) {
	    Object.isExtensible = function isExtensible(object) {
	        // 1. If Type(O) is not Object throw a TypeError exception.
	        if (Object(object) !== object) {
	            throw new TypeError(); // TODO message
	        }
	        // 2. Return the Boolean value of the [[Extensible]] internal property of O.
	        var name = '';
	        while (owns(object, name)) {
	            name += '?';
	        }
	        object[name] = true;
	        var returnValue = owns(object, name);
	        delete object[name];
	        return returnValue;
	    };
	}
	
	}));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(44))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = "/**\n* @preserve HTML5 Shiv 3.7.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed\n*/\n!function(a,b){function c(a,b){var c=a.createElement(\"p\"),d=a.getElementsByTagName(\"head\")[0]||a.documentElement;return c.innerHTML=\"x<style>\"+b+\"</style>\",d.insertBefore(c.lastChild,d.firstChild)}function d(){var a=t.elements;return\"string\"==typeof a?a.split(\" \"):a}function e(a,b){var c=t.elements;\"string\"!=typeof c&&(c=c.join(\" \")),\"string\"!=typeof a&&(a=a.join(\" \")),t.elements=c+\" \"+a,j(b)}function f(a){var b=s[a[q]];return b||(b={},r++,a[q]=r,s[r]=b),b}function g(a,c,d){if(c||(c=b),l)return c.createElement(a);d||(d=f(c));var e;return e=d.cache[a]?d.cache[a].cloneNode():p.test(a)?(d.cache[a]=d.createElem(a)).cloneNode():d.createElem(a),!e.canHaveChildren||o.test(a)||e.tagUrn?e:d.frag.appendChild(e)}function h(a,c){if(a||(a=b),l)return a.createDocumentFragment();c=c||f(a);for(var e=c.frag.cloneNode(),g=0,h=d(),i=h.length;i>g;g++)e.createElement(h[g]);return e}function i(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return t.shivMethods?g(c,a,b):b.createElem(c)},a.createDocumentFragment=Function(\"h,f\",\"return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(\"+d().join().replace(/[\\w\\-:]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c(\"'+a+'\")'})+\");return n}\")(t,b.frag)}function j(a){a||(a=b);var d=f(a);return!t.shivCSS||k||d.hasCSS||(d.hasCSS=!!c(a,\"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}\")),l||i(a,d),a}var k,l,m=\"3.7.2\",n=a.html5||{},o=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,p=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,q=\"_html5shiv\",r=0,s={};!function(){try{var a=b.createElement(\"a\");a.innerHTML=\"<xyz></xyz>\",k=\"hidden\"in a,l=1==a.childNodes.length||function(){b.createElement(\"a\");var a=b.createDocumentFragment();return\"undefined\"==typeof a.cloneNode||\"undefined\"==typeof a.createDocumentFragment||\"undefined\"==typeof a.createElement}()}catch(c){k=!0,l=!0}}();var t={elements:n.elements||\"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video\",version:m,shivCSS:n.shivCSS!==!1,supportsUnknownElements:l,shivMethods:n.shivMethods!==!1,type:\"default\",shivDocument:j,createElement:g,createDocumentFragment:h,addElements:e};a.html5=t,j(b)}(this,document);"

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(46))

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = "/*!\n * jsoneditor.js\n *\n * @brief\n * JSONEditor is a web-based tool to view, edit, and format JSON.\n * It shows data a clear, editable treeview.\n *\n * Supported browsers: Chrome, Firefox, Safari, Opera, Internet Explorer 8+\n *\n * @license\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy\n * of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n * Copyright (c) 2011-2015 Jos de Jong, http://jsoneditoronline.org\n *\n * @author  Jos de Jong, <wjosdejong@gmail.com>\n * @version 4.2.1\n * @date    2015-06-13\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JSONEditor\"] = factory();\n\telse\n\t\troot[\"JSONEditor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar treemode = __webpack_require__(1);\n\tvar textmode = __webpack_require__(2);\n\tvar util = __webpack_require__(3);\n\n\t/**\n\t * @constructor JSONEditor\n\t * @param {Element} container    Container element\n\t * @param {Object}  [options]    Object with options. available options:\n\t *                               {String} mode      Editor mode. Available values:\n\t *                                                  'tree' (default), 'view',\n\t *                                                  'form', 'text', and 'code'.\n\t *                               {function} change  Callback method, triggered\n\t *                                                  on change of contents\n\t *                               {Boolean} search   Enable search box.\n\t *                                                  True by default\n\t *                                                  Only applicable for modes\n\t *                                                  'tree', 'view', and 'form'\n\t *                               {Boolean} history  Enable history (undo/redo).\n\t *                                                  True by default\n\t *                                                  Only applicable for modes\n\t *                                                  'tree', 'view', and 'form'\n\t *                               {String} name      Field name for the root node.\n\t *                                                  Only applicable for modes\n\t *                                                  'tree', 'view', and 'form'\n\t *                               {Number} indentation   Number of indentation\n\t *                                                      spaces. 4 by default.\n\t *                                                      Only applicable for\n\t *                                                      modes 'text' and 'code'\n\t * @param {Object | undefined} json JSON object\n\t */\n\tfunction JSONEditor (container, options, json) {\n\t  if (!(this instanceof JSONEditor)) {\n\t    throw new Error('JSONEditor constructor called without \"new\".');\n\t  }\n\n\t  // check for unsupported browser (IE8 and older)\n\t  var ieVersion = util.getInternetExplorerVersion();\n\t  if (ieVersion != -1 && ieVersion < 9) {\n\t    throw new Error('Unsupported browser, IE9 or newer required. ' +\n\t        'Please install the newest version of your browser.');\n\t  }\n\n\t  if (arguments.length) {\n\t    this._create(container, options, json);\n\t  }\n\t}\n\n\t/**\n\t * Configuration for all registered modes. Example:\n\t * {\n\t *     tree: {\n\t *         mixin: TreeEditor,\n\t *         data: 'json'\n\t *     },\n\t *     text: {\n\t *         mixin: TextEditor,\n\t *         data: 'text'\n\t *     }\n\t * }\n\t *\n\t * @type { Object.<String, {mixin: Object, data: String} > }\n\t */\n\tJSONEditor.modes = {};\n\n\t/**\n\t * Create the JSONEditor\n\t * @param {Element} container    Container element\n\t * @param {Object}  [options]    See description in constructor\n\t * @param {Object | undefined} json JSON object\n\t * @private\n\t */\n\tJSONEditor.prototype._create = function (container, options, json) {\n\t  this.container = container;\n\t  this.options = options || {};\n\t  this.json = json || {};\n\n\t  var mode = this.options.mode || 'tree';\n\t  this.setMode(mode);\n\t};\n\n\t/**\n\t * Detach the editor from the DOM\n\t * @private\n\t */\n\tJSONEditor.prototype._delete = function () {};\n\n\t/**\n\t * Set JSON object in editor\n\t * @param {Object | undefined} json      JSON data\n\t */\n\tJSONEditor.prototype.set = function (json) {\n\t  this.json = json;\n\t};\n\n\t/**\n\t * Get JSON from the editor\n\t * @returns {Object} json\n\t */\n\tJSONEditor.prototype.get = function () {\n\t  return this.json;\n\t};\n\n\t/**\n\t * Set string containing JSON for the editor\n\t * @param {String | undefined} jsonText\n\t */\n\tJSONEditor.prototype.setText = function (jsonText) {\n\t  this.json = util.parse(jsonText);\n\t};\n\n\t/**\n\t * Get stringified JSON contents from the editor\n\t * @returns {String} jsonText\n\t */\n\tJSONEditor.prototype.getText = function () {\n\t  return JSON.stringify(this.json);\n\t};\n\n\t/**\n\t * Set a field name for the root node.\n\t * @param {String | undefined} name\n\t */\n\tJSONEditor.prototype.setName = function (name) {\n\t  if (!this.options) {\n\t    this.options = {};\n\t  }\n\t  this.options.name = name;\n\t};\n\n\t/**\n\t * Get the field name for the root node.\n\t * @return {String | undefined} name\n\t */\n\tJSONEditor.prototype.getName = function () {\n\t  return this.options && this.options.name;\n\t};\n\n\t/**\n\t * Change the mode of the editor.\n\t * JSONEditor will be extended with all methods needed for the chosen mode.\n\t * @param {String} mode     Available modes: 'tree' (default), 'view', 'form',\n\t *                          'text', and 'code'.\n\t */\n\tJSONEditor.prototype.setMode = function (mode) {\n\t  var container = this.container,\n\t      options = util.extend({}, this.options),\n\t      data,\n\t      name;\n\n\t  options.mode = mode;\n\t  var config = JSONEditor.modes[mode];\n\t  if (config) {\n\t    try {\n\t      var asText = (config.data == 'text');\n\t      name = this.getName();\n\t      data = this[asText ? 'getText' : 'get'](); // get text or json\n\n\t      this._delete();\n\t      util.clear(this);\n\t      util.extend(this, config.mixin);\n\t      this.create(container, options);\n\n\t      this.setName(name);\n\t      this[asText ? 'setText' : 'set'](data); // set text or json\n\n\t      if (typeof config.load === 'function') {\n\t        try {\n\t          config.load.call(this);\n\t        }\n\t        catch (err) {}\n\t      }\n\t    }\n\t    catch (err) {\n\t      this._onError(err);\n\t    }\n\t  }\n\t  else {\n\t    throw new Error('Unknown mode \"' + options.mode + '\"');\n\t  }\n\t};\n\n\t/**\n\t * Throw an error. If an error callback is configured in options.error, this\n\t * callback will be invoked. Else, a regular error is thrown.\n\t * @param {Error} err\n\t * @private\n\t */\n\tJSONEditor.prototype._onError = function(err) {\n\t  // TODO: onError is deprecated since version 2.2.0. cleanup some day\n\t  if (typeof this.onError === 'function') {\n\t    util.log('WARNING: JSONEditor.onError is deprecated. ' +\n\t        'Use options.error instead.');\n\t    this.onError(err);\n\t  }\n\n\t  if (this.options && typeof this.options.error === 'function') {\n\t    this.options.error(err);\n\t  }\n\t  else {\n\t    throw err;\n\t  }\n\t};\n\n\t/**\n\t * Register a plugin with one ore multiple modes for the JSON Editor.\n\t *\n\t * A mode is described as an object with properties:\n\t *\n\t * - `mode: String`           The name of the mode.\n\t * - `mixin: Object`          An object containing the mixin functions which\n\t *                            will be added to the JSONEditor. Must contain functions\n\t *                            create, get, getText, set, and setText. May have\n\t *                            additional functions.\n\t *                            When the JSONEditor switches to a mixin, all mixin\n\t *                            functions are added to the JSONEditor, and then\n\t *                            the function `create(container, options)` is executed.\n\t * - `data: 'text' | 'json'`  The type of data that will be used to load the mixin.\n\t * - `[load: function]`       An optional function called after the mixin\n\t *                            has been loaded.\n\t *\n\t * @param {Object | Array} mode  A mode object or an array with multiple mode objects.\n\t */\n\tJSONEditor.registerMode = function (mode) {\n\t  var i, prop;\n\n\t  if (util.isArray(mode)) {\n\t    // multiple modes\n\t    for (i = 0; i < mode.length; i++) {\n\t      JSONEditor.registerMode(mode[i]);\n\t    }\n\t  }\n\t  else {\n\t    // validate the new mode\n\t    if (!('mode' in mode)) throw new Error('Property \"mode\" missing');\n\t    if (!('mixin' in mode)) throw new Error('Property \"mixin\" missing');\n\t    if (!('data' in mode)) throw new Error('Property \"data\" missing');\n\t    var name = mode.mode;\n\t    if (name in JSONEditor.modes) {\n\t      throw new Error('Mode \"' + name + '\" already registered');\n\t    }\n\n\t    // validate the mixin\n\t    if (typeof mode.mixin.create !== 'function') {\n\t      throw new Error('Required function \"create\" missing on mixin');\n\t    }\n\t    var reserved = ['setMode', 'registerMode', 'modes'];\n\t    for (i = 0; i < reserved.length; i++) {\n\t      prop = reserved[i];\n\t      if (prop in mode.mixin) {\n\t        throw new Error('Reserved property \"' + prop + '\" not allowed in mixin');\n\t      }\n\t    }\n\n\t    JSONEditor.modes[name] = mode;\n\t  }\n\t};\n\n\t// register tree and text modes\n\tJSONEditor.registerMode(treemode);\n\tJSONEditor.registerMode(textmode);\n\n\tmodule.exports = JSONEditor;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Highlighter = __webpack_require__(4);\n\tvar History = __webpack_require__(5);\n\tvar SearchBox = __webpack_require__(6);\n\tvar Node = __webpack_require__(7);\n\tvar modeswitcher = __webpack_require__(8);\n\tvar util = __webpack_require__(3);\n\n\t// create a mixin with the functions for tree mode\n\tvar treemode = {};\n\n\t/**\n\t * Create a tree editor\n\t * @param {Element} container    Container element\n\t * @param {Object}  [options]    Object with options. available options:\n\t *                               {String} mode      Editor mode. Available values:\n\t *                                                  'tree' (default), 'view',\n\t *                                                  and 'form'.\n\t *                               {Boolean} search   Enable search box.\n\t *                                                  True by default\n\t *                               {Boolean} history  Enable history (undo/redo).\n\t *                                                  True by default\n\t *                               {function} change  Callback method, triggered\n\t *                                                  on change of contents\n\t *                               {String} name      Field name for the root node.\n\t * @private\n\t */\n\ttreemode.create = function (container, options) {\n\t  if (!container) {\n\t    throw new Error('No container element provided.');\n\t  }\n\t  this.container = container;\n\t  this.dom = {};\n\t  this.highlighter = new Highlighter();\n\t  this.selection = undefined; // will hold the last input selection\n\n\t  this._setOptions(options);\n\n\t  if (this.options.history && this.options.mode !== 'view') {\n\t    this.history = new History(this);\n\t  }\n\n\t  this._createFrame();\n\t  this._createTable();\n\t};\n\n\t/**\n\t * Detach the editor from the DOM\n\t * @private\n\t */\n\ttreemode._delete = function () {\n\t  if (this.frame && this.container && this.frame.parentNode == this.container) {\n\t    this.container.removeChild(this.frame);\n\t  }\n\t};\n\n\t/**\n\t * Initialize and set default options\n\t * @param {Object}  [options]    See description in constructor\n\t * @private\n\t */\n\ttreemode._setOptions = function (options) {\n\t  this.options = {\n\t    search: true,\n\t    history: true,\n\t    mode: 'tree',\n\t    name: undefined   // field name of root node\n\t  };\n\n\t  // copy all options\n\t  if (options) {\n\t    for (var prop in options) {\n\t      if (options.hasOwnProperty(prop)) {\n\t        this.options[prop] = options[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\n\t// node currently being edited\n\tvar focusNode = undefined;\n\n\t// dom having focus\n\tvar domFocus = null;\n\n\t/**\n\t * Set JSON object in editor\n\t * @param {Object | undefined} json      JSON data\n\t * @param {String}             [name]    Optional field name for the root node.\n\t *                                       Can also be set using setName(name).\n\t */\n\ttreemode.set = function (json, name) {\n\t  // adjust field name for root node\n\t  if (name) {\n\t    // TODO: deprecated since version 2.2.0. Cleanup some day.\n\t    util.log('Warning: second parameter \"name\" is deprecated. ' +\n\t        'Use setName(name) instead.');\n\t    this.options.name = name;\n\t  }\n\n\t  // verify if json is valid JSON, ignore when a function\n\t  if (json instanceof Function || (json === undefined)) {\n\t    this.clear();\n\t  }\n\t  else {\n\t    this.content.removeChild(this.table);  // Take the table offline\n\n\t    // replace the root node\n\t    var params = {\n\t      'field': this.options.name,\n\t      'value': json\n\t    };\n\t    var node = new Node(this, params);\n\t    this._setRoot(node);\n\n\t    // expand\n\t    var recurse = false;\n\t    this.node.expand(recurse);\n\n\t    this.content.appendChild(this.table);  // Put the table online again\n\t  }\n\n\t  // TODO: maintain history, store last state and previous document\n\t  if (this.history) {\n\t    this.history.clear();\n\t  }\n\t};\n\n\t/**\n\t * Get JSON object from editor\n\t * @return {Object | undefined} json\n\t */\n\ttreemode.get = function () {\n\t  // remove focus from currently edited node\n\t  if (focusNode) {\n\t    focusNode.blur();\n\t  }\n\n\t  if (this.node) {\n\t    return this.node.getValue();\n\t  }\n\t  else {\n\t    return undefined;\n\t  }\n\t};\n\n\t/**\n\t * Get the text contents of the editor\n\t * @return {String} jsonText\n\t */\n\ttreemode.getText = function() {\n\t  return JSON.stringify(this.get());\n\t};\n\n\t/**\n\t * Set the text contents of the editor\n\t * @param {String} jsonText\n\t */\n\ttreemode.setText = function(jsonText) {\n\t  this.set(util.parse(jsonText));\n\t};\n\n\t/**\n\t * Set a field name for the root node.\n\t * @param {String | undefined} name\n\t */\n\ttreemode.setName = function (name) {\n\t  this.options.name = name;\n\t  if (this.node) {\n\t    this.node.updateField(this.options.name);\n\t  }\n\t};\n\n\t/**\n\t * Get the field name for the root node.\n\t * @return {String | undefined} name\n\t */\n\ttreemode.getName = function () {\n\t  return this.options.name;\n\t};\n\n\t/**\n\t * Set focus to the editor. Focus will be set to:\n\t * - the first editable field or value, or else\n\t * - to the expand button of the root node, or else\n\t * - to the context menu button of the root node, or else\n\t * - to the first button in the top menu\n\t */\n\ttreemode.focus = function () {\n\t  var input = this.content.querySelector('[contenteditable=true]');\n\t  if (input) {\n\t    input.focus();\n\t  }\n\t  else if (this.node.dom.expand) {\n\t    this.node.dom.expand.focus();\n\t  }\n\t  else if (this.node.dom.menu) {\n\t    this.node.dom.menu.focus();\n\t  }\n\t  else {\n\t    // focus to the first button in the menu\n\t    input = this.frame.querySelector('button');\n\t    if (input) {\n\t      input.focus();\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Remove the root node from the editor\n\t */\n\ttreemode.clear = function () {\n\t  if (this.node) {\n\t    this.node.collapse();\n\t    this.tbody.removeChild(this.node.getDom());\n\t    delete this.node;\n\t  }\n\t};\n\n\t/**\n\t * Set the root node for the json editor\n\t * @param {Node} node\n\t * @private\n\t */\n\ttreemode._setRoot = function (node) {\n\t  this.clear();\n\n\t  this.node = node;\n\n\t  // append to the dom\n\t  this.tbody.appendChild(node.getDom());\n\t};\n\n\t/**\n\t * Search text in all nodes\n\t * The nodes will be expanded when the text is found one of its childs,\n\t * else it will be collapsed. Searches are case insensitive.\n\t * @param {String} text\n\t * @return {Object[]} results  Array with nodes containing the search results\n\t *                             The result objects contains fields:\n\t *                             - {Node} node,\n\t *                             - {String} elem  the dom element name where\n\t *                                              the result is found ('field' or\n\t *                                              'value')\n\t */\n\ttreemode.search = function (text) {\n\t  var results;\n\t  if (this.node) {\n\t    this.content.removeChild(this.table);  // Take the table offline\n\t    results = this.node.search(text);\n\t    this.content.appendChild(this.table);  // Put the table online again\n\t  }\n\t  else {\n\t    results = [];\n\t  }\n\n\t  return results;\n\t};\n\n\t/**\n\t * Expand all nodes\n\t */\n\ttreemode.expandAll = function () {\n\t  if (this.node) {\n\t    this.content.removeChild(this.table);  // Take the table offline\n\t    this.node.expand();\n\t    this.content.appendChild(this.table);  // Put the table online again\n\t  }\n\t};\n\n\t/**\n\t * Collapse all nodes\n\t */\n\ttreemode.collapseAll = function () {\n\t  if (this.node) {\n\t    this.content.removeChild(this.table);  // Take the table offline\n\t    this.node.collapse();\n\t    this.content.appendChild(this.table);  // Put the table online again\n\t  }\n\t};\n\n\t/**\n\t * The method onChange is called whenever a field or value is changed, created,\n\t * deleted, duplicated, etc.\n\t * @param {String} action  Change action. Available values: \"editField\",\n\t *                         \"editValue\", \"changeType\", \"appendNode\",\n\t *                         \"removeNode\", \"duplicateNode\", \"moveNode\", \"expand\",\n\t *                         \"collapse\".\n\t * @param {Object} params  Object containing parameters describing the change.\n\t *                         The parameters in params depend on the action (for\n\t *                         example for \"editValue\" the Node, old value, and new\n\t *                         value are provided). params contains all information\n\t *                         needed to undo or redo the action.\n\t * @private\n\t */\n\ttreemode._onAction = function (action, params) {\n\t  // add an action to the history\n\t  if (this.history) {\n\t    this.history.add(action, params);\n\t  }\n\n\t  // trigger the onChange callback\n\t  if (this.options.change) {\n\t    try {\n\t      this.options.change();\n\t    }\n\t    catch (err) {\n\t      util.log('Error in change callback: ', err);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Start autoscrolling when given mouse position is above the top of the\n\t * editor contents, or below the bottom.\n\t * @param {Number} mouseY  Absolute mouse position in pixels\n\t */\n\ttreemode.startAutoScroll = function (mouseY) {\n\t  var me = this;\n\t  var content = this.content;\n\t  var top = util.getAbsoluteTop(content);\n\t  var height = content.clientHeight;\n\t  var bottom = top + height;\n\t  var margin = 24;\n\t  var interval = 50; // ms\n\n\t  if ((mouseY < top + margin) && content.scrollTop > 0) {\n\t    this.autoScrollStep = ((top + margin) - mouseY) / 3;\n\t  }\n\t  else if (mouseY > bottom - margin &&\n\t      height + content.scrollTop < content.scrollHeight) {\n\t    this.autoScrollStep = ((bottom - margin) - mouseY) / 3;\n\t  }\n\t  else {\n\t    this.autoScrollStep = undefined;\n\t  }\n\n\t  if (this.autoScrollStep) {\n\t    if (!this.autoScrollTimer) {\n\t      this.autoScrollTimer = setInterval(function () {\n\t        if (me.autoScrollStep) {\n\t          content.scrollTop -= me.autoScrollStep;\n\t        }\n\t        else {\n\t          me.stopAutoScroll();\n\t        }\n\t      }, interval);\n\t    }\n\t  }\n\t  else {\n\t    this.stopAutoScroll();\n\t  }\n\t};\n\n\t/**\n\t * Stop auto scrolling. Only applicable when scrolling\n\t */\n\ttreemode.stopAutoScroll = function () {\n\t  if (this.autoScrollTimer) {\n\t    clearTimeout(this.autoScrollTimer);\n\t    delete this.autoScrollTimer;\n\t  }\n\t  if (this.autoScrollStep) {\n\t    delete this.autoScrollStep;\n\t  }\n\t};\n\n\n\t/**\n\t * Set the focus to an element in the editor, set text selection, and\n\t * set scroll position.\n\t * @param {Object} selection  An object containing fields:\n\t *                            {Element | undefined} dom     The dom element\n\t *                                                          which has focus\n\t *                            {Range | TextRange} range     A text selection\n\t *                            {Number} scrollTop            Scroll position\n\t */\n\ttreemode.setSelection = function (selection) {\n\t  if (!selection) {\n\t    return;\n\t  }\n\n\t  if ('scrollTop' in selection && this.content) {\n\t    // TODO: animated scroll\n\t    this.content.scrollTop = selection.scrollTop;\n\t  }\n\t  if (selection.range) {\n\t    util.setSelectionOffset(selection.range);\n\t  }\n\t  if (selection.dom) {\n\t    selection.dom.focus();\n\t  }\n\t};\n\n\t/**\n\t * Get the current focus\n\t * @return {Object} selection An object containing fields:\n\t *                            {Element | undefined} dom     The dom element\n\t *                                                          which has focus\n\t *                            {Range | TextRange} range     A text selection\n\t *                            {Number} scrollTop            Scroll position\n\t */\n\ttreemode.getSelection = function () {\n\t  return {\n\t    dom: domFocus,\n\t    scrollTop: this.content ? this.content.scrollTop : 0,\n\t    range: util.getSelectionOffset()\n\t  };\n\t};\n\n\t/**\n\t * Adjust the scroll position such that given top position is shown at 1/4\n\t * of the window height.\n\t * @param {Number} top\n\t * @param {function(boolean)} [callback]   Callback, executed when animation is\n\t *                                         finished. The callback returns true\n\t *                                         when animation is finished, or false\n\t *                                         when not.\n\t */\n\ttreemode.scrollTo = function (top, callback) {\n\t  var content = this.content;\n\t  if (content) {\n\t    var editor = this;\n\t    // cancel any running animation\n\t    if (editor.animateTimeout) {\n\t      clearTimeout(editor.animateTimeout);\n\t      delete editor.animateTimeout;\n\t    }\n\t    if (editor.animateCallback) {\n\t      editor.animateCallback(false);\n\t      delete editor.animateCallback;\n\t    }\n\n\t    // calculate final scroll position\n\t    var height = content.clientHeight;\n\t    var bottom = content.scrollHeight - height;\n\t    var finalScrollTop = Math.min(Math.max(top - height / 4, 0), bottom);\n\n\t    // animate towards the new scroll position\n\t    var animate = function () {\n\t      var scrollTop = content.scrollTop;\n\t      var diff = (finalScrollTop - scrollTop);\n\t      if (Math.abs(diff) > 3) {\n\t        content.scrollTop += diff / 3;\n\t        editor.animateCallback = callback;\n\t        editor.animateTimeout = setTimeout(animate, 50);\n\t      }\n\t      else {\n\t        // finished\n\t        if (callback) {\n\t          callback(true);\n\t        }\n\t        content.scrollTop = finalScrollTop;\n\t        delete editor.animateTimeout;\n\t        delete editor.animateCallback;\n\t      }\n\t    };\n\t    animate();\n\t  }\n\t  else {\n\t    if (callback) {\n\t      callback(false);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Create main frame\n\t * @private\n\t */\n\ttreemode._createFrame = function () {\n\t  // create the frame\n\t  this.frame = document.createElement('div');\n\t  this.frame.className = 'jsoneditor';\n\t  this.container.appendChild(this.frame);\n\n\t  // create one global event listener to handle all events from all nodes\n\t  var editor = this;\n\t  function onEvent(event) {\n\t    editor._onEvent(event);\n\t  }\n\t  this.frame.onclick = function (event) {\n\t    var target = event.target;// || event.srcElement;\n\n\t    onEvent(event);\n\n\t    // prevent default submit action of buttons when editor is located\n\t    // inside a form\n\t    if (target.nodeName == 'BUTTON') {\n\t      event.preventDefault();\n\t    }\n\t  };\n\t  this.frame.oninput = onEvent;\n\t  this.frame.onchange = onEvent;\n\t  this.frame.onkeydown = onEvent;\n\t  this.frame.onkeyup = onEvent;\n\t  this.frame.oncut = onEvent;\n\t  this.frame.onpaste = onEvent;\n\t  this.frame.onmousedown = onEvent;\n\t  this.frame.onmouseup = onEvent;\n\t  this.frame.onmouseover = onEvent;\n\t  this.frame.onmouseout = onEvent;\n\t  // Note: focus and blur events do not propagate, therefore they defined\n\t  // using an eventListener with useCapture=true\n\t  // see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\n\t  util.addEventListener(this.frame, 'focus', onEvent, true);\n\t  util.addEventListener(this.frame, 'blur', onEvent, true);\n\t  this.frame.onfocusin = onEvent;  // for IE\n\t  this.frame.onfocusout = onEvent; // for IE\n\n\t  // create menu\n\t  this.menu = document.createElement('div');\n\t  this.menu.className = 'menu';\n\t  this.frame.appendChild(this.menu);\n\n\t  // create expand all button\n\t  var expandAll = document.createElement('button');\n\t  expandAll.className = 'expand-all';\n\t  expandAll.title = 'Expand all fields';\n\t  expandAll.onclick = function () {\n\t    editor.expandAll();\n\t  };\n\t  this.menu.appendChild(expandAll);\n\n\t  // create expand all button\n\t  var collapseAll = document.createElement('button');\n\t  collapseAll.title = 'Collapse all fields';\n\t  collapseAll.className = 'collapse-all';\n\t  collapseAll.onclick = function () {\n\t    editor.collapseAll();\n\t  };\n\t  this.menu.appendChild(collapseAll);\n\n\t  // create undo/redo buttons\n\t  if (this.history) {\n\t    // create undo button\n\t    var undo = document.createElement('button');\n\t    undo.className = 'undo separator';\n\t    undo.title = 'Undo last action (Ctrl+Z)';\n\t    undo.onclick = function () {\n\t      editor._onUndo();\n\t    };\n\t    this.menu.appendChild(undo);\n\t    this.dom.undo = undo;\n\n\t    // create redo button\n\t    var redo = document.createElement('button');\n\t    redo.className = 'redo';\n\t    redo.title = 'Redo (Ctrl+Shift+Z)';\n\t    redo.onclick = function () {\n\t      editor._onRedo();\n\t    };\n\t    this.menu.appendChild(redo);\n\t    this.dom.redo = redo;\n\n\t    // register handler for onchange of history\n\t    this.history.onChange = function () {\n\t      undo.disabled = !editor.history.canUndo();\n\t      redo.disabled = !editor.history.canRedo();\n\t    };\n\t    this.history.onChange();\n\t  }\n\n\t  // create mode box\n\t  if (this.options && this.options.modes && this.options.modes.length) {\n\t    var modeBox = modeswitcher.create(this, this.options.modes, this.options.mode);\n\t    this.menu.appendChild(modeBox);\n\t    this.dom.modeBox = modeBox;\n\t  }\n\n\t  // create search box\n\t  if (this.options.search) {\n\t    this.searchBox = new SearchBox(this, this.menu);\n\t  }\n\t};\n\n\t/**\n\t * Perform an undo action\n\t * @private\n\t */\n\ttreemode._onUndo = function () {\n\t  if (this.history) {\n\t    // undo last action\n\t    this.history.undo();\n\n\t    // trigger change callback\n\t    if (this.options.change) {\n\t      this.options.change();\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Perform a redo action\n\t * @private\n\t */\n\ttreemode._onRedo = function () {\n\t  if (this.history) {\n\t    // redo last action\n\t    this.history.redo();\n\n\t    // trigger change callback\n\t    if (this.options.change) {\n\t      this.options.change();\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Event handler\n\t * @param event\n\t * @private\n\t */\n\ttreemode._onEvent = function (event) {\n\t  var target = event.target;\n\n\t  if (event.type == 'keydown') {\n\t    this._onKeyDown(event);\n\t  }\n\n\t  if (event.type == 'focus') {\n\t    domFocus = target;\n\t  }\n\n\t  var node = Node.getNodeFromTarget(target);\n\t  if (node) {\n\t    node.onEvent(event);\n\t  }\n\t};\n\n\t/**\n\t * Event handler for keydown. Handles shortcut keys\n\t * @param {Event} event\n\t * @private\n\t */\n\ttreemode._onKeyDown = function (event) {\n\t  var keynum = event.which || event.keyCode;\n\t  var ctrlKey = event.ctrlKey;\n\t  var shiftKey = event.shiftKey;\n\t  var handled = false;\n\n\t  if (keynum == 9) { // Tab or Shift+Tab\n\t    setTimeout(function () {\n\t      // select all text when moving focus to an editable div\n\t      util.selectContentEditable(domFocus);\n\t    }, 0);\n\t  }\n\n\t  if (this.searchBox) {\n\t    if (ctrlKey && keynum == 70) { // Ctrl+F\n\t      this.searchBox.dom.search.focus();\n\t      this.searchBox.dom.search.select();\n\t      handled = true;\n\t    }\n\t    else if (keynum == 114 || (ctrlKey && keynum == 71)) { // F3 or Ctrl+G\n\t      var focus = true;\n\t      if (!shiftKey) {\n\t        // select next search result (F3 or Ctrl+G)\n\t        this.searchBox.next(focus);\n\t      }\n\t      else {\n\t        // select previous search result (Shift+F3 or Ctrl+Shift+G)\n\t        this.searchBox.previous(focus);\n\t      }\n\n\t      handled = true;\n\t    }\n\t  }\n\n\t  if (this.history) {\n\t    if (ctrlKey && !shiftKey && keynum == 90) { // Ctrl+Z\n\t      // undo\n\t      this._onUndo();\n\t      handled = true;\n\t    }\n\t    else if (ctrlKey && shiftKey && keynum == 90) { // Ctrl+Shift+Z\n\t      // redo\n\t      this._onRedo();\n\t      handled = true;\n\t    }\n\t  }\n\n\t  if (handled) {\n\t    event.preventDefault();\n\t    event.stopPropagation();\n\t  }\n\t};\n\n\t/**\n\t * Create main table\n\t * @private\n\t */\n\ttreemode._createTable = function () {\n\t  var contentOuter = document.createElement('div');\n\t  contentOuter.className = 'outer';\n\t  this.contentOuter = contentOuter;\n\n\t  this.content = document.createElement('div');\n\t  this.content.className = 'tree';\n\t  contentOuter.appendChild(this.content);\n\n\t  this.table = document.createElement('table');\n\t  this.table.className = 'tree';\n\t  this.content.appendChild(this.table);\n\n\t  // create colgroup where the first two columns don't have a fixed\n\t  // width, and the edit columns do have a fixed width\n\t  var col;\n\t  this.colgroupContent = document.createElement('colgroup');\n\t  if (this.options.mode === 'tree') {\n\t    col = document.createElement('col');\n\t    col.width = \"24px\";\n\t    this.colgroupContent.appendChild(col);\n\t  }\n\t  col = document.createElement('col');\n\t  col.width = \"24px\";\n\t  this.colgroupContent.appendChild(col);\n\t  col = document.createElement('col');\n\t  this.colgroupContent.appendChild(col);\n\t  this.table.appendChild(this.colgroupContent);\n\n\t  this.tbody = document.createElement('tbody');\n\t  this.table.appendChild(this.tbody);\n\n\t  this.frame.appendChild(contentOuter);\n\t};\n\n\t// define modes\n\tmodule.exports = [\n\t  {\n\t    mode: 'tree',\n\t    mixin: treemode,\n\t    data: 'json'\n\t  },\n\t  {\n\t    mode: 'view',\n\t    mixin: treemode,\n\t    data: 'json'\n\t  },\n\t  {\n\t    mode: 'form',\n\t    mixin: treemode,\n\t    data: 'json'\n\t  }\n\t];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ace;\n\ttry {\n\t  ace = __webpack_require__(9);\n\t}\n\tcatch (err) {\n\t  // failed to load ace, no problem, we will fall back to plain text\n\t}\n\n\tvar modeswitcher = __webpack_require__(8);\n\tvar util = __webpack_require__(3);\n\n\t// create a mixin with the functions for text mode\n\tvar textmode = {};\n\n\t/**\n\t * Create a text editor\n\t * @param {Element} container\n\t * @param {Object} [options]         Object with options. available options:\n\t *                                   {String} mode         Available values:\n\t *                                                         \"text\" (default)\n\t *                                                         or \"code\".\n\t *                                   {Number} indentation  Number of indentation\n\t *                                                         spaces. 2 by default.\n\t *                                   {function} change     Callback method\n\t *                                                         triggered on change\n\t *                                   {Object} ace          A custom instance of\n\t *                                                         Ace editor.\n\t * @private\n\t */\n\ttextmode.create = function (container, options) {\n\t  // read options\n\t  options = options || {};\n\t  this.options = options;\n\n\t  // indentation\n\t  if (options.indentation) {\n\t    this.indentation = Number(options.indentation);\n\t  }\n\t  else {\n\t    this.indentation = 2; // number of spaces\n\t  }\n\n\t  // grab ace from options if provided\n\t  var _ace = options.ace ? options.ace : ace;\n\n\t  // determine mode\n\t  this.mode = (options.mode == 'code') ? 'code' : 'text';\n\t  if (this.mode == 'code') {\n\t    // verify whether Ace editor is available and supported\n\t    if (typeof _ace === 'undefined') {\n\t      this.mode = 'text';\n\t      util.log('WARNING: Cannot load code editor, Ace library not loaded. ' +\n\t          'Falling back to plain text editor');\n\t    }\n\t  }\n\n\t  // determine theme\n\t  this.theme = options.theme || 'ace/theme/jsoneditor';\n\n\t  var me = this;\n\t  this.container = container;\n\t  this.dom = {};\n\t  this.editor = undefined;    // ace code editor\n\t  this.textarea = undefined;  // plain text editor (fallback when Ace is not available)\n\n\t  this.width = container.clientWidth;\n\t  this.height = container.clientHeight;\n\n\t  this.frame = document.createElement('div');\n\t  this.frame.className = 'jsoneditor';\n\t  this.frame.onclick = function (event) {\n\t    // prevent default submit action when the editor is located inside a form\n\t    event.preventDefault();\n\t  };\n\t  this.frame.onkeydown = function (event) {\n\t    me._onKeyDown(event);\n\t  };\n\n\t  // create menu\n\t  this.menu = document.createElement('div');\n\t  this.menu.className = 'menu';\n\t  this.frame.appendChild(this.menu);\n\n\t  // create format button\n\t  var buttonFormat = document.createElement('button');\n\t  buttonFormat.className = 'format';\n\t  buttonFormat.title = 'Format JSON data, with proper indentation and line feeds (Ctrl+\\\\)';\n\t  this.menu.appendChild(buttonFormat);\n\t  buttonFormat.onclick = function () {\n\t    try {\n\t      me.format();\n\t    }\n\t    catch (err) {\n\t      me._onError(err);\n\t    }\n\t  };\n\n\t  // create compact button\n\t  var buttonCompact = document.createElement('button');\n\t  buttonCompact.className = 'compact';\n\t  buttonCompact.title = 'Compact JSON data, remove all whitespaces (Ctrl+Shift+\\\\)';\n\t  this.menu.appendChild(buttonCompact);\n\t  buttonCompact.onclick = function () {\n\t    try {\n\t      me.compact();\n\t    }\n\t    catch (err) {\n\t      me._onError(err);\n\t    }\n\t  };\n\n\t  // create mode box\n\t  if (this.options && this.options.modes && this.options.modes.length) {\n\t    var modeBox = modeswitcher.create(this, this.options.modes, this.options.mode);\n\t    this.menu.appendChild(modeBox);\n\t    this.dom.modeBox = modeBox;\n\t  }\n\n\t  this.content = document.createElement('div');\n\t  this.content.className = 'outer';\n\t  this.frame.appendChild(this.content);\n\n\t  this.container.appendChild(this.frame);\n\n\t  if (this.mode == 'code') {\n\t    this.editorDom = document.createElement('div');\n\t    this.editorDom.style.height = '100%'; // TODO: move to css\n\t    this.editorDom.style.width = '100%'; // TODO: move to css\n\t    this.content.appendChild(this.editorDom);\n\n\t    var editor = _ace.edit(this.editorDom);\n\t    editor.setTheme(this.theme);\n\t    editor.setShowPrintMargin(false);\n\t    editor.setFontSize(13);\n\t    editor.getSession().setMode('ace/mode/json');\n\t    editor.getSession().setTabSize(this.indentation);\n\t    editor.getSession().setUseSoftTabs(true);\n\t    editor.getSession().setUseWrapMode(true);\n\t    this.editor = editor;\n\n\t    var poweredBy = document.createElement('a');\n\t    poweredBy.appendChild(document.createTextNode('powered by ace'));\n\t    poweredBy.href = 'http://ace.ajax.org';\n\t    poweredBy.target = '_blank';\n\t    poweredBy.className = 'poweredBy';\n\t    poweredBy.onclick = function () {\n\t      // TODO: this anchor falls below the margin of the content,\n\t      // therefore the normal a.href does not work. We use a click event\n\t      // for now, but this should be fixed.\n\t      window.open(poweredBy.href, poweredBy.target);\n\t    };\n\t    this.menu.appendChild(poweredBy);\n\n\t    if (options.change) {\n\t      // register onchange event\n\t      editor.on('change', function () {\n\t        options.change();\n\t      });\n\t    }\n\t  }\n\t  else {\n\t    // load a plain text textarea\n\t    var textarea = document.createElement('textarea');\n\t    textarea.className = 'text';\n\t    textarea.spellcheck = false;\n\t    this.content.appendChild(textarea);\n\t    this.textarea = textarea;\n\n\t    if (options.change) {\n\t      // register onchange event\n\t      if (this.textarea.oninput === null) {\n\t        this.textarea.oninput = function () {\n\t          options.change();\n\t        }\n\t      }\n\t      else {\n\t        // oninput is undefined. For IE8-\n\t        this.textarea.onchange = function () {\n\t          options.change();\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Event handler for keydown. Handles shortcut keys\n\t * @param {Event} event\n\t * @private\n\t */\n\ttextmode._onKeyDown = function (event) {\n\t  var keynum = event.which || event.keyCode;\n\t  var handled = false;\n\n\t  if (keynum == 220 && event.ctrlKey) {\n\t    if (event.shiftKey) { // Ctrl+Shift+\\\n\t      this.compact();\n\t    }\n\t    else { // Ctrl+\\\n\t      this.format();\n\t    }\n\t    handled = true;\n\t  }\n\n\t  if (handled) {\n\t    event.preventDefault();\n\t    event.stopPropagation();\n\t  }\n\t};\n\n\t/**\n\t * Detach the editor from the DOM\n\t * @private\n\t */\n\ttextmode._delete = function () {\n\t  if (this.frame && this.container && this.frame.parentNode == this.container) {\n\t    this.container.removeChild(this.frame);\n\t  }\n\t};\n\n\t/**\n\t * Throw an error. If an error callback is configured in options.error, this\n\t * callback will be invoked. Else, a regular error is thrown.\n\t * @param {Error} err\n\t * @private\n\t */\n\ttextmode._onError = function(err) {\n\t  // TODO: onError is deprecated since version 2.2.0. cleanup some day\n\t  if (typeof this.onError === 'function') {\n\t    util.log('WARNING: JSONEditor.onError is deprecated. ' +\n\t        'Use options.error instead.');\n\t    this.onError(err);\n\t  }\n\n\t  if (this.options && typeof this.options.error === 'function') {\n\t    this.options.error(err);\n\t  }\n\t  else {\n\t    throw err;\n\t  }\n\t};\n\n\t/**\n\t * Compact the code in the formatter\n\t */\n\ttextmode.compact = function () {\n\t  var json = this.get();\n\t  var text = JSON.stringify(json);\n\t  this.setText(text);\n\t};\n\n\t/**\n\t * Format the code in the formatter\n\t */\n\ttextmode.format = function () {\n\t  var json = this.get();\n\t  var text = JSON.stringify(json, null, this.indentation);\n\t  this.setText(text);\n\t};\n\n\t/**\n\t * Set focus to the formatter\n\t */\n\ttextmode.focus = function () {\n\t  if (this.textarea) {\n\t    this.textarea.focus();\n\t  }\n\t  if (this.editor) {\n\t    this.editor.focus();\n\t  }\n\t};\n\n\t/**\n\t * Resize the formatter\n\t */\n\ttextmode.resize = function () {\n\t  if (this.editor) {\n\t    var force = false;\n\t    this.editor.resize(force);\n\t  }\n\t};\n\n\t/**\n\t * Set json data in the formatter\n\t * @param {Object} json\n\t */\n\ttextmode.set = function(json) {\n\t  this.setText(JSON.stringify(json, null, this.indentation));\n\t};\n\n\t/**\n\t * Get json data from the formatter\n\t * @return {Object} json\n\t */\n\ttextmode.get = function() {\n\t  var text = this.getText();\n\t  var json;\n\n\t  try {\n\t    json = util.parse(text); // this can throw an error\n\t  }\n\t  catch (err) {\n\t    // try to sanitize json, replace JavaScript notation with JSON notation\n\t    text = util.sanitize(text);\n\n\t    // try to parse again\n\t    json = util.parse(text); // this can throw an error\n\t  }\n\n\t  return json;\n\t};\n\n\t/**\n\t * Get the text contents of the editor\n\t * @return {String} jsonText\n\t */\n\ttextmode.getText = function() {\n\t  if (this.textarea) {\n\t    return this.textarea.value;\n\t  }\n\t  if (this.editor) {\n\t    return this.editor.getValue();\n\t  }\n\t  return '';\n\t};\n\n\t/**\n\t * Set the text contents of the editor\n\t * @param {String} jsonText\n\t */\n\ttextmode.setText = function(jsonText) {\n\t  if (this.textarea) {\n\t    this.textarea.value = jsonText;\n\t  }\n\t  if (this.editor) {\n\t    this.editor.setValue(jsonText, -1);\n\t  }\n\t};\n\n\t// define modes\n\tmodule.exports = [\n\t  {\n\t    mode: 'text',\n\t    mixin: textmode,\n\t    data: 'text',\n\t    load: textmode.format\n\t  },\n\t  {\n\t    mode: 'code',\n\t    mixin: textmode,\n\t    data: 'text',\n\t    load: textmode.format\n\t  }\n\t];\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jsonlint = __webpack_require__(12);\n\n\t/**\n\t * Parse JSON using the parser built-in in the browser.\n\t * On exception, the jsonString is validated and a detailed error is thrown.\n\t * @param {String} jsonString\n\t * @return {JSON} json\n\t */\n\texports.parse = function parse(jsonString) {\n\t  try {\n\t    return JSON.parse(jsonString);\n\t  }\n\t  catch (err) {\n\t    // try to throw a more detailed error message using validate\n\t    exports.validate(jsonString);\n\n\t    // rethrow the original error\n\t    throw err;\n\t  }\n\t};\n\n\t/**\n\t * Sanitize a JSON-like string containing. For example changes JavaScript\n\t * notation into JSON notation.\n\t * This function for example changes a string like \"{a: 2, 'b': {c: 'd'}\"\n\t * into '{\"a\": 2, \"b\": {\"c\": \"d\"}'\n\t * @param {string} jsString\n\t * @returns {string} json\n\t */\n\texports.sanitize = function (jsString) {\n\t  // escape all single and double quotes inside strings\n\t  var chars = [];\n\t  var i = 0;\n\n\t  //If JSON starts with a function (characters/digits/\"_-\"), remove this function.\n\t  //This is useful for \"stripping\" JSONP objects to become JSON\n\t  //For example: /* some comment */ function_12321321 ( [{\"a\":\"b\"}] ); => [{\"a\":\"b\"}]\n\t  var match = jsString.match(/^\\s*(\\/\\*(.|[\\r\\n])*?\\*\\/)?\\s*[\\da-zA-Z_$]+\\s*\\(([\\s\\S]*)\\)\\s*;?\\s*$/);\n\t  if (match) {\n\t    jsString = match[3];\n\t  }\n\n\t  // helper functions to get the current/prev/next character\n\t  function curr () { return jsString.charAt(i);     }\n\t  function next()  { return jsString.charAt(i + 1); }\n\t  function prev()  { return jsString.charAt(i - 1); }\n\n\t  // test whether the last non-whitespace character was a brace-open '{'\n\t  function prevIsBrace() {\n\t    var ii = i - 1;\n\t    while (ii >= 0) {\n\t      var cc = jsString.charAt(ii);\n\t      if (cc === '{') {\n\t        return true;\n\t      }\n\t      else if (cc === ' ' || cc === '\\n' || cc === '\\r') { // whitespace\n\t        ii--;\n\t      }\n\t      else {\n\t        return false;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\n\t  // skip a block comment '/* ... */'\n\t  function skipComment () {\n\t    i += 2;\n\t    while (i < jsString.length && (curr() !== '*' || next() !== '/')) {\n\t      i++;\n\t    }\n\t    i += 2;\n\t  }\n\n\t  // parse single or double quoted string\n\t  function parseString(quote) {\n\t    chars.push('\"');\n\t    i++;\n\t    var c = curr();\n\t    while (i < jsString.length && c !== quote) {\n\t      if (c === '\"' && prev() !== '\\\\') {\n\t        // unescaped double quote, escape it\n\t        chars.push('\\\\');\n\t      }\n\n\t      // handle escape character\n\t      if (c === '\\\\') {\n\t        i++;\n\t        c = curr();\n\n\t        // remove the escape character when followed by a single quote ', not needed\n\t        if (c !== '\\'') {\n\t          chars.push('\\\\');\n\t        }\n\t      }\n\t      chars.push(c);\n\n\t      i++;\n\t      c = curr();\n\t    }\n\t    if (c === quote) {\n\t      chars.push('\"');\n\t      i++;\n\t    }\n\t  }\n\n\t  // parse an unquoted key\n\t  function parseKey() {\n\t    var specialValues = ['null', 'true', 'false'];\n\t    var key = '';\n\t    var c = curr();\n\n\t    var regexp = /[a-zA-Z_$\\d]/; // letter, number, underscore, dollar character\n\t    while (regexp.test(c)) {\n\t      key += c;\n\t      i++;\n\t      c = curr();\n\t    }\n\n\t    if (specialValues.indexOf(key) === -1) {\n\t      chars.push('\"' + key + '\"');\n\t    }\n\t    else {\n\t      chars.push(key);\n\t    }\n\t  }\n\n\t  while(i < jsString.length) {\n\t    var c = curr();\n\n\t    if (c === '/' && next() === '*') {\n\t      skipComment();\n\t    }\n\t    else if (c === '\\'' || c === '\"') {\n\t      parseString(c);\n\t    }\n\t    else if (/[a-zA-Z_$]/.test(c) && prevIsBrace()) {\n\t      // an unquoted object key (like a in '{a:2}')\n\t      parseKey();\n\t    }\n\t    else {\n\t      chars.push(c);\n\t      i++;\n\t    }\n\t  }\n\n\t  return chars.join('');\n\t};\n\n\t/**\n\t * Validate a string containing a JSON object\n\t * This method uses JSONLint to validate the String. If JSONLint is not\n\t * available, the built-in JSON parser of the browser is used.\n\t * @param {String} jsonString   String with an (invalid) JSON object\n\t * @throws Error\n\t */\n\texports.validate = function validate(jsonString) {\n\t  if (typeof(jsonlint) != 'undefined') {\n\t    jsonlint.parse(jsonString);\n\t  }\n\t  else {\n\t    JSON.parse(jsonString);\n\t  }\n\t};\n\n\t/**\n\t * Extend object a with the properties of object b\n\t * @param {Object} a\n\t * @param {Object} b\n\t * @return {Object} a\n\t */\n\texports.extend = function extend(a, b) {\n\t  for (var prop in b) {\n\t    if (b.hasOwnProperty(prop)) {\n\t      a[prop] = b[prop];\n\t    }\n\t  }\n\t  return a;\n\t};\n\n\t/**\n\t * Remove all properties from object a\n\t * @param {Object} a\n\t * @return {Object} a\n\t */\n\texports.clear = function clear (a) {\n\t  for (var prop in a) {\n\t    if (a.hasOwnProperty(prop)) {\n\t      delete a[prop];\n\t    }\n\t  }\n\t  return a;\n\t};\n\n\t/**\n\t * Output text to the console, if console is available\n\t * @param {...*} args\n\t */\n\texports.log = function log (args) {\n\t  if (typeof console !== 'undefined' && typeof console.log === 'function') {\n\t    console.log.apply(console, arguments);\n\t  }\n\t};\n\n\t/**\n\t * Get the type of an object\n\t * @param {*} object\n\t * @return {String} type\n\t */\n\texports.type = function type (object) {\n\t  if (object === null) {\n\t    return 'null';\n\t  }\n\t  if (object === undefined) {\n\t    return 'undefined';\n\t  }\n\t  if ((object instanceof Number) || (typeof object === 'number')) {\n\t    return 'number';\n\t  }\n\t  if ((object instanceof String) || (typeof object === 'string')) {\n\t    return 'string';\n\t  }\n\t  if ((object instanceof Boolean) || (typeof object === 'boolean')) {\n\t    return 'boolean';\n\t  }\n\t  if ((object instanceof RegExp) || (typeof object === 'regexp')) {\n\t    return 'regexp';\n\t  }\n\t  if (exports.isArray(object)) {\n\t    return 'array';\n\t  }\n\n\t  return 'object';\n\t};\n\n\t/**\n\t * Test whether a text contains a url (matches when a string starts\n\t * with 'http://*' or 'https://*' and has no whitespace characters)\n\t * @param {String} text\n\t */\n\tvar isUrlRegex = /^https?:\\/\\/\\S+$/;\n\texports.isUrl = function isUrl (text) {\n\t  return (typeof text == 'string' || text instanceof String) &&\n\t      isUrlRegex.test(text);\n\t};\n\n\t/**\n\t * Tes whether given object is an Array\n\t * @param {*} obj\n\t * @returns {boolean} returns true when obj is an array\n\t */\n\texports.isArray = function (obj) {\n\t  return Object.prototype.toString.call(obj) === '[object Array]';\n\t};\n\n\t/**\n\t * Retrieve the absolute left value of a DOM element\n\t * @param {Element} elem    A dom element, for example a div\n\t * @return {Number} left    The absolute left position of this element\n\t *                          in the browser page.\n\t */\n\texports.getAbsoluteLeft = function getAbsoluteLeft(elem) {\n\t  var rect = elem.getBoundingClientRect();\n\t  return rect.left + window.pageXOffset || document.scrollLeft || 0;\n\t};\n\n\t/**\n\t * Retrieve the absolute top value of a DOM element\n\t * @param {Element} elem    A dom element, for example a div\n\t * @return {Number} top     The absolute top position of this element\n\t *                          in the browser page.\n\t */\n\texports.getAbsoluteTop = function getAbsoluteTop(elem) {\n\t  var rect = elem.getBoundingClientRect();\n\t  return rect.top + window.pageYOffset || document.scrollTop || 0;\n\t};\n\n\t/**\n\t * add a className to the given elements style\n\t * @param {Element} elem\n\t * @param {String} className\n\t */\n\texports.addClassName = function addClassName(elem, className) {\n\t  var classes = elem.className.split(' ');\n\t  if (classes.indexOf(className) == -1) {\n\t    classes.push(className); // add the class to the array\n\t    elem.className = classes.join(' ');\n\t  }\n\t};\n\n\t/**\n\t * add a className to the given elements style\n\t * @param {Element} elem\n\t * @param {String} className\n\t */\n\texports.removeClassName = function removeClassName(elem, className) {\n\t  var classes = elem.className.split(' ');\n\t  var index = classes.indexOf(className);\n\t  if (index != -1) {\n\t    classes.splice(index, 1); // remove the class from the array\n\t    elem.className = classes.join(' ');\n\t  }\n\t};\n\n\t/**\n\t * Strip the formatting from the contents of a div\n\t * the formatting from the div itself is not stripped, only from its childs.\n\t * @param {Element} divElement\n\t */\n\texports.stripFormatting = function stripFormatting(divElement) {\n\t  var childs = divElement.childNodes;\n\t  for (var i = 0, iMax = childs.length; i < iMax; i++) {\n\t    var child = childs[i];\n\n\t    // remove the style\n\t    if (child.style) {\n\t      // TODO: test if child.attributes does contain style\n\t      child.removeAttribute('style');\n\t    }\n\n\t    // remove all attributes\n\t    var attributes = child.attributes;\n\t    if (attributes) {\n\t      for (var j = attributes.length - 1; j >= 0; j--) {\n\t        var attribute = attributes[j];\n\t        if (attribute.specified === true) {\n\t          child.removeAttribute(attribute.name);\n\t        }\n\t      }\n\t    }\n\n\t    // recursively strip childs\n\t    exports.stripFormatting(child);\n\t  }\n\t};\n\n\t/**\n\t * Set focus to the end of an editable div\n\t * code from Nico Burns\n\t * http://stackoverflow.com/users/140293/nico-burns\n\t * http://stackoverflow.com/questions/1125292/how-to-move-cursor-to-end-of-contenteditable-entity\n\t * @param {Element} contentEditableElement   A content editable div\n\t */\n\texports.setEndOfContentEditable = function setEndOfContentEditable(contentEditableElement) {\n\t  var range, selection;\n\t  if(document.createRange) {\n\t    range = document.createRange();//Create a range (a range is a like the selection but invisible)\n\t    range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range\n\t    range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start\n\t    selection = window.getSelection();//get the selection object (allows you to change selection)\n\t    selection.removeAllRanges();//remove any selections already made\n\t    selection.addRange(range);//make the range you have just created the visible selection\n\t  }\n\t};\n\n\t/**\n\t * Select all text of a content editable div.\n\t * http://stackoverflow.com/a/3806004/1262753\n\t * @param {Element} contentEditableElement   A content editable div\n\t */\n\texports.selectContentEditable = function selectContentEditable(contentEditableElement) {\n\t  if (!contentEditableElement || contentEditableElement.nodeName != 'DIV') {\n\t    return;\n\t  }\n\n\t  var sel, range;\n\t  if (window.getSelection && document.createRange) {\n\t    range = document.createRange();\n\t    range.selectNodeContents(contentEditableElement);\n\t    sel = window.getSelection();\n\t    sel.removeAllRanges();\n\t    sel.addRange(range);\n\t  }\n\t};\n\n\t/**\n\t * Get text selection\n\t * http://stackoverflow.com/questions/4687808/contenteditable-selected-text-save-and-restore\n\t * @return {Range | TextRange | null} range\n\t */\n\texports.getSelection = function getSelection() {\n\t  if (window.getSelection) {\n\t    var sel = window.getSelection();\n\t    if (sel.getRangeAt && sel.rangeCount) {\n\t      return sel.getRangeAt(0);\n\t    }\n\t  }\n\t  return null;\n\t};\n\n\t/**\n\t * Set text selection\n\t * http://stackoverflow.com/questions/4687808/contenteditable-selected-text-save-and-restore\n\t * @param {Range | TextRange | null} range\n\t */\n\texports.setSelection = function setSelection(range) {\n\t  if (range) {\n\t    if (window.getSelection) {\n\t      var sel = window.getSelection();\n\t      sel.removeAllRanges();\n\t      sel.addRange(range);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Get selected text range\n\t * @return {Object} params  object containing parameters:\n\t *                              {Number}  startOffset\n\t *                              {Number}  endOffset\n\t *                              {Element} container  HTML element holding the\n\t *                                                   selected text element\n\t *                          Returns null if no text selection is found\n\t */\n\texports.getSelectionOffset = function getSelectionOffset() {\n\t  var range = exports.getSelection();\n\n\t  if (range && 'startOffset' in range && 'endOffset' in range &&\n\t      range.startContainer && (range.startContainer == range.endContainer)) {\n\t    return {\n\t      startOffset: range.startOffset,\n\t      endOffset: range.endOffset,\n\t      container: range.startContainer.parentNode\n\t    };\n\t  }\n\n\t  return null;\n\t};\n\n\t/**\n\t * Set selected text range in given element\n\t * @param {Object} params   An object containing:\n\t *                              {Element} container\n\t *                              {Number} startOffset\n\t *                              {Number} endOffset\n\t */\n\texports.setSelectionOffset = function setSelectionOffset(params) {\n\t  if (document.createRange && window.getSelection) {\n\t    var selection = window.getSelection();\n\t    if(selection) {\n\t      var range = document.createRange();\n\t      // TODO: do not suppose that the first child of the container is a textnode,\n\t      //       but recursively find the textnodes\n\t      range.setStart(params.container.firstChild, params.startOffset);\n\t      range.setEnd(params.container.firstChild, params.endOffset);\n\n\t      exports.setSelection(range);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Get the inner text of an HTML element (for example a div element)\n\t * @param {Element} element\n\t * @param {Object} [buffer]\n\t * @return {String} innerText\n\t */\n\texports.getInnerText = function getInnerText(element, buffer) {\n\t  var first = (buffer == undefined);\n\t  if (first) {\n\t    buffer = {\n\t      'text': '',\n\t      'flush': function () {\n\t        var text = this.text;\n\t        this.text = '';\n\t        return text;\n\t      },\n\t      'set': function (text) {\n\t        this.text = text;\n\t      }\n\t    };\n\t  }\n\n\t  // text node\n\t  if (element.nodeValue) {\n\t    return buffer.flush() + element.nodeValue;\n\t  }\n\n\t  // divs or other HTML elements\n\t  if (element.hasChildNodes()) {\n\t    var childNodes = element.childNodes;\n\t    var innerText = '';\n\n\t    for (var i = 0, iMax = childNodes.length; i < iMax; i++) {\n\t      var child = childNodes[i];\n\n\t      if (child.nodeName == 'DIV' || child.nodeName == 'P') {\n\t        var prevChild = childNodes[i - 1];\n\t        var prevName = prevChild ? prevChild.nodeName : undefined;\n\t        if (prevName && prevName != 'DIV' && prevName != 'P' && prevName != 'BR') {\n\t          innerText += '\\n';\n\t          buffer.flush();\n\t        }\n\t        innerText += exports.getInnerText(child, buffer);\n\t        buffer.set('\\n');\n\t      }\n\t      else if (child.nodeName == 'BR') {\n\t        innerText += buffer.flush();\n\t        buffer.set('\\n');\n\t      }\n\t      else {\n\t        innerText += exports.getInnerText(child, buffer);\n\t      }\n\t    }\n\n\t    return innerText;\n\t  }\n\t  else {\n\t    if (element.nodeName == 'P' && exports.getInternetExplorerVersion() != -1) {\n\t      // On Internet Explorer, a <p> with hasChildNodes()==false is\n\t      // rendered with a new line. Note that a <p> with\n\t      // hasChildNodes()==true is rendered without a new line\n\t      // Other browsers always ensure there is a <br> inside the <p>,\n\t      // and if not, the <p> does not render a new line\n\t      return buffer.flush();\n\t    }\n\t  }\n\n\t  // br or unknown\n\t  return '';\n\t};\n\n\t/**\n\t * Returns the version of Internet Explorer or a -1\n\t * (indicating the use of another browser).\n\t * Source: http://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx\n\t * @return {Number} Internet Explorer version, or -1 in case of an other browser\n\t */\n\texports.getInternetExplorerVersion = function getInternetExplorerVersion() {\n\t  if (_ieVersion == -1) {\n\t    var rv = -1; // Return value assumes failure.\n\t    if (navigator.appName == 'Microsoft Internet Explorer')\n\t    {\n\t      var ua = navigator.userAgent;\n\t      var re  = new RegExp(\"MSIE ([0-9]{1,}[\\.0-9]{0,})\");\n\t      if (re.exec(ua) != null) {\n\t        rv = parseFloat( RegExp.$1 );\n\t      }\n\t    }\n\n\t    _ieVersion = rv;\n\t  }\n\n\t  return _ieVersion;\n\t};\n\n\t/**\n\t * Test whether the current browser is Firefox\n\t * @returns {boolean} isFirefox\n\t */\n\texports.isFirefox = function isFirefox () {\n\t  return (navigator.userAgent.indexOf(\"Firefox\") != -1);\n\t};\n\n\t/**\n\t * cached internet explorer version\n\t * @type {Number}\n\t * @private\n\t */\n\tvar _ieVersion = -1;\n\n\t/**\n\t * Add and event listener. Works for all browsers\n\t * @param {Element}     element    An html element\n\t * @param {string}      action     The action, for example \"click\",\n\t *                                 without the prefix \"on\"\n\t * @param {function}    listener   The callback function to be executed\n\t * @param {boolean}     [useCapture] false by default\n\t * @return {function}   the created event listener\n\t */\n\texports.addEventListener = function addEventListener(element, action, listener, useCapture) {\n\t  if (element.addEventListener) {\n\t    if (useCapture === undefined)\n\t      useCapture = false;\n\n\t    if (action === \"mousewheel\" && exports.isFirefox()) {\n\t      action = \"DOMMouseScroll\";  // For Firefox\n\t    }\n\n\t    element.addEventListener(action, listener, useCapture);\n\t    return listener;\n\t  } else if (element.attachEvent) {\n\t    // Old IE browsers\n\t    var f = function () {\n\t      return listener.call(element, window.event);\n\t    };\n\t    element.attachEvent(\"on\" + action, f);\n\t    return f;\n\t  }\n\t};\n\n\t/**\n\t * Remove an event listener from an element\n\t * @param {Element}  element   An html dom element\n\t * @param {string}   action    The name of the event, for example \"mousedown\"\n\t * @param {function} listener  The listener function\n\t * @param {boolean}  [useCapture]   false by default\n\t */\n\texports.removeEventListener = function removeEventListener(element, action, listener, useCapture) {\n\t  if (element.removeEventListener) {\n\t    if (useCapture === undefined)\n\t      useCapture = false;\n\n\t    if (action === \"mousewheel\" && exports.isFirefox()) {\n\t      action = \"DOMMouseScroll\";  // For Firefox\n\t    }\n\n\t    element.removeEventListener(action, listener, useCapture);\n\t  } else if (element.detachEvent) {\n\t    // Old IE browsers\n\t    element.detachEvent(\"on\" + action, listener);\n\t  }\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * The highlighter can highlight/unhighlight a node, and\n\t * animate the visibility of a context menu.\n\t * @constructor Highlighter\n\t */\n\tfunction Highlighter () {\n\t  this.locked = false;\n\t}\n\n\t/**\n\t * Hightlight given node and its childs\n\t * @param {Node} node\n\t */\n\tHighlighter.prototype.highlight = function (node) {\n\t  if (this.locked) {\n\t    return;\n\t  }\n\n\t  if (this.node != node) {\n\t    // unhighlight current node\n\t    if (this.node) {\n\t      this.node.setHighlight(false);\n\t    }\n\n\t    // highlight new node\n\t    this.node = node;\n\t    this.node.setHighlight(true);\n\t  }\n\n\t  // cancel any current timeout\n\t  this._cancelUnhighlight();\n\t};\n\n\t/**\n\t * Unhighlight currently highlighted node.\n\t * Will be done after a delay\n\t */\n\tHighlighter.prototype.unhighlight = function () {\n\t  if (this.locked) {\n\t    return;\n\t  }\n\n\t  var me = this;\n\t  if (this.node) {\n\t    this._cancelUnhighlight();\n\n\t    // do the unhighlighting after a small delay, to prevent re-highlighting\n\t    // the same node when moving from the drag-icon to the contextmenu-icon\n\t    // or vice versa.\n\t    this.unhighlightTimer = setTimeout(function () {\n\t      me.node.setHighlight(false);\n\t      me.node = undefined;\n\t      me.unhighlightTimer = undefined;\n\t    }, 0);\n\t  }\n\t};\n\n\t/**\n\t * Cancel an unhighlight action (if before the timeout of the unhighlight action)\n\t * @private\n\t */\n\tHighlighter.prototype._cancelUnhighlight = function () {\n\t  if (this.unhighlightTimer) {\n\t    clearTimeout(this.unhighlightTimer);\n\t    this.unhighlightTimer = undefined;\n\t  }\n\t};\n\n\t/**\n\t * Lock highlighting or unhighlighting nodes.\n\t * methods highlight and unhighlight do not work while locked.\n\t */\n\tHighlighter.prototype.lock = function () {\n\t  this.locked = true;\n\t};\n\n\t/**\n\t * Unlock highlighting or unhighlighting nodes\n\t */\n\tHighlighter.prototype.unlock = function () {\n\t  this.locked = false;\n\t};\n\n\tmodule.exports = Highlighter;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(3);\n\n\t/**\n\t * @constructor History\n\t * Store action history, enables undo and redo\n\t * @param {JSONEditor} editor\n\t */\n\tfunction History (editor) {\n\t  this.editor = editor;\n\t  this.clear();\n\n\t  // map with all supported actions\n\t  this.actions = {\n\t    'editField': {\n\t      'undo': function (params) {\n\t        params.node.updateField(params.oldValue);\n\t      },\n\t      'redo': function (params) {\n\t        params.node.updateField(params.newValue);\n\t      }\n\t    },\n\t    'editValue': {\n\t      'undo': function (params) {\n\t        params.node.updateValue(params.oldValue);\n\t      },\n\t      'redo': function (params) {\n\t        params.node.updateValue(params.newValue);\n\t      }\n\t    },\n\t    'appendNode': {\n\t      'undo': function (params) {\n\t        params.parent.removeChild(params.node);\n\t      },\n\t      'redo': function (params) {\n\t        params.parent.appendChild(params.node);\n\t      }\n\t    },\n\t    'insertBeforeNode': {\n\t      'undo': function (params) {\n\t        params.parent.removeChild(params.node);\n\t      },\n\t      'redo': function (params) {\n\t        params.parent.insertBefore(params.node, params.beforeNode);\n\t      }\n\t    },\n\t    'insertAfterNode': {\n\t      'undo': function (params) {\n\t        params.parent.removeChild(params.node);\n\t      },\n\t      'redo': function (params) {\n\t        params.parent.insertAfter(params.node, params.afterNode);\n\t      }\n\t    },\n\t    'removeNode': {\n\t      'undo': function (params) {\n\t        var parent = params.parent;\n\t        var beforeNode = parent.childs[params.index] || parent.append;\n\t        parent.insertBefore(params.node, beforeNode);\n\t      },\n\t      'redo': function (params) {\n\t        params.parent.removeChild(params.node);\n\t      }\n\t    },\n\t    'duplicateNode': {\n\t      'undo': function (params) {\n\t        params.parent.removeChild(params.clone);\n\t      },\n\t      'redo': function (params) {\n\t        params.parent.insertAfter(params.clone, params.node);\n\t      }\n\t    },\n\t    'changeType': {\n\t      'undo': function (params) {\n\t        params.node.changeType(params.oldType);\n\t      },\n\t      'redo': function (params) {\n\t        params.node.changeType(params.newType);\n\t      }\n\t    },\n\t    'moveNode': {\n\t      'undo': function (params) {\n\t        params.startParent.moveTo(params.node, params.startIndex);\n\t      },\n\t      'redo': function (params) {\n\t        params.endParent.moveTo(params.node, params.endIndex);\n\t      }\n\t    },\n\t    'sort': {\n\t      'undo': function (params) {\n\t        var node = params.node;\n\t        node.hideChilds();\n\t        node.sort = params.oldSort;\n\t        node.childs = params.oldChilds;\n\t        node.showChilds();\n\t      },\n\t      'redo': function (params) {\n\t        var node = params.node;\n\t        node.hideChilds();\n\t        node.sort = params.newSort;\n\t        node.childs = params.newChilds;\n\t        node.showChilds();\n\t      }\n\t    }\n\n\t    // TODO: restore the original caret position and selection with each undo\n\t    // TODO: implement history for actions \"expand\", \"collapse\", \"scroll\", \"setDocument\"\n\t  };\n\t}\n\n\t/**\n\t * The method onChange is executed when the History is changed, and can\n\t * be overloaded.\n\t */\n\tHistory.prototype.onChange = function () {};\n\n\t/**\n\t * Add a new action to the history\n\t * @param {String} action  The executed action. Available actions: \"editField\",\n\t *                         \"editValue\", \"changeType\", \"appendNode\",\n\t *                         \"removeNode\", \"duplicateNode\", \"moveNode\"\n\t * @param {Object} params  Object containing parameters describing the change.\n\t *                         The parameters in params depend on the action (for\n\t *                         example for \"editValue\" the Node, old value, and new\n\t *                         value are provided). params contains all information\n\t *                         needed to undo or redo the action.\n\t */\n\tHistory.prototype.add = function (action, params) {\n\t  this.index++;\n\t  this.history[this.index] = {\n\t    'action': action,\n\t    'params': params,\n\t    'timestamp': new Date()\n\t  };\n\n\t  // remove redo actions which are invalid now\n\t  if (this.index < this.history.length - 1) {\n\t    this.history.splice(this.index + 1, this.history.length - this.index - 1);\n\t  }\n\n\t  // fire onchange event\n\t  this.onChange();\n\t};\n\n\t/**\n\t * Clear history\n\t */\n\tHistory.prototype.clear = function () {\n\t  this.history = [];\n\t  this.index = -1;\n\n\t  // fire onchange event\n\t  this.onChange();\n\t};\n\n\t/**\n\t * Check if there is an action available for undo\n\t * @return {Boolean} canUndo\n\t */\n\tHistory.prototype.canUndo = function () {\n\t  return (this.index >= 0);\n\t};\n\n\t/**\n\t * Check if there is an action available for redo\n\t * @return {Boolean} canRedo\n\t */\n\tHistory.prototype.canRedo = function () {\n\t  return (this.index < this.history.length - 1);\n\t};\n\n\t/**\n\t * Undo the last action\n\t */\n\tHistory.prototype.undo = function () {\n\t  if (this.canUndo()) {\n\t    var obj = this.history[this.index];\n\t    if (obj) {\n\t      var action = this.actions[obj.action];\n\t      if (action && action.undo) {\n\t        action.undo(obj.params);\n\t        if (obj.params.oldSelection) {\n\t          this.editor.setSelection(obj.params.oldSelection);\n\t        }\n\t      }\n\t      else {\n\t        util.log('Error: unknown action \"' + obj.action + '\"');\n\t      }\n\t    }\n\t    this.index--;\n\n\t    // fire onchange event\n\t    this.onChange();\n\t  }\n\t};\n\n\t/**\n\t * Redo the last action\n\t */\n\tHistory.prototype.redo = function () {\n\t  if (this.canRedo()) {\n\t    this.index++;\n\n\t    var obj = this.history[this.index];\n\t    if (obj) {\n\t      var action = this.actions[obj.action];\n\t      if (action && action.redo) {\n\t        action.redo(obj.params);\n\t        if (obj.params.newSelection) {\n\t          this.editor.setSelection(obj.params.newSelection);\n\t        }\n\t      }\n\t      else {\n\t        util.log('Error: unknown action \"' + obj.action + '\"');\n\t      }\n\t    }\n\n\t    // fire onchange event\n\t    this.onChange();\n\t  }\n\t};\n\n\tmodule.exports = History;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @constructor SearchBox\n\t * Create a search box in given HTML container\n\t * @param {JSONEditor} editor    The JSON Editor to attach to\n\t * @param {Element} container               HTML container element of where to\n\t *                                          create the search box\n\t */\n\tfunction SearchBox (editor, container) {\n\t  var searchBox = this;\n\n\t  this.editor = editor;\n\t  this.timeout = undefined;\n\t  this.delay = 200; // ms\n\t  this.lastText = undefined;\n\n\t  this.dom = {};\n\t  this.dom.container = container;\n\n\t  var table = document.createElement('table');\n\t  this.dom.table = table;\n\t  table.className = 'search';\n\t  container.appendChild(table);\n\t  var tbody = document.createElement('tbody');\n\t  this.dom.tbody = tbody;\n\t  table.appendChild(tbody);\n\t  var tr = document.createElement('tr');\n\t  tbody.appendChild(tr);\n\n\t  var td = document.createElement('td');\n\t  tr.appendChild(td);\n\t  var results = document.createElement('div');\n\t  this.dom.results = results;\n\t  results.className = 'results';\n\t  td.appendChild(results);\n\n\t  td = document.createElement('td');\n\t  tr.appendChild(td);\n\t  var divInput = document.createElement('div');\n\t  this.dom.input = divInput;\n\t  divInput.className = 'frame';\n\t  divInput.title = 'Search fields and values';\n\t  td.appendChild(divInput);\n\n\t  // table to contain the text input and search button\n\t  var tableInput = document.createElement('table');\n\t  divInput.appendChild(tableInput);\n\t  var tbodySearch = document.createElement('tbody');\n\t  tableInput.appendChild(tbodySearch);\n\t  tr = document.createElement('tr');\n\t  tbodySearch.appendChild(tr);\n\n\t  var refreshSearch = document.createElement('button');\n\t  refreshSearch.className = 'refresh';\n\t  td = document.createElement('td');\n\t  td.appendChild(refreshSearch);\n\t  tr.appendChild(td);\n\n\t  var search = document.createElement('input');\n\t  this.dom.search = search;\n\t  search.oninput = function (event) {\n\t    searchBox._onDelayedSearch(event);\n\t  };\n\t  search.onchange = function (event) { // For IE 9\n\t    searchBox._onSearch(event);\n\t  };\n\t  search.onkeydown = function (event) {\n\t    searchBox._onKeyDown(event);\n\t  };\n\t  search.onkeyup = function (event) {\n\t    searchBox._onKeyUp(event);\n\t  };\n\t  refreshSearch.onclick = function (event) {\n\t    search.select();\n\t  };\n\n\t  // TODO: ESC in FF restores the last input, is a FF bug, https://bugzilla.mozilla.org/show_bug.cgi?id=598819\n\t  td = document.createElement('td');\n\t  td.appendChild(search);\n\t  tr.appendChild(td);\n\n\t  var searchNext = document.createElement('button');\n\t  searchNext.title = 'Next result (Enter)';\n\t  searchNext.className = 'next';\n\t  searchNext.onclick = function () {\n\t    searchBox.next();\n\t  };\n\t  td = document.createElement('td');\n\t  td.appendChild(searchNext);\n\t  tr.appendChild(td);\n\n\t  var searchPrevious = document.createElement('button');\n\t  searchPrevious.title = 'Previous result (Shift+Enter)';\n\t  searchPrevious.className = 'previous';\n\t  searchPrevious.onclick = function () {\n\t    searchBox.previous();\n\t  };\n\t  td = document.createElement('td');\n\t  td.appendChild(searchPrevious);\n\t  tr.appendChild(td);\n\t}\n\n\t/**\n\t * Go to the next search result\n\t * @param {boolean} [focus]   If true, focus will be set to the next result\n\t *                            focus is false by default.\n\t */\n\tSearchBox.prototype.next = function(focus) {\n\t  if (this.results != undefined) {\n\t    var index = (this.resultIndex != undefined) ? this.resultIndex + 1 : 0;\n\t    if (index > this.results.length - 1) {\n\t      index = 0;\n\t    }\n\t    this._setActiveResult(index, focus);\n\t  }\n\t};\n\n\t/**\n\t * Go to the prevous search result\n\t * @param {boolean} [focus]   If true, focus will be set to the next result\n\t *                            focus is false by default.\n\t */\n\tSearchBox.prototype.previous = function(focus) {\n\t  if (this.results != undefined) {\n\t    var max = this.results.length - 1;\n\t    var index = (this.resultIndex != undefined) ? this.resultIndex - 1 : max;\n\t    if (index < 0) {\n\t      index = max;\n\t    }\n\t    this._setActiveResult(index, focus);\n\t  }\n\t};\n\n\t/**\n\t * Set new value for the current active result\n\t * @param {Number} index\n\t * @param {boolean} [focus]   If true, focus will be set to the next result.\n\t *                            focus is false by default.\n\t * @private\n\t */\n\tSearchBox.prototype._setActiveResult = function(index, focus) {\n\t  // de-activate current active result\n\t  if (this.activeResult) {\n\t    var prevNode = this.activeResult.node;\n\t    var prevElem = this.activeResult.elem;\n\t    if (prevElem == 'field') {\n\t      delete prevNode.searchFieldActive;\n\t    }\n\t    else {\n\t      delete prevNode.searchValueActive;\n\t    }\n\t    prevNode.updateDom();\n\t  }\n\n\t  if (!this.results || !this.results[index]) {\n\t    // out of range, set to undefined\n\t    this.resultIndex = undefined;\n\t    this.activeResult = undefined;\n\t    return;\n\t  }\n\n\t  this.resultIndex = index;\n\n\t  // set new node active\n\t  var node = this.results[this.resultIndex].node;\n\t  var elem = this.results[this.resultIndex].elem;\n\t  if (elem == 'field') {\n\t    node.searchFieldActive = true;\n\t  }\n\t  else {\n\t    node.searchValueActive = true;\n\t  }\n\t  this.activeResult = this.results[this.resultIndex];\n\t  node.updateDom();\n\n\t  // TODO: not so nice that the focus is only set after the animation is finished\n\t  node.scrollTo(function () {\n\t    if (focus) {\n\t      node.focus(elem);\n\t    }\n\t  });\n\t};\n\n\t/**\n\t * Cancel any running onDelayedSearch.\n\t * @private\n\t */\n\tSearchBox.prototype._clearDelay = function() {\n\t  if (this.timeout != undefined) {\n\t    clearTimeout(this.timeout);\n\t    delete this.timeout;\n\t  }\n\t};\n\n\t/**\n\t * Start a timer to execute a search after a short delay.\n\t * Used for reducing the number of searches while typing.\n\t * @param {Event} event\n\t * @private\n\t */\n\tSearchBox.prototype._onDelayedSearch = function (event) {\n\t  // execute the search after a short delay (reduces the number of\n\t  // search actions while typing in the search text box)\n\t  this._clearDelay();\n\t  var searchBox = this;\n\t  this.timeout = setTimeout(function (event) {\n\t        searchBox._onSearch(event);\n\t      },\n\t      this.delay);\n\t};\n\n\t/**\n\t * Handle onSearch event\n\t * @param {Event} event\n\t * @param {boolean} [forceSearch]  If true, search will be executed again even\n\t *                                 when the search text is not changed.\n\t *                                 Default is false.\n\t * @private\n\t */\n\tSearchBox.prototype._onSearch = function (event, forceSearch) {\n\t  this._clearDelay();\n\n\t  var value = this.dom.search.value;\n\t  var text = (value.length > 0) ? value : undefined;\n\t  if (text != this.lastText || forceSearch) {\n\t    // only search again when changed\n\t    this.lastText = text;\n\t    this.results = this.editor.search(text);\n\t    this._setActiveResult(undefined);\n\n\t    // display search results\n\t    if (text != undefined) {\n\t      var resultCount = this.results.length;\n\t      switch (resultCount) {\n\t        case 0: this.dom.results.innerHTML = 'no&nbsp;results'; break;\n\t        case 1: this.dom.results.innerHTML = '1&nbsp;result'; break;\n\t        default: this.dom.results.innerHTML = resultCount + '&nbsp;results'; break;\n\t      }\n\t    }\n\t    else {\n\t      this.dom.results.innerHTML = '';\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Handle onKeyDown event in the input box\n\t * @param {Event} event\n\t * @private\n\t */\n\tSearchBox.prototype._onKeyDown = function (event) {\n\t  var keynum = event.which;\n\t  if (keynum == 27) { // ESC\n\t    this.dom.search.value = '';  // clear search\n\t    this._onSearch(event);\n\t    event.preventDefault();\n\t    event.stopPropagation();\n\t  }\n\t  else if (keynum == 13) { // Enter\n\t    if (event.ctrlKey) {\n\t      // force to search again\n\t      this._onSearch(event, true);\n\t    }\n\t    else if (event.shiftKey) {\n\t      // move to the previous search result\n\t      this.previous();\n\t    }\n\t    else {\n\t      // move to the next search result\n\t      this.next();\n\t    }\n\t    event.preventDefault();\n\t    event.stopPropagation();\n\t  }\n\t};\n\n\t/**\n\t * Handle onKeyUp event in the input box\n\t * @param {Event} event\n\t * @private\n\t */\n\tSearchBox.prototype._onKeyUp = function (event) {\n\t  var keynum = event.keyCode;\n\t  if (keynum != 27 && keynum != 13) { // !show and !Enter\n\t    this._onDelayedSearch(event);   // For IE 9\n\t  }\n\t};\n\n\tmodule.exports = SearchBox;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ContextMenu = __webpack_require__(10);\n\tvar appendNodeFactory = __webpack_require__(11);\n\tvar util = __webpack_require__(3);\n\n\t/**\n\t * @constructor Node\n\t * Create a new Node\n\t * @param {TreeEditor} editor\n\t * @param {Object} [params] Can contain parameters:\n\t *                          {string}  field\n\t *                          {boolean} fieldEditable\n\t *                          {*}       value\n\t *                          {String}  type  Can have values 'auto', 'array',\n\t *                                          'object', or 'string'.\n\t */\n\tfunction Node (editor, params) {\n\t  /** @type {TreeEditor} */\n\t  this.editor = editor;\n\t  this.dom = {};\n\t  this.expanded = false;\n\n\t  if(params && (params instanceof Object)) {\n\t    this.setField(params.field, params.fieldEditable);\n\t    this.setValue(params.value, params.type);\n\t  }\n\t  else {\n\t    this.setField('');\n\t    this.setValue(null);\n\t  }\n\t}\n\n\t/**\n\t * Determine whether the field and/or value of this node are editable\n\t * @private\n\t */\n\tNode.prototype._updateEditability = function () {\n\t  this.editable = {\n\t    field: true,\n\t    value: true\n\t  };\n\n\t  if (this.editor) {\n\t    this.editable.field = this.editor.options.mode === 'tree';\n\t    this.editable.value = this.editor.options.mode !== 'view';\n\n\t    if (this.editor.options.mode === 'tree' && (typeof this.editor.options.editable === 'function')) {\n\t      var editable = this.editor.options.editable({\n\t        field: this.field,\n\t        value: this.value,\n\t        path: this.path()\n\t      });\n\n\t      if (typeof editable === 'boolean') {\n\t        this.editable.field = editable;\n\t        this.editable.value = editable;\n\t      }\n\t      else {\n\t        if (typeof editable.field === 'boolean') this.editable.field = editable.field;\n\t        if (typeof editable.value === 'boolean') this.editable.value = editable.value;\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Get the path of this node\n\t * @return {String[]} Array containing the path to this node\n\t */\n\tNode.prototype.path = function () {\n\t  var node = this;\n\t  var path = [];\n\t  while (node) {\n\t    var field = node.field != undefined ? node.field : node.index;\n\t    if (field !== undefined) {\n\t      path.unshift(field);\n\t    }\n\t    node = node.parent;\n\t  }\n\t  return path;\n\t};\n\n\t/**\n\t * Set parent node\n\t * @param {Node} parent\n\t */\n\tNode.prototype.setParent = function(parent) {\n\t  this.parent = parent;\n\t};\n\n\t/**\n\t * Set field\n\t * @param {String}  field\n\t * @param {boolean} [fieldEditable]\n\t */\n\tNode.prototype.setField = function(field, fieldEditable) {\n\t  this.field = field;\n\t  this.fieldEditable = (fieldEditable === true);\n\t};\n\n\t/**\n\t * Get field\n\t * @return {String}\n\t */\n\tNode.prototype.getField = function() {\n\t  if (this.field === undefined) {\n\t    this._getDomField();\n\t  }\n\n\t  return this.field;\n\t};\n\n\t/**\n\t * Set value. Value is a JSON structure or an element String, Boolean, etc.\n\t * @param {*} value\n\t * @param {String} [type]  Specify the type of the value. Can be 'auto',\n\t *                         'array', 'object', or 'string'\n\t */\n\tNode.prototype.setValue = function(value, type) {\n\t  var childValue, child;\n\n\t  // first clear all current childs (if any)\n\t  var childs = this.childs;\n\t  if (childs) {\n\t    while (childs.length) {\n\t      this.removeChild(childs[0]);\n\t    }\n\t  }\n\n\t  // TODO: remove the DOM of this Node\n\n\t  this.type = this._getType(value);\n\n\t  // check if type corresponds with the provided type\n\t  if (type && type != this.type) {\n\t    if (type == 'string' && this.type == 'auto') {\n\t      this.type = type;\n\t    }\n\t    else {\n\t      throw new Error('Type mismatch: ' +\n\t          'cannot cast value of type \"' + this.type +\n\t          ' to the specified type \"' + type + '\"');\n\t    }\n\t  }\n\n\t  if (this.type == 'array') {\n\t    // array\n\t    this.childs = [];\n\t    for (var i = 0, iMax = value.length; i < iMax; i++) {\n\t      childValue = value[i];\n\t      if (childValue !== undefined && !(childValue instanceof Function)) {\n\t        // ignore undefined and functions\n\t        child = new Node(this.editor, {\n\t          value: childValue\n\t        });\n\t        this.appendChild(child);\n\t      }\n\t    }\n\t    this.value = '';\n\t  }\n\t  else if (this.type == 'object') {\n\t    // object\n\t    this.childs = [];\n\t    for (var childField in value) {\n\t      if (value.hasOwnProperty(childField)) {\n\t        childValue = value[childField];\n\t        if (childValue !== undefined && !(childValue instanceof Function)) {\n\t          // ignore undefined and functions\n\t          child = new Node(this.editor, {\n\t            field: childField,\n\t            value: childValue\n\t          });\n\t          this.appendChild(child);\n\t        }\n\t      }\n\t    }\n\t    this.value = '';\n\t  }\n\t  else {\n\t    // value\n\t    this.childs = undefined;\n\t    this.value = value;\n\t    /* TODO\n\t     if (typeof(value) == 'string') {\n\t     var escValue = JSON.stringify(value);\n\t     this.value = escValue.substring(1, escValue.length - 1);\n\t     util.log('check', value, this.value);\n\t     }\n\t     else {\n\t     this.value = value;\n\t     }\n\t     */\n\t  }\n\t};\n\n\t/**\n\t * Get value. Value is a JSON structure\n\t * @return {*} value\n\t */\n\tNode.prototype.getValue = function() {\n\t  //var childs, i, iMax;\n\n\t  if (this.type == 'array') {\n\t    var arr = [];\n\t    this.childs.forEach (function (child) {\n\t      arr.push(child.getValue());\n\t    });\n\t    return arr;\n\t  }\n\t  else if (this.type == 'object') {\n\t    var obj = {};\n\t    this.childs.forEach (function (child) {\n\t      obj[child.getField()] = child.getValue();\n\t    });\n\t    return obj;\n\t  }\n\t  else {\n\t    if (this.value === undefined) {\n\t      this._getDomValue();\n\t    }\n\n\t    return this.value;\n\t  }\n\t};\n\n\t/**\n\t * Get the nesting level of this node\n\t * @return {Number} level\n\t */\n\tNode.prototype.getLevel = function() {\n\t  return (this.parent ? this.parent.getLevel() + 1 : 0);\n\t};\n\n\t/**\n\t * Create a clone of a node\n\t * The complete state of a clone is copied, including whether it is expanded or\n\t * not. The DOM elements are not cloned.\n\t * @return {Node} clone\n\t */\n\tNode.prototype.clone = function() {\n\t  var clone = new Node(this.editor);\n\t  clone.type = this.type;\n\t  clone.field = this.field;\n\t  clone.fieldInnerText = this.fieldInnerText;\n\t  clone.fieldEditable = this.fieldEditable;\n\t  clone.value = this.value;\n\t  clone.valueInnerText = this.valueInnerText;\n\t  clone.expanded = this.expanded;\n\n\t  if (this.childs) {\n\t    // an object or array\n\t    var cloneChilds = [];\n\t    this.childs.forEach(function (child) {\n\t      var childClone = child.clone();\n\t      childClone.setParent(clone);\n\t      cloneChilds.push(childClone);\n\t    });\n\t    clone.childs = cloneChilds;\n\t  }\n\t  else {\n\t    // a value\n\t    clone.childs = undefined;\n\t  }\n\n\t  return clone;\n\t};\n\n\t/**\n\t * Expand this node and optionally its childs.\n\t * @param {boolean} [recurse] Optional recursion, true by default. When\n\t *                            true, all childs will be expanded recursively\n\t */\n\tNode.prototype.expand = function(recurse) {\n\t  if (!this.childs) {\n\t    return;\n\t  }\n\n\t  // set this node expanded\n\t  this.expanded = true;\n\t  if (this.dom.expand) {\n\t    this.dom.expand.className = 'expanded';\n\t  }\n\n\t  this.showChilds();\n\n\t  if (recurse !== false) {\n\t    this.childs.forEach(function (child) {\n\t      child.expand(recurse);\n\t    });\n\t  }\n\t};\n\n\t/**\n\t * Collapse this node and optionally its childs.\n\t * @param {boolean} [recurse] Optional recursion, true by default. When\n\t *                            true, all childs will be collapsed recursively\n\t */\n\tNode.prototype.collapse = function(recurse) {\n\t  if (!this.childs) {\n\t    return;\n\t  }\n\n\t  this.hideChilds();\n\n\t  // collapse childs in case of recurse\n\t  if (recurse !== false) {\n\t    this.childs.forEach(function (child) {\n\t      child.collapse(recurse);\n\t    });\n\n\t  }\n\n\t  // make this node collapsed\n\t  if (this.dom.expand) {\n\t    this.dom.expand.className = 'collapsed';\n\t  }\n\t  this.expanded = false;\n\t};\n\n\t/**\n\t * Recursively show all childs when they are expanded\n\t */\n\tNode.prototype.showChilds = function() {\n\t  var childs = this.childs;\n\t  if (!childs) {\n\t    return;\n\t  }\n\t  if (!this.expanded) {\n\t    return;\n\t  }\n\n\t  var tr = this.dom.tr;\n\t  var table = tr ? tr.parentNode : undefined;\n\t  if (table) {\n\t    // show row with append button\n\t    var append = this.getAppend();\n\t    var nextTr = tr.nextSibling;\n\t    if (nextTr) {\n\t      table.insertBefore(append, nextTr);\n\t    }\n\t    else {\n\t      table.appendChild(append);\n\t    }\n\n\t    // show childs\n\t    this.childs.forEach(function (child) {\n\t      table.insertBefore(child.getDom(), append);\n\t      child.showChilds();\n\t    });\n\t  }\n\t};\n\n\t/**\n\t * Hide the node with all its childs\n\t */\n\tNode.prototype.hide = function() {\n\t  var tr = this.dom.tr;\n\t  var table = tr ? tr.parentNode : undefined;\n\t  if (table) {\n\t    table.removeChild(tr);\n\t  }\n\t  this.hideChilds();\n\t};\n\n\n\t/**\n\t * Recursively hide all childs\n\t */\n\tNode.prototype.hideChilds = function() {\n\t  var childs = this.childs;\n\t  if (!childs) {\n\t    return;\n\t  }\n\t  if (!this.expanded) {\n\t    return;\n\t  }\n\n\t  // hide append row\n\t  var append = this.getAppend();\n\t  if (append.parentNode) {\n\t    append.parentNode.removeChild(append);\n\t  }\n\n\t  // hide childs\n\t  this.childs.forEach(function (child) {\n\t    child.hide();\n\t  });\n\t};\n\n\n\t/**\n\t * Add a new child to the node.\n\t * Only applicable when Node value is of type array or object\n\t * @param {Node} node\n\t */\n\tNode.prototype.appendChild = function(node) {\n\t  if (this._hasChilds()) {\n\t    // adjust the link to the parent\n\t    node.setParent(this);\n\t    node.fieldEditable = (this.type == 'object');\n\t    if (this.type == 'array') {\n\t      node.index = this.childs.length;\n\t    }\n\t    this.childs.push(node);\n\n\t    if (this.expanded) {\n\t      // insert into the DOM, before the appendRow\n\t      var newTr = node.getDom();\n\t      var appendTr = this.getAppend();\n\t      var table = appendTr ? appendTr.parentNode : undefined;\n\t      if (appendTr && table) {\n\t        table.insertBefore(newTr, appendTr);\n\t      }\n\n\t      node.showChilds();\n\t    }\n\n\t    this.updateDom({'updateIndexes': true});\n\t    node.updateDom({'recurse': true});\n\t  }\n\t};\n\n\n\t/**\n\t * Move a node from its current parent to this node\n\t * Only applicable when Node value is of type array or object\n\t * @param {Node} node\n\t * @param {Node} beforeNode\n\t */\n\tNode.prototype.moveBefore = function(node, beforeNode) {\n\t  if (this._hasChilds()) {\n\t    // create a temporary row, to prevent the scroll position from jumping\n\t    // when removing the node\n\t    var tbody = (this.dom.tr) ? this.dom.tr.parentNode : undefined;\n\t    if (tbody) {\n\t      var trTemp = document.createElement('tr');\n\t      trTemp.style.height = tbody.clientHeight + 'px';\n\t      tbody.appendChild(trTemp);\n\t    }\n\n\t    if (node.parent) {\n\t      node.parent.removeChild(node);\n\t    }\n\n\t    if (beforeNode instanceof AppendNode) {\n\t      this.appendChild(node);\n\t    }\n\t    else {\n\t      this.insertBefore(node, beforeNode);\n\t    }\n\n\t    if (tbody) {\n\t      tbody.removeChild(trTemp);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Move a node from its current parent to this node\n\t * Only applicable when Node value is of type array or object.\n\t * If index is out of range, the node will be appended to the end\n\t * @param {Node} node\n\t * @param {Number} index\n\t */\n\tNode.prototype.moveTo = function (node, index) {\n\t  if (node.parent == this) {\n\t    // same parent\n\t    var currentIndex = this.childs.indexOf(node);\n\t    if (currentIndex < index) {\n\t      // compensate the index for removal of the node itself\n\t      index++;\n\t    }\n\t  }\n\n\t  var beforeNode = this.childs[index] || this.append;\n\t  this.moveBefore(node, beforeNode);\n\t};\n\n\t/**\n\t * Insert a new child before a given node\n\t * Only applicable when Node value is of type array or object\n\t * @param {Node} node\n\t * @param {Node} beforeNode\n\t */\n\tNode.prototype.insertBefore = function(node, beforeNode) {\n\t  if (this._hasChilds()) {\n\t    if (beforeNode == this.append) {\n\t      // append to the child nodes\n\n\t      // adjust the link to the parent\n\t      node.setParent(this);\n\t      node.fieldEditable = (this.type == 'object');\n\t      this.childs.push(node);\n\t    }\n\t    else {\n\t      // insert before a child node\n\t      var index = this.childs.indexOf(beforeNode);\n\t      if (index == -1) {\n\t        throw new Error('Node not found');\n\t      }\n\n\t      // adjust the link to the parent\n\t      node.setParent(this);\n\t      node.fieldEditable = (this.type == 'object');\n\t      this.childs.splice(index, 0, node);\n\t    }\n\n\t    if (this.expanded) {\n\t      // insert into the DOM\n\t      var newTr = node.getDom();\n\t      var nextTr = beforeNode.getDom();\n\t      var table = nextTr ? nextTr.parentNode : undefined;\n\t      if (nextTr && table) {\n\t        table.insertBefore(newTr, nextTr);\n\t      }\n\n\t      node.showChilds();\n\t    }\n\n\t    this.updateDom({'updateIndexes': true});\n\t    node.updateDom({'recurse': true});\n\t  }\n\t};\n\n\t/**\n\t * Insert a new child before a given node\n\t * Only applicable when Node value is of type array or object\n\t * @param {Node} node\n\t * @param {Node} afterNode\n\t */\n\tNode.prototype.insertAfter = function(node, afterNode) {\n\t  if (this._hasChilds()) {\n\t    var index = this.childs.indexOf(afterNode);\n\t    var beforeNode = this.childs[index + 1];\n\t    if (beforeNode) {\n\t      this.insertBefore(node, beforeNode);\n\t    }\n\t    else {\n\t      this.appendChild(node);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Search in this node\n\t * The node will be expanded when the text is found one of its childs, else\n\t * it will be collapsed. Searches are case insensitive.\n\t * @param {String} text\n\t * @return {Node[]} results  Array with nodes containing the search text\n\t */\n\tNode.prototype.search = function(text) {\n\t  var results = [];\n\t  var index;\n\t  var search = text ? text.toLowerCase() : undefined;\n\n\t  // delete old search data\n\t  delete this.searchField;\n\t  delete this.searchValue;\n\n\t  // search in field\n\t  if (this.field != undefined) {\n\t    var field = String(this.field).toLowerCase();\n\t    index = field.indexOf(search);\n\t    if (index != -1) {\n\t      this.searchField = true;\n\t      results.push({\n\t        'node': this,\n\t        'elem': 'field'\n\t      });\n\t    }\n\n\t    // update dom\n\t    this._updateDomField();\n\t  }\n\n\t  // search in value\n\t  if (this._hasChilds()) {\n\t    // array, object\n\n\t    // search the nodes childs\n\t    if (this.childs) {\n\t      var childResults = [];\n\t      this.childs.forEach(function (child) {\n\t        childResults = childResults.concat(child.search(text));\n\t      });\n\t      results = results.concat(childResults);\n\t    }\n\n\t    // update dom\n\t    if (search != undefined) {\n\t      var recurse = false;\n\t      if (childResults.length == 0) {\n\t        this.collapse(recurse);\n\t      }\n\t      else {\n\t        this.expand(recurse);\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    // string, auto\n\t    if (this.value != undefined ) {\n\t      var value = String(this.value).toLowerCase();\n\t      index = value.indexOf(search);\n\t      if (index != -1) {\n\t        this.searchValue = true;\n\t        results.push({\n\t          'node': this,\n\t          'elem': 'value'\n\t        });\n\t      }\n\t    }\n\n\t    // update dom\n\t    this._updateDomValue();\n\t  }\n\n\t  return results;\n\t};\n\n\t/**\n\t * Move the scroll position such that this node is in the visible area.\n\t * The node will not get the focus\n\t * @param {function(boolean)} [callback]\n\t */\n\tNode.prototype.scrollTo = function(callback) {\n\t  if (!this.dom.tr || !this.dom.tr.parentNode) {\n\t    // if the node is not visible, expand its parents\n\t    var parent = this.parent;\n\t    var recurse = false;\n\t    while (parent) {\n\t      parent.expand(recurse);\n\t      parent = parent.parent;\n\t    }\n\t  }\n\n\t  if (this.dom.tr && this.dom.tr.parentNode) {\n\t    this.editor.scrollTo(this.dom.tr.offsetTop, callback);\n\t  }\n\t};\n\n\n\t// stores the element name currently having the focus\n\tNode.focusElement = undefined;\n\n\t/**\n\t * Set focus to this node\n\t * @param {String} [elementName]  The field name of the element to get the\n\t *                                focus available values: 'drag', 'menu',\n\t *                                'expand', 'field', 'value' (default)\n\t */\n\tNode.prototype.focus = function(elementName) {\n\t  Node.focusElement = elementName;\n\n\t  if (this.dom.tr && this.dom.tr.parentNode) {\n\t    var dom = this.dom;\n\n\t    switch (elementName) {\n\t      case 'drag':\n\t        if (dom.drag) {\n\t          dom.drag.focus();\n\t        }\n\t        else {\n\t          dom.menu.focus();\n\t        }\n\t        break;\n\n\t      case 'menu':\n\t        dom.menu.focus();\n\t        break;\n\n\t      case 'expand':\n\t        if (this._hasChilds()) {\n\t          dom.expand.focus();\n\t        }\n\t        else if (dom.field && this.fieldEditable) {\n\t          dom.field.focus();\n\t          util.selectContentEditable(dom.field);\n\t        }\n\t        else if (dom.value && !this._hasChilds()) {\n\t          dom.value.focus();\n\t          util.selectContentEditable(dom.value);\n\t        }\n\t        else {\n\t          dom.menu.focus();\n\t        }\n\t        break;\n\n\t      case 'field':\n\t        if (dom.field && this.fieldEditable) {\n\t          dom.field.focus();\n\t          util.selectContentEditable(dom.field);\n\t        }\n\t        else if (dom.value && !this._hasChilds()) {\n\t          dom.value.focus();\n\t          util.selectContentEditable(dom.value);\n\t        }\n\t        else if (this._hasChilds()) {\n\t          dom.expand.focus();\n\t        }\n\t        else {\n\t          dom.menu.focus();\n\t        }\n\t        break;\n\n\t      case 'value':\n\t      default:\n\t        if (dom.value && !this._hasChilds()) {\n\t          dom.value.focus();\n\t          util.selectContentEditable(dom.value);\n\t        }\n\t        else if (dom.field && this.fieldEditable) {\n\t          dom.field.focus();\n\t          util.selectContentEditable(dom.field);\n\t        }\n\t        else if (this._hasChilds()) {\n\t          dom.expand.focus();\n\t        }\n\t        else {\n\t          dom.menu.focus();\n\t        }\n\t        break;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Select all text in an editable div after a delay of 0 ms\n\t * @param {Element} editableDiv\n\t */\n\tNode.select = function(editableDiv) {\n\t  setTimeout(function () {\n\t    util.selectContentEditable(editableDiv);\n\t  }, 0);\n\t};\n\n\t/**\n\t * Update the values from the DOM field and value of this node\n\t */\n\tNode.prototype.blur = function() {\n\t  // retrieve the actual field and value from the DOM.\n\t  this._getDomValue(false);\n\t  this._getDomField(false);\n\t};\n\n\t/**\n\t * Duplicate given child node\n\t * new structure will be added right before the cloned node\n\t * @param {Node} node           the childNode to be duplicated\n\t * @return {Node} clone         the clone of the node\n\t * @private\n\t */\n\tNode.prototype._duplicate = function(node) {\n\t  var clone = node.clone();\n\n\t  /* TODO: adjust the field name (to prevent equal field names)\n\t   if (this.type == 'object') {\n\t   }\n\t   */\n\n\t  this.insertAfter(clone, node);\n\n\t  return clone;\n\t};\n\n\t/**\n\t * Check if given node is a child. The method will check recursively to find\n\t * this node.\n\t * @param {Node} node\n\t * @return {boolean} containsNode\n\t */\n\tNode.prototype.containsNode = function(node) {\n\t  if (this == node) {\n\t    return true;\n\t  }\n\n\t  var childs = this.childs;\n\t  if (childs) {\n\t    // TODO: use the js5 Array.some() here?\n\t    for (var i = 0, iMax = childs.length; i < iMax; i++) {\n\t      if (childs[i].containsNode(node)) {\n\t        return true;\n\t      }\n\t    }\n\t  }\n\n\t  return false;\n\t};\n\n\t/**\n\t * Move given node into this node\n\t * @param {Node} node           the childNode to be moved\n\t * @param {Node} beforeNode     node will be inserted before given\n\t *                                         node. If no beforeNode is given,\n\t *                                         the node is appended at the end\n\t * @private\n\t */\n\tNode.prototype._move = function(node, beforeNode) {\n\t  if (node == beforeNode) {\n\t    // nothing to do...\n\t    return;\n\t  }\n\n\t  // check if this node is not a child of the node to be moved here\n\t  if (node.containsNode(this)) {\n\t    throw new Error('Cannot move a field into a child of itself');\n\t  }\n\n\t  // remove the original node\n\t  if (node.parent) {\n\t    node.parent.removeChild(node);\n\t  }\n\n\t  // create a clone of the node\n\t  var clone = node.clone();\n\t  node.clearDom();\n\n\t  // insert or append the node\n\t  if (beforeNode) {\n\t    this.insertBefore(clone, beforeNode);\n\t  }\n\t  else {\n\t    this.appendChild(clone);\n\t  }\n\n\t  /* TODO: adjust the field name (to prevent equal field names)\n\t   if (this.type == 'object') {\n\t   }\n\t   */\n\t};\n\n\t/**\n\t * Remove a child from the node.\n\t * Only applicable when Node value is of type array or object\n\t * @param {Node} node   The child node to be removed;\n\t * @return {Node | undefined} node  The removed node on success,\n\t *                                             else undefined\n\t */\n\tNode.prototype.removeChild = function(node) {\n\t  if (this.childs) {\n\t    var index = this.childs.indexOf(node);\n\n\t    if (index != -1) {\n\t      node.hide();\n\n\t      // delete old search results\n\t      delete node.searchField;\n\t      delete node.searchValue;\n\n\t      var removedNode = this.childs.splice(index, 1)[0];\n\n\t      this.updateDom({'updateIndexes': true});\n\n\t      return removedNode;\n\t    }\n\t  }\n\n\t  return undefined;\n\t};\n\n\t/**\n\t * Remove a child node node from this node\n\t * This method is equal to Node.removeChild, except that _remove firex an\n\t * onChange event.\n\t * @param {Node} node\n\t * @private\n\t */\n\tNode.prototype._remove = function (node) {\n\t  this.removeChild(node);\n\t};\n\n\t/**\n\t * Change the type of the value of this Node\n\t * @param {String} newType\n\t */\n\tNode.prototype.changeType = function (newType) {\n\t  var oldType = this.type;\n\n\t  if (oldType == newType) {\n\t    // type is not changed\n\t    return;\n\t  }\n\n\t  if ((newType == 'string' || newType == 'auto') &&\n\t      (oldType == 'string' || oldType == 'auto')) {\n\t    // this is an easy change\n\t    this.type = newType;\n\t  }\n\t  else {\n\t    // change from array to object, or from string/auto to object/array\n\t    var table = this.dom.tr ? this.dom.tr.parentNode : undefined;\n\t    var lastTr;\n\t    if (this.expanded) {\n\t      lastTr = this.getAppend();\n\t    }\n\t    else {\n\t      lastTr = this.getDom();\n\t    }\n\t    var nextTr = (lastTr && lastTr.parentNode) ? lastTr.nextSibling : undefined;\n\n\t    // hide current field and all its childs\n\t    this.hide();\n\t    this.clearDom();\n\n\t    // adjust the field and the value\n\t    this.type = newType;\n\n\t    // adjust childs\n\t    if (newType == 'object') {\n\t      if (!this.childs) {\n\t        this.childs = [];\n\t      }\n\n\t      this.childs.forEach(function (child, index) {\n\t        child.clearDom();\n\t        delete child.index;\n\t        child.fieldEditable = true;\n\t        if (child.field == undefined) {\n\t          child.field = '';\n\t        }\n\t      });\n\n\t      if (oldType == 'string' || oldType == 'auto') {\n\t        this.expanded = true;\n\t      }\n\t    }\n\t    else if (newType == 'array') {\n\t      if (!this.childs) {\n\t        this.childs = [];\n\t      }\n\n\t      this.childs.forEach(function (child, index) {\n\t        child.clearDom();\n\t        child.fieldEditable = false;\n\t        child.index = index;\n\t      });\n\n\t      if (oldType == 'string' || oldType == 'auto') {\n\t        this.expanded = true;\n\t      }\n\t    }\n\t    else {\n\t      this.expanded = false;\n\t    }\n\n\t    // create new DOM\n\t    if (table) {\n\t      if (nextTr) {\n\t        table.insertBefore(this.getDom(), nextTr);\n\t      }\n\t      else {\n\t        table.appendChild(this.getDom());\n\t      }\n\t    }\n\t    this.showChilds();\n\t  }\n\n\t  if (newType == 'auto' || newType == 'string') {\n\t    // cast value to the correct type\n\t    if (newType == 'string') {\n\t      this.value = String(this.value);\n\t    }\n\t    else {\n\t      this.value = this._stringCast(String(this.value));\n\t    }\n\n\t    this.focus();\n\t  }\n\n\t  this.updateDom({'updateIndexes': true});\n\t};\n\n\t/**\n\t * Retrieve value from DOM\n\t * @param {boolean} [silent]  If true (default), no errors will be thrown in\n\t *                            case of invalid data\n\t * @private\n\t */\n\tNode.prototype._getDomValue = function(silent) {\n\t  if (this.dom.value && this.type != 'array' && this.type != 'object') {\n\t    this.valueInnerText = util.getInnerText(this.dom.value);\n\t  }\n\n\t  if (this.valueInnerText != undefined) {\n\t    try {\n\t      // retrieve the value\n\t      var value;\n\t      if (this.type == 'string') {\n\t        value = this._unescapeHTML(this.valueInnerText);\n\t      }\n\t      else {\n\t        var str = this._unescapeHTML(this.valueInnerText);\n\t        value = this._stringCast(str);\n\t      }\n\t      if (value !== this.value) {\n\t        var oldValue = this.value;\n\t        this.value = value;\n\t        this.editor._onAction('editValue', {\n\t          'node': this,\n\t          'oldValue': oldValue,\n\t          'newValue': value,\n\t          'oldSelection': this.editor.selection,\n\t          'newSelection': this.editor.getSelection()\n\t        });\n\t      }\n\t    }\n\t    catch (err) {\n\t      this.value = undefined;\n\t      // TODO: sent an action with the new, invalid value?\n\t      if (silent !== true) {\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Update dom value:\n\t * - the text color of the value, depending on the type of the value\n\t * - the height of the field, depending on the width\n\t * - background color in case it is empty\n\t * @private\n\t */\n\tNode.prototype._updateDomValue = function () {\n\t  var domValue = this.dom.value;\n\t  if (domValue) {\n\t    // set text color depending on value type\n\t    // TODO: put colors in css\n\t    var v = this.value;\n\t    var t = (this.type == 'auto') ? util.type(v) : this.type;\n\t    var isUrl = (t == 'string' && util.isUrl(v));\n\t    var color = '';\n\t    if (isUrl && !this.editable.value) { // TODO: when to apply this?\n\t      color = '';\n\t    }\n\t    else if (t == 'string') {\n\t      color = 'green';\n\t    }\n\t    else if (t == 'number') {\n\t      color = 'red';\n\t    }\n\t    else if (t == 'boolean') {\n\t      color = 'darkorange';\n\t    }\n\t    else if (this._hasChilds()) {\n\t      color = '';\n\t    }\n\t    else if (v === null) {\n\t      color = '#004ED0';  // blue\n\t    }\n\t    else {\n\t      // invalid value\n\t      color = 'black';\n\t    }\n\t    domValue.style.color = color;\n\n\t    // make background color light-gray when empty\n\t    var isEmpty = (String(this.value) == '' && this.type != 'array' && this.type != 'object');\n\t    if (isEmpty) {\n\t      util.addClassName(domValue, 'empty');\n\t    }\n\t    else {\n\t      util.removeClassName(domValue, 'empty');\n\t    }\n\n\t    // underline url\n\t    if (isUrl) {\n\t      util.addClassName(domValue, 'url');\n\t    }\n\t    else {\n\t      util.removeClassName(domValue, 'url');\n\t    }\n\n\t    // update title\n\t    if (t == 'array' || t == 'object') {\n\t      var count = this.childs ? this.childs.length : 0;\n\t      domValue.title = this.type + ' containing ' + count + ' items';\n\t    }\n\t    else if (t == 'string' && util.isUrl(v)) {\n\t      if (this.editable.value) {\n\t        domValue.title = 'Ctrl+Click or Ctrl+Enter to open url in new window';\n\t      }\n\t    }\n\t    else {\n\t      domValue.title = '';\n\t    }\n\n\t    // highlight when there is a search result\n\t    if (this.searchValueActive) {\n\t      util.addClassName(domValue, 'highlight-active');\n\t    }\n\t    else {\n\t      util.removeClassName(domValue, 'highlight-active');\n\t    }\n\t    if (this.searchValue) {\n\t      util.addClassName(domValue, 'highlight');\n\t    }\n\t    else {\n\t      util.removeClassName(domValue, 'highlight');\n\t    }\n\n\t    // strip formatting from the contents of the editable div\n\t    util.stripFormatting(domValue);\n\t  }\n\t};\n\n\t/**\n\t * Update dom field:\n\t * - the text color of the field, depending on the text\n\t * - the height of the field, depending on the width\n\t * - background color in case it is empty\n\t * @private\n\t */\n\tNode.prototype._updateDomField = function () {\n\t  var domField = this.dom.field;\n\t  if (domField) {\n\t    // make backgound color lightgray when empty\n\t    var isEmpty = (String(this.field) == '' && this.parent.type != 'array');\n\t    if (isEmpty) {\n\t      util.addClassName(domField, 'empty');\n\t    }\n\t    else {\n\t      util.removeClassName(domField, 'empty');\n\t    }\n\n\t    // highlight when there is a search result\n\t    if (this.searchFieldActive) {\n\t      util.addClassName(domField, 'highlight-active');\n\t    }\n\t    else {\n\t      util.removeClassName(domField, 'highlight-active');\n\t    }\n\t    if (this.searchField) {\n\t      util.addClassName(domField, 'highlight');\n\t    }\n\t    else {\n\t      util.removeClassName(domField, 'highlight');\n\t    }\n\n\t    // strip formatting from the contents of the editable div\n\t    util.stripFormatting(domField);\n\t  }\n\t};\n\n\t/**\n\t * Retrieve field from DOM\n\t * @param {boolean} [silent]  If true (default), no errors will be thrown in\n\t *                            case of invalid data\n\t * @private\n\t */\n\tNode.prototype._getDomField = function(silent) {\n\t  if (this.dom.field && this.fieldEditable) {\n\t    this.fieldInnerText = util.getInnerText(this.dom.field);\n\t  }\n\n\t  if (this.fieldInnerText != undefined) {\n\t    try {\n\t      var field = this._unescapeHTML(this.fieldInnerText);\n\n\t      if (field !== this.field) {\n\t        var oldField = this.field;\n\t        this.field = field;\n\t        this.editor._onAction('editField', {\n\t          'node': this,\n\t          'oldValue': oldField,\n\t          'newValue': field,\n\t          'oldSelection': this.editor.selection,\n\t          'newSelection': this.editor.getSelection()\n\t        });\n\t      }\n\t    }\n\t    catch (err) {\n\t      this.field = undefined;\n\t      // TODO: sent an action here, with the new, invalid value?\n\t      if (silent !== true) {\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Clear the dom of the node\n\t */\n\tNode.prototype.clearDom = function() {\n\t  // TODO: hide the node first?\n\t  //this.hide();\n\t  // TODO: recursively clear dom?\n\n\t  this.dom = {};\n\t};\n\n\t/**\n\t * Get the HTML DOM TR element of the node.\n\t * The dom will be generated when not yet created\n\t * @return {Element} tr    HTML DOM TR Element\n\t */\n\tNode.prototype.getDom = function() {\n\t  var dom = this.dom;\n\t  if (dom.tr) {\n\t    return dom.tr;\n\t  }\n\n\t  this._updateEditability();\n\n\t  // create row\n\t  dom.tr = document.createElement('tr');\n\t  dom.tr.node = this;\n\n\t  if (this.editor.options.mode === 'tree') { // note: we take here the global setting\n\t    var tdDrag = document.createElement('td');\n\t    if (this.editable.field) {\n\t      // create draggable area\n\t      if (this.parent) {\n\t        var domDrag = document.createElement('button');\n\t        dom.drag = domDrag;\n\t        domDrag.className = 'dragarea';\n\t        domDrag.title = 'Drag to move this field (Alt+Shift+Arrows)';\n\t        tdDrag.appendChild(domDrag);\n\t      }\n\t    }\n\t    dom.tr.appendChild(tdDrag);\n\n\t    // create context menu\n\t    var tdMenu = document.createElement('td');\n\t    var menu = document.createElement('button');\n\t    dom.menu = menu;\n\t    menu.className = 'contextmenu';\n\t    menu.title = 'Click to open the actions menu (Ctrl+M)';\n\t    tdMenu.appendChild(dom.menu);\n\t    dom.tr.appendChild(tdMenu);\n\t  }\n\n\t  // create tree and field\n\t  var tdField = document.createElement('td');\n\t  dom.tr.appendChild(tdField);\n\t  dom.tree = this._createDomTree();\n\t  tdField.appendChild(dom.tree);\n\n\t  this.updateDom({'updateIndexes': true});\n\n\t  return dom.tr;\n\t};\n\n\t/**\n\t * DragStart event, fired on mousedown on the dragarea at the left side of a Node\n\t * @param {Event} event\n\t * @private\n\t */\n\tNode.prototype._onDragStart = function (event) {\n\t  var node = this;\n\t  if (!this.mousemove) {\n\t    this.mousemove = util.addEventListener(document, 'mousemove',\n\t        function (event) {\n\t          node._onDrag(event);\n\t        });\n\t  }\n\n\t  if (!this.mouseup) {\n\t    this.mouseup = util.addEventListener(document, 'mouseup',\n\t        function (event ) {\n\t          node._onDragEnd(event);\n\t        });\n\t  }\n\n\t  this.editor.highlighter.lock();\n\t  this.drag = {\n\t    'oldCursor': document.body.style.cursor,\n\t    'startParent': this.parent,\n\t    'startIndex': this.parent.childs.indexOf(this),\n\t    'mouseX': event.pageX,\n\t    'level': this.getLevel()\n\t  };\n\t  document.body.style.cursor = 'move';\n\n\t  event.preventDefault();\n\t};\n\n\t/**\n\t * Drag event, fired when moving the mouse while dragging a Node\n\t * @param {Event} event\n\t * @private\n\t */\n\tNode.prototype._onDrag = function (event) {\n\t  // TODO: this method has grown too large. Split it in a number of methods\n\t  var mouseY = event.pageY;\n\t  var mouseX = event.pageX;\n\n\t  var trThis, trPrev, trNext, trFirst, trLast, trRoot;\n\t  var nodePrev, nodeNext;\n\t  var topThis, topPrev, topFirst, heightThis, bottomNext, heightNext;\n\t  var moved = false;\n\n\t  // TODO: add an ESC option, which resets to the original position\n\n\t  // move up/down\n\t  trThis = this.dom.tr;\n\t  topThis = util.getAbsoluteTop(trThis);\n\t  heightThis = trThis.offsetHeight;\n\t  if (mouseY < topThis) {\n\t    // move up\n\t    trPrev = trThis;\n\t    do {\n\t      trPrev = trPrev.previousSibling;\n\t      nodePrev = Node.getNodeFromTarget(trPrev);\n\t      topPrev = trPrev ? util.getAbsoluteTop(trPrev) : 0;\n\t    }\n\t    while (trPrev && mouseY < topPrev);\n\n\t    if (nodePrev && !nodePrev.parent) {\n\t      nodePrev = undefined;\n\t    }\n\n\t    if (!nodePrev) {\n\t      // move to the first node\n\t      trRoot = trThis.parentNode.firstChild;\n\t      trPrev = trRoot ? trRoot.nextSibling : undefined;\n\t      nodePrev = Node.getNodeFromTarget(trPrev);\n\t      if (nodePrev == this) {\n\t        nodePrev = undefined;\n\t      }\n\t    }\n\n\t    if (nodePrev) {\n\t      // check if mouseY is really inside the found node\n\t      trPrev = nodePrev.dom.tr;\n\t      topPrev = trPrev ? util.getAbsoluteTop(trPrev) : 0;\n\t      if (mouseY > topPrev + heightThis) {\n\t        nodePrev = undefined;\n\t      }\n\t    }\n\n\t    if (nodePrev) {\n\t      nodePrev.parent.moveBefore(this, nodePrev);\n\t      moved = true;\n\t    }\n\t  }\n\t  else {\n\t    // move down\n\t    trLast = (this.expanded && this.append) ? this.append.getDom() : this.dom.tr;\n\t    trFirst = trLast ? trLast.nextSibling : undefined;\n\t    if (trFirst) {\n\t      topFirst = util.getAbsoluteTop(trFirst);\n\t      trNext = trFirst;\n\t      do {\n\t        nodeNext = Node.getNodeFromTarget(trNext);\n\t        if (trNext) {\n\t          bottomNext = trNext.nextSibling ?\n\t              util.getAbsoluteTop(trNext.nextSibling) : 0;\n\t          heightNext = trNext ? (bottomNext - topFirst) : 0;\n\n\t          if (nodeNext.parent.childs.length == 1 && nodeNext.parent.childs[0] == this) {\n\t            // We are about to remove the last child of this parent,\n\t            // which will make the parents appendNode visible.\n\t            topThis += 24 - 1;\n\t            // TODO: dangerous to suppose the height of the appendNode a constant of 24-1 px.\n\t          }\n\t        }\n\n\t        trNext = trNext.nextSibling;\n\t      }\n\t      while (trNext && mouseY > topThis + heightNext);\n\n\t      if (nodeNext && nodeNext.parent) {\n\t        // calculate the desired level\n\t        var diffX = (mouseX - this.drag.mouseX);\n\t        var diffLevel = Math.round(diffX / 24 / 2);\n\t        var level = this.drag.level + diffLevel; // desired level\n\t        var levelNext = nodeNext.getLevel();     // level to be\n\n\t        // find the best fitting level (move upwards over the append nodes)\n\t        trPrev = nodeNext.dom.tr.previousSibling;\n\t        while (levelNext < level && trPrev) {\n\t          nodePrev = Node.getNodeFromTarget(trPrev);\n\t          if (nodePrev == this || nodePrev._isChildOf(this)) {\n\t            // neglect itself and its childs\n\t          }\n\t          else if (nodePrev instanceof AppendNode) {\n\t            var childs = nodePrev.parent.childs;\n\t            if (childs.length > 1 ||\n\t                (childs.length == 1 && childs[0] != this)) {\n\t              // non-visible append node of a list of childs\n\t              // consisting of not only this node (else the\n\t              // append node will change into a visible \"empty\"\n\t              // text when removing this node).\n\t              nodeNext = Node.getNodeFromTarget(trPrev);\n\t              levelNext = nodeNext.getLevel();\n\t            }\n\t            else {\n\t              break;\n\t            }\n\t          }\n\t          else {\n\t            break;\n\t          }\n\n\t          trPrev = trPrev.previousSibling;\n\t        }\n\n\t        // move the node when its position is changed\n\t        if (trLast.nextSibling != nodeNext.dom.tr) {\n\t          nodeNext.parent.moveBefore(this, nodeNext);\n\t          moved = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  if (moved) {\n\t    // update the dragging parameters when moved\n\t    this.drag.mouseX = mouseX;\n\t    this.drag.level = this.getLevel();\n\t  }\n\n\t  // auto scroll when hovering around the top of the editor\n\t  this.editor.startAutoScroll(mouseY);\n\n\t  event.preventDefault();\n\t};\n\n\t/**\n\t * Drag event, fired on mouseup after having dragged a node\n\t * @param {Event} event\n\t * @private\n\t */\n\tNode.prototype._onDragEnd = function (event) {\n\t  var params = {\n\t    'node': this,\n\t    'startParent': this.drag.startParent,\n\t    'startIndex': this.drag.startIndex,\n\t    'endParent': this.parent,\n\t    'endIndex': this.parent.childs.indexOf(this)\n\t  };\n\t  if ((params.startParent != params.endParent) ||\n\t      (params.startIndex != params.endIndex)) {\n\t    // only register this action if the node is actually moved to another place\n\t    this.editor._onAction('moveNode', params);\n\t  }\n\n\t  document.body.style.cursor = this.drag.oldCursor;\n\t  this.editor.highlighter.unlock();\n\t  delete this.drag;\n\n\t  if (this.mousemove) {\n\t    util.removeEventListener(document, 'mousemove', this.mousemove);\n\t    delete this.mousemove;}\n\t  if (this.mouseup) {\n\t    util.removeEventListener(document, 'mouseup', this.mouseup);\n\t    delete this.mouseup;\n\t  }\n\n\t  // Stop any running auto scroll\n\t  this.editor.stopAutoScroll();\n\n\t  event.preventDefault();\n\t};\n\n\t/**\n\t * Test if this node is a child of an other node\n\t * @param {Node} node\n\t * @return {boolean} isChild\n\t * @private\n\t */\n\tNode.prototype._isChildOf = function (node) {\n\t  var n = this.parent;\n\t  while (n) {\n\t    if (n == node) {\n\t      return true;\n\t    }\n\t    n = n.parent;\n\t  }\n\n\t  return false;\n\t};\n\n\t/**\n\t * Create an editable field\n\t * @return {Element} domField\n\t * @private\n\t */\n\tNode.prototype._createDomField = function () {\n\t  return document.createElement('div');\n\t};\n\n\t/**\n\t * Set highlighting for this node and all its childs.\n\t * Only applied to the currently visible (expanded childs)\n\t * @param {boolean} highlight\n\t */\n\tNode.prototype.setHighlight = function (highlight) {\n\t  if (this.dom.tr) {\n\t    this.dom.tr.className = (highlight ? 'highlight' : '');\n\n\t    if (this.append) {\n\t      this.append.setHighlight(highlight);\n\t    }\n\n\t    if (this.childs) {\n\t      this.childs.forEach(function (child) {\n\t        child.setHighlight(highlight);\n\t      });\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Update the value of the node. Only primitive types are allowed, no Object\n\t * or Array is allowed.\n\t * @param {String | Number | Boolean | null} value\n\t */\n\tNode.prototype.updateValue = function (value) {\n\t  this.value = value;\n\t  this.updateDom();\n\t};\n\n\t/**\n\t * Update the field of the node.\n\t * @param {String} field\n\t */\n\tNode.prototype.updateField = function (field) {\n\t  this.field = field;\n\t  this.updateDom();\n\t};\n\n\t/**\n\t * Update the HTML DOM, optionally recursing through the childs\n\t * @param {Object} [options] Available parameters:\n\t *                          {boolean} [recurse]         If true, the\n\t *                          DOM of the childs will be updated recursively.\n\t *                          False by default.\n\t *                          {boolean} [updateIndexes]   If true, the childs\n\t *                          indexes of the node will be updated too. False by\n\t *                          default.\n\t */\n\tNode.prototype.updateDom = function (options) {\n\t  // update level indentation\n\t  var domTree = this.dom.tree;\n\t  if (domTree) {\n\t    domTree.style.marginLeft = this.getLevel() * 24 + 'px';\n\t  }\n\n\t  // update field\n\t  var domField = this.dom.field;\n\t  if (domField) {\n\t    if (this.fieldEditable) {\n\t      // parent is an object\n\t      domField.contentEditable = this.editable.field;\n\t      domField.spellcheck = false;\n\t      domField.className = 'field';\n\t    }\n\t    else {\n\t      // parent is an array this is the root node\n\t      domField.className = 'readonly';\n\t    }\n\n\t    var field;\n\t    if (this.index != undefined) {\n\t      field = this.index;\n\t    }\n\t    else if (this.field != undefined) {\n\t      field = this.field;\n\t    }\n\t    else if (this._hasChilds()) {\n\t      field = this.type;\n\t    }\n\t    else {\n\t      field = '';\n\t    }\n\t    domField.innerHTML = this._escapeHTML(field);\n\t  }\n\n\t  // update value\n\t  var domValue = this.dom.value;\n\t  if (domValue) {\n\t    var count = this.childs ? this.childs.length : 0;\n\t    if (this.type == 'array') {\n\t      domValue.innerHTML = '[' + count + ']';\n\t    }\n\t    else if (this.type == 'object') {\n\t      domValue.innerHTML = '{' + count + '}';\n\t    }\n\t    else {\n\t      domValue.innerHTML = this._escapeHTML(this.value);\n\t    }\n\t  }\n\n\t  // update field and value\n\t  this._updateDomField();\n\t  this._updateDomValue();\n\n\t  // update childs indexes\n\t  if (options && options.updateIndexes === true) {\n\t    // updateIndexes is true or undefined\n\t    this._updateDomIndexes();\n\t  }\n\n\t  if (options && options.recurse === true) {\n\t    // recurse is true or undefined. update childs recursively\n\t    if (this.childs) {\n\t      this.childs.forEach(function (child) {\n\t        child.updateDom(options);\n\t      });\n\t    }\n\t  }\n\n\t  // update row with append button\n\t  if (this.append) {\n\t    this.append.updateDom();\n\t  }\n\t};\n\n\t/**\n\t * Update the DOM of the childs of a node: update indexes and undefined field\n\t * names.\n\t * Only applicable when structure is an array or object\n\t * @private\n\t */\n\tNode.prototype._updateDomIndexes = function () {\n\t  var domValue = this.dom.value;\n\t  var childs = this.childs;\n\t  if (domValue && childs) {\n\t    if (this.type == 'array') {\n\t      childs.forEach(function (child, index) {\n\t        child.index = index;\n\t        var childField = child.dom.field;\n\t        if (childField) {\n\t          childField.innerHTML = index;\n\t        }\n\t      });\n\t    }\n\t    else if (this.type == 'object') {\n\t      childs.forEach(function (child) {\n\t        if (child.index != undefined) {\n\t          delete child.index;\n\n\t          if (child.field == undefined) {\n\t            child.field = '';\n\t          }\n\t        }\n\t      });\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Create an editable value\n\t * @private\n\t */\n\tNode.prototype._createDomValue = function () {\n\t  var domValue;\n\n\t  if (this.type == 'array') {\n\t    domValue = document.createElement('div');\n\t    domValue.className = 'readonly';\n\t    domValue.innerHTML = '[...]';\n\t  }\n\t  else if (this.type == 'object') {\n\t    domValue = document.createElement('div');\n\t    domValue.className = 'readonly';\n\t    domValue.innerHTML = '{...}';\n\t  }\n\t  else {\n\t    if (!this.editable.value && util.isUrl(this.value)) {\n\t      // create a link in case of read-only editor and value containing an url\n\t      domValue = document.createElement('a');\n\t      domValue.className = 'value';\n\t      domValue.href = this.value;\n\t      domValue.target = '_blank';\n\t      domValue.innerHTML = this._escapeHTML(this.value);\n\t    }\n\t    else {\n\t      // create an editable or read-only div\n\t      domValue = document.createElement('div');\n\t      domValue.contentEditable = this.editable.value;\n\t      domValue.spellcheck = false;\n\t      domValue.className = 'value';\n\t      domValue.innerHTML = this._escapeHTML(this.value);\n\t    }\n\t  }\n\n\t  return domValue;\n\t};\n\n\t/**\n\t * Create an expand/collapse button\n\t * @return {Element} expand\n\t * @private\n\t */\n\tNode.prototype._createDomExpandButton = function () {\n\t  // create expand button\n\t  var expand = document.createElement('button');\n\t  if (this._hasChilds()) {\n\t    expand.className = this.expanded ? 'expanded' : 'collapsed';\n\t    expand.title =\n\t        'Click to expand/collapse this field (Ctrl+E). \\n' +\n\t        'Ctrl+Click to expand/collapse including all childs.';\n\t  }\n\t  else {\n\t    expand.className = 'invisible';\n\t    expand.title = '';\n\t  }\n\n\t  return expand;\n\t};\n\n\n\t/**\n\t * Create a DOM tree element, containing the expand/collapse button\n\t * @return {Element} domTree\n\t * @private\n\t */\n\tNode.prototype._createDomTree = function () {\n\t  var dom = this.dom;\n\t  var domTree = document.createElement('table');\n\t  var tbody = document.createElement('tbody');\n\t  domTree.style.borderCollapse = 'collapse'; // TODO: put in css\n\t  domTree.className = 'values';\n\t  domTree.appendChild(tbody);\n\t  var tr = document.createElement('tr');\n\t  tbody.appendChild(tr);\n\n\t  // create expand button\n\t  var tdExpand = document.createElement('td');\n\t  tdExpand.className = 'tree';\n\t  tr.appendChild(tdExpand);\n\t  dom.expand = this._createDomExpandButton();\n\t  tdExpand.appendChild(dom.expand);\n\t  dom.tdExpand = tdExpand;\n\n\t  // create the field\n\t  var tdField = document.createElement('td');\n\t  tdField.className = 'tree';\n\t  tr.appendChild(tdField);\n\t  dom.field = this._createDomField();\n\t  tdField.appendChild(dom.field);\n\t  dom.tdField = tdField;\n\n\t  // create a separator\n\t  var tdSeparator = document.createElement('td');\n\t  tdSeparator.className = 'tree';\n\t  tr.appendChild(tdSeparator);\n\t  if (this.type != 'object' && this.type != 'array') {\n\t    tdSeparator.appendChild(document.createTextNode(':'));\n\t    tdSeparator.className = 'separator';\n\t  }\n\t  dom.tdSeparator = tdSeparator;\n\n\t  // create the value\n\t  var tdValue = document.createElement('td');\n\t  tdValue.className = 'tree';\n\t  tr.appendChild(tdValue);\n\t  dom.value = this._createDomValue();\n\t  tdValue.appendChild(dom.value);\n\t  dom.tdValue = tdValue;\n\n\t  return domTree;\n\t};\n\n\t/**\n\t * Handle an event. The event is catched centrally by the editor\n\t * @param {Event} event\n\t */\n\tNode.prototype.onEvent = function (event) {\n\t  var type = event.type,\n\t      target = event.target || event.srcElement,\n\t      dom = this.dom,\n\t      node = this,\n\t      focusNode,\n\t      expandable = this._hasChilds();\n\n\t  // check if mouse is on menu or on dragarea.\n\t  // If so, highlight current row and its childs\n\t  if (target == dom.drag || target == dom.menu) {\n\t    if (type == 'mouseover') {\n\t      this.editor.highlighter.highlight(this);\n\t    }\n\t    else if (type == 'mouseout') {\n\t      this.editor.highlighter.unhighlight();\n\t    }\n\t  }\n\n\t  // drag events\n\t  if (type == 'mousedown' && target == dom.drag) {\n\t    this._onDragStart(event);\n\t  }\n\n\t  // context menu events\n\t  if (type == 'click' && target == dom.menu) {\n\t    var highlighter = node.editor.highlighter;\n\t    highlighter.highlight(node);\n\t    highlighter.lock();\n\t    util.addClassName(dom.menu, 'selected');\n\t    this.showContextMenu(dom.menu, function () {\n\t      util.removeClassName(dom.menu, 'selected');\n\t      highlighter.unlock();\n\t      highlighter.unhighlight();\n\t    });\n\t  }\n\n\t  // expand events\n\t  if (type == 'click' && target == dom.expand) {\n\t    if (expandable) {\n\t      var recurse = event.ctrlKey; // with ctrl-key, expand/collapse all\n\t      this._onExpand(recurse);\n\t    }\n\t  }\n\n\t  // value events\n\t  var domValue = dom.value;\n\t  if (target == domValue) {\n\t    //noinspection FallthroughInSwitchStatementJS\n\t    switch (type) {\n\t      case 'focus':\n\t        focusNode = this;\n\t        break;\n\n\t      case 'blur':\n\t      case 'change':\n\t        this._getDomValue(true);\n\t        this._updateDomValue();\n\t        if (this.value) {\n\t          domValue.innerHTML = this._escapeHTML(this.value);\n\t        }\n\t        break;\n\n\t      case 'input':\n\t        this._getDomValue(true);\n\t        this._updateDomValue();\n\t        break;\n\n\t      case 'keydown':\n\t      case 'mousedown':\n\t        this.editor.selection = this.editor.getSelection();\n\t        break;\n\n\t      case 'click':\n\t        if (event.ctrlKey || !this.editable.value) {\n\t          if (util.isUrl(this.value)) {\n\t            window.open(this.value, '_blank');\n\t          }\n\t        }\n\t        break;\n\n\t      case 'keyup':\n\t        this._getDomValue(true);\n\t        this._updateDomValue();\n\t        break;\n\n\t      case 'cut':\n\t      case 'paste':\n\t        setTimeout(function () {\n\t          node._getDomValue(true);\n\t          node._updateDomValue();\n\t        }, 1);\n\t        break;\n\t    }\n\t  }\n\n\t  // field events\n\t  var domField = dom.field;\n\t  if (target == domField) {\n\t    switch (type) {\n\t      case 'focus':\n\t        focusNode = this;\n\t        break;\n\n\t      case 'blur':\n\t      case 'change':\n\t        this._getDomField(true);\n\t        this._updateDomField();\n\t        if (this.field) {\n\t          domField.innerHTML = this._escapeHTML(this.field);\n\t        }\n\t        break;\n\n\t      case 'input':\n\t        this._getDomField(true);\n\t        this._updateDomField();\n\t        break;\n\n\t      case 'keydown':\n\t      case 'mousedown':\n\t        this.editor.selection = this.editor.getSelection();\n\t        break;\n\n\t      case 'keyup':\n\t        this._getDomField(true);\n\t        this._updateDomField();\n\t        break;\n\n\t      case 'cut':\n\t      case 'paste':\n\t        setTimeout(function () {\n\t          node._getDomField(true);\n\t          node._updateDomField();\n\t        }, 1);\n\t        break;\n\t    }\n\t  }\n\n\t  // focus\n\t  // when clicked in whitespace left or right from the field or value, set focus\n\t  var domTree = dom.tree;\n\t  if (target == domTree.parentNode) {\n\t    switch (type) {\n\t      case 'click':\n\t        var left = (event.offsetX != undefined) ?\n\t            (event.offsetX < (this.getLevel() + 1) * 24) :\n\t            (event.pageX < util.getAbsoluteLeft(dom.tdSeparator));// for FF\n\t        if (left || expandable) {\n\t          // node is expandable when it is an object or array\n\t          if (domField) {\n\t            util.setEndOfContentEditable(domField);\n\t            domField.focus();\n\t          }\n\t        }\n\t        else {\n\t          if (domValue) {\n\t            util.setEndOfContentEditable(domValue);\n\t            domValue.focus();\n\t          }\n\t        }\n\t        break;\n\t    }\n\t  }\n\t  if ((target == dom.tdExpand && !expandable) || target == dom.tdField ||\n\t      target == dom.tdSeparator) {\n\t    switch (type) {\n\t      case 'click':\n\t        if (domField) {\n\t          util.setEndOfContentEditable(domField);\n\t          domField.focus();\n\t        }\n\t        break;\n\t    }\n\t  }\n\n\t  if (type == 'keydown') {\n\t    this.onKeyDown(event);\n\t  }\n\t};\n\n\t/**\n\t * Key down event handler\n\t * @param {Event} event\n\t */\n\tNode.prototype.onKeyDown = function (event) {\n\t  var keynum = event.which || event.keyCode;\n\t  var target = event.target || event.srcElement;\n\t  var ctrlKey = event.ctrlKey;\n\t  var shiftKey = event.shiftKey;\n\t  var altKey = event.altKey;\n\t  var handled = false;\n\t  var prevNode, nextNode, nextDom, nextDom2;\n\t  var editable = this.editor.options.mode === 'tree';\n\n\t  // util.log(ctrlKey, keynum, event.charCode); // TODO: cleanup\n\t  if (keynum == 13) { // Enter\n\t    if (target == this.dom.value) {\n\t      if (!this.editable.value || event.ctrlKey) {\n\t        if (util.isUrl(this.value)) {\n\t          window.open(this.value, '_blank');\n\t          handled = true;\n\t        }\n\t      }\n\t    }\n\t    else if (target == this.dom.expand) {\n\t      var expandable = this._hasChilds();\n\t      if (expandable) {\n\t        var recurse = event.ctrlKey; // with ctrl-key, expand/collapse all\n\t        this._onExpand(recurse);\n\t        target.focus();\n\t        handled = true;\n\t      }\n\t    }\n\t  }\n\t  else if (keynum == 68) {  // D\n\t    if (ctrlKey && editable) {   // Ctrl+D\n\t      this._onDuplicate();\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 69) { // E\n\t    if (ctrlKey) {       // Ctrl+E and Ctrl+Shift+E\n\t      this._onExpand(shiftKey);  // recurse = shiftKey\n\t      target.focus(); // TODO: should restore focus in case of recursing expand (which takes DOM offline)\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 77 && editable) { // M\n\t    if (ctrlKey) { // Ctrl+M\n\t      this.showContextMenu(target);\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 46 && editable) { // Del\n\t    if (ctrlKey) {       // Ctrl+Del\n\t      this._onRemove();\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 45 && editable) { // Ins\n\t    if (ctrlKey && !shiftKey) {       // Ctrl+Ins\n\t      this._onInsertBefore();\n\t      handled = true;\n\t    }\n\t    else if (ctrlKey && shiftKey) {   // Ctrl+Shift+Ins\n\t      this._onInsertAfter();\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 35) { // End\n\t    if (altKey) { // Alt+End\n\t      // find the last node\n\t      var lastNode = this._lastNode();\n\t      if (lastNode) {\n\t        lastNode.focus(Node.focusElement || this._getElementName(target));\n\t      }\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 36) { // Home\n\t    if (altKey) { // Alt+Home\n\t      // find the first node\n\t      var firstNode = this._firstNode();\n\t      if (firstNode) {\n\t        firstNode.focus(Node.focusElement || this._getElementName(target));\n\t      }\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 37) {        // Arrow Left\n\t    if (altKey && !shiftKey) {  // Alt + Arrow Left\n\t      // move to left element\n\t      var prevElement = this._previousElement(target);\n\t      if (prevElement) {\n\t        this.focus(this._getElementName(prevElement));\n\t      }\n\t      handled = true;\n\t    }\n\t    else if (altKey && shiftKey && editable) { // Alt + Shift Arrow left\n\t      if (this.expanded) {\n\t        var appendDom = this.getAppend();\n\t        nextDom = appendDom ? appendDom.nextSibling : undefined;\n\t      }\n\t      else {\n\t        var dom = this.getDom();\n\t        nextDom = dom.nextSibling;\n\t      }\n\t      if (nextDom) {\n\t        nextNode = Node.getNodeFromTarget(nextDom);\n\t        nextDom2 = nextDom.nextSibling;\n\t        nextNode2 = Node.getNodeFromTarget(nextDom2);\n\t        if (nextNode && nextNode instanceof AppendNode &&\n\t            !(this.parent.childs.length == 1) &&\n\t            nextNode2 && nextNode2.parent) {\n\t          nextNode2.parent.moveBefore(this, nextNode2);\n\t          this.focus(Node.focusElement || this._getElementName(target));\n\t        }\n\t      }\n\t    }\n\t  }\n\t  else if (keynum == 38) {        // Arrow Up\n\t    if (altKey && !shiftKey) {  // Alt + Arrow Up\n\t      // find the previous node\n\t      prevNode = this._previousNode();\n\t      if (prevNode) {\n\t        prevNode.focus(Node.focusElement || this._getElementName(target));\n\t      }\n\t      handled = true;\n\t    }\n\t    else if (altKey && shiftKey) { // Alt + Shift + Arrow Up\n\t      // find the previous node\n\t      prevNode = this._previousNode();\n\t      if (prevNode && prevNode.parent) {\n\t        prevNode.parent.moveBefore(this, prevNode);\n\t        this.focus(Node.focusElement || this._getElementName(target));\n\t      }\n\t      handled = true;\n\t    }\n\t  }\n\t  else if (keynum == 39) {        // Arrow Right\n\t    if (altKey && !shiftKey) {  // Alt + Arrow Right\n\t      // move to right element\n\t      var nextElement = this._nextElement(target);\n\t      if (nextElement) {\n\t        this.focus(this._getElementName(nextElement));\n\t      }\n\t      handled = true;\n\t    }\n\t    else if (altKey && shiftKey) { // Alt + Shift Arrow Right\n\t      dom = this.getDom();\n\t      var prevDom = dom.previousSibling;\n\t      if (prevDom) {\n\t        prevNode = Node.getNodeFromTarget(prevDom);\n\t        if (prevNode && prevNode.parent &&\n\t            (prevNode instanceof AppendNode)\n\t            && !prevNode.isVisible()) {\n\t          prevNode.parent.moveBefore(this, prevNode);\n\t          this.focus(Node.focusElement || this._getElementName(target));\n\t        }\n\t      }\n\t    }\n\t  }\n\t  else if (keynum == 40) {        // Arrow Down\n\t    if (altKey && !shiftKey) {  // Alt + Arrow Down\n\t      // find the next node\n\t      nextNode = this._nextNode();\n\t      if (nextNode) {\n\t        nextNode.focus(Node.focusElement || this._getElementName(target));\n\t      }\n\t      handled = true;\n\t    }\n\t    else if (altKey && shiftKey && editable) { // Alt + Shift + Arrow Down\n\t      // find the 2nd next node and move before that one\n\t      if (this.expanded) {\n\t        nextNode = this.append ? this.append._nextNode() : undefined;\n\t      }\n\t      else {\n\t        nextNode = this._nextNode();\n\t      }\n\t      nextDom = nextNode ? nextNode.getDom() : undefined;\n\t      if (this.parent.childs.length == 1) {\n\t        nextDom2 = nextDom;\n\t      }\n\t      else {\n\t        nextDom2 = nextDom ? nextDom.nextSibling : undefined;\n\t      }\n\t      var nextNode2 = Node.getNodeFromTarget(nextDom2);\n\t      if (nextNode2 && nextNode2.parent) {\n\t        nextNode2.parent.moveBefore(this, nextNode2);\n\t        this.focus(Node.focusElement || this._getElementName(target));\n\t      }\n\t      handled = true;\n\t    }\n\t  }\n\n\t  if (handled) {\n\t    event.preventDefault();\n\t    event.stopPropagation();\n\t  }\n\t};\n\n\t/**\n\t * Handle the expand event, when clicked on the expand button\n\t * @param {boolean} recurse   If true, child nodes will be expanded too\n\t * @private\n\t */\n\tNode.prototype._onExpand = function (recurse) {\n\t  if (recurse) {\n\t    // Take the table offline\n\t    var table = this.dom.tr.parentNode; // TODO: not nice to access the main table like this\n\t    var frame = table.parentNode;\n\t    var scrollTop = frame.scrollTop;\n\t    frame.removeChild(table);\n\t  }\n\n\t  if (this.expanded) {\n\t    this.collapse(recurse);\n\t  }\n\t  else {\n\t    this.expand(recurse);\n\t  }\n\n\t  if (recurse) {\n\t    // Put the table online again\n\t    frame.appendChild(table);\n\t    frame.scrollTop = scrollTop;\n\t  }\n\t};\n\n\t/**\n\t * Remove this node\n\t * @private\n\t */\n\tNode.prototype._onRemove = function() {\n\t  this.editor.highlighter.unhighlight();\n\t  var childs = this.parent.childs;\n\t  var index = childs.indexOf(this);\n\n\t  // adjust the focus\n\t  var oldSelection = this.editor.getSelection();\n\t  if (childs[index + 1]) {\n\t    childs[index + 1].focus();\n\t  }\n\t  else if (childs[index - 1]) {\n\t    childs[index - 1].focus();\n\t  }\n\t  else {\n\t    this.parent.focus();\n\t  }\n\t  var newSelection = this.editor.getSelection();\n\n\t  // remove the node\n\t  this.parent._remove(this);\n\n\t  // store history action\n\t  this.editor._onAction('removeNode', {\n\t    node: this,\n\t    parent: this.parent,\n\t    index: index,\n\t    oldSelection: oldSelection,\n\t    newSelection: newSelection\n\t  });\n\t};\n\n\t/**\n\t * Duplicate this node\n\t * @private\n\t */\n\tNode.prototype._onDuplicate = function() {\n\t  var oldSelection = this.editor.getSelection();\n\t  var clone = this.parent._duplicate(this);\n\t  clone.focus();\n\t  var newSelection = this.editor.getSelection();\n\n\t  this.editor._onAction('duplicateNode', {\n\t    node: this,\n\t    clone: clone,\n\t    parent: this.parent,\n\t    oldSelection: oldSelection,\n\t    newSelection: newSelection\n\t  });\n\t};\n\n\t/**\n\t * Handle insert before event\n\t * @param {String} [field]\n\t * @param {*} [value]\n\t * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n\t * @private\n\t */\n\tNode.prototype._onInsertBefore = function (field, value, type) {\n\t  var oldSelection = this.editor.getSelection();\n\n\t  var newNode = new Node(this.editor, {\n\t    field: (field != undefined) ? field : '',\n\t    value: (value != undefined) ? value : '',\n\t    type: type\n\t  });\n\t  newNode.expand(true);\n\t  this.parent.insertBefore(newNode, this);\n\t  this.editor.highlighter.unhighlight();\n\t  newNode.focus('field');\n\t  var newSelection = this.editor.getSelection();\n\n\t  this.editor._onAction('insertBeforeNode', {\n\t    node: newNode,\n\t    beforeNode: this,\n\t    parent: this.parent,\n\t    oldSelection: oldSelection,\n\t    newSelection: newSelection\n\t  });\n\t};\n\n\t/**\n\t * Handle insert after event\n\t * @param {String} [field]\n\t * @param {*} [value]\n\t * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n\t * @private\n\t */\n\tNode.prototype._onInsertAfter = function (field, value, type) {\n\t  var oldSelection = this.editor.getSelection();\n\n\t  var newNode = new Node(this.editor, {\n\t    field: (field != undefined) ? field : '',\n\t    value: (value != undefined) ? value : '',\n\t    type: type\n\t  });\n\t  newNode.expand(true);\n\t  this.parent.insertAfter(newNode, this);\n\t  this.editor.highlighter.unhighlight();\n\t  newNode.focus('field');\n\t  var newSelection = this.editor.getSelection();\n\n\t  this.editor._onAction('insertAfterNode', {\n\t    node: newNode,\n\t    afterNode: this,\n\t    parent: this.parent,\n\t    oldSelection: oldSelection,\n\t    newSelection: newSelection\n\t  });\n\t};\n\n\t/**\n\t * Handle append event\n\t * @param {String} [field]\n\t * @param {*} [value]\n\t * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n\t * @private\n\t */\n\tNode.prototype._onAppend = function (field, value, type) {\n\t  var oldSelection = this.editor.getSelection();\n\n\t  var newNode = new Node(this.editor, {\n\t    field: (field != undefined) ? field : '',\n\t    value: (value != undefined) ? value : '',\n\t    type: type\n\t  });\n\t  newNode.expand(true);\n\t  this.parent.appendChild(newNode);\n\t  this.editor.highlighter.unhighlight();\n\t  newNode.focus('field');\n\t  var newSelection = this.editor.getSelection();\n\n\t  this.editor._onAction('appendNode', {\n\t    node: newNode,\n\t    parent: this.parent,\n\t    oldSelection: oldSelection,\n\t    newSelection: newSelection\n\t  });\n\t};\n\n\t/**\n\t * Change the type of the node's value\n\t * @param {String} newType\n\t * @private\n\t */\n\tNode.prototype._onChangeType = function (newType) {\n\t  var oldType = this.type;\n\t  if (newType != oldType) {\n\t    var oldSelection = this.editor.getSelection();\n\t    this.changeType(newType);\n\t    var newSelection = this.editor.getSelection();\n\n\t    this.editor._onAction('changeType', {\n\t      node: this,\n\t      oldType: oldType,\n\t      newType: newType,\n\t      oldSelection: oldSelection,\n\t      newSelection: newSelection\n\t    });\n\t  }\n\t};\n\n\t/**\n\t * Sort the childs of the node. Only applicable when the node has type 'object'\n\t * or 'array'.\n\t * @param {String} direction   Sorting direction. Available values: \"asc\", \"desc\"\n\t * @private\n\t */\n\tNode.prototype._onSort = function (direction) {\n\t  if (this._hasChilds()) {\n\t    var order = (direction == 'desc') ? -1 : 1;\n\t    var prop = (this.type == 'array') ? 'value': 'field';\n\t    this.hideChilds();\n\n\t    var oldChilds = this.childs;\n\t    var oldSort = this.sort;\n\n\t    // copy the array (the old one will be kept for an undo action\n\t    this.childs = this.childs.concat();\n\n\t    // sort the arrays\n\t    this.childs.sort(function (a, b) {\n\t      if (a[prop] > b[prop]) return order;\n\t      if (a[prop] < b[prop]) return -order;\n\t      return 0;\n\t    });\n\t    this.sort = (order == 1) ? 'asc' : 'desc';\n\n\t    this.editor._onAction('sort', {\n\t      node: this,\n\t      oldChilds: oldChilds,\n\t      oldSort: oldSort,\n\t      newChilds: this.childs,\n\t      newSort: this.sort\n\t    });\n\n\t    this.showChilds();\n\t  }\n\t};\n\n\t/**\n\t * Create a table row with an append button.\n\t * @return {HTMLElement | undefined} buttonAppend or undefined when inapplicable\n\t */\n\tNode.prototype.getAppend = function () {\n\t  if (!this.append) {\n\t    this.append = new AppendNode(this.editor);\n\t    this.append.setParent(this);\n\t  }\n\t  return this.append.getDom();\n\t};\n\n\t/**\n\t * Find the node from an event target\n\t * @param {Node} target\n\t * @return {Node | undefined} node  or undefined when not found\n\t * @static\n\t */\n\tNode.getNodeFromTarget = function (target) {\n\t  while (target) {\n\t    if (target.node) {\n\t      return target.node;\n\t    }\n\t    target = target.parentNode;\n\t  }\n\n\t  return undefined;\n\t};\n\n\t/**\n\t * Get the previously rendered node\n\t * @return {Node | null} previousNode\n\t * @private\n\t */\n\tNode.prototype._previousNode = function () {\n\t  var prevNode = null;\n\t  var dom = this.getDom();\n\t  if (dom && dom.parentNode) {\n\t    // find the previous field\n\t    var prevDom = dom;\n\t    do {\n\t      prevDom = prevDom.previousSibling;\n\t      prevNode = Node.getNodeFromTarget(prevDom);\n\t    }\n\t    while (prevDom && (prevNode instanceof AppendNode && !prevNode.isVisible()));\n\t  }\n\t  return prevNode;\n\t};\n\n\t/**\n\t * Get the next rendered node\n\t * @return {Node | null} nextNode\n\t * @private\n\t */\n\tNode.prototype._nextNode = function () {\n\t  var nextNode = null;\n\t  var dom = this.getDom();\n\t  if (dom && dom.parentNode) {\n\t    // find the previous field\n\t    var nextDom = dom;\n\t    do {\n\t      nextDom = nextDom.nextSibling;\n\t      nextNode = Node.getNodeFromTarget(nextDom);\n\t    }\n\t    while (nextDom && (nextNode instanceof AppendNode && !nextNode.isVisible()));\n\t  }\n\n\t  return nextNode;\n\t};\n\n\t/**\n\t * Get the first rendered node\n\t * @return {Node | null} firstNode\n\t * @private\n\t */\n\tNode.prototype._firstNode = function () {\n\t  var firstNode = null;\n\t  var dom = this.getDom();\n\t  if (dom && dom.parentNode) {\n\t    var firstDom = dom.parentNode.firstChild;\n\t    firstNode = Node.getNodeFromTarget(firstDom);\n\t  }\n\n\t  return firstNode;\n\t};\n\n\t/**\n\t * Get the last rendered node\n\t * @return {Node | null} lastNode\n\t * @private\n\t */\n\tNode.prototype._lastNode = function () {\n\t  var lastNode = null;\n\t  var dom = this.getDom();\n\t  if (dom && dom.parentNode) {\n\t    var lastDom = dom.parentNode.lastChild;\n\t    lastNode =  Node.getNodeFromTarget(lastDom);\n\t    while (lastDom && (lastNode instanceof AppendNode && !lastNode.isVisible())) {\n\t      lastDom = lastDom.previousSibling;\n\t      lastNode =  Node.getNodeFromTarget(lastDom);\n\t    }\n\t  }\n\t  return lastNode;\n\t};\n\n\t/**\n\t * Get the next element which can have focus.\n\t * @param {Element} elem\n\t * @return {Element | null} nextElem\n\t * @private\n\t */\n\tNode.prototype._previousElement = function (elem) {\n\t  var dom = this.dom;\n\t  // noinspection FallthroughInSwitchStatementJS\n\t  switch (elem) {\n\t    case dom.value:\n\t      if (this.fieldEditable) {\n\t        return dom.field;\n\t      }\n\t    // intentional fall through\n\t    case dom.field:\n\t      if (this._hasChilds()) {\n\t        return dom.expand;\n\t      }\n\t    // intentional fall through\n\t    case dom.expand:\n\t      return dom.menu;\n\t    case dom.menu:\n\t      if (dom.drag) {\n\t        return dom.drag;\n\t      }\n\t    // intentional fall through\n\t    default:\n\t      return null;\n\t  }\n\t};\n\n\t/**\n\t * Get the next element which can have focus.\n\t * @param {Element} elem\n\t * @return {Element | null} nextElem\n\t * @private\n\t */\n\tNode.prototype._nextElement = function (elem) {\n\t  var dom = this.dom;\n\t  // noinspection FallthroughInSwitchStatementJS\n\t  switch (elem) {\n\t    case dom.drag:\n\t      return dom.menu;\n\t    case dom.menu:\n\t      if (this._hasChilds()) {\n\t        return dom.expand;\n\t      }\n\t    // intentional fall through\n\t    case dom.expand:\n\t      if (this.fieldEditable) {\n\t        return dom.field;\n\t      }\n\t    // intentional fall through\n\t    case dom.field:\n\t      if (!this._hasChilds()) {\n\t        return dom.value;\n\t      }\n\t    default:\n\t      return null;\n\t  }\n\t};\n\n\t/**\n\t * Get the dom name of given element. returns null if not found.\n\t * For example when element == dom.field, \"field\" is returned.\n\t * @param {Element} element\n\t * @return {String | null} elementName  Available elements with name: 'drag',\n\t *                                      'menu', 'expand', 'field', 'value'\n\t * @private\n\t */\n\tNode.prototype._getElementName = function (element) {\n\t  var dom = this.dom;\n\t  for (var name in dom) {\n\t    if (dom.hasOwnProperty(name)) {\n\t      if (dom[name] == element) {\n\t        return name;\n\t      }\n\t    }\n\t  }\n\t  return null;\n\t};\n\n\t/**\n\t * Test if this node has childs. This is the case when the node is an object\n\t * or array.\n\t * @return {boolean} hasChilds\n\t * @private\n\t */\n\tNode.prototype._hasChilds = function () {\n\t  return this.type == 'array' || this.type == 'object';\n\t};\n\n\t// titles with explanation for the different types\n\tNode.TYPE_TITLES = {\n\t  'auto': 'Field type \"auto\". ' +\n\t      'The field type is automatically determined from the value ' +\n\t      'and can be a string, number, boolean, or null.',\n\t  'object': 'Field type \"object\". ' +\n\t      'An object contains an unordered set of key/value pairs.',\n\t  'array': 'Field type \"array\". ' +\n\t      'An array contains an ordered collection of values.',\n\t  'string': 'Field type \"string\". ' +\n\t      'Field type is not determined from the value, ' +\n\t      'but always returned as string.'\n\t};\n\n\t/**\n\t * Show a contextmenu for this node\n\t * @param {HTMLElement} anchor   Anchor element to attache the context menu to.\n\t * @param {function} [onClose]   Callback method called when the context menu\n\t *                               is being closed.\n\t */\n\tNode.prototype.showContextMenu = function (anchor, onClose) {\n\t  var node = this;\n\t  var titles = Node.TYPE_TITLES;\n\t  var items = [];\n\n\t  if (this.editable.value) {\n\t    items.push({\n\t      text: 'Type',\n\t      title: 'Change the type of this field',\n\t      className: 'type-' + this.type,\n\t      submenu: [\n\t        {\n\t          text: 'Auto',\n\t          className: 'type-auto' +\n\t              (this.type == 'auto' ? ' selected' : ''),\n\t          title: titles.auto,\n\t          click: function () {\n\t            node._onChangeType('auto');\n\t          }\n\t        },\n\t        {\n\t          text: 'Array',\n\t          className: 'type-array' +\n\t              (this.type == 'array' ? ' selected' : ''),\n\t          title: titles.array,\n\t          click: function () {\n\t            node._onChangeType('array');\n\t          }\n\t        },\n\t        {\n\t          text: 'Object',\n\t          className: 'type-object' +\n\t              (this.type == 'object' ? ' selected' : ''),\n\t          title: titles.object,\n\t          click: function () {\n\t            node._onChangeType('object');\n\t          }\n\t        },\n\t        {\n\t          text: 'String',\n\t          className: 'type-string' +\n\t              (this.type == 'string' ? ' selected' : ''),\n\t          title: titles.string,\n\t          click: function () {\n\t            node._onChangeType('string');\n\t          }\n\t        }\n\t      ]\n\t    });\n\t  }\n\n\t  if (this._hasChilds()) {\n\t    var direction = ((this.sort == 'asc') ? 'desc': 'asc');\n\t    items.push({\n\t      text: 'Sort',\n\t      title: 'Sort the childs of this ' + this.type,\n\t      className: 'sort-' + direction,\n\t      click: function () {\n\t        node._onSort(direction);\n\t      },\n\t      submenu: [\n\t        {\n\t          text: 'Ascending',\n\t          className: 'sort-asc',\n\t          title: 'Sort the childs of this ' + this.type + ' in ascending order',\n\t          click: function () {\n\t            node._onSort('asc');\n\t          }\n\t        },\n\t        {\n\t          text: 'Descending',\n\t          className: 'sort-desc',\n\t          title: 'Sort the childs of this ' + this.type +' in descending order',\n\t          click: function () {\n\t            node._onSort('desc');\n\t          }\n\t        }\n\t      ]\n\t    });\n\t  }\n\n\t  if (this.parent && this.parent._hasChilds()) {\n\t    if (items.length) {\n\t      // create a separator\n\t      items.push({\n\t        'type': 'separator'\n\t      });\n\t    }\n\n\t    // create append button (for last child node only)\n\t    var childs = node.parent.childs;\n\t    if (node == childs[childs.length - 1]) {\n\t      items.push({\n\t        text: 'Append',\n\t        title: 'Append a new field with type \\'auto\\' after this field (Ctrl+Shift+Ins)',\n\t        submenuTitle: 'Select the type of the field to be appended',\n\t        className: 'append',\n\t        click: function () {\n\t          node._onAppend('', '', 'auto');\n\t        },\n\t        submenu: [\n\t          {\n\t            text: 'Auto',\n\t            className: 'type-auto',\n\t            title: titles.auto,\n\t            click: function () {\n\t              node._onAppend('', '', 'auto');\n\t            }\n\t          },\n\t          {\n\t            text: 'Array',\n\t            className: 'type-array',\n\t            title: titles.array,\n\t            click: function () {\n\t              node._onAppend('', []);\n\t            }\n\t          },\n\t          {\n\t            text: 'Object',\n\t            className: 'type-object',\n\t            title: titles.object,\n\t            click: function () {\n\t              node._onAppend('', {});\n\t            }\n\t          },\n\t          {\n\t            text: 'String',\n\t            className: 'type-string',\n\t            title: titles.string,\n\t            click: function () {\n\t              node._onAppend('', '', 'string');\n\t            }\n\t          }\n\t        ]\n\t      });\n\t    }\n\n\t    // create insert button\n\t    items.push({\n\t      text: 'Insert',\n\t      title: 'Insert a new field with type \\'auto\\' before this field (Ctrl+Ins)',\n\t      submenuTitle: 'Select the type of the field to be inserted',\n\t      className: 'insert',\n\t      click: function () {\n\t        node._onInsertBefore('', '', 'auto');\n\t      },\n\t      submenu: [\n\t        {\n\t          text: 'Auto',\n\t          className: 'type-auto',\n\t          title: titles.auto,\n\t          click: function () {\n\t            node._onInsertBefore('', '', 'auto');\n\t          }\n\t        },\n\t        {\n\t          text: 'Array',\n\t          className: 'type-array',\n\t          title: titles.array,\n\t          click: function () {\n\t            node._onInsertBefore('', []);\n\t          }\n\t        },\n\t        {\n\t          text: 'Object',\n\t          className: 'type-object',\n\t          title: titles.object,\n\t          click: function () {\n\t            node._onInsertBefore('', {});\n\t          }\n\t        },\n\t        {\n\t          text: 'String',\n\t          className: 'type-string',\n\t          title: titles.string,\n\t          click: function () {\n\t            node._onInsertBefore('', '', 'string');\n\t          }\n\t        }\n\t      ]\n\t    });\n\n\t    if (this.editable.field) {\n\t      // create duplicate button\n\t      items.push({\n\t        text: 'Duplicate',\n\t        title: 'Duplicate this field (Ctrl+D)',\n\t        className: 'duplicate',\n\t        click: function () {\n\t          node._onDuplicate();\n\t        }\n\t      });\n\n\t      // create remove button\n\t      items.push({\n\t        text: 'Remove',\n\t        title: 'Remove this field (Ctrl+Del)',\n\t        className: 'remove',\n\t        click: function () {\n\t          node._onRemove();\n\t        }\n\t      });\n\t    }\n\t  }\n\n\t  var menu = new ContextMenu(items, {close: onClose});\n\t  menu.show(anchor);\n\t};\n\n\t/**\n\t * get the type of a value\n\t * @param {*} value\n\t * @return {String} type   Can be 'object', 'array', 'string', 'auto'\n\t * @private\n\t */\n\tNode.prototype._getType = function(value) {\n\t  if (value instanceof Array) {\n\t    return 'array';\n\t  }\n\t  if (value instanceof Object) {\n\t    return 'object';\n\t  }\n\t  if (typeof(value) == 'string' && typeof(this._stringCast(value)) != 'string') {\n\t    return 'string';\n\t  }\n\n\t  return 'auto';\n\t};\n\n\t/**\n\t * cast contents of a string to the correct type. This can be a string,\n\t * a number, a boolean, etc\n\t * @param {String} str\n\t * @return {*} castedStr\n\t * @private\n\t */\n\tNode.prototype._stringCast = function(str) {\n\t  var lower = str.toLowerCase(),\n\t      num = Number(str),          // will nicely fail with '123ab'\n\t      numFloat = parseFloat(str); // will nicely fail with '  '\n\n\t  if (str == '') {\n\t    return '';\n\t  }\n\t  else if (lower == 'null') {\n\t    return null;\n\t  }\n\t  else if (lower == 'true') {\n\t    return true;\n\t  }\n\t  else if (lower == 'false') {\n\t    return false;\n\t  }\n\t  else if (!isNaN(num) && !isNaN(numFloat)) {\n\t    return num;\n\t  }\n\t  else {\n\t    return str;\n\t  }\n\t};\n\n\t/**\n\t * escape a text, such that it can be displayed safely in an HTML element\n\t * @param {String} text\n\t * @return {String} escapedText\n\t * @private\n\t */\n\tNode.prototype._escapeHTML = function (text) {\n\t  var htmlEscaped = String(text)\n\t      .replace(/</g, '&lt;')\n\t      .replace(/>/g, '&gt;')\n\t      .replace(/  /g, ' &nbsp;') // replace double space with an nbsp and space\n\t      .replace(/^ /, '&nbsp;')   // space at start\n\t      .replace(/ $/, '&nbsp;');  // space at end\n\n\t  var json = JSON.stringify(htmlEscaped);\n\t  return json.substring(1, json.length - 1);\n\t};\n\n\t/**\n\t * unescape a string.\n\t * @param {String} escapedText\n\t * @return {String} text\n\t * @private\n\t */\n\tNode.prototype._unescapeHTML = function (escapedText) {\n\t  var json = '\"' + this._escapeJSON(escapedText) + '\"';\n\t  var htmlEscaped = util.parse(json);\n\t  return htmlEscaped\n\t      .replace(/&lt;/g, '<')\n\t      .replace(/&gt;/g, '>')\n\t      .replace(/&nbsp;|\\u00A0/g, ' ');\n\t};\n\n\t/**\n\t * escape a text to make it a valid JSON string. The method will:\n\t *   - replace unescaped double quotes with '\\\"'\n\t *   - replace unescaped backslash with '\\\\'\n\t *   - replace returns with '\\n'\n\t * @param {String} text\n\t * @return {String} escapedText\n\t * @private\n\t */\n\tNode.prototype._escapeJSON = function (text) {\n\t  // TODO: replace with some smart regex (only when a new solution is faster!)\n\t  var escaped = '';\n\t  var i = 0, iMax = text.length;\n\t  while (i < iMax) {\n\t    var c = text.charAt(i);\n\t    if (c == '\\n') {\n\t      escaped += '\\\\n';\n\t    }\n\t    else if (c == '\\\\') {\n\t      escaped += c;\n\t      i++;\n\n\t      c = text.charAt(i);\n\t      if ('\"\\\\/bfnrtu'.indexOf(c) == -1) {\n\t        escaped += '\\\\';  // no valid escape character\n\t      }\n\t      escaped += c;\n\t    }\n\t    else if (c == '\"') {\n\t      escaped += '\\\\\"';\n\t    }\n\t    else {\n\t      escaped += c;\n\t    }\n\t    i++;\n\t  }\n\n\t  return escaped;\n\t};\n\n\t// TODO: find a nicer solution to resolve this circular dependency between Node and AppendNode\n\tvar AppendNode = appendNodeFactory(Node);\n\n\tmodule.exports = Node;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ContextMenu = __webpack_require__(10);\n\n\t/**\n\t * Create a select box to be used in the editor menu's, which allows to switch mode\n\t * @param {Object} editor\n\t * @param {String[]} modes  Available modes: 'code', 'form', 'text', 'tree', 'view'\n\t * @param {String} current  Available modes: 'code', 'form', 'text', 'tree', 'view'\n\t * @returns {HTMLElement} box\n\t */\n\tfunction createModeSwitcher(editor, modes, current) {\n\t  // TODO: decouple mode switcher from editor\n\n\t  /**\n\t   * Switch the mode of the editor\n\t   * @param {String} mode\n\t   */\n\t  function switchMode(mode) {\n\t    // switch mode\n\t    editor.setMode(mode);\n\n\t    // restore focus on mode box\n\t    var modeBox = editor.dom && editor.dom.modeBox;\n\t    if (modeBox) {\n\t      modeBox.focus();\n\t    }\n\t  }\n\n\t  // available modes\n\t  var availableModes = {\n\t    code: {\n\t      'text': 'Code',\n\t      'title': 'Switch to code highlighter',\n\t      'click': function () {\n\t        switchMode('code')\n\t      }\n\t    },\n\t    form: {\n\t      'text': 'Form',\n\t      'title': 'Switch to form editor',\n\t      'click': function () {\n\t        switchMode('form');\n\t      }\n\t    },\n\t    text: {\n\t      'text': 'Text',\n\t      'title': 'Switch to plain text editor',\n\t      'click': function () {\n\t        switchMode('text');\n\t      }\n\t    },\n\t    tree: {\n\t      'text': 'Tree',\n\t      'title': 'Switch to tree editor',\n\t      'click': function () {\n\t        switchMode('tree');\n\t      }\n\t    },\n\t    view: {\n\t      'text': 'View',\n\t      'title': 'Switch to tree view',\n\t      'click': function () {\n\t        switchMode('view');\n\t      }\n\t    }\n\t  };\n\n\t  // list the selected modes\n\t  var items = [];\n\t  for (var i = 0; i < modes.length; i++) {\n\t    var mode = modes[i];\n\t    var item = availableModes[mode];\n\t    if (!item) {\n\t      throw new Error('Unknown mode \"' + mode + '\"');\n\t    }\n\n\t    item.className = 'type-modes' + ((current == mode) ? ' selected' : '');\n\t    items.push(item);\n\t  }\n\n\t  // retrieve the title of current mode\n\t  var currentMode = availableModes[current];\n\t  if (!currentMode) {\n\t    throw new Error('Unknown mode \"' + current + '\"');\n\t  }\n\t  var currentTitle = currentMode.text;\n\n\t  // create the html element\n\t  var box = document.createElement('button');\n\t  box.className = 'modes separator';\n\t  box.innerHTML = currentTitle + ' &#x25BE;';\n\t  box.title = 'Switch editor mode';\n\t  box.onclick = function () {\n\t    var menu = new ContextMenu(items);\n\t    menu.show(box);\n\t  };\n\n\t  return box;\n\t}\n\n\texports.create = createModeSwitcher;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// load brace\n\tvar ace = __webpack_require__(14);\n\n\t// load required ace modules\n\t__webpack_require__(15);\n\t__webpack_require__(16);\n\t__webpack_require__(13);\n\n\tmodule.exports = ace;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(3);\n\n\t/**\n\t * A context menu\n\t * @param {Object[]} items    Array containing the menu structure\n\t *                            TODO: describe structure\n\t * @param {Object} [options]  Object with options. Available options:\n\t *                            {function} close    Callback called when the\n\t *                                                context menu is being closed.\n\t * @constructor\n\t */\n\tfunction ContextMenu (items, options) {\n\t  this.dom = {};\n\n\t  var me = this;\n\t  var dom = this.dom;\n\t  this.anchor = undefined;\n\t  this.items = items;\n\t  this.eventListeners = {};\n\t  this.selection = undefined; // holds the selection before the menu was opened\n\t  this.visibleSubmenu = undefined;\n\t  this.onClose = options ? options.close : undefined;\n\n\t  // create a container element\n\t  var menu = document.createElement('div');\n\t  menu.className = 'jsoneditor-contextmenu';\n\t  dom.menu = menu;\n\n\t  // create a list to hold the menu items\n\t  var list = document.createElement('ul');\n\t  list.className = 'menu';\n\t  menu.appendChild(list);\n\t  dom.list = list;\n\t  dom.items = []; // list with all buttons\n\n\t  // create a (non-visible) button to set the focus to the menu\n\t  var focusButton = document.createElement('button');\n\t  dom.focusButton = focusButton;\n\t  var li = document.createElement('li');\n\t  li.style.overflow = 'hidden';\n\t  li.style.height = '0';\n\t  li.appendChild(focusButton);\n\t  list.appendChild(li);\n\n\t  function createMenuItems (list, domItems, items) {\n\t    items.forEach(function (item) {\n\t      if (item.type == 'separator') {\n\t        // create a separator\n\t        var separator = document.createElement('div');\n\t        separator.className = 'separator';\n\t        li = document.createElement('li');\n\t        li.appendChild(separator);\n\t        list.appendChild(li);\n\t      }\n\t      else {\n\t        var domItem = {};\n\n\t        // create a menu item\n\t        var li = document.createElement('li');\n\t        list.appendChild(li);\n\n\t        // create a button in the menu item\n\t        var button = document.createElement('button');\n\t        button.className = item.className;\n\t        domItem.button = button;\n\t        if (item.title) {\n\t          button.title = item.title;\n\t        }\n\t        if (item.click) {\n\t          button.onclick = function () {\n\t            me.hide();\n\t            item.click();\n\t          };\n\t        }\n\t        li.appendChild(button);\n\n\t        // create the contents of the button\n\t        if (item.submenu) {\n\t          // add the icon to the button\n\t          var divIcon = document.createElement('div');\n\t          divIcon.className = 'icon';\n\t          button.appendChild(divIcon);\n\t          button.appendChild(document.createTextNode(item.text));\n\n\t          var buttonSubmenu;\n\t          if (item.click) {\n\t            // submenu and a button with a click handler\n\t            button.className += ' default';\n\n\t            var buttonExpand = document.createElement('button');\n\t            domItem.buttonExpand = buttonExpand;\n\t            buttonExpand.className = 'expand';\n\t            buttonExpand.innerHTML = '<div class=\"expand\"></div>';\n\t            li.appendChild(buttonExpand);\n\t            if (item.submenuTitle) {\n\t              buttonExpand.title = item.submenuTitle;\n\t            }\n\n\t            buttonSubmenu = buttonExpand;\n\t          }\n\t          else {\n\t            // submenu and a button without a click handler\n\t            var divExpand = document.createElement('div');\n\t            divExpand.className = 'expand';\n\t            button.appendChild(divExpand);\n\n\t            buttonSubmenu = button;\n\t          }\n\n\t          // attach a handler to expand/collapse the submenu\n\t          buttonSubmenu.onclick = function () {\n\t            me._onExpandItem(domItem);\n\t            buttonSubmenu.focus();\n\t          };\n\n\t          // create the submenu\n\t          var domSubItems = [];\n\t          domItem.subItems = domSubItems;\n\t          var ul = document.createElement('ul');\n\t          domItem.ul = ul;\n\t          ul.className = 'menu';\n\t          ul.style.height = '0';\n\t          li.appendChild(ul);\n\t          createMenuItems(ul, domSubItems, item.submenu);\n\t        }\n\t        else {\n\t          // no submenu, just a button with clickhandler\n\t          button.innerHTML = '<div class=\"icon\"></div>' + item.text;\n\t        }\n\n\t        domItems.push(domItem);\n\t      }\n\t    });\n\t  }\n\t  createMenuItems(list, this.dom.items, items);\n\n\t  // TODO: when the editor is small, show the submenu on the right instead of inline?\n\n\t  // calculate the max height of the menu with one submenu expanded\n\t  this.maxHeight = 0; // height in pixels\n\t  items.forEach(function (item) {\n\t    var height = (items.length + (item.submenu ? item.submenu.length : 0)) * 24;\n\t    me.maxHeight = Math.max(me.maxHeight, height);\n\t  });\n\t}\n\n\t/**\n\t * Get the currently visible buttons\n\t * @return {Array.<HTMLElement>} buttons\n\t * @private\n\t */\n\tContextMenu.prototype._getVisibleButtons = function () {\n\t  var buttons = [];\n\t  var me = this;\n\t  this.dom.items.forEach(function (item) {\n\t    buttons.push(item.button);\n\t    if (item.buttonExpand) {\n\t      buttons.push(item.buttonExpand);\n\t    }\n\t    if (item.subItems && item == me.expandedItem) {\n\t      item.subItems.forEach(function (subItem) {\n\t        buttons.push(subItem.button);\n\t        if (subItem.buttonExpand) {\n\t          buttons.push(subItem.buttonExpand);\n\t        }\n\t        // TODO: change to fully recursive method\n\t      });\n\t    }\n\t  });\n\n\t  return buttons;\n\t};\n\n\t// currently displayed context menu, a singleton. We may only have one visible context menu\n\tContextMenu.visibleMenu = undefined;\n\n\t/**\n\t * Attach the menu to an anchor\n\t * @param {HTMLElement} anchor\n\t */\n\tContextMenu.prototype.show = function (anchor) {\n\t  this.hide();\n\n\t  // calculate whether the menu fits below the anchor\n\t  var windowHeight = window.innerHeight,\n\t      windowScroll = (window.pageYOffset || document.scrollTop || 0),\n\t      windowBottom = windowHeight + windowScroll,\n\t      anchorHeight = anchor.offsetHeight,\n\t      menuHeight = this.maxHeight;\n\n\t  // position the menu\n\t  var left = util.getAbsoluteLeft(anchor);\n\t  var top = util.getAbsoluteTop(anchor);\n\t  if (top + anchorHeight + menuHeight < windowBottom) {\n\t    // display the menu below the anchor\n\t    this.dom.menu.style.left = left + 'px';\n\t    this.dom.menu.style.top = (top + anchorHeight) + 'px';\n\t    this.dom.menu.style.bottom = '';\n\t  }\n\t  else {\n\t    // display the menu above the anchor\n\t    this.dom.menu.style.left = left + 'px';\n\t    this.dom.menu.style.top = '';\n\t    this.dom.menu.style.bottom = (windowHeight - top) + 'px';\n\t  }\n\n\t  // attach the menu to the document\n\t  document.body.appendChild(this.dom.menu);\n\n\t  // create and attach event listeners\n\t  var me = this;\n\t  var list = this.dom.list;\n\t  this.eventListeners.mousedown = util.addEventListener(\n\t      document, 'mousedown', function (event) {\n\t        // hide menu on click outside of the menu\n\t        var target = event.target;\n\t        if ((target != list) && !me._isChildOf(target, list)) {\n\t          me.hide();\n\t          event.stopPropagation();\n\t          event.preventDefault();\n\t        }\n\t      });\n\t  this.eventListeners.mousewheel = util.addEventListener(\n\t      document, 'mousewheel', function (event) {\n\t        // block scrolling when context menu is visible\n\t        event.stopPropagation();\n\t        event.preventDefault();\n\t      });\n\t  this.eventListeners.keydown = util.addEventListener(\n\t      document, 'keydown', function (event) {\n\t        me._onKeyDown(event);\n\t      });\n\n\t  // move focus to the first button in the context menu\n\t  this.selection = util.getSelection();\n\t  this.anchor = anchor;\n\t  setTimeout(function () {\n\t    me.dom.focusButton.focus();\n\t  }, 0);\n\n\t  if (ContextMenu.visibleMenu) {\n\t    ContextMenu.visibleMenu.hide();\n\t  }\n\t  ContextMenu.visibleMenu = this;\n\t};\n\n\t/**\n\t * Hide the context menu if visible\n\t */\n\tContextMenu.prototype.hide = function () {\n\t  // remove the menu from the DOM\n\t  if (this.dom.menu.parentNode) {\n\t    this.dom.menu.parentNode.removeChild(this.dom.menu);\n\t    if (this.onClose) {\n\t      this.onClose();\n\t    }\n\t  }\n\n\t  // remove all event listeners\n\t  // all event listeners are supposed to be attached to document.\n\t  for (var name in this.eventListeners) {\n\t    if (this.eventListeners.hasOwnProperty(name)) {\n\t      var fn = this.eventListeners[name];\n\t      if (fn) {\n\t        util.removeEventListener(document, name, fn);\n\t      }\n\t      delete this.eventListeners[name];\n\t    }\n\t  }\n\n\t  if (ContextMenu.visibleMenu == this) {\n\t    ContextMenu.visibleMenu = undefined;\n\t  }\n\t};\n\n\t/**\n\t * Expand a submenu\n\t * Any currently expanded submenu will be hided.\n\t * @param {Object} domItem\n\t * @private\n\t */\n\tContextMenu.prototype._onExpandItem = function (domItem) {\n\t  var me = this;\n\t  var alreadyVisible = (domItem == this.expandedItem);\n\n\t  // hide the currently visible submenu\n\t  var expandedItem = this.expandedItem;\n\t  if (expandedItem) {\n\t    //var ul = expandedItem.ul;\n\t    expandedItem.ul.style.height = '0';\n\t    expandedItem.ul.style.padding = '';\n\t    setTimeout(function () {\n\t      if (me.expandedItem != expandedItem) {\n\t        expandedItem.ul.style.display = '';\n\t        util.removeClassName(expandedItem.ul.parentNode, 'selected');\n\t      }\n\t    }, 300); // timeout duration must match the css transition duration\n\t    this.expandedItem = undefined;\n\t  }\n\n\t  if (!alreadyVisible) {\n\t    var ul = domItem.ul;\n\t    ul.style.display = 'block';\n\t    var height = ul.clientHeight; // force a reflow in Firefox\n\t    setTimeout(function () {\n\t      if (me.expandedItem == domItem) {\n\t        ul.style.height = (ul.childNodes.length * 24) + 'px';\n\t        ul.style.padding = '5px 10px';\n\t      }\n\t    }, 0);\n\t    util.addClassName(ul.parentNode, 'selected');\n\t    this.expandedItem = domItem;\n\t  }\n\t};\n\n\t/**\n\t * Handle onkeydown event\n\t * @param {Event} event\n\t * @private\n\t */\n\tContextMenu.prototype._onKeyDown = function (event) {\n\t  var target = event.target;\n\t  var keynum = event.which;\n\t  var handled = false;\n\t  var buttons, targetIndex, prevButton, nextButton;\n\n\t  if (keynum == 27) { // ESC\n\t    // hide the menu on ESC key\n\n\t    // restore previous selection and focus\n\t    if (this.selection) {\n\t      util.setSelection(this.selection);\n\t    }\n\t    if (this.anchor) {\n\t      this.anchor.focus();\n\t    }\n\n\t    this.hide();\n\n\t    handled = true;\n\t  }\n\t  else if (keynum == 9) { // Tab\n\t    if (!event.shiftKey) { // Tab\n\t      buttons = this._getVisibleButtons();\n\t      targetIndex = buttons.indexOf(target);\n\t      if (targetIndex == buttons.length - 1) {\n\t        // move to first button\n\t        buttons[0].focus();\n\t        handled = true;\n\t      }\n\t    }\n\t    else { // Shift+Tab\n\t      buttons = this._getVisibleButtons();\n\t      targetIndex = buttons.indexOf(target);\n\t      if (targetIndex == 0) {\n\t        // move to last button\n\t        buttons[buttons.length - 1].focus();\n\t        handled = true;\n\t      }\n\t    }\n\t  }\n\t  else if (keynum == 37) { // Arrow Left\n\t    if (target.className == 'expand') {\n\t      buttons = this._getVisibleButtons();\n\t      targetIndex = buttons.indexOf(target);\n\t      prevButton = buttons[targetIndex - 1];\n\t      if (prevButton) {\n\t        prevButton.focus();\n\t      }\n\t    }\n\t    handled = true;\n\t  }\n\t  else if (keynum == 38) { // Arrow Up\n\t    buttons = this._getVisibleButtons();\n\t    targetIndex = buttons.indexOf(target);\n\t    prevButton = buttons[targetIndex - 1];\n\t    if (prevButton && prevButton.className == 'expand') {\n\t      // skip expand button\n\t      prevButton = buttons[targetIndex - 2];\n\t    }\n\t    if (!prevButton) {\n\t      // move to last button\n\t      prevButton = buttons[buttons.length - 1];\n\t    }\n\t    if (prevButton) {\n\t      prevButton.focus();\n\t    }\n\t    handled = true;\n\t  }\n\t  else if (keynum == 39) { // Arrow Right\n\t    buttons = this._getVisibleButtons();\n\t    targetIndex = buttons.indexOf(target);\n\t    nextButton = buttons[targetIndex + 1];\n\t    if (nextButton && nextButton.className == 'expand') {\n\t      nextButton.focus();\n\t    }\n\t    handled = true;\n\t  }\n\t  else if (keynum == 40) { // Arrow Down\n\t    buttons = this._getVisibleButtons();\n\t    targetIndex = buttons.indexOf(target);\n\t    nextButton = buttons[targetIndex + 1];\n\t    if (nextButton && nextButton.className == 'expand') {\n\t      // skip expand button\n\t      nextButton = buttons[targetIndex + 2];\n\t    }\n\t    if (!nextButton) {\n\t      // move to first button\n\t      nextButton = buttons[0];\n\t    }\n\t    if (nextButton) {\n\t      nextButton.focus();\n\t      handled = true;\n\t    }\n\t    handled = true;\n\t  }\n\t  // TODO: arrow left and right\n\n\t  if (handled) {\n\t    event.stopPropagation();\n\t    event.preventDefault();\n\t  }\n\t};\n\n\t/**\n\t * Test if an element is a child of a parent element.\n\t * @param {Element} child\n\t * @param {Element} parent\n\t * @return {boolean} isChild\n\t */\n\tContextMenu.prototype._isChildOf = function (child, parent) {\n\t  var e = child.parentNode;\n\t  while (e) {\n\t    if (e == parent) {\n\t      return true;\n\t    }\n\t    e = e.parentNode;\n\t  }\n\n\t  return false;\n\t};\n\n\tmodule.exports = ContextMenu;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar util = __webpack_require__(3);\n\tvar ContextMenu = __webpack_require__(10);\n\n\t/**\n\t * A factory function to create an AppendNode, which depends on a Node\n\t * @param {Node} Node\n\t */\n\tfunction appendNodeFactory(Node) {\n\t  /**\n\t   * @constructor AppendNode\n\t   * @extends Node\n\t   * @param {TreeEditor} editor\n\t   * Create a new AppendNode. This is a special node which is created at the\n\t   * end of the list with childs for an object or array\n\t   */\n\t  function AppendNode (editor) {\n\t    /** @type {TreeEditor} */\n\t    this.editor = editor;\n\t    this.dom = {};\n\t  }\n\n\t  AppendNode.prototype = new Node();\n\n\t  /**\n\t   * Return a table row with an append button.\n\t   * @return {Element} dom   TR element\n\t   */\n\t  AppendNode.prototype.getDom = function () {\n\t    // TODO: implement a new solution for the append node\n\t    var dom = this.dom;\n\n\t    if (dom.tr) {\n\t      return dom.tr;\n\t    }\n\n\t    this._updateEditability();\n\n\t    // a row for the append button\n\t    var trAppend = document.createElement('tr');\n\t    trAppend.node = this;\n\t    dom.tr = trAppend;\n\n\t    // TODO: consistent naming\n\n\t    if (this.editable.field) {\n\t      // a cell for the dragarea column\n\t      dom.tdDrag = document.createElement('td');\n\n\t      // create context menu\n\t      var tdMenu = document.createElement('td');\n\t      dom.tdMenu = tdMenu;\n\t      var menu = document.createElement('button');\n\t      menu.className = 'contextmenu';\n\t      menu.title = 'Click to open the actions menu (Ctrl+M)';\n\t      dom.menu = menu;\n\t      tdMenu.appendChild(dom.menu);\n\t    }\n\n\t    // a cell for the contents (showing text 'empty')\n\t    var tdAppend = document.createElement('td');\n\t    var domText = document.createElement('div');\n\t    domText.innerHTML = '(empty)';\n\t    domText.className = 'readonly';\n\t    tdAppend.appendChild(domText);\n\t    dom.td = tdAppend;\n\t    dom.text = domText;\n\n\t    this.updateDom();\n\n\t    return trAppend;\n\t  };\n\n\t  /**\n\t   * Update the HTML dom of the Node\n\t   */\n\t  AppendNode.prototype.updateDom = function () {\n\t    var dom = this.dom;\n\t    var tdAppend = dom.td;\n\t    if (tdAppend) {\n\t      tdAppend.style.paddingLeft = (this.getLevel() * 24 + 26) + 'px';\n\t      // TODO: not so nice hard coded offset\n\t    }\n\n\t    var domText = dom.text;\n\t    if (domText) {\n\t      domText.innerHTML = '(empty ' + this.parent.type + ')';\n\t    }\n\n\t    // attach or detach the contents of the append node:\n\t    // hide when the parent has childs, show when the parent has no childs\n\t    var trAppend = dom.tr;\n\t    if (!this.isVisible()) {\n\t      if (dom.tr.firstChild) {\n\t        if (dom.tdDrag) {\n\t          trAppend.removeChild(dom.tdDrag);\n\t        }\n\t        if (dom.tdMenu) {\n\t          trAppend.removeChild(dom.tdMenu);\n\t        }\n\t        trAppend.removeChild(tdAppend);\n\t      }\n\t    }\n\t    else {\n\t      if (!dom.tr.firstChild) {\n\t        if (dom.tdDrag) {\n\t          trAppend.appendChild(dom.tdDrag);\n\t        }\n\t        if (dom.tdMenu) {\n\t          trAppend.appendChild(dom.tdMenu);\n\t        }\n\t        trAppend.appendChild(tdAppend);\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * Check whether the AppendNode is currently visible.\n\t   * the AppendNode is visible when its parent has no childs (i.e. is empty).\n\t   * @return {boolean} isVisible\n\t   */\n\t  AppendNode.prototype.isVisible = function () {\n\t    return (this.parent.childs.length == 0);\n\t  };\n\n\t  /**\n\t   * Show a contextmenu for this node\n\t   * @param {HTMLElement} anchor   The element to attach the menu to.\n\t   * @param {function} [onClose]   Callback method called when the context menu\n\t   *                               is being closed.\n\t   */\n\t  AppendNode.prototype.showContextMenu = function (anchor, onClose) {\n\t    var node = this;\n\t    var titles = Node.TYPE_TITLES;\n\t    var items = [\n\t      // create append button\n\t      {\n\t        'text': 'Append',\n\t        'title': 'Append a new field with type \\'auto\\' (Ctrl+Shift+Ins)',\n\t        'submenuTitle': 'Select the type of the field to be appended',\n\t        'className': 'insert',\n\t        'click': function () {\n\t          node._onAppend('', '', 'auto');\n\t        },\n\t        'submenu': [\n\t          {\n\t            'text': 'Auto',\n\t            'className': 'type-auto',\n\t            'title': titles.auto,\n\t            'click': function () {\n\t              node._onAppend('', '', 'auto');\n\t            }\n\t          },\n\t          {\n\t            'text': 'Array',\n\t            'className': 'type-array',\n\t            'title': titles.array,\n\t            'click': function () {\n\t              node._onAppend('', []);\n\t            }\n\t          },\n\t          {\n\t            'text': 'Object',\n\t            'className': 'type-object',\n\t            'title': titles.object,\n\t            'click': function () {\n\t              node._onAppend('', {});\n\t            }\n\t          },\n\t          {\n\t            'text': 'String',\n\t            'className': 'type-string',\n\t            'title': titles.string,\n\t            'click': function () {\n\t              node._onAppend('', '', 'string');\n\t            }\n\t          }\n\t        ]\n\t      }\n\t    ];\n\n\t    var menu = new ContextMenu(items, {close: onClose});\n\t    menu.show(anchor);\n\t  };\n\n\t  /**\n\t   * Handle an event. The event is catched centrally by the editor\n\t   * @param {Event} event\n\t   */\n\t  AppendNode.prototype.onEvent = function (event) {\n\t    var type = event.type;\n\t    var target = event.target || event.srcElement;\n\t    var dom = this.dom;\n\n\t    // highlight the append nodes parent\n\t    var menu = dom.menu;\n\t    if (target == menu) {\n\t      if (type == 'mouseover') {\n\t        this.editor.highlighter.highlight(this.parent);\n\t      }\n\t      else if (type == 'mouseout') {\n\t        this.editor.highlighter.unhighlight();\n\t      }\n\t    }\n\n\t    // context menu events\n\t    if (type == 'click' && target == dom.menu) {\n\t      var highlighter = this.editor.highlighter;\n\t      highlighter.highlight(this.parent);\n\t      highlighter.lock();\n\t      util.addClassName(dom.menu, 'selected');\n\t      this.showContextMenu(dom.menu, function () {\n\t        util.removeClassName(dom.menu, 'selected');\n\t        highlighter.unlock();\n\t        highlighter.unhighlight();\n\t      });\n\t    }\n\n\t    if (type == 'keydown') {\n\t      this.onKeyDown(event);\n\t    }\n\t  };\n\n\t  return AppendNode;\n\t}\n\n\tmodule.exports = appendNodeFactory;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Jison generated parser */\n\tvar jsonlint = (function(){\n\tvar parser = {trace: function trace() { },\n\tyy: {},\n\tsymbols_: {\"error\":2,\"JSONString\":3,\"STRING\":4,\"JSONNumber\":5,\"NUMBER\":6,\"JSONNullLiteral\":7,\"NULL\":8,\"JSONBooleanLiteral\":9,\"TRUE\":10,\"FALSE\":11,\"JSONText\":12,\"JSONValue\":13,\"EOF\":14,\"JSONObject\":15,\"JSONArray\":16,\"{\":17,\"}\":18,\"JSONMemberList\":19,\"JSONMember\":20,\":\":21,\",\":22,\"[\":23,\"]\":24,\"JSONElementList\":25,\"$accept\":0,\"$end\":1},\n\tterminals_: {2:\"error\",4:\"STRING\",6:\"NUMBER\",8:\"NULL\",10:\"TRUE\",11:\"FALSE\",14:\"EOF\",17:\"{\",18:\"}\",21:\":\",22:\",\",23:\"[\",24:\"]\"},\n\tproductions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],\n\tperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\n\tvar $0 = $$.length - 1;\n\tswitch (yystate) {\n\tcase 1: // replace escaped characters with actual character\n\t          this.$ = yytext.replace(/\\\\(\\\\|\")/g, \"$\"+\"1\")\n\t                     .replace(/\\\\n/g,'\\n')\n\t                     .replace(/\\\\r/g,'\\r')\n\t                     .replace(/\\\\t/g,'\\t')\n\t                     .replace(/\\\\v/g,'\\v')\n\t                     .replace(/\\\\f/g,'\\f')\n\t                     .replace(/\\\\b/g,'\\b');\n\t        \n\tbreak;\n\tcase 2:this.$ = Number(yytext);\n\tbreak;\n\tcase 3:this.$ = null;\n\tbreak;\n\tcase 4:this.$ = true;\n\tbreak;\n\tcase 5:this.$ = false;\n\tbreak;\n\tcase 6:return this.$ = $$[$0-1];\n\tbreak;\n\tcase 13:this.$ = {};\n\tbreak;\n\tcase 14:this.$ = $$[$0-1];\n\tbreak;\n\tcase 15:this.$ = [$$[$0-2], $$[$0]];\n\tbreak;\n\tcase 16:this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];\n\tbreak;\n\tcase 17:this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];\n\tbreak;\n\tcase 18:this.$ = [];\n\tbreak;\n\tcase 19:this.$ = $$[$0-1];\n\tbreak;\n\tcase 20:this.$ = [$$[$0]];\n\tbreak;\n\tcase 21:this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);\n\tbreak;\n\t}\n\t},\n\ttable: [{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],\n\tdefaultActions: {16:[2,6]},\n\tparseError: function parseError(str, hash) {\n\t    throw new Error(str);\n\t},\n\tparse: function parse(input) {\n\t    var self = this,\n\t        stack = [0],\n\t        vstack = [null], // semantic value stack\n\t        lstack = [], // location stack\n\t        table = this.table,\n\t        yytext = '',\n\t        yylineno = 0,\n\t        yyleng = 0,\n\t        recovering = 0,\n\t        TERROR = 2,\n\t        EOF = 1;\n\n\t    //this.reductionCount = this.shiftCount = 0;\n\n\t    this.lexer.setInput(input);\n\t    this.lexer.yy = this.yy;\n\t    this.yy.lexer = this.lexer;\n\t    if (typeof this.lexer.yylloc == 'undefined')\n\t        this.lexer.yylloc = {};\n\t    var yyloc = this.lexer.yylloc;\n\t    lstack.push(yyloc);\n\n\t    if (typeof this.yy.parseError === 'function')\n\t        this.parseError = this.yy.parseError;\n\n\t    function popStack (n) {\n\t        stack.length = stack.length - 2*n;\n\t        vstack.length = vstack.length - n;\n\t        lstack.length = lstack.length - n;\n\t    }\n\n\t    function lex() {\n\t        var token;\n\t        token = self.lexer.lex() || 1; // $end = 1\n\t        // if token isn't its numeric value, convert\n\t        if (typeof token !== 'number') {\n\t            token = self.symbols_[token] || token;\n\t        }\n\t        return token;\n\t    }\n\n\t    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;\n\t    while (true) {\n\t        // retreive state number from top of stack\n\t        state = stack[stack.length-1];\n\n\t        // use default actions if available\n\t        if (this.defaultActions[state]) {\n\t            action = this.defaultActions[state];\n\t        } else {\n\t            if (symbol == null)\n\t                symbol = lex();\n\t            // read action for current state and first input\n\t            action = table[state] && table[state][symbol];\n\t        }\n\n\t        // handle parse error\n\t        _handle_error:\n\t        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n\t            if (!recovering) {\n\t                // Report error\n\t                expected = [];\n\t                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n\t                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n\t                }\n\t                var errStr = '';\n\t                if (this.lexer.showPosition) {\n\t                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n\t                } else {\n\t                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n\t                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n\t                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n\t                }\n\t                this.parseError(errStr,\n\t                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n\t            }\n\n\t            // just recovered from another error\n\t            if (recovering == 3) {\n\t                if (symbol == EOF) {\n\t                    throw new Error(errStr || 'Parsing halted.');\n\t                }\n\n\t                // discard current lookahead and grab another\n\t                yyleng = this.lexer.yyleng;\n\t                yytext = this.lexer.yytext;\n\t                yylineno = this.lexer.yylineno;\n\t                yyloc = this.lexer.yylloc;\n\t                symbol = lex();\n\t            }\n\n\t            // try to recover from error\n\t            while (1) {\n\t                // check for error recovery rule in this state\n\t                if ((TERROR.toString()) in table[state]) {\n\t                    break;\n\t                }\n\t                if (state == 0) {\n\t                    throw new Error(errStr || 'Parsing halted.');\n\t                }\n\t                popStack(1);\n\t                state = stack[stack.length-1];\n\t            }\n\n\t            preErrorSymbol = symbol; // save the lookahead token\n\t            symbol = TERROR;         // insert generic error symbol as new lookahead\n\t            state = stack[stack.length-1];\n\t            action = table[state] && table[state][TERROR];\n\t            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n\t        }\n\n\t        // this shouldn't happen, unless resolve defaults are off\n\t        if (action[0] instanceof Array && action.length > 1) {\n\t            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n\t        }\n\n\t        switch (action[0]) {\n\n\t            case 1: // shift\n\t                //this.shiftCount++;\n\n\t                stack.push(symbol);\n\t                vstack.push(this.lexer.yytext);\n\t                lstack.push(this.lexer.yylloc);\n\t                stack.push(action[1]); // push state\n\t                symbol = null;\n\t                if (!preErrorSymbol) { // normal execution/no error\n\t                    yyleng = this.lexer.yyleng;\n\t                    yytext = this.lexer.yytext;\n\t                    yylineno = this.lexer.yylineno;\n\t                    yyloc = this.lexer.yylloc;\n\t                    if (recovering > 0)\n\t                        recovering--;\n\t                } else { // error just occurred, resume old lookahead f/ before error\n\t                    symbol = preErrorSymbol;\n\t                    preErrorSymbol = null;\n\t                }\n\t                break;\n\n\t            case 2: // reduce\n\t                //this.reductionCount++;\n\n\t                len = this.productions_[action[1]][1];\n\n\t                // perform semantic action\n\t                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n\t                // default location, uses first token for firsts, last for lasts\n\t                yyval._$ = {\n\t                    first_line: lstack[lstack.length-(len||1)].first_line,\n\t                    last_line: lstack[lstack.length-1].last_line,\n\t                    first_column: lstack[lstack.length-(len||1)].first_column,\n\t                    last_column: lstack[lstack.length-1].last_column\n\t                };\n\t                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n\t                if (typeof r !== 'undefined') {\n\t                    return r;\n\t                }\n\n\t                // pop off stack\n\t                if (len) {\n\t                    stack = stack.slice(0,-1*len*2);\n\t                    vstack = vstack.slice(0, -1*len);\n\t                    lstack = lstack.slice(0, -1*len);\n\t                }\n\n\t                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n\t                vstack.push(yyval.$);\n\t                lstack.push(yyval._$);\n\t                // goto new state = table[STATE][NONTERMINAL]\n\t                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n\t                stack.push(newState);\n\t                break;\n\n\t            case 3: // accept\n\t                return true;\n\t        }\n\n\t    }\n\n\t    return true;\n\t}};\n\t/* Jison generated lexer */\n\tvar lexer = (function(){\n\tvar lexer = ({EOF:1,\n\tparseError:function parseError(str, hash) {\n\t        if (this.yy.parseError) {\n\t            this.yy.parseError(str, hash);\n\t        } else {\n\t            throw new Error(str);\n\t        }\n\t    },\n\tsetInput:function (input) {\n\t        this._input = input;\n\t        this._more = this._less = this.done = false;\n\t        this.yylineno = this.yyleng = 0;\n\t        this.yytext = this.matched = this.match = '';\n\t        this.conditionStack = ['INITIAL'];\n\t        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n\t        return this;\n\t    },\n\tinput:function () {\n\t        var ch = this._input[0];\n\t        this.yytext+=ch;\n\t        this.yyleng++;\n\t        this.match+=ch;\n\t        this.matched+=ch;\n\t        var lines = ch.match(/\\n/);\n\t        if (lines) this.yylineno++;\n\t        this._input = this._input.slice(1);\n\t        return ch;\n\t    },\n\tunput:function (ch) {\n\t        this._input = ch + this._input;\n\t        return this;\n\t    },\n\tmore:function () {\n\t        this._more = true;\n\t        return this;\n\t    },\n\tless:function (n) {\n\t        this._input = this.match.slice(n) + this._input;\n\t    },\n\tpastInput:function () {\n\t        var past = this.matched.substr(0, this.matched.length - this.match.length);\n\t        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n\t    },\n\tupcomingInput:function () {\n\t        var next = this.match;\n\t        if (next.length < 20) {\n\t            next += this._input.substr(0, 20-next.length);\n\t        }\n\t        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n\t    },\n\tshowPosition:function () {\n\t        var pre = this.pastInput();\n\t        var c = new Array(pre.length + 1).join(\"-\");\n\t        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n\t    },\n\tnext:function () {\n\t        if (this.done) {\n\t            return this.EOF;\n\t        }\n\t        if (!this._input) this.done = true;\n\n\t        var token,\n\t            match,\n\t            tempMatch,\n\t            index,\n\t            col,\n\t            lines;\n\t        if (!this._more) {\n\t            this.yytext = '';\n\t            this.match = '';\n\t        }\n\t        var rules = this._currentRules();\n\t        for (var i=0;i < rules.length; i++) {\n\t            tempMatch = this._input.match(this.rules[rules[i]]);\n\t            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n\t                match = tempMatch;\n\t                index = i;\n\t                if (!this.options.flex) break;\n\t            }\n\t        }\n\t        if (match) {\n\t            lines = match[0].match(/\\n.*/g);\n\t            if (lines) this.yylineno += lines.length;\n\t            this.yylloc = {first_line: this.yylloc.last_line,\n\t                           last_line: this.yylineno+1,\n\t                           first_column: this.yylloc.last_column,\n\t                           last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}\n\t            this.yytext += match[0];\n\t            this.match += match[0];\n\t            this.yyleng = this.yytext.length;\n\t            this._more = false;\n\t            this._input = this._input.slice(match[0].length);\n\t            this.matched += match[0];\n\t            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n\t            if (this.done && this._input) this.done = false;\n\t            if (token) return token;\n\t            else return;\n\t        }\n\t        if (this._input === \"\") {\n\t            return this.EOF;\n\t        } else {\n\t            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(), \n\t                    {text: \"\", token: null, line: this.yylineno});\n\t        }\n\t    },\n\tlex:function lex() {\n\t        var r = this.next();\n\t        if (typeof r !== 'undefined') {\n\t            return r;\n\t        } else {\n\t            return this.lex();\n\t        }\n\t    },\n\tbegin:function begin(condition) {\n\t        this.conditionStack.push(condition);\n\t    },\n\tpopState:function popState() {\n\t        return this.conditionStack.pop();\n\t    },\n\t_currentRules:function _currentRules() {\n\t        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n\t    },\n\ttopState:function () {\n\t        return this.conditionStack[this.conditionStack.length-2];\n\t    },\n\tpushState:function begin(condition) {\n\t        this.begin(condition);\n\t    }});\n\tlexer.options = {};\n\tlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\n\tvar YYSTATE=YY_START\n\tswitch($avoiding_name_collisions) {\n\tcase 0:/* skip whitespace */\n\tbreak;\n\tcase 1:return 6\n\tbreak;\n\tcase 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4\n\tbreak;\n\tcase 3:return 17\n\tbreak;\n\tcase 4:return 18\n\tbreak;\n\tcase 5:return 23\n\tbreak;\n\tcase 6:return 24\n\tbreak;\n\tcase 7:return 22\n\tbreak;\n\tcase 8:return 21\n\tbreak;\n\tcase 9:return 10\n\tbreak;\n\tcase 10:return 11\n\tbreak;\n\tcase 11:return 8\n\tbreak;\n\tcase 12:return 14\n\tbreak;\n\tcase 13:return 'INVALID'\n\tbreak;\n\t}\n\t};\n\tlexer.rules = [/^(?:\\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,/^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?::)/,/^(?:true\\b)/,/^(?:false\\b)/,/^(?:null\\b)/,/^(?:$)/,/^(?:.)/];\n\tlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],\"inclusive\":true}};\n\n\n\t;\n\treturn lexer;})()\n\tparser.lexer = lexer;\n\treturn parser;\n\t})();\n\tif (true) {\n\t  exports.parser = jsonlint;\n\t  exports.parse = jsonlint.parse.bind(jsonlint);\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* ***** BEGIN LICENSE BLOCK *****\n\t * Distributed under the BSD license:\n\t *\n\t * Copyright (c) 2010, Ajax.org B.V.\n\t * All rights reserved.\n\t * \n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are met:\n\t *     * Redistributions of source code must retain the above copyright\n\t *       notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above copyright\n\t *       notice, this list of conditions and the following disclaimer in the\n\t *       documentation and/or other materials provided with the distribution.\n\t *     * Neither the name of Ajax.org B.V. nor the\n\t *       names of its contributors may be used to endorse or promote products\n\t *       derived from this software without specific prior written permission.\n\t * \n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\t * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\t * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\t * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n\t * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n\t * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\t * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n\t * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t *\n\t * ***** END LICENSE BLOCK ***** */\n\n\tace.define('ace/theme/jsoneditor', ['require', 'exports', 'module', 'ace/lib/dom'], function(acequire, exports, module) {\n\n\texports.isDark = false;\n\texports.cssClass = \"ace-jsoneditor\";\n\texports.cssText = \".ace-jsoneditor .ace_gutter {\\\n\tbackground: #ebebeb;\\\n\tcolor: #333\\\n\t}\\\n\t\\\n\t.ace-jsoneditor.ace_editor {\\\n\tfont-family: droid sans mono, consolas, monospace, courier new, courier, sans-serif;\\\n\tline-height: 1.3;\\\n\t}\\\n\t.ace-jsoneditor .ace_print-margin {\\\n\twidth: 1px;\\\n\tbackground: #e8e8e8\\\n\t}\\\n\t.ace-jsoneditor .ace_scroller {\\\n\tbackground-color: #FFFFFF\\\n\t}\\\n\t.ace-jsoneditor .ace_text-layer {\\\n\tcolor: gray\\\n\t}\\\n\t.ace-jsoneditor .ace_variable {\\\n\tcolor: #1a1a1a\\\n\t}\\\n\t.ace-jsoneditor .ace_cursor {\\\n\tborder-left: 2px solid #000000\\\n\t}\\\n\t.ace-jsoneditor .ace_overwrite-cursors .ace_cursor {\\\n\tborder-left: 0px;\\\n\tborder-bottom: 1px solid #000000\\\n\t}\\\n\t.ace-jsoneditor .ace_marker-layer .ace_selection {\\\n\tbackground: #D5DDF6\\\n\t}\\\n\t.ace-jsoneditor.ace_multiselect .ace_selection.ace_start {\\\n\tbox-shadow: 0 0 3px 0px #FFFFFF;\\\n\tborder-radius: 2px\\\n\t}\\\n\t.ace-jsoneditor .ace_marker-layer .ace_step {\\\n\tbackground: rgb(255, 255, 0)\\\n\t}\\\n\t.ace-jsoneditor .ace_marker-layer .ace_bracket {\\\n\tmargin: -1px 0 0 -1px;\\\n\tborder: 1px solid #BFBFBF\\\n\t}\\\n\t.ace-jsoneditor .ace_marker-layer .ace_active-line {\\\n\tbackground: #FFFBD1\\\n\t}\\\n\t.ace-jsoneditor .ace_gutter-active-line {\\\n\tbackground-color : #dcdcdc\\\n\t}\\\n\t.ace-jsoneditor .ace_marker-layer .ace_selected-word {\\\n\tborder: 1px solid #D5DDF6\\\n\t}\\\n\t.ace-jsoneditor .ace_invisible {\\\n\tcolor: #BFBFBF\\\n\t}\\\n\t.ace-jsoneditor .ace_keyword,\\\n\t.ace-jsoneditor .ace_meta,\\\n\t.ace-jsoneditor .ace_support.ace_constant.ace_property-value {\\\n\tcolor: #AF956F\\\n\t}\\\n\t.ace-jsoneditor .ace_keyword.ace_operator {\\\n\tcolor: #484848\\\n\t}\\\n\t.ace-jsoneditor .ace_keyword.ace_other.ace_unit {\\\n\tcolor: #96DC5F\\\n\t}\\\n\t.ace-jsoneditor .ace_constant.ace_language {\\\n\tcolor: darkorange\\\n\t}\\\n\t.ace-jsoneditor .ace_constant.ace_numeric {\\\n\tcolor: red\\\n\t}\\\n\t.ace-jsoneditor .ace_constant.ace_character.ace_entity {\\\n\tcolor: #BF78CC\\\n\t}\\\n\t.ace-jsoneditor .ace_invalid {\\\n\tcolor: #FFFFFF;\\\n\tbackground-color: #FF002A;\\\n\t}\\\n\t.ace-jsoneditor .ace_fold {\\\n\tbackground-color: #AF956F;\\\n\tborder-color: #000000\\\n\t}\\\n\t.ace-jsoneditor .ace_storage,\\\n\t.ace-jsoneditor .ace_support.ace_class,\\\n\t.ace-jsoneditor .ace_support.ace_function,\\\n\t.ace-jsoneditor .ace_support.ace_other,\\\n\t.ace-jsoneditor .ace_support.ace_type {\\\n\tcolor: #C52727\\\n\t}\\\n\t.ace-jsoneditor .ace_string {\\\n\tcolor: green\\\n\t}\\\n\t.ace-jsoneditor .ace_comment {\\\n\tcolor: #BCC8BA\\\n\t}\\\n\t.ace-jsoneditor .ace_entity.ace_name.ace_tag,\\\n\t.ace-jsoneditor .ace_entity.ace_other.ace_attribute-name {\\\n\tcolor: #606060\\\n\t}\\\n\t.ace-jsoneditor .ace_markup.ace_underline {\\\n\ttext-decoration: underline\\\n\t}\\\n\t.ace-jsoneditor .ace_indent-guide {\\\n\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y\\\n\t}\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tdom.importCssString(exports.cssText, exports.cssClass);\n\t});\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* ***** BEGIN LICENSE BLOCK *****\n\t * Distributed under the BSD license:\n\t *\n\t * Copyright (c) 2010, Ajax.org B.V.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are met:\n\t *     * Redistributions of source code must retain the above copyright\n\t *       notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above copyright\n\t *       notice, this list of conditions and the following disclaimer in the\n\t *       documentation and/or other materials provided with the distribution.\n\t *     * Neither the name of Ajax.org B.V. nor the\n\t *       names of its contributors may be used to endorse or promote products\n\t *       derived from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\t * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\t * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\t * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\n\t * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n\t * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\t * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n\t * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t *\n\t * ***** END LICENSE BLOCK ***** */\n\n\t/**\n\t * Define a module along with a payload\n\t * @param module a name for the payload\n\t * @param payload a function to call with (acequire, exports, module) params\n\t */\n\n\t(function() {\n\n\tvar ACE_NAMESPACE = \"ace\";\n\n\tvar global = (function() {\n\t    return this;\n\t})();\n\n\n\tif (!ACE_NAMESPACE && typeof acequirejs !== \"undefined\")\n\t    return;\n\n\n\tvar _define = function(module, deps, payload) {\n\t    if (typeof module !== 'string') {\n\t        if (_define.original)\n\t            _define.original.apply(window, arguments);\n\t        else {\n\t            console.error('dropping module because define wasn\\'t a string.');\n\t            console.trace();\n\t        }\n\t        return;\n\t    }\n\n\t    if (arguments.length == 2)\n\t        payload = deps;\n\n\t    if (!_define.modules) {\n\t        _define.modules = {};\n\t        _define.payloads = {};\n\t    }\n\n\t    _define.payloads[module] = payload;\n\t    _define.modules[module] = null;\n\t};\n\n\t/**\n\t * Get at functionality ace.define()ed using the function above\n\t */\n\tvar _acequire = function(parentId, module, callback) {\n\t    if (Object.prototype.toString.call(module) === \"[object Array]\") {\n\t        var params = [];\n\t        for (var i = 0, l = module.length; i < l; ++i) {\n\t            var dep = lookup(parentId, module[i]);\n\t            if (!dep && _acequire.original)\n\t                return _acequire.original.apply(window, arguments);\n\t            params.push(dep);\n\t        }\n\t        if (callback) {\n\t            callback.apply(null, params);\n\t        }\n\t    }\n\t    else if (typeof module === 'string') {\n\t        var payload = lookup(parentId, module);\n\t        if (!payload && _acequire.original)\n\t            return _acequire.original.apply(window, arguments);\n\n\t        if (callback) {\n\t            callback();\n\t        }\n\n\t        return payload;\n\t    }\n\t    else {\n\t        if (_acequire.original)\n\t            return _acequire.original.apply(window, arguments);\n\t    }\n\t};\n\n\tvar normalizeModule = function(parentId, moduleName) {\n\t    // normalize plugin acequires\n\t    if (moduleName.indexOf(\"!\") !== -1) {\n\t        var chunks = moduleName.split(\"!\");\n\t        return normalizeModule(parentId, chunks[0]) + \"!\" + normalizeModule(parentId, chunks[1]);\n\t    }\n\t    // normalize relative acequires\n\t    if (moduleName.charAt(0) == \".\") {\n\t        var base = parentId.split(\"/\").slice(0, -1).join(\"/\");\n\t        moduleName = base + \"/\" + moduleName;\n\n\t        while(moduleName.indexOf(\".\") !== -1 && previous != moduleName) {\n\t            var previous = moduleName;\n\t            moduleName = moduleName.replace(/\\/\\.\\//, \"/\").replace(/[^\\/]+\\/\\.\\.\\//, \"\");\n\t        }\n\t    }\n\n\t    return moduleName;\n\t};\n\n\t/**\n\t * Internal function to lookup moduleNames and resolve them by calling the\n\t * definition function if needed.\n\t */\n\tvar lookup = function(parentId, moduleName) {\n\n\t    moduleName = normalizeModule(parentId, moduleName);\n\n\t    var module = _define.modules[moduleName];\n\t    if (!module) {\n\t        module = _define.payloads[moduleName];\n\t        if (typeof module === 'function') {\n\t            var exports = {};\n\t            var mod = {\n\t                id: moduleName,\n\t                uri: '',\n\t                exports: exports,\n\t                packaged: true\n\t            };\n\n\t            var req = function(module, callback) {\n\t                return _acequire(moduleName, module, callback);\n\t            };\n\n\t            var returnValue = module(req, exports, mod);\n\t            exports = returnValue || mod.exports;\n\t            _define.modules[moduleName] = exports;\n\t            delete _define.payloads[moduleName];\n\t        }\n\t        module = _define.modules[moduleName] = exports || module;\n\t    }\n\t    return module;\n\t};\n\n\tfunction exportAce(ns) {\n\t    var acequire = function(module, callback) {\n\t        return _acequire(\"\", module, callback);\n\t    };\n\n\t    var root = global;\n\t    if (ns) {\n\t        if (!global[ns])\n\t            global[ns] = {};\n\t        root = global[ns];\n\t    }\n\n\t    if (!root.define || !root.define.packaged) {\n\t        _define.original = root.define;\n\t        root.define = _define;\n\t        root.define.packaged = true;\n\t    }\n\n\t    if (!root.acequire || !root.acequire.packaged) {\n\t        _acequire.original = root.acequire;\n\t        root.acequire = acequire;\n\t        root.acequire.packaged = true;\n\t    }\n\t}\n\n\texportAce(ACE_NAMESPACE);\n\n\t})();\n\n\tace.define(\"ace/lib/regexp\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\t    var real = {\n\t            exec: RegExp.prototype.exec,\n\t            test: RegExp.prototype.test,\n\t            match: String.prototype.match,\n\t            replace: String.prototype.replace,\n\t            split: String.prototype.split\n\t        },\n\t        compliantExecNpcg = real.exec.call(/()??/, \"\")[1] === undefined, // check `exec` handling of nonparticipating capturing groups\n\t        compliantLastIndexIncrement = function () {\n\t            var x = /^/g;\n\t            real.test.call(x, \"\");\n\t            return !x.lastIndex;\n\t        }();\n\n\t    if (compliantLastIndexIncrement && compliantExecNpcg)\n\t        return;\n\t    RegExp.prototype.exec = function (str) {\n\t        var match = real.exec.apply(this, arguments),\n\t            name, r2;\n\t        if ( typeof(str) == 'string' && match) {\n\t            if (!compliantExecNpcg && match.length > 1 && indexOf(match, \"\") > -1) {\n\t                r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), \"g\", \"\"));\n\t                real.replace.call(str.slice(match.index), r2, function () {\n\t                    for (var i = 1; i < arguments.length - 2; i++) {\n\t                        if (arguments[i] === undefined)\n\t                            match[i] = undefined;\n\t                    }\n\t                });\n\t            }\n\t            if (this._xregexp && this._xregexp.captureNames) {\n\t                for (var i = 1; i < match.length; i++) {\n\t                    name = this._xregexp.captureNames[i - 1];\n\t                    if (name)\n\t                       match[name] = match[i];\n\t                }\n\t            }\n\t            if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))\n\t                this.lastIndex--;\n\t        }\n\t        return match;\n\t    };\n\t    if (!compliantLastIndexIncrement) {\n\t        RegExp.prototype.test = function (str) {\n\t            var match = real.exec.call(this, str);\n\t            if (match && this.global && !match[0].length && (this.lastIndex > match.index))\n\t                this.lastIndex--;\n\t            return !!match;\n\t        };\n\t    }\n\n\t    function getNativeFlags (regex) {\n\t        return (regex.global     ? \"g\" : \"\") +\n\t               (regex.ignoreCase ? \"i\" : \"\") +\n\t               (regex.multiline  ? \"m\" : \"\") +\n\t               (regex.extended   ? \"x\" : \"\") + // Proposed for ES4; included in AS3\n\t               (regex.sticky     ? \"y\" : \"\");\n\t    }\n\n\t    function indexOf (array, item, from) {\n\t        if (Array.prototype.indexOf) // Use the native array method if available\n\t            return array.indexOf(item, from);\n\t        for (var i = from || 0; i < array.length; i++) {\n\t            if (array[i] === item)\n\t                return i;\n\t        }\n\t        return -1;\n\t    }\n\n\t});\n\n\tace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\n\tfunction Empty() {}\n\n\tif (!Function.prototype.bind) {\n\t    Function.prototype.bind = function bind(that) { // .length is 1\n\t        var target = this;\n\t        if (typeof target != \"function\") {\n\t            throw new TypeError(\"Function.prototype.bind called on incompatible \" + target);\n\t        }\n\t        var args = slice.call(arguments, 1); // for normal call\n\t        var bound = function () {\n\n\t            if (this instanceof bound) {\n\n\t                var result = target.apply(\n\t                    this,\n\t                    args.concat(slice.call(arguments))\n\t                );\n\t                if (Object(result) === result) {\n\t                    return result;\n\t                }\n\t                return this;\n\n\t            } else {\n\t                return target.apply(\n\t                    that,\n\t                    args.concat(slice.call(arguments))\n\t                );\n\n\t            }\n\n\t        };\n\t        if(target.prototype) {\n\t            Empty.prototype = target.prototype;\n\t            bound.prototype = new Empty();\n\t            Empty.prototype = null;\n\t        }\n\t        return bound;\n\t    };\n\t}\n\tvar call = Function.prototype.call;\n\tvar prototypeOfArray = Array.prototype;\n\tvar prototypeOfObject = Object.prototype;\n\tvar slice = prototypeOfArray.slice;\n\tvar _toString = call.bind(prototypeOfObject.toString);\n\tvar owns = call.bind(prototypeOfObject.hasOwnProperty);\n\tvar defineGetter;\n\tvar defineSetter;\n\tvar lookupGetter;\n\tvar lookupSetter;\n\tvar supportsAccessors;\n\tif ((supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\"))) {\n\t    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n\t    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n\t    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n\t    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n\t}\n\tif ([1,2].splice(0).length != 2) {\n\t    if(function() { // test IE < 9 to splice bug - see issue #138\n\t        function makeArray(l) {\n\t            var a = new Array(l+2);\n\t            a[0] = a[1] = 0;\n\t            return a;\n\t        }\n\t        var array = [], lengthBefore;\n\t        \n\t        array.splice.apply(array, makeArray(20));\n\t        array.splice.apply(array, makeArray(26));\n\n\t        lengthBefore = array.length; //46\n\t        array.splice(5, 0, \"XXX\"); // add one element\n\n\t        lengthBefore + 1 == array.length\n\n\t        if (lengthBefore + 1 == array.length) {\n\t            return true;// has right splice implementation without bugs\n\t        }\n\t    }()) {//IE 6/7\n\t        var array_splice = Array.prototype.splice;\n\t        Array.prototype.splice = function(start, deleteCount) {\n\t            if (!arguments.length) {\n\t                return [];\n\t            } else {\n\t                return array_splice.apply(this, [\n\t                    start === void 0 ? 0 : start,\n\t                    deleteCount === void 0 ? (this.length - start) : deleteCount\n\t                ].concat(slice.call(arguments, 2)))\n\t            }\n\t        };\n\t    } else {//IE8\n\t        Array.prototype.splice = function(pos, removeCount){\n\t            var length = this.length;\n\t            if (pos > 0) {\n\t                if (pos > length)\n\t                    pos = length;\n\t            } else if (pos == void 0) {\n\t                pos = 0;\n\t            } else if (pos < 0) {\n\t                pos = Math.max(length + pos, 0);\n\t            }\n\n\t            if (!(pos+removeCount < length))\n\t                removeCount = length - pos;\n\n\t            var removed = this.slice(pos, pos+removeCount);\n\t            var insert = slice.call(arguments, 2);\n\t            var add = insert.length;            \n\t            if (pos === length) {\n\t                if (add) {\n\t                    this.push.apply(this, insert);\n\t                }\n\t            } else {\n\t                var remove = Math.min(removeCount, length - pos);\n\t                var tailOldPos = pos + remove;\n\t                var tailNewPos = tailOldPos + add - remove;\n\t                var tailCount = length - tailOldPos;\n\t                var lengthAfterRemove = length - remove;\n\n\t                if (tailNewPos < tailOldPos) { // case A\n\t                    for (var i = 0; i < tailCount; ++i) {\n\t                        this[tailNewPos+i] = this[tailOldPos+i];\n\t                    }\n\t                } else if (tailNewPos > tailOldPos) { // case B\n\t                    for (i = tailCount; i--; ) {\n\t                        this[tailNewPos+i] = this[tailOldPos+i];\n\t                    }\n\t                } // else, add == remove (nothing to do)\n\n\t                if (add && pos === lengthAfterRemove) {\n\t                    this.length = lengthAfterRemove; // truncate array\n\t                    this.push.apply(this, insert);\n\t                } else {\n\t                    this.length = lengthAfterRemove + add; // reserves space\n\t                    for (i = 0; i < add; ++i) {\n\t                        this[pos+i] = insert[i];\n\t                    }\n\t                }\n\t            }\n\t            return removed;\n\t        };\n\t    }\n\t}\n\tif (!Array.isArray) {\n\t    Array.isArray = function isArray(obj) {\n\t        return _toString(obj) == \"[object Array]\";\n\t    };\n\t}\n\tvar boxedString = Object(\"a\"),\n\t    splitString = boxedString[0] != \"a\" || !(0 in boxedString);\n\n\tif (!Array.prototype.forEach) {\n\t    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                object,\n\t            thisp = arguments[1],\n\t            i = -1,\n\t            length = self.length >>> 0;\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(); // TODO message\n\t        }\n\n\t        while (++i < length) {\n\t            if (i in self) {\n\t                fun.call(thisp, self[i], i, object);\n\t            }\n\t        }\n\t    };\n\t}\n\tif (!Array.prototype.map) {\n\t    Array.prototype.map = function map(fun /*, thisp*/) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                object,\n\t            length = self.length >>> 0,\n\t            result = Array(length),\n\t            thisp = arguments[1];\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(fun + \" is not a function\");\n\t        }\n\n\t        for (var i = 0; i < length; i++) {\n\t            if (i in self)\n\t                result[i] = fun.call(thisp, self[i], i, object);\n\t        }\n\t        return result;\n\t    };\n\t}\n\tif (!Array.prototype.filter) {\n\t    Array.prototype.filter = function filter(fun /*, thisp */) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                    object,\n\t            length = self.length >>> 0,\n\t            result = [],\n\t            value,\n\t            thisp = arguments[1];\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(fun + \" is not a function\");\n\t        }\n\n\t        for (var i = 0; i < length; i++) {\n\t            if (i in self) {\n\t                value = self[i];\n\t                if (fun.call(thisp, value, i, object)) {\n\t                    result.push(value);\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t}\n\tif (!Array.prototype.every) {\n\t    Array.prototype.every = function every(fun /*, thisp */) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                object,\n\t            length = self.length >>> 0,\n\t            thisp = arguments[1];\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(fun + \" is not a function\");\n\t        }\n\n\t        for (var i = 0; i < length; i++) {\n\t            if (i in self && !fun.call(thisp, self[i], i, object)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    };\n\t}\n\tif (!Array.prototype.some) {\n\t    Array.prototype.some = function some(fun /*, thisp */) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                object,\n\t            length = self.length >>> 0,\n\t            thisp = arguments[1];\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(fun + \" is not a function\");\n\t        }\n\n\t        for (var i = 0; i < length; i++) {\n\t            if (i in self && fun.call(thisp, self[i], i, object)) {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t}\n\tif (!Array.prototype.reduce) {\n\t    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                object,\n\t            length = self.length >>> 0;\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(fun + \" is not a function\");\n\t        }\n\t        if (!length && arguments.length == 1) {\n\t            throw new TypeError(\"reduce of empty array with no initial value\");\n\t        }\n\n\t        var i = 0;\n\t        var result;\n\t        if (arguments.length >= 2) {\n\t            result = arguments[1];\n\t        } else {\n\t            do {\n\t                if (i in self) {\n\t                    result = self[i++];\n\t                    break;\n\t                }\n\t                if (++i >= length) {\n\t                    throw new TypeError(\"reduce of empty array with no initial value\");\n\t                }\n\t            } while (true);\n\t        }\n\n\t        for (; i < length; i++) {\n\t            if (i in self) {\n\t                result = fun.call(void 0, result, self[i], i, object);\n\t            }\n\t        }\n\n\t        return result;\n\t    };\n\t}\n\tif (!Array.prototype.reduceRight) {\n\t    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n\t        var object = toObject(this),\n\t            self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                object,\n\t            length = self.length >>> 0;\n\t        if (_toString(fun) != \"[object Function]\") {\n\t            throw new TypeError(fun + \" is not a function\");\n\t        }\n\t        if (!length && arguments.length == 1) {\n\t            throw new TypeError(\"reduceRight of empty array with no initial value\");\n\t        }\n\n\t        var result, i = length - 1;\n\t        if (arguments.length >= 2) {\n\t            result = arguments[1];\n\t        } else {\n\t            do {\n\t                if (i in self) {\n\t                    result = self[i--];\n\t                    break;\n\t                }\n\t                if (--i < 0) {\n\t                    throw new TypeError(\"reduceRight of empty array with no initial value\");\n\t                }\n\t            } while (true);\n\t        }\n\n\t        do {\n\t            if (i in this) {\n\t                result = fun.call(void 0, result, self[i], i, object);\n\t            }\n\t        } while (i--);\n\n\t        return result;\n\t    };\n\t}\n\tif (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {\n\t    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n\t        var self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                toObject(this),\n\t            length = self.length >>> 0;\n\n\t        if (!length) {\n\t            return -1;\n\t        }\n\n\t        var i = 0;\n\t        if (arguments.length > 1) {\n\t            i = toInteger(arguments[1]);\n\t        }\n\t        i = i >= 0 ? i : Math.max(0, length + i);\n\t        for (; i < length; i++) {\n\t            if (i in self && self[i] === sought) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t}\n\tif (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {\n\t    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n\t        var self = splitString && _toString(this) == \"[object String]\" ?\n\t                this.split(\"\") :\n\t                toObject(this),\n\t            length = self.length >>> 0;\n\n\t        if (!length) {\n\t            return -1;\n\t        }\n\t        var i = length - 1;\n\t        if (arguments.length > 1) {\n\t            i = Math.min(i, toInteger(arguments[1]));\n\t        }\n\t        i = i >= 0 ? i : length - Math.abs(i);\n\t        for (; i >= 0; i--) {\n\t            if (i in self && sought === self[i]) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t}\n\tif (!Object.getPrototypeOf) {\n\t    Object.getPrototypeOf = function getPrototypeOf(object) {\n\t        return object.__proto__ || (\n\t            object.constructor ?\n\t            object.constructor.prototype :\n\t            prototypeOfObject\n\t        );\n\t    };\n\t}\n\tif (!Object.getOwnPropertyDescriptor) {\n\t    var ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a \" +\n\t                         \"non-object: \";\n\t    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {\n\t        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n\t            throw new TypeError(ERR_NON_OBJECT + object);\n\t        if (!owns(object, property))\n\t            return;\n\n\t        var descriptor, getter, setter;\n\t        descriptor =  { enumerable: true, configurable: true };\n\t        if (supportsAccessors) {\n\t            var prototype = object.__proto__;\n\t            object.__proto__ = prototypeOfObject;\n\n\t            var getter = lookupGetter(object, property);\n\t            var setter = lookupSetter(object, property);\n\t            object.__proto__ = prototype;\n\n\t            if (getter || setter) {\n\t                if (getter) descriptor.get = getter;\n\t                if (setter) descriptor.set = setter;\n\t                return descriptor;\n\t            }\n\t        }\n\t        descriptor.value = object[property];\n\t        return descriptor;\n\t    };\n\t}\n\tif (!Object.getOwnPropertyNames) {\n\t    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {\n\t        return Object.keys(object);\n\t    };\n\t}\n\tif (!Object.create) {\n\t    var createEmpty;\n\t    if (Object.prototype.__proto__ === null) {\n\t        createEmpty = function () {\n\t            return { \"__proto__\": null };\n\t        };\n\t    } else {\n\t        createEmpty = function () {\n\t            var empty = {};\n\t            for (var i in empty)\n\t                empty[i] = null;\n\t            empty.constructor =\n\t            empty.hasOwnProperty =\n\t            empty.propertyIsEnumerable =\n\t            empty.isPrototypeOf =\n\t            empty.toLocaleString =\n\t            empty.toString =\n\t            empty.valueOf =\n\t            empty.__proto__ = null;\n\t            return empty;\n\t        }\n\t    }\n\n\t    Object.create = function create(prototype, properties) {\n\t        var object;\n\t        if (prototype === null) {\n\t            object = createEmpty();\n\t        } else {\n\t            if (typeof prototype != \"object\")\n\t                throw new TypeError(\"typeof prototype[\"+(typeof prototype)+\"] != 'object'\");\n\t            var Type = function () {};\n\t            Type.prototype = prototype;\n\t            object = new Type();\n\t            object.__proto__ = prototype;\n\t        }\n\t        if (properties !== void 0)\n\t            Object.defineProperties(object, properties);\n\t        return object;\n\t    };\n\t}\n\n\tfunction doesDefinePropertyWork(object) {\n\t    try {\n\t        Object.defineProperty(object, \"sentinel\", {});\n\t        return \"sentinel\" in object;\n\t    } catch (exception) {\n\t    }\n\t}\n\tif (Object.defineProperty) {\n\t    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n\t    var definePropertyWorksOnDom = typeof document == \"undefined\" ||\n\t        doesDefinePropertyWork(document.createElement(\"div\"));\n\t    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n\t        var definePropertyFallback = Object.defineProperty;\n\t    }\n\t}\n\n\tif (!Object.defineProperty || definePropertyFallback) {\n\t    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\n\t    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \"\n\t    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined \" +\n\t                                      \"on this javascript engine\";\n\n\t    Object.defineProperty = function defineProperty(object, property, descriptor) {\n\t        if ((typeof object != \"object\" && typeof object != \"function\") || object === null)\n\t            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n\t        if ((typeof descriptor != \"object\" && typeof descriptor != \"function\") || descriptor === null)\n\t            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n\t        if (definePropertyFallback) {\n\t            try {\n\t                return definePropertyFallback.call(Object, object, property, descriptor);\n\t            } catch (exception) {\n\t            }\n\t        }\n\t        if (owns(descriptor, \"value\")) {\n\n\t            if (supportsAccessors && (lookupGetter(object, property) ||\n\t                                      lookupSetter(object, property)))\n\t            {\n\t                var prototype = object.__proto__;\n\t                object.__proto__ = prototypeOfObject;\n\t                delete object[property];\n\t                object[property] = descriptor.value;\n\t                object.__proto__ = prototype;\n\t            } else {\n\t                object[property] = descriptor.value;\n\t            }\n\t        } else {\n\t            if (!supportsAccessors)\n\t                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n\t            if (owns(descriptor, \"get\"))\n\t                defineGetter(object, property, descriptor.get);\n\t            if (owns(descriptor, \"set\"))\n\t                defineSetter(object, property, descriptor.set);\n\t        }\n\n\t        return object;\n\t    };\n\t}\n\tif (!Object.defineProperties) {\n\t    Object.defineProperties = function defineProperties(object, properties) {\n\t        for (var property in properties) {\n\t            if (owns(properties, property))\n\t                Object.defineProperty(object, property, properties[property]);\n\t        }\n\t        return object;\n\t    };\n\t}\n\tif (!Object.seal) {\n\t    Object.seal = function seal(object) {\n\t        return object;\n\t    };\n\t}\n\tif (!Object.freeze) {\n\t    Object.freeze = function freeze(object) {\n\t        return object;\n\t    };\n\t}\n\ttry {\n\t    Object.freeze(function () {});\n\t} catch (exception) {\n\t    Object.freeze = (function freeze(freezeObject) {\n\t        return function freeze(object) {\n\t            if (typeof object == \"function\") {\n\t                return object;\n\t            } else {\n\t                return freezeObject(object);\n\t            }\n\t        };\n\t    })(Object.freeze);\n\t}\n\tif (!Object.preventExtensions) {\n\t    Object.preventExtensions = function preventExtensions(object) {\n\t        return object;\n\t    };\n\t}\n\tif (!Object.isSealed) {\n\t    Object.isSealed = function isSealed(object) {\n\t        return false;\n\t    };\n\t}\n\tif (!Object.isFrozen) {\n\t    Object.isFrozen = function isFrozen(object) {\n\t        return false;\n\t    };\n\t}\n\tif (!Object.isExtensible) {\n\t    Object.isExtensible = function isExtensible(object) {\n\t        if (Object(object) === object) {\n\t            throw new TypeError(); // TODO message\n\t        }\n\t        var name = '';\n\t        while (owns(object, name)) {\n\t            name += '?';\n\t        }\n\t        object[name] = true;\n\t        var returnValue = owns(object, name);\n\t        delete object[name];\n\t        return returnValue;\n\t    };\n\t}\n\tif (!Object.keys) {\n\t    var hasDontEnumBug = true,\n\t        dontEnums = [\n\t            \"toString\",\n\t            \"toLocaleString\",\n\t            \"valueOf\",\n\t            \"hasOwnProperty\",\n\t            \"isPrototypeOf\",\n\t            \"propertyIsEnumerable\",\n\t            \"constructor\"\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    for (var key in {\"toString\": null}) {\n\t        hasDontEnumBug = false;\n\t    }\n\n\t    Object.keys = function keys(object) {\n\n\t        if (\n\t            (typeof object != \"object\" && typeof object != \"function\") ||\n\t            object === null\n\t        ) {\n\t            throw new TypeError(\"Object.keys called on a non-object\");\n\t        }\n\n\t        var keys = [];\n\t        for (var name in object) {\n\t            if (owns(object, name)) {\n\t                keys.push(name);\n\t            }\n\t        }\n\n\t        if (hasDontEnumBug) {\n\t            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {\n\t                var dontEnum = dontEnums[i];\n\t                if (owns(object, dontEnum)) {\n\t                    keys.push(dontEnum);\n\t                }\n\t            }\n\t        }\n\t        return keys;\n\t    };\n\n\t}\n\tif (!Date.now) {\n\t    Date.now = function now() {\n\t        return new Date().getTime();\n\t    };\n\t}\n\tvar ws = \"\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\" +\n\t    \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\" +\n\t    \"\\u2029\\uFEFF\";\n\tif (!String.prototype.trim || ws.trim()) {\n\t    ws = \"[\" + ws + \"]\";\n\t    var trimBeginRegexp = new RegExp(\"^\" + ws + ws + \"*\"),\n\t        trimEndRegexp = new RegExp(ws + ws + \"*$\");\n\t    String.prototype.trim = function trim() {\n\t        return String(this).replace(trimBeginRegexp, \"\").replace(trimEndRegexp, \"\");\n\t    };\n\t}\n\n\tfunction toInteger(n) {\n\t    n = +n;\n\t    if (n !== n) { // isNaN\n\t        n = 0;\n\t    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {\n\t        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t    }\n\t    return n;\n\t}\n\n\tfunction isPrimitive(input) {\n\t    var type = typeof input;\n\t    return (\n\t        input === null ||\n\t        type === \"undefined\" ||\n\t        type === \"boolean\" ||\n\t        type === \"number\" ||\n\t        type === \"string\"\n\t    );\n\t}\n\n\tfunction toPrimitive(input) {\n\t    var val, valueOf, toString;\n\t    if (isPrimitive(input)) {\n\t        return input;\n\t    }\n\t    valueOf = input.valueOf;\n\t    if (typeof valueOf === \"function\") {\n\t        val = valueOf.call(input);\n\t        if (isPrimitive(val)) {\n\t            return val;\n\t        }\n\t    }\n\t    toString = input.toString;\n\t    if (typeof toString === \"function\") {\n\t        val = toString.call(input);\n\t        if (isPrimitive(val)) {\n\t            return val;\n\t        }\n\t    }\n\t    throw new TypeError();\n\t}\n\tvar toObject = function (o) {\n\t    if (o == null) { // this matches both null and undefined\n\t        throw new TypeError(\"can't convert \"+o+\" to object\");\n\t    }\n\t    return Object(o);\n\t};\n\n\t});\n\n\tace.define(\"ace/lib/fixoldbrowsers\",[\"require\",\"exports\",\"module\",\"ace/lib/regexp\",\"ace/lib/es5-shim\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tacequire(\"./regexp\");\n\tacequire(\"./es5-shim\");\n\n\t});\n\n\tace.define(\"ace/lib/dom\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tif (typeof document == \"undefined\")\n\t    return;\n\n\tvar XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n\n\texports.getDocumentHead = function(doc) {\n\t    if (!doc)\n\t        doc = document;\n\t    return doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement;\n\t}\n\n\texports.createElement = function(tag, ns) {\n\t    return document.createElementNS ?\n\t           document.createElementNS(ns || XHTML_NS, tag) :\n\t           document.createElement(tag);\n\t};\n\n\texports.hasCssClass = function(el, name) {\n\t    var classes = (el.className || \"\").split(/\\s+/g);\n\t    return classes.indexOf(name) !== -1;\n\t};\n\texports.addCssClass = function(el, name) {\n\t    if (!exports.hasCssClass(el, name)) {\n\t        el.className += \" \" + name;\n\t    }\n\t};\n\texports.removeCssClass = function(el, name) {\n\t    var classes = el.className.split(/\\s+/g);\n\t    while (true) {\n\t        var index = classes.indexOf(name);\n\t        if (index == -1) {\n\t            break;\n\t        }\n\t        classes.splice(index, 1);\n\t    }\n\t    el.className = classes.join(\" \");\n\t};\n\n\texports.toggleCssClass = function(el, name) {\n\t    var classes = el.className.split(/\\s+/g), add = true;\n\t    while (true) {\n\t        var index = classes.indexOf(name);\n\t        if (index == -1) {\n\t            break;\n\t        }\n\t        add = false;\n\t        classes.splice(index, 1);\n\t    }\n\t    if(add)\n\t        classes.push(name);\n\n\t    el.className = classes.join(\" \");\n\t    return add;\n\t};\n\texports.setCssClass = function(node, className, include) {\n\t    if (include) {\n\t        exports.addCssClass(node, className);\n\t    } else {\n\t        exports.removeCssClass(node, className);\n\t    }\n\t};\n\n\texports.hasCssString = function(id, doc) {\n\t    var index = 0, sheets;\n\t    doc = doc || document;\n\n\t    if (doc.createStyleSheet && (sheets = doc.styleSheets)) {\n\t        while (index < sheets.length)\n\t            if (sheets[index++].owningElement.id === id) return true;\n\t    } else if ((sheets = doc.getElementsByTagName(\"style\"))) {\n\t        while (index < sheets.length)\n\t            if (sheets[index++].id === id) return true;\n\t    }\n\n\t    return false;\n\t};\n\n\texports.importCssString = function importCssString(cssText, id, doc) {\n\t    doc = doc || document;\n\t    if (id && exports.hasCssString(id, doc))\n\t        return null;\n\t    \n\t    var style;\n\t    \n\t    if (doc.createStyleSheet) {\n\t        style = doc.createStyleSheet();\n\t        style.cssText = cssText;\n\t        if (id)\n\t            style.owningElement.id = id;\n\t    } else {\n\t        style = doc.createElementNS\n\t            ? doc.createElementNS(XHTML_NS, \"style\")\n\t            : doc.createElement(\"style\");\n\n\t        style.appendChild(doc.createTextNode(cssText));\n\t        if (id)\n\t            style.id = id;\n\n\t        exports.getDocumentHead(doc).appendChild(style);\n\t    }\n\t};\n\n\texports.importCssStylsheet = function(uri, doc) {\n\t    if (doc.createStyleSheet) {\n\t        doc.createStyleSheet(uri);\n\t    } else {\n\t        var link = exports.createElement('link');\n\t        link.rel = 'stylesheet';\n\t        link.href = uri;\n\n\t        exports.getDocumentHead(doc).appendChild(link);\n\t    }\n\t};\n\n\texports.getInnerWidth = function(element) {\n\t    return (\n\t        parseInt(exports.computedStyle(element, \"paddingLeft\"), 10) +\n\t        parseInt(exports.computedStyle(element, \"paddingRight\"), 10) + \n\t        element.clientWidth\n\t    );\n\t};\n\n\texports.getInnerHeight = function(element) {\n\t    return (\n\t        parseInt(exports.computedStyle(element, \"paddingTop\"), 10) +\n\t        parseInt(exports.computedStyle(element, \"paddingBottom\"), 10) +\n\t        element.clientHeight\n\t    );\n\t};\n\n\tif (window.pageYOffset !== undefined) {\n\t    exports.getPageScrollTop = function() {\n\t        return window.pageYOffset;\n\t    };\n\n\t    exports.getPageScrollLeft = function() {\n\t        return window.pageXOffset;\n\t    };\n\t}\n\telse {\n\t    exports.getPageScrollTop = function() {\n\t        return document.body.scrollTop;\n\t    };\n\n\t    exports.getPageScrollLeft = function() {\n\t        return document.body.scrollLeft;\n\t    };\n\t}\n\n\tif (window.getComputedStyle)\n\t    exports.computedStyle = function(element, style) {\n\t        if (style)\n\t            return (window.getComputedStyle(element, \"\") || {})[style] || \"\";\n\t        return window.getComputedStyle(element, \"\") || {};\n\t    };\n\telse\n\t    exports.computedStyle = function(element, style) {\n\t        if (style)\n\t            return element.currentStyle[style];\n\t        return element.currentStyle;\n\t    };\n\n\texports.scrollbarWidth = function(document) {\n\t    var inner = exports.createElement(\"ace_inner\");\n\t    inner.style.width = \"100%\";\n\t    inner.style.minWidth = \"0px\";\n\t    inner.style.height = \"200px\";\n\t    inner.style.display = \"block\";\n\n\t    var outer = exports.createElement(\"ace_outer\");\n\t    var style = outer.style;\n\n\t    style.position = \"absolute\";\n\t    style.left = \"-10000px\";\n\t    style.overflow = \"hidden\";\n\t    style.width = \"200px\";\n\t    style.minWidth = \"0px\";\n\t    style.height = \"150px\";\n\t    style.display = \"block\";\n\n\t    outer.appendChild(inner);\n\n\t    var body = document.documentElement;\n\t    body.appendChild(outer);\n\n\t    var noScrollbar = inner.offsetWidth;\n\n\t    style.overflow = \"scroll\";\n\t    var withScrollbar = inner.offsetWidth;\n\n\t    if (noScrollbar == withScrollbar) {\n\t        withScrollbar = outer.clientWidth;\n\t    }\n\n\t    body.removeChild(outer);\n\n\t    return noScrollbar-withScrollbar;\n\t};\n\texports.setInnerHtml = function(el, innerHtml) {\n\t    var element = el.cloneNode(false);//document.createElement(\"div\");\n\t    element.innerHTML = innerHtml;\n\t    el.parentNode.replaceChild(element, el);\n\t    return element;\n\t};\n\n\tif (\"textContent\" in document.documentElement) {\n\t    exports.setInnerText = function(el, innerText) {\n\t        el.textContent = innerText;\n\t    };\n\n\t    exports.getInnerText = function(el) {\n\t        return el.textContent;\n\t    };\n\t}\n\telse {\n\t    exports.setInnerText = function(el, innerText) {\n\t        el.innerText = innerText;\n\t    };\n\n\t    exports.getInnerText = function(el) {\n\t        return el.innerText;\n\t    };\n\t}\n\n\texports.getParentWindow = function(document) {\n\t    return document.defaultView || document.parentWindow;\n\t};\n\n\t});\n\n\tace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\texports.inherits = function(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t        constructor: {\n\t            value: ctor,\n\t            enumerable: false,\n\t            writable: true,\n\t            configurable: true\n\t        }\n\t    });\n\t};\n\n\texports.mixin = function(obj, mixin) {\n\t    for (var key in mixin) {\n\t        obj[key] = mixin[key];\n\t    }\n\t    return obj;\n\t};\n\n\texports.implement = function(proto, mixin) {\n\t    exports.mixin(proto, mixin);\n\t};\n\n\t});\n\n\tace.define(\"ace/lib/keys\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/oop\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tacequire(\"./fixoldbrowsers\");\n\n\tvar oop = acequire(\"./oop\");\n\tvar Keys = (function() {\n\t    var ret = {\n\t        MODIFIER_KEYS: {\n\t            16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'\n\t        },\n\n\t        KEY_MODS: {\n\t            \"ctrl\": 1, \"alt\": 2, \"option\" : 2, \"shift\": 4,\n\t            \"super\": 8, \"meta\": 8, \"command\": 8, \"cmd\": 8\n\t        },\n\n\t        FUNCTION_KEYS : {\n\t            8  : \"Backspace\",\n\t            9  : \"Tab\",\n\t            13 : \"Return\",\n\t            19 : \"Pause\",\n\t            27 : \"Esc\",\n\t            32 : \"Space\",\n\t            33 : \"PageUp\",\n\t            34 : \"PageDown\",\n\t            35 : \"End\",\n\t            36 : \"Home\",\n\t            37 : \"Left\",\n\t            38 : \"Up\",\n\t            39 : \"Right\",\n\t            40 : \"Down\",\n\t            44 : \"Print\",\n\t            45 : \"Insert\",\n\t            46 : \"Delete\",\n\t            96 : \"Numpad0\",\n\t            97 : \"Numpad1\",\n\t            98 : \"Numpad2\",\n\t            99 : \"Numpad3\",\n\t            100: \"Numpad4\",\n\t            101: \"Numpad5\",\n\t            102: \"Numpad6\",\n\t            103: \"Numpad7\",\n\t            104: \"Numpad8\",\n\t            105: \"Numpad9\",\n\t            '-13': \"NumpadEnter\",\n\t            112: \"F1\",\n\t            113: \"F2\",\n\t            114: \"F3\",\n\t            115: \"F4\",\n\t            116: \"F5\",\n\t            117: \"F6\",\n\t            118: \"F7\",\n\t            119: \"F8\",\n\t            120: \"F9\",\n\t            121: \"F10\",\n\t            122: \"F11\",\n\t            123: \"F12\",\n\t            144: \"Numlock\",\n\t            145: \"Scrolllock\"\n\t        },\n\n\t        PRINTABLE_KEYS: {\n\t           32: ' ',  48: '0',  49: '1',  50: '2',  51: '3',  52: '4', 53:  '5',\n\t           54: '6',  55: '7',  56: '8',  57: '9',  59: ';',  61: '=', 65:  'a',\n\t           66: 'b',  67: 'c',  68: 'd',  69: 'e',  70: 'f',  71: 'g', 72:  'h',\n\t           73: 'i',  74: 'j',  75: 'k',  76: 'l',  77: 'm',  78: 'n', 79:  'o',\n\t           80: 'p',  81: 'q',  82: 'r',  83: 's',  84: 't',  85: 'u', 86:  'v',\n\t           87: 'w',  88: 'x',  89: 'y',  90: 'z', 107: '+', 109: '-', 110: '.',\n\t          187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[',\n\t          220: '\\\\',221: ']', 222: '\\''\n\t        }\n\t    };\n\t    var name, i;\n\t    for (i in ret.FUNCTION_KEYS) {\n\t        name = ret.FUNCTION_KEYS[i].toLowerCase();\n\t        ret[name] = parseInt(i, 10);\n\t    }\n\t    for (i in ret.PRINTABLE_KEYS) {\n\t        name = ret.PRINTABLE_KEYS[i].toLowerCase();\n\t        ret[name] = parseInt(i, 10);\n\t    }\n\t    oop.mixin(ret, ret.MODIFIER_KEYS);\n\t    oop.mixin(ret, ret.PRINTABLE_KEYS);\n\t    oop.mixin(ret, ret.FUNCTION_KEYS);\n\t    ret.enter = ret[\"return\"];\n\t    ret.escape = ret.esc;\n\t    ret.del = ret[\"delete\"];\n\t    ret[173] = '-';\n\t    \n\t    (function() {\n\t        var mods = [\"cmd\", \"ctrl\", \"alt\", \"shift\"];\n\t        for (var i = Math.pow(2, mods.length); i--;) {            \n\t            ret.KEY_MODS[i] = mods.filter(function(x) {\n\t                return i & ret.KEY_MODS[x];\n\t            }).join(\"-\") + \"-\";\n\t        }\n\t    })();\n\n\t    ret.KEY_MODS[0] = \"\";\n\t    ret.KEY_MODS[-1] = \"input\";\n\n\t    return ret;\n\t})();\n\toop.mixin(exports, Keys);\n\n\texports.keyCodeToString = function(keyCode) {\n\t    var keyString = Keys[keyCode];\n\t    if (typeof keyString != \"string\")\n\t        keyString = String.fromCharCode(keyCode);\n\t    return keyString.toLowerCase();\n\t};\n\n\t});\n\n\tace.define(\"ace/lib/useragent\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\texports.OS = {\n\t    LINUX: \"LINUX\",\n\t    MAC: \"MAC\",\n\t    WINDOWS: \"WINDOWS\"\n\t};\n\texports.getOS = function() {\n\t    if (exports.isMac) {\n\t        return exports.OS.MAC;\n\t    } else if (exports.isLinux) {\n\t        return exports.OS.LINUX;\n\t    } else {\n\t        return exports.OS.WINDOWS;\n\t    }\n\t};\n\tif (typeof navigator != \"object\")\n\t    return;\n\n\tvar os = (navigator.platform.match(/mac|win|linux/i) || [\"other\"])[0].toLowerCase();\n\tvar ua = navigator.userAgent;\n\texports.isWin = (os == \"win\");\n\texports.isMac = (os == \"mac\");\n\texports.isLinux = (os == \"linux\");\n\texports.isIE = \n\t    (navigator.appName == \"Microsoft Internet Explorer\" || navigator.appName.indexOf(\"MSAppHost\") >= 0)\n\t    ? parseFloat((ua.match(/(?:MSIE |Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1])\n\t    : parseFloat((ua.match(/(?:Trident\\/[0-9]+[\\.0-9]+;.*rv:)([0-9]+[\\.0-9]+)/)||[])[1]); // for ie\n\t    \n\texports.isOldIE = exports.isIE && exports.isIE < 9;\n\texports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === \"Gecko\";\n\texports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\\:(\\d+)/)||[])[1], 10) < 4;\n\texports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == \"[object Opera]\";\n\texports.isWebKit = parseFloat(ua.split(\"WebKit/\")[1]) || undefined;\n\n\texports.isChrome = parseFloat(ua.split(\" Chrome/\")[1]) || undefined;\n\n\texports.isAIR = ua.indexOf(\"AdobeAIR\") >= 0;\n\n\texports.isIPad = ua.indexOf(\"iPad\") >= 0;\n\n\texports.isTouchPad = ua.indexOf(\"TouchPad\") >= 0;\n\n\texports.isChromeOS = ua.indexOf(\" CrOS \") >= 0;\n\n\t});\n\n\tace.define(\"ace/lib/event\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar keys = acequire(\"./keys\");\n\tvar useragent = acequire(\"./useragent\");\n\n\texports.addListener = function(elem, type, callback) {\n\t    if (elem.addEventListener) {\n\t        return elem.addEventListener(type, callback, false);\n\t    }\n\t    if (elem.attachEvent) {\n\t        var wrapper = function() {\n\t            callback.call(elem, window.event);\n\t        };\n\t        callback._wrapper = wrapper;\n\t        elem.attachEvent(\"on\" + type, wrapper);\n\t    }\n\t};\n\n\texports.removeListener = function(elem, type, callback) {\n\t    if (elem.removeEventListener) {\n\t        return elem.removeEventListener(type, callback, false);\n\t    }\n\t    if (elem.detachEvent) {\n\t        elem.detachEvent(\"on\" + type, callback._wrapper || callback);\n\t    }\n\t};\n\texports.stopEvent = function(e) {\n\t    exports.stopPropagation(e);\n\t    exports.preventDefault(e);\n\t    return false;\n\t};\n\n\texports.stopPropagation = function(e) {\n\t    if (e.stopPropagation)\n\t        e.stopPropagation();\n\t    else\n\t        e.cancelBubble = true;\n\t};\n\n\texports.preventDefault = function(e) {\n\t    if (e.preventDefault)\n\t        e.preventDefault();\n\t    else\n\t        e.returnValue = false;\n\t};\n\texports.getButton = function(e) {\n\t    if (e.type == \"dblclick\")\n\t        return 0;\n\t    if (e.type == \"contextmenu\" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))\n\t        return 2;\n\t    if (e.preventDefault) {\n\t        return e.button;\n\t    }\n\t    else {\n\t        return {1:0, 2:2, 4:1}[e.button];\n\t    }\n\t};\n\n\texports.capture = function(el, eventHandler, releaseCaptureHandler) {\n\t    function onMouseUp(e) {\n\t        eventHandler && eventHandler(e);\n\t        releaseCaptureHandler && releaseCaptureHandler(e);\n\n\t        exports.removeListener(document, \"mousemove\", eventHandler, true);\n\t        exports.removeListener(document, \"mouseup\", onMouseUp, true);\n\t        exports.removeListener(document, \"dragstart\", onMouseUp, true);\n\t    }\n\n\t    exports.addListener(document, \"mousemove\", eventHandler, true);\n\t    exports.addListener(document, \"mouseup\", onMouseUp, true);\n\t    exports.addListener(document, \"dragstart\", onMouseUp, true);\n\t    \n\t    return onMouseUp;\n\t};\n\n\texports.addMouseWheelListener = function(el, callback) {\n\t    if (\"onmousewheel\" in el) {\n\t        exports.addListener(el, \"mousewheel\", function(e) {\n\t            var factor = 8;\n\t            if (e.wheelDeltaX !== undefined) {\n\t                e.wheelX = -e.wheelDeltaX / factor;\n\t                e.wheelY = -e.wheelDeltaY / factor;\n\t            } else {\n\t                e.wheelX = 0;\n\t                e.wheelY = -e.wheelDelta / factor;\n\t            }\n\t            callback(e);\n\t        });\n\t    } else if (\"onwheel\" in el) {\n\t        exports.addListener(el, \"wheel\",  function(e) {\n\t            var factor = 0.35;\n\t            switch (e.deltaMode) {\n\t                case e.DOM_DELTA_PIXEL:\n\t                    e.wheelX = e.deltaX * factor || 0;\n\t                    e.wheelY = e.deltaY * factor || 0;\n\t                    break;\n\t                case e.DOM_DELTA_LINE:\n\t                case e.DOM_DELTA_PAGE:\n\t                    e.wheelX = (e.deltaX || 0) * 5;\n\t                    e.wheelY = (e.deltaY || 0) * 5;\n\t                    break;\n\t            }\n\t            \n\t            callback(e);\n\t        });\n\t    } else {\n\t        exports.addListener(el, \"DOMMouseScroll\", function(e) {\n\t            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {\n\t                e.wheelX = (e.detail || 0) * 5;\n\t                e.wheelY = 0;\n\t            } else {\n\t                e.wheelX = 0;\n\t                e.wheelY = (e.detail || 0) * 5;\n\t            }\n\t            callback(e);\n\t        });\n\t    }\n\t};\n\n\texports.addMultiMouseDownListener = function(el, timeouts, eventHandler, callbackName) {\n\t    var clicks = 0;\n\t    var startX, startY, timer; \n\t    var eventNames = {\n\t        2: \"dblclick\",\n\t        3: \"tripleclick\",\n\t        4: \"quadclick\"\n\t    };\n\n\t    exports.addListener(el, \"mousedown\", function(e) {\n\t        if (exports.getButton(e) !== 0) {\n\t            clicks = 0;\n\t        } else if (e.detail > 1) {\n\t            clicks++;\n\t            if (clicks > 4)\n\t                clicks = 1;\n\t        } else {\n\t            clicks = 1;\n\t        }\n\t        if (useragent.isIE) {\n\t            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;\n\t            if (!timer || isNewClick)\n\t                clicks = 1;\n\t            if (timer)\n\t                clearTimeout(timer);\n\t            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);\n\n\t            if (clicks == 1) {\n\t                startX = e.clientX;\n\t                startY = e.clientY;\n\t            }\n\t        }\n\t        \n\t        e._clicks = clicks;\n\n\t        eventHandler[callbackName](\"mousedown\", e);\n\n\t        if (clicks > 4)\n\t            clicks = 0;\n\t        else if (clicks > 1)\n\t            return eventHandler[callbackName](eventNames[clicks], e);\n\t    });\n\n\t    if (useragent.isOldIE) {\n\t        exports.addListener(el, \"dblclick\", function(e) {\n\t            clicks = 2;\n\t            if (timer)\n\t                clearTimeout(timer);\n\t            timer = setTimeout(function() {timer = null}, timeouts[clicks - 1] || 600);\n\t            eventHandler[callbackName](\"mousedown\", e);\n\t            eventHandler[callbackName](eventNames[clicks], e);\n\t        });\n\t    }\n\t};\n\n\tvar getModifierHash = useragent.isMac && useragent.isOpera && !(\"KeyboardEvent\" in window)\n\t    ? function(e) {\n\t        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);\n\t    }\n\t    : function(e) {\n\t        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);\n\t    };\n\n\texports.getModifierString = function(e) {\n\t    return keys.KEY_MODS[getModifierHash(e)];\n\t};\n\n\tfunction normalizeCommandKeys(callback, e, keyCode) {\n\t    var hashId = getModifierHash(e);\n\n\t    if (!useragent.isMac && pressedKeys) {\n\t        if (pressedKeys[91] || pressedKeys[92])\n\t            hashId |= 8;\n\t        if (pressedKeys.altGr) {\n\t            if ((3 & hashId) != 3)\n\t                pressedKeys.altGr = 0;\n\t            else\n\t                return;\n\t        }\n\t        if (keyCode === 18 || keyCode === 17) {\n\t            var location = \"location\" in e ? e.location : e.keyLocation;\n\t            if (keyCode === 17 && location === 1) {\n\t                ts = e.timeStamp;\n\t            } else if (keyCode === 18 && hashId === 3 && location === 2) {\n\t                var dt = -ts;\n\t                ts = e.timeStamp;\n\t                dt += ts;\n\t                if (dt < 3)\n\t                    pressedKeys.altGr = true;\n\t            }\n\t        }\n\t    }\n\t    \n\t    if (keyCode in keys.MODIFIER_KEYS) {\n\t        switch (keys.MODIFIER_KEYS[keyCode]) {\n\t            case \"Alt\":\n\t                hashId = 2;\n\t                break;\n\t            case \"Shift\":\n\t                hashId = 4;\n\t                break;\n\t            case \"Ctrl\":\n\t                hashId = 1;\n\t                break;\n\t            default:\n\t                hashId = 8;\n\t                break;\n\t        }\n\t        keyCode = -1;\n\t    }\n\n\t    if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {\n\t        keyCode = -1;\n\t    }\n\t    \n\t    if (!hashId && keyCode === 13) {\n\t        var location = \"location\" in e ? e.location : e.keyLocation;\n\t        if (location === 3) {\n\t            callback(e, hashId, -keyCode);\n\t            if (e.defaultPrevented)\n\t                return;\n\t        }\n\t    }\n\t    \n\t    if (useragent.isChromeOS && hashId & 8) {\n\t        callback(e, hashId, keyCode);\n\t        if (e.defaultPrevented)\n\t            return;\n\t        else\n\t            hashId &= ~8;\n\t    }\n\t    if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {\n\t        return false;\n\t    }\n\t    \n\t    return callback(e, hashId, keyCode);\n\t}\n\n\tvar pressedKeys = null;\n\tvar ts = 0;\n\texports.addCommandKeyListener = function(el, callback) {\n\t    var addListener = exports.addListener;\n\t    if (useragent.isOldGecko || (useragent.isOpera && !(\"KeyboardEvent\" in window))) {\n\t        var lastKeyDownKeyCode = null;\n\t        addListener(el, \"keydown\", function(e) {\n\t            lastKeyDownKeyCode = e.keyCode;\n\t        });\n\t        addListener(el, \"keypress\", function(e) {\n\t            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);\n\t        });\n\t    } else {\n\t        var lastDefaultPrevented = null;\n\n\t        addListener(el, \"keydown\", function(e) {\n\t            pressedKeys[e.keyCode] = true;\n\t            var result = normalizeCommandKeys(callback, e, e.keyCode);\n\t            lastDefaultPrevented = e.defaultPrevented;\n\t            return result;\n\t        });\n\n\t        addListener(el, \"keypress\", function(e) {\n\t            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {\n\t                exports.stopEvent(e);\n\t                lastDefaultPrevented = null;\n\t            }\n\t        });\n\n\t        addListener(el, \"keyup\", function(e) {\n\t            pressedKeys[e.keyCode] = null;\n\t        });\n\n\t        if (!pressedKeys) {\n\t            pressedKeys = Object.create(null);\n\t            addListener(window, \"focus\", function(e) {\n\t                pressedKeys = Object.create(null);\n\t            });\n\t        }\n\t    }\n\t};\n\n\tif (window.postMessage && !useragent.isOldIE) {\n\t    var postMessageId = 1;\n\t    exports.nextTick = function(callback, win) {\n\t        win = win || window;\n\t        var messageName = \"zero-timeout-message-\" + postMessageId;\n\t        exports.addListener(win, \"message\", function listener(e) {\n\t            if (e.data == messageName) {\n\t                exports.stopPropagation(e);\n\t                exports.removeListener(win, \"message\", listener);\n\t                callback();\n\t            }\n\t        });\n\t        win.postMessage(messageName, \"*\");\n\t    };\n\t}\n\n\n\texports.nextFrame = window.requestAnimationFrame ||\n\t    window.mozRequestAnimationFrame ||\n\t    window.webkitRequestAnimationFrame ||\n\t    window.msRequestAnimationFrame ||\n\t    window.oRequestAnimationFrame;\n\n\tif (exports.nextFrame)\n\t    exports.nextFrame = exports.nextFrame.bind(window);\n\telse\n\t    exports.nextFrame = function(callback) {\n\t        setTimeout(callback, 17);\n\t    };\n\t});\n\n\tace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\texports.last = function(a) {\n\t    return a[a.length - 1];\n\t};\n\n\texports.stringReverse = function(string) {\n\t    return string.split(\"\").reverse().join(\"\");\n\t};\n\n\texports.stringRepeat = function (string, count) {\n\t    var result = '';\n\t    while (count > 0) {\n\t        if (count & 1)\n\t            result += string;\n\n\t        if (count >>= 1)\n\t            string += string;\n\t    }\n\t    return result;\n\t};\n\n\tvar trimBeginRegexp = /^\\s\\s*/;\n\tvar trimEndRegexp = /\\s\\s*$/;\n\n\texports.stringTrimLeft = function (string) {\n\t    return string.replace(trimBeginRegexp, '');\n\t};\n\n\texports.stringTrimRight = function (string) {\n\t    return string.replace(trimEndRegexp, '');\n\t};\n\n\texports.copyObject = function(obj) {\n\t    var copy = {};\n\t    for (var key in obj) {\n\t        copy[key] = obj[key];\n\t    }\n\t    return copy;\n\t};\n\n\texports.copyArray = function(array){\n\t    var copy = [];\n\t    for (var i=0, l=array.length; i<l; i++) {\n\t        if (array[i] && typeof array[i] == \"object\")\n\t            copy[i] = this.copyObject( array[i] );\n\t        else \n\t            copy[i] = array[i];\n\t    }\n\t    return copy;\n\t};\n\n\texports.deepCopy = function (obj) {\n\t    if (typeof obj !== \"object\" || !obj)\n\t        return obj;\n\t    var cons = obj.constructor;\n\t    if (cons === RegExp)\n\t        return obj;\n\t    \n\t    var copy = cons();\n\t    for (var key in obj) {\n\t        if (typeof obj[key] === \"object\") {\n\t            copy[key] = exports.deepCopy(obj[key]);\n\t        } else {\n\t            copy[key] = obj[key];\n\t        }\n\t    }\n\t    return copy;\n\t};\n\n\texports.arrayToMap = function(arr) {\n\t    var map = {};\n\t    for (var i=0; i<arr.length; i++) {\n\t        map[arr[i]] = 1;\n\t    }\n\t    return map;\n\n\t};\n\n\texports.createMap = function(props) {\n\t    var map = Object.create(null);\n\t    for (var i in props) {\n\t        map[i] = props[i];\n\t    }\n\t    return map;\n\t};\n\texports.arrayRemove = function(array, value) {\n\t  for (var i = 0; i <= array.length; i++) {\n\t    if (value === array[i]) {\n\t      array.splice(i, 1);\n\t    }\n\t  }\n\t};\n\n\texports.escapeRegExp = function(str) {\n\t    return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g, '\\\\$1');\n\t};\n\n\texports.escapeHTML = function(str) {\n\t    return str.replace(/&/g, \"&#38;\").replace(/\"/g, \"&#34;\").replace(/'/g, \"&#39;\").replace(/</g, \"&#60;\");\n\t};\n\n\texports.getMatchOffsets = function(string, regExp) {\n\t    var matches = [];\n\n\t    string.replace(regExp, function(str) {\n\t        matches.push({\n\t            offset: arguments[arguments.length-2],\n\t            length: str.length\n\t        });\n\t    });\n\n\t    return matches;\n\t};\n\texports.deferredCall = function(fcn) {\n\t    var timer = null;\n\t    var callback = function() {\n\t        timer = null;\n\t        fcn();\n\t    };\n\n\t    var deferred = function(timeout) {\n\t        deferred.cancel();\n\t        timer = setTimeout(callback, timeout || 0);\n\t        return deferred;\n\t    };\n\n\t    deferred.schedule = deferred;\n\n\t    deferred.call = function() {\n\t        this.cancel();\n\t        fcn();\n\t        return deferred;\n\t    };\n\n\t    deferred.cancel = function() {\n\t        clearTimeout(timer);\n\t        timer = null;\n\t        return deferred;\n\t    };\n\t    \n\t    deferred.isPending = function() {\n\t        return timer;\n\t    };\n\n\t    return deferred;\n\t};\n\n\n\texports.delayedCall = function(fcn, defaultTimeout) {\n\t    var timer = null;\n\t    var callback = function() {\n\t        timer = null;\n\t        fcn();\n\t    };\n\n\t    var _self = function(timeout) {\n\t        if (timer == null)\n\t            timer = setTimeout(callback, timeout || defaultTimeout);\n\t    };\n\n\t    _self.delay = function(timeout) {\n\t        timer && clearTimeout(timer);\n\t        timer = setTimeout(callback, timeout || defaultTimeout);\n\t    };\n\t    _self.schedule = _self;\n\n\t    _self.call = function() {\n\t        this.cancel();\n\t        fcn();\n\t    };\n\n\t    _self.cancel = function() {\n\t        timer && clearTimeout(timer);\n\t        timer = null;\n\t    };\n\n\t    _self.isPending = function() {\n\t        return timer;\n\t    };\n\n\t    return _self;\n\t};\n\t});\n\n\tace.define(\"ace/keyboard/textinput\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/lib/dom\",\"ace/lib/lang\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar event = acequire(\"../lib/event\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tvar dom = acequire(\"../lib/dom\");\n\tvar lang = acequire(\"../lib/lang\");\n\tvar BROKEN_SETDATA = useragent.isChrome < 18;\n\tvar USE_IE_MIME_TYPE =  useragent.isIE;\n\n\tvar TextInput = function(parentNode, host) {\n\t    var text = dom.createElement(\"textarea\");\n\t    text.className = \"ace_text-input\";\n\n\t    if (useragent.isTouchPad)\n\t        text.setAttribute(\"x-palm-disable-auto-cap\", true);\n\n\t    text.wrap = \"off\";\n\t    text.autocorrect = \"off\";\n\t    text.autocapitalize = \"off\";\n\t    text.spellcheck = false;\n\n\t    text.style.opacity = \"0\";\n\t    if (useragent.isOldIE) text.style.top = \"-100px\";\n\t    parentNode.insertBefore(text, parentNode.firstChild);\n\n\t    var PLACEHOLDER = \"\\x01\\x01\";\n\n\t    var copied = false;\n\t    var pasted = false;\n\t    var inComposition = false;\n\t    var tempStyle = '';\n\t    var isSelectionEmpty = true;\n\t    try { var isFocused = document.activeElement === text; } catch(e) {}\n\t    \n\t    event.addListener(text, \"blur\", function(e) {\n\t        host.onBlur(e);\n\t        isFocused = false;\n\t    });\n\t    event.addListener(text, \"focus\", function(e) {\n\t        isFocused = true;\n\t        host.onFocus(e);\n\t        resetSelection();\n\t    });\n\t    this.focus = function() { text.focus(); };\n\t    this.blur = function() { text.blur(); };\n\t    this.isFocused = function() {\n\t        return isFocused;\n\t    };\n\t    var syncSelection = lang.delayedCall(function() {\n\t        isFocused && resetSelection(isSelectionEmpty);\n\t    });\n\t    var syncValue = lang.delayedCall(function() {\n\t         if (!inComposition) {\n\t            text.value = PLACEHOLDER;\n\t            isFocused && resetSelection();\n\t         }\n\t    });\n\n\t    function resetSelection(isEmpty) {\n\t        if (inComposition)\n\t            return;\n\t        if (inputHandler) {\n\t            selectionStart = 0;\n\t            selectionEnd = isEmpty ? 0 : text.value.length - 1;\n\t        } else {\n\t            var selectionStart = isEmpty ? 2 : 1;\n\t            var selectionEnd = 2;\n\t        }\n\t        try {\n\t            text.setSelectionRange(selectionStart, selectionEnd);\n\t        } catch(e){}\n\t    }\n\n\t    function resetValue() {\n\t        if (inComposition)\n\t            return;\n\t        text.value = PLACEHOLDER;\n\t        if (useragent.isWebKit)\n\t            syncValue.schedule();\n\t    }\n\n\t    useragent.isWebKit || host.addEventListener('changeSelection', function() {\n\t        if (host.selection.isEmpty() != isSelectionEmpty) {\n\t            isSelectionEmpty = !isSelectionEmpty;\n\t            syncSelection.schedule();\n\t        }\n\t    });\n\n\t    resetValue();\n\t    if (isFocused)\n\t        host.onFocus();\n\n\n\t    var isAllSelected = function(text) {\n\t        return text.selectionStart === 0 && text.selectionEnd === text.value.length;\n\t    };\n\t    if (!text.setSelectionRange && text.createTextRange) {\n\t        text.setSelectionRange = function(selectionStart, selectionEnd) {\n\t            var range = this.createTextRange();\n\t            range.collapse(true);\n\t            range.moveStart('character', selectionStart);\n\t            range.moveEnd('character', selectionEnd);\n\t            range.select();\n\t        };\n\t        isAllSelected = function(text) {\n\t            try {\n\t                var range = text.ownerDocument.selection.createRange();\n\t            }catch(e) {}\n\t            if (!range || range.parentElement() != text) return false;\n\t                return range.text == text.value;\n\t        }\n\t    }\n\t    if (useragent.isOldIE) {\n\t        var inPropertyChange = false;\n\t        var onPropertyChange = function(e){\n\t            if (inPropertyChange)\n\t                return;\n\t            var data = text.value;\n\t            if (inComposition || !data || data == PLACEHOLDER)\n\t                return;\n\t            if (e && data == PLACEHOLDER[0])\n\t                return syncProperty.schedule();\n\n\t            sendText(data);\n\t            inPropertyChange = true;\n\t            resetValue();\n\t            inPropertyChange = false;\n\t        };\n\t        var syncProperty = lang.delayedCall(onPropertyChange);\n\t        event.addListener(text, \"propertychange\", onPropertyChange);\n\n\t        var keytable = { 13:1, 27:1 };\n\t        event.addListener(text, \"keyup\", function (e) {\n\t            if (inComposition && (!text.value || keytable[e.keyCode]))\n\t                setTimeout(onCompositionEnd, 0);\n\t            if ((text.value.charCodeAt(0)||0) < 129) {\n\t                return syncProperty.call();\n\t            }\n\t            inComposition ? onCompositionUpdate() : onCompositionStart();\n\t        });\n\t        event.addListener(text, \"keydown\", function (e) {\n\t            syncProperty.schedule(50);\n\t        });\n\t    }\n\n\t    var onSelect = function(e) {\n\t        if (copied) {\n\t            copied = false;\n\t        } else if (isAllSelected(text)) {\n\t            host.selectAll();\n\t            resetSelection();\n\t        } else if (inputHandler) {\n\t            resetSelection(host.selection.isEmpty());\n\t        }\n\t    };\n\n\t    var inputHandler = null;\n\t    this.setInputHandler = function(cb) {inputHandler = cb};\n\t    this.getInputHandler = function() {return inputHandler};\n\t    var afterContextMenu = false;\n\t    \n\t    var sendText = function(data) {\n\t        if (inputHandler) {\n\t            data = inputHandler(data);\n\t            inputHandler = null;\n\t        }\n\t        if (pasted) {\n\t            resetSelection();\n\t            if (data)\n\t                host.onPaste(data);\n\t            pasted = false;\n\t        } else if (data == PLACEHOLDER.charAt(0)) {\n\t            if (afterContextMenu)\n\t                host.execCommand(\"del\", {source: \"ace\"});\n\t            else // some versions of android do not fire keydown when pressing backspace\n\t                host.execCommand(\"backspace\", {source: \"ace\"});\n\t        } else {\n\t            if (data.substring(0, 2) == PLACEHOLDER)\n\t                data = data.substr(2);\n\t            else if (data.charAt(0) == PLACEHOLDER.charAt(0))\n\t                data = data.substr(1);\n\t            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))\n\t                data = data.slice(0, -1);\n\t            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))\n\t                data = data.slice(0, -1);\n\t            \n\t            if (data)\n\t                host.onTextInput(data);\n\t        }\n\t        if (afterContextMenu)\n\t            afterContextMenu = false;\n\t    };\n\t    var onInput = function(e) {\n\t        if (inComposition)\n\t            return;\n\t        var data = text.value;\n\t        sendText(data);\n\t        resetValue();\n\t    };\n\t    \n\t    var handleClipboardData = function(e, data) {\n\t        var clipboardData = e.clipboardData || window.clipboardData;\n\t        if (!clipboardData || BROKEN_SETDATA)\n\t            return;\n\t        var mime = USE_IE_MIME_TYPE ? \"Text\" : \"text/plain\";\n\t        if (data) {\n\t            return clipboardData.setData(mime, data) !== false;\n\t        } else {\n\t            return clipboardData.getData(mime);\n\t        }\n\t    };\n\n\t    var doCopy = function(e, isCut) {\n\t        var data = host.getCopyText();\n\t        if (!data)\n\t            return event.preventDefault(e);\n\n\t        if (handleClipboardData(e, data)) {\n\t            isCut ? host.onCut() : host.onCopy();\n\t            event.preventDefault(e);\n\t        } else {\n\t            copied = true;\n\t            text.value = data;\n\t            text.select();\n\t            setTimeout(function(){\n\t                copied = false;\n\t                resetValue();\n\t                resetSelection();\n\t                isCut ? host.onCut() : host.onCopy();\n\t            });\n\t        }\n\t    };\n\t    \n\t    var onCut = function(e) {\n\t        doCopy(e, true);\n\t    };\n\t    \n\t    var onCopy = function(e) {\n\t        doCopy(e, false);\n\t    };\n\t    \n\t    var onPaste = function(e) {\n\t        var data = handleClipboardData(e);\n\t        if (typeof data == \"string\") {\n\t            if (data)\n\t                host.onPaste(data);\n\t            if (useragent.isIE)\n\t                setTimeout(resetSelection);\n\t            event.preventDefault(e);\n\t        }\n\t        else {\n\t            text.value = \"\";\n\t            pasted = true;\n\t        }\n\t    };\n\n\t    event.addCommandKeyListener(text, host.onCommandKey.bind(host));\n\n\t    event.addListener(text, \"select\", onSelect);\n\n\t    event.addListener(text, \"input\", onInput);\n\n\t    event.addListener(text, \"cut\", onCut);\n\t    event.addListener(text, \"copy\", onCopy);\n\t    event.addListener(text, \"paste\", onPaste);\n\t    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)){\n\t        event.addListener(parentNode, \"keydown\", function(e) {\n\t            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)\n\t                return;\n\n\t            switch (e.keyCode) {\n\t                case 67:\n\t                    onCopy(e);\n\t                    break;\n\t                case 86:\n\t                    onPaste(e);\n\t                    break;\n\t                case 88:\n\t                    onCut(e);\n\t                    break;\n\t            }\n\t        });\n\t    }\n\t    var onCompositionStart = function(e) {\n\t        if (inComposition || !host.onCompositionStart || host.$readOnly) \n\t            return;\n\t        inComposition = {};\n\t        host.onCompositionStart();\n\t        setTimeout(onCompositionUpdate, 0);\n\t        host.on(\"mousedown\", onCompositionEnd);\n\t        if (!host.selection.isEmpty()) {\n\t            host.insert(\"\");\n\t            host.session.markUndoGroup();\n\t            host.selection.clearSelection();\n\t        }\n\t        host.session.markUndoGroup();\n\t    };\n\n\t    var onCompositionUpdate = function() {\n\t        if (!inComposition || !host.onCompositionUpdate || host.$readOnly)\n\t            return;\n\t        var val = text.value.replace(/\\x01/g, \"\");\n\t        if (inComposition.lastValue === val) return;\n\t        \n\t        host.onCompositionUpdate(val);\n\t        if (inComposition.lastValue)\n\t            host.undo();\n\t        inComposition.lastValue = val;\n\t        if (inComposition.lastValue) {\n\t            var r = host.selection.getRange();\n\t            host.insert(inComposition.lastValue);\n\t            host.session.markUndoGroup();\n\t            inComposition.range = host.selection.getRange();\n\t            host.selection.setRange(r);\n\t            host.selection.clearSelection();\n\t        }\n\t    };\n\n\t    var onCompositionEnd = function(e) {\n\t        if (!host.onCompositionEnd || host.$readOnly) return;\n\t        var c = inComposition;\n\t        inComposition = false;\n\t        var timer = setTimeout(function() {\n\t            timer = null;\n\t            var str = text.value.replace(/\\x01/g, \"\");\n\t            if (inComposition)\n\t                return;\n\t            else if (str == c.lastValue)\n\t                resetValue();\n\t            else if (!c.lastValue && str) {\n\t                resetValue();\n\t                sendText(str);\n\t            }\n\t        });\n\t        inputHandler = function compositionInputHandler(str) {\n\t            if (timer)\n\t                clearTimeout(timer);\n\t            str = str.replace(/\\x01/g, \"\");\n\t            if (str == c.lastValue)\n\t                return \"\";\n\t            if (c.lastValue && timer)\n\t                host.undo();\n\t            return str;\n\t        };\n\t        host.onCompositionEnd();\n\t        host.removeListener(\"mousedown\", onCompositionEnd);\n\t        if (e.type == \"compositionend\" && c.range) {\n\t            host.selection.setRange(c.range);\n\t        }\n\t    };\n\t    \n\t    \n\n\t    var syncComposition = lang.delayedCall(onCompositionUpdate, 50);\n\n\t    event.addListener(text, \"compositionstart\", onCompositionStart);\n\t    if (useragent.isGecko) {\n\t        event.addListener(text, \"text\", function(){syncComposition.schedule()});\n\t    } else {\n\t        event.addListener(text, \"keyup\", function(){syncComposition.schedule()});\n\t        event.addListener(text, \"keydown\", function(){syncComposition.schedule()});\n\t    }\n\t    event.addListener(text, \"compositionend\", onCompositionEnd);\n\n\t    this.getElement = function() {\n\t        return text;\n\t    };\n\n\t    this.setReadOnly = function(readOnly) {\n\t       text.readOnly = readOnly;\n\t    };\n\n\t    this.onContextMenu = function(e) {\n\t        afterContextMenu = true;\n\t        resetSelection(host.selection.isEmpty());\n\t        host._emit(\"nativecontextmenu\", {target: host, domEvent: e});\n\t        this.moveToMouse(e, true);\n\t    };\n\t    \n\t    this.moveToMouse = function(e, bringToFront) {\n\t        if (!bringToFront && useragent.isOldIE)\n\t            return;\n\t        if (!tempStyle)\n\t            tempStyle = text.style.cssText;\n\t        text.style.cssText = (bringToFront ? \"z-index:100000;\" : \"\")\n\t            + \"height:\" + text.style.height + \";\"\n\t            + (useragent.isIE ? \"opacity:0.1;\" : \"\");\n\n\t        var rect = host.container.getBoundingClientRect();\n\t        var style = dom.computedStyle(host.container);\n\t        var top = rect.top + (parseInt(style.borderTopWidth) || 0);\n\t        var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);\n\t        var maxTop = rect.bottom - top - text.clientHeight -2;\n\t        var move = function(e) {\n\t            text.style.left = e.clientX - left - 2 + \"px\";\n\t            text.style.top = Math.min(e.clientY - top - 2, maxTop) + \"px\";\n\t        }; \n\t        move(e);\n\n\t        if (e.type != \"mousedown\")\n\t            return;\n\n\t        if (host.renderer.$keepTextAreaAtCursor)\n\t            host.renderer.$keepTextAreaAtCursor = null;\n\t        if (useragent.isWin && !useragent.isOldIE)\n\t            event.capture(host.container, move, onContextMenuClose);\n\t    };\n\n\t    this.onContextMenuClose = onContextMenuClose;\n\t    var closeTimeout;\n\t    function onContextMenuClose() {\n\t        clearTimeout(closeTimeout)\n\t        closeTimeout = setTimeout(function () {\n\t            if (tempStyle) {\n\t                text.style.cssText = tempStyle;\n\t                tempStyle = '';\n\t            }\n\t            if (host.renderer.$keepTextAreaAtCursor == null) {\n\t                host.renderer.$keepTextAreaAtCursor = true;\n\t                host.renderer.$moveTextAreaToCursor();\n\t            }\n\t        }, useragent.isOldIE ? 200 : 0);\n\t    }\n\n\t    var onContextMenu = function(e) {\n\t        host.textInput.onContextMenu(e);\n\t        onContextMenuClose();\n\t    };\n\t    event.addListener(host.renderer.scroller, \"contextmenu\", onContextMenu);\n\t    event.addListener(text, \"contextmenu\", onContextMenu);\n\t};\n\n\texports.TextInput = TextInput;\n\t});\n\n\tace.define(\"ace/mouse/default_handlers\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tvar event = acequire(\"../lib/event\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\n\tvar DRAG_OFFSET = 0; // pixels\n\n\tfunction DefaultHandlers(mouseHandler) {\n\t    mouseHandler.$clickSelection = null;\n\n\t    var editor = mouseHandler.editor;\n\t    editor.setDefaultHandler(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n\t    editor.setDefaultHandler(\"dblclick\", this.onDoubleClick.bind(mouseHandler));\n\t    editor.setDefaultHandler(\"tripleclick\", this.onTripleClick.bind(mouseHandler));\n\t    editor.setDefaultHandler(\"quadclick\", this.onQuadClick.bind(mouseHandler));\n\t    editor.setDefaultHandler(\"mousewheel\", this.onMouseWheel.bind(mouseHandler));\n\n\t    var exports = [\"select\", \"startSelect\", \"selectEnd\", \"selectAllEnd\", \"selectByWordsEnd\",\n\t        \"selectByLinesEnd\", \"dragWait\", \"dragWaitEnd\", \"focusWait\"];\n\n\t    exports.forEach(function(x) {\n\t        mouseHandler[x] = this[x];\n\t    }, this);\n\n\t    mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, \"getLineRange\");\n\t    mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, \"getWordRange\");\n\t}\n\n\t(function() {\n\n\t    this.onMouseDown = function(ev) {\n\t        var inSelection = ev.inSelection();\n\t        var pos = ev.getDocumentPosition();\n\t        this.mousedownEvent = ev;\n\t        var editor = this.editor;\n\n\t        var button = ev.getButton();\n\t        if (button !== 0) {\n\t            var selectionRange = editor.getSelectionRange();\n\t            var selectionEmpty = selectionRange.isEmpty();\n\n\t            if (selectionEmpty)\n\t                editor.selection.moveToPosition(pos);\n\t            editor.textInput.onContextMenu(ev.domEvent);\n\t            return; // stopping event here breaks contextmenu on ff mac\n\t        }\n\n\t        this.mousedownEvent.time = Date.now();\n\t        if (inSelection && !editor.isFocused()) {\n\t            editor.focus();\n\t            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {\n\t                this.setState(\"focusWait\");\n\t                this.captureMouse(ev);\n\t                return;\n\t            }\n\t        }\n\n\t        this.captureMouse(ev);\n\t        this.startSelect(pos, ev.domEvent._clicks > 1);\n\t        return ev.preventDefault();\n\t    };\n\n\t    this.startSelect = function(pos, waitForClickSelection) {\n\t        pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);\n\t        var editor = this.editor;\n\t        \n\t        if (this.mousedownEvent.getShiftKey())\n\t            editor.selection.selectToPosition(pos);\n\t        else if (!waitForClickSelection)\n\t            editor.selection.moveToPosition(pos);\n\t        if (!waitForClickSelection)\n\t            this.select();\n\t        if (editor.renderer.scroller.setCapture) {\n\t            editor.renderer.scroller.setCapture();\n\t        }\n\t        editor.setStyle(\"ace_selecting\");\n\t        this.setState(\"select\");\n\t    };\n\n\t    this.select = function() {\n\t        var anchor, editor = this.editor;\n\t        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n\n\t        if (this.$clickSelection) {\n\t            var cmp = this.$clickSelection.comparePoint(cursor);\n\n\t            if (cmp == -1) {\n\t                anchor = this.$clickSelection.end;\n\t            } else if (cmp == 1) {\n\t                anchor = this.$clickSelection.start;\n\t            } else {\n\t                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n\t                cursor = orientedRange.cursor;\n\t                anchor = orientedRange.anchor;\n\t            }\n\t            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n\t        }\n\t        editor.selection.selectToPosition(cursor);\n\n\t        editor.renderer.scrollCursorIntoView();\n\t    };\n\n\t    this.extendSelectionBy = function(unitName) {\n\t        var anchor, editor = this.editor;\n\t        var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);\n\t        var range = editor.selection[unitName](cursor.row, cursor.column);\n\n\t        if (this.$clickSelection) {\n\t            var cmpStart = this.$clickSelection.comparePoint(range.start);\n\t            var cmpEnd = this.$clickSelection.comparePoint(range.end);\n\n\t            if (cmpStart == -1 && cmpEnd <= 0) {\n\t                anchor = this.$clickSelection.end;\n\t                if (range.end.row != cursor.row || range.end.column != cursor.column)\n\t                    cursor = range.start;\n\t            } else if (cmpEnd == 1 && cmpStart >= 0) {\n\t                anchor = this.$clickSelection.start;\n\t                if (range.start.row != cursor.row || range.start.column != cursor.column)\n\t                    cursor = range.end;\n\t            } else if (cmpStart == -1 && cmpEnd == 1) {\n\t                cursor = range.end;\n\t                anchor = range.start;\n\t            } else {\n\t                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);\n\t                cursor = orientedRange.cursor;\n\t                anchor = orientedRange.anchor;\n\t            }\n\t            editor.selection.setSelectionAnchor(anchor.row, anchor.column);\n\t        }\n\t        editor.selection.selectToPosition(cursor);\n\n\t        editor.renderer.scrollCursorIntoView();\n\t    };\n\n\t    this.selectEnd =\n\t    this.selectAllEnd =\n\t    this.selectByWordsEnd =\n\t    this.selectByLinesEnd = function() {\n\t        this.$clickSelection = null;\n\t        this.editor.unsetStyle(\"ace_selecting\");\n\t        if (this.editor.renderer.scroller.releaseCapture) {\n\t            this.editor.renderer.scroller.releaseCapture();\n\t        }\n\t    };\n\n\t    this.focusWait = function() {\n\t        var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n\t        var time = Date.now();\n\n\t        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)\n\t            this.startSelect(this.mousedownEvent.getDocumentPosition());\n\t    };\n\n\t    this.onDoubleClick = function(ev) {\n\t        var pos = ev.getDocumentPosition();\n\t        var editor = this.editor;\n\t        var session = editor.session;\n\n\t        var range = session.getBracketRange(pos);\n\t        if (range) {\n\t            if (range.isEmpty()) {\n\t                range.start.column--;\n\t                range.end.column++;\n\t            }\n\t            this.setState(\"select\");\n\t        } else {\n\t            range = editor.selection.getWordRange(pos.row, pos.column);\n\t            this.setState(\"selectByWords\");\n\t        }\n\t        this.$clickSelection = range;\n\t        this.select();\n\t    };\n\n\t    this.onTripleClick = function(ev) {\n\t        var pos = ev.getDocumentPosition();\n\t        var editor = this.editor;\n\n\t        this.setState(\"selectByLines\");\n\t        var range = editor.getSelectionRange();\n\t        if (range.isMultiLine() && range.contains(pos.row, pos.column)) {\n\t            this.$clickSelection = editor.selection.getLineRange(range.start.row);\n\t            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;\n\t        } else {\n\t            this.$clickSelection = editor.selection.getLineRange(pos.row);\n\t        }\n\t        this.select();\n\t    };\n\n\t    this.onQuadClick = function(ev) {\n\t        var editor = this.editor;\n\n\t        editor.selectAll();\n\t        this.$clickSelection = editor.getSelectionRange();\n\t        this.setState(\"selectAll\");\n\t    };\n\n\t    this.onMouseWheel = function(ev) {\n\t        if (ev.getAccelKey())\n\t            return;\n\t        if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {\n\t            ev.wheelX = ev.wheelY;\n\t            ev.wheelY = 0;\n\t        }\n\n\t        var t = ev.domEvent.timeStamp;\n\t        var dt = t - (this.$lastScrollTime||0);\n\t        \n\t        var editor = this.editor;\n\t        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n\t        if (isScrolable || dt < 200) {\n\t            this.$lastScrollTime = t;\n\t            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);\n\t            return ev.stop();\n\t        }\n\t    };\n\n\t}).call(DefaultHandlers.prototype);\n\n\texports.DefaultHandlers = DefaultHandlers;\n\n\tfunction calcDistance(ax, ay, bx, by) {\n\t    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n\t}\n\n\tfunction calcRangeOrientation(range, cursor) {\n\t    if (range.start.row == range.end.row)\n\t        var cmp = 2 * cursor.column - range.start.column - range.end.column;\n\t    else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)\n\t        var cmp = cursor.column - 4;\n\t    else\n\t        var cmp = 2 * cursor.row - range.start.row - range.end.row;\n\n\t    if (cmp < 0)\n\t        return {cursor: range.start, anchor: range.end};\n\t    else\n\t        return {cursor: range.end, anchor: range.start};\n\t}\n\n\t});\n\n\tace.define(\"ace/tooltip\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar dom = acequire(\"./lib/dom\");\n\tfunction Tooltip (parentNode) {\n\t    this.isOpen = false;\n\t    this.$element = null;\n\t    this.$parentNode = parentNode;\n\t}\n\n\t(function() {\n\t    this.$init = function() {\n\t        this.$element = dom.createElement(\"div\");\n\t        this.$element.className = \"ace_tooltip\";\n\t        this.$element.style.display = \"none\";\n\t        this.$parentNode.appendChild(this.$element);\n\t        return this.$element;\n\t    };\n\t    this.getElement = function() {\n\t        return this.$element || this.$init();\n\t    };\n\t    this.setText = function(text) {\n\t        dom.setInnerText(this.getElement(), text);\n\t    };\n\t    this.setHtml = function(html) {\n\t        this.getElement().innerHTML = html;\n\t    };\n\t    this.setPosition = function(x, y) {\n\t        this.getElement().style.left = x + \"px\";\n\t        this.getElement().style.top = y + \"px\";\n\t    };\n\t    this.setClassName = function(className) {\n\t        dom.addCssClass(this.getElement(), className);\n\t    };\n\t    this.show = function(text, x, y) {\n\t        if (text != null)\n\t            this.setText(text);\n\t        if (x != null && y != null)\n\t            this.setPosition(x, y);\n\t        if (!this.isOpen) {\n\t            this.getElement().style.display = \"block\";\n\t            this.isOpen = true;\n\t        }\n\t    };\n\n\t    this.hide = function() {\n\t        if (this.isOpen) {\n\t            this.getElement().style.display = \"none\";\n\t            this.isOpen = false;\n\t        }\n\t    };\n\t    this.getHeight = function() {\n\t        return this.getElement().offsetHeight;\n\t    };\n\t    this.getWidth = function() {\n\t        return this.getElement().offsetWidth;\n\t    };\n\n\t}).call(Tooltip.prototype);\n\n\texports.Tooltip = Tooltip;\n\t});\n\n\tace.define(\"ace/mouse/default_gutter_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/event\",\"ace/tooltip\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar dom = acequire(\"../lib/dom\");\n\tvar oop = acequire(\"../lib/oop\");\n\tvar event = acequire(\"../lib/event\");\n\tvar Tooltip = acequire(\"../tooltip\").Tooltip;\n\n\tfunction GutterHandler(mouseHandler) {\n\t    var editor = mouseHandler.editor;\n\t    var gutter = editor.renderer.$gutterLayer;\n\t    var tooltip = new GutterTooltip(editor.container);\n\n\t    mouseHandler.editor.setDefaultHandler(\"guttermousedown\", function(e) {\n\t        if (!editor.isFocused() || e.getButton() != 0)\n\t            return;\n\t        var gutterRegion = gutter.getRegion(e);\n\n\t        if (gutterRegion == \"foldWidgets\")\n\t            return;\n\n\t        var row = e.getDocumentPosition().row;\n\t        var selection = editor.session.selection;\n\n\t        if (e.getShiftKey())\n\t            selection.selectTo(row, 0);\n\t        else {\n\t            if (e.domEvent.detail == 2) {\n\t                editor.selectAll();\n\t                return e.preventDefault();\n\t            }\n\t            mouseHandler.$clickSelection = editor.selection.getLineRange(row);\n\t        }\n\t        mouseHandler.setState(\"selectByLines\");\n\t        mouseHandler.captureMouse(e);\n\t        return e.preventDefault();\n\t    });\n\n\n\t    var tooltipTimeout, mouseEvent, tooltipAnnotation;\n\n\t    function showTooltip() {\n\t        var row = mouseEvent.getDocumentPosition().row;\n\t        var annotation = gutter.$annotations[row];\n\t        if (!annotation)\n\t            return hideTooltip();\n\n\t        var maxRow = editor.session.getLength();\n\t        if (row == maxRow) {\n\t            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;\n\t            var pos = mouseEvent.$pos;\n\t            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))\n\t                return hideTooltip();\n\t        }\n\n\t        if (tooltipAnnotation == annotation)\n\t            return;\n\t        tooltipAnnotation = annotation.text.join(\"<br/>\");\n\n\t        tooltip.setHtml(tooltipAnnotation);\n\t        tooltip.show();\n\t        editor.on(\"mousewheel\", hideTooltip);\n\n\t        if (mouseHandler.$tooltipFollowsMouse) {\n\t            moveTooltip(mouseEvent);\n\t        } else {\n\t            var gutterElement = gutter.$cells[editor.session.documentToScreenRow(row, 0)].element;\n\t            var rect = gutterElement.getBoundingClientRect();\n\t            var style = tooltip.getElement().style;\n\t            style.left = rect.right + \"px\";\n\t            style.top = rect.bottom + \"px\";\n\t        }\n\t    }\n\n\t    function hideTooltip() {\n\t        if (tooltipTimeout)\n\t            tooltipTimeout = clearTimeout(tooltipTimeout);\n\t        if (tooltipAnnotation) {\n\t            tooltip.hide();\n\t            tooltipAnnotation = null;\n\t            editor.removeEventListener(\"mousewheel\", hideTooltip);\n\t        }\n\t    }\n\n\t    function moveTooltip(e) {\n\t        tooltip.setPosition(e.x, e.y);\n\t    }\n\n\t    mouseHandler.editor.setDefaultHandler(\"guttermousemove\", function(e) {\n\t        var target = e.domEvent.target || e.domEvent.srcElement;\n\t        if (dom.hasCssClass(target, \"ace_fold-widget\"))\n\t            return hideTooltip();\n\n\t        if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)\n\t            moveTooltip(e);\n\n\t        mouseEvent = e;\n\t        if (tooltipTimeout)\n\t            return;\n\t        tooltipTimeout = setTimeout(function() {\n\t            tooltipTimeout = null;\n\t            if (mouseEvent && !mouseHandler.isMousePressed)\n\t                showTooltip();\n\t            else\n\t                hideTooltip();\n\t        }, 50);\n\t    });\n\n\t    event.addListener(editor.renderer.$gutter, \"mouseout\", function(e) {\n\t        mouseEvent = null;\n\t        if (!tooltipAnnotation || tooltipTimeout)\n\t            return;\n\n\t        tooltipTimeout = setTimeout(function() {\n\t            tooltipTimeout = null;\n\t            hideTooltip();\n\t        }, 50);\n\t    });\n\t    \n\t    editor.on(\"changeSession\", hideTooltip);\n\t}\n\n\tfunction GutterTooltip(parentNode) {\n\t    Tooltip.call(this, parentNode);\n\t}\n\n\toop.inherits(GutterTooltip, Tooltip);\n\n\t(function(){\n\t    this.setPosition = function(x, y) {\n\t        var windowWidth = window.innerWidth || document.documentElement.clientWidth;\n\t        var windowHeight = window.innerHeight || document.documentElement.clientHeight;\n\t        var width = this.getWidth();\n\t        var height = this.getHeight();\n\t        x += 15;\n\t        y += 15;\n\t        if (x + width > windowWidth) {\n\t            x -= (x + width) - windowWidth;\n\t        }\n\t        if (y + height > windowHeight) {\n\t            y -= 20 + height;\n\t        }\n\t        Tooltip.prototype.setPosition.call(this, x, y);\n\t    };\n\n\t}).call(GutterTooltip.prototype);\n\n\n\n\texports.GutterHandler = GutterHandler;\n\n\t});\n\n\tace.define(\"ace/mouse/mouse_event\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar event = acequire(\"../lib/event\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tvar MouseEvent = exports.MouseEvent = function(domEvent, editor) {\n\t    this.domEvent = domEvent;\n\t    this.editor = editor;\n\t    \n\t    this.x = this.clientX = domEvent.clientX;\n\t    this.y = this.clientY = domEvent.clientY;\n\n\t    this.$pos = null;\n\t    this.$inSelection = null;\n\t    \n\t    this.propagationStopped = false;\n\t    this.defaultPrevented = false;\n\t};\n\n\t(function() {  \n\t    \n\t    this.stopPropagation = function() {\n\t        event.stopPropagation(this.domEvent);\n\t        this.propagationStopped = true;\n\t    };\n\t    \n\t    this.preventDefault = function() {\n\t        event.preventDefault(this.domEvent);\n\t        this.defaultPrevented = true;\n\t    };\n\t    \n\t    this.stop = function() {\n\t        this.stopPropagation();\n\t        this.preventDefault();\n\t    };\n\t    this.getDocumentPosition = function() {\n\t        if (this.$pos)\n\t            return this.$pos;\n\t        \n\t        this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);\n\t        return this.$pos;\n\t    };\n\t    this.inSelection = function() {\n\t        if (this.$inSelection !== null)\n\t            return this.$inSelection;\n\t            \n\t        var editor = this.editor;\n\t        \n\n\t        var selectionRange = editor.getSelectionRange();\n\t        if (selectionRange.isEmpty())\n\t            this.$inSelection = false;\n\t        else {\n\t            var pos = this.getDocumentPosition();\n\t            this.$inSelection = selectionRange.contains(pos.row, pos.column);\n\t        }\n\n\t        return this.$inSelection;\n\t    };\n\t    this.getButton = function() {\n\t        return event.getButton(this.domEvent);\n\t    };\n\t    this.getShiftKey = function() {\n\t        return this.domEvent.shiftKey;\n\t    };\n\t    \n\t    this.getAccelKey = useragent.isMac\n\t        ? function() { return this.domEvent.metaKey; }\n\t        : function() { return this.domEvent.ctrlKey; };\n\t    \n\t}).call(MouseEvent.prototype);\n\n\t});\n\n\tace.define(\"ace/mouse/dragdrop_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/useragent\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tvar event = acequire(\"../lib/event\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\n\tvar AUTOSCROLL_DELAY = 200;\n\tvar SCROLL_CURSOR_DELAY = 200;\n\tvar SCROLL_CURSOR_HYSTERESIS = 5;\n\n\tfunction DragdropHandler(mouseHandler) {\n\n\t    var editor = mouseHandler.editor;\n\n\t    var blankImage = dom.createElement(\"img\");\n\t    blankImage.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t    if (useragent.isOpera)\n\t        blankImage.style.cssText = \"width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;\";\n\n\t    var exports = [\"dragWait\", \"dragWaitEnd\", \"startDrag\", \"dragReadyEnd\", \"onMouseDrag\"];\n\n\t     exports.forEach(function(x) {\n\t         mouseHandler[x] = this[x];\n\t    }, this);\n\t    editor.addEventListener(\"mousedown\", this.onMouseDown.bind(mouseHandler));\n\n\n\t    var mouseTarget = editor.container;\n\t    var dragSelectionMarker, x, y;\n\t    var timerId, range;\n\t    var dragCursor, counter = 0;\n\t    var dragOperation;\n\t    var isInternal;\n\t    var autoScrollStartTime;\n\t    var cursorMovedTime;\n\t    var cursorPointOnCaretMoved;\n\n\t    this.onDragStart = function(e) {\n\t        if (this.cancelDrag || !mouseTarget.draggable) {\n\t            var self = this;\n\t            setTimeout(function(){\n\t                self.startSelect();\n\t                self.captureMouse(e);\n\t            }, 0);\n\t            return e.preventDefault();\n\t        }\n\t        range = editor.getSelectionRange();\n\n\t        var dataTransfer = e.dataTransfer;\n\t        dataTransfer.effectAllowed = editor.getReadOnly() ? \"copy\" : \"copyMove\";\n\t        if (useragent.isOpera) {\n\t            editor.container.appendChild(blankImage);\n\t            blankImage.scrollTop = 0;\n\t        }\n\t        dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);\n\t        if (useragent.isOpera) {\n\t            editor.container.removeChild(blankImage);\n\t        }\n\t        dataTransfer.clearData();\n\t        dataTransfer.setData(\"Text\", editor.session.getTextRange());\n\n\t        isInternal = true;\n\t        this.setState(\"drag\");\n\t    };\n\n\t    this.onDragEnd = function(e) {\n\t        mouseTarget.draggable = false;\n\t        isInternal = false;\n\t        this.setState(null);\n\t        if (!editor.getReadOnly()) {\n\t            var dropEffect = e.dataTransfer.dropEffect;\n\t            if (!dragOperation && dropEffect == \"move\")\n\t                editor.session.remove(editor.getSelectionRange());\n\t            editor.renderer.$cursorLayer.setBlinking(true);\n\t        }\n\t        this.editor.unsetStyle(\"ace_dragging\");\n\t        this.editor.renderer.setCursorStyle(\"\");\n\t    };\n\n\t    this.onDragEnter = function(e) {\n\t        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n\t            return;\n\t        x = e.clientX;\n\t        y = e.clientY;\n\t        if (!dragSelectionMarker)\n\t            addDragMarker();\n\t        counter++;\n\t        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n\t        return event.preventDefault(e);\n\t    };\n\n\t    this.onDragOver = function(e) {\n\t        if (editor.getReadOnly() || !canAccept(e.dataTransfer))\n\t            return;\n\t        x = e.clientX;\n\t        y = e.clientY;\n\t        if (!dragSelectionMarker) {\n\t            addDragMarker();\n\t            counter++;\n\t        }\n\t        if (onMouseMoveTimer !== null)\n\t            onMouseMoveTimer = null;\n\n\t        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);\n\t        return event.preventDefault(e);\n\t    };\n\n\t    this.onDragLeave = function(e) {\n\t        counter--;\n\t        if (counter <= 0 && dragSelectionMarker) {\n\t            clearDragMarker();\n\t            dragOperation = null;\n\t            return event.preventDefault(e);\n\t        }\n\t    };\n\n\t    this.onDrop = function(e) {\n\t        if (!dragCursor)\n\t            return;\n\t        var dataTransfer = e.dataTransfer;\n\t        if (isInternal) {\n\t            switch (dragOperation) {\n\t                case \"move\":\n\t                    if (range.contains(dragCursor.row, dragCursor.column)) {\n\t                        range = {\n\t                            start: dragCursor,\n\t                            end: dragCursor\n\t                        };\n\t                    } else {\n\t                        range = editor.moveText(range, dragCursor);\n\t                    }\n\t                    break;\n\t                case \"copy\":\n\t                    range = editor.moveText(range, dragCursor, true);\n\t                    break;\n\t            }\n\t        } else {\n\t            var dropData = dataTransfer.getData('Text');\n\t            range = {\n\t                start: dragCursor,\n\t                end: editor.session.insert(dragCursor, dropData)\n\t            };\n\t            editor.focus();\n\t            dragOperation = null;\n\t        }\n\t        clearDragMarker();\n\t        return event.preventDefault(e);\n\t    };\n\n\t    event.addListener(mouseTarget, \"dragstart\", this.onDragStart.bind(mouseHandler));\n\t    event.addListener(mouseTarget, \"dragend\", this.onDragEnd.bind(mouseHandler));\n\t    event.addListener(mouseTarget, \"dragenter\", this.onDragEnter.bind(mouseHandler));\n\t    event.addListener(mouseTarget, \"dragover\", this.onDragOver.bind(mouseHandler));\n\t    event.addListener(mouseTarget, \"dragleave\", this.onDragLeave.bind(mouseHandler));\n\t    event.addListener(mouseTarget, \"drop\", this.onDrop.bind(mouseHandler));\n\n\t    function scrollCursorIntoView(cursor, prevCursor) {\n\t        var now = Date.now();\n\t        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n\t        var hMovement = !prevCursor || cursor.column != prevCursor.column;\n\t        if (!cursorMovedTime || vMovement || hMovement) {\n\t            editor.$blockScrolling += 1;\n\t            editor.moveCursorToPosition(cursor);\n\t            editor.$blockScrolling -= 1;\n\t            cursorMovedTime = now;\n\t            cursorPointOnCaretMoved = {x: x, y: y};\n\t        } else {\n\t            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);\n\t            if (distance > SCROLL_CURSOR_HYSTERESIS) {\n\t                cursorMovedTime = null;\n\t            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {\n\t                editor.renderer.scrollCursorIntoView();\n\t                cursorMovedTime = null;\n\t            }\n\t        }\n\t    }\n\n\t    function autoScroll(cursor, prevCursor) {\n\t        var now = Date.now();\n\t        var lineHeight = editor.renderer.layerConfig.lineHeight;\n\t        var characterWidth = editor.renderer.layerConfig.characterWidth;\n\t        var editorRect = editor.renderer.scroller.getBoundingClientRect();\n\t        var offsets = {\n\t           x: {\n\t               left: x - editorRect.left,\n\t               right: editorRect.right - x\n\t           },\n\t           y: {\n\t               top: y - editorRect.top,\n\t               bottom: editorRect.bottom - y\n\t           }\n\t        };\n\t        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);\n\t        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);\n\t        var scrollCursor = {row: cursor.row, column: cursor.column};\n\t        if (nearestXOffset / characterWidth <= 2) {\n\t            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);\n\t        }\n\t        if (nearestYOffset / lineHeight <= 1) {\n\t            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);\n\t        }\n\t        var vScroll = cursor.row != scrollCursor.row;\n\t        var hScroll = cursor.column != scrollCursor.column;\n\t        var vMovement = !prevCursor || cursor.row != prevCursor.row;\n\t        if (vScroll || (hScroll && !vMovement)) {\n\t            if (!autoScrollStartTime)\n\t                autoScrollStartTime = now;\n\t            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)\n\t                editor.renderer.scrollCursorIntoView(scrollCursor);\n\t        } else {\n\t            autoScrollStartTime = null;\n\t        }\n\t    }\n\n\t    function onDragInterval() {\n\t        var prevCursor = dragCursor;\n\t        dragCursor = editor.renderer.screenToTextCoordinates(x, y);\n\t        scrollCursorIntoView(dragCursor, prevCursor);\n\t        autoScroll(dragCursor, prevCursor);\n\t    }\n\n\t    function addDragMarker() {\n\t        range = editor.selection.toOrientedRange();\n\t        dragSelectionMarker = editor.session.addMarker(range, \"ace_selection\", editor.getSelectionStyle());\n\t        editor.clearSelection();\n\t        if (editor.isFocused())\n\t            editor.renderer.$cursorLayer.setBlinking(false);\n\t        clearInterval(timerId);\n\t        onDragInterval();\n\t        timerId = setInterval(onDragInterval, 20);\n\t        counter = 0;\n\t        event.addListener(document, \"mousemove\", onMouseMove);\n\t    }\n\n\t    function clearDragMarker() {\n\t        clearInterval(timerId);\n\t        editor.session.removeMarker(dragSelectionMarker);\n\t        dragSelectionMarker = null;\n\t        editor.$blockScrolling += 1;\n\t        editor.selection.fromOrientedRange(range);\n\t        editor.$blockScrolling -= 1;\n\t        if (editor.isFocused() && !isInternal)\n\t            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());\n\t        range = null;\n\t        dragCursor = null;\n\t        counter = 0;\n\t        autoScrollStartTime = null;\n\t        cursorMovedTime = null;\n\t        event.removeListener(document, \"mousemove\", onMouseMove);\n\t    }\n\t    var onMouseMoveTimer = null;\n\t    function onMouseMove() {\n\t        if (onMouseMoveTimer == null) {\n\t            onMouseMoveTimer = setTimeout(function() {\n\t                if (onMouseMoveTimer != null && dragSelectionMarker)\n\t                    clearDragMarker();\n\t            }, 20);\n\t        }\n\t    }\n\n\t    function canAccept(dataTransfer) {\n\t        var types = dataTransfer.types;\n\t        return !types || Array.prototype.some.call(types, function(type) {\n\t            return type == 'text/plain' || type == 'Text';\n\t        });\n\t    }\n\n\t    function getDropEffect(e) {\n\t        var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];\n\t        var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];\n\n\t        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;\n\t        var effectAllowed = \"uninitialized\";\n\t        try {\n\t            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();\n\t        } catch (e) {}\n\t        var dropEffect = \"none\";\n\n\t        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)\n\t            dropEffect = \"copy\";\n\t        else if (moveAllowed.indexOf(effectAllowed) >= 0)\n\t            dropEffect = \"move\";\n\t        else if (copyAllowed.indexOf(effectAllowed) >= 0)\n\t            dropEffect = \"copy\";\n\n\t        return dropEffect;\n\t    }\n\t}\n\n\t(function() {\n\n\t    this.dragWait = function() {\n\t        var interval = Date.now() - this.mousedownEvent.time;\n\t        if (interval > this.editor.getDragDelay())\n\t            this.startDrag();\n\t    };\n\n\t    this.dragWaitEnd = function() {\n\t        var target = this.editor.container;\n\t        target.draggable = false;\n\t        this.startSelect(this.mousedownEvent.getDocumentPosition());\n\t        this.selectEnd();\n\t    };\n\n\t    this.dragReadyEnd = function(e) {\n\t        this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());\n\t        this.editor.unsetStyle(\"ace_dragging\");\n\t        this.editor.renderer.setCursorStyle(\"\");\n\t        this.dragWaitEnd();\n\t    };\n\n\t    this.startDrag = function(){\n\t        this.cancelDrag = false;\n\t        var editor = this.editor;\n\t        var target = editor.container;\n\t        target.draggable = true;\n\t        editor.renderer.$cursorLayer.setBlinking(false);\n\t        editor.setStyle(\"ace_dragging\");\n\t        var cursorStyle = useragent.isWin ? \"default\" : \"move\";\n\t        editor.renderer.setCursorStyle(cursorStyle);\n\t        this.setState(\"dragReady\");\n\t    };\n\n\t    this.onMouseDrag = function(e) {\n\t        var target = this.editor.container;\n\t        if (useragent.isIE && this.state == \"dragReady\") {\n\t            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n\t            if (distance > 3)\n\t                target.dragDrop();\n\t        }\n\t        if (this.state === \"dragWait\") {\n\t            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);\n\t            if (distance > 0) {\n\t                target.draggable = false;\n\t                this.startSelect(this.mousedownEvent.getDocumentPosition());\n\t            }\n\t        }\n\t    };\n\n\t    this.onMouseDown = function(e) {\n\t        if (!this.$dragEnabled)\n\t            return;\n\t        this.mousedownEvent = e;\n\t        var editor = this.editor;\n\n\t        var inSelection = e.inSelection();\n\t        var button = e.getButton();\n\t        var clickCount = e.domEvent.detail || 1;\n\t        if (clickCount === 1 && button === 0 && inSelection) {\n\t            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))\n\t                return;\n\t            this.mousedownEvent.time = Date.now();\n\t            var eventTarget = e.domEvent.target || e.domEvent.srcElement;\n\t            if (\"unselectable\" in eventTarget)\n\t                eventTarget.unselectable = \"on\";\n\t            if (editor.getDragDelay()) {\n\t                if (useragent.isWebKit) {\n\t                    this.cancelDrag = true;\n\t                    var mouseTarget = editor.container;\n\t                    mouseTarget.draggable = true;\n\t                }\n\t                this.setState(\"dragWait\");\n\t            } else {\n\t                this.startDrag();\n\t            }\n\t            this.captureMouse(e, this.onMouseDrag.bind(this));\n\t            e.defaultPrevented = true;\n\t        }\n\t    };\n\n\t}).call(DragdropHandler.prototype);\n\n\n\tfunction calcDistance(ax, ay, bx, by) {\n\t    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));\n\t}\n\n\texports.DragdropHandler = DragdropHandler;\n\n\t});\n\n\tace.define(\"ace/lib/net\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar dom = acequire(\"./dom\");\n\n\texports.get = function (url, callback) {\n\t    var xhr = new XMLHttpRequest();\n\t    xhr.open('GET', url, true);\n\t    xhr.onreadystatechange = function () {\n\t        if (xhr.readyState === 4) {\n\t            callback(xhr.responseText);\n\t        }\n\t    };\n\t    xhr.send(null);\n\t};\n\n\texports.loadScript = function(path, callback) {\n\t    var head = dom.getDocumentHead();\n\t    var s = document.createElement('script');\n\n\t    s.src = path;\n\t    head.appendChild(s);\n\n\t    s.onload = s.onreadystatechange = function(_, isAbort) {\n\t        if (isAbort || !s.readyState || s.readyState == \"loaded\" || s.readyState == \"complete\") {\n\t            s = s.onload = s.onreadystatechange = null;\n\t            if (!isAbort)\n\t                callback();\n\t        }\n\t    };\n\t};\n\texports.qualifyURL = function(url) {\n\t    var a = document.createElement('a');\n\t    a.href = url;\n\t    return a.href;\n\t}\n\n\t});\n\n\tace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar EventEmitter = {};\n\tvar stopPropagation = function() { this.propagationStopped = true; };\n\tvar preventDefault = function() { this.defaultPrevented = true; };\n\n\tEventEmitter._emit =\n\tEventEmitter._dispatchEvent = function(eventName, e) {\n\t    this._eventRegistry || (this._eventRegistry = {});\n\t    this._defaultHandlers || (this._defaultHandlers = {});\n\n\t    var listeners = this._eventRegistry[eventName] || [];\n\t    var defaultHandler = this._defaultHandlers[eventName];\n\t    if (!listeners.length && !defaultHandler)\n\t        return;\n\n\t    if (typeof e != \"object\" || !e)\n\t        e = {};\n\n\t    if (!e.type)\n\t        e.type = eventName;\n\t    if (!e.stopPropagation)\n\t        e.stopPropagation = stopPropagation;\n\t    if (!e.preventDefault)\n\t        e.preventDefault = preventDefault;\n\n\t    listeners = listeners.slice();\n\t    for (var i=0; i<listeners.length; i++) {\n\t        listeners[i](e, this);\n\t        if (e.propagationStopped)\n\t            break;\n\t    }\n\t    \n\t    if (defaultHandler && !e.defaultPrevented)\n\t        return defaultHandler(e, this);\n\t};\n\n\n\tEventEmitter._signal = function(eventName, e) {\n\t    var listeners = (this._eventRegistry || {})[eventName];\n\t    if (!listeners)\n\t        return;\n\t    listeners = listeners.slice();\n\t    for (var i=0; i<listeners.length; i++)\n\t        listeners[i](e, this);\n\t};\n\n\tEventEmitter.once = function(eventName, callback) {\n\t    var _self = this;\n\t    callback && this.addEventListener(eventName, function newCallback() {\n\t        _self.removeEventListener(eventName, newCallback);\n\t        callback.apply(null, arguments);\n\t    });\n\t};\n\n\n\tEventEmitter.setDefaultHandler = function(eventName, callback) {\n\t    var handlers = this._defaultHandlers\n\t    if (!handlers)\n\t        handlers = this._defaultHandlers = {_disabled_: {}};\n\t    \n\t    if (handlers[eventName]) {\n\t        var old = handlers[eventName];\n\t        var disabled = handlers._disabled_[eventName];\n\t        if (!disabled)\n\t            handlers._disabled_[eventName] = disabled = [];\n\t        disabled.push(old);\n\t        var i = disabled.indexOf(callback);\n\t        if (i != -1) \n\t            disabled.splice(i, 1);\n\t    }\n\t    handlers[eventName] = callback;\n\t};\n\tEventEmitter.removeDefaultHandler = function(eventName, callback) {\n\t    var handlers = this._defaultHandlers\n\t    if (!handlers)\n\t        return;\n\t    var disabled = handlers._disabled_[eventName];\n\t    \n\t    if (handlers[eventName] == callback) {\n\t        var old = handlers[eventName];\n\t        if (disabled)\n\t            this.setDefaultHandler(eventName, disabled.pop());\n\t    } else if (disabled) {\n\t        var i = disabled.indexOf(callback);\n\t        if (i != -1)\n\t            disabled.splice(i, 1);\n\t    }\n\t};\n\n\tEventEmitter.on =\n\tEventEmitter.addEventListener = function(eventName, callback, capturing) {\n\t    this._eventRegistry = this._eventRegistry || {};\n\n\t    var listeners = this._eventRegistry[eventName];\n\t    if (!listeners)\n\t        listeners = this._eventRegistry[eventName] = [];\n\n\t    if (listeners.indexOf(callback) == -1)\n\t        listeners[capturing ? \"unshift\" : \"push\"](callback);\n\t    return callback;\n\t};\n\n\tEventEmitter.off =\n\tEventEmitter.removeListener =\n\tEventEmitter.removeEventListener = function(eventName, callback) {\n\t    this._eventRegistry = this._eventRegistry || {};\n\n\t    var listeners = this._eventRegistry[eventName];\n\t    if (!listeners)\n\t        return;\n\n\t    var index = listeners.indexOf(callback);\n\t    if (index !== -1)\n\t        listeners.splice(index, 1);\n\t};\n\n\tEventEmitter.removeAllListeners = function(eventName) {\n\t    if (this._eventRegistry) this._eventRegistry[eventName] = [];\n\t};\n\n\texports.EventEmitter = EventEmitter;\n\n\t});\n\n\tace.define(\"ace/config\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"no use strict\";\n\n\tvar lang = acequire(\"./lib/lang\");\n\tvar oop = acequire(\"./lib/oop\");\n\tvar net = acequire(\"./lib/net\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\n\tvar global = (function() {\n\t    return this;\n\t})();\n\n\tvar options = {\n\t    packaged: false,\n\t    workerPath: null,\n\t    modePath: null,\n\t    themePath: null,\n\t    basePath: \"\",\n\t    suffix: \".js\",\n\t    $moduleUrls: {}\n\t};\n\n\texports.get = function(key) {\n\t    if (!options.hasOwnProperty(key))\n\t        throw new Error(\"Unknown config key: \" + key);\n\n\t    return options[key];\n\t};\n\n\texports.set = function(key, value) {\n\t    if (!options.hasOwnProperty(key))\n\t        throw new Error(\"Unknown config key: \" + key);\n\n\t    options[key] = value;\n\t};\n\n\texports.all = function() {\n\t    return lang.copyObject(options);\n\t};\n\toop.implement(exports, EventEmitter);\n\n\texports.moduleUrl = function(name, component) {\n\t    if (options.$moduleUrls[name])\n\t        return options.$moduleUrls[name];\n\n\t    var parts = name.split(\"/\");\n\t    component = component || parts[parts.length - 2] || \"\";\n\t    var sep = component == \"snippets\" ? \"/\" : \"-\";\n\t    var base = parts[parts.length - 1];\n\t    if (component == \"worker\" && sep == \"-\") {\n\t        var re = new RegExp(\"^\" + component + \"[\\\\-_]|[\\\\-_]\" + component + \"$\", \"g\");\n\t        base = base.replace(re, \"\");\n\t    }\n\n\t    if ((!base || base == component) && parts.length > 1)\n\t        base = parts[parts.length - 2];\n\t    var path = options[component + \"Path\"];\n\t    if (path == null) {\n\t        path = options.basePath;\n\t    } else if (sep == \"/\") {\n\t        component = sep = \"\";\n\t    }\n\t    if (path && path.slice(-1) != \"/\")\n\t        path += \"/\";\n\t    return path + component + sep + base + this.get(\"suffix\");\n\t};\n\n\texports.setModuleUrl = function(name, subst) {\n\t    return options.$moduleUrls[name] = subst;\n\t};\n\n\texports.$loading = {};\n\texports.loadModule = function(moduleName, onLoad) {\n\t    var module, moduleType;\n\t    if (Array.isArray(moduleName)) {\n\t        moduleType = moduleName[0];\n\t        moduleName = moduleName[1];\n\t    }\n\n\t    try {\n\t        module = acequire(moduleName);\n\t    } catch (e) {}\n\t    if (module && !exports.$loading[moduleName])\n\t        return onLoad && onLoad(module);\n\n\t    if (!exports.$loading[moduleName])\n\t        exports.$loading[moduleName] = [];\n\n\t    exports.$loading[moduleName].push(onLoad);\n\n\t    if (exports.$loading[moduleName].length > 1)\n\t        return;\n\n\t    var afterLoad = function() {\n\t        acequire([moduleName], function(module) {\n\t            exports._emit(\"load.module\", {name: moduleName, module: module});\n\t            var listeners = exports.$loading[moduleName];\n\t            exports.$loading[moduleName] = null;\n\t            listeners.forEach(function(onLoad) {\n\t                onLoad && onLoad(module);\n\t            });\n\t        });\n\t    };\n\n\t    if (!exports.get(\"packaged\"))\n\t        return afterLoad();\n\t    net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);\n\t};\n\tinit(true);function init(packaged) {\n\n\t    options.packaged = packaged || acequire.packaged || module.packaged || (global.define && __webpack_require__(18).packaged);\n\n\t    if (!global.document)\n\t        return \"\";\n\n\t    var scriptOptions = {};\n\t    var scriptUrl = \"\";\n\t    var currentScript = (document.currentScript || document._currentScript ); // native or polyfill\n\t    var currentDocument = currentScript && currentScript.ownerDocument || document;\n\t    \n\t    var scripts = currentDocument.getElementsByTagName(\"script\");\n\t    for (var i=0; i<scripts.length; i++) {\n\t        var script = scripts[i];\n\n\t        var src = script.src || script.getAttribute(\"src\");\n\t        if (!src)\n\t            continue;\n\n\t        var attributes = script.attributes;\n\t        for (var j=0, l=attributes.length; j < l; j++) {\n\t            var attr = attributes[j];\n\t            if (attr.name.indexOf(\"data-ace-\") === 0) {\n\t                scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, \"\"))] = attr.value;\n\t            }\n\t        }\n\n\t        var m = src.match(/^(.*)\\/ace(\\-\\w+)?\\.js(\\?|$)/);\n\t        if (m)\n\t            scriptUrl = m[1];\n\t    }\n\n\t    if (scriptUrl) {\n\t        scriptOptions.base = scriptOptions.base || scriptUrl;\n\t        scriptOptions.packaged = true;\n\t    }\n\n\t    scriptOptions.basePath = scriptOptions.base;\n\t    scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;\n\t    scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;\n\t    scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;\n\t    delete scriptOptions.base;\n\n\t    for (var key in scriptOptions)\n\t        if (typeof scriptOptions[key] !== \"undefined\")\n\t            exports.set(key, scriptOptions[key]);\n\t};\n\n\texports.init = init;\n\n\tfunction deHyphenate(str) {\n\t    return str.replace(/-(.)/g, function(m, m1) { return m1.toUpperCase(); });\n\t}\n\n\tvar optionsProvider = {\n\t    setOptions: function(optList) {\n\t        Object.keys(optList).forEach(function(key) {\n\t            this.setOption(key, optList[key]);\n\t        }, this);\n\t    },\n\t    getOptions: function(optionNames) {\n\t        var result = {};\n\t        if (!optionNames) {\n\t            optionNames = Object.keys(this.$options);\n\t        } else if (!Array.isArray(optionNames)) {\n\t            result = optionNames;\n\t            optionNames = Object.keys(result);\n\t        }\n\t        optionNames.forEach(function(key) {\n\t            result[key] = this.getOption(key);\n\t        }, this);\n\t        return result;\n\t    },\n\t    setOption: function(name, value) {\n\t        if (this[\"$\" + name] === value)\n\t            return;\n\t        var opt = this.$options[name];\n\t        if (!opt) {\n\t            if (typeof console != \"undefined\" && console.warn)\n\t                console.warn('misspelled option \"' + name + '\"');\n\t            return undefined;\n\t        }\n\t        if (opt.forwardTo)\n\t            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);\n\n\t        if (!opt.handlesSet)\n\t            this[\"$\" + name] = value;\n\t        if (opt && opt.set)\n\t            opt.set.call(this, value);\n\t    },\n\t    getOption: function(name) {\n\t        var opt = this.$options[name];\n\t        if (!opt) {\n\t            if (typeof console != \"undefined\" && console.warn)\n\t                console.warn('misspelled option \"' + name + '\"');\n\t            return undefined;\n\t        }\n\t        if (opt.forwardTo)\n\t            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);\n\t        return opt && opt.get ? opt.get.call(this) : this[\"$\" + name];\n\t    }\n\t};\n\n\tvar defaultOptions = {};\n\texports.defineOptions = function(obj, path, options) {\n\t    if (!obj.$options)\n\t        defaultOptions[path] = obj.$options = {};\n\n\t    Object.keys(options).forEach(function(key) {\n\t        var opt = options[key];\n\t        if (typeof opt == \"string\")\n\t            opt = {forwardTo: opt};\n\n\t        opt.name || (opt.name = key);\n\t        obj.$options[opt.name] = opt;\n\t        if (\"initialValue\" in opt)\n\t            obj[\"$\" + opt.name] = opt.initialValue;\n\t    });\n\t    oop.implement(obj, optionsProvider);\n\n\t    return this;\n\t};\n\n\texports.resetOptions = function(obj) {\n\t    Object.keys(obj.$options).forEach(function(key) {\n\t        var opt = obj.$options[key];\n\t        if (\"value\" in opt)\n\t            obj.setOption(key, opt.value);\n\t    });\n\t};\n\n\texports.setDefaultValue = function(path, name, value) {\n\t    var opts = defaultOptions[path] || (defaultOptions[path] = {});\n\t    if (opts[name]) {\n\t        if (opts.forwardTo)\n\t            exports.setDefaultValue(opts.forwardTo, name, value);\n\t        else\n\t            opts[name].value = value;\n\t    }\n\t};\n\n\texports.setDefaultValues = function(path, optionHash) {\n\t    Object.keys(optionHash).forEach(function(key) {\n\t        exports.setDefaultValue(path, key, optionHash[key]);\n\t    });\n\t};\n\n\t});\n\n\tace.define(\"ace/mouse/mouse_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\",\"ace/mouse/default_handlers\",\"ace/mouse/default_gutter_handler\",\"ace/mouse/mouse_event\",\"ace/mouse/dragdrop_handler\",\"ace/config\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar event = acequire(\"../lib/event\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tvar DefaultHandlers = acequire(\"./default_handlers\").DefaultHandlers;\n\tvar DefaultGutterHandler = acequire(\"./default_gutter_handler\").GutterHandler;\n\tvar MouseEvent = acequire(\"./mouse_event\").MouseEvent;\n\tvar DragdropHandler = acequire(\"./dragdrop_handler\").DragdropHandler;\n\tvar config = acequire(\"../config\");\n\n\tvar MouseHandler = function(editor) {\n\t    var _self = this;\n\t    this.editor = editor;\n\n\t    new DefaultHandlers(this);\n\t    new DefaultGutterHandler(this);\n\t    new DragdropHandler(this);\n\t    \n\t    var focusEditor = function(e) { \n\t        if (!editor.isFocused() && editor.textInput)\n\t            editor.textInput.moveToMouse(e);\n\t        editor.focus() \n\t    };\n\t    \n\t    var mouseTarget = editor.renderer.getMouseEventTarget();\n\t    event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"));\n\t    event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"));\n\t    event.addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, \"onMouseEvent\");\n\t    if (editor.renderer.scrollBarV) {\n\t        event.addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, \"onMouseEvent\");\n\t        event.addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, \"onMouseEvent\");\n\t        if (useragent.isIE) {\n\t            event.addListener(editor.renderer.scrollBarV.element, \"mousedown\", focusEditor);\n\t            event.addListener(editor.renderer.scrollBarH.element, \"mousemove\", focusEditor);\n\t        }\n\t    }\n\t    event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, \"mousewheel\"));\n\n\t    var gutterEl = editor.renderer.$gutter;\n\t    event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"));\n\t    event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"));\n\t    event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"));\n\t    event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"));\n\n\t    event.addListener(mouseTarget, \"mousedown\", focusEditor);\n\n\t    event.addListener(gutterEl, \"mousedown\", function(e) {\n\t        editor.focus();\n\t        return event.preventDefault(e);\n\t    });\n\n\t    editor.on(\"mousemove\", function(e){\n\t        if (_self.state || _self.$dragDelay || !_self.$dragEnabled)\n\t            return;\n\t        \n\t        var char = editor.renderer.screenToTextCoordinates(e.x, e.y);\n\t        var range = editor.session.selection.getRange();\n\t        var renderer = editor.renderer;\n\n\t        if (!range.isEmpty() && range.insideStart(char.row, char.column)) {\n\t            renderer.setCursorStyle(\"default\");\n\t        } else {\n\t            renderer.setCursorStyle(\"\");\n\t        }\n\t    });\n\t};\n\n\t(function() {\n\t    this.onMouseEvent = function(name, e) {\n\t        this.editor._emit(name, new MouseEvent(e, this.editor));\n\t    };\n\n\t    this.onMouseMove = function(name, e) {\n\t        var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;\n\t        if (!listeners || !listeners.length)\n\t            return;\n\n\t        this.editor._emit(name, new MouseEvent(e, this.editor));\n\t    };\n\n\t    this.onMouseWheel = function(name, e) {\n\t        var mouseEvent = new MouseEvent(e, this.editor);\n\t        mouseEvent.speed = this.$scrollSpeed * 2;\n\t        mouseEvent.wheelX = e.wheelX;\n\t        mouseEvent.wheelY = e.wheelY;\n\n\t        this.editor._emit(name, mouseEvent);\n\t    };\n\n\t    this.setState = function(state) {\n\t        this.state = state;\n\t    };\n\n\t    this.captureMouse = function(ev, mouseMoveHandler) {\n\t        this.x = ev.x;\n\t        this.y = ev.y;\n\n\t        this.isMousePressed = true;\n\t        var renderer = this.editor.renderer;\n\t        if (renderer.$keepTextAreaAtCursor)\n\t            renderer.$keepTextAreaAtCursor = null;\n\n\t        var self = this;\n\t        var onMouseMove = function(e) {\n\t            if (!e) return;\n\t            if (useragent.isWebKit && !e.which && self.releaseMouse)\n\t                return self.releaseMouse();\n\n\t            self.x = e.clientX;\n\t            self.y = e.clientY;\n\t            mouseMoveHandler && mouseMoveHandler(e);\n\t            self.mouseEvent = new MouseEvent(e, self.editor);\n\t            self.$mouseMoved = true;\n\t        };\n\n\t        var onCaptureEnd = function(e) {\n\t            clearInterval(timerId);\n\t            onCaptureInterval();\n\t            self[self.state + \"End\"] && self[self.state + \"End\"](e);\n\t            self.state = \"\";\n\t            if (renderer.$keepTextAreaAtCursor == null) {\n\t                renderer.$keepTextAreaAtCursor = true;\n\t                renderer.$moveTextAreaToCursor();\n\t            }\n\t            self.isMousePressed = false;\n\t            self.$onCaptureMouseMove = self.releaseMouse = null;\n\t            e && self.onMouseEvent(\"mouseup\", e);\n\t        };\n\n\t        var onCaptureInterval = function() {\n\t            self[self.state] && self[self.state]();\n\t            self.$mouseMoved = false;\n\t        };\n\n\t        if (useragent.isOldIE && ev.domEvent.type == \"dblclick\") {\n\t            return setTimeout(function() {onCaptureEnd(ev);});\n\t        }\n\n\t        self.$onCaptureMouseMove = onMouseMove;\n\t        self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);\n\t        var timerId = setInterval(onCaptureInterval, 20);\n\t    };\n\t    this.releaseMouse = null;\n\t    this.cancelContextMenu = function() {\n\t        var stop = function(e) {\n\t            if (e && e.domEvent && e.domEvent.type != \"contextmenu\")\n\t                return;\n\t            this.editor.off(\"nativecontextmenu\", stop);\n\t            if (e && e.domEvent)\n\t                event.stopEvent(e.domEvent);\n\t        }.bind(this);\n\t        setTimeout(stop, 10);\n\t        this.editor.on(\"nativecontextmenu\", stop);\n\t    };\n\t}).call(MouseHandler.prototype);\n\n\tconfig.defineOptions(MouseHandler.prototype, \"mouseHandler\", {\n\t    scrollSpeed: {initialValue: 2},\n\t    dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},\n\t    dragEnabled: {initialValue: true},\n\t    focusTimout: {initialValue: 0},\n\t    tooltipFollowsMouse: {initialValue: true}\n\t});\n\n\n\texports.MouseHandler = MouseHandler;\n\t});\n\n\tace.define(\"ace/mouse/fold_handler\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tfunction FoldHandler(editor) {\n\n\t    editor.on(\"click\", function(e) {\n\t        var position = e.getDocumentPosition();\n\t        var session = editor.session;\n\t        var fold = session.getFoldAt(position.row, position.column, 1);\n\t        if (fold) {\n\t            if (e.getAccelKey())\n\t                session.removeFold(fold);\n\t            else\n\t                session.expandFold(fold);\n\n\t            e.stop();\n\t        }\n\t    });\n\n\t    editor.on(\"gutterclick\", function(e) {\n\t        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n\t        if (gutterRegion == \"foldWidgets\") {\n\t            var row = e.getDocumentPosition().row;\n\t            var session = editor.session;\n\t            if (session.foldWidgets && session.foldWidgets[row])\n\t                editor.session.onFoldWidgetClick(row, e);\n\t            if (!editor.isFocused())\n\t                editor.focus();\n\t            e.stop();\n\t        }\n\t    });\n\n\t    editor.on(\"gutterdblclick\", function(e) {\n\t        var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);\n\n\t        if (gutterRegion == \"foldWidgets\") {\n\t            var row = e.getDocumentPosition().row;\n\t            var session = editor.session;\n\t            var data = session.getParentFoldRangeData(row, true);\n\t            var range = data.range || data.firstRange;\n\n\t            if (range) {\n\t                row = range.start.row;\n\t                var fold = session.getFoldAt(row, session.getLine(row).length, 1);\n\n\t                if (fold) {\n\t                    session.removeFold(fold);\n\t                } else {\n\t                    session.addFold(\"...\", range);\n\t                    editor.renderer.scrollCursorIntoView({row: range.start.row, column: 0});\n\t                }\n\t            }\n\t            e.stop();\n\t        }\n\t    });\n\t}\n\n\texports.FoldHandler = FoldHandler;\n\n\t});\n\n\tace.define(\"ace/keyboard/keybinding\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/event\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar keyUtil  = acequire(\"../lib/keys\");\n\tvar event = acequire(\"../lib/event\");\n\n\tvar KeyBinding = function(editor) {\n\t    this.$editor = editor;\n\t    this.$data = {editor: editor};\n\t    this.$handlers = [];\n\t    this.setDefaultHandler(editor.commands);\n\t};\n\n\t(function() {\n\t    this.setDefaultHandler = function(kb) {\n\t        this.removeKeyboardHandler(this.$defaultHandler);\n\t        this.$defaultHandler = kb;\n\t        this.addKeyboardHandler(kb, 0);\n\t    };\n\n\t    this.setKeyboardHandler = function(kb) {\n\t        var h = this.$handlers;\n\t        if (h[h.length - 1] == kb)\n\t            return;\n\n\t        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)\n\t            this.removeKeyboardHandler(h[h.length - 1]);\n\n\t        this.addKeyboardHandler(kb, 1);\n\t    };\n\n\t    this.addKeyboardHandler = function(kb, pos) {\n\t        if (!kb)\n\t            return;\n\t        if (typeof kb == \"function\" && !kb.handleKeyboard)\n\t            kb.handleKeyboard = kb;\n\t        var i = this.$handlers.indexOf(kb);\n\t        if (i != -1)\n\t            this.$handlers.splice(i, 1);\n\n\t        if (pos == undefined)\n\t            this.$handlers.push(kb);\n\t        else\n\t            this.$handlers.splice(pos, 0, kb);\n\n\t        if (i == -1 && kb.attach)\n\t            kb.attach(this.$editor);\n\t    };\n\n\t    this.removeKeyboardHandler = function(kb) {\n\t        var i = this.$handlers.indexOf(kb);\n\t        if (i == -1)\n\t            return false;\n\t        this.$handlers.splice(i, 1);\n\t        kb.detach && kb.detach(this.$editor);\n\t        return true;\n\t    };\n\n\t    this.getKeyboardHandler = function() {\n\t        return this.$handlers[this.$handlers.length - 1];\n\t    };\n\n\t    this.getStatusText = function() {\n\t        var data = this.$data;\n\t        var editor = data.editor;\n\t        return this.$handlers.map(function(h) {\n\t            return h.getStatusText && h.getStatusText(editor, data) || \"\";\n\t        }).filter(Boolean).join(\" \");\n\t    };\n\n\t    this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {\n\t        var toExecute;\n\t        var success = false;\n\t        var commands = this.$editor.commands;\n\n\t        for (var i = this.$handlers.length; i--;) {\n\t            toExecute = this.$handlers[i].handleKeyboard(\n\t                this.$data, hashId, keyString, keyCode, e\n\t            );\n\t            if (!toExecute || !toExecute.command)\n\t                continue;\n\t            if (toExecute.command == \"null\") {\n\t                success = true;\n\t            } else {\n\t                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);                \n\t            }\n\t            if (success && e && hashId != -1 && \n\t                toExecute.passEvent != true && toExecute.command.passEvent != true\n\t            ) {\n\t                event.stopEvent(e);\n\t            }\n\t            if (success)\n\t                break;\n\t        }\n\t        return success;\n\t    };\n\n\t    this.onCommandKey = function(e, hashId, keyCode) {\n\t        var keyString = keyUtil.keyCodeToString(keyCode);\n\t        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);\n\t    };\n\n\t    this.onTextInput = function(text) {\n\t        var success = this.$callKeyboardHandlers(-1, text);\n\t        if (!success)\n\t            this.$editor.commands.exec(\"insertstring\", this.$editor, text);\n\t    };\n\n\t}).call(KeyBinding.prototype);\n\n\texports.KeyBinding = KeyBinding;\n\t});\n\n\tace.define(\"ace/range\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar comparePoints = function(p1, p2) {\n\t    return p1.row - p2.row || p1.column - p2.column;\n\t};\n\tvar Range = function(startRow, startColumn, endRow, endColumn) {\n\t    this.start = {\n\t        row: startRow,\n\t        column: startColumn\n\t    };\n\n\t    this.end = {\n\t        row: endRow,\n\t        column: endColumn\n\t    };\n\t};\n\n\t(function() {\n\t    this.isEqual = function(range) {\n\t        return this.start.row === range.start.row &&\n\t            this.end.row === range.end.row &&\n\t            this.start.column === range.start.column &&\n\t            this.end.column === range.end.column;\n\t    };\n\t    this.toString = function() {\n\t        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\n\t            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\n\t    };\n\n\t    this.contains = function(row, column) {\n\t        return this.compare(row, column) == 0;\n\t    };\n\t    this.compareRange = function(range) {\n\t        var cmp,\n\t            end = range.end,\n\t            start = range.start;\n\n\t        cmp = this.compare(end.row, end.column);\n\t        if (cmp == 1) {\n\t            cmp = this.compare(start.row, start.column);\n\t            if (cmp == 1) {\n\t                return 2;\n\t            } else if (cmp == 0) {\n\t                return 1;\n\t            } else {\n\t                return 0;\n\t            }\n\t        } else if (cmp == -1) {\n\t            return -2;\n\t        } else {\n\t            cmp = this.compare(start.row, start.column);\n\t            if (cmp == -1) {\n\t                return -1;\n\t            } else if (cmp == 1) {\n\t                return 42;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    };\n\t    this.comparePoint = function(p) {\n\t        return this.compare(p.row, p.column);\n\t    };\n\t    this.containsRange = function(range) {\n\t        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\n\t    };\n\t    this.intersects = function(range) {\n\t        var cmp = this.compareRange(range);\n\t        return (cmp == -1 || cmp == 0 || cmp == 1);\n\t    };\n\t    this.isEnd = function(row, column) {\n\t        return this.end.row == row && this.end.column == column;\n\t    };\n\t    this.isStart = function(row, column) {\n\t        return this.start.row == row && this.start.column == column;\n\t    };\n\t    this.setStart = function(row, column) {\n\t        if (typeof row == \"object\") {\n\t            this.start.column = row.column;\n\t            this.start.row = row.row;\n\t        } else {\n\t            this.start.row = row;\n\t            this.start.column = column;\n\t        }\n\t    };\n\t    this.setEnd = function(row, column) {\n\t        if (typeof row == \"object\") {\n\t            this.end.column = row.column;\n\t            this.end.row = row.row;\n\t        } else {\n\t            this.end.row = row;\n\t            this.end.column = column;\n\t        }\n\t    };\n\t    this.inside = function(row, column) {\n\t        if (this.compare(row, column) == 0) {\n\t            if (this.isEnd(row, column) || this.isStart(row, column)) {\n\t                return false;\n\t            } else {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    this.insideStart = function(row, column) {\n\t        if (this.compare(row, column) == 0) {\n\t            if (this.isEnd(row, column)) {\n\t                return false;\n\t            } else {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    this.insideEnd = function(row, column) {\n\t        if (this.compare(row, column) == 0) {\n\t            if (this.isStart(row, column)) {\n\t                return false;\n\t            } else {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t    this.compare = function(row, column) {\n\t        if (!this.isMultiLine()) {\n\t            if (row === this.start.row) {\n\t                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\n\t            };\n\t        }\n\n\t        if (row < this.start.row)\n\t            return -1;\n\n\t        if (row > this.end.row)\n\t            return 1;\n\n\t        if (this.start.row === row)\n\t            return column >= this.start.column ? 0 : -1;\n\n\t        if (this.end.row === row)\n\t            return column <= this.end.column ? 0 : 1;\n\n\t        return 0;\n\t    };\n\t    this.compareStart = function(row, column) {\n\t        if (this.start.row == row && this.start.column == column) {\n\t            return -1;\n\t        } else {\n\t            return this.compare(row, column);\n\t        }\n\t    };\n\t    this.compareEnd = function(row, column) {\n\t        if (this.end.row == row && this.end.column == column) {\n\t            return 1;\n\t        } else {\n\t            return this.compare(row, column);\n\t        }\n\t    };\n\t    this.compareInside = function(row, column) {\n\t        if (this.end.row == row && this.end.column == column) {\n\t            return 1;\n\t        } else if (this.start.row == row && this.start.column == column) {\n\t            return -1;\n\t        } else {\n\t            return this.compare(row, column);\n\t        }\n\t    };\n\t    this.clipRows = function(firstRow, lastRow) {\n\t        if (this.end.row > lastRow)\n\t            var end = {row: lastRow + 1, column: 0};\n\t        else if (this.end.row < firstRow)\n\t            var end = {row: firstRow, column: 0};\n\n\t        if (this.start.row > lastRow)\n\t            var start = {row: lastRow + 1, column: 0};\n\t        else if (this.start.row < firstRow)\n\t            var start = {row: firstRow, column: 0};\n\n\t        return Range.fromPoints(start || this.start, end || this.end);\n\t    };\n\t    this.extend = function(row, column) {\n\t        var cmp = this.compare(row, column);\n\n\t        if (cmp == 0)\n\t            return this;\n\t        else if (cmp == -1)\n\t            var start = {row: row, column: column};\n\t        else\n\t            var end = {row: row, column: column};\n\n\t        return Range.fromPoints(start || this.start, end || this.end);\n\t    };\n\n\t    this.isEmpty = function() {\n\t        return (this.start.row === this.end.row && this.start.column === this.end.column);\n\t    };\n\t    this.isMultiLine = function() {\n\t        return (this.start.row !== this.end.row);\n\t    };\n\t    this.clone = function() {\n\t        return Range.fromPoints(this.start, this.end);\n\t    };\n\t    this.collapseRows = function() {\n\t        if (this.end.column == 0)\n\t            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0)\n\t        else\n\t            return new Range(this.start.row, 0, this.end.row, 0)\n\t    };\n\t    this.toScreenRange = function(session) {\n\t        var screenPosStart = session.documentToScreenPosition(this.start);\n\t        var screenPosEnd = session.documentToScreenPosition(this.end);\n\n\t        return new Range(\n\t            screenPosStart.row, screenPosStart.column,\n\t            screenPosEnd.row, screenPosEnd.column\n\t        );\n\t    };\n\t    this.moveBy = function(row, column) {\n\t        this.start.row += row;\n\t        this.start.column += column;\n\t        this.end.row += row;\n\t        this.end.column += column;\n\t    };\n\n\t}).call(Range.prototype);\n\tRange.fromPoints = function(start, end) {\n\t    return new Range(start.row, start.column, end.row, end.column);\n\t};\n\tRange.comparePoints = comparePoints;\n\n\tRange.comparePoints = function(p1, p2) {\n\t    return p1.row - p2.row || p1.column - p2.column;\n\t};\n\n\n\texports.Range = Range;\n\t});\n\n\tace.define(\"ace/selection\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar lang = acequire(\"./lib/lang\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar Range = acequire(\"./range\").Range;\n\tvar Selection = function(session) {\n\t    this.session = session;\n\t    this.doc = session.getDocument();\n\n\t    this.clearSelection();\n\t    this.lead = this.selectionLead = this.doc.createAnchor(0, 0);\n\t    this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);\n\n\t    var self = this;\n\t    this.lead.on(\"change\", function(e) {\n\t        self._emit(\"changeCursor\");\n\t        if (!self.$isEmpty)\n\t            self._emit(\"changeSelection\");\n\t        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)\n\t            self.$desiredColumn = null;\n\t    });\n\n\t    this.selectionAnchor.on(\"change\", function() {\n\t        if (!self.$isEmpty)\n\t            self._emit(\"changeSelection\");\n\t    });\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\t    this.isEmpty = function() {\n\t        return (this.$isEmpty || (\n\t            this.anchor.row == this.lead.row &&\n\t            this.anchor.column == this.lead.column\n\t        ));\n\t    };\n\t    this.isMultiLine = function() {\n\t        if (this.isEmpty()) {\n\t            return false;\n\t        }\n\n\t        return this.getRange().isMultiLine();\n\t    };\n\t    this.getCursor = function() {\n\t        return this.lead.getPosition();\n\t    };\n\t    this.setSelectionAnchor = function(row, column) {\n\t        this.anchor.setPosition(row, column);\n\n\t        if (this.$isEmpty) {\n\t            this.$isEmpty = false;\n\t            this._emit(\"changeSelection\");\n\t        }\n\t    };\n\t    this.getSelectionAnchor = function() {\n\t        if (this.$isEmpty)\n\t            return this.getSelectionLead();\n\t        else\n\t            return this.anchor.getPosition();\n\t    };\n\t    this.getSelectionLead = function() {\n\t        return this.lead.getPosition();\n\t    };\n\t    this.shiftSelection = function(columns) {\n\t        if (this.$isEmpty) {\n\t            this.moveCursorTo(this.lead.row, this.lead.column + columns);\n\t            return;\n\t        }\n\n\t        var anchor = this.getSelectionAnchor();\n\t        var lead = this.getSelectionLead();\n\n\t        var isBackwards = this.isBackwards();\n\n\t        if (!isBackwards || anchor.column !== 0)\n\t            this.setSelectionAnchor(anchor.row, anchor.column + columns);\n\n\t        if (isBackwards || lead.column !== 0) {\n\t            this.$moveSelection(function() {\n\t                this.moveCursorTo(lead.row, lead.column + columns);\n\t            });\n\t        }\n\t    };\n\t    this.isBackwards = function() {\n\t        var anchor = this.anchor;\n\t        var lead = this.lead;\n\t        return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));\n\t    };\n\t    this.getRange = function() {\n\t        var anchor = this.anchor;\n\t        var lead = this.lead;\n\n\t        if (this.isEmpty())\n\t            return Range.fromPoints(lead, lead);\n\n\t        if (this.isBackwards()) {\n\t            return Range.fromPoints(lead, anchor);\n\t        }\n\t        else {\n\t            return Range.fromPoints(anchor, lead);\n\t        }\n\t    };\n\t    this.clearSelection = function() {\n\t        if (!this.$isEmpty) {\n\t            this.$isEmpty = true;\n\t            this._emit(\"changeSelection\");\n\t        }\n\t    };\n\t    this.selectAll = function() {\n\t        var lastRow = this.doc.getLength() - 1;\n\t        this.setSelectionAnchor(0, 0);\n\t        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);\n\t    };\n\t    this.setRange =\n\t    this.setSelectionRange = function(range, reverse) {\n\t        if (reverse) {\n\t            this.setSelectionAnchor(range.end.row, range.end.column);\n\t            this.selectTo(range.start.row, range.start.column);\n\t        } else {\n\t            this.setSelectionAnchor(range.start.row, range.start.column);\n\t            this.selectTo(range.end.row, range.end.column);\n\t        }\n\t        if (this.getRange().isEmpty())\n\t            this.$isEmpty = true;\n\t        this.$desiredColumn = null;\n\t    };\n\n\t    this.$moveSelection = function(mover) {\n\t        var lead = this.lead;\n\t        if (this.$isEmpty)\n\t            this.setSelectionAnchor(lead.row, lead.column);\n\n\t        mover.call(this);\n\t    };\n\t    this.selectTo = function(row, column) {\n\t        this.$moveSelection(function() {\n\t            this.moveCursorTo(row, column);\n\t        });\n\t    };\n\t    this.selectToPosition = function(pos) {\n\t        this.$moveSelection(function() {\n\t            this.moveCursorToPosition(pos);\n\t        });\n\t    };\n\t    this.moveTo = function(row, column) {\n\t        this.clearSelection();\n\t        this.moveCursorTo(row, column);\n\t    };\n\t    this.moveToPosition = function(pos) {\n\t        this.clearSelection();\n\t        this.moveCursorToPosition(pos);\n\t    };\n\t    this.selectUp = function() {\n\t        this.$moveSelection(this.moveCursorUp);\n\t    };\n\t    this.selectDown = function() {\n\t        this.$moveSelection(this.moveCursorDown);\n\t    };\n\t    this.selectRight = function() {\n\t        this.$moveSelection(this.moveCursorRight);\n\t    };\n\t    this.selectLeft = function() {\n\t        this.$moveSelection(this.moveCursorLeft);\n\t    };\n\t    this.selectLineStart = function() {\n\t        this.$moveSelection(this.moveCursorLineStart);\n\t    };\n\t    this.selectLineEnd = function() {\n\t        this.$moveSelection(this.moveCursorLineEnd);\n\t    };\n\t    this.selectFileEnd = function() {\n\t        this.$moveSelection(this.moveCursorFileEnd);\n\t    };\n\t    this.selectFileStart = function() {\n\t        this.$moveSelection(this.moveCursorFileStart);\n\t    };\n\t    this.selectWordRight = function() {\n\t        this.$moveSelection(this.moveCursorWordRight);\n\t    };\n\t    this.selectWordLeft = function() {\n\t        this.$moveSelection(this.moveCursorWordLeft);\n\t    };\n\t    this.getWordRange = function(row, column) {\n\t        if (typeof column == \"undefined\") {\n\t            var cursor = row || this.lead;\n\t            row = cursor.row;\n\t            column = cursor.column;\n\t        }\n\t        return this.session.getWordRange(row, column);\n\t    };\n\t    this.selectWord = function() {\n\t        this.setSelectionRange(this.getWordRange());\n\t    };\n\t    this.selectAWord = function() {\n\t        var cursor = this.getCursor();\n\t        var range = this.session.getAWordRange(cursor.row, cursor.column);\n\t        this.setSelectionRange(range);\n\t    };\n\n\t    this.getLineRange = function(row, excludeLastChar) {\n\t        var rowStart = typeof row == \"number\" ? row : this.lead.row;\n\t        var rowEnd;\n\n\t        var foldLine = this.session.getFoldLine(rowStart);\n\t        if (foldLine) {\n\t            rowStart = foldLine.start.row;\n\t            rowEnd = foldLine.end.row;\n\t        } else {\n\t            rowEnd = rowStart;\n\t        }\n\t        if (excludeLastChar === true)\n\t            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);\n\t        else\n\t            return new Range(rowStart, 0, rowEnd + 1, 0);\n\t    };\n\t    this.selectLine = function() {\n\t        this.setSelectionRange(this.getLineRange());\n\t    };\n\t    this.moveCursorUp = function() {\n\t        this.moveCursorBy(-1, 0);\n\t    };\n\t    this.moveCursorDown = function() {\n\t        this.moveCursorBy(1, 0);\n\t    };\n\t    this.moveCursorLeft = function() {\n\t        var cursor = this.lead.getPosition(),\n\t            fold;\n\n\t        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {\n\t            this.moveCursorTo(fold.start.row, fold.start.column);\n\t        } else if (cursor.column === 0) {\n\t            if (cursor.row > 0) {\n\t                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);\n\t            }\n\t        }\n\t        else {\n\t            var tabSize = this.session.getTabSize();\n\t            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column-tabSize, cursor.column).split(\" \").length-1 == tabSize)\n\t                this.moveCursorBy(0, -tabSize);\n\t            else\n\t                this.moveCursorBy(0, -1);\n\t        }\n\t    };\n\t    this.moveCursorRight = function() {\n\t        var cursor = this.lead.getPosition(),\n\t            fold;\n\t        if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {\n\t            this.moveCursorTo(fold.end.row, fold.end.column);\n\t        }\n\t        else if (this.lead.column == this.doc.getLine(this.lead.row).length) {\n\t            if (this.lead.row < this.doc.getLength() - 1) {\n\t                this.moveCursorTo(this.lead.row + 1, 0);\n\t            }\n\t        }\n\t        else {\n\t            var tabSize = this.session.getTabSize();\n\t            var cursor = this.lead;\n\t            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column+tabSize).split(\" \").length-1 == tabSize)\n\t                this.moveCursorBy(0, tabSize);\n\t            else\n\t                this.moveCursorBy(0, 1);\n\t        }\n\t    };\n\t    this.moveCursorLineStart = function() {\n\t        var row = this.lead.row;\n\t        var column = this.lead.column;\n\t        var screenRow = this.session.documentToScreenRow(row, column);\n\t        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);\n\t        var beforeCursor = this.session.getDisplayLine(\n\t            row, null, firstColumnPosition.row,\n\t            firstColumnPosition.column\n\t        );\n\n\t        var leadingSpace = beforeCursor.match(/^\\s*/);\n\t        if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)\n\t            firstColumnPosition.column += leadingSpace[0].length;\n\t        this.moveCursorToPosition(firstColumnPosition);\n\t    };\n\t    this.moveCursorLineEnd = function() {\n\t        var lead = this.lead;\n\t        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);\n\t        if (this.lead.column == lineEnd.column) {\n\t            var line = this.session.getLine(lineEnd.row);\n\t            if (lineEnd.column == line.length) {\n\t                var textEnd = line.search(/\\s+$/);\n\t                if (textEnd > 0)\n\t                    lineEnd.column = textEnd;\n\t            }\n\t        }\n\n\t        this.moveCursorTo(lineEnd.row, lineEnd.column);\n\t    };\n\t    this.moveCursorFileEnd = function() {\n\t        var row = this.doc.getLength() - 1;\n\t        var column = this.doc.getLine(row).length;\n\t        this.moveCursorTo(row, column);\n\t    };\n\t    this.moveCursorFileStart = function() {\n\t        this.moveCursorTo(0, 0);\n\t    };\n\t    this.moveCursorLongWordRight = function() {\n\t        var row = this.lead.row;\n\t        var column = this.lead.column;\n\t        var line = this.doc.getLine(row);\n\t        var rightOfCursor = line.substring(column);\n\n\t        var match;\n\t        this.session.nonTokenRe.lastIndex = 0;\n\t        this.session.tokenRe.lastIndex = 0;\n\t        var fold = this.session.getFoldAt(row, column, 1);\n\t        if (fold) {\n\t            this.moveCursorTo(fold.end.row, fold.end.column);\n\t            return;\n\t        }\n\t        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {\n\t            column += this.session.nonTokenRe.lastIndex;\n\t            this.session.nonTokenRe.lastIndex = 0;\n\t            rightOfCursor = line.substring(column);\n\t        }\n\t        if (column >= line.length) {\n\t            this.moveCursorTo(row, line.length);\n\t            this.moveCursorRight();\n\t            if (row < this.doc.getLength() - 1)\n\t                this.moveCursorWordRight();\n\t            return;\n\t        }\n\t        if (match = this.session.tokenRe.exec(rightOfCursor)) {\n\t            column += this.session.tokenRe.lastIndex;\n\t            this.session.tokenRe.lastIndex = 0;\n\t        }\n\n\t        this.moveCursorTo(row, column);\n\t    };\n\t    this.moveCursorLongWordLeft = function() {\n\t        var row = this.lead.row;\n\t        var column = this.lead.column;\n\t        var fold;\n\t        if (fold = this.session.getFoldAt(row, column, -1)) {\n\t            this.moveCursorTo(fold.start.row, fold.start.column);\n\t            return;\n\t        }\n\n\t        var str = this.session.getFoldStringAt(row, column, -1);\n\t        if (str == null) {\n\t            str = this.doc.getLine(row).substring(0, column);\n\t        }\n\n\t        var leftOfCursor = lang.stringReverse(str);\n\t        var match;\n\t        this.session.nonTokenRe.lastIndex = 0;\n\t        this.session.tokenRe.lastIndex = 0;\n\t        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {\n\t            column -= this.session.nonTokenRe.lastIndex;\n\t            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);\n\t            this.session.nonTokenRe.lastIndex = 0;\n\t        }\n\t        if (column <= 0) {\n\t            this.moveCursorTo(row, 0);\n\t            this.moveCursorLeft();\n\t            if (row > 0)\n\t                this.moveCursorWordLeft();\n\t            return;\n\t        }\n\t        if (match = this.session.tokenRe.exec(leftOfCursor)) {\n\t            column -= this.session.tokenRe.lastIndex;\n\t            this.session.tokenRe.lastIndex = 0;\n\t        }\n\n\t        this.moveCursorTo(row, column);\n\t    };\n\n\t    this.$shortWordEndIndex = function(rightOfCursor) {\n\t        var match, index = 0, ch;\n\t        var whitespaceRe = /\\s/;\n\t        var tokenRe = this.session.tokenRe;\n\n\t        tokenRe.lastIndex = 0;\n\t        if (match = this.session.tokenRe.exec(rightOfCursor)) {\n\t            index = this.session.tokenRe.lastIndex;\n\t        } else {\n\t            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n\t                index ++;\n\n\t            if (index < 1) {\n\t                tokenRe.lastIndex = 0;\n\t                 while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {\n\t                    tokenRe.lastIndex = 0;\n\t                    index ++;\n\t                    if (whitespaceRe.test(ch)) {\n\t                        if (index > 2) {\n\t                            index--;\n\t                            break;\n\t                        } else {\n\t                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))\n\t                                index ++;\n\t                            if (index > 2)\n\t                                break;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        tokenRe.lastIndex = 0;\n\n\t        return index;\n\t    };\n\n\t    this.moveCursorShortWordRight = function() {\n\t        var row = this.lead.row;\n\t        var column = this.lead.column;\n\t        var line = this.doc.getLine(row);\n\t        var rightOfCursor = line.substring(column);\n\n\t        var fold = this.session.getFoldAt(row, column, 1);\n\t        if (fold)\n\t            return this.moveCursorTo(fold.end.row, fold.end.column);\n\n\t        if (column == line.length) {\n\t            var l = this.doc.getLength();\n\t            do {\n\t                row++;\n\t                rightOfCursor = this.doc.getLine(row);\n\t            } while (row < l && /^\\s*$/.test(rightOfCursor));\n\n\t            if (!/^\\s+/.test(rightOfCursor))\n\t                rightOfCursor = \"\";\n\t            column = 0;\n\t        }\n\n\t        var index = this.$shortWordEndIndex(rightOfCursor);\n\n\t        this.moveCursorTo(row, column + index);\n\t    };\n\n\t    this.moveCursorShortWordLeft = function() {\n\t        var row = this.lead.row;\n\t        var column = this.lead.column;\n\n\t        var fold;\n\t        if (fold = this.session.getFoldAt(row, column, -1))\n\t            return this.moveCursorTo(fold.start.row, fold.start.column);\n\n\t        var line = this.session.getLine(row).substring(0, column);\n\t        if (column === 0) {\n\t            do {\n\t                row--;\n\t                line = this.doc.getLine(row);\n\t            } while (row > 0 && /^\\s*$/.test(line));\n\n\t            column = line.length;\n\t            if (!/\\s+$/.test(line))\n\t                line = \"\";\n\t        }\n\n\t        var leftOfCursor = lang.stringReverse(line);\n\t        var index = this.$shortWordEndIndex(leftOfCursor);\n\n\t        return this.moveCursorTo(row, column - index);\n\t    };\n\n\t    this.moveCursorWordRight = function() {\n\t        if (this.session.$selectLongWords)\n\t            this.moveCursorLongWordRight();\n\t        else\n\t            this.moveCursorShortWordRight();\n\t    };\n\n\t    this.moveCursorWordLeft = function() {\n\t        if (this.session.$selectLongWords)\n\t            this.moveCursorLongWordLeft();\n\t        else\n\t            this.moveCursorShortWordLeft();\n\t    };\n\t    this.moveCursorBy = function(rows, chars) {\n\t        var screenPos = this.session.documentToScreenPosition(\n\t            this.lead.row,\n\t            this.lead.column\n\t        );\n\n\t        if (chars === 0) {\n\t            if (this.$desiredColumn)\n\t                screenPos.column = this.$desiredColumn;\n\t            else\n\t                this.$desiredColumn = screenPos.column;\n\t        }\n\n\t        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);\n\t        \n\t        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {\n\t            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row])\n\t                docPos.row++;\n\t        }\n\t        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);\n\t    };\n\t    this.moveCursorToPosition = function(position) {\n\t        this.moveCursorTo(position.row, position.column);\n\t    };\n\t    this.moveCursorTo = function(row, column, keepDesiredColumn) {\n\t        var fold = this.session.getFoldAt(row, column, 1);\n\t        if (fold) {\n\t            row = fold.start.row;\n\t            column = fold.start.column;\n\t        }\n\n\t        this.$keepDesiredColumnOnChange = true;\n\t        this.lead.setPosition(row, column);\n\t        this.$keepDesiredColumnOnChange = false;\n\n\t        if (!keepDesiredColumn)\n\t            this.$desiredColumn = null;\n\t    };\n\t    this.moveCursorToScreen = function(row, column, keepDesiredColumn) {\n\t        var pos = this.session.screenToDocumentPosition(row, column);\n\t        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);\n\t    };\n\t    this.detach = function() {\n\t        this.lead.detach();\n\t        this.anchor.detach();\n\t        this.session = this.doc = null;\n\t    };\n\n\t    this.fromOrientedRange = function(range) {\n\t        this.setSelectionRange(range, range.cursor == range.start);\n\t        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;\n\t    };\n\n\t    this.toOrientedRange = function(range) {\n\t        var r = this.getRange();\n\t        if (range) {\n\t            range.start.column = r.start.column;\n\t            range.start.row = r.start.row;\n\t            range.end.column = r.end.column;\n\t            range.end.row = r.end.row;\n\t        } else {\n\t            range = r;\n\t        }\n\n\t        range.cursor = this.isBackwards() ? range.start : range.end;\n\t        range.desiredColumn = this.$desiredColumn;\n\t        return range;\n\t    };\n\t    this.getRangeOfMovements = function(func) {\n\t        var start = this.getCursor();\n\t        try {\n\t            func.call(null, this);\n\t            var end = this.getCursor();\n\t            return Range.fromPoints(start,end);\n\t        } catch(e) {\n\t            return Range.fromPoints(start,start);\n\t        } finally {\n\t            this.moveCursorToPosition(start);\n\t        }\n\t    };\n\n\t    this.toJSON = function() {\n\t        if (this.rangeCount) {\n\t            var data = this.ranges.map(function(r) {\n\t                var r1 = r.clone();\n\t                r1.isBackwards = r.cursor == r.start;\n\t                return r1;\n\t            });\n\t        } else {\n\t            var data = this.getRange();\n\t            data.isBackwards = this.isBackwards();\n\t        }\n\t        return data;\n\t    };\n\n\t    this.fromJSON = function(data) {\n\t        if (data.start == undefined) {\n\t            if (this.rangeList) {\n\t                this.toSingleRange(data[0]);\n\t                for (var i = data.length; i--; ) {\n\t                    var r = Range.fromPoints(data[i].start, data[i].end);\n\t                    if (data.isBackwards)\n\t                        r.cursor = r.start;\n\t                    this.addRange(r, true);\n\t                }\n\t                return;\n\t            } else\n\t                data = data[0];\n\t        }\n\t        if (this.rangeList)\n\t            this.toSingleRange(data);\n\t        this.setSelectionRange(data, data.isBackwards);\n\t    };\n\n\t    this.isEqual = function(data) {\n\t        if ((data.length || this.rangeCount) && data.length != this.rangeCount)\n\t            return false;\n\t        if (!data.length || !this.ranges)\n\t            return this.getRange().isEqual(data);\n\n\t        for (var i = this.ranges.length; i--; ) {\n\t            if (!this.ranges[i].isEqual(data[i]))\n\t                return false;\n\t        }\n\t        return true;\n\t    };\n\n\t}).call(Selection.prototype);\n\n\texports.Selection = Selection;\n\t});\n\n\tace.define(\"ace/tokenizer\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar MAX_TOKEN_COUNT = 2000;\n\tvar Tokenizer = function(rules) {\n\t    this.states = rules;\n\n\t    this.regExps = {};\n\t    this.matchMappings = {};\n\t    for (var key in this.states) {\n\t        var state = this.states[key];\n\t        var ruleRegExps = [];\n\t        var matchTotal = 0;\n\t        var mapping = this.matchMappings[key] = {defaultToken: \"text\"};\n\t        var flag = \"g\";\n\n\t        var splitterRurles = [];\n\t        for (var i = 0; i < state.length; i++) {\n\t            var rule = state[i];\n\t            if (rule.defaultToken)\n\t                mapping.defaultToken = rule.defaultToken;\n\t            if (rule.caseInsensitive)\n\t                flag = \"gi\";\n\t            if (rule.regex == null)\n\t                continue;\n\n\t            if (rule.regex instanceof RegExp)\n\t                rule.regex = rule.regex.toString().slice(1, -1);\n\t            var adjustedregex = rule.regex;\n\t            var matchcount = new RegExp(\"(?:(\" + adjustedregex + \")|(.))\").exec(\"a\").length - 2;\n\t            if (Array.isArray(rule.token)) {\n\t                if (rule.token.length == 1 || matchcount == 1) {\n\t                    rule.token = rule.token[0];\n\t                } else if (matchcount - 1 != rule.token.length) {\n\t                    this.reportError(\"number of classes and regexp groups doesn't match\", {\n\t                        rule: rule,\n\t                        groupCount: matchcount - 1\n\t                    });\n\t                    rule.token = rule.token[0];\n\t                } else {\n\t                    rule.tokenArray = rule.token;\n\t                    rule.token = null;\n\t                    rule.onMatch = this.$arrayTokens;\n\t                }\n\t            } else if (typeof rule.token == \"function\" && !rule.onMatch) {\n\t                if (matchcount > 1)\n\t                    rule.onMatch = this.$applyToken;\n\t                else\n\t                    rule.onMatch = rule.token;\n\t            }\n\n\t            if (matchcount > 1) {\n\t                if (/\\\\\\d/.test(rule.regex)) {\n\t                    adjustedregex = rule.regex.replace(/\\\\([0-9]+)/g, function(match, digit) {\n\t                        return \"\\\\\" + (parseInt(digit, 10) + matchTotal + 1);\n\t                    });\n\t                } else {\n\t                    matchcount = 1;\n\t                    adjustedregex = this.removeCapturingGroups(rule.regex);\n\t                }\n\t                if (!rule.splitRegex && typeof rule.token != \"string\")\n\t                    splitterRurles.push(rule); // flag will be known only at the very end\n\t            }\n\n\t            mapping[matchTotal] = i;\n\t            matchTotal += matchcount;\n\n\t            ruleRegExps.push(adjustedregex);\n\t            if (!rule.onMatch)\n\t                rule.onMatch = null;\n\t        }\n\t        \n\t        if (!ruleRegExps.length) {\n\t            mapping[0] = 0;\n\t            ruleRegExps.push(\"$\");\n\t        }\n\t        \n\t        splitterRurles.forEach(function(rule) {\n\t            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);\n\t        }, this);\n\n\t        this.regExps[key] = new RegExp(\"(\" + ruleRegExps.join(\")|(\") + \")|($)\", flag);\n\t    }\n\t};\n\n\t(function() {\n\t    this.$setMaxTokenCount = function(m) {\n\t        MAX_TOKEN_COUNT = m | 0;\n\t    };\n\t    \n\t    this.$applyToken = function(str) {\n\t        var values = this.splitRegex.exec(str).slice(1);\n\t        var types = this.token.apply(this, values);\n\t        if (typeof types === \"string\")\n\t            return [{type: types, value: str}];\n\n\t        var tokens = [];\n\t        for (var i = 0, l = types.length; i < l; i++) {\n\t            if (values[i])\n\t                tokens[tokens.length] = {\n\t                    type: types[i],\n\t                    value: values[i]\n\t                };\n\t        }\n\t        return tokens;\n\t    },\n\n\t    this.$arrayTokens = function(str) {\n\t        if (!str)\n\t            return [];\n\t        var values = this.splitRegex.exec(str);\n\t        if (!values)\n\t            return \"text\";\n\t        var tokens = [];\n\t        var types = this.tokenArray;\n\t        for (var i = 0, l = types.length; i < l; i++) {\n\t            if (values[i + 1])\n\t                tokens[tokens.length] = {\n\t                    type: types[i],\n\t                    value: values[i + 1]\n\t                };\n\t        }\n\t        return tokens;\n\t    };\n\n\t    this.removeCapturingGroups = function(src) {\n\t        var r = src.replace(\n\t            /\\[(?:\\\\.|[^\\]])*?\\]|\\\\.|\\(\\?[:=!]|(\\()/g,\n\t            function(x, y) {return y ? \"(?:\" : x;}\n\t        );\n\t        return r;\n\t    };\n\n\t    this.createSplitterRegexp = function(src, flag) {\n\t        if (src.indexOf(\"(?=\") != -1) {\n\t            var stack = 0;\n\t            var inChClass = false;\n\t            var lastCapture = {};\n\t            src.replace(/(\\\\.)|(\\((?:\\?[=!])?)|(\\))|([\\[\\]])/g, function(\n\t                m, esc, parenOpen, parenClose, square, index\n\t            ) {\n\t                if (inChClass) {\n\t                    inChClass = square != \"]\";\n\t                } else if (square) {\n\t                    inChClass = true;\n\t                } else if (parenClose) {\n\t                    if (stack == lastCapture.stack) {\n\t                        lastCapture.end = index+1;\n\t                        lastCapture.stack = -1;\n\t                    }\n\t                    stack--;\n\t                } else if (parenOpen) {\n\t                    stack++;\n\t                    if (parenOpen.length != 1) {\n\t                        lastCapture.stack = stack\n\t                        lastCapture.start = index;\n\t                    }\n\t                }\n\t                return m;\n\t            });\n\n\t            if (lastCapture.end != null && /^\\)*$/.test(src.substr(lastCapture.end)))\n\t                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);\n\t        }\n\t        return new RegExp(src, (flag||\"\").replace(\"g\", \"\"));\n\t    };\n\t    this.getLineTokens = function(line, startState) {\n\t        if (startState && typeof startState != \"string\") {\n\t            var stack = startState.slice(0);\n\t            startState = stack[0];\n\t            if (startState === \"#tmp\") {\n\t                stack.shift()\n\t                startState = stack.shift()\n\t            }\n\t        } else\n\t            var stack = [];\n\n\t        var currentState = startState || \"start\";\n\t        var state = this.states[currentState];\n\t        if (!state) {\n\t            currentState = \"start\";\n\t            state = this.states[currentState];\n\t        }\n\t        var mapping = this.matchMappings[currentState];\n\t        var re = this.regExps[currentState];\n\t        re.lastIndex = 0;\n\n\t        var match, tokens = [];\n\t        var lastIndex = 0;\n\t        var matchAttempts = 0;\n\n\t        var token = {type: null, value: \"\"};\n\n\t        while (match = re.exec(line)) {\n\t            var type = mapping.defaultToken;\n\t            var rule = null;\n\t            var value = match[0];\n\t            var index = re.lastIndex;\n\n\t            if (index - value.length > lastIndex) {\n\t                var skipped = line.substring(lastIndex, index - value.length);\n\t                if (token.type == type) {\n\t                    token.value += skipped;\n\t                } else {\n\t                    if (token.type)\n\t                        tokens.push(token);\n\t                    token = {type: type, value: skipped};\n\t                }\n\t            }\n\n\t            for (var i = 0; i < match.length-2; i++) {\n\t                if (match[i + 1] === undefined)\n\t                    continue;\n\n\t                rule = state[mapping[i]];\n\n\t                if (rule.onMatch)\n\t                    type = rule.onMatch(value, currentState, stack);\n\t                else\n\t                    type = rule.token;\n\n\t                if (rule.next) {\n\t                    if (typeof rule.next == \"string\") {\n\t                        currentState = rule.next;\n\t                    } else {\n\t                        currentState = rule.next(currentState, stack);\n\t                    }\n\t                    \n\t                    state = this.states[currentState];\n\t                    if (!state) {\n\t                        this.reportError(\"state doesn't exist\", currentState);\n\t                        currentState = \"start\";\n\t                        state = this.states[currentState];\n\t                    }\n\t                    mapping = this.matchMappings[currentState];\n\t                    lastIndex = index;\n\t                    re = this.regExps[currentState];\n\t                    re.lastIndex = index;\n\t                }\n\t                break;\n\t            }\n\n\t            if (value) {\n\t                if (typeof type === \"string\") {\n\t                    if ((!rule || rule.merge !== false) && token.type === type) {\n\t                        token.value += value;\n\t                    } else {\n\t                        if (token.type)\n\t                            tokens.push(token);\n\t                        token = {type: type, value: value};\n\t                    }\n\t                } else if (type) {\n\t                    if (token.type)\n\t                        tokens.push(token);\n\t                    token = {type: null, value: \"\"};\n\t                    for (var i = 0; i < type.length; i++)\n\t                        tokens.push(type[i]);\n\t                }\n\t            }\n\n\t            if (lastIndex == line.length)\n\t                break;\n\n\t            lastIndex = index;\n\n\t            if (matchAttempts++ > MAX_TOKEN_COUNT) {\n\t                if (matchAttempts > 2 * line.length) {\n\t                    this.reportError(\"infinite loop with in ace tokenizer\", {\n\t                        startState: startState,\n\t                        line: line\n\t                    });\n\t                }\n\t                while (lastIndex < line.length) {\n\t                    if (token.type)\n\t                        tokens.push(token);\n\t                    token = {\n\t                        value: line.substring(lastIndex, lastIndex += 2000),\n\t                        type: \"overflow\"\n\t                    };\n\t                }\n\t                currentState = \"start\";\n\t                stack = [];\n\t                break;\n\t            }\n\t        }\n\n\t        if (token.type)\n\t            tokens.push(token);\n\t        \n\t        if (stack.length > 1) {\n\t            if (stack[0] !== currentState)\n\t                stack.unshift(\"#tmp\", currentState);\n\t        }\n\t        return {\n\t            tokens : tokens,\n\t            state : stack.length ? stack : currentState\n\t        };\n\t    };\n\n\t    this.reportError = function(msg, data) {\n\t        var e = new Error(msg);\n\t        e.data = data;\n\t        if (typeof console == \"object\" && console.error)\n\t            console.error(e);\n\t        setTimeout(function() { throw e; });\n\t    };\n\t}).call(Tokenizer.prototype);\n\n\texports.Tokenizer = Tokenizer;\n\t});\n\n\tace.define(\"ace/mode/text_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar lang = acequire(\"../lib/lang\");\n\n\tvar TextHighlightRules = function() {\n\n\t    this.$rules = {\n\t        \"start\" : [{\n\t            token : \"empty_line\",\n\t            regex : '^$'\n\t        }, {\n\t            defaultToken : \"text\"\n\t        }]\n\t    };\n\t};\n\n\t(function() {\n\n\t    this.addRules = function(rules, prefix) {\n\t        if (!prefix) {\n\t            for (var key in rules)\n\t                this.$rules[key] = rules[key];\n\t            return;\n\t        }\n\t        for (var key in rules) {\n\t            var state = rules[key];\n\t            for (var i = 0; i < state.length; i++) {\n\t                var rule = state[i];\n\t                if (rule.next || rule.onMatch) {\n\t                    if (typeof rule.next != \"string\") {\n\t                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)\n\t                            rule.nextState = prefix + rule.nextState;\n\t                    } else {\n\t                        if (rule.next.indexOf(prefix) !== 0)\n\t                            rule.next = prefix + rule.next;\n\t                    }\n\t                }\n\t            }\n\t            this.$rules[prefix + key] = state;\n\t        }\n\t    };\n\n\t    this.getRules = function() {\n\t        return this.$rules;\n\t    };\n\n\t    this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {\n\t        var embedRules = typeof HighlightRules == \"function\"\n\t            ? new HighlightRules().getRules()\n\t            : HighlightRules;\n\t        if (states) {\n\t            for (var i = 0; i < states.length; i++)\n\t                states[i] = prefix + states[i];\n\t        } else {\n\t            states = [];\n\t            for (var key in embedRules)\n\t                states.push(prefix + key);\n\t        }\n\n\t        this.addRules(embedRules, prefix);\n\n\t        if (escapeRules) {\n\t            var addRules = Array.prototype[append ? \"push\" : \"unshift\"];\n\t            for (var i = 0; i < states.length; i++)\n\t                addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));\n\t        }\n\n\t        if (!this.$embeds)\n\t            this.$embeds = [];\n\t        this.$embeds.push(prefix);\n\t    };\n\n\t    this.getEmbeds = function() {\n\t        return this.$embeds;\n\t    };\n\n\t    var pushState = function(currentState, stack) {\n\t        if (currentState != \"start\" || stack.length)\n\t            stack.unshift(this.nextState, currentState);\n\t        return this.nextState;\n\t    };\n\t    var popState = function(currentState, stack) {\n\t        stack.shift();\n\t        return stack.shift() || \"start\";\n\t    };\n\n\t    this.normalizeRules = function() {\n\t        var id = 0;\n\t        var rules = this.$rules;\n\t        function processState(key) {\n\t            var state = rules[key];\n\t            state.processed = true;\n\t            for (var i = 0; i < state.length; i++) {\n\t                var rule = state[i];\n\t                if (!rule.regex && rule.start) {\n\t                    rule.regex = rule.start;\n\t                    if (!rule.next)\n\t                        rule.next = [];\n\t                    rule.next.push({\n\t                        defaultToken: rule.token\n\t                    }, {\n\t                        token: rule.token + \".end\",\n\t                        regex: rule.end || rule.start,\n\t                        next: \"pop\"\n\t                    });\n\t                    rule.token = rule.token + \".start\";\n\t                    rule.push = true;\n\t                }\n\t                var next = rule.next || rule.push;\n\t                if (next && Array.isArray(next)) {\n\t                    var stateName = rule.stateName;\n\t                    if (!stateName)  {\n\t                        stateName = rule.token;\n\t                        if (typeof stateName != \"string\")\n\t                            stateName = stateName[0] || \"\";\n\t                        if (rules[stateName])\n\t                            stateName += id++;\n\t                    }\n\t                    rules[stateName] = next;\n\t                    rule.next = stateName;\n\t                    processState(stateName);\n\t                } else if (next == \"pop\") {\n\t                    rule.next = popState;\n\t                }\n\n\t                if (rule.push) {\n\t                    rule.nextState = rule.next || rule.push;\n\t                    rule.next = pushState;\n\t                    delete rule.push;\n\t                }\n\n\t                if (rule.rules) {\n\t                    for (var r in rule.rules) {\n\t                        if (rules[r]) {\n\t                            if (rules[r].push)\n\t                                rules[r].push.apply(rules[r], rule.rules[r]);\n\t                        } else {\n\t                            rules[r] = rule.rules[r];\n\t                        }\n\t                    }\n\t                }\n\t                if (rule.include || typeof rule == \"string\") {\n\t                    var includeName = rule.include || rule;\n\t                    var toInsert = rules[includeName];\n\t                } else if (Array.isArray(rule))\n\t                    toInsert = rule;\n\n\t                if (toInsert) {\n\t                    var args = [i, 1].concat(toInsert);\n\t                    if (rule.noEscape)\n\t                        args = args.filter(function(x) {return !x.next;});\n\t                    state.splice.apply(state, args);\n\t                    i--;\n\t                    toInsert = null;\n\t                }\n\t                \n\t                if (rule.keywordMap) {\n\t                    rule.token = this.createKeywordMapper(\n\t                        rule.keywordMap, rule.defaultToken || \"text\", rule.caseInsensitive\n\t                    );\n\t                    delete rule.defaultToken;\n\t                }\n\t            }\n\t        }\n\t        Object.keys(rules).forEach(processState, this);\n\t    };\n\n\t    this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {\n\t        var keywords = Object.create(null);\n\t        Object.keys(map).forEach(function(className) {\n\t            var a = map[className];\n\t            if (ignoreCase)\n\t                a = a.toLowerCase();\n\t            var list = a.split(splitChar || \"|\");\n\t            for (var i = list.length; i--; )\n\t                keywords[list[i]] = className;\n\t        });\n\t        if (Object.getPrototypeOf(keywords)) {\n\t            keywords.__proto__ = null;\n\t        }\n\t        this.$keywordList = Object.keys(keywords);\n\t        map = null;\n\t        return ignoreCase\n\t            ? function(value) {return keywords[value.toLowerCase()] || defaultToken }\n\t            : function(value) {return keywords[value] || defaultToken };\n\t    };\n\n\t    this.getKeywords = function() {\n\t        return this.$keywords;\n\t    };\n\n\t}).call(TextHighlightRules.prototype);\n\n\texports.TextHighlightRules = TextHighlightRules;\n\t});\n\n\tace.define(\"ace/mode/behaviour\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Behaviour = function() {\n\t   this.$behaviours = {};\n\t};\n\n\t(function () {\n\n\t    this.add = function (name, action, callback) {\n\t        switch (undefined) {\n\t          case this.$behaviours:\n\t              this.$behaviours = {};\n\t          case this.$behaviours[name]:\n\t              this.$behaviours[name] = {};\n\t        }\n\t        this.$behaviours[name][action] = callback;\n\t    }\n\t    \n\t    this.addBehaviours = function (behaviours) {\n\t        for (var key in behaviours) {\n\t            for (var action in behaviours[key]) {\n\t                this.add(key, action, behaviours[key][action]);\n\t            }\n\t        }\n\t    }\n\t    \n\t    this.remove = function (name) {\n\t        if (this.$behaviours && this.$behaviours[name]) {\n\t            delete this.$behaviours[name];\n\t        }\n\t    }\n\t    \n\t    this.inherit = function (mode, filter) {\n\t        if (typeof mode === \"function\") {\n\t            var behaviours = new mode().getBehaviours(filter);\n\t        } else {\n\t            var behaviours = mode.getBehaviours(filter);\n\t        }\n\t        this.addBehaviours(behaviours);\n\t    }\n\t    \n\t    this.getBehaviours = function (filter) {\n\t        if (!filter) {\n\t            return this.$behaviours;\n\t        } else {\n\t            var ret = {}\n\t            for (var i = 0; i < filter.length; i++) {\n\t                if (this.$behaviours[filter[i]]) {\n\t                    ret[filter[i]] = this.$behaviours[filter[i]];\n\t                }\n\t            }\n\t            return ret;\n\t        }\n\t    }\n\n\t}).call(Behaviour.prototype);\n\n\texports.Behaviour = Behaviour;\n\t});\n\n\tace.define(\"ace/unicode\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\texports.packages = {};\n\n\taddUnicodePackage({\n\t    L:  \"0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC\",\n\t    Ll: \"0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A\",\n\t    Lu: \"0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A\",\n\t    Lt: \"01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC\",\n\t    Lm: \"02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F\",\n\t    Lo: \"01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC\",\n\t    M:  \"0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26\",\n\t    Mn: \"0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26\",\n\t    Mc: \"0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC\",\n\t    Me: \"0488048906DE20DD-20E020E2-20E4A670-A672\",\n\t    N:  \"0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19\",\n\t    Nd: \"0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19\",\n\t    Nl: \"16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF\",\n\t    No: \"00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835\",\n\t    P:  \"0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65\",\n\t    Pd: \"002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D\",\n\t    Ps: \"0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62\",\n\t    Pe: \"0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63\",\n\t    Pi: \"00AB2018201B201C201F20392E022E042E092E0C2E1C2E20\",\n\t    Pf: \"00BB2019201D203A2E032E052E0A2E0D2E1D2E21\",\n\t    Pc: \"005F203F20402054FE33FE34FE4D-FE4FFF3F\",\n\t    Po: \"0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65\",\n\t    S:  \"0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD\",\n\t    Sm: \"002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC\",\n\t    Sc: \"002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6\",\n\t    Sk: \"005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3\",\n\t    So: \"00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD\",\n\t    Z:  \"002000A01680180E2000-200A20282029202F205F3000\",\n\t    Zs: \"002000A01680180E2000-200A202F205F3000\",\n\t    Zl: \"2028\",\n\t    Zp: \"2029\",\n\t    C:  \"0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF\",\n\t    Cc: \"0000-001F007F-009F\",\n\t    Cf: \"00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB\",\n\t    Co: \"E000-F8FF\",\n\t    Cs: \"D800-DFFF\",\n\t    Cn: \"03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF\"\n\t});\n\n\tfunction addUnicodePackage (pack) {\n\t    var codePoint = /\\w{4}/g;\n\t    for (var name in pack)\n\t        exports.packages[name] = pack[name].replace(codePoint, \"\\\\u$&\");\n\t};\n\n\t});\n\n\tace.define(\"ace/token_iterator\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar TokenIterator = function(session, initialRow, initialColumn) {\n\t    this.$session = session;\n\t    this.$row = initialRow;\n\t    this.$rowTokens = session.getTokens(initialRow);\n\n\t    var token = session.getTokenAt(initialRow, initialColumn);\n\t    this.$tokenIndex = token ? token.index : -1;\n\t};\n\n\t(function() { \n\t    this.stepBackward = function() {\n\t        this.$tokenIndex -= 1;\n\t        \n\t        while (this.$tokenIndex < 0) {\n\t            this.$row -= 1;\n\t            if (this.$row < 0) {\n\t                this.$row = 0;\n\t                return null;\n\t            }\n\t                \n\t            this.$rowTokens = this.$session.getTokens(this.$row);\n\t            this.$tokenIndex = this.$rowTokens.length - 1;\n\t        }\n\t            \n\t        return this.$rowTokens[this.$tokenIndex];\n\t    };   \n\t    this.stepForward = function() {\n\t        this.$tokenIndex += 1;\n\t        var rowCount;\n\t        while (this.$tokenIndex >= this.$rowTokens.length) {\n\t            this.$row += 1;\n\t            if (!rowCount)\n\t                rowCount = this.$session.getLength();\n\t            if (this.$row >= rowCount) {\n\t                this.$row = rowCount - 1;\n\t                return null;\n\t            }\n\n\t            this.$rowTokens = this.$session.getTokens(this.$row);\n\t            this.$tokenIndex = 0;\n\t        }\n\t            \n\t        return this.$rowTokens[this.$tokenIndex];\n\t    };      \n\t    this.getCurrentToken = function () {\n\t        return this.$rowTokens[this.$tokenIndex];\n\t    };      \n\t    this.getCurrentTokenRow = function () {\n\t        return this.$row;\n\t    };     \n\t    this.getCurrentTokenColumn = function() {\n\t        var rowTokens = this.$rowTokens;\n\t        var tokenIndex = this.$tokenIndex;\n\t        var column = rowTokens[tokenIndex].start;\n\t        if (column !== undefined)\n\t            return column;\n\t            \n\t        column = 0;\n\t        while (tokenIndex > 0) {\n\t            tokenIndex -= 1;\n\t            column += rowTokens[tokenIndex].value.length;\n\t        }\n\t        \n\t        return column;  \n\t    };\n\t            \n\t}).call(TokenIterator.prototype);\n\n\texports.TokenIterator = TokenIterator;\n\t});\n\n\tace.define(\"ace/mode/text\",[\"require\",\"exports\",\"module\",\"ace/tokenizer\",\"ace/mode/text_highlight_rules\",\"ace/mode/behaviour\",\"ace/unicode\",\"ace/lib/lang\",\"ace/token_iterator\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Tokenizer = acequire(\"../tokenizer\").Tokenizer;\n\tvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\tvar Behaviour = acequire(\"./behaviour\").Behaviour;\n\tvar unicode = acequire(\"../unicode\");\n\tvar lang = acequire(\"../lib/lang\");\n\tvar TokenIterator = acequire(\"../token_iterator\").TokenIterator;\n\tvar Range = acequire(\"../range\").Range;\n\n\tvar Mode = function() {\n\t    this.HighlightRules = TextHighlightRules;\n\t    this.$behaviour = new Behaviour();\n\t};\n\n\t(function() {\n\n\t    this.tokenRe = new RegExp(\"^[\"\n\t        + unicode.packages.L\n\t        + unicode.packages.Mn + unicode.packages.Mc\n\t        + unicode.packages.Nd\n\t        + unicode.packages.Pc + \"\\\\$_]+\", \"g\"\n\t    );\n\n\t    this.nonTokenRe = new RegExp(\"^(?:[^\"\n\t        + unicode.packages.L\n\t        + unicode.packages.Mn + unicode.packages.Mc\n\t        + unicode.packages.Nd\n\t        + unicode.packages.Pc + \"\\\\$_]|\\\\s])+\", \"g\"\n\t    );\n\n\t    this.getTokenizer = function() {\n\t        if (!this.$tokenizer) {\n\t            this.$highlightRules = this.$highlightRules || new this.HighlightRules();\n\t            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\n\t        }\n\t        return this.$tokenizer;\n\t    };\n\n\t    this.lineCommentStart = \"\";\n\t    this.blockComment = \"\";\n\n\t    this.toggleCommentLines = function(state, session, startRow, endRow) {\n\t        var doc = session.doc;\n\n\t        var ignoreBlankLines = true;\n\t        var shouldRemove = true;\n\t        var minIndent = Infinity;\n\t        var tabSize = session.getTabSize();\n\t        var insertAtTabStop = false;\n\n\t        if (!this.lineCommentStart) {\n\t            if (!this.blockComment)\n\t                return false;\n\t            var lineCommentStart = this.blockComment.start;\n\t            var lineCommentEnd = this.blockComment.end;\n\t            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\n\t            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\n\n\t            var comment = function(line, i) {\n\t                if (testRemove(line, i))\n\t                    return;\n\t                if (!ignoreBlankLines || /\\S/.test(line)) {\n\t                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);\n\t                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n\t                }\n\t            };\n\n\t            var uncomment = function(line, i) {\n\t                var m;\n\t                if (m = line.match(regexpEnd))\n\t                    doc.removeInLine(i, line.length - m[0].length, line.length);\n\t                if (m = line.match(regexpStart))\n\t                    doc.removeInLine(i, m[1].length, m[0].length);\n\t            };\n\n\t            var testRemove = function(line, row) {\n\t                if (regexpStart.test(line))\n\t                    return true;\n\t                var tokens = session.getTokens(row);\n\t                for (var i = 0; i < tokens.length; i++) {\n\t                    if (tokens[i].type === 'comment')\n\t                        return true;\n\t                }\n\t            };\n\t        } else {\n\t            if (Array.isArray(this.lineCommentStart)) {\n\t                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\n\t                var lineCommentStart = this.lineCommentStart[0];\n\t            } else {\n\t                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\n\t                var lineCommentStart = this.lineCommentStart;\n\t            }\n\t            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\n\t            \n\t            insertAtTabStop = session.getUseSoftTabs();\n\n\t            var uncomment = function(line, i) {\n\t                var m = line.match(regexpStart);\n\t                if (!m) return;\n\t                var start = m[1].length, end = m[0].length;\n\t                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\n\t                    end--;\n\t                doc.removeInLine(i, start, end);\n\t            };\n\t            var commentWithSpace = lineCommentStart + \" \";\n\t            var comment = function(line, i) {\n\t                if (!ignoreBlankLines || /\\S/.test(line)) {\n\t                    if (shouldInsertSpace(line, minIndent, minIndent))\n\t                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);\n\t                    else\n\t                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\n\t                }\n\t            };\n\t            var testRemove = function(line, i) {\n\t                return regexpStart.test(line);\n\t            };\n\t            \n\t            var shouldInsertSpace = function(line, before, after) {\n\t                var spaces = 0;\n\t                while (before-- && line.charAt(before) == \" \")\n\t                    spaces++;\n\t                if (spaces % tabSize != 0)\n\t                    return false;\n\t                var spaces = 0;\n\t                while (line.charAt(after++) == \" \")\n\t                    spaces++;\n\t                if (tabSize > 2)\n\t                    return spaces % tabSize != tabSize - 1;\n\t                else\n\t                    return spaces % tabSize == 0;\n\t                return true;\n\t            };\n\t        }\n\n\t        function iter(fun) {\n\t            for (var i = startRow; i <= endRow; i++)\n\t                fun(doc.getLine(i), i);\n\t        }\n\n\n\t        var minEmptyLength = Infinity;\n\t        iter(function(line, i) {\n\t            var indent = line.search(/\\S/);\n\t            if (indent !== -1) {\n\t                if (indent < minIndent)\n\t                    minIndent = indent;\n\t                if (shouldRemove && !testRemove(line, i))\n\t                    shouldRemove = false;\n\t            } else if (minEmptyLength > line.length) {\n\t                minEmptyLength = line.length;\n\t            }\n\t        });\n\n\t        if (minIndent == Infinity) {\n\t            minIndent = minEmptyLength;\n\t            ignoreBlankLines = false;\n\t            shouldRemove = false;\n\t        }\n\n\t        if (insertAtTabStop && minIndent % tabSize != 0)\n\t            minIndent = Math.floor(minIndent / tabSize) * tabSize;\n\n\t        iter(shouldRemove ? uncomment : comment);\n\t    };\n\n\t    this.toggleBlockComment = function(state, session, range, cursor) {\n\t        var comment = this.blockComment;\n\t        if (!comment)\n\t            return;\n\t        if (!comment.start && comment[0])\n\t            comment = comment[0];\n\n\t        var iterator = new TokenIterator(session, cursor.row, cursor.column);\n\t        var token = iterator.getCurrentToken();\n\n\t        var sel = session.selection;\n\t        var initialRange = session.selection.toOrientedRange();\n\t        var startRow, colDiff;\n\n\t        if (token && /comment/.test(token.type)) {\n\t            var startRange, endRange;\n\t            while (token && /comment/.test(token.type)) {\n\t                var i = token.value.indexOf(comment.start);\n\t                if (i != -1) {\n\t                    var row = iterator.getCurrentTokenRow();\n\t                    var column = iterator.getCurrentTokenColumn() + i;\n\t                    startRange = new Range(row, column, row, column + comment.start.length);\n\t                    break;\n\t                }\n\t                token = iterator.stepBackward();\n\t            }\n\n\t            var iterator = new TokenIterator(session, cursor.row, cursor.column);\n\t            var token = iterator.getCurrentToken();\n\t            while (token && /comment/.test(token.type)) {\n\t                var i = token.value.indexOf(comment.end);\n\t                if (i != -1) {\n\t                    var row = iterator.getCurrentTokenRow();\n\t                    var column = iterator.getCurrentTokenColumn() + i;\n\t                    endRange = new Range(row, column, row, column + comment.end.length);\n\t                    break;\n\t                }\n\t                token = iterator.stepForward();\n\t            }\n\t            if (endRange)\n\t                session.remove(endRange);\n\t            if (startRange) {\n\t                session.remove(startRange);\n\t                startRow = startRange.start.row;\n\t                colDiff = -comment.start.length;\n\t            }\n\t        } else {\n\t            colDiff = comment.start.length;\n\t            startRow = range.start.row;\n\t            session.insert(range.end, comment.end);\n\t            session.insert(range.start, comment.start);\n\t        }\n\t        if (initialRange.start.row == startRow)\n\t            initialRange.start.column += colDiff;\n\t        if (initialRange.end.row == startRow)\n\t            initialRange.end.column += colDiff;\n\t        session.selection.fromOrientedRange(initialRange);\n\t    };\n\n\t    this.getNextLineIndent = function(state, line, tab) {\n\t        return this.$getIndent(line);\n\t    };\n\n\t    this.checkOutdent = function(state, line, input) {\n\t        return false;\n\t    };\n\n\t    this.autoOutdent = function(state, doc, row) {\n\t    };\n\n\t    this.$getIndent = function(line) {\n\t        return line.match(/^\\s*/)[0];\n\t    };\n\n\t    this.createWorker = function(session) {\n\t        return null;\n\t    };\n\n\t    this.createModeDelegates = function (mapping) {\n\t        this.$embeds = [];\n\t        this.$modes = {};\n\t        for (var i in mapping) {\n\t            if (mapping[i]) {\n\t                this.$embeds.push(i);\n\t                this.$modes[i] = new mapping[i]();\n\t            }\n\t        }\n\n\t        var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent', \n\t            'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];\n\n\t        for (var i = 0; i < delegations.length; i++) {\n\t            (function(scope) {\n\t              var functionName = delegations[i];\n\t              var defaultHandler = scope[functionName];\n\t              scope[delegations[i]] = function() {\n\t                  return this.$delegator(functionName, arguments, defaultHandler);\n\t              };\n\t            } (this));\n\t        }\n\t    };\n\n\t    this.$delegator = function(method, args, defaultHandler) {\n\t        var state = args[0];\n\t        if (typeof state != \"string\")\n\t            state = state[0];\n\t        for (var i = 0; i < this.$embeds.length; i++) {\n\t            if (!this.$modes[this.$embeds[i]]) continue;\n\n\t            var split = state.split(this.$embeds[i]);\n\t            if (!split[0] && split[1]) {\n\t                args[0] = split[1];\n\t                var mode = this.$modes[this.$embeds[i]];\n\t                return mode[method].apply(mode, args);\n\t            }\n\t        }\n\t        var ret = defaultHandler.apply(this, args);\n\t        return defaultHandler ? ret : undefined;\n\t    };\n\n\t    this.transformAction = function(state, action, editor, session, param) {\n\t        if (this.$behaviour) {\n\t            var behaviours = this.$behaviour.getBehaviours();\n\t            for (var key in behaviours) {\n\t                if (behaviours[key][action]) {\n\t                    var ret = behaviours[key][action].apply(this, arguments);\n\t                    if (ret) {\n\t                        return ret;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    \n\t    this.getKeywords = function(append) {\n\t        if (!this.completionKeywords) {\n\t            var rules = this.$tokenizer.rules;\n\t            var completionKeywords = [];\n\t            for (var rule in rules) {\n\t                var ruleItr = rules[rule];\n\t                for (var r = 0, l = ruleItr.length; r < l; r++) {\n\t                    if (typeof ruleItr[r].token === \"string\") {\n\t                        if (/keyword|support|storage/.test(ruleItr[r].token))\n\t                            completionKeywords.push(ruleItr[r].regex);\n\t                    }\n\t                    else if (typeof ruleItr[r].token === \"object\") {\n\t                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    \n\t                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\n\t                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\n\t                                completionKeywords.push(rule.substr(1, rule.length - 2));\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            this.completionKeywords = completionKeywords;\n\t        }\n\t        if (!append)\n\t            return this.$keywordList;\n\t        return completionKeywords.concat(this.$keywordList || []);\n\t    };\n\t    \n\t    this.$createKeywordList = function() {\n\t        if (!this.$highlightRules)\n\t            this.getTokenizer();\n\t        return this.$keywordList = this.$highlightRules.$keywordList || [];\n\t    };\n\n\t    this.getCompletions = function(state, session, pos, prefix) {\n\t        var keywords = this.$keywordList || this.$createKeywordList();\n\t        return keywords.map(function(word) {\n\t            return {\n\t                name: word,\n\t                value: word,\n\t                score: 0,\n\t                meta: \"keyword\"\n\t            };\n\t        });\n\t    };\n\n\t    this.$id = \"ace/mode/text\";\n\t}).call(Mode.prototype);\n\n\texports.Mode = Mode;\n\t});\n\n\tace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\n\tvar Anchor = exports.Anchor = function(doc, row, column) {\n\t    this.$onChange = this.onChange.bind(this);\n\t    this.attach(doc);\n\t    \n\t    if (typeof column == \"undefined\")\n\t        this.setPosition(row.row, row.column);\n\t    else\n\t        this.setPosition(row, column);\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\t    this.getPosition = function() {\n\t        return this.$clipPositionToDocument(this.row, this.column);\n\t    };\n\t    this.getDocument = function() {\n\t        return this.document;\n\t    };\n\t    this.$insertRight = false;\n\t    this.onChange = function(e) {\n\t        var delta = e.data;\n\t        var range = delta.range;\n\n\t        if (range.start.row == range.end.row && range.start.row != this.row)\n\t            return;\n\n\t        if (range.start.row > this.row)\n\t            return;\n\n\t        if (range.start.row == this.row && range.start.column > this.column)\n\t            return;\n\n\t        var row = this.row;\n\t        var column = this.column;\n\t        var start = range.start;\n\t        var end = range.end;\n\n\t        if (delta.action === \"insertText\") {\n\t            if (start.row === row && start.column <= column) {\n\t                if (start.column === column && this.$insertRight) {\n\t                } else if (start.row === end.row) {\n\t                    column += end.column - start.column;\n\t                } else {\n\t                    column -= start.column;\n\t                    row += end.row - start.row;\n\t                }\n\t            } else if (start.row !== end.row && start.row < row) {\n\t                row += end.row - start.row;\n\t            }\n\t        } else if (delta.action === \"insertLines\") {\n\t            if (start.row === row && column === 0 && this.$insertRight) {\n\t            }\n\t            else if (start.row <= row) {\n\t                row += end.row - start.row;\n\t            }\n\t        } else if (delta.action === \"removeText\") {\n\t            if (start.row === row && start.column < column) {\n\t                if (end.column >= column)\n\t                    column = start.column;\n\t                else\n\t                    column = Math.max(0, column - (end.column - start.column));\n\n\t            } else if (start.row !== end.row && start.row < row) {\n\t                if (end.row === row)\n\t                    column = Math.max(0, column - end.column) + start.column;\n\t                row -= (end.row - start.row);\n\t            } else if (end.row === row) {\n\t                row -= end.row - start.row;\n\t                column = Math.max(0, column - end.column) + start.column;\n\t            }\n\t        } else if (delta.action == \"removeLines\") {\n\t            if (start.row <= row) {\n\t                if (end.row <= row)\n\t                    row -= end.row - start.row;\n\t                else {\n\t                    row = start.row;\n\t                    column = 0;\n\t                }\n\t            }\n\t        }\n\n\t        this.setPosition(row, column, true);\n\t    };\n\t    this.setPosition = function(row, column, noClip) {\n\t        var pos;\n\t        if (noClip) {\n\t            pos = {\n\t                row: row,\n\t                column: column\n\t            };\n\t        } else {\n\t            pos = this.$clipPositionToDocument(row, column);\n\t        }\n\n\t        if (this.row == pos.row && this.column == pos.column)\n\t            return;\n\n\t        var old = {\n\t            row: this.row,\n\t            column: this.column\n\t        };\n\n\t        this.row = pos.row;\n\t        this.column = pos.column;\n\t        this._signal(\"change\", {\n\t            old: old,\n\t            value: pos\n\t        });\n\t    };\n\t    this.detach = function() {\n\t        this.document.removeEventListener(\"change\", this.$onChange);\n\t    };\n\t    this.attach = function(doc) {\n\t        this.document = doc || this.document;\n\t        this.document.on(\"change\", this.$onChange);\n\t    };\n\t    this.$clipPositionToDocument = function(row, column) {\n\t        var pos = {};\n\n\t        if (row >= this.document.getLength()) {\n\t            pos.row = Math.max(0, this.document.getLength() - 1);\n\t            pos.column = this.document.getLine(pos.row).length;\n\t        }\n\t        else if (row < 0) {\n\t            pos.row = 0;\n\t            pos.column = 0;\n\t        }\n\t        else {\n\t            pos.row = row;\n\t            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));\n\t        }\n\n\t        if (column < 0)\n\t            pos.column = 0;\n\n\t        return pos;\n\t    };\n\n\t}).call(Anchor.prototype);\n\n\t});\n\n\tace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar Range = acequire(\"./range\").Range;\n\tvar Anchor = acequire(\"./anchor\").Anchor;\n\n\tvar Document = function(text) {\n\t    this.$lines = [];\n\t    if (text.length === 0) {\n\t        this.$lines = [\"\"];\n\t    } else if (Array.isArray(text)) {\n\t        this._insertLines(0, text);\n\t    } else {\n\t        this.insert({row: 0, column:0}, text);\n\t    }\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\t    this.setValue = function(text) {\n\t        var len = this.getLength();\n\t        this.remove(new Range(0, 0, len, this.getLine(len-1).length));\n\t        this.insert({row: 0, column:0}, text);\n\t    };\n\t    this.getValue = function() {\n\t        return this.getAllLines().join(this.getNewLineCharacter());\n\t    };\n\t    this.createAnchor = function(row, column) {\n\t        return new Anchor(this, row, column);\n\t    };\n\t    if (\"aaa\".split(/a/).length === 0)\n\t        this.$split = function(text) {\n\t            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\n\t        };\n\t    else\n\t        this.$split = function(text) {\n\t            return text.split(/\\r\\n|\\r|\\n/);\n\t        };\n\n\n\t    this.$detectNewLine = function(text) {\n\t        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\n\t        this.$autoNewLine = match ? match[1] : \"\\n\";\n\t        this._signal(\"changeNewLineMode\");\n\t    };\n\t    this.getNewLineCharacter = function() {\n\t        switch (this.$newLineMode) {\n\t          case \"windows\":\n\t            return \"\\r\\n\";\n\t          case \"unix\":\n\t            return \"\\n\";\n\t          default:\n\t            return this.$autoNewLine || \"\\n\";\n\t        }\n\t    };\n\n\t    this.$autoNewLine = \"\";\n\t    this.$newLineMode = \"auto\";\n\t    this.setNewLineMode = function(newLineMode) {\n\t        if (this.$newLineMode === newLineMode)\n\t            return;\n\n\t        this.$newLineMode = newLineMode;\n\t        this._signal(\"changeNewLineMode\");\n\t    };\n\t    this.getNewLineMode = function() {\n\t        return this.$newLineMode;\n\t    };\n\t    this.isNewLine = function(text) {\n\t        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\n\t    };\n\t    this.getLine = function(row) {\n\t        return this.$lines[row] || \"\";\n\t    };\n\t    this.getLines = function(firstRow, lastRow) {\n\t        return this.$lines.slice(firstRow, lastRow + 1);\n\t    };\n\t    this.getAllLines = function() {\n\t        return this.getLines(0, this.getLength());\n\t    };\n\t    this.getLength = function() {\n\t        return this.$lines.length;\n\t    };\n\t    this.getTextRange = function(range) {\n\t        if (range.start.row == range.end.row) {\n\t            return this.getLine(range.start.row)\n\t                .substring(range.start.column, range.end.column);\n\t        }\n\t        var lines = this.getLines(range.start.row, range.end.row);\n\t        lines[0] = (lines[0] || \"\").substring(range.start.column);\n\t        var l = lines.length - 1;\n\t        if (range.end.row - range.start.row == l)\n\t            lines[l] = lines[l].substring(0, range.end.column);\n\t        return lines.join(this.getNewLineCharacter());\n\t    };\n\n\t    this.$clipPosition = function(position) {\n\t        var length = this.getLength();\n\t        if (position.row >= length) {\n\t            position.row = Math.max(0, length - 1);\n\t            position.column = this.getLine(length-1).length;\n\t        } else if (position.row < 0)\n\t            position.row = 0;\n\t        return position;\n\t    };\n\t    this.insert = function(position, text) {\n\t        if (!text || text.length === 0)\n\t            return position;\n\n\t        position = this.$clipPosition(position);\n\t        if (this.getLength() <= 1)\n\t            this.$detectNewLine(text);\n\n\t        var lines = this.$split(text);\n\t        var firstLine = lines.splice(0, 1)[0];\n\t        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];\n\n\t        position = this.insertInLine(position, firstLine);\n\t        if (lastLine !== null) {\n\t            position = this.insertNewLine(position); // terminate first line\n\t            position = this._insertLines(position.row, lines);\n\t            position = this.insertInLine(position, lastLine || \"\");\n\t        }\n\t        return position;\n\t    };\n\t    this.insertLines = function(row, lines) {\n\t        if (row >= this.getLength())\n\t            return this.insert({row: row, column: 0}, \"\\n\" + lines.join(\"\\n\"));\n\t        return this._insertLines(Math.max(row, 0), lines);\n\t    };\n\t    this._insertLines = function(row, lines) {\n\t        if (lines.length == 0)\n\t            return {row: row, column: 0};\n\t        while (lines.length > 0xF000) {\n\t            var end = this._insertLines(row, lines.slice(0, 0xF000));\n\t            lines = lines.slice(0xF000);\n\t            row = end.row;\n\t        }\n\n\t        var args = [row, 0];\n\t        args.push.apply(args, lines);\n\t        this.$lines.splice.apply(this.$lines, args);\n\n\t        var range = new Range(row, 0, row + lines.length, 0);\n\t        var delta = {\n\t            action: \"insertLines\",\n\t            range: range,\n\t            lines: lines\n\t        };\n\t        this._signal(\"change\", { data: delta });\n\t        return range.end;\n\t    };\n\t    this.insertNewLine = function(position) {\n\t        position = this.$clipPosition(position);\n\t        var line = this.$lines[position.row] || \"\";\n\n\t        this.$lines[position.row] = line.substring(0, position.column);\n\t        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));\n\n\t        var end = {\n\t            row : position.row + 1,\n\t            column : 0\n\t        };\n\n\t        var delta = {\n\t            action: \"insertText\",\n\t            range: Range.fromPoints(position, end),\n\t            text: this.getNewLineCharacter()\n\t        };\n\t        this._signal(\"change\", { data: delta });\n\n\t        return end;\n\t    };\n\t    this.insertInLine = function(position, text) {\n\t        if (text.length == 0)\n\t            return position;\n\n\t        var line = this.$lines[position.row] || \"\";\n\n\t        this.$lines[position.row] = line.substring(0, position.column) + text\n\t                + line.substring(position.column);\n\n\t        var end = {\n\t            row : position.row,\n\t            column : position.column + text.length\n\t        };\n\n\t        var delta = {\n\t            action: \"insertText\",\n\t            range: Range.fromPoints(position, end),\n\t            text: text\n\t        };\n\t        this._signal(\"change\", { data: delta });\n\n\t        return end;\n\t    };\n\t    this.remove = function(range) {\n\t        if (!(range instanceof Range))\n\t            range = Range.fromPoints(range.start, range.end);\n\t        range.start = this.$clipPosition(range.start);\n\t        range.end = this.$clipPosition(range.end);\n\n\t        if (range.isEmpty())\n\t            return range.start;\n\n\t        var firstRow = range.start.row;\n\t        var lastRow = range.end.row;\n\n\t        if (range.isMultiLine()) {\n\t            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;\n\t            var lastFullRow = lastRow - 1;\n\n\t            if (range.end.column > 0)\n\t                this.removeInLine(lastRow, 0, range.end.column);\n\n\t            if (lastFullRow >= firstFullRow)\n\t                this._removeLines(firstFullRow, lastFullRow);\n\n\t            if (firstFullRow != firstRow) {\n\t                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);\n\t                this.removeNewLine(range.start.row);\n\t            }\n\t        }\n\t        else {\n\t            this.removeInLine(firstRow, range.start.column, range.end.column);\n\t        }\n\t        return range.start;\n\t    };\n\t    this.removeInLine = function(row, startColumn, endColumn) {\n\t        if (startColumn == endColumn)\n\t            return;\n\n\t        var range = new Range(row, startColumn, row, endColumn);\n\t        var line = this.getLine(row);\n\t        var removed = line.substring(startColumn, endColumn);\n\t        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);\n\t        this.$lines.splice(row, 1, newLine);\n\n\t        var delta = {\n\t            action: \"removeText\",\n\t            range: range,\n\t            text: removed\n\t        };\n\t        this._signal(\"change\", { data: delta });\n\t        return range.start;\n\t    };\n\t    this.removeLines = function(firstRow, lastRow) {\n\t        if (firstRow < 0 || lastRow >= this.getLength())\n\t            return this.remove(new Range(firstRow, 0, lastRow + 1, 0));\n\t        return this._removeLines(firstRow, lastRow);\n\t    };\n\n\t    this._removeLines = function(firstRow, lastRow) {\n\t        var range = new Range(firstRow, 0, lastRow + 1, 0);\n\t        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);\n\n\t        var delta = {\n\t            action: \"removeLines\",\n\t            range: range,\n\t            nl: this.getNewLineCharacter(),\n\t            lines: removed\n\t        };\n\t        this._signal(\"change\", { data: delta });\n\t        return removed;\n\t    };\n\t    this.removeNewLine = function(row) {\n\t        var firstLine = this.getLine(row);\n\t        var secondLine = this.getLine(row+1);\n\n\t        var range = new Range(row, firstLine.length, row+1, 0);\n\t        var line = firstLine + secondLine;\n\n\t        this.$lines.splice(row, 2, line);\n\n\t        var delta = {\n\t            action: \"removeText\",\n\t            range: range,\n\t            text: this.getNewLineCharacter()\n\t        };\n\t        this._signal(\"change\", { data: delta });\n\t    };\n\t    this.replace = function(range, text) {\n\t        if (!(range instanceof Range))\n\t            range = Range.fromPoints(range.start, range.end);\n\t        if (text.length == 0 && range.isEmpty())\n\t            return range.start;\n\t        if (text == this.getTextRange(range))\n\t            return range.end;\n\n\t        this.remove(range);\n\t        if (text) {\n\t            var end = this.insert(range.start, text);\n\t        }\n\t        else {\n\t            end = range.start;\n\t        }\n\n\t        return end;\n\t    };\n\t    this.applyDeltas = function(deltas) {\n\t        for (var i=0; i<deltas.length; i++) {\n\t            var delta = deltas[i];\n\t            var range = Range.fromPoints(delta.range.start, delta.range.end);\n\n\t            if (delta.action == \"insertLines\")\n\t                this.insertLines(range.start.row, delta.lines);\n\t            else if (delta.action == \"insertText\")\n\t                this.insert(range.start, delta.text);\n\t            else if (delta.action == \"removeLines\")\n\t                this._removeLines(range.start.row, range.end.row - 1);\n\t            else if (delta.action == \"removeText\")\n\t                this.remove(range);\n\t        }\n\t    };\n\t    this.revertDeltas = function(deltas) {\n\t        for (var i=deltas.length-1; i>=0; i--) {\n\t            var delta = deltas[i];\n\n\t            var range = Range.fromPoints(delta.range.start, delta.range.end);\n\n\t            if (delta.action == \"insertLines\")\n\t                this._removeLines(range.start.row, range.end.row - 1);\n\t            else if (delta.action == \"insertText\")\n\t                this.remove(range);\n\t            else if (delta.action == \"removeLines\")\n\t                this._insertLines(range.start.row, delta.lines);\n\t            else if (delta.action == \"removeText\")\n\t                this.insert(range.start, delta.text);\n\t        }\n\t    };\n\t    this.indexToPosition = function(index, startRow) {\n\t        var lines = this.$lines || this.getAllLines();\n\t        var newlineLength = this.getNewLineCharacter().length;\n\t        for (var i = startRow || 0, l = lines.length; i < l; i++) {\n\t            index -= lines[i].length + newlineLength;\n\t            if (index < 0)\n\t                return {row: i, column: index + lines[i].length + newlineLength};\n\t        }\n\t        return {row: l-1, column: lines[l-1].length};\n\t    };\n\t    this.positionToIndex = function(pos, startRow) {\n\t        var lines = this.$lines || this.getAllLines();\n\t        var newlineLength = this.getNewLineCharacter().length;\n\t        var index = 0;\n\t        var row = Math.min(pos.row, lines.length);\n\t        for (var i = startRow || 0; i < row; ++i)\n\t            index += lines[i].length + newlineLength;\n\n\t        return index + pos.column;\n\t    };\n\n\t}).call(Document.prototype);\n\n\texports.Document = Document;\n\t});\n\n\tace.define(\"ace/background_tokenizer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\n\tvar BackgroundTokenizer = function(tokenizer, editor) {\n\t    this.running = false;\n\t    this.lines = [];\n\t    this.states = [];\n\t    this.currentLine = 0;\n\t    this.tokenizer = tokenizer;\n\n\t    var self = this;\n\n\t    this.$worker = function() {\n\t        if (!self.running) { return; }\n\n\t        var workerStart = new Date();\n\t        var currentLine = self.currentLine;\n\t        var endLine = -1;\n\t        var doc = self.doc;\n\n\t        while (self.lines[currentLine])\n\t            currentLine++;\n\n\t        var startLine = currentLine;\n\n\t        var len = doc.getLength();\n\t        var processedLines = 0;\n\t        self.running = false;\n\t        while (currentLine < len) {\n\t            self.$tokenizeRow(currentLine);\n\t            endLine = currentLine;\n\t            do {\n\t                currentLine++;\n\t            } while (self.lines[currentLine]);\n\t            processedLines ++;\n\t            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {                \n\t                self.running = setTimeout(self.$worker, 20);\n\t                break;\n\t            }\n\t        }\n\t        self.currentLine = currentLine;\n\t        \n\t        if (startLine <= endLine)\n\t            self.fireUpdateEvent(startLine, endLine);\n\t    };\n\t};\n\n\t(function(){\n\n\t    oop.implement(this, EventEmitter);\n\t    this.setTokenizer = function(tokenizer) {\n\t        this.tokenizer = tokenizer;\n\t        this.lines = [];\n\t        this.states = [];\n\n\t        this.start(0);\n\t    };\n\t    this.setDocument = function(doc) {\n\t        this.doc = doc;\n\t        this.lines = [];\n\t        this.states = [];\n\n\t        this.stop();\n\t    };\n\t    this.fireUpdateEvent = function(firstRow, lastRow) {\n\t        var data = {\n\t            first: firstRow,\n\t            last: lastRow\n\t        };\n\t        this._signal(\"update\", {data: data});\n\t    };\n\t    this.start = function(startRow) {\n\t        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());\n\t        this.lines.splice(this.currentLine, this.lines.length);\n\t        this.states.splice(this.currentLine, this.states.length);\n\n\t        this.stop();\n\t        this.running = setTimeout(this.$worker, 700);\n\t    };\n\t    \n\t    this.scheduleStart = function() {\n\t        if (!this.running)\n\t            this.running = setTimeout(this.$worker, 700);\n\t    }\n\n\t    this.$updateOnChange = function(delta) {\n\t        var range = delta.range;\n\t        var startRow = range.start.row;\n\t        var len = range.end.row - startRow;\n\n\t        if (len === 0) {\n\t            this.lines[startRow] = null;\n\t        } else if (delta.action == \"removeText\" || delta.action == \"removeLines\") {\n\t            this.lines.splice(startRow, len + 1, null);\n\t            this.states.splice(startRow, len + 1, null);\n\t        } else {\n\t            var args = Array(len + 1);\n\t            args.unshift(startRow, 1);\n\t            this.lines.splice.apply(this.lines, args);\n\t            this.states.splice.apply(this.states, args);\n\t        }\n\n\t        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());\n\n\t        this.stop();\n\t    };\n\t    this.stop = function() {\n\t        if (this.running)\n\t            clearTimeout(this.running);\n\t        this.running = false;\n\t    };\n\t    this.getTokens = function(row) {\n\t        return this.lines[row] || this.$tokenizeRow(row);\n\t    };\n\t    this.getState = function(row) {\n\t        if (this.currentLine == row)\n\t            this.$tokenizeRow(row);\n\t        return this.states[row] || \"start\";\n\t    };\n\n\t    this.$tokenizeRow = function(row) {\n\t        var line = this.doc.getLine(row);\n\t        var state = this.states[row - 1];\n\n\t        var data = this.tokenizer.getLineTokens(line, state, row);\n\n\t        if (this.states[row] + \"\" !== data.state + \"\") {\n\t            this.states[row] = data.state;\n\t            this.lines[row + 1] = null;\n\t            if (this.currentLine > row + 1)\n\t                this.currentLine = row + 1;\n\t        } else if (this.currentLine == row) {\n\t            this.currentLine = row + 1;\n\t        }\n\n\t        return this.lines[row] = data.tokens;\n\t    };\n\n\t}).call(BackgroundTokenizer.prototype);\n\n\texports.BackgroundTokenizer = BackgroundTokenizer;\n\t});\n\n\tace.define(\"ace/search_highlight\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar lang = acequire(\"./lib/lang\");\n\tvar oop = acequire(\"./lib/oop\");\n\tvar Range = acequire(\"./range\").Range;\n\n\tvar SearchHighlight = function(regExp, clazz, type) {\n\t    this.setRegexp(regExp);\n\t    this.clazz = clazz;\n\t    this.type = type || \"text\";\n\t};\n\n\t(function() {\n\t    this.MAX_RANGES = 500;\n\t    \n\t    this.setRegexp = function(regExp) {\n\t        if (this.regExp+\"\" == regExp+\"\")\n\t            return;\n\t        this.regExp = regExp;\n\t        this.cache = [];\n\t    };\n\n\t    this.update = function(html, markerLayer, session, config) {\n\t        if (!this.regExp)\n\t            return;\n\t        var start = config.firstRow, end = config.lastRow;\n\n\t        for (var i = start; i <= end; i++) {\n\t            var ranges = this.cache[i];\n\t            if (ranges == null) {\n\t                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);\n\t                if (ranges.length > this.MAX_RANGES)\n\t                    ranges = ranges.slice(0, this.MAX_RANGES);\n\t                ranges = ranges.map(function(match) {\n\t                    return new Range(i, match.offset, i, match.offset + match.length);\n\t                });\n\t                this.cache[i] = ranges.length ? ranges : \"\";\n\t            }\n\n\t            for (var j = ranges.length; j --; ) {\n\t                markerLayer.drawSingleLineMarker(\n\t                    html, ranges[j].toScreenRange(session), this.clazz, config);\n\t            }\n\t        }\n\t    };\n\n\t}).call(SearchHighlight.prototype);\n\n\texports.SearchHighlight = SearchHighlight;\n\t});\n\n\tace.define(\"ace/edit_session/fold_line\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"../range\").Range;\n\tfunction FoldLine(foldData, folds) {\n\t    this.foldData = foldData;\n\t    if (Array.isArray(folds)) {\n\t        this.folds = folds;\n\t    } else {\n\t        folds = this.folds = [ folds ];\n\t    }\n\n\t    var last = folds[folds.length - 1];\n\t    this.range = new Range(folds[0].start.row, folds[0].start.column,\n\t                           last.end.row, last.end.column);\n\t    this.start = this.range.start;\n\t    this.end   = this.range.end;\n\n\t    this.folds.forEach(function(fold) {\n\t        fold.setFoldLine(this);\n\t    }, this);\n\t}\n\n\t(function() {\n\t    this.shiftRow = function(shift) {\n\t        this.start.row += shift;\n\t        this.end.row += shift;\n\t        this.folds.forEach(function(fold) {\n\t            fold.start.row += shift;\n\t            fold.end.row += shift;\n\t        });\n\t    };\n\n\t    this.addFold = function(fold) {\n\t        if (fold.sameRow) {\n\t            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {\n\t                throw new Error(\"Can't add a fold to this FoldLine as it has no connection\");\n\t            }\n\t            this.folds.push(fold);\n\t            this.folds.sort(function(a, b) {\n\t                return -a.range.compareEnd(b.start.row, b.start.column);\n\t            });\n\t            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {\n\t                this.end.row = fold.end.row;\n\t                this.end.column =  fold.end.column;\n\t            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {\n\t                this.start.row = fold.start.row;\n\t                this.start.column = fold.start.column;\n\t            }\n\t        } else if (fold.start.row == this.end.row) {\n\t            this.folds.push(fold);\n\t            this.end.row = fold.end.row;\n\t            this.end.column = fold.end.column;\n\t        } else if (fold.end.row == this.start.row) {\n\t            this.folds.unshift(fold);\n\t            this.start.row = fold.start.row;\n\t            this.start.column = fold.start.column;\n\t        } else {\n\t            throw new Error(\"Trying to add fold to FoldRow that doesn't have a matching row\");\n\t        }\n\t        fold.foldLine = this;\n\t    };\n\n\t    this.containsRow = function(row) {\n\t        return row >= this.start.row && row <= this.end.row;\n\t    };\n\n\t    this.walk = function(callback, endRow, endColumn) {\n\t        var lastEnd = 0,\n\t            folds = this.folds,\n\t            fold,\n\t            cmp, stop, isNewRow = true;\n\n\t        if (endRow == null) {\n\t            endRow = this.end.row;\n\t            endColumn = this.end.column;\n\t        }\n\n\t        for (var i = 0; i < folds.length; i++) {\n\t            fold = folds[i];\n\n\t            cmp = fold.range.compareStart(endRow, endColumn);\n\t            if (cmp == -1) {\n\t                callback(null, endRow, endColumn, lastEnd, isNewRow);\n\t                return;\n\t            }\n\n\t            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);\n\t            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);\n\t            if (stop || cmp === 0) {\n\t                return;\n\t            }\n\t            isNewRow = !fold.sameRow;\n\t            lastEnd = fold.end.column;\n\t        }\n\t        callback(null, endRow, endColumn, lastEnd, isNewRow);\n\t    };\n\n\t    this.getNextFoldTo = function(row, column) {\n\t        var fold, cmp;\n\t        for (var i = 0; i < this.folds.length; i++) {\n\t            fold = this.folds[i];\n\t            cmp = fold.range.compareEnd(row, column);\n\t            if (cmp == -1) {\n\t                return {\n\t                    fold: fold,\n\t                    kind: \"after\"\n\t                };\n\t            } else if (cmp === 0) {\n\t                return {\n\t                    fold: fold,\n\t                    kind: \"inside\"\n\t                };\n\t            }\n\t        }\n\t        return null;\n\t    };\n\n\t    this.addRemoveChars = function(row, column, len) {\n\t        var ret = this.getNextFoldTo(row, column),\n\t            fold, folds;\n\t        if (ret) {\n\t            fold = ret.fold;\n\t            if (ret.kind == \"inside\"\n\t                && fold.start.column != column\n\t                && fold.start.row != row)\n\t            {\n\t                window.console && window.console.log(row, column, fold);\n\t            } else if (fold.start.row == row) {\n\t                folds = this.folds;\n\t                var i = folds.indexOf(fold);\n\t                if (i === 0) {\n\t                    this.start.column += len;\n\t                }\n\t                for (i; i < folds.length; i++) {\n\t                    fold = folds[i];\n\t                    fold.start.column += len;\n\t                    if (!fold.sameRow) {\n\t                        return;\n\t                    }\n\t                    fold.end.column += len;\n\t                }\n\t                this.end.column += len;\n\t            }\n\t        }\n\t    };\n\n\t    this.split = function(row, column) {\n\t        var pos = this.getNextFoldTo(row, column);\n\t        \n\t        if (!pos || pos.kind == \"inside\")\n\t            return null;\n\t            \n\t        var fold = pos.fold;\n\t        var folds = this.folds;\n\t        var foldData = this.foldData;\n\t        \n\t        var i = folds.indexOf(fold);\n\t        var foldBefore = folds[i - 1];\n\t        this.end.row = foldBefore.end.row;\n\t        this.end.column = foldBefore.end.column;\n\t        folds = folds.splice(i, folds.length - i);\n\n\t        var newFoldLine = new FoldLine(foldData, folds);\n\t        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);\n\t        return newFoldLine;\n\t    };\n\n\t    this.merge = function(foldLineNext) {\n\t        var folds = foldLineNext.folds;\n\t        for (var i = 0; i < folds.length; i++) {\n\t            this.addFold(folds[i]);\n\t        }\n\t        var foldData = this.foldData;\n\t        foldData.splice(foldData.indexOf(foldLineNext), 1);\n\t    };\n\n\t    this.toString = function() {\n\t        var ret = [this.range.toString() + \": [\" ];\n\n\t        this.folds.forEach(function(fold) {\n\t            ret.push(\"  \" + fold.toString());\n\t        });\n\t        ret.push(\"]\");\n\t        return ret.join(\"\\n\");\n\t    };\n\n\t    this.idxToPosition = function(idx) {\n\t        var lastFoldEndColumn = 0;\n\n\t        for (var i = 0; i < this.folds.length; i++) {\n\t            var fold = this.folds[i];\n\n\t            idx -= fold.start.column - lastFoldEndColumn;\n\t            if (idx < 0) {\n\t                return {\n\t                    row: fold.start.row,\n\t                    column: fold.start.column + idx\n\t                };\n\t            }\n\n\t            idx -= fold.placeholder.length;\n\t            if (idx < 0) {\n\t                return fold.start;\n\t            }\n\n\t            lastFoldEndColumn = fold.end.column;\n\t        }\n\n\t        return {\n\t            row: this.end.row,\n\t            column: this.end.column + idx\n\t        };\n\t    };\n\t}).call(FoldLine.prototype);\n\n\texports.FoldLine = FoldLine;\n\t});\n\n\tace.define(\"ace/range_list\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar Range = acequire(\"./range\").Range;\n\tvar comparePoints = Range.comparePoints;\n\n\tvar RangeList = function() {\n\t    this.ranges = [];\n\t};\n\n\t(function() {\n\t    this.comparePoints = comparePoints;\n\n\t    this.pointIndex = function(pos, excludeEdges, startIndex) {\n\t        var list = this.ranges;\n\n\t        for (var i = startIndex || 0; i < list.length; i++) {\n\t            var range = list[i];\n\t            var cmpEnd = comparePoints(pos, range.end);\n\t            if (cmpEnd > 0)\n\t                continue;\n\t            var cmpStart = comparePoints(pos, range.start);\n\t            if (cmpEnd === 0)\n\t                return excludeEdges && cmpStart !== 0 ? -i-2 : i;\n\t            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))\n\t                return i;\n\n\t            return -i-1;\n\t        }\n\t        return -i - 1;\n\t    };\n\n\t    this.add = function(range) {\n\t        var excludeEdges = !range.isEmpty();\n\t        var startIndex = this.pointIndex(range.start, excludeEdges);\n\t        if (startIndex < 0)\n\t            startIndex = -startIndex - 1;\n\n\t        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);\n\n\t        if (endIndex < 0)\n\t            endIndex = -endIndex - 1;\n\t        else\n\t            endIndex++;\n\t        return this.ranges.splice(startIndex, endIndex - startIndex, range);\n\t    };\n\n\t    this.addList = function(list) {\n\t        var removed = [];\n\t        for (var i = list.length; i--; ) {\n\t            removed.push.call(removed, this.add(list[i]));\n\t        }\n\t        return removed;\n\t    };\n\n\t    this.substractPoint = function(pos) {\n\t        var i = this.pointIndex(pos);\n\n\t        if (i >= 0)\n\t            return this.ranges.splice(i, 1);\n\t    };\n\t    this.merge = function() {\n\t        var removed = [];\n\t        var list = this.ranges;\n\t        \n\t        list = list.sort(function(a, b) {\n\t            return comparePoints(a.start, b.start);\n\t        });\n\t        \n\t        var next = list[0], range;\n\t        for (var i = 1; i < list.length; i++) {\n\t            range = next;\n\t            next = list[i];\n\t            var cmp = comparePoints(range.end, next.start);\n\t            if (cmp < 0)\n\t                continue;\n\n\t            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())\n\t                continue;\n\n\t            if (comparePoints(range.end, next.end) < 0) {\n\t                range.end.row = next.end.row;\n\t                range.end.column = next.end.column;\n\t            }\n\n\t            list.splice(i, 1);\n\t            removed.push(next);\n\t            next = range;\n\t            i--;\n\t        }\n\t        \n\t        this.ranges = list;\n\n\t        return removed;\n\t    };\n\n\t    this.contains = function(row, column) {\n\t        return this.pointIndex({row: row, column: column}) >= 0;\n\t    };\n\n\t    this.containsPoint = function(pos) {\n\t        return this.pointIndex(pos) >= 0;\n\t    };\n\n\t    this.rangeAtPoint = function(pos) {\n\t        var i = this.pointIndex(pos);\n\t        if (i >= 0)\n\t            return this.ranges[i];\n\t    };\n\n\n\t    this.clipRows = function(startRow, endRow) {\n\t        var list = this.ranges;\n\t        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)\n\t            return [];\n\n\t        var startIndex = this.pointIndex({row: startRow, column: 0});\n\t        if (startIndex < 0)\n\t            startIndex = -startIndex - 1;\n\t        var endIndex = this.pointIndex({row: endRow, column: 0}, startIndex);\n\t        if (endIndex < 0)\n\t            endIndex = -endIndex - 1;\n\n\t        var clipped = [];\n\t        for (var i = startIndex; i < endIndex; i++) {\n\t            clipped.push(list[i]);\n\t        }\n\t        return clipped;\n\t    };\n\n\t    this.removeAll = function() {\n\t        return this.ranges.splice(0, this.ranges.length);\n\t    };\n\n\t    this.attach = function(session) {\n\t        if (this.session)\n\t            this.detach();\n\n\t        this.session = session;\n\t        this.onChange = this.$onChange.bind(this);\n\n\t        this.session.on('change', this.onChange);\n\t    };\n\n\t    this.detach = function() {\n\t        if (!this.session)\n\t            return;\n\t        this.session.removeListener('change', this.onChange);\n\t        this.session = null;\n\t    };\n\n\t    this.$onChange = function(e) {\n\t        var changeRange = e.data.range;\n\t        if (e.data.action[0] == \"i\"){\n\t            var start = changeRange.start;\n\t            var end = changeRange.end;\n\t        } else {\n\t            var end = changeRange.start;\n\t            var start = changeRange.end;\n\t        }\n\t        var startRow = start.row;\n\t        var endRow = end.row;\n\t        var lineDif = endRow - startRow;\n\n\t        var colDiff = -start.column + end.column;\n\t        var ranges = this.ranges;\n\n\t        for (var i = 0, n = ranges.length; i < n; i++) {\n\t            var r = ranges[i];\n\t            if (r.end.row < startRow)\n\t                continue;\n\t            if (r.start.row > startRow)\n\t                break;\n\n\t            if (r.start.row == startRow && r.start.column >= start.column ) {\n\t                if (r.start.column == start.column && this.$insertRight) {\n\t                } else {\n\t                    r.start.column += colDiff;\n\t                    r.start.row += lineDif;\n\t                }\n\t            }\n\t            if (r.end.row == startRow && r.end.column >= start.column) {\n\t                if (r.end.column == start.column && this.$insertRight) {\n\t                    continue;\n\t                }\n\t                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {                \n\t                    if (r.end.column > r.start.column && r.end.column == ranges[i+1].start.column)\n\t                        r.end.column -= colDiff;\n\t                }\n\t                r.end.column += colDiff;\n\t                r.end.row += lineDif;\n\t            }\n\t        }\n\n\t        if (lineDif != 0 && i < n) {\n\t            for (; i < n; i++) {\n\t                var r = ranges[i];\n\t                r.start.row += lineDif;\n\t                r.end.row += lineDif;\n\t            }\n\t        }\n\t    };\n\n\t}).call(RangeList.prototype);\n\n\texports.RangeList = RangeList;\n\t});\n\n\tace.define(\"ace/edit_session/fold\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/range_list\",\"ace/lib/oop\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"../range\").Range;\n\tvar RangeList = acequire(\"../range_list\").RangeList;\n\tvar oop = acequire(\"../lib/oop\")\n\tvar Fold = exports.Fold = function(range, placeholder) {\n\t    this.foldLine = null;\n\t    this.placeholder = placeholder;\n\t    this.range = range;\n\t    this.start = range.start;\n\t    this.end = range.end;\n\n\t    this.sameRow = range.start.row == range.end.row;\n\t    this.subFolds = this.ranges = [];\n\t};\n\n\toop.inherits(Fold, RangeList);\n\n\t(function() {\n\n\t    this.toString = function() {\n\t        return '\"' + this.placeholder + '\" ' + this.range.toString();\n\t    };\n\n\t    this.setFoldLine = function(foldLine) {\n\t        this.foldLine = foldLine;\n\t        this.subFolds.forEach(function(fold) {\n\t            fold.setFoldLine(foldLine);\n\t        });\n\t    };\n\n\t    this.clone = function() {\n\t        var range = this.range.clone();\n\t        var fold = new Fold(range, this.placeholder);\n\t        this.subFolds.forEach(function(subFold) {\n\t            fold.subFolds.push(subFold.clone());\n\t        });\n\t        fold.collapseChildren = this.collapseChildren;\n\t        return fold;\n\t    };\n\n\t    this.addSubFold = function(fold) {\n\t        if (this.range.isEqual(fold))\n\t            return;\n\n\t        if (!this.range.containsRange(fold))\n\t            throw new Error(\"A fold can't intersect already existing fold\" + fold.range + this.range);\n\t        consumeRange(fold, this.start);\n\n\t        var row = fold.start.row, column = fold.start.column;\n\t        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {\n\t            cmp = this.subFolds[i].range.compare(row, column);\n\t            if (cmp != 1)\n\t                break;\n\t        }\n\t        var afterStart = this.subFolds[i];\n\n\t        if (cmp == 0)\n\t            return afterStart.addSubFold(fold);\n\t        var row = fold.range.end.row, column = fold.range.end.column;\n\t        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {\n\t            cmp = this.subFolds[j].range.compare(row, column);\n\t            if (cmp != 1)\n\t                break;\n\t        }\n\t        var afterEnd = this.subFolds[j];\n\n\t        if (cmp == 0)\n\t            throw new Error(\"A fold can't intersect already existing fold\" + fold.range + this.range);\n\n\t        var consumedFolds = this.subFolds.splice(i, j - i, fold);\n\t        fold.setFoldLine(this.foldLine);\n\n\t        return fold;\n\t    };\n\t    \n\t    this.restoreRange = function(range) {\n\t        return restoreRange(range, this.start);\n\t    };\n\n\t}).call(Fold.prototype);\n\n\tfunction consumePoint(point, anchor) {\n\t    point.row -= anchor.row;\n\t    if (point.row == 0)\n\t        point.column -= anchor.column;\n\t}\n\tfunction consumeRange(range, anchor) {\n\t    consumePoint(range.start, anchor);\n\t    consumePoint(range.end, anchor);\n\t}\n\tfunction restorePoint(point, anchor) {\n\t    if (point.row == 0)\n\t        point.column += anchor.column;\n\t    point.row += anchor.row;\n\t}\n\tfunction restoreRange(range, anchor) {\n\t    restorePoint(range.start, anchor);\n\t    restorePoint(range.end, anchor);\n\t}\n\n\t});\n\n\tace.define(\"ace/edit_session/folding\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/edit_session/fold_line\",\"ace/edit_session/fold\",\"ace/token_iterator\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"../range\").Range;\n\tvar FoldLine = acequire(\"./fold_line\").FoldLine;\n\tvar Fold = acequire(\"./fold\").Fold;\n\tvar TokenIterator = acequire(\"../token_iterator\").TokenIterator;\n\n\tfunction Folding() {\n\t    this.getFoldAt = function(row, column, side) {\n\t        var foldLine = this.getFoldLine(row);\n\t        if (!foldLine)\n\t            return null;\n\n\t        var folds = foldLine.folds;\n\t        for (var i = 0; i < folds.length; i++) {\n\t            var fold = folds[i];\n\t            if (fold.range.contains(row, column)) {\n\t                if (side == 1 && fold.range.isEnd(row, column)) {\n\t                    continue;\n\t                } else if (side == -1 && fold.range.isStart(row, column)) {\n\t                    continue;\n\t                }\n\t                return fold;\n\t            }\n\t        }\n\t    };\n\t    this.getFoldsInRange = function(range) {\n\t        var start = range.start;\n\t        var end = range.end;\n\t        var foldLines = this.$foldData;\n\t        var foundFolds = [];\n\n\t        start.column += 1;\n\t        end.column -= 1;\n\n\t        for (var i = 0; i < foldLines.length; i++) {\n\t            var cmp = foldLines[i].range.compareRange(range);\n\t            if (cmp == 2) {\n\t                continue;\n\t            }\n\t            else if (cmp == -2) {\n\t                break;\n\t            }\n\n\t            var folds = foldLines[i].folds;\n\t            for (var j = 0; j < folds.length; j++) {\n\t                var fold = folds[j];\n\t                cmp = fold.range.compareRange(range);\n\t                if (cmp == -2) {\n\t                    break;\n\t                } else if (cmp == 2) {\n\t                    continue;\n\t                } else\n\t                if (cmp == 42) {\n\t                    break;\n\t                }\n\t                foundFolds.push(fold);\n\t            }\n\t        }\n\t        start.column -= 1;\n\t        end.column += 1;\n\n\t        return foundFolds;\n\t    };\n\n\t    this.getFoldsInRangeList = function(ranges) {\n\t        if (Array.isArray(ranges)) {\n\t            var folds = [];\n\t            ranges.forEach(function(range) {\n\t                folds = folds.concat(this.getFoldsInRange(range));\n\t            }, this);\n\t        } else {\n\t            var folds = this.getFoldsInRange(ranges);\n\t        }\n\t        return folds;\n\t    }\n\t    this.getAllFolds = function() {\n\t        var folds = [];\n\t        var foldLines = this.$foldData;\n\t        \n\t        for (var i = 0; i < foldLines.length; i++)\n\t            for (var j = 0; j < foldLines[i].folds.length; j++)\n\t                folds.push(foldLines[i].folds[j]);\n\n\t        return folds;\n\t    };\n\t    this.getFoldStringAt = function(row, column, trim, foldLine) {\n\t        foldLine = foldLine || this.getFoldLine(row);\n\t        if (!foldLine)\n\t            return null;\n\n\t        var lastFold = {\n\t            end: { column: 0 }\n\t        };\n\t        var str, fold;\n\t        for (var i = 0; i < foldLine.folds.length; i++) {\n\t            fold = foldLine.folds[i];\n\t            var cmp = fold.range.compareEnd(row, column);\n\t            if (cmp == -1) {\n\t                str = this\n\t                    .getLine(fold.start.row)\n\t                    .substring(lastFold.end.column, fold.start.column);\n\t                break;\n\t            }\n\t            else if (cmp === 0) {\n\t                return null;\n\t            }\n\t            lastFold = fold;\n\t        }\n\t        if (!str)\n\t            str = this.getLine(fold.start.row).substring(lastFold.end.column);\n\n\t        if (trim == -1)\n\t            return str.substring(0, column - lastFold.end.column);\n\t        else if (trim == 1)\n\t            return str.substring(column - lastFold.end.column);\n\t        else\n\t            return str;\n\t    };\n\n\t    this.getFoldLine = function(docRow, startFoldLine) {\n\t        var foldData = this.$foldData;\n\t        var i = 0;\n\t        if (startFoldLine)\n\t            i = foldData.indexOf(startFoldLine);\n\t        if (i == -1)\n\t            i = 0;\n\t        for (i; i < foldData.length; i++) {\n\t            var foldLine = foldData[i];\n\t            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\n\t                return foldLine;\n\t            } else if (foldLine.end.row > docRow) {\n\t                return null;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    this.getNextFoldLine = function(docRow, startFoldLine) {\n\t        var foldData = this.$foldData;\n\t        var i = 0;\n\t        if (startFoldLine)\n\t            i = foldData.indexOf(startFoldLine);\n\t        if (i == -1)\n\t            i = 0;\n\t        for (i; i < foldData.length; i++) {\n\t            var foldLine = foldData[i];\n\t            if (foldLine.end.row >= docRow) {\n\t                return foldLine;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\n\t    this.getFoldedRowCount = function(first, last) {\n\t        var foldData = this.$foldData, rowCount = last-first+1;\n\t        for (var i = 0; i < foldData.length; i++) {\n\t            var foldLine = foldData[i],\n\t                end = foldLine.end.row,\n\t                start = foldLine.start.row;\n\t            if (end >= last) {\n\t                if(start < last) {\n\t                    if(start >= first)\n\t                        rowCount -= last-start;\n\t                    else\n\t                        rowCount = 0;//in one fold\n\t                }\n\t                break;\n\t            } else if(end >= first){\n\t                if (start >= first) //fold inside range\n\t                    rowCount -=  end-start;\n\t                else\n\t                    rowCount -=  end-first+1;\n\t            }\n\t        }\n\t        return rowCount;\n\t    };\n\n\t    this.$addFoldLine = function(foldLine) {\n\t        this.$foldData.push(foldLine);\n\t        this.$foldData.sort(function(a, b) {\n\t            return a.start.row - b.start.row;\n\t        });\n\t        return foldLine;\n\t    };\n\t    this.addFold = function(placeholder, range) {\n\t        var foldData = this.$foldData;\n\t        var added = false;\n\t        var fold;\n\t        \n\t        if (placeholder instanceof Fold)\n\t            fold = placeholder;\n\t        else {\n\t            fold = new Fold(range, placeholder);\n\t            fold.collapseChildren = range.collapseChildren;\n\t        }\n\t        this.$clipRangeToDocument(fold.range);\n\n\t        var startRow = fold.start.row;\n\t        var startColumn = fold.start.column;\n\t        var endRow = fold.end.row;\n\t        var endColumn = fold.end.column;\n\t        if (!(startRow < endRow || \n\t            startRow == endRow && startColumn <= endColumn - 2))\n\t            throw new Error(\"The range has to be at least 2 characters width\");\n\n\t        var startFold = this.getFoldAt(startRow, startColumn, 1);\n\t        var endFold = this.getFoldAt(endRow, endColumn, -1);\n\t        if (startFold && endFold == startFold)\n\t            return startFold.addSubFold(fold);\n\n\t        if (startFold && !startFold.range.isStart(startRow, startColumn))\n\t            this.removeFold(startFold);\n\n\t        if (endFold && !endFold.range.isEnd(endRow, endColumn))\n\t            this.removeFold(endFold);\n\t        var folds = this.getFoldsInRange(fold.range);\n\t        if (folds.length > 0) {\n\t            this.removeFolds(folds);\n\t            folds.forEach(function(subFold) {\n\t                fold.addSubFold(subFold);\n\t            });\n\t        }\n\n\t        for (var i = 0; i < foldData.length; i++) {\n\t            var foldLine = foldData[i];\n\t            if (endRow == foldLine.start.row) {\n\t                foldLine.addFold(fold);\n\t                added = true;\n\t                break;\n\t            } else if (startRow == foldLine.end.row) {\n\t                foldLine.addFold(fold);\n\t                added = true;\n\t                if (!fold.sameRow) {\n\t                    var foldLineNext = foldData[i + 1];\n\t                    if (foldLineNext && foldLineNext.start.row == endRow) {\n\t                        foldLine.merge(foldLineNext);\n\t                        break;\n\t                    }\n\t                }\n\t                break;\n\t            } else if (endRow <= foldLine.start.row) {\n\t                break;\n\t            }\n\t        }\n\n\t        if (!added)\n\t            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\n\n\t        if (this.$useWrapMode)\n\t            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\n\t        else\n\t            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\n\t        this.$modified = true;\n\t        this._emit(\"changeFold\", { data: fold, action: \"add\" });\n\n\t        return fold;\n\t    };\n\n\t    this.addFolds = function(folds) {\n\t        folds.forEach(function(fold) {\n\t            this.addFold(fold);\n\t        }, this);\n\t    };\n\n\t    this.removeFold = function(fold) {\n\t        var foldLine = fold.foldLine;\n\t        var startRow = foldLine.start.row;\n\t        var endRow = foldLine.end.row;\n\n\t        var foldLines = this.$foldData;\n\t        var folds = foldLine.folds;\n\t        if (folds.length == 1) {\n\t            foldLines.splice(foldLines.indexOf(foldLine), 1);\n\t        } else\n\t        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\n\t            folds.pop();\n\t            foldLine.end.row = folds[folds.length - 1].end.row;\n\t            foldLine.end.column = folds[folds.length - 1].end.column;\n\t        } else\n\t        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\n\t            folds.shift();\n\t            foldLine.start.row = folds[0].start.row;\n\t            foldLine.start.column = folds[0].start.column;\n\t        } else\n\t        if (fold.sameRow) {\n\t            folds.splice(folds.indexOf(fold), 1);\n\t        } else\n\t        {\n\t            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\n\t            folds = newFoldLine.folds;\n\t            folds.shift();\n\t            newFoldLine.start.row = folds[0].start.row;\n\t            newFoldLine.start.column = folds[0].start.column;\n\t        }\n\n\t        if (!this.$updating) {\n\t            if (this.$useWrapMode)\n\t                this.$updateWrapData(startRow, endRow);\n\t            else\n\t                this.$updateRowLengthCache(startRow, endRow);\n\t        }\n\t        this.$modified = true;\n\t        this._emit(\"changeFold\", { data: fold, action: \"remove\" });\n\t    };\n\n\t    this.removeFolds = function(folds) {\n\t        var cloneFolds = [];\n\t        for (var i = 0; i < folds.length; i++) {\n\t            cloneFolds.push(folds[i]);\n\t        }\n\n\t        cloneFolds.forEach(function(fold) {\n\t            this.removeFold(fold);\n\t        }, this);\n\t        this.$modified = true;\n\t    };\n\n\t    this.expandFold = function(fold) {\n\t        this.removeFold(fold);\n\t        fold.subFolds.forEach(function(subFold) {\n\t            fold.restoreRange(subFold);\n\t            this.addFold(subFold);\n\t        }, this);\n\t        if (fold.collapseChildren > 0) {\n\t            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);\n\t        }\n\t        fold.subFolds = [];\n\t    };\n\n\t    this.expandFolds = function(folds) {\n\t        folds.forEach(function(fold) {\n\t            this.expandFold(fold);\n\t        }, this);\n\t    };\n\n\t    this.unfold = function(location, expandInner) {\n\t        var range, folds;\n\t        if (location == null) {\n\t            range = new Range(0, 0, this.getLength(), 0);\n\t            expandInner = true;\n\t        } else if (typeof location == \"number\")\n\t            range = new Range(location, 0, location, this.getLine(location).length);\n\t        else if (\"row\" in location)\n\t            range = Range.fromPoints(location, location);\n\t        else\n\t            range = location;\n\t        \n\t        folds = this.getFoldsInRangeList(range);\n\t        if (expandInner) {\n\t            this.removeFolds(folds);\n\t        } else {\n\t            var subFolds = folds;\n\t            while (subFolds.length) {\n\t                this.expandFolds(subFolds);\n\t                subFolds = this.getFoldsInRangeList(range);\n\t            }\n\t        }\n\t        if (folds.length)\n\t            return folds;\n\t    };\n\t    this.isRowFolded = function(docRow, startFoldRow) {\n\t        return !!this.getFoldLine(docRow, startFoldRow);\n\t    };\n\n\t    this.getRowFoldEnd = function(docRow, startFoldRow) {\n\t        var foldLine = this.getFoldLine(docRow, startFoldRow);\n\t        return foldLine ? foldLine.end.row : docRow;\n\t    };\n\n\t    this.getRowFoldStart = function(docRow, startFoldRow) {\n\t        var foldLine = this.getFoldLine(docRow, startFoldRow);\n\t        return foldLine ? foldLine.start.row : docRow;\n\t    };\n\n\t    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {\n\t        if (startRow == null)\n\t            startRow = foldLine.start.row;\n\t        if (startColumn == null)\n\t            startColumn = 0;\n\t        if (endRow == null)\n\t            endRow = foldLine.end.row;\n\t        if (endColumn == null)\n\t            endColumn = this.getLine(endRow).length;\n\t        var doc = this.doc;\n\t        var textLine = \"\";\n\n\t        foldLine.walk(function(placeholder, row, column, lastColumn) {\n\t            if (row < startRow)\n\t                return;\n\t            if (row == startRow) {\n\t                if (column < startColumn)\n\t                    return;\n\t                lastColumn = Math.max(startColumn, lastColumn);\n\t            }\n\n\t            if (placeholder != null) {\n\t                textLine += placeholder;\n\t            } else {\n\t                textLine += doc.getLine(row).substring(lastColumn, column);\n\t            }\n\t        }, endRow, endColumn);\n\t        return textLine;\n\t    };\n\n\t    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {\n\t        var foldLine = this.getFoldLine(row);\n\n\t        if (!foldLine) {\n\t            var line;\n\t            line = this.doc.getLine(row);\n\t            return line.substring(startColumn || 0, endColumn || line.length);\n\t        } else {\n\t            return this.getFoldDisplayLine(\n\t                foldLine, row, endColumn, startRow, startColumn);\n\t        }\n\t    };\n\n\t    this.$cloneFoldData = function() {\n\t        var fd = [];\n\t        fd = this.$foldData.map(function(foldLine) {\n\t            var folds = foldLine.folds.map(function(fold) {\n\t                return fold.clone();\n\t            });\n\t            return new FoldLine(fd, folds);\n\t        });\n\n\t        return fd;\n\t    };\n\n\t    this.toggleFold = function(tryToUnfold) {\n\t        var selection = this.selection;\n\t        var range = selection.getRange();\n\t        var fold;\n\t        var bracketPos;\n\n\t        if (range.isEmpty()) {\n\t            var cursor = range.start;\n\t            fold = this.getFoldAt(cursor.row, cursor.column);\n\n\t            if (fold) {\n\t                this.expandFold(fold);\n\t                return;\n\t            } else if (bracketPos = this.findMatchingBracket(cursor)) {\n\t                if (range.comparePoint(bracketPos) == 1) {\n\t                    range.end = bracketPos;\n\t                } else {\n\t                    range.start = bracketPos;\n\t                    range.start.column++;\n\t                    range.end.column--;\n\t                }\n\t            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {\n\t                if (range.comparePoint(bracketPos) == 1)\n\t                    range.end = bracketPos;\n\t                else\n\t                    range.start = bracketPos;\n\n\t                range.start.column++;\n\t            } else {\n\t                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\n\t            }\n\t        } else {\n\t            var folds = this.getFoldsInRange(range);\n\t            if (tryToUnfold && folds.length) {\n\t                this.expandFolds(folds);\n\t                return;\n\t            } else if (folds.length == 1 ) {\n\t                fold = folds[0];\n\t            }\n\t        }\n\n\t        if (!fold)\n\t            fold = this.getFoldAt(range.start.row, range.start.column);\n\n\t        if (fold && fold.range.toString() == range.toString()) {\n\t            this.expandFold(fold);\n\t            return;\n\t        }\n\n\t        var placeholder = \"...\";\n\t        if (!range.isMultiLine()) {\n\t            placeholder = this.getTextRange(range);\n\t            if(placeholder.length < 4)\n\t                return;\n\t            placeholder = placeholder.trim().substring(0, 2) + \"..\";\n\t        }\n\n\t        this.addFold(placeholder, range);\n\t    };\n\n\t    this.getCommentFoldRange = function(row, column, dir) {\n\t        var iterator = new TokenIterator(this, row, column);\n\t        var token = iterator.getCurrentToken();\n\t        if (token && /^comment|string/.test(token.type)) {\n\t            var range = new Range();\n\t            var re = new RegExp(token.type.replace(/\\..*/, \"\\\\.\"));\n\t            if (dir != 1) {\n\t                do {\n\t                    token = iterator.stepBackward();\n\t                } while(token && re.test(token.type));\n\t                iterator.stepForward();\n\t            }\n\t            \n\t            range.start.row = iterator.getCurrentTokenRow();\n\t            range.start.column = iterator.getCurrentTokenColumn() + 2;\n\n\t            iterator = new TokenIterator(this, row, column);\n\t            \n\t            if (dir != -1) {\n\t                do {\n\t                    token = iterator.stepForward();\n\t                } while(token && re.test(token.type));\n\t                token = iterator.stepBackward();\n\t            } else\n\t                token = iterator.getCurrentToken();\n\n\t            range.end.row = iterator.getCurrentTokenRow();\n\t            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;\n\t            return range;\n\t        }\n\t    };\n\n\t    this.foldAll = function(startRow, endRow, depth) {\n\t        if (depth == undefined)\n\t            depth = 100000; // JSON.stringify doesn't hanle Infinity\n\t        var foldWidgets = this.foldWidgets;\n\t        if (!foldWidgets)\n\t            return; // mode doesn't support folding\n\t        endRow = endRow || this.getLength();\n\t        startRow = startRow || 0;\n\t        for (var row = startRow; row < endRow; row++) {\n\t            if (foldWidgets[row] == null)\n\t                foldWidgets[row] = this.getFoldWidget(row);\n\t            if (foldWidgets[row] != \"start\")\n\t                continue;\n\n\t            var range = this.getFoldWidgetRange(row);\n\t            if (range && range.isMultiLine()\n\t                && range.end.row <= endRow\n\t                && range.start.row >= startRow\n\t            ) {\n\t                row = range.end.row;\n\t                try {\n\t                    var fold = this.addFold(\"...\", range);\n\t                    if (fold)\n\t                        fold.collapseChildren = depth;\n\t                } catch(e) {}\n\t            }\n\t        }\n\t    };\n\t    this.$foldStyles = {\n\t        \"manual\": 1,\n\t        \"markbegin\": 1,\n\t        \"markbeginend\": 1\n\t    };\n\t    this.$foldStyle = \"markbegin\";\n\t    this.setFoldStyle = function(style) {\n\t        if (!this.$foldStyles[style])\n\t            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\n\t        \n\t        if (this.$foldStyle == style)\n\t            return;\n\n\t        this.$foldStyle = style;\n\t        \n\t        if (style == \"manual\")\n\t            this.unfold();\n\t        var mode = this.$foldMode;\n\t        this.$setFolding(null);\n\t        this.$setFolding(mode);\n\t    };\n\n\t    this.$setFolding = function(foldMode) {\n\t        if (this.$foldMode == foldMode)\n\t            return;\n\t            \n\t        this.$foldMode = foldMode;\n\t        \n\t        this.removeListener('change', this.$updateFoldWidgets);\n\t        this._emit(\"changeAnnotation\");\n\t        \n\t        if (!foldMode || this.$foldStyle == \"manual\") {\n\t            this.foldWidgets = null;\n\t            return;\n\t        }\n\t        \n\t        this.foldWidgets = [];\n\t        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\n\t        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\n\t        \n\t        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\n\t        this.on('change', this.$updateFoldWidgets);\n\t        \n\t    };\n\n\t    this.getParentFoldRangeData = function (row, ignoreCurrent) {\n\t        var fw = this.foldWidgets;\n\t        if (!fw || (ignoreCurrent && fw[row]))\n\t            return {};\n\n\t        var i = row - 1, firstRange;\n\t        while (i >= 0) {\n\t            var c = fw[i];\n\t            if (c == null)\n\t                c = fw[i] = this.getFoldWidget(i);\n\n\t            if (c == \"start\") {\n\t                var range = this.getFoldWidgetRange(i);\n\t                if (!firstRange)\n\t                    firstRange = range;\n\t                if (range && range.end.row >= row)\n\t                    break;\n\t            }\n\t            i--;\n\t        }\n\n\t        return {\n\t            range: i !== -1 && range,\n\t            firstRange: firstRange\n\t        };\n\t    }\n\n\t    this.onFoldWidgetClick = function(row, e) {\n\t        e = e.domEvent;\n\t        var options = {\n\t            children: e.shiftKey,\n\t            all: e.ctrlKey || e.metaKey,\n\t            siblings: e.altKey\n\t        };\n\t        \n\t        var range = this.$toggleFoldWidget(row, options);\n\t        if (!range) {\n\t            var el = (e.target || e.srcElement)\n\t            if (el && /ace_fold-widget/.test(el.className))\n\t                el.className += \" ace_invalid\";\n\t        }\n\t    };\n\t    \n\t    this.$toggleFoldWidget = function(row, options) {\n\t        if (!this.getFoldWidget)\n\t            return;\n\t        var type = this.getFoldWidget(row);\n\t        var line = this.getLine(row);\n\n\t        var dir = type === \"end\" ? -1 : 1;\n\t        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\n\n\t        if (fold) {\n\t            if (options.children || options.all)\n\t                this.removeFold(fold);\n\t            else\n\t                this.expandFold(fold);\n\t            return;\n\t        }\n\n\t        var range = this.getFoldWidgetRange(row, true);\n\t        if (range && !range.isMultiLine()) {\n\t            fold = this.getFoldAt(range.start.row, range.start.column, 1);\n\t            if (fold && range.isEqual(fold.range)) {\n\t                this.removeFold(fold);\n\t                return;\n\t            }\n\t        }\n\t        \n\t        if (options.siblings) {\n\t            var data = this.getParentFoldRangeData(row);\n\t            if (data.range) {\n\t                var startRow = data.range.start.row + 1;\n\t                var endRow = data.range.end.row;\n\t            }\n\t            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\n\t        } else if (options.children) {\n\t            endRow = range ? range.end.row : this.getLength();\n\t            this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);\n\t        } else if (range) {\n\t            if (options.all) \n\t                range.collapseChildren = 10000;\n\t            this.addFold(\"...\", range);\n\t        }\n\t        \n\t        return range;\n\t    };\n\t    \n\t    \n\t    \n\t    this.toggleFoldWidget = function(toggleParent) {\n\t        var row = this.selection.getCursor().row;\n\t        row = this.getRowFoldStart(row);\n\t        var range = this.$toggleFoldWidget(row, {});\n\t        \n\t        if (range)\n\t            return;\n\t        var data = this.getParentFoldRangeData(row, true);\n\t        range = data.range || data.firstRange;\n\t        \n\t        if (range) {\n\t            row = range.start.row;\n\t            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\n\n\t            if (fold) {\n\t                this.removeFold(fold);\n\t            } else {\n\t                this.addFold(\"...\", range);\n\t            }\n\t        }\n\t    };\n\n\t    this.updateFoldWidgets = function(e) {\n\t        var delta = e.data;\n\t        var range = delta.range;\n\t        var firstRow = range.start.row;\n\t        var len = range.end.row - firstRow;\n\n\t        if (len === 0) {\n\t            this.foldWidgets[firstRow] = null;\n\t        } else if (delta.action == \"removeText\" || delta.action == \"removeLines\") {\n\t            this.foldWidgets.splice(firstRow, len + 1, null);\n\t        } else {\n\t            var args = Array(len + 1);\n\t            args.unshift(firstRow, 1);\n\t            this.foldWidgets.splice.apply(this.foldWidgets, args);\n\t        }\n\t    };\n\n\t}\n\n\texports.Folding = Folding;\n\n\t});\n\n\tace.define(\"ace/edit_session/bracket_match\",[\"require\",\"exports\",\"module\",\"ace/token_iterator\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar TokenIterator = acequire(\"../token_iterator\").TokenIterator;\n\tvar Range = acequire(\"../range\").Range;\n\n\n\tfunction BracketMatch() {\n\n\t    this.findMatchingBracket = function(position, chr) {\n\t        if (position.column == 0) return null;\n\n\t        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);\n\t        if (charBeforeCursor == \"\") return null;\n\n\t        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n\t        if (!match)\n\t            return null;\n\n\t        if (match[1])\n\t            return this.$findClosingBracket(match[1], position);\n\t        else\n\t            return this.$findOpeningBracket(match[2], position);\n\t    };\n\t    \n\t    this.getBracketRange = function(pos) {\n\t        var line = this.getLine(pos.row);\n\t        var before = true, range;\n\n\t        var chr = line.charAt(pos.column-1);\n\t        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n\t        if (!match) {\n\t            chr = line.charAt(pos.column);\n\t            pos = {row: pos.row, column: pos.column + 1};\n\t            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\n\t            before = false;\n\t        }\n\t        if (!match)\n\t            return null;\n\n\t        if (match[1]) {\n\t            var bracketPos = this.$findClosingBracket(match[1], pos);\n\t            if (!bracketPos)\n\t                return null;\n\t            range = Range.fromPoints(pos, bracketPos);\n\t            if (!before) {\n\t                range.end.column++;\n\t                range.start.column--;\n\t            }\n\t            range.cursor = range.end;\n\t        } else {\n\t            var bracketPos = this.$findOpeningBracket(match[2], pos);\n\t            if (!bracketPos)\n\t                return null;\n\t            range = Range.fromPoints(bracketPos, pos);\n\t            if (!before) {\n\t                range.start.column++;\n\t                range.end.column--;\n\t            }\n\t            range.cursor = range.start;\n\t        }\n\t        \n\t        return range;\n\t    };\n\n\t    this.$brackets = {\n\t        \")\": \"(\",\n\t        \"(\": \")\",\n\t        \"]\": \"[\",\n\t        \"[\": \"]\",\n\t        \"{\": \"}\",\n\t        \"}\": \"{\"\n\t    };\n\n\t    this.$findOpeningBracket = function(bracket, position, typeRe) {\n\t        var openBracket = this.$brackets[bracket];\n\t        var depth = 1;\n\n\t        var iterator = new TokenIterator(this, position.row, position.column);\n\t        var token = iterator.getCurrentToken();\n\t        if (!token)\n\t            token = iterator.stepForward();\n\t        if (!token)\n\t            return;\n\t        \n\t         if (!typeRe){\n\t            typeRe = new RegExp(\n\t                \"(\\\\.?\" +\n\t                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\n\t                    .replace(/\\b(?:end|start|begin)\\b/, \"\")\n\t                + \")+\"\n\t            );\n\t        }\n\t        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\n\t        var value = token.value;\n\t        \n\t        while (true) {\n\t        \n\t            while (valueIndex >= 0) {\n\t                var chr = value.charAt(valueIndex);\n\t                if (chr == openBracket) {\n\t                    depth -= 1;\n\t                    if (depth == 0) {\n\t                        return {row: iterator.getCurrentTokenRow(),\n\t                            column: valueIndex + iterator.getCurrentTokenColumn()};\n\t                    }\n\t                }\n\t                else if (chr == bracket) {\n\t                    depth += 1;\n\t                }\n\t                valueIndex -= 1;\n\t            }\n\t            do {\n\t                token = iterator.stepBackward();\n\t            } while (token && !typeRe.test(token.type));\n\n\t            if (token == null)\n\t                break;\n\t                \n\t            value = token.value;\n\t            valueIndex = value.length - 1;\n\t        }\n\t        \n\t        return null;\n\t    };\n\n\t    this.$findClosingBracket = function(bracket, position, typeRe) {\n\t        var closingBracket = this.$brackets[bracket];\n\t        var depth = 1;\n\n\t        var iterator = new TokenIterator(this, position.row, position.column);\n\t        var token = iterator.getCurrentToken();\n\t        if (!token)\n\t            token = iterator.stepForward();\n\t        if (!token)\n\t            return;\n\n\t        if (!typeRe){\n\t            typeRe = new RegExp(\n\t                \"(\\\\.?\" +\n\t                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\n\t                    .replace(/\\b(?:end|start|begin)\\b/, \"\")\n\t                + \")+\"\n\t            );\n\t        }\n\t        var valueIndex = position.column - iterator.getCurrentTokenColumn();\n\n\t        while (true) {\n\n\t            var value = token.value;\n\t            var valueLength = value.length;\n\t            while (valueIndex < valueLength) {\n\t                var chr = value.charAt(valueIndex);\n\t                if (chr == closingBracket) {\n\t                    depth -= 1;\n\t                    if (depth == 0) {\n\t                        return {row: iterator.getCurrentTokenRow(),\n\t                            column: valueIndex + iterator.getCurrentTokenColumn()};\n\t                    }\n\t                }\n\t                else if (chr == bracket) {\n\t                    depth += 1;\n\t                }\n\t                valueIndex += 1;\n\t            }\n\t            do {\n\t                token = iterator.stepForward();\n\t            } while (token && !typeRe.test(token.type));\n\n\t            if (token == null)\n\t                break;\n\n\t            valueIndex = 0;\n\t        }\n\t        \n\t        return null;\n\t    };\n\t}\n\texports.BracketMatch = BracketMatch;\n\n\t});\n\n\tace.define(\"ace/edit_session\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/config\",\"ace/lib/event_emitter\",\"ace/selection\",\"ace/mode/text\",\"ace/range\",\"ace/document\",\"ace/background_tokenizer\",\"ace/search_highlight\",\"ace/edit_session/folding\",\"ace/edit_session/bracket_match\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar lang = acequire(\"./lib/lang\");\n\tvar config = acequire(\"./config\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar Selection = acequire(\"./selection\").Selection;\n\tvar TextMode = acequire(\"./mode/text\").Mode;\n\tvar Range = acequire(\"./range\").Range;\n\tvar Document = acequire(\"./document\").Document;\n\tvar BackgroundTokenizer = acequire(\"./background_tokenizer\").BackgroundTokenizer;\n\tvar SearchHighlight = acequire(\"./search_highlight\").SearchHighlight;\n\n\tvar EditSession = function(text, mode) {\n\t    this.$breakpoints = [];\n\t    this.$decorations = [];\n\t    this.$frontMarkers = {};\n\t    this.$backMarkers = {};\n\t    this.$markerId = 1;\n\t    this.$undoSelect = true;\n\n\t    this.$foldData = [];\n\t    this.$foldData.toString = function() {\n\t        return this.join(\"\\n\");\n\t    }\n\t    this.on(\"changeFold\", this.onChangeFold.bind(this));\n\t    this.$onChange = this.onChange.bind(this);\n\n\t    if (typeof text != \"object\" || !text.getLine)\n\t        text = new Document(text);\n\n\t    this.setDocument(text);\n\t    this.selection = new Selection(this);\n\n\t    config.resetOptions(this);\n\t    this.setMode(mode);\n\t    config._signal(\"session\", this);\n\t};\n\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\t    this.setDocument = function(doc) {\n\t        if (this.doc)\n\t            this.doc.removeListener(\"change\", this.$onChange);\n\n\t        this.doc = doc;\n\t        doc.on(\"change\", this.$onChange);\n\n\t        if (this.bgTokenizer)\n\t            this.bgTokenizer.setDocument(this.getDocument());\n\n\t        this.resetCaches();\n\t    };\n\t    this.getDocument = function() {\n\t        return this.doc;\n\t    };\n\t    this.$resetRowCache = function(docRow) {\n\t        if (!docRow) {\n\t            this.$docRowCache = [];\n\t            this.$screenRowCache = [];\n\t            return;\n\t        }\n\t        var l = this.$docRowCache.length;\n\t        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;\n\t        if (l > i) {\n\t            this.$docRowCache.splice(i, l);\n\t            this.$screenRowCache.splice(i, l);\n\t        }\n\t    };\n\n\t    this.$getRowCacheIndex = function(cacheArray, val) {\n\t        var low = 0;\n\t        var hi = cacheArray.length - 1;\n\n\t        while (low <= hi) {\n\t            var mid = (low + hi) >> 1;\n\t            var c = cacheArray[mid];\n\n\t            if (val > c)\n\t                low = mid + 1;\n\t            else if (val < c)\n\t                hi = mid - 1;\n\t            else\n\t                return mid;\n\t        }\n\n\t        return low -1;\n\t    };\n\n\t    this.resetCaches = function() {\n\t        this.$modified = true;\n\t        this.$wrapData = [];\n\t        this.$rowLengthCache = [];\n\t        this.$resetRowCache(0);\n\t        if (this.bgTokenizer)\n\t            this.bgTokenizer.start(0);\n\t    };\n\n\t    this.onChangeFold = function(e) {\n\t        var fold = e.data;\n\t        this.$resetRowCache(fold.start.row);\n\t    };\n\n\t    this.onChange = function(e) {\n\t        var delta = e.data;\n\t        this.$modified = true;\n\n\t        this.$resetRowCache(delta.range.start.row);\n\n\t        var removedFolds = this.$updateInternalDataOnChange(e);\n\t        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {\n\t            this.$deltasDoc.push(delta);\n\t            if (removedFolds && removedFolds.length != 0) {\n\t                this.$deltasFold.push({\n\t                    action: \"removeFolds\",\n\t                    folds:  removedFolds\n\t                });\n\t            }\n\n\t            this.$informUndoManager.schedule();\n\t        }\n\n\t        this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);\n\t        this._signal(\"change\", e);\n\t    };\n\t    this.setValue = function(text) {\n\t        this.doc.setValue(text);\n\t        this.selection.moveTo(0, 0);\n\n\t        this.$resetRowCache(0);\n\t        this.$deltas = [];\n\t        this.$deltasDoc = [];\n\t        this.$deltasFold = [];\n\t        this.setUndoManager(this.$undoManager);\n\t        this.getUndoManager().reset();\n\t    };\n\t    this.getValue =\n\t    this.toString = function() {\n\t        return this.doc.getValue();\n\t    };\n\t    this.getSelection = function() {\n\t        return this.selection;\n\t    };\n\t    this.getState = function(row) {\n\t        return this.bgTokenizer.getState(row);\n\t    };\n\t    this.getTokens = function(row) {\n\t        return this.bgTokenizer.getTokens(row);\n\t    };\n\t    this.getTokenAt = function(row, column) {\n\t        var tokens = this.bgTokenizer.getTokens(row);\n\t        var token, c = 0;\n\t        if (column == null) {\n\t            i = tokens.length - 1;\n\t            c = this.getLine(row).length;\n\t        } else {\n\t            for (var i = 0; i < tokens.length; i++) {\n\t                c += tokens[i].value.length;\n\t                if (c >= column)\n\t                    break;\n\t            }\n\t        }\n\t        token = tokens[i];\n\t        if (!token)\n\t            return null;\n\t        token.index = i;\n\t        token.start = c - token.value.length;\n\t        return token;\n\t    };\n\t    this.setUndoManager = function(undoManager) {\n\t        this.$undoManager = undoManager;\n\t        this.$deltas = [];\n\t        this.$deltasDoc = [];\n\t        this.$deltasFold = [];\n\n\t        if (this.$informUndoManager)\n\t            this.$informUndoManager.cancel();\n\n\t        if (undoManager) {\n\t            var self = this;\n\n\t            this.$syncInformUndoManager = function() {\n\t                self.$informUndoManager.cancel();\n\n\t                if (self.$deltasFold.length) {\n\t                    self.$deltas.push({\n\t                        group: \"fold\",\n\t                        deltas: self.$deltasFold\n\t                    });\n\t                    self.$deltasFold = [];\n\t                }\n\n\t                if (self.$deltasDoc.length) {\n\t                    self.$deltas.push({\n\t                        group: \"doc\",\n\t                        deltas: self.$deltasDoc\n\t                    });\n\t                    self.$deltasDoc = [];\n\t                }\n\n\t                if (self.$deltas.length > 0) {\n\t                    undoManager.execute({\n\t                        action: \"aceupdate\",\n\t                        args: [self.$deltas, self],\n\t                        merge: self.mergeUndoDeltas\n\t                    });\n\t                }\n\t                self.mergeUndoDeltas = false;\n\t                self.$deltas = [];\n\t            };\n\t            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);\n\t        }\n\t    };\n\t    this.markUndoGroup = function() {\n\t        if (this.$syncInformUndoManager)\n\t            this.$syncInformUndoManager();\n\t    };\n\t    \n\t    this.$defaultUndoManager = {\n\t        undo: function() {},\n\t        redo: function() {},\n\t        reset: function() {}\n\t    };\n\t    this.getUndoManager = function() {\n\t        return this.$undoManager || this.$defaultUndoManager;\n\t    };\n\t    this.getTabString = function() {\n\t        if (this.getUseSoftTabs()) {\n\t            return lang.stringRepeat(\" \", this.getTabSize());\n\t        } else {\n\t            return \"\\t\";\n\t        }\n\t    };\n\t    this.setUseSoftTabs = function(val) {\n\t        this.setOption(\"useSoftTabs\", val);\n\t    };\n\t    this.getUseSoftTabs = function() {\n\t        return this.$useSoftTabs && !this.$mode.$indentWithTabs;\n\t    };\n\t    this.setTabSize = function(tabSize) {\n\t        this.setOption(\"tabSize\", tabSize);\n\t    };\n\t    this.getTabSize = function() {\n\t        return this.$tabSize;\n\t    };\n\t    this.isTabStop = function(position) {\n\t        return this.$useSoftTabs && (position.column % this.$tabSize === 0);\n\t    };\n\n\t    this.$overwrite = false;\n\t    this.setOverwrite = function(overwrite) {\n\t        this.setOption(\"overwrite\", overwrite);\n\t    };\n\t    this.getOverwrite = function() {\n\t        return this.$overwrite;\n\t    };\n\t    this.toggleOverwrite = function() {\n\t        this.setOverwrite(!this.$overwrite);\n\t    };\n\t    this.addGutterDecoration = function(row, className) {\n\t        if (!this.$decorations[row])\n\t            this.$decorations[row] = \"\";\n\t        this.$decorations[row] += \" \" + className;\n\t        this._signal(\"changeBreakpoint\", {});\n\t    };\n\t    this.removeGutterDecoration = function(row, className) {\n\t        this.$decorations[row] = (this.$decorations[row] || \"\").replace(\" \" + className, \"\");\n\t        this._signal(\"changeBreakpoint\", {});\n\t    };\n\t    this.getBreakpoints = function() {\n\t        return this.$breakpoints;\n\t    };\n\t    this.setBreakpoints = function(rows) {\n\t        this.$breakpoints = [];\n\t        for (var i=0; i<rows.length; i++) {\n\t            this.$breakpoints[rows[i]] = \"ace_breakpoint\";\n\t        }\n\t        this._signal(\"changeBreakpoint\", {});\n\t    };\n\t    this.clearBreakpoints = function() {\n\t        this.$breakpoints = [];\n\t        this._signal(\"changeBreakpoint\", {});\n\t    };\n\t    this.setBreakpoint = function(row, className) {\n\t        if (className === undefined)\n\t            className = \"ace_breakpoint\";\n\t        if (className)\n\t            this.$breakpoints[row] = className;\n\t        else\n\t            delete this.$breakpoints[row];\n\t        this._signal(\"changeBreakpoint\", {});\n\t    };\n\t    this.clearBreakpoint = function(row) {\n\t        delete this.$breakpoints[row];\n\t        this._signal(\"changeBreakpoint\", {});\n\t    };\n\t    this.addMarker = function(range, clazz, type, inFront) {\n\t        var id = this.$markerId++;\n\n\t        var marker = {\n\t            range : range,\n\t            type : type || \"line\",\n\t            renderer: typeof type == \"function\" ? type : null,\n\t            clazz : clazz,\n\t            inFront: !!inFront,\n\t            id: id\n\t        };\n\n\t        if (inFront) {\n\t            this.$frontMarkers[id] = marker;\n\t            this._signal(\"changeFrontMarker\");\n\t        } else {\n\t            this.$backMarkers[id] = marker;\n\t            this._signal(\"changeBackMarker\");\n\t        }\n\n\t        return id;\n\t    };\n\t    this.addDynamicMarker = function(marker, inFront) {\n\t        if (!marker.update)\n\t            return;\n\t        var id = this.$markerId++;\n\t        marker.id = id;\n\t        marker.inFront = !!inFront;\n\n\t        if (inFront) {\n\t            this.$frontMarkers[id] = marker;\n\t            this._signal(\"changeFrontMarker\");\n\t        } else {\n\t            this.$backMarkers[id] = marker;\n\t            this._signal(\"changeBackMarker\");\n\t        }\n\n\t        return marker;\n\t    };\n\t    this.removeMarker = function(markerId) {\n\t        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];\n\t        if (!marker)\n\t            return;\n\n\t        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;\n\t        if (marker) {\n\t            delete (markers[markerId]);\n\t            this._signal(marker.inFront ? \"changeFrontMarker\" : \"changeBackMarker\");\n\t        }\n\t    };\n\t    this.getMarkers = function(inFront) {\n\t        return inFront ? this.$frontMarkers : this.$backMarkers;\n\t    };\n\n\t    this.highlight = function(re) {\n\t        if (!this.$searchHighlight) {\n\t            var highlight = new SearchHighlight(null, \"ace_selected-word\", \"text\");\n\t            this.$searchHighlight = this.addDynamicMarker(highlight);\n\t        }\n\t        this.$searchHighlight.setRegexp(re);\n\t    };\n\t    this.highlightLines = function(startRow, endRow, clazz, inFront) {\n\t        if (typeof endRow != \"number\") {\n\t            clazz = endRow;\n\t            endRow = startRow;\n\t        }\n\t        if (!clazz)\n\t            clazz = \"ace_step\";\n\n\t        var range = new Range(startRow, 0, endRow, Infinity);\n\t        range.id = this.addMarker(range, clazz, \"fullLine\", inFront);\n\t        return range;\n\t    };\n\t    this.setAnnotations = function(annotations) {\n\t        this.$annotations = annotations;\n\t        this._signal(\"changeAnnotation\", {});\n\t    };\n\t    this.getAnnotations = function() {\n\t        return this.$annotations || [];\n\t    };\n\t    this.clearAnnotations = function() {\n\t        this.setAnnotations([]);\n\t    };\n\t    this.$detectNewLine = function(text) {\n\t        var match = text.match(/^.*?(\\r?\\n)/m);\n\t        if (match) {\n\t            this.$autoNewLine = match[1];\n\t        } else {\n\t            this.$autoNewLine = \"\\n\";\n\t        }\n\t    };\n\t    this.getWordRange = function(row, column) {\n\t        var line = this.getLine(row);\n\n\t        var inToken = false;\n\t        if (column > 0)\n\t            inToken = !!line.charAt(column - 1).match(this.tokenRe);\n\n\t        if (!inToken)\n\t            inToken = !!line.charAt(column).match(this.tokenRe);\n\n\t        if (inToken)\n\t            var re = this.tokenRe;\n\t        else if (/^\\s+$/.test(line.slice(column-1, column+1)))\n\t            var re = /\\s/;\n\t        else\n\t            var re = this.nonTokenRe;\n\n\t        var start = column;\n\t        if (start > 0) {\n\t            do {\n\t                start--;\n\t            }\n\t            while (start >= 0 && line.charAt(start).match(re));\n\t            start++;\n\t        }\n\n\t        var end = column;\n\t        while (end < line.length && line.charAt(end).match(re)) {\n\t            end++;\n\t        }\n\n\t        return new Range(row, start, row, end);\n\t    };\n\t    this.getAWordRange = function(row, column) {\n\t        var wordRange = this.getWordRange(row, column);\n\t        var line = this.getLine(wordRange.end.row);\n\n\t        while (line.charAt(wordRange.end.column).match(/[ \\t]/)) {\n\t            wordRange.end.column += 1;\n\t        }\n\t        return wordRange;\n\t    };\n\t    this.setNewLineMode = function(newLineMode) {\n\t        this.doc.setNewLineMode(newLineMode);\n\t    };\n\t    this.getNewLineMode = function() {\n\t        return this.doc.getNewLineMode();\n\t    };\n\t    this.setUseWorker = function(useWorker) { this.setOption(\"useWorker\", useWorker); };\n\t    this.getUseWorker = function() { return this.$useWorker; };\n\t    this.onReloadTokenizer = function(e) {\n\t        var rows = e.data;\n\t        this.bgTokenizer.start(rows.first);\n\t        this._signal(\"tokenizerUpdate\", e);\n\t    };\n\n\t    this.$modes = {};\n\t    this.$mode = null;\n\t    this.$modeId = null;\n\t    this.setMode = function(mode, cb) {\n\t        if (mode && typeof mode === \"object\") {\n\t            if (mode.getTokenizer)\n\t                return this.$onChangeMode(mode);\n\t            var options = mode;\n\t            var path = options.path;\n\t        } else {\n\t            path = mode || \"ace/mode/text\";\n\t        }\n\t        if (!this.$modes[\"ace/mode/text\"])\n\t            this.$modes[\"ace/mode/text\"] = new TextMode();\n\n\t        if (this.$modes[path] && !options) {\n\t            this.$onChangeMode(this.$modes[path]);\n\t            cb && cb();\n\t            return;\n\t        }\n\t        this.$modeId = path;\n\t        config.loadModule([\"mode\", path], function(m) {\n\t            if (this.$modeId !== path)\n\t                return cb && cb();\n\t            if (this.$modes[path] && !options)\n\t                return this.$onChangeMode(this.$modes[path]);\n\t            if (m && m.Mode) {\n\t                m = new m.Mode(options);\n\t                if (!options) {\n\t                    this.$modes[path] = m;\n\t                    m.$id = path;\n\t                }\n\t                this.$onChangeMode(m);\n\t                cb && cb();\n\t            }\n\t        }.bind(this));\n\t        if (!this.$mode)\n\t            this.$onChangeMode(this.$modes[\"ace/mode/text\"], true);\n\t    };\n\n\t    this.$onChangeMode = function(mode, $isPlaceholder) {\n\t        if (!$isPlaceholder)\n\t            this.$modeId = mode.$id;\n\t        if (this.$mode === mode) \n\t            return;\n\n\t        this.$mode = mode;\n\n\t        this.$stopWorker();\n\n\t        if (this.$useWorker)\n\t            this.$startWorker();\n\n\t        var tokenizer = mode.getTokenizer();\n\n\t        if(tokenizer.addEventListener !== undefined) {\n\t            var onReloadTokenizer = this.onReloadTokenizer.bind(this);\n\t            tokenizer.addEventListener(\"update\", onReloadTokenizer);\n\t        }\n\n\t        if (!this.bgTokenizer) {\n\t            this.bgTokenizer = new BackgroundTokenizer(tokenizer);\n\t            var _self = this;\n\t            this.bgTokenizer.addEventListener(\"update\", function(e) {\n\t                _self._signal(\"tokenizerUpdate\", e);\n\t            });\n\t        } else {\n\t            this.bgTokenizer.setTokenizer(tokenizer);\n\t        }\n\n\t        this.bgTokenizer.setDocument(this.getDocument());\n\n\t        this.tokenRe = mode.tokenRe;\n\t        this.nonTokenRe = mode.nonTokenRe;\n\n\t        \n\t        if (!$isPlaceholder) {\n\t            if (mode.attachToSession)\n\t                mode.attachToSession(this);\n\t            this.$options.wrapMethod.set.call(this, this.$wrapMethod);\n\t            this.$setFolding(mode.foldingRules);\n\t            this.bgTokenizer.start(0);\n\t            this._emit(\"changeMode\");\n\t        }\n\t    };\n\n\t    this.$stopWorker = function() {\n\t        if (this.$worker) {\n\t            this.$worker.terminate();\n\t            this.$worker = null;\n\t        }\n\t    };\n\n\t    this.$startWorker = function() {\n\t        try {\n\t            this.$worker = this.$mode.createWorker(this);\n\t        } catch (e) {\n\t            if (typeof console == \"object\") {\n\t                console.log(\"Could not load worker\");\n\t                console.log(e);\n\t            }    \n\t            this.$worker = null;\n\t        }\n\t    };\n\t    this.getMode = function() {\n\t        return this.$mode;\n\t    };\n\n\t    this.$scrollTop = 0;\n\t    this.setScrollTop = function(scrollTop) {\n\t        if (this.$scrollTop === scrollTop || isNaN(scrollTop))\n\t            return;\n\n\t        this.$scrollTop = scrollTop;\n\t        this._signal(\"changeScrollTop\", scrollTop);\n\t    };\n\t    this.getScrollTop = function() {\n\t        return this.$scrollTop;\n\t    };\n\n\t    this.$scrollLeft = 0;\n\t    this.setScrollLeft = function(scrollLeft) {\n\t        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))\n\t            return;\n\n\t        this.$scrollLeft = scrollLeft;\n\t        this._signal(\"changeScrollLeft\", scrollLeft);\n\t    };\n\t    this.getScrollLeft = function() {\n\t        return this.$scrollLeft;\n\t    };\n\t    this.getScreenWidth = function() {\n\t        this.$computeWidth();\n\t        if (this.lineWidgets) \n\t            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);\n\t        return this.screenWidth;\n\t    };\n\t    \n\t    this.getLineWidgetMaxWidth = function() {\n\t        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;\n\t        var width = 0;\n\t        this.lineWidgets.forEach(function(w) {\n\t            if (w && w.screenWidth > width)\n\t                width = w.screenWidth;\n\t        });\n\t        return this.lineWidgetWidth = width;\n\t    };\n\n\t    this.$computeWidth = function(force) {\n\t        if (this.$modified || force) {\n\t            this.$modified = false;\n\n\t            if (this.$useWrapMode)\n\t                return this.screenWidth = this.$wrapLimit;\n\n\t            var lines = this.doc.getAllLines();\n\t            var cache = this.$rowLengthCache;\n\t            var longestScreenLine = 0;\n\t            var foldIndex = 0;\n\t            var foldLine = this.$foldData[foldIndex];\n\t            var foldStart = foldLine ? foldLine.start.row : Infinity;\n\t            var len = lines.length;\n\n\t            for (var i = 0; i < len; i++) {\n\t                if (i > foldStart) {\n\t                    i = foldLine.end.row + 1;\n\t                    if (i >= len)\n\t                        break;\n\t                    foldLine = this.$foldData[foldIndex++];\n\t                    foldStart = foldLine ? foldLine.start.row : Infinity;\n\t                }\n\n\t                if (cache[i] == null)\n\t                    cache[i] = this.$getStringScreenWidth(lines[i])[0];\n\n\t                if (cache[i] > longestScreenLine)\n\t                    longestScreenLine = cache[i];\n\t            }\n\t            this.screenWidth = longestScreenLine;\n\t        }\n\t    };\n\t    this.getLine = function(row) {\n\t        return this.doc.getLine(row);\n\t    };\n\t    this.getLines = function(firstRow, lastRow) {\n\t        return this.doc.getLines(firstRow, lastRow);\n\t    };\n\t    this.getLength = function() {\n\t        return this.doc.getLength();\n\t    };\n\t    this.getTextRange = function(range) {\n\t        return this.doc.getTextRange(range || this.selection.getRange());\n\t    };\n\t    this.insert = function(position, text) {\n\t        return this.doc.insert(position, text);\n\t    };\n\t    this.remove = function(range) {\n\t        return this.doc.remove(range);\n\t    };\n\t    this.undoChanges = function(deltas, dontSelect) {\n\t        if (!deltas.length)\n\t            return;\n\n\t        this.$fromUndo = true;\n\t        var lastUndoRange = null;\n\t        for (var i = deltas.length - 1; i != -1; i--) {\n\t            var delta = deltas[i];\n\t            if (delta.group == \"doc\") {\n\t                this.doc.revertDeltas(delta.deltas);\n\t                lastUndoRange =\n\t                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);\n\t            } else {\n\t                delta.deltas.forEach(function(foldDelta) {\n\t                    this.addFolds(foldDelta.folds);\n\t                }, this);\n\t            }\n\t        }\n\t        this.$fromUndo = false;\n\t        lastUndoRange &&\n\t            this.$undoSelect &&\n\t            !dontSelect &&\n\t            this.selection.setSelectionRange(lastUndoRange);\n\t        return lastUndoRange;\n\t    };\n\t    this.redoChanges = function(deltas, dontSelect) {\n\t        if (!deltas.length)\n\t            return;\n\n\t        this.$fromUndo = true;\n\t        var lastUndoRange = null;\n\t        for (var i = 0; i < deltas.length; i++) {\n\t            var delta = deltas[i];\n\t            if (delta.group == \"doc\") {\n\t                this.doc.applyDeltas(delta.deltas);\n\t                lastUndoRange =\n\t                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);\n\t            }\n\t        }\n\t        this.$fromUndo = false;\n\t        lastUndoRange &&\n\t            this.$undoSelect &&\n\t            !dontSelect &&\n\t            this.selection.setSelectionRange(lastUndoRange);\n\t        return lastUndoRange;\n\t    };\n\t    this.setUndoSelect = function(enable) {\n\t        this.$undoSelect = enable;\n\t    };\n\n\t    this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {\n\t        function isInsert(delta) {\n\t            var insert =\n\t                delta.action === \"insertText\" || delta.action === \"insertLines\";\n\t            return isUndo ? !insert : insert;\n\t        }\n\n\t        var delta = deltas[0];\n\t        var range, point;\n\t        var lastDeltaIsInsert = false;\n\t        if (isInsert(delta)) {\n\t            range = Range.fromPoints(delta.range.start, delta.range.end);\n\t            lastDeltaIsInsert = true;\n\t        } else {\n\t            range = Range.fromPoints(delta.range.start, delta.range.start);\n\t            lastDeltaIsInsert = false;\n\t        }\n\n\t        for (var i = 1; i < deltas.length; i++) {\n\t            delta = deltas[i];\n\t            if (isInsert(delta)) {\n\t                point = delta.range.start;\n\t                if (range.compare(point.row, point.column) == -1) {\n\t                    range.setStart(delta.range.start);\n\t                }\n\t                point = delta.range.end;\n\t                if (range.compare(point.row, point.column) == 1) {\n\t                    range.setEnd(delta.range.end);\n\t                }\n\t                lastDeltaIsInsert = true;\n\t            } else {\n\t                point = delta.range.start;\n\t                if (range.compare(point.row, point.column) == -1) {\n\t                    range =\n\t                        Range.fromPoints(delta.range.start, delta.range.start);\n\t                }\n\t                lastDeltaIsInsert = false;\n\t            }\n\t        }\n\t        if (lastUndoRange != null) {\n\t            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {\n\t                lastUndoRange.start.column += range.end.column - range.start.column;\n\t                lastUndoRange.end.column += range.end.column - range.start.column;\n\t            }\n\n\t            var cmp = lastUndoRange.compareRange(range);\n\t            if (cmp == 1) {\n\t                range.setStart(lastUndoRange.start);\n\t            } else if (cmp == -1) {\n\t                range.setEnd(lastUndoRange.end);\n\t            }\n\t        }\n\n\t        return range;\n\t    };\n\t    this.replace = function(range, text) {\n\t        return this.doc.replace(range, text);\n\t    };\n\t    this.moveText = function(fromRange, toPosition, copy) {\n\t        var text = this.getTextRange(fromRange);\n\t        var folds = this.getFoldsInRange(fromRange);\n\n\t        var toRange = Range.fromPoints(toPosition, toPosition);\n\t        if (!copy) {\n\t            this.remove(fromRange);\n\t            var rowDiff = fromRange.start.row - fromRange.end.row;\n\t            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;\n\t            if (collDiff) {\n\t                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)\n\t                    toRange.start.column += collDiff;\n\t                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)\n\t                    toRange.end.column += collDiff;\n\t            }\n\t            if (rowDiff && toRange.start.row >= fromRange.end.row) {\n\t                toRange.start.row += rowDiff;\n\t                toRange.end.row += rowDiff;\n\t            }\n\t        }\n\n\t        toRange.end = this.insert(toRange.start, text);\n\t        if (folds.length) {\n\t            var oldStart = fromRange.start;\n\t            var newStart = toRange.start;\n\t            var rowDiff = newStart.row - oldStart.row;\n\t            var collDiff = newStart.column - oldStart.column;\n\t            this.addFolds(folds.map(function(x) {\n\t                x = x.clone();\n\t                if (x.start.row == oldStart.row)\n\t                    x.start.column += collDiff;\n\t                if (x.end.row == oldStart.row)\n\t                    x.end.column += collDiff;\n\t                x.start.row += rowDiff;\n\t                x.end.row += rowDiff;\n\t                return x;\n\t            }));\n\t        }\n\n\t        return toRange;\n\t    };\n\t    this.indentRows = function(startRow, endRow, indentString) {\n\t        indentString = indentString.replace(/\\t/g, this.getTabString());\n\t        for (var row=startRow; row<=endRow; row++)\n\t            this.insert({row: row, column:0}, indentString);\n\t    };\n\t    this.outdentRows = function (range) {\n\t        var rowRange = range.collapseRows();\n\t        var deleteRange = new Range(0, 0, 0, 0);\n\t        var size = this.getTabSize();\n\n\t        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {\n\t            var line = this.getLine(i);\n\n\t            deleteRange.start.row = i;\n\t            deleteRange.end.row = i;\n\t            for (var j = 0; j < size; ++j)\n\t                if (line.charAt(j) != ' ')\n\t                    break;\n\t            if (j < size && line.charAt(j) == '\\t') {\n\t                deleteRange.start.column = j;\n\t                deleteRange.end.column = j + 1;\n\t            } else {\n\t                deleteRange.start.column = 0;\n\t                deleteRange.end.column = j;\n\t            }\n\t            this.remove(deleteRange);\n\t        }\n\t    };\n\n\t    this.$moveLines = function(firstRow, lastRow, dir) {\n\t        firstRow = this.getRowFoldStart(firstRow);\n\t        lastRow = this.getRowFoldEnd(lastRow);\n\t        if (dir < 0) {\n\t            var row = this.getRowFoldStart(firstRow + dir);\n\t            if (row < 0) return 0;\n\t            var diff = row-firstRow;\n\t        } else if (dir > 0) {\n\t            var row = this.getRowFoldEnd(lastRow + dir);\n\t            if (row > this.doc.getLength()-1) return 0;\n\t            var diff = row-lastRow;\n\t        } else {\n\t            firstRow = this.$clipRowToDocument(firstRow);\n\t            lastRow = this.$clipRowToDocument(lastRow);\n\t            var diff = lastRow - firstRow + 1;\n\t        }\n\n\t        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);\n\t        var folds = this.getFoldsInRange(range).map(function(x){\n\t            x = x.clone();\n\t            x.start.row += diff;\n\t            x.end.row += diff;\n\t            return x;\n\t        });\n\n\t        var lines = dir == 0\n\t            ? this.doc.getLines(firstRow, lastRow)\n\t            : this.doc.removeLines(firstRow, lastRow);\n\t        this.doc.insertLines(firstRow+diff, lines);\n\t        folds.length && this.addFolds(folds);\n\t        return diff;\n\t    };\n\t    this.moveLinesUp = function(firstRow, lastRow) {\n\t        return this.$moveLines(firstRow, lastRow, -1);\n\t    };\n\t    this.moveLinesDown = function(firstRow, lastRow) {\n\t        return this.$moveLines(firstRow, lastRow, 1);\n\t    };\n\t    this.duplicateLines = function(firstRow, lastRow) {\n\t        return this.$moveLines(firstRow, lastRow, 0);\n\t    };\n\n\n\t    this.$clipRowToDocument = function(row) {\n\t        return Math.max(0, Math.min(row, this.doc.getLength()-1));\n\t    };\n\n\t    this.$clipColumnToRow = function(row, column) {\n\t        if (column < 0)\n\t            return 0;\n\t        return Math.min(this.doc.getLine(row).length, column);\n\t    };\n\n\n\t    this.$clipPositionToDocument = function(row, column) {\n\t        column = Math.max(0, column);\n\n\t        if (row < 0) {\n\t            row = 0;\n\t            column = 0;\n\t        } else {\n\t            var len = this.doc.getLength();\n\t            if (row >= len) {\n\t                row = len - 1;\n\t                column = this.doc.getLine(len-1).length;\n\t            } else {\n\t                column = Math.min(this.doc.getLine(row).length, column);\n\t            }\n\t        }\n\n\t        return {\n\t            row: row,\n\t            column: column\n\t        };\n\t    };\n\n\t    this.$clipRangeToDocument = function(range) {\n\t        if (range.start.row < 0) {\n\t            range.start.row = 0;\n\t            range.start.column = 0;\n\t        } else {\n\t            range.start.column = this.$clipColumnToRow(\n\t                range.start.row,\n\t                range.start.column\n\t            );\n\t        }\n\n\t        var len = this.doc.getLength() - 1;\n\t        if (range.end.row > len) {\n\t            range.end.row = len;\n\t            range.end.column = this.doc.getLine(len).length;\n\t        } else {\n\t            range.end.column = this.$clipColumnToRow(\n\t                range.end.row,\n\t                range.end.column\n\t            );\n\t        }\n\t        return range;\n\t    };\n\t    this.$wrapLimit = 80;\n\t    this.$useWrapMode = false;\n\t    this.$wrapLimitRange = {\n\t        min : null,\n\t        max : null\n\t    };\n\t    this.setUseWrapMode = function(useWrapMode) {\n\t        if (useWrapMode != this.$useWrapMode) {\n\t            this.$useWrapMode = useWrapMode;\n\t            this.$modified = true;\n\t            this.$resetRowCache(0);\n\t            if (useWrapMode) {\n\t                var len = this.getLength();\n\t                this.$wrapData = Array(len);\n\t                this.$updateWrapData(0, len - 1);\n\t            }\n\n\t            this._signal(\"changeWrapMode\");\n\t        }\n\t    };\n\t    this.getUseWrapMode = function() {\n\t        return this.$useWrapMode;\n\t    };\n\t    this.setWrapLimitRange = function(min, max) {\n\t        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {\n\t            this.$wrapLimitRange = {\n\t                min: min,\n\t                max: max\n\t            };\n\t            this.$modified = true;\n\t            this._signal(\"changeWrapMode\");\n\t        }\n\t    };\n\t    this.adjustWrapLimit = function(desiredLimit, $printMargin) {\n\t        var limits = this.$wrapLimitRange;\n\t        if (limits.max < 0)\n\t            limits = {min: $printMargin, max: $printMargin};\n\t        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);\n\t        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {\n\t            this.$wrapLimit = wrapLimit;\n\t            this.$modified = true;\n\t            if (this.$useWrapMode) {\n\t                this.$updateWrapData(0, this.getLength() - 1);\n\t                this.$resetRowCache(0);\n\t                this._signal(\"changeWrapLimit\");\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\n\t    this.$constrainWrapLimit = function(wrapLimit, min, max) {\n\t        if (min)\n\t            wrapLimit = Math.max(min, wrapLimit);\n\n\t        if (max)\n\t            wrapLimit = Math.min(max, wrapLimit);\n\n\t        return wrapLimit;\n\t    };\n\t    this.getWrapLimit = function() {\n\t        return this.$wrapLimit;\n\t    };\n\t    this.setWrapLimit = function (limit) {\n\t        this.setWrapLimitRange(limit, limit);\n\t    };\n\t    this.getWrapLimitRange = function() {\n\t        return {\n\t            min : this.$wrapLimitRange.min,\n\t            max : this.$wrapLimitRange.max\n\t        };\n\t    };\n\n\t    this.$updateInternalDataOnChange = function(e) {\n\t        var useWrapMode = this.$useWrapMode;\n\t        var len;\n\t        var action = e.data.action;\n\t        var firstRow = e.data.range.start.row;\n\t        var lastRow = e.data.range.end.row;\n\t        var start = e.data.range.start;\n\t        var end = e.data.range.end;\n\t        var removedFolds = null;\n\n\t        if (action.indexOf(\"Lines\") != -1) {\n\t            if (action == \"insertLines\") {\n\t                lastRow = firstRow + (e.data.lines.length);\n\t            } else {\n\t                lastRow = firstRow;\n\t            }\n\t            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;\n\t        } else {\n\t            len = lastRow - firstRow;\n\t        }\n\n\t        this.$updating = true;\n\t        if (len != 0) {\n\t            if (action.indexOf(\"remove\") != -1) {\n\t                this[useWrapMode ? \"$wrapData\" : \"$rowLengthCache\"].splice(firstRow, len);\n\n\t                var foldLines = this.$foldData;\n\t                removedFolds = this.getFoldsInRange(e.data.range);\n\t                this.removeFolds(removedFolds);\n\n\t                var foldLine = this.getFoldLine(end.row);\n\t                var idx = 0;\n\t                if (foldLine) {\n\t                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);\n\t                    foldLine.shiftRow(-len);\n\n\t                    var foldLineBefore = this.getFoldLine(firstRow);\n\t                    if (foldLineBefore && foldLineBefore !== foldLine) {\n\t                        foldLineBefore.merge(foldLine);\n\t                        foldLine = foldLineBefore;\n\t                    }\n\t                    idx = foldLines.indexOf(foldLine) + 1;\n\t                }\n\n\t                for (idx; idx < foldLines.length; idx++) {\n\t                    var foldLine = foldLines[idx];\n\t                    if (foldLine.start.row >= end.row) {\n\t                        foldLine.shiftRow(-len);\n\t                    }\n\t                }\n\n\t                lastRow = firstRow;\n\t            } else {\n\t                var args = Array(len);\n\t                args.unshift(firstRow, 0);\n\t                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache\n\t                arr.splice.apply(arr, args);\n\t                var foldLines = this.$foldData;\n\t                var foldLine = this.getFoldLine(firstRow);\n\t                var idx = 0;\n\t                if (foldLine) {\n\t                    var cmp = foldLine.range.compareInside(start.row, start.column);\n\t                    if (cmp == 0) {\n\t                        foldLine = foldLine.split(start.row, start.column);\n\t                        if (foldLine) {\n\t                            foldLine.shiftRow(len);\n\t                            foldLine.addRemoveChars(lastRow, 0, end.column - start.column);\n\t                        }\n\t                    } else\n\t                    if (cmp == -1) {\n\t                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);\n\t                        foldLine.shiftRow(len);\n\t                    }\n\t                    idx = foldLines.indexOf(foldLine) + 1;\n\t                }\n\n\t                for (idx; idx < foldLines.length; idx++) {\n\t                    var foldLine = foldLines[idx];\n\t                    if (foldLine.start.row >= firstRow) {\n\t                        foldLine.shiftRow(len);\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            len = Math.abs(e.data.range.start.column - e.data.range.end.column);\n\t            if (action.indexOf(\"remove\") != -1) {\n\t                removedFolds = this.getFoldsInRange(e.data.range);\n\t                this.removeFolds(removedFolds);\n\n\t                len = -len;\n\t            }\n\t            var foldLine = this.getFoldLine(firstRow);\n\t            if (foldLine) {\n\t                foldLine.addRemoveChars(firstRow, start.column, len);\n\t            }\n\t        }\n\n\t        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {\n\t            console.error(\"doc.getLength() and $wrapData.length have to be the same!\");\n\t        }\n\t        this.$updating = false;\n\n\t        if (useWrapMode)\n\t            this.$updateWrapData(firstRow, lastRow);\n\t        else\n\t            this.$updateRowLengthCache(firstRow, lastRow);\n\n\t        return removedFolds;\n\t    };\n\n\t    this.$updateRowLengthCache = function(firstRow, lastRow, b) {\n\t        this.$rowLengthCache[firstRow] = null;\n\t        this.$rowLengthCache[lastRow] = null;\n\t    };\n\n\t    this.$updateWrapData = function(firstRow, lastRow) {\n\t        var lines = this.doc.getAllLines();\n\t        var tabSize = this.getTabSize();\n\t        var wrapData = this.$wrapData;\n\t        var wrapLimit = this.$wrapLimit;\n\t        var tokens;\n\t        var foldLine;\n\n\t        var row = firstRow;\n\t        lastRow = Math.min(lastRow, lines.length - 1);\n\t        while (row <= lastRow) {\n\t            foldLine = this.getFoldLine(row, foldLine);\n\t            if (!foldLine) {\n\t                tokens = this.$getDisplayTokens(lines[row]);\n\t                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n\t                row ++;\n\t            } else {\n\t                tokens = [];\n\t                foldLine.walk(function(placeholder, row, column, lastColumn) {\n\t                        var walkTokens;\n\t                        if (placeholder != null) {\n\t                            walkTokens = this.$getDisplayTokens(\n\t                                            placeholder, tokens.length);\n\t                            walkTokens[0] = PLACEHOLDER_START;\n\t                            for (var i = 1; i < walkTokens.length; i++) {\n\t                                walkTokens[i] = PLACEHOLDER_BODY;\n\t                            }\n\t                        } else {\n\t                            walkTokens = this.$getDisplayTokens(\n\t                                lines[row].substring(lastColumn, column),\n\t                                tokens.length);\n\t                        }\n\t                        tokens = tokens.concat(walkTokens);\n\t                    }.bind(this),\n\t                    foldLine.end.row,\n\t                    lines[foldLine.end.row].length + 1\n\t                );\n\n\t                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);\n\t                row = foldLine.end.row + 1;\n\t            }\n\t        }\n\t    };\n\t    var CHAR = 1,\n\t        CHAR_EXT = 2,\n\t        PLACEHOLDER_START = 3,\n\t        PLACEHOLDER_BODY =  4,\n\t        PUNCTUATION = 9,\n\t        SPACE = 10,\n\t        TAB = 11,\n\t        TAB_SPACE = 12;\n\n\n\t    this.$computeWrapSplits = function(tokens, wrapLimit) {\n\t        if (tokens.length == 0) {\n\t            return [];\n\t        }\n\n\t        var splits = [];\n\t        var displayLength = tokens.length;\n\t        var lastSplit = 0, lastDocSplit = 0;\n\n\t        var isCode = this.$wrapAsCode;\n\n\t        function addSplit(screenPos) {\n\t            var displayed = tokens.slice(lastSplit, screenPos);\n\t            var len = displayed.length;\n\t            displayed.join(\"\").\n\t                replace(/12/g, function() {\n\t                    len -= 1;\n\t                }).\n\t                replace(/2/g, function() {\n\t                    len -= 1;\n\t                });\n\n\t            lastDocSplit += len;\n\t            splits.push(lastDocSplit);\n\t            lastSplit = screenPos;\n\t        }\n\n\t        while (displayLength - lastSplit > wrapLimit) {\n\t            var split = lastSplit + wrapLimit;\n\t            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {\n\t                addSplit(split);\n\t                continue;\n\t            }\n\t            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {\n\t                for (split; split != lastSplit - 1; split--) {\n\t                    if (tokens[split] == PLACEHOLDER_START) {\n\t                        break;\n\t                    }\n\t                }\n\t                if (split > lastSplit) {\n\t                    addSplit(split);\n\t                    continue;\n\t                }\n\t                split = lastSplit + wrapLimit;\n\t                for (split; split < tokens.length; split++) {\n\t                    if (tokens[split] != PLACEHOLDER_BODY) {\n\t                        break;\n\t                    }\n\t                }\n\t                if (split == tokens.length) {\n\t                    break;  // Breaks the while-loop.\n\t                }\n\t                addSplit(split);\n\t                continue;\n\t            }\n\t            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit-(wrapLimit>>2)), lastSplit - 1);\n\t            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n\t                split --;\n\t            }\n\t            if (isCode) {\n\t                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {\n\t                    split --;\n\t                }\n\t                while (split > minSplit && tokens[split] == PUNCTUATION) {\n\t                    split --;\n\t                }\n\t            } else {\n\t                while (split > minSplit && tokens[split] < SPACE) {\n\t                    split --;\n\t                }\n\t            }\n\t            if (split > minSplit) {\n\t                addSplit(++split);\n\t                continue;\n\t            }\n\t            split = lastSplit + wrapLimit;\n\t            if (tokens[split] == CHAR_EXT)\n\t                split--;\n\t            addSplit(split);\n\t        }\n\t        return splits;\n\t    };\n\t    this.$getDisplayTokens = function(str, offset) {\n\t        var arr = [];\n\t        var tabSize;\n\t        offset = offset || 0;\n\n\t        for (var i = 0; i < str.length; i++) {\n\t            var c = str.charCodeAt(i);\n\t            if (c == 9) {\n\t                tabSize = this.getScreenTabSize(arr.length + offset);\n\t                arr.push(TAB);\n\t                for (var n = 1; n < tabSize; n++) {\n\t                    arr.push(TAB_SPACE);\n\t                }\n\t            }\n\t            else if (c == 32) {\n\t                arr.push(SPACE);\n\t            } else if((c > 39 && c < 48) || (c > 57 && c < 64)) {\n\t                arr.push(PUNCTUATION);\n\t            }\n\t            else if (c >= 0x1100 && isFullWidth(c)) {\n\t                arr.push(CHAR, CHAR_EXT);\n\t            } else {\n\t                arr.push(CHAR);\n\t            }\n\t        }\n\t        return arr;\n\t    };\n\t    this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {\n\t        if (maxScreenColumn == 0)\n\t            return [0, 0];\n\t        if (maxScreenColumn == null)\n\t            maxScreenColumn = Infinity;\n\t        screenColumn = screenColumn || 0;\n\n\t        var c, column;\n\t        for (column = 0; column < str.length; column++) {\n\t            c = str.charCodeAt(column);\n\t            if (c == 9) {\n\t                screenColumn += this.getScreenTabSize(screenColumn);\n\t            }\n\t            else if (c >= 0x1100 && isFullWidth(c)) {\n\t                screenColumn += 2;\n\t            } else {\n\t                screenColumn += 1;\n\t            }\n\t            if (screenColumn > maxScreenColumn) {\n\t                break;\n\t            }\n\t        }\n\n\t        return [screenColumn, column];\n\t    };\n\n\t    this.lineWidgets = null;\n\t    this.getRowLength = function(row) {\n\t        if (this.lineWidgets)\n\t            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n\t        else \n\t            h = 0\n\t        if (!this.$useWrapMode || !this.$wrapData[row]) {\n\t            return 1 + h;\n\t        } else {\n\t            return this.$wrapData[row].length + 1 + h;\n\t        }\n\t    };\n\t    this.getRowLineCount = function(row) {\n\t        if (!this.$useWrapMode || !this.$wrapData[row]) {\n\t            return 1;\n\t        } else {\n\t            return this.$wrapData[row].length + 1;\n\t        }\n\t    };\n\t    this.getScreenLastRowColumn = function(screenRow) {\n\t        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);\n\t        return this.documentToScreenColumn(pos.row, pos.column);\n\t    };\n\t    this.getDocumentLastRowColumn = function(docRow, docColumn) {\n\t        var screenRow = this.documentToScreenRow(docRow, docColumn);\n\t        return this.getScreenLastRowColumn(screenRow);\n\t    };\n\t    this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {\n\t        var screenRow = this.documentToScreenRow(docRow, docColumn);\n\t        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);\n\t    };\n\t    this.getRowSplitData = function(row) {\n\t        if (!this.$useWrapMode) {\n\t            return undefined;\n\t        } else {\n\t            return this.$wrapData[row];\n\t        }\n\t    };\n\t    this.getScreenTabSize = function(screenColumn) {\n\t        return this.$tabSize - screenColumn % this.$tabSize;\n\t    };\n\n\n\t    this.screenToDocumentRow = function(screenRow, screenColumn) {\n\t        return this.screenToDocumentPosition(screenRow, screenColumn).row;\n\t    };\n\n\n\t    this.screenToDocumentColumn = function(screenRow, screenColumn) {\n\t        return this.screenToDocumentPosition(screenRow, screenColumn).column;\n\t    };\n\t    this.screenToDocumentPosition = function(screenRow, screenColumn) {\n\t        if (screenRow < 0)\n\t            return {row: 0, column: 0};\n\n\t        var line;\n\t        var docRow = 0;\n\t        var docColumn = 0;\n\t        var column;\n\t        var row = 0;\n\t        var rowLength = 0;\n\n\t        var rowCache = this.$screenRowCache;\n\t        var i = this.$getRowCacheIndex(rowCache, screenRow);\n\t        var l = rowCache.length;\n\t        if (l && i >= 0) {\n\t            var row = rowCache[i];\n\t            var docRow = this.$docRowCache[i];\n\t            var doCache = screenRow > rowCache[l - 1];\n\t        } else {\n\t            var doCache = !l;\n\t        }\n\n\t        var maxRow = this.getLength() - 1;\n\t        var foldLine = this.getNextFoldLine(docRow);\n\t        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n\t        while (row <= screenRow) {\n\t            rowLength = this.getRowLength(docRow);\n\t            if (row + rowLength > screenRow || docRow >= maxRow) {\n\t                break;\n\t            } else {\n\t                row += rowLength;\n\t                docRow++;\n\t                if (docRow > foldStart) {\n\t                    docRow = foldLine.end.row+1;\n\t                    foldLine = this.getNextFoldLine(docRow, foldLine);\n\t                    foldStart = foldLine ? foldLine.start.row : Infinity;\n\t                }\n\t            }\n\n\t            if (doCache) {\n\t                this.$docRowCache.push(docRow);\n\t                this.$screenRowCache.push(row);\n\t            }\n\t        }\n\n\t        if (foldLine && foldLine.start.row <= docRow) {\n\t            line = this.getFoldDisplayLine(foldLine);\n\t            docRow = foldLine.start.row;\n\t        } else if (row + rowLength <= screenRow || docRow > maxRow) {\n\t            return {\n\t                row: maxRow,\n\t                column: this.getLine(maxRow).length\n\t            };\n\t        } else {\n\t            line = this.getLine(docRow);\n\t            foldLine = null;\n\t        }\n\n\t        if (this.$useWrapMode) {\n\t            var splits = this.$wrapData[docRow];\n\t            if (splits) {\n\t                var splitIndex = Math.floor(screenRow - row);\n\t                column = splits[splitIndex];\n\t                if(splitIndex > 0 && splits.length) {\n\t                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];\n\t                    line = line.substring(docColumn);\n\t                }\n\t            }\n\t        }\n\n\t        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];\n\t        if (this.$useWrapMode && docColumn >= column)\n\t            docColumn = column - 1;\n\n\t        if (foldLine)\n\t            return foldLine.idxToPosition(docColumn);\n\n\t        return {row: docRow, column: docColumn};\n\t    };\n\t    this.documentToScreenPosition = function(docRow, docColumn) {\n\t        if (typeof docColumn === \"undefined\")\n\t            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);\n\t        else\n\t            pos = this.$clipPositionToDocument(docRow, docColumn);\n\n\t        docRow = pos.row;\n\t        docColumn = pos.column;\n\n\t        var screenRow = 0;\n\t        var foldStartRow = null;\n\t        var fold = null;\n\t        fold = this.getFoldAt(docRow, docColumn, 1);\n\t        if (fold) {\n\t            docRow = fold.start.row;\n\t            docColumn = fold.start.column;\n\t        }\n\n\t        var rowEnd, row = 0;\n\n\n\t        var rowCache = this.$docRowCache;\n\t        var i = this.$getRowCacheIndex(rowCache, docRow);\n\t        var l = rowCache.length;\n\t        if (l && i >= 0) {\n\t            var row = rowCache[i];\n\t            var screenRow = this.$screenRowCache[i];\n\t            var doCache = docRow > rowCache[l - 1];\n\t        } else {\n\t            var doCache = !l;\n\t        }\n\n\t        var foldLine = this.getNextFoldLine(row);\n\t        var foldStart = foldLine ?foldLine.start.row :Infinity;\n\n\t        while (row < docRow) {\n\t            if (row >= foldStart) {\n\t                rowEnd = foldLine.end.row + 1;\n\t                if (rowEnd > docRow)\n\t                    break;\n\t                foldLine = this.getNextFoldLine(rowEnd, foldLine);\n\t                foldStart = foldLine ?foldLine.start.row :Infinity;\n\t            }\n\t            else {\n\t                rowEnd = row + 1;\n\t            }\n\n\t            screenRow += this.getRowLength(row);\n\t            row = rowEnd;\n\n\t            if (doCache) {\n\t                this.$docRowCache.push(row);\n\t                this.$screenRowCache.push(screenRow);\n\t            }\n\t        }\n\t        var textLine = \"\";\n\t        if (foldLine && row >= foldStart) {\n\t            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);\n\t            foldStartRow = foldLine.start.row;\n\t        } else {\n\t            textLine = this.getLine(docRow).substring(0, docColumn);\n\t            foldStartRow = docRow;\n\t        }\n\t        if (this.$useWrapMode) {\n\t            var wrapRow = this.$wrapData[foldStartRow];\n\t            if (wrapRow) {\n\t                var screenRowOffset = 0;\n\t                while (textLine.length >= wrapRow[screenRowOffset]) {\n\t                    screenRow ++;\n\t                    screenRowOffset++;\n\t                }\n\t                textLine = textLine.substring(\n\t                    wrapRow[screenRowOffset - 1] || 0, textLine.length\n\t                );\n\t            }\n\t        }\n\n\t        return {\n\t            row: screenRow,\n\t            column: this.$getStringScreenWidth(textLine)[0]\n\t        };\n\t    };\n\t    this.documentToScreenColumn = function(row, docColumn) {\n\t        return this.documentToScreenPosition(row, docColumn).column;\n\t    };\n\t    this.documentToScreenRow = function(docRow, docColumn) {\n\t        return this.documentToScreenPosition(docRow, docColumn).row;\n\t    };\n\t    this.getScreenLength = function() {\n\t        var screenRows = 0;\n\t        var fold = null;\n\t        if (!this.$useWrapMode) {\n\t            screenRows = this.getLength();\n\t            var foldData = this.$foldData;\n\t            for (var i = 0; i < foldData.length; i++) {\n\t                fold = foldData[i];\n\t                screenRows -= fold.end.row - fold.start.row;\n\t            }\n\t        } else {\n\t            var lastRow = this.$wrapData.length;\n\t            var row = 0, i = 0;\n\t            var fold = this.$foldData[i++];\n\t            var foldStart = fold ? fold.start.row :Infinity;\n\n\t            while (row < lastRow) {\n\t                var splits = this.$wrapData[row];\n\t                screenRows += splits ? splits.length + 1 : 1;\n\t                row ++;\n\t                if (row > foldStart) {\n\t                    row = fold.end.row+1;\n\t                    fold = this.$foldData[i++];\n\t                    foldStart = fold ?fold.start.row :Infinity;\n\t                }\n\t            }\n\t        }\n\t        if (this.lineWidgets)\n\t            screenRows += this.$getWidgetScreenLength();\n\n\t        return screenRows;\n\t    };\n\t    this.$setFontMetrics = function(fm) {\n\t    };\n\t    \n\t    this.destroy = function() {\n\t        if (this.bgTokenizer) {\n\t            this.bgTokenizer.setDocument(null);\n\t            this.bgTokenizer = null;\n\t        }\n\t        this.$stopWorker();\n\t    };\n\t    function isFullWidth(c) {\n\t        if (c < 0x1100)\n\t            return false;\n\t        return c >= 0x1100 && c <= 0x115F ||\n\t               c >= 0x11A3 && c <= 0x11A7 ||\n\t               c >= 0x11FA && c <= 0x11FF ||\n\t               c >= 0x2329 && c <= 0x232A ||\n\t               c >= 0x2E80 && c <= 0x2E99 ||\n\t               c >= 0x2E9B && c <= 0x2EF3 ||\n\t               c >= 0x2F00 && c <= 0x2FD5 ||\n\t               c >= 0x2FF0 && c <= 0x2FFB ||\n\t               c >= 0x3000 && c <= 0x303E ||\n\t               c >= 0x3041 && c <= 0x3096 ||\n\t               c >= 0x3099 && c <= 0x30FF ||\n\t               c >= 0x3105 && c <= 0x312D ||\n\t               c >= 0x3131 && c <= 0x318E ||\n\t               c >= 0x3190 && c <= 0x31BA ||\n\t               c >= 0x31C0 && c <= 0x31E3 ||\n\t               c >= 0x31F0 && c <= 0x321E ||\n\t               c >= 0x3220 && c <= 0x3247 ||\n\t               c >= 0x3250 && c <= 0x32FE ||\n\t               c >= 0x3300 && c <= 0x4DBF ||\n\t               c >= 0x4E00 && c <= 0xA48C ||\n\t               c >= 0xA490 && c <= 0xA4C6 ||\n\t               c >= 0xA960 && c <= 0xA97C ||\n\t               c >= 0xAC00 && c <= 0xD7A3 ||\n\t               c >= 0xD7B0 && c <= 0xD7C6 ||\n\t               c >= 0xD7CB && c <= 0xD7FB ||\n\t               c >= 0xF900 && c <= 0xFAFF ||\n\t               c >= 0xFE10 && c <= 0xFE19 ||\n\t               c >= 0xFE30 && c <= 0xFE52 ||\n\t               c >= 0xFE54 && c <= 0xFE66 ||\n\t               c >= 0xFE68 && c <= 0xFE6B ||\n\t               c >= 0xFF01 && c <= 0xFF60 ||\n\t               c >= 0xFFE0 && c <= 0xFFE6;\n\t    };\n\n\t}).call(EditSession.prototype);\n\n\tacequire(\"./edit_session/folding\").Folding.call(EditSession.prototype);\n\tacequire(\"./edit_session/bracket_match\").BracketMatch.call(EditSession.prototype);\n\n\n\tconfig.defineOptions(EditSession.prototype, \"session\", {\n\t    wrap: {\n\t        set: function(value) {\n\t            if (!value || value == \"off\")\n\t                value = false;\n\t            else if (value == \"free\")\n\t                value = true;\n\t            else if (value == \"printMargin\")\n\t                value = -1;\n\t            else if (typeof value == \"string\")\n\t                value = parseInt(value, 10) || false;\n\n\t            if (this.$wrap == value)\n\t                return;\n\t            if (!value) {\n\t                this.setUseWrapMode(false);\n\t            } else {\n\t                var col = typeof value == \"number\" ? value : null;\n\t                this.setWrapLimitRange(col, col);\n\t                this.setUseWrapMode(true);\n\t            }\n\t            this.$wrap = value;\n\t        },\n\t        get: function() {\n\t            if (this.getUseWrapMode()) {\n\t                if (this.$wrap == -1)\n\t                    return \"printMargin\";\n\t                if (!this.getWrapLimitRange().min)\n\t                    return \"free\";\n\t                return this.$wrap;\n\t            }\n\t            return \"off\";\n\t        },\n\t        handlesSet: true\n\t    },    \n\t    wrapMethod: {\n\t        set: function(val) {\n\t            val = val == \"auto\"\n\t                ? this.$mode.type != \"text\"\n\t                : val != \"text\";\n\t            if (val != this.$wrapAsCode) {\n\t                this.$wrapAsCode = val;\n\t                if (this.$useWrapMode) {\n\t                    this.$modified = true;\n\t                    this.$resetRowCache(0);\n\t                    this.$updateWrapData(0, this.getLength() - 1);\n\t                }\n\t            }\n\t        },\n\t        initialValue: \"auto\"\n\t    },\n\t    firstLineNumber: {\n\t        set: function() {this._signal(\"changeBreakpoint\");},\n\t        initialValue: 1\n\t    },\n\t    useWorker: {\n\t        set: function(useWorker) {\n\t            this.$useWorker = useWorker;\n\n\t            this.$stopWorker();\n\t            if (useWorker)\n\t                this.$startWorker();\n\t        },\n\t        initialValue: true\n\t    },\n\t    useSoftTabs: {initialValue: true},\n\t    tabSize: {\n\t        set: function(tabSize) {\n\t            if (isNaN(tabSize) || this.$tabSize === tabSize) return;\n\n\t            this.$modified = true;\n\t            this.$rowLengthCache = [];\n\t            this.$tabSize = tabSize;\n\t            this._signal(\"changeTabSize\");\n\t        },\n\t        initialValue: 4,\n\t        handlesSet: true\n\t    },\n\t    overwrite: {\n\t        set: function(val) {this._signal(\"changeOverwrite\");},\n\t        initialValue: false\n\t    },\n\t    newLineMode: {\n\t        set: function(val) {this.doc.setNewLineMode(val)},\n\t        get: function() {return this.doc.getNewLineMode()},\n\t        handlesSet: true\n\t    },\n\t    mode: {\n\t        set: function(val) { this.setMode(val) },\n\t        get: function() { return this.$modeId }\n\t    }\n\t});\n\n\texports.EditSession = EditSession;\n\t});\n\n\tace.define(\"ace/search\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/lib/oop\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar lang = acequire(\"./lib/lang\");\n\tvar oop = acequire(\"./lib/oop\");\n\tvar Range = acequire(\"./range\").Range;\n\n\tvar Search = function() {\n\t    this.$options = {};\n\t};\n\n\t(function() {\n\t    this.set = function(options) {\n\t        oop.mixin(this.$options, options);\n\t        return this;\n\t    };\n\t    this.getOptions = function() {\n\t        return lang.copyObject(this.$options);\n\t    };\n\t    this.setOptions = function(options) {\n\t        this.$options = options;\n\t    };\n\t    this.find = function(session) {\n\t        var iterator = this.$matchIterator(session, this.$options);\n\n\t        if (!iterator)\n\t            return false;\n\n\t        var firstRange = null;\n\t        iterator.forEach(function(range, row, offset) {\n\t            if (!range.start) {\n\t                var column = range.offset + (offset || 0);\n\t                firstRange = new Range(row, column, row, column+range.length);\n\t            } else\n\t                firstRange = range;\n\t            return true;\n\t        });\n\n\t        return firstRange;\n\t    };\n\t    this.findAll = function(session) {\n\t        var options = this.$options;\n\t        if (!options.needle)\n\t            return [];\n\t        this.$assembleRegExp(options);\n\n\t        var range = options.range;\n\t        var lines = range\n\t            ? session.getLines(range.start.row, range.end.row)\n\t            : session.doc.getAllLines();\n\n\t        var ranges = [];\n\t        var re = options.re;\n\t        if (options.$isMultiLine) {\n\t            var len = re.length;\n\t            var maxRow = lines.length - len;\n\t            var prevRange;\n\t            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\n\t                for (var j = 0; j < len; j++)\n\t                    if (lines[row + j].search(re[j]) == -1)\n\t                        continue outer;\n\t                \n\t                var startLine = lines[row];\n\t                var line = lines[row + len - 1];\n\t                var startIndex = startLine.length - startLine.match(re[0])[0].length;\n\t                var endIndex = line.match(re[len - 1])[0].length;\n\t                \n\t                if (prevRange && prevRange.end.row === row &&\n\t                    prevRange.end.column > startIndex\n\t                ) {\n\t                    continue;\n\t                }\n\t                ranges.push(prevRange = new Range(\n\t                    row, startIndex, row + len - 1, endIndex\n\t                ));\n\t                if (len > 2)\n\t                    row = row + len - 2;\n\t            }\n\t        } else {\n\t            for (var i = 0; i < lines.length; i++) {\n\t                var matches = lang.getMatchOffsets(lines[i], re);\n\t                for (var j = 0; j < matches.length; j++) {\n\t                    var match = matches[j];\n\t                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));\n\t                }\n\t            }\n\t        }\n\n\t        if (range) {\n\t            var startColumn = range.start.column;\n\t            var endColumn = range.start.column;\n\t            var i = 0, j = ranges.length - 1;\n\t            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)\n\t                i++;\n\n\t            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)\n\t                j--;\n\t            \n\t            ranges = ranges.slice(i, j + 1);\n\t            for (i = 0, j = ranges.length; i < j; i++) {\n\t                ranges[i].start.row += range.start.row;\n\t                ranges[i].end.row += range.start.row;\n\t            }\n\t        }\n\n\t        return ranges;\n\t    };\n\t    this.replace = function(input, replacement) {\n\t        var options = this.$options;\n\n\t        var re = this.$assembleRegExp(options);\n\t        if (options.$isMultiLine)\n\t            return replacement;\n\n\t        if (!re)\n\t            return;\n\n\t        var match = re.exec(input);\n\t        if (!match || match[0].length != input.length)\n\t            return null;\n\t        \n\t        replacement = input.replace(re, replacement);\n\t        if (options.preserveCase) {\n\t            replacement = replacement.split(\"\");\n\t            for (var i = Math.min(input.length, input.length); i--; ) {\n\t                var ch = input[i];\n\t                if (ch && ch.toLowerCase() != ch)\n\t                    replacement[i] = replacement[i].toUpperCase();\n\t                else\n\t                    replacement[i] = replacement[i].toLowerCase();\n\t            }\n\t            replacement = replacement.join(\"\");\n\t        }\n\t        \n\t        return replacement;\n\t    };\n\n\t    this.$matchIterator = function(session, options) {\n\t        var re = this.$assembleRegExp(options);\n\t        if (!re)\n\t            return false;\n\n\t        var self = this, callback, backwards = options.backwards;\n\n\t        if (options.$isMultiLine) {\n\t            var len = re.length;\n\t            var matchIterator = function(line, row, offset) {\n\t                var startIndex = line.search(re[0]);\n\t                if (startIndex == -1)\n\t                    return;\n\t                for (var i = 1; i < len; i++) {\n\t                    line = session.getLine(row + i);\n\t                    if (line.search(re[i]) == -1)\n\t                        return;\n\t                }\n\n\t                var endIndex = line.match(re[len - 1])[0].length;\n\n\t                var range = new Range(row, startIndex, row + len - 1, endIndex);\n\t                if (re.offset == 1) {\n\t                    range.start.row--;\n\t                    range.start.column = Number.MAX_VALUE;\n\t                } else if (offset)\n\t                    range.start.column += offset;\n\n\t                if (callback(range))\n\t                    return true;\n\t            };\n\t        } else if (backwards) {\n\t            var matchIterator = function(line, row, startIndex) {\n\t                var matches = lang.getMatchOffsets(line, re);\n\t                for (var i = matches.length-1; i >= 0; i--)\n\t                    if (callback(matches[i], row, startIndex))\n\t                        return true;\n\t            };\n\t        } else {\n\t            var matchIterator = function(line, row, startIndex) {\n\t                var matches = lang.getMatchOffsets(line, re);\n\t                for (var i = 0; i < matches.length; i++)\n\t                    if (callback(matches[i], row, startIndex))\n\t                        return true;\n\t            };\n\t        }\n\n\t        return {\n\t            forEach: function(_callback) {\n\t                callback = _callback;\n\t                self.$lineIterator(session, options).forEach(matchIterator);\n\t            }\n\t        };\n\t    };\n\n\t    this.$assembleRegExp = function(options, $disableFakeMultiline) {\n\t        if (options.needle instanceof RegExp)\n\t            return options.re = options.needle;\n\n\t        var needle = options.needle;\n\n\t        if (!options.needle)\n\t            return options.re = false;\n\n\t        if (!options.regExp)\n\t            needle = lang.escapeRegExp(needle);\n\n\t        if (options.wholeWord)\n\t            needle = \"\\\\b\" + needle + \"\\\\b\";\n\n\t        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\n\n\t        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\n\t        if (options.$isMultiLine)\n\t            return options.re = this.$assembleMultilineRegExp(needle, modifier);\n\n\t        try {\n\t            var re = new RegExp(needle, modifier);\n\t        } catch(e) {\n\t            re = false;\n\t        }\n\t        return options.re = re;\n\t    };\n\n\t    this.$assembleMultilineRegExp = function(needle, modifier) {\n\t        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\n\t        var re = [];\n\t        for (var i = 0; i < parts.length; i++) try {\n\t            re.push(new RegExp(parts[i], modifier));\n\t        } catch(e) {\n\t            return false;\n\t        }\n\t        if (parts[0] == \"\") {\n\t            re.shift();\n\t            re.offset = 1;\n\t        } else {\n\t            re.offset = 0;\n\t        }\n\t        return re;\n\t    };\n\n\t    this.$lineIterator = function(session, options) {\n\t        var backwards = options.backwards == true;\n\t        var skipCurrent = options.skipCurrent != false;\n\n\t        var range = options.range;\n\t        var start = options.start;\n\t        if (!start)\n\t            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\n\t         \n\t        if (start.start)\n\t            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\n\n\t        var firstRow = range ? range.start.row : 0;\n\t        var lastRow = range ? range.end.row : session.getLength() - 1;\n\n\t        var forEach = backwards ? function(callback) {\n\t                var row = start.row;\n\n\t                var line = session.getLine(row).substring(0, start.column);\n\t                if (callback(line, row))\n\t                    return;\n\n\t                for (row--; row >= firstRow; row--)\n\t                    if (callback(session.getLine(row), row))\n\t                        return;\n\n\t                if (options.wrap == false)\n\t                    return;\n\n\t                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\n\t                    if (callback(session.getLine(row), row))\n\t                        return;\n\t            } : function(callback) {\n\t                var row = start.row;\n\n\t                var line = session.getLine(row).substr(start.column);\n\t                if (callback(line, row, start.column))\n\t                    return;\n\n\t                for (row = row+1; row <= lastRow; row++)\n\t                    if (callback(session.getLine(row), row))\n\t                        return;\n\n\t                if (options.wrap == false)\n\t                    return;\n\n\t                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\n\t                    if (callback(session.getLine(row), row))\n\t                        return;\n\t            };\n\t        \n\t        return {forEach: forEach};\n\t    };\n\n\t}).call(Search.prototype);\n\n\texports.Search = Search;\n\t});\n\n\tace.define(\"ace/keyboard/hash_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/keys\",\"ace/lib/useragent\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar keyUtil = acequire(\"../lib/keys\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tvar KEY_MODS = keyUtil.KEY_MODS;\n\n\tfunction HashHandler(config, platform) {\n\t    this.platform = platform || (useragent.isMac ? \"mac\" : \"win\");\n\t    this.commands = {};\n\t    this.commandKeyBinding = {};\n\t    this.addCommands(config);\n\t    this.$singleCommand = true;\n\t}\n\n\tfunction MultiHashHandler(config, platform) {\n\t    HashHandler.call(this, config, platform);\n\t    this.$singleCommand = false;\n\t}\n\n\tMultiHashHandler.prototype = HashHandler.prototype;\n\n\t(function() {\n\n\n\t    this.addCommand = function(command) {\n\t        if (this.commands[command.name])\n\t            this.removeCommand(command);\n\n\t        this.commands[command.name] = command;\n\n\t        if (command.bindKey)\n\t            this._buildKeyHash(command);\n\t    };\n\n\t    this.removeCommand = function(command, keepCommand) {\n\t        var name = command && (typeof command === 'string' ? command : command.name);\n\t        command = this.commands[name];\n\t        if (!keepCommand)\n\t            delete this.commands[name];\n\t        var ckb = this.commandKeyBinding;\n\t        for (var keyId in ckb) {\n\t            var cmdGroup = ckb[keyId];\n\t            if (cmdGroup == command) {\n\t                delete ckb[keyId];\n\t            } else if (Array.isArray(cmdGroup)) {\n\t                var i = cmdGroup.indexOf(command);\n\t                if (i != -1) {\n\t                    cmdGroup.splice(i, 1);\n\t                    if (cmdGroup.length == 1)\n\t                        ckb[keyId] = cmdGroup[0];\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    this.bindKey = function(key, command, asDefault) {\n\t        if (typeof key == \"object\")\n\t            key = key[this.platform];\n\t        if (!key)\n\t            return;\n\t        if (typeof command == \"function\")\n\t            return this.addCommand({exec: command, bindKey: key, name: command.name || key});\n\n\t        key.split(\"|\").forEach(function(keyPart) {\n\t            var chain = \"\";\n\t            if (keyPart.indexOf(\" \") != -1) {\n\t                var parts = keyPart.split(/\\s+/);\n\t                keyPart = parts.pop();\n\t                parts.forEach(function(keyPart) {\n\t                    var binding = this.parseKeys(keyPart);\n\t                    var id = KEY_MODS[binding.hashId] + binding.key;\n\t                    chain += (chain ? \" \" : \"\") + id;\n\t                    this._addCommandToBinding(chain, \"chainKeys\");\n\t                }, this);\n\t                chain += \" \";\n\t            }\n\t            var binding = this.parseKeys(keyPart);\n\t            var id = KEY_MODS[binding.hashId] + binding.key;\n\t            this._addCommandToBinding(chain + id, command, asDefault);\n\t        }, this);\n\t    };\n\n\t    this._addCommandToBinding = function(keyId, command, asDefault) {\n\t        var ckb = this.commandKeyBinding, i;\n\t        if (!command) {\n\t            delete ckb[keyId];\n\t        } else if (!ckb[keyId] || this.$singleCommand) {\n\t            ckb[keyId] = command;\n\t        } else {\n\t            if (!Array.isArray(ckb[keyId])) {\n\t                ckb[keyId] = [ckb[keyId]];\n\t            } else if ((i = ckb[keyId].indexOf(command)) != -1) {\n\t                ckb[keyId].splice(i, 1);\n\t            }\n\n\t            if (asDefault || command.isDefault)\n\t                ckb[keyId].unshift(command);\n\t            else\n\t                ckb[keyId].push(command);\n\t        }\n\t    };\n\n\t    this.addCommands = function(commands) {\n\t        commands && Object.keys(commands).forEach(function(name) {\n\t            var command = commands[name];\n\t            if (!command)\n\t                return;\n\t            \n\t            if (typeof command === \"string\")\n\t                return this.bindKey(command, name);\n\n\t            if (typeof command === \"function\")\n\t                command = { exec: command };\n\n\t            if (typeof command !== \"object\")\n\t                return;\n\n\t            if (!command.name)\n\t                command.name = name;\n\n\t            this.addCommand(command);\n\t        }, this);\n\t    };\n\n\t    this.removeCommands = function(commands) {\n\t        Object.keys(commands).forEach(function(name) {\n\t            this.removeCommand(commands[name]);\n\t        }, this);\n\t    };\n\n\t    this.bindKeys = function(keyList) {\n\t        Object.keys(keyList).forEach(function(key) {\n\t            this.bindKey(key, keyList[key]);\n\t        }, this);\n\t    };\n\n\t    this._buildKeyHash = function(command) {\n\t        this.bindKey(command.bindKey, command);\n\t    };\n\t    this.parseKeys = function(keys) {\n\t        var parts = keys.toLowerCase().split(/[\\-\\+]([\\-\\+])?/).filter(function(x){return x});\n\t        var key = parts.pop();\n\n\t        var keyCode = keyUtil[key];\n\t        if (keyUtil.FUNCTION_KEYS[keyCode])\n\t            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();\n\t        else if (!parts.length)\n\t            return {key: key, hashId: -1};\n\t        else if (parts.length == 1 && parts[0] == \"shift\")\n\t            return {key: key.toUpperCase(), hashId: -1};\n\n\t        var hashId = 0;\n\t        for (var i = parts.length; i--;) {\n\t            var modifier = keyUtil.KEY_MODS[parts[i]];\n\t            if (modifier == null) {\n\t                if (typeof console != \"undefined\")\n\t                    console.error(\"invalid modifier \" + parts[i] + \" in \" + keys);\n\t                return false;\n\t            }\n\t            hashId |= modifier;\n\t        }\n\t        return {key: key, hashId: hashId};\n\t    };\n\n\t    this.findKeyCommand = function findKeyCommand(hashId, keyString) {\n\t        var key = KEY_MODS[hashId] + keyString;\n\t        return this.commandKeyBinding[key];\n\t    };\n\n\t    this.handleKeyboard = function(data, hashId, keyString, keyCode) {\n\t        var key = KEY_MODS[hashId] + keyString;\n\t        var command = this.commandKeyBinding[key];\n\t        if (data.$keyChain) {\n\t            data.$keyChain += \" \" + key;\n\t            command = this.commandKeyBinding[data.$keyChain] || command;\n\t        }\n\n\t        if (command) {\n\t            if (command == \"chainKeys\" || command[command.length - 1] == \"chainKeys\") {\n\t                data.$keyChain = data.$keyChain || key;\n\t                return {command: \"null\"};\n\t            }\n\t        }\n\n\t        if (data.$keyChain && keyCode > 0)\n\t            data.$keyChain = \"\";\n\t        return {command: command};\n\t    };\n\n\t}).call(HashHandler.prototype);\n\n\texports.HashHandler = HashHandler;\n\texports.MultiHashHandler = MultiHashHandler;\n\t});\n\n\tace.define(\"ace/commands/command_manager\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/keyboard/hash_handler\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../lib/oop\");\n\tvar MultiHashHandler = acequire(\"../keyboard/hash_handler\").MultiHashHandler;\n\tvar EventEmitter = acequire(\"../lib/event_emitter\").EventEmitter;\n\n\tvar CommandManager = function(platform, commands) {\n\t    MultiHashHandler.call(this, commands, platform);\n\t    this.byName = this.commands;\n\t    this.setDefaultHandler(\"exec\", function(e) {\n\t        return e.command.exec(e.editor, e.args || {});\n\t    });\n\t};\n\n\toop.inherits(CommandManager, MultiHashHandler);\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\n\t    this.exec = function(command, editor, args) {\n\t        if (Array.isArray(command)) {\n\t            for (var i = command.length; i--; ) {\n\t                if (this.exec(command[i], editor, args)) return true;\n\t            }\n\t            return false;\n\t        }\n\n\t        if (typeof command === \"string\")\n\t            command = this.commands[command];\n\n\t        if (!command)\n\t            return false;\n\n\t        if (editor && editor.$readOnly && !command.readOnly)\n\t            return false;\n\n\t        var e = {editor: editor, command: command, args: args};\n\t        e.returnValue = this._emit(\"exec\", e);\n\t        this._signal(\"afterExec\", e);\n\n\t        return e.returnValue === false ? false : true;\n\t    };\n\n\t    this.toggleRecording = function(editor) {\n\t        if (this.$inReplay)\n\t            return;\n\n\t        editor && editor._emit(\"changeStatus\");\n\t        if (this.recording) {\n\t            this.macro.pop();\n\t            this.removeEventListener(\"exec\", this.$addCommandToMacro);\n\n\t            if (!this.macro.length)\n\t                this.macro = this.oldMacro;\n\n\t            return this.recording = false;\n\t        }\n\t        if (!this.$addCommandToMacro) {\n\t            this.$addCommandToMacro = function(e) {\n\t                this.macro.push([e.command, e.args]);\n\t            }.bind(this);\n\t        }\n\n\t        this.oldMacro = this.macro;\n\t        this.macro = [];\n\t        this.on(\"exec\", this.$addCommandToMacro);\n\t        return this.recording = true;\n\t    };\n\n\t    this.replay = function(editor) {\n\t        if (this.$inReplay || !this.macro)\n\t            return;\n\n\t        if (this.recording)\n\t            return this.toggleRecording(editor);\n\n\t        try {\n\t            this.$inReplay = true;\n\t            this.macro.forEach(function(x) {\n\t                if (typeof x == \"string\")\n\t                    this.exec(x, editor);\n\t                else\n\t                    this.exec(x[0], editor, x[1]);\n\t            }, this);\n\t        } finally {\n\t            this.$inReplay = false;\n\t        }\n\t    };\n\n\t    this.trimMacro = function(m) {\n\t        return m.map(function(x){\n\t            if (typeof x[0] != \"string\")\n\t                x[0] = x[0].name;\n\t            if (!x[1])\n\t                x = x[0];\n\t            return x;\n\t        });\n\t    };\n\n\t}).call(CommandManager.prototype);\n\n\texports.CommandManager = CommandManager;\n\n\t});\n\n\tace.define(\"ace/commands/default_commands\",[\"require\",\"exports\",\"module\",\"ace/lib/lang\",\"ace/config\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar lang = acequire(\"../lib/lang\");\n\tvar config = acequire(\"../config\");\n\tvar Range = acequire(\"../range\").Range;\n\n\tfunction bindKey(win, mac) {\n\t    return {win: win, mac: mac};\n\t}\n\texports.commands = [{\n\t    name: \"showSettingsMenu\",\n\t    bindKey: bindKey(\"Ctrl-,\", \"Command-,\"),\n\t    exec: function(editor) {\n\t        config.loadModule(\"ace/ext/settings_menu\", function(module) {\n\t            module.init(editor);\n\t            editor.showSettingsMenu();\n\t        });\n\t    },\n\t    readOnly: true\n\t}, {\n\t    name: \"goToNextError\",\n\t    bindKey: bindKey(\"Alt-E\", \"Ctrl-E\"),\n\t    exec: function(editor) {\n\t        config.loadModule(\"ace/ext/error_marker\", function(module) {\n\t            module.showErrorMarker(editor, 1);\n\t        });\n\t    },\n\t    scrollIntoView: \"animate\",\n\t    readOnly: true\n\t}, {\n\t    name: \"goToPreviousError\",\n\t    bindKey: bindKey(\"Alt-Shift-E\", \"Ctrl-Shift-E\"),\n\t    exec: function(editor) {\n\t        config.loadModule(\"ace/ext/error_marker\", function(module) {\n\t            module.showErrorMarker(editor, -1);\n\t        });\n\t    },\n\t    scrollIntoView: \"animate\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectall\",\n\t    bindKey: bindKey(\"Ctrl-A\", \"Command-A\"),\n\t    exec: function(editor) { editor.selectAll(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"centerselection\",\n\t    bindKey: bindKey(null, \"Ctrl-L\"),\n\t    exec: function(editor) { editor.centerSelection(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"gotoline\",\n\t    bindKey: bindKey(\"Ctrl-L\", \"Command-L\"),\n\t    exec: function(editor) {\n\t        var line = parseInt(prompt(\"Enter line number:\"), 10);\n\t        if (!isNaN(line)) {\n\t            editor.gotoLine(line);\n\t        }\n\t    },\n\t    readOnly: true\n\t}, {\n\t    name: \"fold\",\n\t    bindKey: bindKey(\"Alt-L|Ctrl-F1\", \"Command-Alt-L|Command-F1\"),\n\t    exec: function(editor) { editor.session.toggleFold(false); },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"unfold\",\n\t    bindKey: bindKey(\"Alt-Shift-L|Ctrl-Shift-F1\", \"Command-Alt-Shift-L|Command-Shift-F1\"),\n\t    exec: function(editor) { editor.session.toggleFold(true); },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"toggleFoldWidget\",\n\t    bindKey: bindKey(\"F2\", \"F2\"),\n\t    exec: function(editor) { editor.session.toggleFoldWidget(); },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"toggleParentFoldWidget\",\n\t    bindKey: bindKey(\"Alt-F2\", \"Alt-F2\"),\n\t    exec: function(editor) { editor.session.toggleFoldWidget(true); },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"foldall\",\n\t    bindKey: bindKey(\"Ctrl-Alt-0\", \"Ctrl-Command-Option-0\"),\n\t    exec: function(editor) { editor.session.foldAll(); },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"foldOther\",\n\t    bindKey: bindKey(\"Alt-0\", \"Command-Option-0\"),\n\t    exec: function(editor) { \n\t        editor.session.foldAll();\n\t        editor.session.unfold(editor.selection.getAllRanges());\n\t    },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"unfoldall\",\n\t    bindKey: bindKey(\"Alt-Shift-0\", \"Command-Option-Shift-0\"),\n\t    exec: function(editor) { editor.session.unfold(); },\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"findnext\",\n\t    bindKey: bindKey(\"Ctrl-K\", \"Command-G\"),\n\t    exec: function(editor) { editor.findNext(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"findprevious\",\n\t    bindKey: bindKey(\"Ctrl-Shift-K\", \"Command-Shift-G\"),\n\t    exec: function(editor) { editor.findPrevious(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"center\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectOrFindNext\",\n\t    bindKey: bindKey(\"Alt-K\", \"Ctrl-G\"),\n\t    exec: function(editor) {\n\t        if (editor.selection.isEmpty())\n\t            editor.selection.selectWord();\n\t        else\n\t            editor.findNext(); \n\t    },\n\t    readOnly: true\n\t}, {\n\t    name: \"selectOrFindPrevious\",\n\t    bindKey: bindKey(\"Alt-Shift-K\", \"Ctrl-Shift-G\"),\n\t    exec: function(editor) { \n\t        if (editor.selection.isEmpty())\n\t            editor.selection.selectWord();\n\t        else\n\t            editor.findPrevious();\n\t    },\n\t    readOnly: true\n\t}, {\n\t    name: \"find\",\n\t    bindKey: bindKey(\"Ctrl-F\", \"Command-F\"),\n\t    exec: function(editor) {\n\t        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor)});\n\t    },\n\t    readOnly: true\n\t}, {\n\t    name: \"overwrite\",\n\t    bindKey: \"Insert\",\n\t    exec: function(editor) { editor.toggleOverwrite(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"selecttostart\",\n\t    bindKey: bindKey(\"Ctrl-Shift-Home\", \"Command-Shift-Up\"),\n\t    exec: function(editor) { editor.getSelection().selectFileStart(); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true,\n\t    scrollIntoView: \"animate\",\n\t    aceCommandGroup: \"fileJump\"\n\t}, {\n\t    name: \"gotostart\",\n\t    bindKey: bindKey(\"Ctrl-Home\", \"Command-Home|Command-Up\"),\n\t    exec: function(editor) { editor.navigateFileStart(); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true,\n\t    scrollIntoView: \"animate\",\n\t    aceCommandGroup: \"fileJump\"\n\t}, {\n\t    name: \"selectup\",\n\t    bindKey: bindKey(\"Shift-Up\", \"Shift-Up\"),\n\t    exec: function(editor) { editor.getSelection().selectUp(); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true\n\t}, {\n\t    name: \"golineup\",\n\t    bindKey: bindKey(\"Up\", \"Up|Ctrl-P\"),\n\t    exec: function(editor, args) { editor.navigateUp(args.times); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selecttoend\",\n\t    bindKey: bindKey(\"Ctrl-Shift-End\", \"Command-Shift-Down\"),\n\t    exec: function(editor) { editor.getSelection().selectFileEnd(); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true,\n\t    scrollIntoView: \"animate\",\n\t    aceCommandGroup: \"fileJump\"\n\t}, {\n\t    name: \"gotoend\",\n\t    bindKey: bindKey(\"Ctrl-End\", \"Command-End|Command-Down\"),\n\t    exec: function(editor) { editor.navigateFileEnd(); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true,\n\t    scrollIntoView: \"animate\",\n\t    aceCommandGroup: \"fileJump\"\n\t}, {\n\t    name: \"selectdown\",\n\t    bindKey: bindKey(\"Shift-Down\", \"Shift-Down\"),\n\t    exec: function(editor) { editor.getSelection().selectDown(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"golinedown\",\n\t    bindKey: bindKey(\"Down\", \"Down|Ctrl-N\"),\n\t    exec: function(editor, args) { editor.navigateDown(args.times); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectwordleft\",\n\t    bindKey: bindKey(\"Ctrl-Shift-Left\", \"Option-Shift-Left\"),\n\t    exec: function(editor) { editor.getSelection().selectWordLeft(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"gotowordleft\",\n\t    bindKey: bindKey(\"Ctrl-Left\", \"Option-Left\"),\n\t    exec: function(editor) { editor.navigateWordLeft(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selecttolinestart\",\n\t    bindKey: bindKey(\"Alt-Shift-Left\", \"Command-Shift-Left\"),\n\t    exec: function(editor) { editor.getSelection().selectLineStart(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"gotolinestart\",\n\t    bindKey: bindKey(\"Alt-Left|Home\", \"Command-Left|Home|Ctrl-A\"),\n\t    exec: function(editor) { editor.navigateLineStart(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectleft\",\n\t    bindKey: bindKey(\"Shift-Left\", \"Shift-Left\"),\n\t    exec: function(editor) { editor.getSelection().selectLeft(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"gotoleft\",\n\t    bindKey: bindKey(\"Left\", \"Left|Ctrl-B\"),\n\t    exec: function(editor, args) { editor.navigateLeft(args.times); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectwordright\",\n\t    bindKey: bindKey(\"Ctrl-Shift-Right\", \"Option-Shift-Right\"),\n\t    exec: function(editor) { editor.getSelection().selectWordRight(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"gotowordright\",\n\t    bindKey: bindKey(\"Ctrl-Right\", \"Option-Right\"),\n\t    exec: function(editor) { editor.navigateWordRight(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selecttolineend\",\n\t    bindKey: bindKey(\"Alt-Shift-Right\", \"Command-Shift-Right\"),\n\t    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"gotolineend\",\n\t    bindKey: bindKey(\"Alt-Right|End\", \"Command-Right|End|Ctrl-E\"),\n\t    exec: function(editor) { editor.navigateLineEnd(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectright\",\n\t    bindKey: bindKey(\"Shift-Right\", \"Shift-Right\"),\n\t    exec: function(editor) { editor.getSelection().selectRight(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"gotoright\",\n\t    bindKey: bindKey(\"Right\", \"Right|Ctrl-F\"),\n\t    exec: function(editor, args) { editor.navigateRight(args.times); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectpagedown\",\n\t    bindKey: \"Shift-PageDown\",\n\t    exec: function(editor) { editor.selectPageDown(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"pagedown\",\n\t    bindKey: bindKey(null, \"Option-PageDown\"),\n\t    exec: function(editor) { editor.scrollPageDown(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"gotopagedown\",\n\t    bindKey: bindKey(\"PageDown\", \"PageDown|Ctrl-V\"),\n\t    exec: function(editor) { editor.gotoPageDown(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"selectpageup\",\n\t    bindKey: \"Shift-PageUp\",\n\t    exec: function(editor) { editor.selectPageUp(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"pageup\",\n\t    bindKey: bindKey(null, \"Option-PageUp\"),\n\t    exec: function(editor) { editor.scrollPageUp(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"gotopageup\",\n\t    bindKey: \"PageUp\",\n\t    exec: function(editor) { editor.gotoPageUp(); },\n\t    readOnly: true\n\t}, {\n\t    name: \"scrollup\",\n\t    bindKey: bindKey(\"Ctrl-Up\", null),\n\t    exec: function(e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },\n\t    readOnly: true\n\t}, {\n\t    name: \"scrolldown\",\n\t    bindKey: bindKey(\"Ctrl-Down\", null),\n\t    exec: function(e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },\n\t    readOnly: true\n\t}, {\n\t    name: \"selectlinestart\",\n\t    bindKey: \"Shift-Home\",\n\t    exec: function(editor) { editor.getSelection().selectLineStart(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selectlineend\",\n\t    bindKey: \"Shift-End\",\n\t    exec: function(editor) { editor.getSelection().selectLineEnd(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"togglerecording\",\n\t    bindKey: bindKey(\"Ctrl-Alt-E\", \"Command-Option-E\"),\n\t    exec: function(editor) { editor.commands.toggleRecording(editor); },\n\t    readOnly: true\n\t}, {\n\t    name: \"replaymacro\",\n\t    bindKey: bindKey(\"Ctrl-Shift-E\", \"Command-Shift-E\"),\n\t    exec: function(editor) { editor.commands.replay(editor); },\n\t    readOnly: true\n\t}, {\n\t    name: \"jumptomatching\",\n\t    bindKey: bindKey(\"Ctrl-P\", \"Ctrl-P\"),\n\t    exec: function(editor) { editor.jumpToMatching(); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true\n\t}, {\n\t    name: \"selecttomatching\",\n\t    bindKey: bindKey(\"Ctrl-Shift-P\", \"Ctrl-Shift-P\"),\n\t    exec: function(editor) { editor.jumpToMatching(true); },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true\n\t}, {\n\t    name: \"passKeysToBrowser\",\n\t    bindKey: bindKey(\"null\", \"null\"),\n\t    exec: function() {},\n\t    passEvent: true,\n\t    readOnly: true\n\t},\n\t{\n\t    name: \"cut\",\n\t    exec: function(editor) {\n\t        var range = editor.getSelectionRange();\n\t        editor._emit(\"cut\", range);\n\n\t        if (!editor.selection.isEmpty()) {\n\t            editor.session.remove(range);\n\t            editor.clearSelection();\n\t        }\n\t    },\n\t    scrollIntoView: \"cursor\",\n\t    multiSelectAction: \"forEach\"\n\t}, {\n\t    name: \"removeline\",\n\t    bindKey: bindKey(\"Ctrl-D\", \"Command-D\"),\n\t    exec: function(editor) { editor.removeLines(); },\n\t    scrollIntoView: \"cursor\",\n\t    multiSelectAction: \"forEachLine\"\n\t}, {\n\t    name: \"duplicateSelection\",\n\t    bindKey: bindKey(\"Ctrl-Shift-D\", \"Command-Shift-D\"),\n\t    exec: function(editor) { editor.duplicateSelection(); },\n\t    scrollIntoView: \"cursor\",\n\t    multiSelectAction: \"forEach\"\n\t}, {\n\t    name: \"sortlines\",\n\t    bindKey: bindKey(\"Ctrl-Alt-S\", \"Command-Alt-S\"),\n\t    exec: function(editor) { editor.sortLines(); },\n\t    scrollIntoView: \"selection\",\n\t    multiSelectAction: \"forEachLine\"\n\t}, {\n\t    name: \"togglecomment\",\n\t    bindKey: bindKey(\"Ctrl-/\", \"Command-/\"),\n\t    exec: function(editor) { editor.toggleCommentLines(); },\n\t    multiSelectAction: \"forEachLine\",\n\t    scrollIntoView: \"selectionPart\"\n\t}, {\n\t    name: \"toggleBlockComment\",\n\t    bindKey: bindKey(\"Ctrl-Shift-/\", \"Command-Shift-/\"),\n\t    exec: function(editor) { editor.toggleBlockComment(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"selectionPart\"\n\t}, {\n\t    name: \"modifyNumberUp\",\n\t    bindKey: bindKey(\"Ctrl-Shift-Up\", \"Alt-Shift-Up\"),\n\t    exec: function(editor) { editor.modifyNumber(1); },\n\t    multiSelectAction: \"forEach\"\n\t}, {\n\t    name: \"modifyNumberDown\",\n\t    bindKey: bindKey(\"Ctrl-Shift-Down\", \"Alt-Shift-Down\"),\n\t    exec: function(editor) { editor.modifyNumber(-1); },\n\t    multiSelectAction: \"forEach\"\n\t}, {\n\t    name: \"replace\",\n\t    bindKey: bindKey(\"Ctrl-H\", \"Command-Option-F\"),\n\t    exec: function(editor) {\n\t        config.loadModule(\"ace/ext/searchbox\", function(e) {e.Search(editor, true)});\n\t    }\n\t}, {\n\t    name: \"undo\",\n\t    bindKey: bindKey(\"Ctrl-Z\", \"Command-Z\"),\n\t    exec: function(editor) { editor.undo(); }\n\t}, {\n\t    name: \"redo\",\n\t    bindKey: bindKey(\"Ctrl-Shift-Z|Ctrl-Y\", \"Command-Shift-Z|Command-Y\"),\n\t    exec: function(editor) { editor.redo(); }\n\t}, {\n\t    name: \"copylinesup\",\n\t    bindKey: bindKey(\"Alt-Shift-Up\", \"Command-Option-Up\"),\n\t    exec: function(editor) { editor.copyLinesUp(); },\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"movelinesup\",\n\t    bindKey: bindKey(\"Alt-Up\", \"Option-Up\"),\n\t    exec: function(editor) { editor.moveLinesUp(); },\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"copylinesdown\",\n\t    bindKey: bindKey(\"Alt-Shift-Down\", \"Command-Option-Down\"),\n\t    exec: function(editor) { editor.copyLinesDown(); },\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"movelinesdown\",\n\t    bindKey: bindKey(\"Alt-Down\", \"Option-Down\"),\n\t    exec: function(editor) { editor.moveLinesDown(); },\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"del\",\n\t    bindKey: bindKey(\"Delete\", \"Delete|Ctrl-D|Shift-Delete\"),\n\t    exec: function(editor) { editor.remove(\"right\"); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"backspace\",\n\t    bindKey: bindKey(\n\t        \"Shift-Backspace|Backspace\",\n\t        \"Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H\"\n\t    ),\n\t    exec: function(editor) { editor.remove(\"left\"); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"cut_or_delete\",\n\t    bindKey: bindKey(\"Shift-Delete\", null),\n\t    exec: function(editor) { \n\t        if (editor.selection.isEmpty()) {\n\t            editor.remove(\"left\");\n\t        } else {\n\t            return false;\n\t        }\n\t    },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"removetolinestart\",\n\t    bindKey: bindKey(\"Alt-Backspace\", \"Command-Backspace\"),\n\t    exec: function(editor) { editor.removeToLineStart(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"removetolineend\",\n\t    bindKey: bindKey(\"Alt-Delete\", \"Ctrl-K\"),\n\t    exec: function(editor) { editor.removeToLineEnd(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"removewordleft\",\n\t    bindKey: bindKey(\"Ctrl-Backspace\", \"Alt-Backspace|Ctrl-Alt-Backspace\"),\n\t    exec: function(editor) { editor.removeWordLeft(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"removewordright\",\n\t    bindKey: bindKey(\"Ctrl-Delete\", \"Alt-Delete\"),\n\t    exec: function(editor) { editor.removeWordRight(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"outdent\",\n\t    bindKey: bindKey(\"Shift-Tab\", \"Shift-Tab\"),\n\t    exec: function(editor) { editor.blockOutdent(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"selectionPart\"\n\t}, {\n\t    name: \"indent\",\n\t    bindKey: bindKey(\"Tab\", \"Tab\"),\n\t    exec: function(editor) { editor.indent(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"selectionPart\"\n\t}, {\n\t    name: \"blockoutdent\",\n\t    bindKey: bindKey(\"Ctrl-[\", \"Ctrl-[\"),\n\t    exec: function(editor) { editor.blockOutdent(); },\n\t    multiSelectAction: \"forEachLine\",\n\t    scrollIntoView: \"selectionPart\"\n\t}, {\n\t    name: \"blockindent\",\n\t    bindKey: bindKey(\"Ctrl-]\", \"Ctrl-]\"),\n\t    exec: function(editor) { editor.blockIndent(); },\n\t    multiSelectAction: \"forEachLine\",\n\t    scrollIntoView: \"selectionPart\"\n\t}, {\n\t    name: \"insertstring\",\n\t    exec: function(editor, str) { editor.insert(str); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"inserttext\",\n\t    exec: function(editor, args) {\n\t        editor.insert(lang.stringRepeat(args.text  || \"\", args.times || 1));\n\t    },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"splitline\",\n\t    bindKey: bindKey(null, \"Ctrl-O\"),\n\t    exec: function(editor) { editor.splitLine(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"transposeletters\",\n\t    bindKey: bindKey(\"Ctrl-T\", \"Ctrl-T\"),\n\t    exec: function(editor) { editor.transposeLetters(); },\n\t    multiSelectAction: function(editor) {editor.transposeSelections(1); },\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"touppercase\",\n\t    bindKey: bindKey(\"Ctrl-U\", \"Ctrl-U\"),\n\t    exec: function(editor) { editor.toUpperCase(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"tolowercase\",\n\t    bindKey: bindKey(\"Ctrl-Shift-U\", \"Ctrl-Shift-U\"),\n\t    exec: function(editor) { editor.toLowerCase(); },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\"\n\t}, {\n\t    name: \"expandtoline\",\n\t    bindKey: bindKey(\"Ctrl-Shift-L\", \"Command-Shift-L\"),\n\t    exec: function(editor) {\n\t        var range = editor.selection.getRange();\n\n\t        range.start.column = range.end.column = 0;\n\t        range.end.row++;\n\t        editor.selection.setRange(range, false);\n\t    },\n\t    multiSelectAction: \"forEach\",\n\t    scrollIntoView: \"cursor\",\n\t    readOnly: true\n\t}, {\n\t    name: \"joinlines\",\n\t    bindKey: bindKey(null, null),\n\t    exec: function(editor) {\n\t        var isBackwards = editor.selection.isBackwards();\n\t        var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();\n\t        var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();\n\t        var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length\n\t        var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());\n\t        var selectedCount = selectedText.replace(/\\n\\s*/, \" \").length;\n\t        var insertLine = editor.session.doc.getLine(selectionStart.row);\n\n\t        for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {\n\t            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));\n\t            if (curLine.length !== 0) {\n\t                curLine = \" \" + curLine;\n\t            }\n\t            insertLine += curLine;\n\t        };\n\n\t        if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {\n\t            insertLine += editor.session.doc.getNewLineCharacter();\n\t        }\n\n\t        editor.clearSelection();\n\t        editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);\n\n\t        if (selectedCount > 0) {\n\t            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);\n\t            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);\n\t        } else {\n\t            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;\n\t            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);\n\t        }\n\t    },\n\t    multiSelectAction: \"forEach\",\n\t    readOnly: true\n\t}, {\n\t    name: \"invertSelection\",\n\t    bindKey: bindKey(null, null),\n\t    exec: function(editor) {\n\t        var endRow = editor.session.doc.getLength() - 1;\n\t        var endCol = editor.session.doc.getLine(endRow).length;\n\t        var ranges = editor.selection.rangeList.ranges;\n\t        var newRanges = [];\n\t        if (ranges.length < 1) {\n\t            ranges = [editor.selection.getRange()];\n\t        }\n\n\t        for (var i = 0; i < ranges.length; i++) {\n\t            if (i == (ranges.length - 1)) {\n\t                if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {\n\t                    newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));\n\t                }\n\t            }\n\n\t            if (i === 0) {\n\t                if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {\n\t                    newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));\n\t                }\n\t            } else {\n\t                newRanges.push(new Range(ranges[i-1].end.row, ranges[i-1].end.column, ranges[i].start.row, ranges[i].start.column));\n\t            }\n\t        }\n\n\t        editor.exitMultiSelectMode();\n\t        editor.clearSelection();\n\n\t        for(var i = 0; i < newRanges.length; i++) {\n\t            editor.selection.addRange(newRanges[i], false);\n\t        }\n\t    },\n\t    readOnly: true,\n\t    scrollIntoView: \"none\"\n\t}];\n\n\t});\n\n\tace.define(\"ace/editor\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/keyboard/textinput\",\"ace/mouse/mouse_handler\",\"ace/mouse/fold_handler\",\"ace/keyboard/keybinding\",\"ace/edit_session\",\"ace/search\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/commands/command_manager\",\"ace/commands/default_commands\",\"ace/config\",\"ace/token_iterator\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tacequire(\"./lib/fixoldbrowsers\");\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar dom = acequire(\"./lib/dom\");\n\tvar lang = acequire(\"./lib/lang\");\n\tvar useragent = acequire(\"./lib/useragent\");\n\tvar TextInput = acequire(\"./keyboard/textinput\").TextInput;\n\tvar MouseHandler = acequire(\"./mouse/mouse_handler\").MouseHandler;\n\tvar FoldHandler = acequire(\"./mouse/fold_handler\").FoldHandler;\n\tvar KeyBinding = acequire(\"./keyboard/keybinding\").KeyBinding;\n\tvar EditSession = acequire(\"./edit_session\").EditSession;\n\tvar Search = acequire(\"./search\").Search;\n\tvar Range = acequire(\"./range\").Range;\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar CommandManager = acequire(\"./commands/command_manager\").CommandManager;\n\tvar defaultCommands = acequire(\"./commands/default_commands\").commands;\n\tvar config = acequire(\"./config\");\n\tvar TokenIterator = acequire(\"./token_iterator\").TokenIterator;\n\tvar Editor = function(renderer, session) {\n\t    var container = renderer.getContainerElement();\n\t    this.container = container;\n\t    this.renderer = renderer;\n\n\t    this.commands = new CommandManager(useragent.isMac ? \"mac\" : \"win\", defaultCommands);\n\t    this.textInput  = new TextInput(renderer.getTextAreaContainer(), this);\n\t    this.renderer.textarea = this.textInput.getElement();\n\t    this.keyBinding = new KeyBinding(this);\n\t    this.$mouseHandler = new MouseHandler(this);\n\t    new FoldHandler(this);\n\n\t    this.$blockScrolling = 0;\n\t    this.$search = new Search().set({\n\t        wrap: true\n\t    });\n\n\t    this.$historyTracker = this.$historyTracker.bind(this);\n\t    this.commands.on(\"exec\", this.$historyTracker);\n\n\t    this.$initOperationListeners();\n\t    \n\t    this._$emitInputEvent = lang.delayedCall(function() {\n\t        this._signal(\"input\", {});\n\t        if (this.session && this.session.bgTokenizer)\n\t            this.session.bgTokenizer.scheduleStart();\n\t    }.bind(this));\n\t    \n\t    this.on(\"change\", function(_, _self) {\n\t        _self._$emitInputEvent.schedule(31);\n\t    });\n\n\t    this.setSession(session || new EditSession(\"\"));\n\t    config.resetOptions(this);\n\t    config._signal(\"editor\", this);\n\t};\n\n\t(function(){\n\n\t    oop.implement(this, EventEmitter);\n\n\t    this.$initOperationListeners = function() {\n\t        function last(a) {return a[a.length - 1]}\n\n\t        this.selections = [];\n\t        this.commands.on(\"exec\", this.startOperation.bind(this), true);\n\t        this.commands.on(\"afterExec\", this.endOperation.bind(this), true);\n\n\t        this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));\n\n\t        this.on(\"change\", function() {\n\t            this.curOp || this.startOperation();\n\t            this.curOp.docChanged = true;\n\t        }.bind(this), true);\n\n\t        this.on(\"changeSelection\", function() {\n\t            this.curOp || this.startOperation();\n\t            this.curOp.selectionChanged = true;\n\t        }.bind(this), true);\n\t    };\n\n\t    this.curOp = null;\n\t    this.prevOp = {};\n\t    this.startOperation = function(commadEvent) {\n\t        if (this.curOp) {\n\t            if (!commadEvent || this.curOp.command)\n\t                return;\n\t            this.prevOp = this.curOp;\n\t        }\n\t        if (!commadEvent) {\n\t            this.previousCommand = null;\n\t            commadEvent = {};\n\t        }\n\n\t        this.$opResetTimer.schedule();\n\t        this.curOp = {\n\t            command: commadEvent.command || {},\n\t            args: commadEvent.args,\n\t            scrollTop: this.renderer.scrollTop\n\t        };\n\t    };\n\n\t    this.endOperation = function(e) {\n\t        if (this.curOp) {\n\t            if (e && e.returnValue === false)\n\t                return this.curOp = null;\n\n\t            var command = this.curOp.command;\n\t            if (command && command.scrollIntoView) {\n\t                switch (command.scrollIntoView) {\n\t                    case \"center\":\n\t                        this.renderer.scrollCursorIntoView(null, 0.5);\n\t                        break;\n\t                    case \"animate\":\n\t                    case \"cursor\":\n\t                        this.renderer.scrollCursorIntoView();\n\t                        break;\n\t                    case \"selectionPart\":\n\t                        var range = this.selection.getRange();\n\t                        var config = this.renderer.layerConfig;\n\t                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {\n\t                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);\n\t                        }\n\t                        break;\n\t                    default:\n\t                        break;\n\t                }\n\t                if (command.scrollIntoView == \"animate\")\n\t                    this.renderer.animateScrolling(this.curOp.scrollTop);\n\t            }\n\t            \n\t            this.prevOp = this.curOp;\n\t            this.curOp = null;\n\t        }\n\t    };\n\t    this.$mergeableCommands = [\"backspace\", \"del\", \"insertstring\"];\n\t    this.$historyTracker = function(e) {\n\t        if (!this.$mergeUndoDeltas)\n\t            return;\n\n\t        var prev = this.prevOp;\n\t        var mergeableCommands = this.$mergeableCommands;\n\t        var shouldMerge = prev.command && (e.command.name == prev.command.name);\n\t        if (e.command.name == \"insertstring\") {\n\t            var text = e.args;\n\t            if (this.mergeNextCommand === undefined)\n\t                this.mergeNextCommand = true;\n\n\t            shouldMerge = shouldMerge\n\t                && this.mergeNextCommand // previous command allows to coalesce with\n\t                && (!/\\s/.test(text) || /\\s/.test(prev.args)); // previous insertion was of same type\n\n\t            this.mergeNextCommand = true;\n\t        } else {\n\t            shouldMerge = shouldMerge\n\t                && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable\n\t        }\n\n\t        if (\n\t            this.$mergeUndoDeltas != \"always\"\n\t            && Date.now() - this.sequenceStartTime > 2000\n\t        ) {\n\t            shouldMerge = false; // the sequence is too long\n\t        }\n\n\t        if (shouldMerge)\n\t            this.session.mergeUndoDeltas = true;\n\t        else if (mergeableCommands.indexOf(e.command.name) !== -1)\n\t            this.sequenceStartTime = Date.now();\n\t    };\n\t    this.setKeyboardHandler = function(keyboardHandler, cb) {\n\t        if (keyboardHandler && typeof keyboardHandler === \"string\") {\n\t            this.$keybindingId = keyboardHandler;\n\t            var _self = this;\n\t            config.loadModule([\"keybinding\", keyboardHandler], function(module) {\n\t                if (_self.$keybindingId == keyboardHandler)\n\t                    _self.keyBinding.setKeyboardHandler(module && module.handler);\n\t                cb && cb();\n\t            });\n\t        } else {\n\t            this.$keybindingId = null;\n\t            this.keyBinding.setKeyboardHandler(keyboardHandler);\n\t            cb && cb();\n\t        }\n\t    };\n\t    this.getKeyboardHandler = function() {\n\t        return this.keyBinding.getKeyboardHandler();\n\t    };\n\t    this.setSession = function(session) {\n\t        if (this.session == session)\n\t            return;\n\n\t        var oldSession = this.session;\n\t        if (oldSession) {\n\t            this.session.removeEventListener(\"change\", this.$onDocumentChange);\n\t            this.session.removeEventListener(\"changeMode\", this.$onChangeMode);\n\t            this.session.removeEventListener(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n\t            this.session.removeEventListener(\"changeTabSize\", this.$onChangeTabSize);\n\t            this.session.removeEventListener(\"changeWrapLimit\", this.$onChangeWrapLimit);\n\t            this.session.removeEventListener(\"changeWrapMode\", this.$onChangeWrapMode);\n\t            this.session.removeEventListener(\"onChangeFold\", this.$onChangeFold);\n\t            this.session.removeEventListener(\"changeFrontMarker\", this.$onChangeFrontMarker);\n\t            this.session.removeEventListener(\"changeBackMarker\", this.$onChangeBackMarker);\n\t            this.session.removeEventListener(\"changeBreakpoint\", this.$onChangeBreakpoint);\n\t            this.session.removeEventListener(\"changeAnnotation\", this.$onChangeAnnotation);\n\t            this.session.removeEventListener(\"changeOverwrite\", this.$onCursorChange);\n\t            this.session.removeEventListener(\"changeScrollTop\", this.$onScrollTopChange);\n\t            this.session.removeEventListener(\"changeScrollLeft\", this.$onScrollLeftChange);\n\n\t            var selection = this.session.getSelection();\n\t            selection.removeEventListener(\"changeCursor\", this.$onCursorChange);\n\t            selection.removeEventListener(\"changeSelection\", this.$onSelectionChange);\n\t        }\n\n\t        this.session = session;\n\t        if (session) {\n\t            this.$onDocumentChange = this.onDocumentChange.bind(this);\n\t            session.addEventListener(\"change\", this.$onDocumentChange);\n\t            this.renderer.setSession(session);\n\t    \n\t            this.$onChangeMode = this.onChangeMode.bind(this);\n\t            session.addEventListener(\"changeMode\", this.$onChangeMode);\n\t    \n\t            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);\n\t            session.addEventListener(\"tokenizerUpdate\", this.$onTokenizerUpdate);\n\t    \n\t            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);\n\t            session.addEventListener(\"changeTabSize\", this.$onChangeTabSize);\n\t    \n\t            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);\n\t            session.addEventListener(\"changeWrapLimit\", this.$onChangeWrapLimit);\n\t    \n\t            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);\n\t            session.addEventListener(\"changeWrapMode\", this.$onChangeWrapMode);\n\t    \n\t            this.$onChangeFold = this.onChangeFold.bind(this);\n\t            session.addEventListener(\"changeFold\", this.$onChangeFold);\n\t    \n\t            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);\n\t            this.session.addEventListener(\"changeFrontMarker\", this.$onChangeFrontMarker);\n\t    \n\t            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);\n\t            this.session.addEventListener(\"changeBackMarker\", this.$onChangeBackMarker);\n\t    \n\t            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);\n\t            this.session.addEventListener(\"changeBreakpoint\", this.$onChangeBreakpoint);\n\t    \n\t            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);\n\t            this.session.addEventListener(\"changeAnnotation\", this.$onChangeAnnotation);\n\t    \n\t            this.$onCursorChange = this.onCursorChange.bind(this);\n\t            this.session.addEventListener(\"changeOverwrite\", this.$onCursorChange);\n\t    \n\t            this.$onScrollTopChange = this.onScrollTopChange.bind(this);\n\t            this.session.addEventListener(\"changeScrollTop\", this.$onScrollTopChange);\n\t    \n\t            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);\n\t            this.session.addEventListener(\"changeScrollLeft\", this.$onScrollLeftChange);\n\t    \n\t            this.selection = session.getSelection();\n\t            this.selection.addEventListener(\"changeCursor\", this.$onCursorChange);\n\t    \n\t            this.$onSelectionChange = this.onSelectionChange.bind(this);\n\t            this.selection.addEventListener(\"changeSelection\", this.$onSelectionChange);\n\t    \n\t            this.onChangeMode();\n\t    \n\t            this.$blockScrolling += 1;\n\t            this.onCursorChange();\n\t            this.$blockScrolling -= 1;\n\t    \n\t            this.onScrollTopChange();\n\t            this.onScrollLeftChange();\n\t            this.onSelectionChange();\n\t            this.onChangeFrontMarker();\n\t            this.onChangeBackMarker();\n\t            this.onChangeBreakpoint();\n\t            this.onChangeAnnotation();\n\t            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();\n\t            this.renderer.updateFull();\n\t        } else {\n\t            this.selection = null;\n\t            this.renderer.setSession(session);\n\t        }\n\n\t        this._signal(\"changeSession\", {\n\t            session: session,\n\t            oldSession: oldSession\n\t        });\n\t        \n\t        oldSession && oldSession._signal(\"changeEditor\", {oldEditor: this});\n\t        session && session._signal(\"changeEditor\", {editor: this});\n\t    };\n\t    this.getSession = function() {\n\t        return this.session;\n\t    };\n\t    this.setValue = function(val, cursorPos) {\n\t        this.session.doc.setValue(val);\n\n\t        if (!cursorPos)\n\t            this.selectAll();\n\t        else if (cursorPos == 1)\n\t            this.navigateFileEnd();\n\t        else if (cursorPos == -1)\n\t            this.navigateFileStart();\n\n\t        return val;\n\t    };\n\t    this.getValue = function() {\n\t        return this.session.getValue();\n\t    };\n\t    this.getSelection = function() {\n\t        return this.selection;\n\t    };\n\t    this.resize = function(force) {\n\t        this.renderer.onResize(force);\n\t    };\n\t    this.setTheme = function(theme, cb) {\n\t        this.renderer.setTheme(theme, cb);\n\t    };\n\t    this.getTheme = function() {\n\t        return this.renderer.getTheme();\n\t    };\n\t    this.setStyle = function(style) {\n\t        this.renderer.setStyle(style);\n\t    };\n\t    this.unsetStyle = function(style) {\n\t        this.renderer.unsetStyle(style);\n\t    };\n\t    this.getFontSize = function () {\n\t        return this.getOption(\"fontSize\") ||\n\t           dom.computedStyle(this.container, \"fontSize\");\n\t    };\n\t    this.setFontSize = function(size) {\n\t        this.setOption(\"fontSize\", size);\n\t    };\n\n\t    this.$highlightBrackets = function() {\n\t        if (this.session.$bracketHighlight) {\n\t            this.session.removeMarker(this.session.$bracketHighlight);\n\t            this.session.$bracketHighlight = null;\n\t        }\n\n\t        if (this.$highlightPending) {\n\t            return;\n\t        }\n\t        var self = this;\n\t        this.$highlightPending = true;\n\t        setTimeout(function() {\n\t            self.$highlightPending = false;\n\t            var session = self.session;\n\t            if (!session || !session.bgTokenizer) return;\n\t            var pos = session.findMatchingBracket(self.getCursorPosition());\n\t            if (pos) {\n\t                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);\n\t            } else if (session.$mode.getMatching) {\n\t                var range = session.$mode.getMatching(self.session);\n\t            }\n\t            if (range)\n\t                session.$bracketHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n\t        }, 50);\n\t    };\n\t    this.$highlightTags = function() {\n\t        if (this.$highlightTagPending)\n\t            return;\n\t        var self = this;\n\t        this.$highlightTagPending = true;\n\t        setTimeout(function() {\n\t            self.$highlightTagPending = false;\n\t            \n\t            var session = self.session;\n\t            if (!session || !session.bgTokenizer) return;\n\t            \n\t            var pos = self.getCursorPosition();\n\t            var iterator = new TokenIterator(self.session, pos.row, pos.column);\n\t            var token = iterator.getCurrentToken();\n\t            \n\t            if (!token || token.type.indexOf('tag-name') === -1) {\n\t                session.removeMarker(session.$tagHighlight);\n\t                session.$tagHighlight = null;\n\t                return;\n\t            }\n\n\t            var tag = token.value;\n\t            var depth = 0;\n\t            var prevToken = iterator.stepBackward();\n\t            \n\t            if (prevToken.value == '<'){\n\t                do {\n\t                    prevToken = token;\n\t                    token = iterator.stepForward();\n\t                    \n\t                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n\t                        if (prevToken.value === '<'){\n\t                            depth++;\n\t                        } else if (prevToken.value === '</'){\n\t                            depth--;\n\t                        }\n\t                    }\n\t                    \n\t                } while (token && depth >= 0);\n\t            } else {\n\t                do {\n\t                    token = prevToken;\n\t                    prevToken = iterator.stepBackward();\n\t                    \n\t                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {\n\t                        if (prevToken.value === '<') {\n\t                            depth++;\n\t                        } else if (prevToken.value === '</') {\n\t                            depth--;\n\t                        }\n\t                    }\n\t                } while (prevToken && depth <= 0);\n\t                iterator.stepForward();\n\t            }\n\t            \n\t            if (!token) {\n\t                session.removeMarker(session.$tagHighlight);\n\t                session.$tagHighlight = null;\n\t                return;\n\t            }\n\t            \n\t            var row = iterator.getCurrentTokenRow();\n\t            var column = iterator.getCurrentTokenColumn();\n\t            var range = new Range(row, column, row, column+token.value.length);\n\t            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range)!==0) {\n\t                session.removeMarker(session.$tagHighlight);\n\t                session.$tagHighlight = null;\n\t            }\n\t            \n\t            if (range && !session.$tagHighlight)\n\t                session.$tagHighlight = session.addMarker(range, \"ace_bracket\", \"text\");\n\t        }, 50);\n\t    };\n\t    this.focus = function() {\n\t        var _self = this;\n\t        setTimeout(function() {\n\t            _self.textInput.focus();\n\t        });\n\t        this.textInput.focus();\n\t    };\n\t    this.isFocused = function() {\n\t        return this.textInput.isFocused();\n\t    };\n\t    this.blur = function() {\n\t        this.textInput.blur();\n\t    };\n\t    this.onFocus = function(e) {\n\t        if (this.$isFocused)\n\t            return;\n\t        this.$isFocused = true;\n\t        this.renderer.showCursor();\n\t        this.renderer.visualizeFocus();\n\t        this._emit(\"focus\", e);\n\t    };\n\t    this.onBlur = function(e) {\n\t        if (!this.$isFocused)\n\t            return;\n\t        this.$isFocused = false;\n\t        this.renderer.hideCursor();\n\t        this.renderer.visualizeBlur();\n\t        this._emit(\"blur\", e);\n\t    };\n\n\t    this.$cursorChange = function() {\n\t        this.renderer.updateCursor();\n\t    };\n\t    this.onDocumentChange = function(e) {\n\t        var delta = e.data;\n\t        var range = delta.range;\n\t        var lastRow;\n\n\t        if (range.start.row == range.end.row && delta.action != \"insertLines\" && delta.action != \"removeLines\")\n\t            lastRow = range.end.row;\n\t        else\n\t            lastRow = Infinity;\n\t        this.renderer.updateLines(range.start.row, lastRow, this.session.$useWrapMode);\n\n\t        this._signal(\"change\", e);\n\t        this.$cursorChange();\n\t        this.$updateHighlightActiveLine();\n\t    };\n\n\t    this.onTokenizerUpdate = function(e) {\n\t        var rows = e.data;\n\t        this.renderer.updateLines(rows.first, rows.last);\n\t    };\n\n\n\t    this.onScrollTopChange = function() {\n\t        this.renderer.scrollToY(this.session.getScrollTop());\n\t    };\n\n\t    this.onScrollLeftChange = function() {\n\t        this.renderer.scrollToX(this.session.getScrollLeft());\n\t    };\n\t    this.onCursorChange = function() {\n\t        this.$cursorChange();\n\n\t        if (!this.$blockScrolling) {\n\t            this.renderer.scrollCursorIntoView();\n\t        }\n\n\t        this.$highlightBrackets();\n\t        this.$highlightTags();\n\t        this.$updateHighlightActiveLine();\n\t        this._signal(\"changeSelection\");\n\t    };\n\n\t    this.$updateHighlightActiveLine = function() {\n\t        var session = this.getSession();\n\n\t        var highlight;\n\t        if (this.$highlightActiveLine) {\n\t            if ((this.$selectionStyle != \"line\" || !this.selection.isMultiLine()))\n\t                highlight = this.getCursorPosition();\n\t            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))\n\t                highlight = false;\n\t        }\n\n\t        if (session.$highlightLineMarker && !highlight) {\n\t            session.removeMarker(session.$highlightLineMarker.id);\n\t            session.$highlightLineMarker = null;\n\t        } else if (!session.$highlightLineMarker && highlight) {\n\t            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);\n\t            range.id = session.addMarker(range, \"ace_active-line\", \"screenLine\");\n\t            session.$highlightLineMarker = range;\n\t        } else if (highlight) {\n\t            session.$highlightLineMarker.start.row = highlight.row;\n\t            session.$highlightLineMarker.end.row = highlight.row;\n\t            session.$highlightLineMarker.start.column = highlight.column;\n\t            session._signal(\"changeBackMarker\");\n\t        }\n\t    };\n\n\t    this.onSelectionChange = function(e) {\n\t        var session = this.session;\n\n\t        if (session.$selectionMarker) {\n\t            session.removeMarker(session.$selectionMarker);\n\t        }\n\t        session.$selectionMarker = null;\n\n\t        if (!this.selection.isEmpty()) {\n\t            var range = this.selection.getRange();\n\t            var style = this.getSelectionStyle();\n\t            session.$selectionMarker = session.addMarker(range, \"ace_selection\", style);\n\t        } else {\n\t            this.$updateHighlightActiveLine();\n\t        }\n\n\t        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();\n\t        this.session.highlight(re);\n\n\t        this._signal(\"changeSelection\");\n\t    };\n\n\t    this.$getSelectionHighLightRegexp = function() {\n\t        var session = this.session;\n\n\t        var selection = this.getSelectionRange();\n\t        if (selection.isEmpty() || selection.isMultiLine())\n\t            return;\n\n\t        var startOuter = selection.start.column - 1;\n\t        var endOuter = selection.end.column + 1;\n\t        var line = session.getLine(selection.start.row);\n\t        var lineCols = line.length;\n\t        var needle = line.substring(Math.max(startOuter, 0),\n\t                                    Math.min(endOuter, lineCols));\n\t        if ((startOuter >= 0 && /^[\\w\\d]/.test(needle)) ||\n\t            (endOuter <= lineCols && /[\\w\\d]$/.test(needle)))\n\t            return;\n\n\t        needle = line.substring(selection.start.column, selection.end.column);\n\t        if (!/^[\\w\\d]+$/.test(needle))\n\t            return;\n\n\t        var re = this.$search.$assembleRegExp({\n\t            wholeWord: true,\n\t            caseSensitive: true,\n\t            needle: needle\n\t        });\n\n\t        return re;\n\t    };\n\n\n\t    this.onChangeFrontMarker = function() {\n\t        this.renderer.updateFrontMarkers();\n\t    };\n\n\t    this.onChangeBackMarker = function() {\n\t        this.renderer.updateBackMarkers();\n\t    };\n\n\n\t    this.onChangeBreakpoint = function() {\n\t        this.renderer.updateBreakpoints();\n\t    };\n\n\t    this.onChangeAnnotation = function() {\n\t        this.renderer.setAnnotations(this.session.getAnnotations());\n\t    };\n\n\n\t    this.onChangeMode = function(e) {\n\t        this.renderer.updateText();\n\t        this._emit(\"changeMode\", e);\n\t    };\n\n\n\t    this.onChangeWrapLimit = function() {\n\t        this.renderer.updateFull();\n\t    };\n\n\t    this.onChangeWrapMode = function() {\n\t        this.renderer.onResize(true);\n\t    };\n\n\n\t    this.onChangeFold = function() {\n\t        this.$updateHighlightActiveLine();\n\t        this.renderer.updateFull();\n\t    };\n\t    this.getSelectedText = function() {\n\t        return this.session.getTextRange(this.getSelectionRange());\n\t    };\n\t    this.getCopyText = function() {\n\t        var text = this.getSelectedText();\n\t        this._signal(\"copy\", text);\n\t        return text;\n\t    };\n\t    this.onCopy = function() {\n\t        this.commands.exec(\"copy\", this);\n\t    };\n\t    this.onCut = function() {\n\t        this.commands.exec(\"cut\", this);\n\t    };\n\t    this.onPaste = function(text) {\n\t        if (this.$readOnly)\n\t            return;\n\t        var e = {text: text};\n\t        this._signal(\"paste\", e);\n\t        this.insert(e.text, true);\n\t    };\n\n\t    this.execCommand = function(command, args) {\n\t        return this.commands.exec(command, this, args);\n\t    };\n\t    this.insert = function(text, pasted) {\n\t        var session = this.session;\n\t        var mode = session.getMode();\n\t        var cursor = this.getCursorPosition();\n\n\t        if (this.getBehavioursEnabled() && !pasted) {\n\t            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);\n\t            if (transform) {\n\t                if (text !== transform.text) {\n\t                    this.session.mergeUndoDeltas = false;\n\t                    this.$mergeNextCommand = false;\n\t                }\n\t                text = transform.text;\n\n\t            }\n\t        }\n\t        \n\t        if (text == \"\\t\")\n\t            text = this.session.getTabString();\n\t        if (!this.selection.isEmpty()) {\n\t            var range = this.getSelectionRange();\n\t            cursor = this.session.remove(range);\n\t            this.clearSelection();\n\t        }\n\t        else if (this.session.getOverwrite()) {\n\t            var range = new Range.fromPoints(cursor, cursor);\n\t            range.end.column += text.length;\n\t            this.session.remove(range);\n\t        }\n\n\t        if (text == \"\\n\" || text == \"\\r\\n\") {\n\t            var line = session.getLine(cursor.row);\n\t            if (cursor.column > line.search(/\\S|$/)) {\n\t                var d = line.substr(cursor.column).search(/\\S|$/);\n\t                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);\n\t            }\n\t        }\n\t        this.clearSelection();\n\n\t        var start = cursor.column;\n\t        var lineState = session.getState(cursor.row);\n\t        var line = session.getLine(cursor.row);\n\t        var shouldOutdent = mode.checkOutdent(lineState, line, text);\n\t        var end = session.insert(cursor, text);\n\n\t        if (transform && transform.selection) {\n\t            if (transform.selection.length == 2) { // Transform relative to the current column\n\t                this.selection.setSelectionRange(\n\t                    new Range(cursor.row, start + transform.selection[0],\n\t                              cursor.row, start + transform.selection[1]));\n\t            } else { // Transform relative to the current row.\n\t                this.selection.setSelectionRange(\n\t                    new Range(cursor.row + transform.selection[0],\n\t                              transform.selection[1],\n\t                              cursor.row + transform.selection[2],\n\t                              transform.selection[3]));\n\t            }\n\t        }\n\n\t        if (session.getDocument().isNewLine(text)) {\n\t            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());\n\n\t            session.insert({row: cursor.row+1, column: 0}, lineIndent);\n\t        }\n\t        if (shouldOutdent)\n\t            mode.autoOutdent(lineState, session, cursor.row);\n\t    };\n\n\t    this.onTextInput = function(text) {\n\t        this.keyBinding.onTextInput(text);\n\t    };\n\n\t    this.onCommandKey = function(e, hashId, keyCode) {\n\t        this.keyBinding.onCommandKey(e, hashId, keyCode);\n\t    };\n\t    this.setOverwrite = function(overwrite) {\n\t        this.session.setOverwrite(overwrite);\n\t    };\n\t    this.getOverwrite = function() {\n\t        return this.session.getOverwrite();\n\t    };\n\t    this.toggleOverwrite = function() {\n\t        this.session.toggleOverwrite();\n\t    };\n\t    this.setScrollSpeed = function(speed) {\n\t        this.setOption(\"scrollSpeed\", speed);\n\t    };\n\t    this.getScrollSpeed = function() {\n\t        return this.getOption(\"scrollSpeed\");\n\t    };\n\t    this.setDragDelay = function(dragDelay) {\n\t        this.setOption(\"dragDelay\", dragDelay);\n\t    };\n\t    this.getDragDelay = function() {\n\t        return this.getOption(\"dragDelay\");\n\t    };\n\t    this.setSelectionStyle = function(val) {\n\t        this.setOption(\"selectionStyle\", val);\n\t    };\n\t    this.getSelectionStyle = function() {\n\t        return this.getOption(\"selectionStyle\");\n\t    };\n\t    this.setHighlightActiveLine = function(shouldHighlight) {\n\t        this.setOption(\"highlightActiveLine\", shouldHighlight);\n\t    };\n\t    this.getHighlightActiveLine = function() {\n\t        return this.getOption(\"highlightActiveLine\");\n\t    };\n\t    this.setHighlightGutterLine = function(shouldHighlight) {\n\t        this.setOption(\"highlightGutterLine\", shouldHighlight);\n\t    };\n\n\t    this.getHighlightGutterLine = function() {\n\t        return this.getOption(\"highlightGutterLine\");\n\t    };\n\t    this.setHighlightSelectedWord = function(shouldHighlight) {\n\t        this.setOption(\"highlightSelectedWord\", shouldHighlight);\n\t    };\n\t    this.getHighlightSelectedWord = function() {\n\t        return this.$highlightSelectedWord;\n\t    };\n\n\t    this.setAnimatedScroll = function(shouldAnimate){\n\t        this.renderer.setAnimatedScroll(shouldAnimate);\n\t    };\n\n\t    this.getAnimatedScroll = function(){\n\t        return this.renderer.getAnimatedScroll();\n\t    };\n\t    this.setShowInvisibles = function(showInvisibles) {\n\t        this.renderer.setShowInvisibles(showInvisibles);\n\t    };\n\t    this.getShowInvisibles = function() {\n\t        return this.renderer.getShowInvisibles();\n\t    };\n\n\t    this.setDisplayIndentGuides = function(display) {\n\t        this.renderer.setDisplayIndentGuides(display);\n\t    };\n\n\t    this.getDisplayIndentGuides = function() {\n\t        return this.renderer.getDisplayIndentGuides();\n\t    };\n\t    this.setShowPrintMargin = function(showPrintMargin) {\n\t        this.renderer.setShowPrintMargin(showPrintMargin);\n\t    };\n\t    this.getShowPrintMargin = function() {\n\t        return this.renderer.getShowPrintMargin();\n\t    };\n\t    this.setPrintMarginColumn = function(showPrintMargin) {\n\t        this.renderer.setPrintMarginColumn(showPrintMargin);\n\t    };\n\t    this.getPrintMarginColumn = function() {\n\t        return this.renderer.getPrintMarginColumn();\n\t    };\n\t    this.setReadOnly = function(readOnly) {\n\t        this.setOption(\"readOnly\", readOnly);\n\t    };\n\t    this.getReadOnly = function() {\n\t        return this.getOption(\"readOnly\");\n\t    };\n\t    this.setBehavioursEnabled = function (enabled) {\n\t        this.setOption(\"behavioursEnabled\", enabled);\n\t    };\n\t    this.getBehavioursEnabled = function () {\n\t        return this.getOption(\"behavioursEnabled\");\n\t    };\n\t    this.setWrapBehavioursEnabled = function (enabled) {\n\t        this.setOption(\"wrapBehavioursEnabled\", enabled);\n\t    };\n\t    this.getWrapBehavioursEnabled = function () {\n\t        return this.getOption(\"wrapBehavioursEnabled\");\n\t    };\n\t    this.setShowFoldWidgets = function(show) {\n\t        this.setOption(\"showFoldWidgets\", show);\n\n\t    };\n\t    this.getShowFoldWidgets = function() {\n\t        return this.getOption(\"showFoldWidgets\");\n\t    };\n\n\t    this.setFadeFoldWidgets = function(fade) {\n\t        this.setOption(\"fadeFoldWidgets\", fade);\n\t    };\n\n\t    this.getFadeFoldWidgets = function() {\n\t        return this.getOption(\"fadeFoldWidgets\");\n\t    };\n\t    this.remove = function(dir) {\n\t        if (this.selection.isEmpty()){\n\t            if (dir == \"left\")\n\t                this.selection.selectLeft();\n\t            else\n\t                this.selection.selectRight();\n\t        }\n\n\t        var range = this.getSelectionRange();\n\t        if (this.getBehavioursEnabled()) {\n\t            var session = this.session;\n\t            var state = session.getState(range.start.row);\n\t            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);\n\n\t            if (range.end.column === 0) {\n\t                var text = session.getTextRange(range);\n\t                if (text[text.length - 1] == \"\\n\") {\n\t                    var line = session.getLine(range.end.row);\n\t                    if (/^\\s+$/.test(line)) {\n\t                        range.end.column = line.length;\n\t                    }\n\t                }\n\t            }\n\t            if (new_range)\n\t                range = new_range;\n\t        }\n\n\t        this.session.remove(range);\n\t        this.clearSelection();\n\t    };\n\t    this.removeWordRight = function() {\n\t        if (this.selection.isEmpty())\n\t            this.selection.selectWordRight();\n\n\t        this.session.remove(this.getSelectionRange());\n\t        this.clearSelection();\n\t    };\n\t    this.removeWordLeft = function() {\n\t        if (this.selection.isEmpty())\n\t            this.selection.selectWordLeft();\n\n\t        this.session.remove(this.getSelectionRange());\n\t        this.clearSelection();\n\t    };\n\t    this.removeToLineStart = function() {\n\t        if (this.selection.isEmpty())\n\t            this.selection.selectLineStart();\n\n\t        this.session.remove(this.getSelectionRange());\n\t        this.clearSelection();\n\t    };\n\t    this.removeToLineEnd = function() {\n\t        if (this.selection.isEmpty())\n\t            this.selection.selectLineEnd();\n\n\t        var range = this.getSelectionRange();\n\t        if (range.start.column == range.end.column && range.start.row == range.end.row) {\n\t            range.end.column = 0;\n\t            range.end.row++;\n\t        }\n\n\t        this.session.remove(range);\n\t        this.clearSelection();\n\t    };\n\t    this.splitLine = function() {\n\t        if (!this.selection.isEmpty()) {\n\t            this.session.remove(this.getSelectionRange());\n\t            this.clearSelection();\n\t        }\n\n\t        var cursor = this.getCursorPosition();\n\t        this.insert(\"\\n\");\n\t        this.moveCursorToPosition(cursor);\n\t    };\n\t    this.transposeLetters = function() {\n\t        if (!this.selection.isEmpty()) {\n\t            return;\n\t        }\n\n\t        var cursor = this.getCursorPosition();\n\t        var column = cursor.column;\n\t        if (column === 0)\n\t            return;\n\n\t        var line = this.session.getLine(cursor.row);\n\t        var swap, range;\n\t        if (column < line.length) {\n\t            swap = line.charAt(column) + line.charAt(column-1);\n\t            range = new Range(cursor.row, column-1, cursor.row, column+1);\n\t        }\n\t        else {\n\t            swap = line.charAt(column-1) + line.charAt(column-2);\n\t            range = new Range(cursor.row, column-2, cursor.row, column);\n\t        }\n\t        this.session.replace(range, swap);\n\t    };\n\t    this.toLowerCase = function() {\n\t        var originalRange = this.getSelectionRange();\n\t        if (this.selection.isEmpty()) {\n\t            this.selection.selectWord();\n\t        }\n\n\t        var range = this.getSelectionRange();\n\t        var text = this.session.getTextRange(range);\n\t        this.session.replace(range, text.toLowerCase());\n\t        this.selection.setSelectionRange(originalRange);\n\t    };\n\t    this.toUpperCase = function() {\n\t        var originalRange = this.getSelectionRange();\n\t        if (this.selection.isEmpty()) {\n\t            this.selection.selectWord();\n\t        }\n\n\t        var range = this.getSelectionRange();\n\t        var text = this.session.getTextRange(range);\n\t        this.session.replace(range, text.toUpperCase());\n\t        this.selection.setSelectionRange(originalRange);\n\t    };\n\t    this.indent = function() {\n\t        var session = this.session;\n\t        var range = this.getSelectionRange();\n\n\t        if (range.start.row < range.end.row) {\n\t            var rows = this.$getSelectedRows();\n\t            session.indentRows(rows.first, rows.last, \"\\t\");\n\t            return;\n\t        } else if (range.start.column < range.end.column) {\n\t            var text = session.getTextRange(range);\n\t            if (!/^\\s+$/.test(text)) {\n\t                var rows = this.$getSelectedRows();\n\t                session.indentRows(rows.first, rows.last, \"\\t\");\n\t                return;\n\t            }\n\t        }\n\t        \n\t        var line = session.getLine(range.start.row);\n\t        var position = range.start;\n\t        var size = session.getTabSize();\n\t        var column = session.documentToScreenColumn(position.row, position.column);\n\n\t        if (this.session.getUseSoftTabs()) {\n\t            var count = (size - column % size);\n\t            var indentString = lang.stringRepeat(\" \", count);\n\t        } else {\n\t            var count = column % size;\n\t            while (line[range.start.column] == \" \" && count) {\n\t                range.start.column--;\n\t                count--;\n\t            }\n\t            this.selection.setSelectionRange(range);\n\t            indentString = \"\\t\";\n\t        }\n\t        return this.insert(indentString);\n\t    };\n\t    this.blockIndent = function() {\n\t        var rows = this.$getSelectedRows();\n\t        this.session.indentRows(rows.first, rows.last, \"\\t\");\n\t    };\n\t    this.blockOutdent = function() {\n\t        var selection = this.session.getSelection();\n\t        this.session.outdentRows(selection.getRange());\n\t    };\n\t    this.sortLines = function() {\n\t        var rows = this.$getSelectedRows();\n\t        var session = this.session;\n\n\t        var lines = [];\n\t        for (i = rows.first; i <= rows.last; i++)\n\t            lines.push(session.getLine(i));\n\n\t        lines.sort(function(a, b) {\n\t            if (a.toLowerCase() < b.toLowerCase()) return -1;\n\t            if (a.toLowerCase() > b.toLowerCase()) return 1;\n\t            return 0;\n\t        });\n\n\t        var deleteRange = new Range(0, 0, 0, 0);\n\t        for (var i = rows.first; i <= rows.last; i++) {\n\t            var line = session.getLine(i);\n\t            deleteRange.start.row = i;\n\t            deleteRange.end.row = i;\n\t            deleteRange.end.column = line.length;\n\t            session.replace(deleteRange, lines[i-rows.first]);\n\t        }\n\t    };\n\t    this.toggleCommentLines = function() {\n\t        var state = this.session.getState(this.getCursorPosition().row);\n\t        var rows = this.$getSelectedRows();\n\t        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);\n\t    };\n\n\t    this.toggleBlockComment = function() {\n\t        var cursor = this.getCursorPosition();\n\t        var state = this.session.getState(cursor.row);\n\t        var range = this.getSelectionRange();\n\t        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);\n\t    };\n\t    this.getNumberAt = function(row, column) {\n\t        var _numberRx = /[\\-]?[0-9]+(?:\\.[0-9]+)?/g;\n\t        _numberRx.lastIndex = 0;\n\n\t        var s = this.session.getLine(row);\n\t        while (_numberRx.lastIndex < column) {\n\t            var m = _numberRx.exec(s);\n\t            if(m.index <= column && m.index+m[0].length >= column){\n\t                var number = {\n\t                    value: m[0],\n\t                    start: m.index,\n\t                    end: m.index+m[0].length\n\t                };\n\t                return number;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    this.modifyNumber = function(amount) {\n\t        var row = this.selection.getCursor().row;\n\t        var column = this.selection.getCursor().column;\n\t        var charRange = new Range(row, column-1, row, column);\n\n\t        var c = this.session.getTextRange(charRange);\n\t        if (!isNaN(parseFloat(c)) && isFinite(c)) {\n\t            var nr = this.getNumberAt(row, column);\n\t            if (nr) {\n\t                var fp = nr.value.indexOf(\".\") >= 0 ? nr.start + nr.value.indexOf(\".\") + 1 : nr.end;\n\t                var decimals = nr.start + nr.value.length - fp;\n\n\t                var t = parseFloat(nr.value);\n\t                t *= Math.pow(10, decimals);\n\n\n\t                if(fp !== nr.end && column < fp){\n\t                    amount *= Math.pow(10, nr.end - column - 1);\n\t                } else {\n\t                    amount *= Math.pow(10, nr.end - column);\n\t                }\n\n\t                t += amount;\n\t                t /= Math.pow(10, decimals);\n\t                var nnr = t.toFixed(decimals);\n\t                var replaceRange = new Range(row, nr.start, row, nr.end);\n\t                this.session.replace(replaceRange, nnr);\n\t                this.moveCursorTo(row, Math.max(nr.start +1, column + nnr.length - nr.value.length));\n\n\t            }\n\t        }\n\t    };\n\t    this.removeLines = function() {\n\t        var rows = this.$getSelectedRows();\n\t        var range;\n\t        if (rows.first === 0 || rows.last+1 < this.session.getLength())\n\t            range = new Range(rows.first, 0, rows.last+1, 0);\n\t        else\n\t            range = new Range(\n\t                rows.first-1, this.session.getLine(rows.first-1).length,\n\t                rows.last, this.session.getLine(rows.last).length\n\t            );\n\t        this.session.remove(range);\n\t        this.clearSelection();\n\t    };\n\n\t    this.duplicateSelection = function() {\n\t        var sel = this.selection;\n\t        var doc = this.session;\n\t        var range = sel.getRange();\n\t        var reverse = sel.isBackwards();\n\t        if (range.isEmpty()) {\n\t            var row = range.start.row;\n\t            doc.duplicateLines(row, row);\n\t        } else {\n\t            var point = reverse ? range.start : range.end;\n\t            var endPoint = doc.insert(point, doc.getTextRange(range), false);\n\t            range.start = point;\n\t            range.end = endPoint;\n\n\t            sel.setSelectionRange(range, reverse);\n\t        }\n\t    };\n\t    this.moveLinesDown = function() {\n\t        this.$moveLines(function(firstRow, lastRow) {\n\t            return this.session.moveLinesDown(firstRow, lastRow);\n\t        });\n\t    };\n\t    this.moveLinesUp = function() {\n\t        this.$moveLines(function(firstRow, lastRow) {\n\t            return this.session.moveLinesUp(firstRow, lastRow);\n\t        });\n\t    };\n\t    this.moveText = function(range, toPosition, copy) {\n\t        return this.session.moveText(range, toPosition, copy);\n\t    };\n\t    this.copyLinesUp = function() {\n\t        this.$moveLines(function(firstRow, lastRow) {\n\t            this.session.duplicateLines(firstRow, lastRow);\n\t            return 0;\n\t        });\n\t    };\n\t    this.copyLinesDown = function() {\n\t        this.$moveLines(function(firstRow, lastRow) {\n\t            return this.session.duplicateLines(firstRow, lastRow);\n\t        });\n\t    };\n\t    this.$moveLines = function(mover) {\n\t        var selection = this.selection;\n\t        if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {\n\t            var range = selection.toOrientedRange();\n\t            var rows = this.$getSelectedRows(range);\n\t            var linesMoved = mover.call(this, rows.first, rows.last);\n\t            range.moveBy(linesMoved, 0);\n\t            selection.fromOrientedRange(range);\n\t        } else {\n\t            var ranges = selection.rangeList.ranges;\n\t            selection.rangeList.detach(this.session);\n\n\t            for (var i = ranges.length; i--; ) {\n\t                var rangeIndex = i;\n\t                var rows = ranges[i].collapseRows();\n\t                var last = rows.end.row;\n\t                var first = rows.start.row;\n\t                while (i--) {\n\t                    rows = ranges[i].collapseRows();\n\t                    if (first - rows.end.row <= 1)\n\t                        first = rows.end.row;\n\t                    else\n\t                        break;\n\t                }\n\t                i++;\n\n\t                var linesMoved = mover.call(this, first, last);\n\t                while (rangeIndex >= i) {\n\t                    ranges[rangeIndex].moveBy(linesMoved, 0);\n\t                    rangeIndex--;\n\t                }\n\t            }\n\t            selection.fromOrientedRange(selection.ranges[0]);\n\t            selection.rangeList.attach(this.session);\n\t        }\n\t    };\n\t    this.$getSelectedRows = function() {\n\t        var range = this.getSelectionRange().collapseRows();\n\n\t        return {\n\t            first: this.session.getRowFoldStart(range.start.row),\n\t            last: this.session.getRowFoldEnd(range.end.row)\n\t        };\n\t    };\n\n\t    this.onCompositionStart = function(text) {\n\t        this.renderer.showComposition(this.getCursorPosition());\n\t    };\n\n\t    this.onCompositionUpdate = function(text) {\n\t        this.renderer.setCompositionText(text);\n\t    };\n\n\t    this.onCompositionEnd = function() {\n\t        this.renderer.hideComposition();\n\t    };\n\t    this.getFirstVisibleRow = function() {\n\t        return this.renderer.getFirstVisibleRow();\n\t    };\n\t    this.getLastVisibleRow = function() {\n\t        return this.renderer.getLastVisibleRow();\n\t    };\n\t    this.isRowVisible = function(row) {\n\t        return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());\n\t    };\n\t    this.isRowFullyVisible = function(row) {\n\t        return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());\n\t    };\n\t    this.$getVisibleRowCount = function() {\n\t        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;\n\t    };\n\n\t    this.$moveByPage = function(dir, select) {\n\t        var renderer = this.renderer;\n\t        var config = this.renderer.layerConfig;\n\t        var rows = dir * Math.floor(config.height / config.lineHeight);\n\n\t        this.$blockScrolling++;\n\t        if (select === true) {\n\t            this.selection.$moveSelection(function(){\n\t                this.moveCursorBy(rows, 0);\n\t            });\n\t        } else if (select === false) {\n\t            this.selection.moveCursorBy(rows, 0);\n\t            this.selection.clearSelection();\n\t        }\n\t        this.$blockScrolling--;\n\n\t        var scrollTop = renderer.scrollTop;\n\n\t        renderer.scrollBy(0, rows * config.lineHeight);\n\t        if (select != null)\n\t            renderer.scrollCursorIntoView(null, 0.5);\n\n\t        renderer.animateScrolling(scrollTop);\n\t    };\n\t    this.selectPageDown = function() {\n\t        this.$moveByPage(1, true);\n\t    };\n\t    this.selectPageUp = function() {\n\t        this.$moveByPage(-1, true);\n\t    };\n\t    this.gotoPageDown = function() {\n\t       this.$moveByPage(1, false);\n\t    };\n\t    this.gotoPageUp = function() {\n\t        this.$moveByPage(-1, false);\n\t    };\n\t    this.scrollPageDown = function() {\n\t        this.$moveByPage(1);\n\t    };\n\t    this.scrollPageUp = function() {\n\t        this.$moveByPage(-1);\n\t    };\n\t    this.scrollToRow = function(row) {\n\t        this.renderer.scrollToRow(row);\n\t    };\n\t    this.scrollToLine = function(line, center, animate, callback) {\n\t        this.renderer.scrollToLine(line, center, animate, callback);\n\t    };\n\t    this.centerSelection = function() {\n\t        var range = this.getSelectionRange();\n\t        var pos = {\n\t            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),\n\t            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)\n\t        };\n\t        this.renderer.alignCursor(pos, 0.5);\n\t    };\n\t    this.getCursorPosition = function() {\n\t        return this.selection.getCursor();\n\t    };\n\t    this.getCursorPositionScreen = function() {\n\t        return this.session.documentToScreenPosition(this.getCursorPosition());\n\t    };\n\t    this.getSelectionRange = function() {\n\t        return this.selection.getRange();\n\t    };\n\t    this.selectAll = function() {\n\t        this.$blockScrolling += 1;\n\t        this.selection.selectAll();\n\t        this.$blockScrolling -= 1;\n\t    };\n\t    this.clearSelection = function() {\n\t        this.selection.clearSelection();\n\t    };\n\t    this.moveCursorTo = function(row, column) {\n\t        this.selection.moveCursorTo(row, column);\n\t    };\n\t    this.moveCursorToPosition = function(pos) {\n\t        this.selection.moveCursorToPosition(pos);\n\t    };\n\t    this.jumpToMatching = function(select, expand) {\n\t        var cursor = this.getCursorPosition();\n\t        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);\n\t        var prevToken = iterator.getCurrentToken();\n\t        var token = prevToken || iterator.stepForward();\n\n\t        if (!token) return;\n\t        var matchType;\n\t        var found = false;\n\t        var depth = {};\n\t        var i = cursor.column - token.start;\n\t        var bracketType;\n\t        var brackets = {\n\t            \")\": \"(\",\n\t            \"(\": \"(\",\n\t            \"]\": \"[\",\n\t            \"[\": \"[\",\n\t            \"{\": \"{\",\n\t            \"}\": \"{\"\n\t        };\n\t        \n\t        do {\n\t            if (token.value.match(/[{}()\\[\\]]/g)) {\n\t                for (; i < token.value.length && !found; i++) {\n\t                    if (!brackets[token.value[i]]) {\n\t                        continue;\n\t                    }\n\n\t                    bracketType = brackets[token.value[i]] + '.' + token.type.replace(\"rparen\", \"lparen\");\n\n\t                    if (isNaN(depth[bracketType])) {\n\t                        depth[bracketType] = 0;\n\t                    }\n\n\t                    switch (token.value[i]) {\n\t                        case '(':\n\t                        case '[':\n\t                        case '{':\n\t                            depth[bracketType]++;\n\t                            break;\n\t                        case ')':\n\t                        case ']':\n\t                        case '}':\n\t                            depth[bracketType]--;\n\n\t                            if (depth[bracketType] === -1) {\n\t                                matchType = 'bracket';\n\t                                found = true;\n\t                            }\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            else if (token && token.type.indexOf('tag-name') !== -1) {\n\t                if (isNaN(depth[token.value])) {\n\t                    depth[token.value] = 0;\n\t                }\n\t                \n\t                if (prevToken.value === '<') {\n\t                    depth[token.value]++;\n\t                }\n\t                else if (prevToken.value === '</') {\n\t                    depth[token.value]--;\n\t                }\n\t                \n\t                if (depth[token.value] === -1) {\n\t                    matchType = 'tag';\n\t                    found = true;\n\t                }\n\t            }\n\n\t            if (!found) {\n\t                prevToken = token;\n\t                token = iterator.stepForward();\n\t                i = 0;\n\t            }\n\t        } while (token && !found);\n\t        if (!matchType)\n\t            return;\n\n\t        var range, pos;\n\t        if (matchType === 'bracket') {\n\t            range = this.session.getBracketRange(cursor);\n\t            if (!range) {\n\t                range = new Range(\n\t                    iterator.getCurrentTokenRow(),\n\t                    iterator.getCurrentTokenColumn() + i - 1,\n\t                    iterator.getCurrentTokenRow(),\n\t                    iterator.getCurrentTokenColumn() + i - 1\n\t                );\n\t                pos = range.start;\n\t                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)\n\t                    range = this.session.getBracketRange(pos);\n\t            }\n\t        }\n\t        else if (matchType === 'tag') {\n\t            if (token && token.type.indexOf('tag-name') !== -1) \n\t                var tag = token.value;\n\t            else\n\t                return;\n\n\t            range = new Range(\n\t                iterator.getCurrentTokenRow(),\n\t                iterator.getCurrentTokenColumn() - 2,\n\t                iterator.getCurrentTokenRow(),\n\t                iterator.getCurrentTokenColumn() - 2\n\t            );\n\t            if (range.compare(cursor.row, cursor.column) === 0) {\n\t                found = false;\n\t                do {\n\t                    token = prevToken;\n\t                    prevToken = iterator.stepBackward();\n\t                    \n\t                    if (prevToken) {\n\t                        if (prevToken.type.indexOf('tag-close') !== -1) {\n\t                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);\n\t                        }\n\n\t                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {\n\t                            if (prevToken.value === '<') {\n\t                                depth[tag]++;\n\t                            }\n\t                            else if (prevToken.value === '</') {\n\t                                depth[tag]--;\n\t                            }\n\t                            \n\t                            if (depth[tag] === 0)\n\t                                found = true;\n\t                        }\n\t                    }\n\t                } while (prevToken && !found);\n\t            }\n\t            if (token && token.type.indexOf('tag-name')) {\n\t                pos = range.start;\n\t                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)\n\t                    pos = range.end;\n\t            }\n\t        }\n\n\t        pos = range && range.cursor || pos;\n\t        if (pos) {\n\t            if (select) {\n\t                if (range && expand) {\n\t                    this.selection.setRange(range);\n\t                } else if (range && range.isEqual(this.getSelectionRange())) {\n\t                    this.clearSelection();\n\t                } else {\n\t                    this.selection.selectTo(pos.row, pos.column);\n\t                }\n\t            } else {\n\t                this.selection.moveTo(pos.row, pos.column);\n\t            }\n\t        }\n\t    };\n\t    this.gotoLine = function(lineNumber, column, animate) {\n\t        this.selection.clearSelection();\n\t        this.session.unfold({row: lineNumber - 1, column: column || 0});\n\n\t        this.$blockScrolling += 1;\n\t        this.exitMultiSelectMode && this.exitMultiSelectMode();\n\t        this.moveCursorTo(lineNumber - 1, column || 0);\n\t        this.$blockScrolling -= 1;\n\n\t        if (!this.isRowFullyVisible(lineNumber - 1))\n\t            this.scrollToLine(lineNumber - 1, true, animate);\n\t    };\n\t    this.navigateTo = function(row, column) {\n\t        this.selection.moveTo(row, column);\n\t    };\n\t    this.navigateUp = function(times) {\n\t        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {\n\t            var selectionStart = this.selection.anchor.getPosition();\n\t            return this.moveCursorToPosition(selectionStart);\n\t        }\n\t        this.selection.clearSelection();\n\t        this.selection.moveCursorBy(-times || -1, 0);\n\t    };\n\t    this.navigateDown = function(times) {\n\t        if (this.selection.isMultiLine() && this.selection.isBackwards()) {\n\t            var selectionEnd = this.selection.anchor.getPosition();\n\t            return this.moveCursorToPosition(selectionEnd);\n\t        }\n\t        this.selection.clearSelection();\n\t        this.selection.moveCursorBy(times || 1, 0);\n\t    };\n\t    this.navigateLeft = function(times) {\n\t        if (!this.selection.isEmpty()) {\n\t            var selectionStart = this.getSelectionRange().start;\n\t            this.moveCursorToPosition(selectionStart);\n\t        }\n\t        else {\n\t            times = times || 1;\n\t            while (times--) {\n\t                this.selection.moveCursorLeft();\n\t            }\n\t        }\n\t        this.clearSelection();\n\t    };\n\t    this.navigateRight = function(times) {\n\t        if (!this.selection.isEmpty()) {\n\t            var selectionEnd = this.getSelectionRange().end;\n\t            this.moveCursorToPosition(selectionEnd);\n\t        }\n\t        else {\n\t            times = times || 1;\n\t            while (times--) {\n\t                this.selection.moveCursorRight();\n\t            }\n\t        }\n\t        this.clearSelection();\n\t    };\n\t    this.navigateLineStart = function() {\n\t        this.selection.moveCursorLineStart();\n\t        this.clearSelection();\n\t    };\n\t    this.navigateLineEnd = function() {\n\t        this.selection.moveCursorLineEnd();\n\t        this.clearSelection();\n\t    };\n\t    this.navigateFileEnd = function() {\n\t        this.selection.moveCursorFileEnd();\n\t        this.clearSelection();\n\t    };\n\t    this.navigateFileStart = function() {\n\t        this.selection.moveCursorFileStart();\n\t        this.clearSelection();\n\t    };\n\t    this.navigateWordRight = function() {\n\t        this.selection.moveCursorWordRight();\n\t        this.clearSelection();\n\t    };\n\t    this.navigateWordLeft = function() {\n\t        this.selection.moveCursorWordLeft();\n\t        this.clearSelection();\n\t    };\n\t    this.replace = function(replacement, options) {\n\t        if (options)\n\t            this.$search.set(options);\n\n\t        var range = this.$search.find(this.session);\n\t        var replaced = 0;\n\t        if (!range)\n\t            return replaced;\n\n\t        if (this.$tryReplace(range, replacement)) {\n\t            replaced = 1;\n\t        }\n\t        if (range !== null) {\n\t            this.selection.setSelectionRange(range);\n\t            this.renderer.scrollSelectionIntoView(range.start, range.end);\n\t        }\n\n\t        return replaced;\n\t    };\n\t    this.replaceAll = function(replacement, options) {\n\t        if (options) {\n\t            this.$search.set(options);\n\t        }\n\n\t        var ranges = this.$search.findAll(this.session);\n\t        var replaced = 0;\n\t        if (!ranges.length)\n\t            return replaced;\n\n\t        this.$blockScrolling += 1;\n\n\t        var selection = this.getSelectionRange();\n\t        this.selection.moveTo(0, 0);\n\n\t        for (var i = ranges.length - 1; i >= 0; --i) {\n\t            if(this.$tryReplace(ranges[i], replacement)) {\n\t                replaced++;\n\t            }\n\t        }\n\n\t        this.selection.setSelectionRange(selection);\n\t        this.$blockScrolling -= 1;\n\n\t        return replaced;\n\t    };\n\n\t    this.$tryReplace = function(range, replacement) {\n\t        var input = this.session.getTextRange(range);\n\t        replacement = this.$search.replace(input, replacement);\n\t        if (replacement !== null) {\n\t            range.end = this.session.replace(range, replacement);\n\t            return range;\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    this.getLastSearchOptions = function() {\n\t        return this.$search.getOptions();\n\t    };\n\t    this.find = function(needle, options, animate) {\n\t        if (!options)\n\t            options = {};\n\n\t        if (typeof needle == \"string\" || needle instanceof RegExp)\n\t            options.needle = needle;\n\t        else if (typeof needle == \"object\")\n\t            oop.mixin(options, needle);\n\n\t        var range = this.selection.getRange();\n\t        if (options.needle == null) {\n\t            needle = this.session.getTextRange(range)\n\t                || this.$search.$options.needle;\n\t            if (!needle) {\n\t                range = this.session.getWordRange(range.start.row, range.start.column);\n\t                needle = this.session.getTextRange(range);\n\t            }\n\t            this.$search.set({needle: needle});\n\t        }\n\n\t        this.$search.set(options);\n\t        if (!options.start)\n\t            this.$search.set({start: range});\n\n\t        var newRange = this.$search.find(this.session);\n\t        if (options.preventScroll)\n\t            return newRange;\n\t        if (newRange) {\n\t            this.revealRange(newRange, animate);\n\t            return newRange;\n\t        }\n\t        if (options.backwards)\n\t            range.start = range.end;\n\t        else\n\t            range.end = range.start;\n\t        this.selection.setRange(range);\n\t    };\n\t    this.findNext = function(options, animate) {\n\t        this.find({skipCurrent: true, backwards: false}, options, animate);\n\t    };\n\t    this.findPrevious = function(options, animate) {\n\t        this.find(options, {skipCurrent: true, backwards: true}, animate);\n\t    };\n\n\t    this.revealRange = function(range, animate) {\n\t        this.$blockScrolling += 1;\n\t        this.session.unfold(range);\n\t        this.selection.setSelectionRange(range);\n\t        this.$blockScrolling -= 1;\n\n\t        var scrollTop = this.renderer.scrollTop;\n\t        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);\n\t        if (animate !== false)\n\t            this.renderer.animateScrolling(scrollTop);\n\t    };\n\t    this.undo = function() {\n\t        this.$blockScrolling++;\n\t        this.session.getUndoManager().undo();\n\t        this.$blockScrolling--;\n\t        this.renderer.scrollCursorIntoView(null, 0.5);\n\t    };\n\t    this.redo = function() {\n\t        this.$blockScrolling++;\n\t        this.session.getUndoManager().redo();\n\t        this.$blockScrolling--;\n\t        this.renderer.scrollCursorIntoView(null, 0.5);\n\t    };\n\t    this.destroy = function() {\n\t        this.renderer.destroy();\n\t        this._signal(\"destroy\", this);\n\t        if (this.session) {\n\t            this.session.destroy();\n\t        }\n\t    };\n\t    this.setAutoScrollEditorIntoView = function(enable) {\n\t        if (!enable)\n\t            return;\n\t        var rect;\n\t        var self = this;\n\t        var shouldScroll = false;\n\t        if (!this.$scrollAnchor)\n\t            this.$scrollAnchor = document.createElement(\"div\");\n\t        var scrollAnchor = this.$scrollAnchor;\n\t        scrollAnchor.style.cssText = \"position:absolute\";\n\t        this.container.insertBefore(scrollAnchor, this.container.firstChild);\n\t        var onChangeSelection = this.on(\"changeSelection\", function() {\n\t            shouldScroll = true;\n\t        });\n\t        var onBeforeRender = this.renderer.on(\"beforeRender\", function() {\n\t            if (shouldScroll)\n\t                rect = self.renderer.container.getBoundingClientRect();\n\t        });\n\t        var onAfterRender = this.renderer.on(\"afterRender\", function() {\n\t            if (shouldScroll && rect && (self.isFocused()\n\t                || self.searchBox && self.searchBox.isFocused())\n\t            ) {\n\t                var renderer = self.renderer;\n\t                var pos = renderer.$cursorLayer.$pixelPos;\n\t                var config = renderer.layerConfig;\n\t                var top = pos.top - config.offset;\n\t                if (pos.top >= 0 && top + rect.top < 0) {\n\t                    shouldScroll = true;\n\t                } else if (pos.top < config.height &&\n\t                    pos.top + rect.top + config.lineHeight > window.innerHeight) {\n\t                    shouldScroll = false;\n\t                } else {\n\t                    shouldScroll = null;\n\t                }\n\t                if (shouldScroll != null) {\n\t                    scrollAnchor.style.top = top + \"px\";\n\t                    scrollAnchor.style.left = pos.left + \"px\";\n\t                    scrollAnchor.style.height = config.lineHeight + \"px\";\n\t                    scrollAnchor.scrollIntoView(shouldScroll);\n\t                }\n\t                shouldScroll = rect = null;\n\t            }\n\t        });\n\t        this.setAutoScrollEditorIntoView = function(enable) {\n\t            if (enable)\n\t                return;\n\t            delete this.setAutoScrollEditorIntoView;\n\t            this.removeEventListener(\"changeSelection\", onChangeSelection);\n\t            this.renderer.removeEventListener(\"afterRender\", onAfterRender);\n\t            this.renderer.removeEventListener(\"beforeRender\", onBeforeRender);\n\t        };\n\t    };\n\n\n\t    this.$resetCursorStyle = function() {\n\t        var style = this.$cursorStyle || \"ace\";\n\t        var cursorLayer = this.renderer.$cursorLayer;\n\t        if (!cursorLayer)\n\t            return;\n\t        cursorLayer.setSmoothBlinking(/smooth/.test(style));\n\t        cursorLayer.isBlinking = !this.$readOnly && style != \"wide\";\n\t        dom.setCssClass(cursorLayer.element, \"ace_slim-cursors\", /slim/.test(style));\n\t    };\n\n\t}).call(Editor.prototype);\n\n\n\n\tconfig.defineOptions(Editor.prototype, \"editor\", {\n\t    selectionStyle: {\n\t        set: function(style) {\n\t            this.onSelectionChange();\n\t            this._signal(\"changeSelectionStyle\", {data: style});\n\t        },\n\t        initialValue: \"line\"\n\t    },\n\t    highlightActiveLine: {\n\t        set: function() {this.$updateHighlightActiveLine();},\n\t        initialValue: true\n\t    },\n\t    highlightSelectedWord: {\n\t        set: function(shouldHighlight) {this.$onSelectionChange();},\n\t        initialValue: true\n\t    },\n\t    readOnly: {\n\t        set: function(readOnly) {\n\t            this.$resetCursorStyle(); \n\t        },\n\t        initialValue: false\n\t    },\n\t    cursorStyle: {\n\t        set: function(val) { this.$resetCursorStyle(); },\n\t        values: [\"ace\", \"slim\", \"smooth\", \"wide\"],\n\t        initialValue: \"ace\"\n\t    },\n\t    mergeUndoDeltas: {\n\t        values: [false, true, \"always\"],\n\t        initialValue: true\n\t    },\n\t    behavioursEnabled: {initialValue: true},\n\t    wrapBehavioursEnabled: {initialValue: true},\n\t    autoScrollEditorIntoView: {\n\t        set: function(val) {this.setAutoScrollEditorIntoView(val)}\n\t    },\n\n\t    hScrollBarAlwaysVisible: \"renderer\",\n\t    vScrollBarAlwaysVisible: \"renderer\",\n\t    highlightGutterLine: \"renderer\",\n\t    animatedScroll: \"renderer\",\n\t    showInvisibles: \"renderer\",\n\t    showPrintMargin: \"renderer\",\n\t    printMarginColumn: \"renderer\",\n\t    printMargin: \"renderer\",\n\t    fadeFoldWidgets: \"renderer\",\n\t    showFoldWidgets: \"renderer\",\n\t    showLineNumbers: \"renderer\",\n\t    showGutter: \"renderer\",\n\t    displayIndentGuides: \"renderer\",\n\t    fontSize: \"renderer\",\n\t    fontFamily: \"renderer\",\n\t    maxLines: \"renderer\",\n\t    minLines: \"renderer\",\n\t    scrollPastEnd: \"renderer\",\n\t    fixedWidthGutter: \"renderer\",\n\t    theme: \"renderer\",\n\n\t    scrollSpeed: \"$mouseHandler\",\n\t    dragDelay: \"$mouseHandler\",\n\t    dragEnabled: \"$mouseHandler\",\n\t    focusTimout: \"$mouseHandler\",\n\t    tooltipFollowsMouse: \"$mouseHandler\",\n\n\t    firstLineNumber: \"session\",\n\t    overwrite: \"session\",\n\t    newLineMode: \"session\",\n\t    useWorker: \"session\",\n\t    useSoftTabs: \"session\",\n\t    tabSize: \"session\",\n\t    wrap: \"session\",\n\t    foldStyle: \"session\",\n\t    mode: \"session\"\n\t});\n\n\texports.Editor = Editor;\n\t});\n\n\tace.define(\"ace/undomanager\",[\"require\",\"exports\",\"module\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar UndoManager = function() {\n\t    this.reset();\n\t};\n\n\t(function() {\n\t    this.execute = function(options) {\n\t        var deltas = options.args[0];\n\t        this.$doc  = options.args[1];\n\t        if (options.merge && this.hasUndo()){\n\t            this.dirtyCounter--;\n\t            deltas = this.$undoStack.pop().concat(deltas);\n\t        }\n\t        this.$undoStack.push(deltas);\n\t        this.$redoStack = [];\n\n\t        if (this.dirtyCounter < 0) {\n\t            this.dirtyCounter = NaN;\n\t        }\n\t        this.dirtyCounter++;\n\t    };\n\t    this.undo = function(dontSelect) {\n\t        var deltas = this.$undoStack.pop();\n\t        var undoSelectionRange = null;\n\t        if (deltas) {\n\t            undoSelectionRange =\n\t                this.$doc.undoChanges(deltas, dontSelect);\n\t            this.$redoStack.push(deltas);\n\t            this.dirtyCounter--;\n\t        }\n\n\t        return undoSelectionRange;\n\t    };\n\t    this.redo = function(dontSelect) {\n\t        var deltas = this.$redoStack.pop();\n\t        var redoSelectionRange = null;\n\t        if (deltas) {\n\t            redoSelectionRange =\n\t                this.$doc.redoChanges(deltas, dontSelect);\n\t            this.$undoStack.push(deltas);\n\t            this.dirtyCounter++;\n\t        }\n\n\t        return redoSelectionRange;\n\t    };\n\t    this.reset = function() {\n\t        this.$undoStack = [];\n\t        this.$redoStack = [];\n\t        this.dirtyCounter = 0;\n\t    };\n\t    this.hasUndo = function() {\n\t        return this.$undoStack.length > 0;\n\t    };\n\t    this.hasRedo = function() {\n\t        return this.$redoStack.length > 0;\n\t    };\n\t    this.markClean = function() {\n\t        this.dirtyCounter = 0;\n\t    };\n\t    this.isClean = function() {\n\t        return this.dirtyCounter === 0;\n\t    };\n\n\t}).call(UndoManager.prototype);\n\n\texports.UndoManager = UndoManager;\n\t});\n\n\tace.define(\"ace/layer/gutter\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/lang\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tvar oop = acequire(\"../lib/oop\");\n\tvar lang = acequire(\"../lib/lang\");\n\tvar EventEmitter = acequire(\"../lib/event_emitter\").EventEmitter;\n\n\tvar Gutter = function(parentEl) {\n\t    this.element = dom.createElement(\"div\");\n\t    this.element.className = \"ace_layer ace_gutter-layer\";\n\t    parentEl.appendChild(this.element);\n\t    this.setShowFoldWidgets(this.$showFoldWidgets);\n\t    \n\t    this.gutterWidth = 0;\n\n\t    this.$annotations = [];\n\t    this.$updateAnnotations = this.$updateAnnotations.bind(this);\n\n\t    this.$cells = [];\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\n\t    this.setSession = function(session) {\n\t        if (this.session)\n\t            this.session.removeEventListener(\"change\", this.$updateAnnotations);\n\t        this.session = session;\n\t        if (session)\n\t            session.on(\"change\", this.$updateAnnotations);\n\t    };\n\n\t    this.addGutterDecoration = function(row, className){\n\t        if (window.console)\n\t            console.warn && console.warn(\"deprecated use session.addGutterDecoration\");\n\t        this.session.addGutterDecoration(row, className);\n\t    };\n\n\t    this.removeGutterDecoration = function(row, className){\n\t        if (window.console)\n\t            console.warn && console.warn(\"deprecated use session.removeGutterDecoration\");\n\t        this.session.removeGutterDecoration(row, className);\n\t    };\n\n\t    this.setAnnotations = function(annotations) {\n\t        this.$annotations = [];\n\t        for (var i = 0; i < annotations.length; i++) {\n\t            var annotation = annotations[i];\n\t            var row = annotation.row;\n\t            var rowInfo = this.$annotations[row];\n\t            if (!rowInfo)\n\t                rowInfo = this.$annotations[row] = {text: []};\n\t           \n\t            var annoText = annotation.text;\n\t            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || \"\";\n\n\t            if (rowInfo.text.indexOf(annoText) === -1)\n\t                rowInfo.text.push(annoText);\n\n\t            var type = annotation.type;\n\t            if (type == \"error\")\n\t                rowInfo.className = \" ace_error\";\n\t            else if (type == \"warning\" && rowInfo.className != \" ace_error\")\n\t                rowInfo.className = \" ace_warning\";\n\t            else if (type == \"info\" && (!rowInfo.className))\n\t                rowInfo.className = \" ace_info\";\n\t        }\n\t    };\n\n\t    this.$updateAnnotations = function (e) {\n\t        if (!this.$annotations.length)\n\t            return;\n\t        var delta = e.data;\n\t        var range = delta.range;\n\t        var firstRow = range.start.row;\n\t        var len = range.end.row - firstRow;\n\t        if (len === 0) {\n\t        } else if (delta.action == \"removeText\" || delta.action == \"removeLines\") {\n\t            this.$annotations.splice(firstRow, len + 1, null);\n\t        } else {\n\t            var args = new Array(len + 1);\n\t            args.unshift(firstRow, 1);\n\t            this.$annotations.splice.apply(this.$annotations, args);\n\t        }\n\t    };\n\n\t    this.update = function(config) {\n\t        var session = this.session;\n\t        var firstRow = config.firstRow;\n\t        var lastRow = Math.min(config.lastRow + config.gutterOffset,  // needed to compensate for hor scollbar\n\t            session.getLength() - 1);\n\t        var fold = session.getNextFoldLine(firstRow);\n\t        var foldStart = fold ? fold.start.row : Infinity;\n\t        var foldWidgets = this.$showFoldWidgets && session.foldWidgets;\n\t        var breakpoints = session.$breakpoints;\n\t        var decorations = session.$decorations;\n\t        var firstLineNumber = session.$firstLineNumber;\n\t        var lastLineNumber = 0;\n\t        \n\t        var gutterRenderer = session.gutterRenderer || this.$renderer;\n\n\t        var cell = null;\n\t        var index = -1;\n\t        var row = firstRow;\n\t        while (true) {\n\t            if (row > foldStart) {\n\t                row = fold.end.row + 1;\n\t                fold = session.getNextFoldLine(row, fold);\n\t                foldStart = fold ? fold.start.row : Infinity;\n\t            }\n\t            if (row > lastRow) {\n\t                while (this.$cells.length > index + 1) {\n\t                    cell = this.$cells.pop();\n\t                    this.element.removeChild(cell.element);\n\t                }\n\t                break;\n\t            }\n\n\t            cell = this.$cells[++index];\n\t            if (!cell) {\n\t                cell = {element: null, textNode: null, foldWidget: null};\n\t                cell.element = dom.createElement(\"div\");\n\t                cell.textNode = document.createTextNode('');\n\t                cell.element.appendChild(cell.textNode);\n\t                this.element.appendChild(cell.element);\n\t                this.$cells[index] = cell;\n\t            }\n\n\t            var className = \"ace_gutter-cell \";\n\t            if (breakpoints[row])\n\t                className += breakpoints[row];\n\t            if (decorations[row])\n\t                className += decorations[row];\n\t            if (this.$annotations[row])\n\t                className += this.$annotations[row].className;\n\t            if (cell.element.className != className)\n\t                cell.element.className = className;\n\n\t            var height = session.getRowLength(row) * config.lineHeight + \"px\";\n\t            if (height != cell.element.style.height)\n\t                cell.element.style.height = height;\n\n\t            if (foldWidgets) {\n\t                var c = foldWidgets[row];\n\t                if (c == null)\n\t                    c = foldWidgets[row] = session.getFoldWidget(row);\n\t            }\n\n\t            if (c) {\n\t                if (!cell.foldWidget) {\n\t                    cell.foldWidget = dom.createElement(\"span\");\n\t                    cell.element.appendChild(cell.foldWidget);\n\t                }\n\t                var className = \"ace_fold-widget ace_\" + c;\n\t                if (c == \"start\" && row == foldStart && row < fold.end.row)\n\t                    className += \" ace_closed\";\n\t                else\n\t                    className += \" ace_open\";\n\t                if (cell.foldWidget.className != className)\n\t                    cell.foldWidget.className = className;\n\n\t                var height = config.lineHeight + \"px\";\n\t                if (cell.foldWidget.style.height != height)\n\t                    cell.foldWidget.style.height = height;\n\t            } else {\n\t                if (cell.foldWidget) {\n\t                    cell.element.removeChild(cell.foldWidget);\n\t                    cell.foldWidget = null;\n\t                }\n\t            }\n\t            \n\t            var text = lastLineNumber = gutterRenderer\n\t                ? gutterRenderer.getText(session, row)\n\t                : row + firstLineNumber;\n\t            if (text != cell.textNode.data)\n\t                cell.textNode.data = text;\n\n\t            row++;\n\t        }\n\n\t        this.element.style.height = config.minHeight + \"px\";\n\n\t        if (this.$fixedWidth || session.$useWrapMode)\n\t            lastLineNumber = session.getLength() + firstLineNumber;\n\n\t        var gutterWidth = gutterRenderer \n\t            ? gutterRenderer.getWidth(session, lastLineNumber, config)\n\t            : lastLineNumber.toString().length * config.characterWidth;\n\t        \n\t        var padding = this.$padding || this.$computePadding();\n\t        gutterWidth += padding.left + padding.right;\n\t        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {\n\t            this.gutterWidth = gutterWidth;\n\t            this.element.style.width = Math.ceil(this.gutterWidth) + \"px\";\n\t            this._emit(\"changeGutterWidth\", gutterWidth);\n\t        }\n\t    };\n\n\t    this.$fixedWidth = false;\n\t    \n\t    this.$showLineNumbers = true;\n\t    this.$renderer = \"\";\n\t    this.setShowLineNumbers = function(show) {\n\t        this.$renderer = !show && {\n\t            getWidth: function() {return \"\"},\n\t            getText: function() {return \"\"}\n\t        };\n\t    };\n\t    \n\t    this.getShowLineNumbers = function() {\n\t        return this.$showLineNumbers;\n\t    };\n\t    \n\t    this.$showFoldWidgets = true;\n\t    this.setShowFoldWidgets = function(show) {\n\t        if (show)\n\t            dom.addCssClass(this.element, \"ace_folding-enabled\");\n\t        else\n\t            dom.removeCssClass(this.element, \"ace_folding-enabled\");\n\n\t        this.$showFoldWidgets = show;\n\t        this.$padding = null;\n\t    };\n\t    \n\t    this.getShowFoldWidgets = function() {\n\t        return this.$showFoldWidgets;\n\t    };\n\n\t    this.$computePadding = function() {\n\t        if (!this.element.firstChild)\n\t            return {left: 0, right: 0};\n\t        var style = dom.computedStyle(this.element.firstChild);\n\t        this.$padding = {};\n\t        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;\n\t        this.$padding.right = parseInt(style.paddingRight) || 0;\n\t        return this.$padding;\n\t    };\n\n\t    this.getRegion = function(point) {\n\t        var padding = this.$padding || this.$computePadding();\n\t        var rect = this.element.getBoundingClientRect();\n\t        if (point.x < padding.left + rect.left)\n\t            return \"markers\";\n\t        if (this.$showFoldWidgets && point.x > rect.right - padding.right)\n\t            return \"foldWidgets\";\n\t    };\n\n\t}).call(Gutter.prototype);\n\n\texports.Gutter = Gutter;\n\n\t});\n\n\tace.define(\"ace/layer/marker\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/dom\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"../range\").Range;\n\tvar dom = acequire(\"../lib/dom\");\n\n\tvar Marker = function(parentEl) {\n\t    this.element = dom.createElement(\"div\");\n\t    this.element.className = \"ace_layer ace_marker-layer\";\n\t    parentEl.appendChild(this.element);\n\t};\n\n\t(function() {\n\n\t    this.$padding = 0;\n\n\t    this.setPadding = function(padding) {\n\t        this.$padding = padding;\n\t    };\n\t    this.setSession = function(session) {\n\t        this.session = session;\n\t    };\n\t    \n\t    this.setMarkers = function(markers) {\n\t        this.markers = markers;\n\t    };\n\n\t    this.update = function(config) {\n\t        var config = config || this.config;\n\t        if (!config)\n\t            return;\n\n\t        this.config = config;\n\n\n\t        var html = [];\n\t        for (var key in this.markers) {\n\t            var marker = this.markers[key];\n\n\t            if (!marker.range) {\n\t                marker.update(html, this, this.session, config);\n\t                continue;\n\t            }\n\n\t            var range = marker.range.clipRows(config.firstRow, config.lastRow);\n\t            if (range.isEmpty()) continue;\n\n\t            range = range.toScreenRange(this.session);\n\t            if (marker.renderer) {\n\t                var top = this.$getTop(range.start.row, config);\n\t                var left = this.$padding + range.start.column * config.characterWidth;\n\t                marker.renderer(html, range, left, top, config);\n\t            } else if (marker.type == \"fullLine\") {\n\t                this.drawFullLineMarker(html, range, marker.clazz, config);\n\t            } else if (marker.type == \"screenLine\") {\n\t                this.drawScreenLineMarker(html, range, marker.clazz, config);\n\t            } else if (range.isMultiLine()) {\n\t                if (marker.type == \"text\")\n\t                    this.drawTextMarker(html, range, marker.clazz, config);\n\t                else\n\t                    this.drawMultiLineMarker(html, range, marker.clazz, config);\n\t            } else {\n\t                this.drawSingleLineMarker(html, range, marker.clazz + \" ace_start\", config);\n\t            }\n\t        }\n\t        this.element.innerHTML = html.join(\"\");\n\t    };\n\n\t    this.$getTop = function(row, layerConfig) {\n\t        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;\n\t    };\n\t    this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {\n\t        var row = range.start.row;\n\n\t        var lineRange = new Range(\n\t            row, range.start.column,\n\t            row, this.session.getScreenLastRowColumn(row)\n\t        );\n\t        this.drawSingleLineMarker(stringBuilder, lineRange, clazz + \" ace_start\", layerConfig, 1, extraStyle);\n\t        row = range.end.row;\n\t        lineRange = new Range(row, 0, row, range.end.column);\n\t        this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 0, extraStyle);\n\n\t        for (row = range.start.row + 1; row < range.end.row; row++) {\n\t            lineRange.start.row = row;\n\t            lineRange.end.row = row;\n\t            lineRange.end.column = this.session.getScreenLastRowColumn(row);\n\t            this.drawSingleLineMarker(stringBuilder, lineRange, clazz, layerConfig, 1, extraStyle);\n\t        }\n\t    };\n\t    this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n\t        var padding = this.$padding;\n\t        var height = config.lineHeight;\n\t        var top = this.$getTop(range.start.row, config);\n\t        var left = padding + range.start.column * config.characterWidth;\n\t        extraStyle = extraStyle || \"\";\n\n\t        stringBuilder.push(\n\t            \"<div class='\", clazz, \" ace_start' style='\",\n\t            \"height:\", height, \"px;\",\n\t            \"right:0;\",\n\t            \"top:\", top, \"px;\",\n\t            \"left:\", left, \"px;\", extraStyle, \"'></div>\"\n\t        );\n\t        top = this.$getTop(range.end.row, config);\n\t        var width = range.end.column * config.characterWidth;\n\n\t        stringBuilder.push(\n\t            \"<div class='\", clazz, \"' style='\",\n\t            \"height:\", height, \"px;\",\n\t            \"width:\", width, \"px;\",\n\t            \"top:\", top, \"px;\",\n\t            \"left:\", padding, \"px;\", extraStyle, \"'></div>\"\n\t        );\n\t        height = (range.end.row - range.start.row - 1) * config.lineHeight;\n\t        if (height < 0)\n\t            return;\n\t        top = this.$getTop(range.start.row + 1, config);\n\n\t        stringBuilder.push(\n\t            \"<div class='\", clazz, \"' style='\",\n\t            \"height:\", height, \"px;\",\n\t            \"right:0;\",\n\t            \"top:\", top, \"px;\",\n\t            \"left:\", padding, \"px;\", extraStyle, \"'></div>\"\n\t        );\n\t    };\n\t    this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {\n\t        var height = config.lineHeight;\n\t        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;\n\n\t        var top = this.$getTop(range.start.row, config);\n\t        var left = this.$padding + range.start.column * config.characterWidth;\n\n\t        stringBuilder.push(\n\t            \"<div class='\", clazz, \"' style='\",\n\t            \"height:\", height, \"px;\",\n\t            \"width:\", width, \"px;\",\n\t            \"top:\", top, \"px;\",\n\t            \"left:\", left, \"px;\", extraStyle || \"\", \"'></div>\"\n\t        );\n\t    };\n\n\t    this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n\t        var top = this.$getTop(range.start.row, config);\n\t        var height = config.lineHeight;\n\t        if (range.start.row != range.end.row)\n\t            height += this.$getTop(range.end.row, config) - top;\n\n\t        stringBuilder.push(\n\t            \"<div class='\", clazz, \"' style='\",\n\t            \"height:\", height, \"px;\",\n\t            \"top:\", top, \"px;\",\n\t            \"left:0;right:0;\", extraStyle || \"\", \"'></div>\"\n\t        );\n\t    };\n\t    \n\t    this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {\n\t        var top = this.$getTop(range.start.row, config);\n\t        var height = config.lineHeight;\n\n\t        stringBuilder.push(\n\t            \"<div class='\", clazz, \"' style='\",\n\t            \"height:\", height, \"px;\",\n\t            \"top:\", top, \"px;\",\n\t            \"left:0;right:0;\", extraStyle || \"\", \"'></div>\"\n\t        );\n\t    };\n\n\t}).call(Marker.prototype);\n\n\texports.Marker = Marker;\n\n\t});\n\n\tace.define(\"ace/layer/text\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../lib/oop\");\n\tvar dom = acequire(\"../lib/dom\");\n\tvar lang = acequire(\"../lib/lang\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tvar EventEmitter = acequire(\"../lib/event_emitter\").EventEmitter;\n\n\tvar Text = function(parentEl) {\n\t    this.element = dom.createElement(\"div\");\n\t    this.element.className = \"ace_layer ace_text-layer\";\n\t    parentEl.appendChild(this.element);\n\t    this.$updateEolChar = this.$updateEolChar.bind(this);\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\n\t    this.EOF_CHAR = \"\\xB6\";\n\t    this.EOL_CHAR_LF = \"\\xAC\";\n\t    this.EOL_CHAR_CRLF = \"\\xa4\";\n\t    this.EOL_CHAR = this.EOL_CHAR_LF;\n\t    this.TAB_CHAR = \"\\u2192\"; //\"\\u21E5\";\n\t    this.SPACE_CHAR = \"\\xB7\";\n\t    this.$padding = 0;\n\n\t    this.$updateEolChar = function() {\n\t        var EOL_CHAR = this.session.doc.getNewLineCharacter() == \"\\n\"\n\t           ? this.EOL_CHAR_LF\n\t           : this.EOL_CHAR_CRLF;\n\t        if (this.EOL_CHAR != EOL_CHAR) {\n\t            this.EOL_CHAR = EOL_CHAR;\n\t            return true;\n\t        }\n\t    }\n\n\t    this.setPadding = function(padding) {\n\t        this.$padding = padding;\n\t        this.element.style.padding = \"0 \" + padding + \"px\";\n\t    };\n\n\t    this.getLineHeight = function() {\n\t        return this.$fontMetrics.$characterSize.height || 0;\n\t    };\n\n\t    this.getCharacterWidth = function() {\n\t        return this.$fontMetrics.$characterSize.width || 0;\n\t    };\n\t    \n\t    this.$setFontMetrics = function(measure) {\n\t        this.$fontMetrics = measure;\n\t        this.$fontMetrics.on(\"changeCharacterSize\", function(e) {\n\t            this._signal(\"changeCharacterSize\", e);\n\t        }.bind(this));\n\t        this.$pollSizeChanges();\n\t    }\n\n\t    this.checkForSizeChanges = function() {\n\t        this.$fontMetrics.checkForSizeChanges();\n\t    };\n\t    this.$pollSizeChanges = function() {\n\t        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();\n\t    };\n\t    this.setSession = function(session) {\n\t        this.session = session;\n\t        if (session)\n\t            this.$computeTabString();\n\t    };\n\n\t    this.showInvisibles = false;\n\t    this.setShowInvisibles = function(showInvisibles) {\n\t        if (this.showInvisibles == showInvisibles)\n\t            return false;\n\n\t        this.showInvisibles = showInvisibles;\n\t        this.$computeTabString();\n\t        return true;\n\t    };\n\n\t    this.displayIndentGuides = true;\n\t    this.setDisplayIndentGuides = function(display) {\n\t        if (this.displayIndentGuides == display)\n\t            return false;\n\n\t        this.displayIndentGuides = display;\n\t        this.$computeTabString();\n\t        return true;\n\t    };\n\n\t    this.$tabStrings = [];\n\t    this.onChangeTabSize =\n\t    this.$computeTabString = function() {\n\t        var tabSize = this.session.getTabSize();\n\t        this.tabSize = tabSize;\n\t        var tabStr = this.$tabStrings = [0];\n\t        for (var i = 1; i < tabSize + 1; i++) {\n\t            if (this.showInvisibles) {\n\t                tabStr.push(\"<span class='ace_invisible ace_invisible_tab'>\"\n\t                    + this.TAB_CHAR\n\t                    + lang.stringRepeat(\"\\xa0\", i - 1)\n\t                    + \"</span>\");\n\t            } else {\n\t                tabStr.push(lang.stringRepeat(\"\\xa0\", i));\n\t            }\n\t        }\n\t        if (this.displayIndentGuides) {\n\t            this.$indentGuideRe =  /\\s\\S| \\t|\\t |\\s$/;\n\t            var className = \"ace_indent-guide\";\n\t            var spaceClass = \"\";\n\t            var tabClass = \"\";\n\t            if (this.showInvisibles) {\n\t                className += \" ace_invisible\";\n\t                spaceClass = \" ace_invisible_space\";\n\t                tabClass = \" ace_invisible_tab\";\n\t                var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);\n\t                var tabContent = this.TAB_CHAR + lang.stringRepeat(\"\\xa0\", this.tabSize - 1);\n\t            } else{\n\t                var spaceContent = lang.stringRepeat(\"\\xa0\", this.tabSize);\n\t                var tabContent = spaceContent;\n\t            }\n\n\t            this.$tabStrings[\" \"] = \"<span class='\" + className + spaceClass + \"'>\" + spaceContent + \"</span>\";\n\t            this.$tabStrings[\"\\t\"] = \"<span class='\" + className + tabClass + \"'>\" + tabContent + \"</span>\";\n\t        }\n\t    };\n\n\t    this.updateLines = function(config, firstRow, lastRow) {\n\t        if (this.config.lastRow != config.lastRow ||\n\t            this.config.firstRow != config.firstRow) {\n\t            this.scrollLines(config);\n\t        }\n\t        this.config = config;\n\n\t        var first = Math.max(firstRow, config.firstRow);\n\t        var last = Math.min(lastRow, config.lastRow);\n\n\t        var lineElements = this.element.childNodes;\n\t        var lineElementsIdx = 0;\n\n\t        for (var row = config.firstRow; row < first; row++) {\n\t            var foldLine = this.session.getFoldLine(row);\n\t            if (foldLine) {\n\t                if (foldLine.containsRow(first)) {\n\t                    first = foldLine.start.row;\n\t                    break;\n\t                } else {\n\t                    row = foldLine.end.row;\n\t                }\n\t            }\n\t            lineElementsIdx ++;\n\t        }\n\n\t        var row = first;\n\t        var foldLine = this.session.getNextFoldLine(row);\n\t        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n\t        while (true) {\n\t            if (row > foldStart) {\n\t                row = foldLine.end.row+1;\n\t                foldLine = this.session.getNextFoldLine(row, foldLine);\n\t                foldStart = foldLine ? foldLine.start.row :Infinity;\n\t            }\n\t            if (row > last)\n\t                break;\n\n\t            var lineElement = lineElements[lineElementsIdx++];\n\t            if (lineElement) {\n\t                var html = [];\n\t                this.$renderLine(\n\t                    html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false\n\t                );\n\t                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + \"px\";\n\t                lineElement.innerHTML = html.join(\"\");\n\t            }\n\t            row++;\n\t        }\n\t    };\n\n\t    this.scrollLines = function(config) {\n\t        var oldConfig = this.config;\n\t        this.config = config;\n\n\t        if (!oldConfig || oldConfig.lastRow < config.firstRow)\n\t            return this.update(config);\n\n\t        if (config.lastRow < oldConfig.firstRow)\n\t            return this.update(config);\n\n\t        var el = this.element;\n\t        if (oldConfig.firstRow < config.firstRow)\n\t            for (var row=this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row>0; row--)\n\t                el.removeChild(el.firstChild);\n\n\t        if (oldConfig.lastRow > config.lastRow)\n\t            for (var row=this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row>0; row--)\n\t                el.removeChild(el.lastChild);\n\n\t        if (config.firstRow < oldConfig.firstRow) {\n\t            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);\n\t            if (el.firstChild)\n\t                el.insertBefore(fragment, el.firstChild);\n\t            else\n\t                el.appendChild(fragment);\n\t        }\n\n\t        if (config.lastRow > oldConfig.lastRow) {\n\t            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);\n\t            el.appendChild(fragment);\n\t        }\n\t    };\n\n\t    this.$renderLinesFragment = function(config, firstRow, lastRow) {\n\t        var fragment = this.element.ownerDocument.createDocumentFragment();\n\t        var row = firstRow;\n\t        var foldLine = this.session.getNextFoldLine(row);\n\t        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n\t        while (true) {\n\t            if (row > foldStart) {\n\t                row = foldLine.end.row+1;\n\t                foldLine = this.session.getNextFoldLine(row, foldLine);\n\t                foldStart = foldLine ? foldLine.start.row : Infinity;\n\t            }\n\t            if (row > lastRow)\n\t                break;\n\n\t            var container = dom.createElement(\"div\");\n\n\t            var html = [];\n\t            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);\n\t            container.innerHTML = html.join(\"\");\n\t            if (this.$useLineGroups()) {\n\t                container.className = 'ace_line_group';\n\t                fragment.appendChild(container);\n\t                container.style.height = config.lineHeight * this.session.getRowLength(row) + \"px\";\n\n\t            } else {\n\t                while(container.firstChild)\n\t                    fragment.appendChild(container.firstChild);\n\t            }\n\n\t            row++;\n\t        }\n\t        return fragment;\n\t    };\n\n\t    this.update = function(config) {\n\t        this.config = config;\n\n\t        var html = [];\n\t        var firstRow = config.firstRow, lastRow = config.lastRow;\n\n\t        var row = firstRow;\n\t        var foldLine = this.session.getNextFoldLine(row);\n\t        var foldStart = foldLine ? foldLine.start.row : Infinity;\n\n\t        while (true) {\n\t            if (row > foldStart) {\n\t                row = foldLine.end.row+1;\n\t                foldLine = this.session.getNextFoldLine(row, foldLine);\n\t                foldStart = foldLine ? foldLine.start.row :Infinity;\n\t            }\n\t            if (row > lastRow)\n\t                break;\n\n\t            if (this.$useLineGroups())\n\t                html.push(\"<div class='ace_line_group' style='height:\", config.lineHeight*this.session.getRowLength(row), \"px'>\")\n\n\t            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);\n\n\t            if (this.$useLineGroups())\n\t                html.push(\"</div>\"); // end the line group\n\n\t            row++;\n\t        }\n\t        this.element.innerHTML = html.join(\"\");\n\t    };\n\n\t    this.$textToken = {\n\t        \"text\": true,\n\t        \"rparen\": true,\n\t        \"lparen\": true\n\t    };\n\n\t    this.$renderToken = function(stringBuilder, screenColumn, token, value) {\n\t        var self = this;\n\t        var replaceReg = /\\t|&|<|( +)|([\\x00-\\x1f\\x80-\\xa0\\xad\\u1680\\u180E\\u2000-\\u200f\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])|[\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u4DBF\\u4E00-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFAFF\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]/g;\n\t        var replaceFunc = function(c, a, b, tabIdx, idx4) {\n\t            if (a) {\n\t                return self.showInvisibles ?\n\t                    \"<span class='ace_invisible ace_invisible_space'>\" + lang.stringRepeat(self.SPACE_CHAR, c.length) + \"</span>\" :\n\t                    lang.stringRepeat(\"\\xa0\", c.length);\n\t            } else if (c == \"&\") {\n\t                return \"&#38;\";\n\t            } else if (c == \"<\") {\n\t                return \"&#60;\";\n\t            } else if (c == \"\\t\") {\n\t                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);\n\t                screenColumn += tabSize - 1;\n\t                return self.$tabStrings[tabSize];\n\t            } else if (c == \"\\u3000\") {\n\t                var classToUse = self.showInvisibles ? \"ace_cjk ace_invisible ace_invisible_space\" : \"ace_cjk\";\n\t                var space = self.showInvisibles ? self.SPACE_CHAR : \"\";\n\t                screenColumn += 1;\n\t                return \"<span class='\" + classToUse + \"' style='width:\" +\n\t                    (self.config.characterWidth * 2) +\n\t                    \"px'>\" + space + \"</span>\";\n\t            } else if (b) {\n\t                return \"<span class='ace_invisible ace_invisible_space ace_invalid'>\" + self.SPACE_CHAR + \"</span>\";\n\t            } else {\n\t                screenColumn += 1;\n\t                return \"<span class='ace_cjk' style='width:\" +\n\t                    (self.config.characterWidth * 2) +\n\t                    \"px'>\" + c + \"</span>\";\n\t            }\n\t        };\n\n\t        var output = value.replace(replaceReg, replaceFunc);\n\n\t        if (!this.$textToken[token.type]) {\n\t            var classes = \"ace_\" + token.type.replace(/\\./g, \" ace_\");\n\t            var style = \"\";\n\t            if (token.type == \"fold\")\n\t                style = \" style='width:\" + (token.value.length * this.config.characterWidth) + \"px;' \";\n\t            stringBuilder.push(\"<span class='\", classes, \"'\", style, \">\", output, \"</span>\");\n\t        }\n\t        else {\n\t            stringBuilder.push(output);\n\t        }\n\t        return screenColumn + value.length;\n\t    };\n\n\t    this.renderIndentGuide = function(stringBuilder, value, max) {\n\t        var cols = value.search(this.$indentGuideRe);\n\t        if (cols <= 0 || cols >= max)\n\t            return value;\n\t        if (value[0] == \" \") {\n\t            cols -= cols % this.tabSize;\n\t            stringBuilder.push(lang.stringRepeat(this.$tabStrings[\" \"], cols/this.tabSize));\n\t            return value.substr(cols);\n\t        } else if (value[0] == \"\\t\") {\n\t            stringBuilder.push(lang.stringRepeat(this.$tabStrings[\"\\t\"], cols));\n\t            return value.substr(cols);\n\t        }\n\t        return value;\n\t    };\n\n\t    this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {\n\t        var chars = 0;\n\t        var split = 0;\n\t        var splitChars = splits[0];\n\t        var screenColumn = 0;\n\n\t        for (var i = 0; i < tokens.length; i++) {\n\t            var token = tokens[i];\n\t            var value = token.value;\n\t            if (i == 0 && this.displayIndentGuides) {\n\t                chars = value.length;\n\t                value = this.renderIndentGuide(stringBuilder, value, splitChars);\n\t                if (!value)\n\t                    continue;\n\t                chars -= value.length;\n\t            }\n\n\t            if (chars + value.length < splitChars) {\n\t                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);\n\t                chars += value.length;\n\t            } else {\n\t                while (chars + value.length >= splitChars) {\n\t                    screenColumn = this.$renderToken(\n\t                        stringBuilder, screenColumn,\n\t                        token, value.substring(0, splitChars - chars)\n\t                    );\n\t                    value = value.substring(splitChars - chars);\n\t                    chars = splitChars;\n\n\t                    if (!onlyContents) {\n\t                        stringBuilder.push(\"</div>\",\n\t                            \"<div class='ace_line' style='height:\",\n\t                            this.config.lineHeight, \"px'>\"\n\t                        );\n\t                    }\n\n\t                    split ++;\n\t                    screenColumn = 0;\n\t                    splitChars = splits[split] || Number.MAX_VALUE;\n\t                }\n\t                if (value.length != 0) {\n\t                    chars += value.length;\n\t                    screenColumn = this.$renderToken(\n\t                        stringBuilder, screenColumn, token, value\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    this.$renderSimpleLine = function(stringBuilder, tokens) {\n\t        var screenColumn = 0;\n\t        var token = tokens[0];\n\t        var value = token.value;\n\t        if (this.displayIndentGuides)\n\t            value = this.renderIndentGuide(stringBuilder, value);\n\t        if (value)\n\t            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);\n\t        for (var i = 1; i < tokens.length; i++) {\n\t            token = tokens[i];\n\t            value = token.value;\n\t            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);\n\t        }\n\t    };\n\t    this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {\n\t        if (!foldLine && foldLine != false)\n\t            foldLine = this.session.getFoldLine(row);\n\n\t        if (foldLine)\n\t            var tokens = this.$getFoldLineTokens(row, foldLine);\n\t        else\n\t            var tokens = this.session.getTokens(row);\n\n\n\t        if (!onlyContents) {\n\t            stringBuilder.push(\n\t                \"<div class='ace_line' style='height:\", \n\t                    this.config.lineHeight * (\n\t                        this.$useLineGroups() ? 1 :this.session.getRowLength(row)\n\t                    ), \"px'>\"\n\t            );\n\t        }\n\n\t        if (tokens.length) {\n\t            var splits = this.session.getRowSplitData(row);\n\t            if (splits && splits.length)\n\t                this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);\n\t            else\n\t                this.$renderSimpleLine(stringBuilder, tokens);\n\t        }\n\n\t        if (this.showInvisibles) {\n\t            if (foldLine)\n\t                row = foldLine.end.row\n\n\t            stringBuilder.push(\n\t                \"<span class='ace_invisible ace_invisible_eol'>\",\n\t                row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR,\n\t                \"</span>\"\n\t            );\n\t        }\n\t        if (!onlyContents)\n\t            stringBuilder.push(\"</div>\");\n\t    };\n\n\t    this.$getFoldLineTokens = function(row, foldLine) {\n\t        var session = this.session;\n\t        var renderTokens = [];\n\n\t        function addTokens(tokens, from, to) {\n\t            var idx = 0, col = 0;\n\t            while ((col + tokens[idx].value.length) < from) {\n\t                col += tokens[idx].value.length;\n\t                idx++;\n\n\t                if (idx == tokens.length)\n\t                    return;\n\t            }\n\t            if (col != from) {\n\t                var value = tokens[idx].value.substring(from - col);\n\t                if (value.length > (to - from))\n\t                    value = value.substring(0, to - from);\n\n\t                renderTokens.push({\n\t                    type: tokens[idx].type,\n\t                    value: value\n\t                });\n\n\t                col = from + value.length;\n\t                idx += 1;\n\t            }\n\n\t            while (col < to && idx < tokens.length) {\n\t                var value = tokens[idx].value;\n\t                if (value.length + col > to) {\n\t                    renderTokens.push({\n\t                        type: tokens[idx].type,\n\t                        value: value.substring(0, to - col)\n\t                    });\n\t                } else\n\t                    renderTokens.push(tokens[idx]);\n\t                col += value.length;\n\t                idx += 1;\n\t            }\n\t        }\n\n\t        var tokens = session.getTokens(row);\n\t        foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {\n\t            if (placeholder != null) {\n\t                renderTokens.push({\n\t                    type: \"fold\",\n\t                    value: placeholder\n\t                });\n\t            } else {\n\t                if (isNewRow)\n\t                    tokens = session.getTokens(row);\n\n\t                if (tokens.length)\n\t                    addTokens(tokens, lastColumn, column);\n\t            }\n\t        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);\n\n\t        return renderTokens;\n\t    };\n\n\t    this.$useLineGroups = function() {\n\t        return this.session.getUseWrapMode();\n\t    };\n\n\t    this.destroy = function() {\n\t        clearInterval(this.$pollSizeChangesTimer);\n\t        if (this.$measureNode)\n\t            this.$measureNode.parentNode.removeChild(this.$measureNode);\n\t        delete this.$measureNode;\n\t    };\n\n\t}).call(Text.prototype);\n\n\texports.Text = Text;\n\n\t});\n\n\tace.define(\"ace/layer/cursor\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tvar IE8;\n\n\tvar Cursor = function(parentEl) {\n\t    this.element = dom.createElement(\"div\");\n\t    this.element.className = \"ace_layer ace_cursor-layer\";\n\t    parentEl.appendChild(this.element);\n\t    \n\t    if (IE8 === undefined)\n\t        IE8 = \"opacity\" in this.element;\n\n\t    this.isVisible = false;\n\t    this.isBlinking = true;\n\t    this.blinkInterval = 1000;\n\t    this.smoothBlinking = false;\n\n\t    this.cursors = [];\n\t    this.cursor = this.addCursor();\n\t    dom.addCssClass(this.element, \"ace_hidden-cursors\");\n\t    this.$updateCursors = this.$updateVisibility.bind(this);\n\t};\n\n\t(function() {\n\t    \n\t    this.$updateVisibility = function(val) {\n\t        var cursors = this.cursors;\n\t        for (var i = cursors.length; i--; )\n\t            cursors[i].style.visibility = val ? \"\" : \"hidden\";\n\t    };\n\t    this.$updateOpacity = function(val) {\n\t        var cursors = this.cursors;\n\t        for (var i = cursors.length; i--; )\n\t            cursors[i].style.opacity = val ? \"\" : \"0\";\n\t    };\n\t    \n\n\t    this.$padding = 0;\n\t    this.setPadding = function(padding) {\n\t        this.$padding = padding;\n\t    };\n\n\t    this.setSession = function(session) {\n\t        this.session = session;\n\t    };\n\n\t    this.setBlinking = function(blinking) {\n\t        if (blinking != this.isBlinking){\n\t            this.isBlinking = blinking;\n\t            this.restartTimer();\n\t        }\n\t    };\n\n\t    this.setBlinkInterval = function(blinkInterval) {\n\t        if (blinkInterval != this.blinkInterval){\n\t            this.blinkInterval = blinkInterval;\n\t            this.restartTimer();\n\t        }\n\t    };\n\n\t    this.setSmoothBlinking = function(smoothBlinking) {\n\t        if (smoothBlinking != this.smoothBlinking && !IE8) {\n\t            this.smoothBlinking = smoothBlinking;\n\t            dom.setCssClass(this.element, \"ace_smooth-blinking\", smoothBlinking);\n\t            this.$updateCursors(true);\n\t            this.$updateCursors = (smoothBlinking \n\t                ? this.$updateOpacity\n\t                : this.$updateVisibility).bind(this);\n\t            this.restartTimer();\n\t        }\n\t    };\n\n\t    this.addCursor = function() {\n\t        var el = dom.createElement(\"div\");\n\t        el.className = \"ace_cursor\";\n\t        this.element.appendChild(el);\n\t        this.cursors.push(el);\n\t        return el;\n\t    };\n\n\t    this.removeCursor = function() {\n\t        if (this.cursors.length > 1) {\n\t            var el = this.cursors.pop();\n\t            el.parentNode.removeChild(el);\n\t            return el;\n\t        }\n\t    };\n\n\t    this.hideCursor = function() {\n\t        this.isVisible = false;\n\t        dom.addCssClass(this.element, \"ace_hidden-cursors\");\n\t        this.restartTimer();\n\t    };\n\n\t    this.showCursor = function() {\n\t        this.isVisible = true;\n\t        dom.removeCssClass(this.element, \"ace_hidden-cursors\");\n\t        this.restartTimer();\n\t    };\n\n\t    this.restartTimer = function() {\n\t        var update = this.$updateCursors;\n\t        clearInterval(this.intervalId);\n\t        clearTimeout(this.timeoutId);\n\t        if (this.smoothBlinking) {\n\t            dom.removeCssClass(this.element, \"ace_smooth-blinking\");\n\t        }\n\t        \n\t        update(true);\n\n\t        if (!this.isBlinking || !this.blinkInterval || !this.isVisible)\n\t            return;\n\n\t        if (this.smoothBlinking) {\n\t            setTimeout(function(){\n\t                dom.addCssClass(this.element, \"ace_smooth-blinking\");\n\t            }.bind(this));\n\t        }\n\t        \n\t        var blink = function(){\n\t            this.timeoutId = setTimeout(function() {\n\t                update(false);\n\t            }, 0.6 * this.blinkInterval);\n\t        }.bind(this);\n\n\t        this.intervalId = setInterval(function() {\n\t            update(true);\n\t            blink();\n\t        }, this.blinkInterval);\n\n\t        blink();\n\t    };\n\n\t    this.getPixelPosition = function(position, onScreen) {\n\t        if (!this.config || !this.session)\n\t            return {left : 0, top : 0};\n\n\t        if (!position)\n\t            position = this.session.selection.getCursor();\n\t        var pos = this.session.documentToScreenPosition(position);\n\t        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;\n\t        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *\n\t            this.config.lineHeight;\n\n\t        return {left : cursorLeft, top : cursorTop};\n\t    };\n\n\t    this.update = function(config) {\n\t        this.config = config;\n\n\t        var selections = this.session.$selectionMarkers;\n\t        var i = 0, cursorIndex = 0;\n\n\t        if (selections === undefined || selections.length === 0){\n\t            selections = [{cursor: null}];\n\t        }\n\n\t        for (var i = 0, n = selections.length; i < n; i++) {\n\t            var pixelPos = this.getPixelPosition(selections[i].cursor, true);\n\t            if ((pixelPos.top > config.height + config.offset ||\n\t                 pixelPos.top < 0) && i > 1) {\n\t                continue;\n\t            }\n\n\t            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;\n\n\t            style.left = pixelPos.left + \"px\";\n\t            style.top = pixelPos.top + \"px\";\n\t            style.width = config.characterWidth + \"px\";\n\t            style.height = config.lineHeight + \"px\";\n\t        }\n\t        while (this.cursors.length > cursorIndex)\n\t            this.removeCursor();\n\n\t        var overwrite = this.session.getOverwrite();\n\t        this.$setOverwrite(overwrite);\n\t        this.$pixelPos = pixelPos;\n\t        this.restartTimer();\n\t    };\n\n\t    this.$setOverwrite = function(overwrite) {\n\t        if (overwrite != this.overwrite) {\n\t            this.overwrite = overwrite;\n\t            if (overwrite)\n\t                dom.addCssClass(this.element, \"ace_overwrite-cursors\");\n\t            else\n\t                dom.removeCssClass(this.element, \"ace_overwrite-cursors\");\n\t        }\n\t    };\n\n\t    this.destroy = function() {\n\t        clearInterval(this.intervalId);\n\t        clearTimeout(this.timeoutId);\n\t    };\n\n\t}).call(Cursor.prototype);\n\n\texports.Cursor = Cursor;\n\n\t});\n\n\tace.define(\"ace/scrollbar\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar dom = acequire(\"./lib/dom\");\n\tvar event = acequire(\"./lib/event\");\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar ScrollBar = function(parent) {\n\t    this.element = dom.createElement(\"div\");\n\t    this.element.className = \"ace_scrollbar ace_scrollbar\" + this.classSuffix;\n\n\t    this.inner = dom.createElement(\"div\");\n\t    this.inner.className = \"ace_scrollbar-inner\";\n\t    this.element.appendChild(this.inner);\n\n\t    parent.appendChild(this.element);\n\n\t    this.setVisible(false);\n\t    this.skipEvent = false;\n\n\t    event.addListener(this.element, \"scroll\", this.onScroll.bind(this));\n\t    event.addListener(this.element, \"mousedown\", event.preventDefault);\n\t};\n\n\t(function() {\n\t    oop.implement(this, EventEmitter);\n\n\t    this.setVisible = function(isVisible) {\n\t        this.element.style.display = isVisible ? \"\" : \"none\";\n\t        this.isVisible = isVisible;\n\t    };\n\t}).call(ScrollBar.prototype);\n\tvar VScrollBar = function(parent, renderer) {\n\t    ScrollBar.call(this, parent);\n\t    this.scrollTop = 0;\n\t    renderer.$scrollbarWidth = \n\t    this.width = dom.scrollbarWidth(parent.ownerDocument);\n\t    this.inner.style.width =\n\t    this.element.style.width = (this.width || 15) + 5 + \"px\";\n\t};\n\n\toop.inherits(VScrollBar, ScrollBar);\n\n\t(function() {\n\n\t    this.classSuffix = '-v';\n\t    this.onScroll = function() {\n\t        if (!this.skipEvent) {\n\t            this.scrollTop = this.element.scrollTop;\n\t            this._emit(\"scroll\", {data: this.scrollTop});\n\t        }\n\t        this.skipEvent = false;\n\t    };\n\t    this.getWidth = function() {\n\t        return this.isVisible ? this.width : 0;\n\t    };\n\t    this.setHeight = function(height) {\n\t        this.element.style.height = height + \"px\";\n\t    };\n\t    this.setInnerHeight = function(height) {\n\t        this.inner.style.height = height + \"px\";\n\t    };\n\t    this.setScrollHeight = function(height) {\n\t        this.inner.style.height = height + \"px\";\n\t    };\n\t    this.setScrollTop = function(scrollTop) {\n\t        if (this.scrollTop != scrollTop) {\n\t            this.skipEvent = true;\n\t            this.scrollTop = this.element.scrollTop = scrollTop;\n\t        }\n\t    };\n\n\t}).call(VScrollBar.prototype);\n\tvar HScrollBar = function(parent, renderer) {\n\t    ScrollBar.call(this, parent);\n\t    this.scrollLeft = 0;\n\t    this.height = renderer.$scrollbarWidth;\n\t    this.inner.style.height =\n\t    this.element.style.height = (this.height || 15) + 5 + \"px\";\n\t};\n\n\toop.inherits(HScrollBar, ScrollBar);\n\n\t(function() {\n\n\t    this.classSuffix = '-h';\n\t    this.onScroll = function() {\n\t        if (!this.skipEvent) {\n\t            this.scrollLeft = this.element.scrollLeft;\n\t            this._emit(\"scroll\", {data: this.scrollLeft});\n\t        }\n\t        this.skipEvent = false;\n\t    };\n\t    this.getHeight = function() {\n\t        return this.isVisible ? this.height : 0;\n\t    };\n\t    this.setWidth = function(width) {\n\t        this.element.style.width = width + \"px\";\n\t    };\n\t    this.setInnerWidth = function(width) {\n\t        this.inner.style.width = width + \"px\";\n\t    };\n\t    this.setScrollWidth = function(width) {\n\t        this.inner.style.width = width + \"px\";\n\t    };\n\t    this.setScrollLeft = function(scrollLeft) {\n\t        if (this.scrollLeft != scrollLeft) {\n\t            this.skipEvent = true;\n\t            this.scrollLeft = this.element.scrollLeft = scrollLeft;\n\t        }\n\t    };\n\n\t}).call(HScrollBar.prototype);\n\n\n\texports.ScrollBar = VScrollBar; // backward compatibility\n\texports.ScrollBarV = VScrollBar; // backward compatibility\n\texports.ScrollBarH = HScrollBar; // backward compatibility\n\n\texports.VScrollBar = VScrollBar;\n\texports.HScrollBar = HScrollBar;\n\t});\n\n\tace.define(\"ace/renderloop\",[\"require\",\"exports\",\"module\",\"ace/lib/event\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar event = acequire(\"./lib/event\");\n\n\n\tvar RenderLoop = function(onRender, win) {\n\t    this.onRender = onRender;\n\t    this.pending = false;\n\t    this.changes = 0;\n\t    this.window = win || window;\n\t};\n\n\t(function() {\n\n\n\t    this.schedule = function(change) {\n\t        this.changes = this.changes | change;\n\t        if (!this.pending && this.changes) {\n\t            this.pending = true;\n\t            var _self = this;\n\t            event.nextFrame(function() {\n\t                _self.pending = false;\n\t                var changes;\n\t                while (changes = _self.changes) {\n\t                    _self.changes = 0;\n\t                    _self.onRender(changes);\n\t                }\n\t            }, this.window);\n\t        }\n\t    };\n\n\t}).call(RenderLoop.prototype);\n\n\texports.RenderLoop = RenderLoop;\n\t});\n\n\tace.define(\"ace/layer/font_metrics\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/useragent\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\n\tvar oop = acequire(\"../lib/oop\");\n\tvar dom = acequire(\"../lib/dom\");\n\tvar lang = acequire(\"../lib/lang\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tvar EventEmitter = acequire(\"../lib/event_emitter\").EventEmitter;\n\n\tvar CHAR_COUNT = 0;\n\n\tvar FontMetrics = exports.FontMetrics = function(parentEl, interval) {\n\t    this.el = dom.createElement(\"div\");\n\t    this.$setMeasureNodeStyles(this.el.style, true);\n\t    \n\t    this.$main = dom.createElement(\"div\");\n\t    this.$setMeasureNodeStyles(this.$main.style);\n\t    \n\t    this.$measureNode = dom.createElement(\"div\");\n\t    this.$setMeasureNodeStyles(this.$measureNode.style);\n\t    \n\t    \n\t    this.el.appendChild(this.$main);\n\t    this.el.appendChild(this.$measureNode);\n\t    parentEl.appendChild(this.el);\n\t    \n\t    if (!CHAR_COUNT)\n\t        this.$testFractionalRect();\n\t    this.$measureNode.innerHTML = lang.stringRepeat(\"X\", CHAR_COUNT);\n\t    \n\t    this.$characterSize = {width: 0, height: 0};\n\t    this.checkForSizeChanges();\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\t        \n\t    this.$characterSize = {width: 0, height: 0};\n\t    \n\t    this.$testFractionalRect = function() {\n\t        var el = dom.createElement(\"div\");\n\t        this.$setMeasureNodeStyles(el.style);\n\t        el.style.width = \"0.2px\";\n\t        document.documentElement.appendChild(el);\n\t        var w = el.getBoundingClientRect().width;\n\t        if (w > 0 && w < 1)\n\t            CHAR_COUNT = 50;\n\t        else\n\t            CHAR_COUNT = 100;\n\t        el.parentNode.removeChild(el);\n\t    };\n\t    \n\t    this.$setMeasureNodeStyles = function(style, isRoot) {\n\t        style.width = style.height = \"auto\";\n\t        style.left = style.top = \"-100px\";\n\t        style.visibility = \"hidden\";\n\t        style.position = \"fixed\";\n\t        style.whiteSpace = \"pre\";\n\n\t        if (useragent.isIE < 8) {\n\t            style[\"font-family\"] = \"inherit\";\n\t        } else {\n\t            style.font = \"inherit\";\n\t        }\n\t        style.overflow = isRoot ? \"hidden\" : \"visible\";\n\t    };\n\n\t    this.checkForSizeChanges = function() {\n\t        var size = this.$measureSizes();\n\t        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {\n\t            this.$measureNode.style.fontWeight = \"bold\";\n\t            var boldSize = this.$measureSizes();\n\t            this.$measureNode.style.fontWeight = \"\";\n\t            this.$characterSize = size;\n\t            this.charSizes = Object.create(null);\n\t            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;\n\t            this._emit(\"changeCharacterSize\", {data: size});\n\t        }\n\t    };\n\n\t    this.$pollSizeChanges = function() {\n\t        if (this.$pollSizeChangesTimer)\n\t            return this.$pollSizeChangesTimer;\n\t        var self = this;\n\t        return this.$pollSizeChangesTimer = setInterval(function() {\n\t            self.checkForSizeChanges();\n\t        }, 500);\n\t    };\n\t    \n\t    this.setPolling = function(val) {\n\t        if (val) {\n\t            this.$pollSizeChanges();\n\t        } else {\n\t            if (this.$pollSizeChangesTimer)\n\t                this.$pollSizeChangesTimer;\n\t        }\n\t    };\n\n\t    this.$measureSizes = function() {\n\t        if (CHAR_COUNT === 50) {\n\t            var rect = null;\n\t            try { \n\t               rect = this.$measureNode.getBoundingClientRect();\n\t            } catch(e) {\n\t               rect = {width: 0, height:0 };\n\t            };\n\t            var size = {\n\t                height: rect.height,\n\t                width: rect.width / CHAR_COUNT\n\t            };\n\t        } else {\n\t            var size = {\n\t                height: this.$measureNode.clientHeight,\n\t                width: this.$measureNode.clientWidth / CHAR_COUNT\n\t            };\n\t        }\n\t        if (size.width === 0 || size.height === 0)\n\t            return null;\n\t        return size;\n\t    };\n\n\t    this.$measureCharWidth = function(ch) {\n\t        this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);\n\t        var rect = this.$main.getBoundingClientRect();\n\t        return rect.width / CHAR_COUNT;\n\t    };\n\t    \n\t    this.getCharacterWidth = function(ch) {\n\t        var w = this.charSizes[ch];\n\t        if (w === undefined) {\n\t            this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;\n\t        }\n\t        return w;\n\t    };\n\n\t    this.destroy = function() {\n\t        clearInterval(this.$pollSizeChangesTimer);\n\t        if (this.el && this.el.parentNode)\n\t            this.el.parentNode.removeChild(this.el);\n\t    };\n\n\t}).call(FontMetrics.prototype);\n\n\t});\n\n\tace.define(\"ace/virtual_renderer\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/config\",\"ace/lib/useragent\",\"ace/layer/gutter\",\"ace/layer/marker\",\"ace/layer/text\",\"ace/layer/cursor\",\"ace/scrollbar\",\"ace/scrollbar\",\"ace/renderloop\",\"ace/layer/font_metrics\",\"ace/lib/event_emitter\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar dom = acequire(\"./lib/dom\");\n\tvar config = acequire(\"./config\");\n\tvar useragent = acequire(\"./lib/useragent\");\n\tvar GutterLayer = acequire(\"./layer/gutter\").Gutter;\n\tvar MarkerLayer = acequire(\"./layer/marker\").Marker;\n\tvar TextLayer = acequire(\"./layer/text\").Text;\n\tvar CursorLayer = acequire(\"./layer/cursor\").Cursor;\n\tvar HScrollBar = acequire(\"./scrollbar\").HScrollBar;\n\tvar VScrollBar = acequire(\"./scrollbar\").VScrollBar;\n\tvar RenderLoop = acequire(\"./renderloop\").RenderLoop;\n\tvar FontMetrics = acequire(\"./layer/font_metrics\").FontMetrics;\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar editorCss = \".ace_editor {\\\n\tposition: relative;\\\n\toverflow: hidden;\\\n\tfont: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\\\n\tdirection: ltr;\\\n\t}\\\n\t.ace_scroller {\\\n\tposition: absolute;\\\n\toverflow: hidden;\\\n\ttop: 0;\\\n\tbottom: 0;\\\n\tbackground-color: inherit;\\\n\t-ms-user-select: none;\\\n\t-moz-user-select: none;\\\n\t-webkit-user-select: none;\\\n\tuser-select: none;\\\n\tcursor: text;\\\n\t}\\\n\t.ace_content {\\\n\tposition: absolute;\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tmin-width: 100%;\\\n\t}\\\n\t.ace_dragging .ace_scroller:before{\\\n\tposition: absolute;\\\n\ttop: 0;\\\n\tleft: 0;\\\n\tright: 0;\\\n\tbottom: 0;\\\n\tcontent: '';\\\n\tbackground: rgba(250, 250, 250, 0.01);\\\n\tz-index: 1000;\\\n\t}\\\n\t.ace_dragging.ace_dark .ace_scroller:before{\\\n\tbackground: rgba(0, 0, 0, 0.01);\\\n\t}\\\n\t.ace_selecting, .ace_selecting * {\\\n\tcursor: text !important;\\\n\t}\\\n\t.ace_gutter {\\\n\tposition: absolute;\\\n\toverflow : hidden;\\\n\twidth: auto;\\\n\ttop: 0;\\\n\tbottom: 0;\\\n\tleft: 0;\\\n\tcursor: default;\\\n\tz-index: 4;\\\n\t-ms-user-select: none;\\\n\t-moz-user-select: none;\\\n\t-webkit-user-select: none;\\\n\tuser-select: none;\\\n\t}\\\n\t.ace_gutter-active-line {\\\n\tposition: absolute;\\\n\tleft: 0;\\\n\tright: 0;\\\n\t}\\\n\t.ace_scroller.ace_scroll-left {\\\n\tbox-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\\\n\t}\\\n\t.ace_gutter-cell {\\\n\tpadding-left: 19px;\\\n\tpadding-right: 6px;\\\n\tbackground-repeat: no-repeat;\\\n\t}\\\n\t.ace_gutter-cell.ace_error {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\\\");\\\n\tbackground-repeat: no-repeat;\\\n\tbackground-position: 2px center;\\\n\t}\\\n\t.ace_gutter-cell.ace_warning {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\\\");\\\n\tbackground-position: 2px center;\\\n\t}\\\n\t.ace_gutter-cell.ace_info {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\\\");\\\n\tbackground-position: 2px center;\\\n\t}\\\n\t.ace_dark .ace_gutter-cell.ace_info {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\\\");\\\n\t}\\\n\t.ace_scrollbar {\\\n\tposition: absolute;\\\n\tright: 0;\\\n\tbottom: 0;\\\n\tz-index: 6;\\\n\t}\\\n\t.ace_scrollbar-inner {\\\n\tposition: absolute;\\\n\tcursor: text;\\\n\tleft: 0;\\\n\ttop: 0;\\\n\t}\\\n\t.ace_scrollbar-v{\\\n\toverflow-x: hidden;\\\n\toverflow-y: scroll;\\\n\ttop: 0;\\\n\t}\\\n\t.ace_scrollbar-h {\\\n\toverflow-x: scroll;\\\n\toverflow-y: hidden;\\\n\tleft: 0;\\\n\t}\\\n\t.ace_print-margin {\\\n\tposition: absolute;\\\n\theight: 100%;\\\n\t}\\\n\t.ace_text-input {\\\n\tposition: absolute;\\\n\tz-index: 0;\\\n\twidth: 0.5em;\\\n\theight: 1em;\\\n\topacity: 0;\\\n\tbackground: transparent;\\\n\t-moz-appearance: none;\\\n\tappearance: none;\\\n\tborder: none;\\\n\tresize: none;\\\n\toutline: none;\\\n\toverflow: hidden;\\\n\tfont: inherit;\\\n\tpadding: 0 1px;\\\n\tmargin: 0 -1px;\\\n\ttext-indent: -1em;\\\n\t-ms-user-select: text;\\\n\t-moz-user-select: text;\\\n\t-webkit-user-select: text;\\\n\tuser-select: text;\\\n\t}\\\n\t.ace_text-input.ace_composition {\\\n\tbackground: inherit;\\\n\tcolor: inherit;\\\n\tz-index: 1000;\\\n\topacity: 1;\\\n\ttext-indent: 0;\\\n\t}\\\n\t.ace_layer {\\\n\tz-index: 1;\\\n\tposition: absolute;\\\n\toverflow: hidden;\\\n\twhite-space: pre;\\\n\theight: 100%;\\\n\twidth: 100%;\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tpointer-events: none;\\\n\t}\\\n\t.ace_gutter-layer {\\\n\tposition: relative;\\\n\twidth: auto;\\\n\ttext-align: right;\\\n\tpointer-events: auto;\\\n\t}\\\n\t.ace_text-layer {\\\n\tfont: inherit !important;\\\n\t}\\\n\t.ace_cjk {\\\n\tdisplay: inline-block;\\\n\ttext-align: center;\\\n\t}\\\n\t.ace_cursor-layer {\\\n\tz-index: 4;\\\n\t}\\\n\t.ace_cursor {\\\n\tz-index: 4;\\\n\tposition: absolute;\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tborder-left: 2px solid\\\n\t}\\\n\t.ace_slim-cursors .ace_cursor {\\\n\tborder-left-width: 1px;\\\n\t}\\\n\t.ace_overwrite-cursors .ace_cursor {\\\n\tborder-left-width: 0;\\\n\tborder-bottom: 1px solid;\\\n\t}\\\n\t.ace_hidden-cursors .ace_cursor {\\\n\topacity: 0.2;\\\n\t}\\\n\t.ace_smooth-blinking .ace_cursor {\\\n\t-webkit-transition: opacity 0.18s;\\\n\ttransition: opacity 0.18s;\\\n\t}\\\n\t.ace_editor.ace_multiselect .ace_cursor {\\\n\tborder-left-width: 1px;\\\n\t}\\\n\t.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\\\n\tposition: absolute;\\\n\tz-index: 3;\\\n\t}\\\n\t.ace_marker-layer .ace_selection {\\\n\tposition: absolute;\\\n\tz-index: 5;\\\n\t}\\\n\t.ace_marker-layer .ace_bracket {\\\n\tposition: absolute;\\\n\tz-index: 6;\\\n\t}\\\n\t.ace_marker-layer .ace_active-line {\\\n\tposition: absolute;\\\n\tz-index: 2;\\\n\t}\\\n\t.ace_marker-layer .ace_selected-word {\\\n\tposition: absolute;\\\n\tz-index: 4;\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\t}\\\n\t.ace_line .ace_fold {\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tdisplay: inline-block;\\\n\theight: 11px;\\\n\tmargin-top: -2px;\\\n\tvertical-align: middle;\\\n\tbackground-image:\\\n\turl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\n\turl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\\\");\\\n\tbackground-repeat: no-repeat, repeat-x;\\\n\tbackground-position: center center, top left;\\\n\tcolor: transparent;\\\n\tborder: 1px solid black;\\\n\tborder-radius: 2px;\\\n\tcursor: pointer;\\\n\tpointer-events: auto;\\\n\t}\\\n\t.ace_dark .ace_fold {\\\n\t}\\\n\t.ace_fold:hover{\\\n\tbackground-image:\\\n\turl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\\\"),\\\n\turl(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\\\");\\\n\t}\\\n\t.ace_tooltip {\\\n\tbackground-color: #FFF;\\\n\tbackground-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\\\n\tbackground-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\\\n\tborder: 1px solid gray;\\\n\tborder-radius: 1px;\\\n\tbox-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\\\n\tcolor: black;\\\n\tmax-width: 100%;\\\n\tpadding: 3px 4px;\\\n\tposition: fixed;\\\n\tz-index: 999999;\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tcursor: default;\\\n\twhite-space: pre;\\\n\tword-wrap: break-word;\\\n\tline-height: normal;\\\n\tfont-style: normal;\\\n\tfont-weight: normal;\\\n\tletter-spacing: normal;\\\n\tpointer-events: none;\\\n\t}\\\n\t.ace_folding-enabled > .ace_gutter-cell {\\\n\tpadding-right: 13px;\\\n\t}\\\n\t.ace_fold-widget {\\\n\t-moz-box-sizing: border-box;\\\n\t-webkit-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tmargin: 0 -12px 0 1px;\\\n\tdisplay: none;\\\n\twidth: 11px;\\\n\tvertical-align: top;\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\\\");\\\n\tbackground-repeat: no-repeat;\\\n\tbackground-position: center;\\\n\tborder-radius: 3px;\\\n\tborder: 1px solid transparent;\\\n\tcursor: pointer;\\\n\t}\\\n\t.ace_folding-enabled .ace_fold-widget {\\\n\tdisplay: inline-block;   \\\n\t}\\\n\t.ace_fold-widget.ace_end {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\\\");\\\n\t}\\\n\t.ace_fold-widget.ace_closed {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\\\");\\\n\t}\\\n\t.ace_fold-widget:hover {\\\n\tborder: 1px solid rgba(0, 0, 0, 0.3);\\\n\tbackground-color: rgba(255, 255, 255, 0.2);\\\n\tbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\\\n\t}\\\n\t.ace_fold-widget:active {\\\n\tborder: 1px solid rgba(0, 0, 0, 0.4);\\\n\tbackground-color: rgba(0, 0, 0, 0.05);\\\n\tbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\\\n\t}\\\n\t.ace_dark .ace_fold-widget {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\\\");\\\n\t}\\\n\t.ace_dark .ace_fold-widget.ace_end {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\\\");\\\n\t}\\\n\t.ace_dark .ace_fold-widget.ace_closed {\\\n\tbackground-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\\\");\\\n\t}\\\n\t.ace_dark .ace_fold-widget:hover {\\\n\tbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\n\tbackground-color: rgba(255, 255, 255, 0.1);\\\n\t}\\\n\t.ace_dark .ace_fold-widget:active {\\\n\tbox-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\\\n\t}\\\n\t.ace_fold-widget.ace_invalid {\\\n\tbackground-color: #FFB4B4;\\\n\tborder-color: #DE5555;\\\n\t}\\\n\t.ace_fade-fold-widgets .ace_fold-widget {\\\n\t-webkit-transition: opacity 0.4s ease 0.05s;\\\n\ttransition: opacity 0.4s ease 0.05s;\\\n\topacity: 0;\\\n\t}\\\n\t.ace_fade-fold-widgets:hover .ace_fold-widget {\\\n\t-webkit-transition: opacity 0.05s ease 0.05s;\\\n\ttransition: opacity 0.05s ease 0.05s;\\\n\topacity:1;\\\n\t}\\\n\t.ace_underline {\\\n\ttext-decoration: underline;\\\n\t}\\\n\t.ace_bold {\\\n\tfont-weight: bold;\\\n\t}\\\n\t.ace_nobold .ace_bold {\\\n\tfont-weight: normal;\\\n\t}\\\n\t.ace_italic {\\\n\tfont-style: italic;\\\n\t}\\\n\t.ace_error-marker {\\\n\tbackground-color: rgba(255, 0, 0,0.2);\\\n\tposition: absolute;\\\n\tz-index: 9;\\\n\t}\\\n\t.ace_highlight-marker {\\\n\tbackground-color: rgba(255, 255, 0,0.2);\\\n\tposition: absolute;\\\n\tz-index: 8;\\\n\t}\\\n\t\";\n\n\tdom.importCssString(editorCss, \"ace_editor\");\n\n\tvar VirtualRenderer = function(container, theme) {\n\t    var _self = this;\n\n\t    this.container = container || dom.createElement(\"div\");\n\t    this.$keepTextAreaAtCursor = !useragent.isOldIE;\n\n\t    dom.addCssClass(this.container, \"ace_editor\");\n\n\t    this.setTheme(theme);\n\n\t    this.$gutter = dom.createElement(\"div\");\n\t    this.$gutter.className = \"ace_gutter\";\n\t    this.container.appendChild(this.$gutter);\n\n\t    this.scroller = dom.createElement(\"div\");\n\t    this.scroller.className = \"ace_scroller\";\n\t    this.container.appendChild(this.scroller);\n\n\t    this.content = dom.createElement(\"div\");\n\t    this.content.className = \"ace_content\";\n\t    this.scroller.appendChild(this.content);\n\n\t    this.$gutterLayer = new GutterLayer(this.$gutter);\n\t    this.$gutterLayer.on(\"changeGutterWidth\", this.onGutterResize.bind(this));\n\n\t    this.$markerBack = new MarkerLayer(this.content);\n\n\t    var textLayer = this.$textLayer = new TextLayer(this.content);\n\t    this.canvas = textLayer.element;\n\n\t    this.$markerFront = new MarkerLayer(this.content);\n\n\t    this.$cursorLayer = new CursorLayer(this.content);\n\t    this.$horizScroll = false;\n\t    this.$vScroll = false;\n\n\t    this.scrollBar = \n\t    this.scrollBarV = new VScrollBar(this.container, this);\n\t    this.scrollBarH = new HScrollBar(this.container, this);\n\t    this.scrollBarV.addEventListener(\"scroll\", function(e) {\n\t        if (!_self.$scrollAnimation)\n\t            _self.session.setScrollTop(e.data - _self.scrollMargin.top);\n\t    });\n\t    this.scrollBarH.addEventListener(\"scroll\", function(e) {\n\t        if (!_self.$scrollAnimation)\n\t            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);\n\t    });\n\n\t    this.scrollTop = 0;\n\t    this.scrollLeft = 0;\n\n\t    this.cursorPos = {\n\t        row : 0,\n\t        column : 0\n\t    };\n\n\t    this.$fontMetrics = new FontMetrics(this.container, 500);\n\t    this.$textLayer.$setFontMetrics(this.$fontMetrics);\n\t    this.$textLayer.addEventListener(\"changeCharacterSize\", function(e) {\n\t        _self.updateCharacterSize();\n\t        _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);\n\t        _self._signal(\"changeCharacterSize\", e);\n\t    });\n\n\t    this.$size = {\n\t        width: 0,\n\t        height: 0,\n\t        scrollerHeight: 0,\n\t        scrollerWidth: 0,\n\t        $dirty: true\n\t    };\n\n\t    this.layerConfig = {\n\t        width : 1,\n\t        padding : 0,\n\t        firstRow : 0,\n\t        firstRowScreen: 0,\n\t        lastRow : 0,\n\t        lineHeight : 0,\n\t        characterWidth : 0,\n\t        minHeight : 1,\n\t        maxHeight : 1,\n\t        offset : 0,\n\t        height : 1,\n\t        gutterOffset: 1\n\t    };\n\t    \n\t    this.scrollMargin = {\n\t        left: 0,\n\t        right: 0,\n\t        top: 0,\n\t        bottom: 0,\n\t        v: 0,\n\t        h: 0\n\t    };\n\n\t    this.$loop = new RenderLoop(\n\t        this.$renderChanges.bind(this),\n\t        this.container.ownerDocument.defaultView\n\t    );\n\t    this.$loop.schedule(this.CHANGE_FULL);\n\n\t    this.updateCharacterSize();\n\t    this.setPadding(4);\n\t    config.resetOptions(this);\n\t    config._emit(\"renderer\", this);\n\t};\n\n\t(function() {\n\n\t    this.CHANGE_CURSOR = 1;\n\t    this.CHANGE_MARKER = 2;\n\t    this.CHANGE_GUTTER = 4;\n\t    this.CHANGE_SCROLL = 8;\n\t    this.CHANGE_LINES = 16;\n\t    this.CHANGE_TEXT = 32;\n\t    this.CHANGE_SIZE = 64;\n\t    this.CHANGE_MARKER_BACK = 128;\n\t    this.CHANGE_MARKER_FRONT = 256;\n\t    this.CHANGE_FULL = 512;\n\t    this.CHANGE_H_SCROLL = 1024;\n\n\t    oop.implement(this, EventEmitter);\n\n\t    this.updateCharacterSize = function() {\n\t        if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {\n\t            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;\n\t            this.setStyle(\"ace_nobold\", !this.$allowBoldFonts);\n\t        }\n\n\t        this.layerConfig.characterWidth =\n\t        this.characterWidth = this.$textLayer.getCharacterWidth();\n\t        this.layerConfig.lineHeight =\n\t        this.lineHeight = this.$textLayer.getLineHeight();\n\t        this.$updatePrintMargin();\n\t    };\n\t    this.setSession = function(session) {\n\t        if (this.session)\n\t            this.session.doc.off(\"changeNewLineMode\", this.onChangeNewLineMode);\n\t            \n\t        this.session = session;\n\t        if (session && this.scrollMargin.top && session.getScrollTop() <= 0)\n\t            session.setScrollTop(-this.scrollMargin.top);\n\n\t        this.$cursorLayer.setSession(session);\n\t        this.$markerBack.setSession(session);\n\t        this.$markerFront.setSession(session);\n\t        this.$gutterLayer.setSession(session);\n\t        this.$textLayer.setSession(session);\n\t        if (!session)\n\t            return;\n\t        \n\t        this.$loop.schedule(this.CHANGE_FULL);\n\t        this.session.$setFontMetrics(this.$fontMetrics);\n\t        \n\t        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);\n\t        this.onChangeNewLineMode()\n\t        this.session.doc.on(\"changeNewLineMode\", this.onChangeNewLineMode);\n\t    };\n\t    this.updateLines = function(firstRow, lastRow, force) {\n\t        if (lastRow === undefined)\n\t            lastRow = Infinity;\n\n\t        if (!this.$changedLines) {\n\t            this.$changedLines = {\n\t                firstRow: firstRow,\n\t                lastRow: lastRow\n\t            };\n\t        }\n\t        else {\n\t            if (this.$changedLines.firstRow > firstRow)\n\t                this.$changedLines.firstRow = firstRow;\n\n\t            if (this.$changedLines.lastRow < lastRow)\n\t                this.$changedLines.lastRow = lastRow;\n\t        }\n\t        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {\n\t            if (force)\n\t                this.$changedLines.lastRow = this.layerConfig.lastRow;\n\t            else\n\t                return;\n\t        }\n\t        if (this.$changedLines.firstRow > this.layerConfig.lastRow)\n\t            return;\n\t        this.$loop.schedule(this.CHANGE_LINES);\n\t    };\n\n\t    this.onChangeNewLineMode = function() {\n\t        this.$loop.schedule(this.CHANGE_TEXT);\n\t        this.$textLayer.$updateEolChar();\n\t    };\n\t    \n\t    this.onChangeTabSize = function() {\n\t        this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);\n\t        this.$textLayer.onChangeTabSize();\n\t    };\n\t    this.updateText = function() {\n\t        this.$loop.schedule(this.CHANGE_TEXT);\n\t    };\n\t    this.updateFull = function(force) {\n\t        if (force)\n\t            this.$renderChanges(this.CHANGE_FULL, true);\n\t        else\n\t            this.$loop.schedule(this.CHANGE_FULL);\n\t    };\n\t    this.updateFontSize = function() {\n\t        this.$textLayer.checkForSizeChanges();\n\t    };\n\n\t    this.$changes = 0;\n\t    this.$updateSizeAsync = function() {\n\t        if (this.$loop.pending)\n\t            this.$size.$dirty = true;\n\t        else\n\t            this.onResize();\n\t    };\n\t    this.onResize = function(force, gutterWidth, width, height) {\n\t        if (this.resizing > 2)\n\t            return;\n\t        else if (this.resizing > 0)\n\t            this.resizing++;\n\t        else\n\t            this.resizing = force ? 1 : 0;\n\t        var el = this.container;\n\t        if (!height)\n\t            height = el.clientHeight || el.scrollHeight;\n\t        if (!width)\n\t            width = el.clientWidth || el.scrollWidth;\n\t        var changes = this.$updateCachedSize(force, gutterWidth, width, height);\n\n\t        \n\t        if (!this.$size.scrollerHeight || (!width && !height))\n\t            return this.resizing = 0;\n\n\t        if (force)\n\t            this.$gutterLayer.$padding = null;\n\n\t        if (force)\n\t            this.$renderChanges(changes | this.$changes, true);\n\t        else\n\t            this.$loop.schedule(changes | this.$changes);\n\n\t        if (this.resizing)\n\t            this.resizing = 0;\n\t    };\n\t    \n\t    this.$updateCachedSize = function(force, gutterWidth, width, height) {\n\t        height -= (this.$extraHeight || 0);\n\t        var changes = 0;\n\t        var size = this.$size;\n\t        var oldSize = {\n\t            width: size.width,\n\t            height: size.height,\n\t            scrollerHeight: size.scrollerHeight,\n\t            scrollerWidth: size.scrollerWidth\n\t        };\n\t        if (height && (force || size.height != height)) {\n\t            size.height = height;\n\t            changes |= this.CHANGE_SIZE;\n\n\t            size.scrollerHeight = size.height;\n\t            if (this.$horizScroll)\n\t                size.scrollerHeight -= this.scrollBarH.getHeight();\n\t            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + \"px\";\n\n\t            changes = changes | this.CHANGE_SCROLL;\n\t        }\n\n\t        if (width && (force || size.width != width)) {\n\t            changes |= this.CHANGE_SIZE;\n\t            size.width = width;\n\t            \n\t            if (gutterWidth == null)\n\t                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n\t            \n\t            this.gutterWidth = gutterWidth;\n\t            \n\t            this.scrollBarH.element.style.left = \n\t            this.scroller.style.left = gutterWidth + \"px\";\n\t            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());           \n\t            \n\t            this.scrollBarH.element.style.right = \n\t            this.scroller.style.right = this.scrollBarV.getWidth() + \"px\";\n\t            this.scroller.style.bottom = this.scrollBarH.getHeight() + \"px\";\n\n\t            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)\n\t                changes |= this.CHANGE_FULL;\n\t        }\n\t        \n\t        size.$dirty = !width || !height;\n\n\t        if (changes)\n\t            this._signal(\"resize\", oldSize);\n\n\t        return changes;\n\t    };\n\n\t    this.onGutterResize = function() {\n\t        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;\n\t        if (gutterWidth != this.gutterWidth)\n\t            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);\n\n\t        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {\n\t            this.$loop.schedule(this.CHANGE_FULL);\n\t        } else if (this.$size.$dirty) {\n\t            this.$loop.schedule(this.CHANGE_FULL);\n\t        } else {\n\t            this.$computeLayerConfig();\n\t            this.$loop.schedule(this.CHANGE_MARKER);\n\t        }\n\t    };\n\t    this.adjustWrapLimit = function() {\n\t        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;\n\t        var limit = Math.floor(availableWidth / this.characterWidth);\n\t        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);\n\t    };\n\t    this.setAnimatedScroll = function(shouldAnimate){\n\t        this.setOption(\"animatedScroll\", shouldAnimate);\n\t    };\n\t    this.getAnimatedScroll = function() {\n\t        return this.$animatedScroll;\n\t    };\n\t    this.setShowInvisibles = function(showInvisibles) {\n\t        this.setOption(\"showInvisibles\", showInvisibles);\n\t    };\n\t    this.getShowInvisibles = function() {\n\t        return this.getOption(\"showInvisibles\");\n\t    };\n\t    this.getDisplayIndentGuides = function() {\n\t        return this.getOption(\"displayIndentGuides\");\n\t    };\n\n\t    this.setDisplayIndentGuides = function(display) {\n\t        this.setOption(\"displayIndentGuides\", display);\n\t    };\n\t    this.setShowPrintMargin = function(showPrintMargin) {\n\t        this.setOption(\"showPrintMargin\", showPrintMargin);\n\t    };\n\t    this.getShowPrintMargin = function() {\n\t        return this.getOption(\"showPrintMargin\");\n\t    };\n\t    this.setPrintMarginColumn = function(showPrintMargin) {\n\t        this.setOption(\"printMarginColumn\", showPrintMargin);\n\t    };\n\t    this.getPrintMarginColumn = function() {\n\t        return this.getOption(\"printMarginColumn\");\n\t    };\n\t    this.getShowGutter = function(){\n\t        return this.getOption(\"showGutter\");\n\t    };\n\t    this.setShowGutter = function(show){\n\t        return this.setOption(\"showGutter\", show);\n\t    };\n\n\t    this.getFadeFoldWidgets = function(){\n\t        return this.getOption(\"fadeFoldWidgets\")\n\t    };\n\n\t    this.setFadeFoldWidgets = function(show) {\n\t        this.setOption(\"fadeFoldWidgets\", show);\n\t    };\n\n\t    this.setHighlightGutterLine = function(shouldHighlight) {\n\t        this.setOption(\"highlightGutterLine\", shouldHighlight);\n\t    };\n\n\t    this.getHighlightGutterLine = function() {\n\t        return this.getOption(\"highlightGutterLine\");\n\t    };\n\n\t    this.$updateGutterLineHighlight = function() {\n\t        var pos = this.$cursorLayer.$pixelPos;\n\t        var height = this.layerConfig.lineHeight;\n\t        if (this.session.getUseWrapMode()) {\n\t            var cursor = this.session.selection.getCursor();\n\t            cursor.column = 0;\n\t            pos = this.$cursorLayer.getPixelPosition(cursor, true);\n\t            height *= this.session.getRowLength(cursor.row);\n\t        }\n\t        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + \"px\";\n\t        this.$gutterLineHighlight.style.height = height + \"px\";\n\t    };\n\n\t    this.$updatePrintMargin = function() {\n\t        if (!this.$showPrintMargin && !this.$printMarginEl)\n\t            return;\n\n\t        if (!this.$printMarginEl) {\n\t            var containerEl = dom.createElement(\"div\");\n\t            containerEl.className = \"ace_layer ace_print-margin-layer\";\n\t            this.$printMarginEl = dom.createElement(\"div\");\n\t            this.$printMarginEl.className = \"ace_print-margin\";\n\t            containerEl.appendChild(this.$printMarginEl);\n\t            this.content.insertBefore(containerEl, this.content.firstChild);\n\t        }\n\n\t        var style = this.$printMarginEl.style;\n\t        style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + \"px\";\n\t        style.visibility = this.$showPrintMargin ? \"visible\" : \"hidden\";\n\t        \n\t        if (this.session && this.session.$wrap == -1)\n\t            this.adjustWrapLimit();\n\t    };\n\t    this.getContainerElement = function() {\n\t        return this.container;\n\t    };\n\t    this.getMouseEventTarget = function() {\n\t        return this.content;\n\t    };\n\t    this.getTextAreaContainer = function() {\n\t        return this.container;\n\t    };\n\t    this.$moveTextAreaToCursor = function() {\n\t        if (!this.$keepTextAreaAtCursor)\n\t            return;\n\t        var config = this.layerConfig;\n\t        var posTop = this.$cursorLayer.$pixelPos.top;\n\t        var posLeft = this.$cursorLayer.$pixelPos.left;\n\t        posTop -= config.offset;\n\n\t        var h = this.lineHeight;\n\t        if (posTop < 0 || posTop > config.height - h)\n\t            return;\n\n\t        var w = this.characterWidth;\n\t        if (this.$composition) {\n\t            var val = this.textarea.value.replace(/^\\x01+/, \"\");\n\t            w *= (this.session.$getStringScreenWidth(val)[0]+2);\n\t            h += 2;\n\t        }\n\t        posLeft -= this.scrollLeft;\n\t        if (posLeft > this.$size.scrollerWidth - w)\n\t            posLeft = this.$size.scrollerWidth - w;\n\n\t        posLeft += this.gutterWidth;\n\n\t        this.textarea.style.height = h + \"px\";\n\t        this.textarea.style.width = w + \"px\";\n\t        this.textarea.style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + \"px\";\n\t        this.textarea.style.top = Math.min(posTop, this.$size.height - h) + \"px\";\n\t    };\n\t    this.getFirstVisibleRow = function() {\n\t        return this.layerConfig.firstRow;\n\t    };\n\t    this.getFirstFullyVisibleRow = function() {\n\t        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);\n\t    };\n\t    this.getLastFullyVisibleRow = function() {\n\t        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);\n\t        return this.layerConfig.firstRow - 1 + flint;\n\t    };\n\t    this.getLastVisibleRow = function() {\n\t        return this.layerConfig.lastRow;\n\t    };\n\n\t    this.$padding = null;\n\t    this.setPadding = function(padding) {\n\t        this.$padding = padding;\n\t        this.$textLayer.setPadding(padding);\n\t        this.$cursorLayer.setPadding(padding);\n\t        this.$markerFront.setPadding(padding);\n\t        this.$markerBack.setPadding(padding);\n\t        this.$loop.schedule(this.CHANGE_FULL);\n\t        this.$updatePrintMargin();\n\t    };\n\t    \n\t    this.setScrollMargin = function(top, bottom, left, right) {\n\t        var sm = this.scrollMargin;\n\t        sm.top = top|0;\n\t        sm.bottom = bottom|0;\n\t        sm.right = right|0;\n\t        sm.left = left|0;\n\t        sm.v = sm.top + sm.bottom;\n\t        sm.h = sm.left + sm.right;\n\t        if (sm.top && this.scrollTop <= 0 && this.session)\n\t            this.session.setScrollTop(-sm.top);\n\t        this.updateFull();\n\t    };\n\t    this.getHScrollBarAlwaysVisible = function() {\n\t        return this.$hScrollBarAlwaysVisible;\n\t    };\n\t    this.setHScrollBarAlwaysVisible = function(alwaysVisible) {\n\t        this.setOption(\"hScrollBarAlwaysVisible\", alwaysVisible);\n\t    };\n\t    this.getVScrollBarAlwaysVisible = function() {\n\t        return this.$hScrollBarAlwaysVisible;\n\t    };\n\t    this.setVScrollBarAlwaysVisible = function(alwaysVisible) {\n\t        this.setOption(\"vScrollBarAlwaysVisible\", alwaysVisible);\n\t    };\n\n\t    this.$updateScrollBarV = function() {\n\t        var scrollHeight = this.layerConfig.maxHeight;\n\t        var scrollerHeight = this.$size.scrollerHeight;\n\t        if (!this.$maxLines && this.$scrollPastEnd) {\n\t            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;\n\t            if (this.scrollTop > scrollHeight - scrollerHeight) {\n\t                scrollHeight = this.scrollTop + scrollerHeight;\n\t                this.scrollBarV.scrollTop = null;\n\t            }\n\t        }\n\t        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);\n\t        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);\n\t    };\n\t    this.$updateScrollBarH = function() {\n\t        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);\n\t        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);\n\t    };\n\t    \n\t    this.$frozen = false;\n\t    this.freeze = function() {\n\t        this.$frozen = true;\n\t    };\n\t    \n\t    this.unfreeze = function() {\n\t        this.$frozen = false;\n\t    };\n\n\t    this.$renderChanges = function(changes, force) {\n\t        if (this.$changes) {\n\t            changes |= this.$changes;\n\t            this.$changes = 0;\n\t        }\n\t        if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {\n\t            this.$changes |= changes;\n\t            return; \n\t        } \n\t        if (this.$size.$dirty) {\n\t            this.$changes |= changes;\n\t            return this.onResize(true);\n\t        }\n\t        if (!this.lineHeight) {\n\t            this.$textLayer.checkForSizeChanges();\n\t        }\n\t        \n\t        this._signal(\"beforeRender\");\n\t        var config = this.layerConfig;\n\t        if (changes & this.CHANGE_FULL ||\n\t            changes & this.CHANGE_SIZE ||\n\t            changes & this.CHANGE_TEXT ||\n\t            changes & this.CHANGE_LINES ||\n\t            changes & this.CHANGE_SCROLL ||\n\t            changes & this.CHANGE_H_SCROLL\n\t        ) {\n\t            changes |= this.$computeLayerConfig();\n\t            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {\n\t                var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;\n\t                if (st > 0) {\n\t                    this.scrollTop = st;\n\t                    changes = changes | this.CHANGE_SCROLL;\n\t                    changes |= this.$computeLayerConfig();\n\t                }\n\t            }\n\t            config = this.layerConfig;\n\t            this.$updateScrollBarV();\n\t            if (changes & this.CHANGE_H_SCROLL)\n\t                this.$updateScrollBarH();\n\t            this.$gutterLayer.element.style.marginTop = (-config.offset) + \"px\";\n\t            this.content.style.marginTop = (-config.offset) + \"px\";\n\t            this.content.style.width = config.width + 2 * this.$padding + \"px\";\n\t            this.content.style.height = config.minHeight + \"px\";\n\t        }\n\t        if (changes & this.CHANGE_H_SCROLL) {\n\t            this.content.style.marginLeft = -this.scrollLeft + \"px\";\n\t            this.scroller.className = this.scrollLeft <= 0 ? \"ace_scroller\" : \"ace_scroller ace_scroll-left\";\n\t        }\n\t        if (changes & this.CHANGE_FULL) {\n\t            this.$textLayer.update(config);\n\t            if (this.$showGutter)\n\t                this.$gutterLayer.update(config);\n\t            this.$markerBack.update(config);\n\t            this.$markerFront.update(config);\n\t            this.$cursorLayer.update(config);\n\t            this.$moveTextAreaToCursor();\n\t            this.$highlightGutterLine && this.$updateGutterLineHighlight();\n\t            this._signal(\"afterRender\");\n\t            return;\n\t        }\n\t        if (changes & this.CHANGE_SCROLL) {\n\t            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)\n\t                this.$textLayer.update(config);\n\t            else\n\t                this.$textLayer.scrollLines(config);\n\n\t            if (this.$showGutter)\n\t                this.$gutterLayer.update(config);\n\t            this.$markerBack.update(config);\n\t            this.$markerFront.update(config);\n\t            this.$cursorLayer.update(config);\n\t            this.$highlightGutterLine && this.$updateGutterLineHighlight();\n\t            this.$moveTextAreaToCursor();\n\t            this._signal(\"afterRender\");\n\t            return;\n\t        }\n\n\t        if (changes & this.CHANGE_TEXT) {\n\t            this.$textLayer.update(config);\n\t            if (this.$showGutter)\n\t                this.$gutterLayer.update(config);\n\t        }\n\t        else if (changes & this.CHANGE_LINES) {\n\t            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)\n\t                this.$gutterLayer.update(config);\n\t        }\n\t        else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {\n\t            if (this.$showGutter)\n\t                this.$gutterLayer.update(config);\n\t        }\n\n\t        if (changes & this.CHANGE_CURSOR) {\n\t            this.$cursorLayer.update(config);\n\t            this.$moveTextAreaToCursor();\n\t            this.$highlightGutterLine && this.$updateGutterLineHighlight();\n\t        }\n\n\t        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {\n\t            this.$markerFront.update(config);\n\t        }\n\n\t        if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {\n\t            this.$markerBack.update(config);\n\t        }\n\n\t        this._signal(\"afterRender\");\n\t    };\n\n\t    \n\t    this.$autosize = function() {\n\t        var height = this.session.getScreenLength() * this.lineHeight;\n\t        var maxHeight = this.$maxLines * this.lineHeight;\n\t        var desiredHeight = Math.max(\n\t            (this.$minLines||1) * this.lineHeight,\n\t            Math.min(maxHeight, height)\n\t        ) + this.scrollMargin.v + (this.$extraHeight || 0);\n\t        var vScroll = height > maxHeight;\n\t        \n\t        if (desiredHeight != this.desiredHeight ||\n\t            this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {\n\t            if (vScroll != this.$vScroll) {\n\t                this.$vScroll = vScroll;\n\t                this.scrollBarV.setVisible(vScroll);\n\t            }\n\t            \n\t            var w = this.container.clientWidth;\n\t            this.container.style.height = desiredHeight + \"px\";\n\t            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);\n\t            this.desiredHeight = desiredHeight;\n\t            \n\t            this._signal(\"autosize\");\n\t        }\n\t    };\n\t    \n\t    this.$computeLayerConfig = function() {\n\t        if (this.$maxLines && this.lineHeight > 1)\n\t            this.$autosize();\n\n\t        var session = this.session;\n\t        var size = this.$size;\n\t        \n\t        var hideScrollbars = size.height <= 2 * this.lineHeight;\n\t        var screenLines = this.session.getScreenLength();\n\t        var maxHeight = screenLines * this.lineHeight;\n\n\t        var offset = this.scrollTop % this.lineHeight;\n\t        var minHeight = size.scrollerHeight + this.lineHeight;\n\n\t        var longestLine = this.$getLongestLine();\n\t        \n\t        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||\n\t            size.scrollerWidth - longestLine - 2 * this.$padding < 0);\n\n\t        var hScrollChanged = this.$horizScroll !== horizScroll;\n\t        if (hScrollChanged) {\n\t            this.$horizScroll = horizScroll;\n\t            this.scrollBarH.setVisible(horizScroll);\n\t        }\n\t        \n\t        var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd\n\t            ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd\n\t            : 0;\n\t        maxHeight += scrollPastEnd;\n\n\t        this.session.setScrollTop(Math.max(-this.scrollMargin.top,\n\t            Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));\n\n\t        this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft,\n\t            longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));\n\t        \n\t        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||\n\t            size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop);\n\t        var vScrollChanged = this.$vScroll !== vScroll;\n\t        if (vScrollChanged) {\n\t            this.$vScroll = vScroll;\n\t            this.scrollBarV.setVisible(vScroll);\n\t        }\n\n\t        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;\n\t        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));\n\t        var lastRow = firstRow + lineCount;\n\t        var firstRowScreen, firstRowHeight;\n\t        var lineHeight = this.lineHeight;\n\t        firstRow = session.screenToDocumentRow(firstRow, 0);\n\t        var foldLine = session.getFoldLine(firstRow);\n\t        if (foldLine) {\n\t            firstRow = foldLine.start.row;\n\t        }\n\n\t        firstRowScreen = session.documentToScreenRow(firstRow, 0);\n\t        firstRowHeight = session.getRowLength(firstRow) * lineHeight;\n\n\t        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);\n\t        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +\n\t                                                firstRowHeight;\n\n\t        offset = this.scrollTop - firstRowScreen * lineHeight;\n\n\t        var changes = 0;\n\t        if (this.layerConfig.width != longestLine) \n\t            changes = this.CHANGE_H_SCROLL;\n\t        if (hScrollChanged || vScrollChanged) {\n\t            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);\n\t            this._signal(\"scrollbarVisibilityChanged\");\n\t            if (vScrollChanged)\n\t                longestLine = this.$getLongestLine();\n\t        }\n\t        \n\t        this.layerConfig = {\n\t            width : longestLine,\n\t            padding : this.$padding,\n\t            firstRow : firstRow,\n\t            firstRowScreen: firstRowScreen,\n\t            lastRow : lastRow,\n\t            lineHeight : lineHeight,\n\t            characterWidth : this.characterWidth,\n\t            minHeight : minHeight,\n\t            maxHeight : maxHeight,\n\t            offset : offset,\n\t            gutterOffset : Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),\n\t            height : this.$size.scrollerHeight\n\t        };\n\n\t        return changes;\n\t    };\n\n\t    this.$updateLines = function() {\n\t        var firstRow = this.$changedLines.firstRow;\n\t        var lastRow = this.$changedLines.lastRow;\n\t        this.$changedLines = null;\n\n\t        var layerConfig = this.layerConfig;\n\n\t        if (firstRow > layerConfig.lastRow + 1) { return; }\n\t        if (lastRow < layerConfig.firstRow) { return; }\n\t        if (lastRow === Infinity) {\n\t            if (this.$showGutter)\n\t                this.$gutterLayer.update(layerConfig);\n\t            this.$textLayer.update(layerConfig);\n\t            return;\n\t        }\n\t        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);\n\t        return true;\n\t    };\n\n\t    this.$getLongestLine = function() {\n\t        var charCount = this.session.getScreenWidth();\n\t        if (this.showInvisibles && !this.session.$useWrapMode)\n\t            charCount += 1;\n\n\t        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));\n\t    };\n\t    this.updateFrontMarkers = function() {\n\t        this.$markerFront.setMarkers(this.session.getMarkers(true));\n\t        this.$loop.schedule(this.CHANGE_MARKER_FRONT);\n\t    };\n\t    this.updateBackMarkers = function() {\n\t        this.$markerBack.setMarkers(this.session.getMarkers());\n\t        this.$loop.schedule(this.CHANGE_MARKER_BACK);\n\t    };\n\t    this.addGutterDecoration = function(row, className){\n\t        this.$gutterLayer.addGutterDecoration(row, className);\n\t    };\n\t    this.removeGutterDecoration = function(row, className){\n\t        this.$gutterLayer.removeGutterDecoration(row, className);\n\t    };\n\t    this.updateBreakpoints = function(rows) {\n\t        this.$loop.schedule(this.CHANGE_GUTTER);\n\t    };\n\t    this.setAnnotations = function(annotations) {\n\t        this.$gutterLayer.setAnnotations(annotations);\n\t        this.$loop.schedule(this.CHANGE_GUTTER);\n\t    };\n\t    this.updateCursor = function() {\n\t        this.$loop.schedule(this.CHANGE_CURSOR);\n\t    };\n\t    this.hideCursor = function() {\n\t        this.$cursorLayer.hideCursor();\n\t    };\n\t    this.showCursor = function() {\n\t        this.$cursorLayer.showCursor();\n\t    };\n\n\t    this.scrollSelectionIntoView = function(anchor, lead, offset) {\n\t        this.scrollCursorIntoView(anchor, offset);\n\t        this.scrollCursorIntoView(lead, offset);\n\t    };\n\t    this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {\n\t        if (this.$size.scrollerHeight === 0)\n\t            return;\n\n\t        var pos = this.$cursorLayer.getPixelPosition(cursor);\n\n\t        var left = pos.left;\n\t        var top = pos.top;\n\t        \n\t        var topMargin = $viewMargin && $viewMargin.top || 0;\n\t        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;\n\t        \n\t        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;\n\t        \n\t        if (scrollTop + topMargin > top) {\n\t            if (offset)\n\t                top -= offset * this.$size.scrollerHeight;\n\t            if (top === 0)\n\t                top = -this.scrollMargin.top;\n\t            this.session.setScrollTop(top);\n\t        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {\n\t            if (offset)\n\t                top += offset * this.$size.scrollerHeight;\n\t            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);\n\t        }\n\n\t        var scrollLeft = this.scrollLeft;\n\n\t        if (scrollLeft > left) {\n\t            if (left < this.$padding + 2 * this.layerConfig.characterWidth)\n\t                left = -this.scrollMargin.left;\n\t            this.session.setScrollLeft(left);\n\t        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {\n\t            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));\n\t        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {\n\t            this.session.setScrollLeft(0);\n\t        }\n\t    };\n\t    this.getScrollTop = function() {\n\t        return this.session.getScrollTop();\n\t    };\n\t    this.getScrollLeft = function() {\n\t        return this.session.getScrollLeft();\n\t    };\n\t    this.getScrollTopRow = function() {\n\t        return this.scrollTop / this.lineHeight;\n\t    };\n\t    this.getScrollBottomRow = function() {\n\t        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);\n\t    };\n\t    this.scrollToRow = function(row) {\n\t        this.session.setScrollTop(row * this.lineHeight);\n\t    };\n\n\t    this.alignCursor = function(cursor, alignment) {\n\t        if (typeof cursor == \"number\")\n\t            cursor = {row: cursor, column: 0};\n\n\t        var pos = this.$cursorLayer.getPixelPosition(cursor);\n\t        var h = this.$size.scrollerHeight - this.lineHeight;\n\t        var offset = pos.top - h * (alignment || 0);\n\n\t        this.session.setScrollTop(offset);\n\t        return offset;\n\t    };\n\n\t    this.STEPS = 8;\n\t    this.$calcSteps = function(fromValue, toValue){\n\t        var i = 0;\n\t        var l = this.STEPS;\n\t        var steps = [];\n\n\t        var func  = function(t, x_min, dx) {\n\t            return dx * (Math.pow(t - 1, 3) + 1) + x_min;\n\t        };\n\n\t        for (i = 0; i < l; ++i)\n\t            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));\n\n\t        return steps;\n\t    };\n\t    this.scrollToLine = function(line, center, animate, callback) {\n\t        var pos = this.$cursorLayer.getPixelPosition({row: line, column: 0});\n\t        var offset = pos.top;\n\t        if (center)\n\t            offset -= this.$size.scrollerHeight / 2;\n\n\t        var initialScroll = this.scrollTop;\n\t        this.session.setScrollTop(offset);\n\t        if (animate !== false)\n\t            this.animateScrolling(initialScroll, callback);\n\t    };\n\n\t    this.animateScrolling = function(fromValue, callback) {\n\t        var toValue = this.scrollTop;\n\t        if (!this.$animatedScroll)\n\t            return;\n\t        var _self = this;\n\t        \n\t        if (fromValue == toValue)\n\t            return;\n\t        \n\t        if (this.$scrollAnimation) {\n\t            var oldSteps = this.$scrollAnimation.steps;\n\t            if (oldSteps.length) {\n\t                fromValue = oldSteps[0];\n\t                if (fromValue == toValue)\n\t                    return;\n\t            }\n\t        }\n\t        \n\t        var steps = _self.$calcSteps(fromValue, toValue);\n\t        this.$scrollAnimation = {from: fromValue, to: toValue, steps: steps};\n\n\t        clearInterval(this.$timer);\n\n\t        _self.session.setScrollTop(steps.shift());\n\t        _self.session.$scrollTop = toValue;\n\t        this.$timer = setInterval(function() {\n\t            if (steps.length) {\n\t                _self.session.setScrollTop(steps.shift());\n\t                _self.session.$scrollTop = toValue;\n\t            } else if (toValue != null) {\n\t                _self.session.$scrollTop = -1;\n\t                _self.session.setScrollTop(toValue);\n\t                toValue = null;\n\t            } else {\n\t                _self.$timer = clearInterval(_self.$timer);\n\t                _self.$scrollAnimation = null;\n\t                callback && callback();\n\t            }\n\t        }, 10);\n\t    };\n\t    this.scrollToY = function(scrollTop) {\n\t        if (this.scrollTop !== scrollTop) {\n\t            this.$loop.schedule(this.CHANGE_SCROLL);\n\t            this.scrollTop = scrollTop;\n\t        }\n\t    };\n\t    this.scrollToX = function(scrollLeft) {\n\t        if (this.scrollLeft !== scrollLeft)\n\t            this.scrollLeft = scrollLeft;\n\t        this.$loop.schedule(this.CHANGE_H_SCROLL);\n\t    };\n\t    this.scrollTo = function(x, y) {\n\t        this.session.setScrollTop(y);\n\t        this.session.setScrollLeft(y);\n\t    };\n\t    this.scrollBy = function(deltaX, deltaY) {\n\t        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);\n\t        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);\n\t    };\n\t    this.isScrollableBy = function(deltaX, deltaY) {\n\t        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)\n\t           return true;\n\t        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight\n\t            - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)\n\t           return true;\n\t        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)\n\t            return true;\n\t        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth\n\t            - this.layerConfig.width < -1 + this.scrollMargin.right)\n\t           return true;\n\t    };\n\n\t    this.pixelToScreenCoordinates = function(x, y) {\n\t        var canvasPos = this.scroller.getBoundingClientRect();\n\n\t        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;\n\t        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);\n\t        var col = Math.round(offset);\n\n\t        return {row: row, column: col, side: offset - col > 0 ? 1 : -1};\n\t    };\n\n\t    this.screenToTextCoordinates = function(x, y) {\n\t        var canvasPos = this.scroller.getBoundingClientRect();\n\n\t        var col = Math.round(\n\t            (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth\n\t        );\n\n\t        var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;\n\n\t        return this.session.screenToDocumentPosition(row, Math.max(col, 0));\n\t    };\n\t    this.textToScreenCoordinates = function(row, column) {\n\t        var canvasPos = this.scroller.getBoundingClientRect();\n\t        var pos = this.session.documentToScreenPosition(row, column);\n\n\t        var x = this.$padding + Math.round(pos.column * this.characterWidth);\n\t        var y = pos.row * this.lineHeight;\n\n\t        return {\n\t            pageX: canvasPos.left + x - this.scrollLeft,\n\t            pageY: canvasPos.top + y - this.scrollTop\n\t        };\n\t    };\n\t    this.visualizeFocus = function() {\n\t        dom.addCssClass(this.container, \"ace_focus\");\n\t    };\n\t    this.visualizeBlur = function() {\n\t        dom.removeCssClass(this.container, \"ace_focus\");\n\t    };\n\t    this.showComposition = function(position) {\n\t        if (!this.$composition)\n\t            this.$composition = {\n\t                keepTextAreaAtCursor: this.$keepTextAreaAtCursor,\n\t                cssText: this.textarea.style.cssText\n\t            };\n\n\t        this.$keepTextAreaAtCursor = true;\n\t        dom.addCssClass(this.textarea, \"ace_composition\");\n\t        this.textarea.style.cssText = \"\";\n\t        this.$moveTextAreaToCursor();\n\t    };\n\t    this.setCompositionText = function(text) {\n\t        this.$moveTextAreaToCursor();\n\t    };\n\t    this.hideComposition = function() {\n\t        if (!this.$composition)\n\t            return;\n\n\t        dom.removeCssClass(this.textarea, \"ace_composition\");\n\t        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;\n\t        this.textarea.style.cssText = this.$composition.cssText;\n\t        this.$composition = null;\n\t    };\n\t    this.setTheme = function(theme, cb) {\n\t        var _self = this;\n\t        this.$themeId = theme;\n\t        _self._dispatchEvent('themeChange',{theme:theme});\n\n\t        if (!theme || typeof theme == \"string\") {\n\t            var moduleName = theme || this.$options.theme.initialValue;\n\t            config.loadModule([\"theme\", moduleName], afterLoad);\n\t        } else {\n\t            afterLoad(theme);\n\t        }\n\n\t        function afterLoad(module) {\n\t            if (_self.$themeId != theme)\n\t                return cb && cb();\n\t            if (!module.cssClass)\n\t                return;\n\t            dom.importCssString(\n\t                module.cssText,\n\t                module.cssClass,\n\t                _self.container.ownerDocument\n\t            );\n\n\t            if (_self.theme)\n\t                dom.removeCssClass(_self.container, _self.theme.cssClass);\n\n\t            var padding = \"padding\" in module ? module.padding \n\t                : \"padding\" in (_self.theme || {}) ? 4 : _self.$padding;\n\t            if (_self.$padding && padding != _self.$padding)\n\t                _self.setPadding(padding);\n\t            _self.$theme = module.cssClass;\n\n\t            _self.theme = module;\n\t            dom.addCssClass(_self.container, module.cssClass);\n\t            dom.setCssClass(_self.container, \"ace_dark\", module.isDark);\n\t            if (_self.$size) {\n\t                _self.$size.width = 0;\n\t                _self.$updateSizeAsync();\n\t            }\n\n\t            _self._dispatchEvent('themeLoaded', {theme:module});\n\t            cb && cb();\n\t        }\n\t    };\n\t    this.getTheme = function() {\n\t        return this.$themeId;\n\t    };\n\t    this.setStyle = function(style, include) {\n\t        dom.setCssClass(this.container, style, include !== false);\n\t    };\n\t    this.unsetStyle = function(style) {\n\t        dom.removeCssClass(this.container, style);\n\t    };\n\t    \n\t    this.setCursorStyle = function(style) {\n\t        if (this.scroller.style.cursor != style)\n\t            this.scroller.style.cursor = style;\n\t    };\n\t    this.setMouseCursor = function(cursorStyle) {\n\t        this.scroller.style.cursor = cursorStyle;\n\t    };\n\t    this.destroy = function() {\n\t        this.$textLayer.destroy();\n\t        this.$cursorLayer.destroy();\n\t    };\n\n\t}).call(VirtualRenderer.prototype);\n\n\n\tconfig.defineOptions(VirtualRenderer.prototype, \"renderer\", {\n\t    animatedScroll: {initialValue: false},\n\t    showInvisibles: {\n\t        set: function(value) {\n\t            if (this.$textLayer.setShowInvisibles(value))\n\t                this.$loop.schedule(this.CHANGE_TEXT);\n\t        },\n\t        initialValue: false\n\t    },\n\t    showPrintMargin: {\n\t        set: function() { this.$updatePrintMargin(); },\n\t        initialValue: true\n\t    },\n\t    printMarginColumn: {\n\t        set: function() { this.$updatePrintMargin(); },\n\t        initialValue: 80\n\t    },\n\t    printMargin: {\n\t        set: function(val) {\n\t            if (typeof val == \"number\")\n\t                this.$printMarginColumn = val;\n\t            this.$showPrintMargin = !!val;\n\t            this.$updatePrintMargin();\n\t        },\n\t        get: function() {\n\t            return this.$showPrintMargin && this.$printMarginColumn; \n\t        }\n\t    },\n\t    showGutter: {\n\t        set: function(show){\n\t            this.$gutter.style.display = show ? \"block\" : \"none\";\n\t            this.$loop.schedule(this.CHANGE_FULL);\n\t            this.onGutterResize();\n\t        },\n\t        initialValue: true\n\t    },\n\t    fadeFoldWidgets: {\n\t        set: function(show) {\n\t            dom.setCssClass(this.$gutter, \"ace_fade-fold-widgets\", show);\n\t        },\n\t        initialValue: false\n\t    },\n\t    showFoldWidgets: {\n\t        set: function(show) {this.$gutterLayer.setShowFoldWidgets(show)},\n\t        initialValue: true\n\t    },\n\t    showLineNumbers: {\n\t        set: function(show) {\n\t            this.$gutterLayer.setShowLineNumbers(show);\n\t            this.$loop.schedule(this.CHANGE_GUTTER);\n\t        },\n\t        initialValue: true\n\t    },\n\t    displayIndentGuides: {\n\t        set: function(show) {\n\t            if (this.$textLayer.setDisplayIndentGuides(show))\n\t                this.$loop.schedule(this.CHANGE_TEXT);\n\t        },\n\t        initialValue: true\n\t    },\n\t    highlightGutterLine: {\n\t        set: function(shouldHighlight) {\n\t            if (!this.$gutterLineHighlight) {\n\t                this.$gutterLineHighlight = dom.createElement(\"div\");\n\t                this.$gutterLineHighlight.className = \"ace_gutter-active-line\";\n\t                this.$gutter.appendChild(this.$gutterLineHighlight);\n\t                return;\n\t            }\n\n\t            this.$gutterLineHighlight.style.display = shouldHighlight ? \"\" : \"none\";\n\t            if (this.$cursorLayer.$pixelPos)\n\t                this.$updateGutterLineHighlight();\n\t        },\n\t        initialValue: false,\n\t        value: true\n\t    },\n\t    hScrollBarAlwaysVisible: {\n\t        set: function(val) {\n\t            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)\n\t                this.$loop.schedule(this.CHANGE_SCROLL);\n\t        },\n\t        initialValue: false\n\t    },\n\t    vScrollBarAlwaysVisible: {\n\t        set: function(val) {\n\t            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)\n\t                this.$loop.schedule(this.CHANGE_SCROLL);\n\t        },\n\t        initialValue: false\n\t    },\n\t    fontSize:  {\n\t        set: function(size) {\n\t            if (typeof size == \"number\")\n\t                size = size + \"px\";\n\t            this.container.style.fontSize = size;\n\t            this.updateFontSize();\n\t        },\n\t        initialValue: 12\n\t    },\n\t    fontFamily: {\n\t        set: function(name) {\n\t            this.container.style.fontFamily = name;\n\t            this.updateFontSize();\n\t        }\n\t    },\n\t    maxLines: {\n\t        set: function(val) {\n\t            this.updateFull();\n\t        }\n\t    },\n\t    minLines: {\n\t        set: function(val) {\n\t            this.updateFull();\n\t        }\n\t    },\n\t    scrollPastEnd: {\n\t        set: function(val) {\n\t            val = +val || 0;\n\t            if (this.$scrollPastEnd == val)\n\t                return;\n\t            this.$scrollPastEnd = val;\n\t            this.$loop.schedule(this.CHANGE_SCROLL);\n\t        },\n\t        initialValue: 0,\n\t        handlesSet: true\n\t    },\n\t    fixedWidthGutter: {\n\t        set: function(val) {\n\t            this.$gutterLayer.$fixedWidth = !!val;\n\t            this.$loop.schedule(this.CHANGE_GUTTER);\n\t        }\n\t    },\n\t    theme: {\n\t        set: function(val) { this.setTheme(val) },\n\t        get: function() { return this.$themeId || this.theme; },\n\t        initialValue: \"./theme/textmate\",\n\t        handlesSet: true\n\t    }\n\t});\n\n\texports.VirtualRenderer = VirtualRenderer;\n\t});\n\n\tace.define(\"ace/worker/worker_client\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/net\",\"ace/lib/event_emitter\",\"ace/config\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../lib/oop\");\n\tvar net = acequire(\"../lib/net\");\n\tvar EventEmitter = acequire(\"../lib/event_emitter\").EventEmitter;\n\tvar config = acequire(\"../config\");\n\n\tvar WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {\n\t    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n\t    this.changeListener = this.changeListener.bind(this);\n\t    this.onMessage = this.onMessage.bind(this);\n\t    if (acequire.nameToUrl && !acequire.toUrl)\n\t        acequire.toUrl = acequire.nameToUrl;\n\t    \n\t    if (config.get(\"packaged\") || !acequire.toUrl) {\n\t        workerUrl = workerUrl || config.moduleUrl(mod.id, \"worker\")\n\t    } else {\n\t        var normalizePath = this.$normalizePath;\n\t        workerUrl = workerUrl || normalizePath(acequire.toUrl(\"ace/worker/worker.js\", null, \"_\"));\n\n\t        var tlns = {};\n\t        topLevelNamespaces.forEach(function(ns) {\n\t            tlns[ns] = normalizePath(acequire.toUrl(ns, null, \"_\").replace(/(\\.js)?(\\?.*)?$/, \"\"));\n\t        });\n\t    }\n\n\t    try {\n\t            var workerSrc = mod.src;\n\t    var Blob = __webpack_require__(19);\n\t    var blob = new Blob([ workerSrc ], { type: 'application/javascript' });\n\t    var blobUrl = (window.URL || window.webkitURL).createObjectURL(blob);\n\n\t    this.$worker = new Worker(blobUrl);\n\n\t    } catch(e) {\n\t        if (e instanceof window.DOMException) {\n\t            var blob = this.$workerBlob(workerUrl);\n\t            var URL = window.URL || window.webkitURL;\n\t            var blobURL = URL.createObjectURL(blob);\n\n\t            this.$worker = new Worker(blobURL);\n\t            URL.revokeObjectURL(blobURL);\n\t        } else {\n\t            throw e;\n\t        }\n\t    }\n\t    this.$worker.postMessage({\n\t        init : true,\n\t        tlns : tlns,\n\t        module : mod.id,\n\t        classname : classname\n\t    });\n\n\t    this.callbackId = 1;\n\t    this.callbacks = {};\n\n\t    this.$worker.onmessage = this.onMessage;\n\t};\n\n\t(function(){\n\n\t    oop.implement(this, EventEmitter);\n\n\t    this.onMessage = function(e) {\n\t        var msg = e.data;\n\t        switch(msg.type) {\n\t            case \"event\":\n\t                this._signal(msg.name, {data: msg.data});\n\t                break;\n\t            case \"call\":\n\t                var callback = this.callbacks[msg.id];\n\t                if (callback) {\n\t                    callback(msg.data);\n\t                    delete this.callbacks[msg.id];\n\t                }\n\t                break;\n\t            case \"error\":\n\t                this.reportError(msg.data);\n\t                break;\n\t            case \"log\":\n\t                window.console && console.log && console.log.apply(console, msg.data);\n\t                break;\n\t        }\n\t    };\n\n\t    this.reportError = function(err) {\n\t        window.console && console.error && console.error(err);\n\t    };\n\n\t    this.$normalizePath = function(path) {\n\t        return net.qualifyURL(path);\n\t    };\n\n\t    this.terminate = function() {\n\t        this._signal(\"terminate\", {});\n\t        this.deltaQueue = null;\n\t        this.$worker.terminate();\n\t        this.$worker = null;\n\t        if (this.$doc)\n\t            this.$doc.off(\"change\", this.changeListener);\n\t        this.$doc = null;\n\t    };\n\n\t    this.send = function(cmd, args) {\n\t        this.$worker.postMessage({command: cmd, args: args});\n\t    };\n\n\t    this.call = function(cmd, args, callback) {\n\t        if (callback) {\n\t            var id = this.callbackId++;\n\t            this.callbacks[id] = callback;\n\t            args.push(id);\n\t        }\n\t        this.send(cmd, args);\n\t    };\n\n\t    this.emit = function(event, data) {\n\t        try {\n\t            this.$worker.postMessage({event: event, data: {data: data.data}});\n\t        }\n\t        catch(ex) {\n\t            console.error(ex.stack);\n\t        }\n\t    };\n\n\t    this.attachToDocument = function(doc) {\n\t        if(this.$doc)\n\t            this.terminate();\n\n\t        this.$doc = doc;\n\t        this.call(\"setValue\", [doc.getValue()]);\n\t        doc.on(\"change\", this.changeListener);\n\t    };\n\n\t    this.changeListener = function(e) {\n\t        if (!this.deltaQueue) {\n\t            this.deltaQueue = [e.data];\n\t            setTimeout(this.$sendDeltaQueue, 0);\n\t        } else\n\t            this.deltaQueue.push(e.data);\n\t    };\n\n\t    this.$sendDeltaQueue = function() {\n\t        var q = this.deltaQueue;\n\t        if (!q) return;\n\t        this.deltaQueue = null;\n\t        if (q.length > 20 && q.length > this.$doc.getLength() >> 1) {\n\t            this.call(\"setValue\", [this.$doc.getValue()]);\n\t        } else\n\t            this.emit(\"change\", {data: q});\n\t    };\n\n\t    this.$workerBlob = function(workerUrl) {\n\t        var script = \"importScripts('\" + net.qualifyURL(workerUrl) + \"');\";\n\t        try {\n\t            return new Blob([script], {\"type\": \"application/javascript\"});\n\t        } catch (e) { // Backwards-compatibility\n\t            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n\t            var blobBuilder = new BlobBuilder();\n\t            blobBuilder.append(script);\n\t            return blobBuilder.getBlob(\"application/javascript\");\n\t        }\n\t    };\n\n\t}).call(WorkerClient.prototype);\n\n\n\tvar UIWorkerClient = function(topLevelNamespaces, mod, classname) {\n\t    this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);\n\t    this.changeListener = this.changeListener.bind(this);\n\t    this.callbackId = 1;\n\t    this.callbacks = {};\n\t    this.messageBuffer = [];\n\n\t    var main = null;\n\t    var emitSync = false;\n\t    var sender = Object.create(EventEmitter);\n\t    var _self = this;\n\n\t    this.$worker = {};\n\t    this.$worker.terminate = function() {};\n\t    this.$worker.postMessage = function(e) {\n\t        _self.messageBuffer.push(e);\n\t        if (main) {\n\t            if (emitSync)\n\t                setTimeout(processNext);\n\t            else\n\t                processNext();\n\t        }\n\t    };\n\t    this.setEmitSync = function(val) { emitSync = val };\n\n\t    var processNext = function() {\n\t        var msg = _self.messageBuffer.shift();\n\t        if (msg.command)\n\t            main[msg.command].apply(main, msg.args);\n\t        else if (msg.event)\n\t            sender._signal(msg.event, msg.data);\n\t    };\n\n\t    sender.postMessage = function(msg) {\n\t        _self.onMessage({data: msg});\n\t    };\n\t    sender.callback = function(data, callbackId) {\n\t        this.postMessage({type: \"call\", id: callbackId, data: data});\n\t    };\n\t    sender.emit = function(name, data) {\n\t        this.postMessage({type: \"event\", name: name, data: data});\n\t    };\n\n\t    config.loadModule([\"worker\", mod], function(Main) {\n\t        main = new Main[classname](sender);\n\t        while (_self.messageBuffer.length)\n\t            processNext();\n\t    });\n\t};\n\n\tUIWorkerClient.prototype = WorkerClient.prototype;\n\n\texports.UIWorkerClient = UIWorkerClient;\n\texports.WorkerClient = WorkerClient;\n\n\t});\n\n\tace.define(\"ace/placeholder\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/oop\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"./range\").Range;\n\tvar EventEmitter = acequire(\"./lib/event_emitter\").EventEmitter;\n\tvar oop = acequire(\"./lib/oop\");\n\n\tvar PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {\n\t    var _self = this;\n\t    this.length = length;\n\t    this.session = session;\n\t    this.doc = session.getDocument();\n\t    this.mainClass = mainClass;\n\t    this.othersClass = othersClass;\n\t    this.$onUpdate = this.onUpdate.bind(this);\n\t    this.doc.on(\"change\", this.$onUpdate);\n\t    this.$others = others;\n\t    \n\t    this.$onCursorChange = function() {\n\t        setTimeout(function() {\n\t            _self.onCursorChange();\n\t        });\n\t    };\n\t    \n\t    this.$pos = pos;\n\t    var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};\n\t    this.$undoStackDepth =  undoStack.length;\n\t    this.setup();\n\n\t    session.selection.on(\"changeCursor\", this.$onCursorChange);\n\t};\n\n\t(function() {\n\n\t    oop.implement(this, EventEmitter);\n\t    this.setup = function() {\n\t        var _self = this;\n\t        var doc = this.doc;\n\t        var session = this.session;\n\t        var pos = this.$pos;\n\t        \n\t        this.selectionBefore = session.selection.toJSON();\n\t        if (session.selection.inMultiSelectMode)\n\t            session.selection.toSingleRange();\n\n\t        this.pos = doc.createAnchor(pos.row, pos.column);\n\t        this.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);\n\t        this.pos.on(\"change\", function(event) {\n\t            session.removeMarker(_self.markerId);\n\t            _self.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.mainClass, null, false);\n\t        });\n\t        this.others = [];\n\t        this.$others.forEach(function(other) {\n\t            var anchor = doc.createAnchor(other.row, other.column);\n\t            _self.others.push(anchor);\n\t        });\n\t        session.setUndoSelect(false);\n\t    };\n\t    this.showOtherMarkers = function() {\n\t        if(this.othersActive) return;\n\t        var session = this.session;\n\t        var _self = this;\n\t        this.othersActive = true;\n\t        this.others.forEach(function(anchor) {\n\t            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column+_self.length), _self.othersClass, null, false);\n\t            anchor.on(\"change\", function(event) {\n\t                session.removeMarker(anchor.markerId);\n\t                anchor.markerId = session.addMarker(new Range(event.value.row, event.value.column, event.value.row, event.value.column+_self.length), _self.othersClass, null, false);\n\t            });\n\t        });\n\t    };\n\t    this.hideOtherMarkers = function() {\n\t        if(!this.othersActive) return;\n\t        this.othersActive = false;\n\t        for (var i = 0; i < this.others.length; i++) {\n\t            this.session.removeMarker(this.others[i].markerId);\n\t        }\n\t    };\n\t    this.onUpdate = function(event) {\n\t        var delta = event.data;\n\t        var range = delta.range;\n\t        if(range.start.row !== range.end.row) return;\n\t        if(range.start.row !== this.pos.row) return;\n\t        if (this.$updating) return;\n\t        this.$updating = true;\n\t        var lengthDiff = delta.action === \"insertText\" ? range.end.column - range.start.column : range.start.column - range.end.column;\n\t        \n\t        if(range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1) {\n\t            var distanceFromStart = range.start.column - this.pos.column;\n\t            this.length += lengthDiff;\n\t            if(!this.session.$fromUndo) {\n\t                if(delta.action === \"insertText\") {\n\t                    for (var i = this.others.length - 1; i >= 0; i--) {\n\t                        var otherPos = this.others[i];\n\t                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n\t                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)\n\t                            newPos.column += lengthDiff;\n\t                        this.doc.insert(newPos, delta.text);\n\t                    }\n\t                } else if(delta.action === \"removeText\") {\n\t                    for (var i = this.others.length - 1; i >= 0; i--) {\n\t                        var otherPos = this.others[i];\n\t                        var newPos = {row: otherPos.row, column: otherPos.column + distanceFromStart};\n\t                        if(otherPos.row === range.start.row && range.start.column < otherPos.column)\n\t                            newPos.column += lengthDiff;\n\t                        this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));\n\t                    }\n\t                }\n\t                if(range.start.column === this.pos.column && delta.action === \"insertText\") {\n\t                    setTimeout(function() {\n\t                        this.pos.setPosition(this.pos.row, this.pos.column - lengthDiff);\n\t                        for (var i = 0; i < this.others.length; i++) {\n\t                            var other = this.others[i];\n\t                            var newPos = {row: other.row, column: other.column - lengthDiff};\n\t                            if(other.row === range.start.row && range.start.column < other.column)\n\t                                newPos.column += lengthDiff;\n\t                            other.setPosition(newPos.row, newPos.column);\n\t                        }\n\t                    }.bind(this), 0);\n\t                }\n\t                else if(range.start.column === this.pos.column && delta.action === \"removeText\") {\n\t                    setTimeout(function() {\n\t                        for (var i = 0; i < this.others.length; i++) {\n\t                            var other = this.others[i];\n\t                            if(other.row === range.start.row && range.start.column < other.column) {\n\t                                other.setPosition(other.row, other.column - lengthDiff);\n\t                            }\n\t                        }\n\t                    }.bind(this), 0);\n\t                }\n\t            }\n\t            this.pos._emit(\"change\", {value: this.pos});\n\t            for (var i = 0; i < this.others.length; i++) {\n\t                this.others[i]._emit(\"change\", {value: this.others[i]});\n\t            }\n\t        }\n\t        this.$updating = false;\n\t    };\n\n\t    this.onCursorChange = function(event) {\n\t        if (this.$updating || !this.session) return;\n\t        var pos = this.session.selection.getCursor();\n\t        if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {\n\t            this.showOtherMarkers();\n\t            this._emit(\"cursorEnter\", event);\n\t        } else {\n\t            this.hideOtherMarkers();\n\t            this._emit(\"cursorLeave\", event);\n\t        }\n\t    };    \n\t    this.detach = function() {\n\t        this.session.removeMarker(this.markerId);\n\t        this.hideOtherMarkers();\n\t        this.doc.removeEventListener(\"change\", this.$onUpdate);\n\t        this.session.selection.removeEventListener(\"changeCursor\", this.$onCursorChange);\n\t        this.pos.detach();\n\t        for (var i = 0; i < this.others.length; i++) {\n\t            this.others[i].detach();\n\t        }\n\t        this.session.setUndoSelect(true);\n\t        this.session = null;\n\t    };\n\t    this.cancel = function() {\n\t        if(this.$undoStackDepth === -1)\n\t            throw Error(\"Canceling placeholders only supported with undo manager attached to session.\");\n\t        var undoManager = this.session.getUndoManager();\n\t        var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;\n\t        for (var i = 0; i < undosRequired; i++) {\n\t            undoManager.undo(true);\n\t        }\n\t        if (this.selectionBefore)\n\t            this.session.selection.fromJSON(this.selectionBefore);\n\t    };\n\t}).call(PlaceHolder.prototype);\n\n\n\texports.PlaceHolder = PlaceHolder;\n\t});\n\n\tace.define(\"ace/mouse/multi_select_handler\",[\"require\",\"exports\",\"module\",\"ace/lib/event\",\"ace/lib/useragent\"], function(acequire, exports, module) {\n\n\tvar event = acequire(\"../lib/event\");\n\tvar useragent = acequire(\"../lib/useragent\");\n\tfunction isSamePoint(p1, p2) {\n\t    return p1.row == p2.row && p1.column == p2.column;\n\t}\n\n\tfunction onMouseDown(e) {\n\t    var ev = e.domEvent;\n\t    var alt = ev.altKey;\n\t    var shift = ev.shiftKey;\n\t    var ctrl = ev.ctrlKey;\n\t    var accel = e.getAccelKey();\n\t    var button = e.getButton();\n\t    \n\t    if (ctrl && useragent.isMac)\n\t        button = ev.button;\n\n\t    if (e.editor.inMultiSelectMode && button == 2) {\n\t        e.editor.textInput.onContextMenu(e.domEvent);\n\t        return;\n\t    }\n\t    \n\t    if (!ctrl && !alt && !accel) {\n\t        if (button === 0 && e.editor.inMultiSelectMode)\n\t            e.editor.exitMultiSelectMode();\n\t        return;\n\t    }\n\t    \n\t    if (button !== 0)\n\t        return;\n\n\t    var editor = e.editor;\n\t    var selection = editor.selection;\n\t    var isMultiSelect = editor.inMultiSelectMode;\n\t    var pos = e.getDocumentPosition();\n\t    var cursor = selection.getCursor();\n\t    var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));\n\n\t    var mouseX = e.x, mouseY = e.y;\n\t    var onMouseSelection = function(e) {\n\t        mouseX = e.clientX;\n\t        mouseY = e.clientY;\n\t    };\n\t    \n\t    var session = editor.session;\n\t    var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n\t    var screenCursor = screenAnchor;\n\t    \n\t    var selectionMode;\n\t    if (editor.$mouseHandler.$enableJumpToDef) {\n\t        if (ctrl && alt || accel && alt)\n\t            selectionMode = \"add\";\n\t        else if (alt)\n\t            selectionMode = \"block\";\n\t    } else {\n\t        if (accel && !alt) {\n\t            selectionMode = \"add\";\n\t            if (!isMultiSelect && shift)\n\t                return;\n\t        } else if (alt) {\n\t            selectionMode = \"block\";\n\t        }\n\t    }\n\t    \n\t    if (selectionMode && useragent.isMac && ev.ctrlKey) {\n\t        editor.$mouseHandler.cancelContextMenu();\n\t    }\n\n\t    if (selectionMode == \"add\") {\n\t        if (!isMultiSelect && inSelection)\n\t            return; // dragging\n\n\t        if (!isMultiSelect) {\n\t            var range = selection.toOrientedRange();\n\t            editor.addSelectionMarker(range);\n\t        }\n\n\t        var oldRange = selection.rangeList.rangeAtPoint(pos);\n\t        \n\t        \n\t        editor.$blockScrolling++;\n\t        editor.inVirtualSelectionMode = true;\n\t        \n\t        if (shift) {\n\t            oldRange = null;\n\t            range = selection.ranges[0];\n\t            editor.removeSelectionMarker(range);\n\t        }\n\t        editor.once(\"mouseup\", function() {\n\t            var tmpSel = selection.toOrientedRange();\n\n\t            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))\n\t                selection.substractPoint(tmpSel.cursor);\n\t            else {\n\t                if (shift) {\n\t                    selection.substractPoint(range.cursor);\n\t                } else if (range) {\n\t                    editor.removeSelectionMarker(range);\n\t                    selection.addRange(range);\n\t                }\n\t                selection.addRange(tmpSel);\n\t            }\n\t            editor.$blockScrolling--;\n\t            editor.inVirtualSelectionMode = false;\n\t        });\n\n\t    } else if (selectionMode == \"block\") {\n\t        e.stop();\n\t        editor.inVirtualSelectionMode = true;        \n\t        var initialRange;\n\t        var rectSel = [];\n\t        var blockSelect = function() {\n\t            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);\n\t            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);\n\n\t            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))\n\t                return;\n\t            screenCursor = newCursor;\n\n\t            editor.selection.moveToPosition(cursor);\n\t            editor.renderer.scrollCursorIntoView();\n\n\t            editor.removeSelectionMarkers(rectSel);\n\t            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);\n\t            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())\n\t                rectSel[0] = editor.$mouseHandler.$clickSelection.clone();\n\t            rectSel.forEach(editor.addSelectionMarker, editor);\n\t            editor.updateSelectionMarkers();\n\t        };\n\t        \n\t        if (isMultiSelect && !accel) {\n\t            selection.toSingleRange();\n\t        } else if (!isMultiSelect && accel) {\n\t            initialRange = selection.toOrientedRange();\n\t            editor.addSelectionMarker(initialRange);\n\t        }\n\t        \n\t        if (shift)\n\t            screenAnchor = session.documentToScreenPosition(selection.lead);            \n\t        else\n\t            selection.moveToPosition(pos);\n\t        \n\t        screenCursor = {row: -1, column: -1};\n\n\t        var onMouseSelectionEnd = function(e) {\n\t            clearInterval(timerId);\n\t            editor.removeSelectionMarkers(rectSel);\n\t            if (!rectSel.length)\n\t                rectSel = [selection.toOrientedRange()];\n\t            editor.$blockScrolling++;\n\t            if (initialRange) {\n\t                editor.removeSelectionMarker(initialRange);\n\t                selection.toSingleRange(initialRange);\n\t            }\n\t            for (var i = 0; i < rectSel.length; i++)\n\t                selection.addRange(rectSel[i]);\n\t            editor.inVirtualSelectionMode = false;\n\t            editor.$mouseHandler.$clickSelection = null;\n\t            editor.$blockScrolling--;\n\t        };\n\n\t        var onSelectionInterval = blockSelect;\n\n\t        event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);\n\t        var timerId = setInterval(function() {onSelectionInterval();}, 20);\n\n\t        return e.preventDefault();\n\t    }\n\t}\n\n\n\texports.onMouseDown = onMouseDown;\n\n\t});\n\n\tace.define(\"ace/commands/multi_select_commands\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\"], function(acequire, exports, module) {\n\texports.defaultCommands = [{\n\t    name: \"addCursorAbove\",\n\t    exec: function(editor) { editor.selectMoreLines(-1); },\n\t    bindKey: {win: \"Ctrl-Alt-Up\", mac: \"Ctrl-Alt-Up\"},\n\t    readonly: true\n\t}, {\n\t    name: \"addCursorBelow\",\n\t    exec: function(editor) { editor.selectMoreLines(1); },\n\t    bindKey: {win: \"Ctrl-Alt-Down\", mac: \"Ctrl-Alt-Down\"},\n\t    readonly: true\n\t}, {\n\t    name: \"addCursorAboveSkipCurrent\",\n\t    exec: function(editor) { editor.selectMoreLines(-1, true); },\n\t    bindKey: {win: \"Ctrl-Alt-Shift-Up\", mac: \"Ctrl-Alt-Shift-Up\"},\n\t    readonly: true\n\t}, {\n\t    name: \"addCursorBelowSkipCurrent\",\n\t    exec: function(editor) { editor.selectMoreLines(1, true); },\n\t    bindKey: {win: \"Ctrl-Alt-Shift-Down\", mac: \"Ctrl-Alt-Shift-Down\"},\n\t    readonly: true\n\t}, {\n\t    name: \"selectMoreBefore\",\n\t    exec: function(editor) { editor.selectMore(-1); },\n\t    bindKey: {win: \"Ctrl-Alt-Left\", mac: \"Ctrl-Alt-Left\"},\n\t    readonly: true\n\t}, {\n\t    name: \"selectMoreAfter\",\n\t    exec: function(editor) { editor.selectMore(1); },\n\t    bindKey: {win: \"Ctrl-Alt-Right\", mac: \"Ctrl-Alt-Right\"},\n\t    readonly: true\n\t}, {\n\t    name: \"selectNextBefore\",\n\t    exec: function(editor) { editor.selectMore(-1, true); },\n\t    bindKey: {win: \"Ctrl-Alt-Shift-Left\", mac: \"Ctrl-Alt-Shift-Left\"},\n\t    readonly: true\n\t}, {\n\t    name: \"selectNextAfter\",\n\t    exec: function(editor) { editor.selectMore(1, true); },\n\t    bindKey: {win: \"Ctrl-Alt-Shift-Right\", mac: \"Ctrl-Alt-Shift-Right\"},\n\t    readonly: true\n\t}, {\n\t    name: \"splitIntoLines\",\n\t    exec: function(editor) { editor.multiSelect.splitIntoLines(); },\n\t    bindKey: {win: \"Ctrl-Alt-L\", mac: \"Ctrl-Alt-L\"},\n\t    readonly: true\n\t}, {\n\t    name: \"alignCursors\",\n\t    exec: function(editor) { editor.alignCursors(); },\n\t    bindKey: {win: \"Ctrl-Alt-A\", mac: \"Ctrl-Alt-A\"}\n\t}, {\n\t    name: \"findAll\",\n\t    exec: function(editor) { editor.findAll(); },\n\t    bindKey: {win: \"Ctrl-Alt-K\", mac: \"Ctrl-Alt-G\"},\n\t    readonly: true\n\t}];\n\texports.multiSelectCommands = [{\n\t    name: \"singleSelection\",\n\t    bindKey: \"esc\",\n\t    exec: function(editor) { editor.exitMultiSelectMode(); },\n\t    readonly: true,\n\t    isAvailable: function(editor) {return editor && editor.inMultiSelectMode}\n\t}];\n\n\tvar HashHandler = acequire(\"../keyboard/hash_handler\").HashHandler;\n\texports.keyboardHandler = new HashHandler(exports.multiSelectCommands);\n\n\t});\n\n\tace.define(\"ace/multi_select\",[\"require\",\"exports\",\"module\",\"ace/range_list\",\"ace/range\",\"ace/selection\",\"ace/mouse/multi_select_handler\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/commands/multi_select_commands\",\"ace/search\",\"ace/edit_session\",\"ace/editor\",\"ace/config\"], function(acequire, exports, module) {\n\n\tvar RangeList = acequire(\"./range_list\").RangeList;\n\tvar Range = acequire(\"./range\").Range;\n\tvar Selection = acequire(\"./selection\").Selection;\n\tvar onMouseDown = acequire(\"./mouse/multi_select_handler\").onMouseDown;\n\tvar event = acequire(\"./lib/event\");\n\tvar lang = acequire(\"./lib/lang\");\n\tvar commands = acequire(\"./commands/multi_select_commands\");\n\texports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);\n\tvar Search = acequire(\"./search\").Search;\n\tvar search = new Search();\n\n\tfunction find(session, needle, dir) {\n\t    search.$options.wrap = true;\n\t    search.$options.needle = needle;\n\t    search.$options.backwards = dir == -1;\n\t    return search.find(session);\n\t}\n\tvar EditSession = acequire(\"./edit_session\").EditSession;\n\t(function() {\n\t    this.getSelectionMarkers = function() {\n\t        return this.$selectionMarkers;\n\t    };\n\t}).call(EditSession.prototype);\n\t(function() {\n\t    this.ranges = null;\n\t    this.rangeList = null;\n\t    this.addRange = function(range, $blockChangeEvents) {\n\t        if (!range)\n\t            return;\n\n\t        if (!this.inMultiSelectMode && this.rangeCount === 0) {\n\t            var oldRange = this.toOrientedRange();\n\t            this.rangeList.add(oldRange);\n\t            this.rangeList.add(range);\n\t            if (this.rangeList.ranges.length != 2) {\n\t                this.rangeList.removeAll();\n\t                return $blockChangeEvents || this.fromOrientedRange(range);\n\t            }\n\t            this.rangeList.removeAll();\n\t            this.rangeList.add(oldRange);\n\t            this.$onAddRange(oldRange);\n\t        }\n\n\t        if (!range.cursor)\n\t            range.cursor = range.end;\n\n\t        var removed = this.rangeList.add(range);\n\n\t        this.$onAddRange(range);\n\n\t        if (removed.length)\n\t            this.$onRemoveRange(removed);\n\n\t        if (this.rangeCount > 1 && !this.inMultiSelectMode) {\n\t            this._signal(\"multiSelect\");\n\t            this.inMultiSelectMode = true;\n\t            this.session.$undoSelect = false;\n\t            this.rangeList.attach(this.session);\n\t        }\n\n\t        return $blockChangeEvents || this.fromOrientedRange(range);\n\t    };\n\n\t    this.toSingleRange = function(range) {\n\t        range = range || this.ranges[0];\n\t        var removed = this.rangeList.removeAll();\n\t        if (removed.length)\n\t            this.$onRemoveRange(removed);\n\n\t        range && this.fromOrientedRange(range);\n\t    };\n\t    this.substractPoint = function(pos) {\n\t        var removed = this.rangeList.substractPoint(pos);\n\t        if (removed) {\n\t            this.$onRemoveRange(removed);\n\t            return removed[0];\n\t        }\n\t    };\n\t    this.mergeOverlappingRanges = function() {\n\t        var removed = this.rangeList.merge();\n\t        if (removed.length)\n\t            this.$onRemoveRange(removed);\n\t        else if(this.ranges[0])\n\t            this.fromOrientedRange(this.ranges[0]);\n\t    };\n\n\t    this.$onAddRange = function(range) {\n\t        this.rangeCount = this.rangeList.ranges.length;\n\t        this.ranges.unshift(range);\n\t        this._signal(\"addRange\", {range: range});\n\t    };\n\n\t    this.$onRemoveRange = function(removed) {\n\t        this.rangeCount = this.rangeList.ranges.length;\n\t        if (this.rangeCount == 1 && this.inMultiSelectMode) {\n\t            var lastRange = this.rangeList.ranges.pop();\n\t            removed.push(lastRange);\n\t            this.rangeCount = 0;\n\t        }\n\n\t        for (var i = removed.length; i--; ) {\n\t            var index = this.ranges.indexOf(removed[i]);\n\t            this.ranges.splice(index, 1);\n\t        }\n\n\t        this._signal(\"removeRange\", {ranges: removed});\n\n\t        if (this.rangeCount === 0 && this.inMultiSelectMode) {\n\t            this.inMultiSelectMode = false;\n\t            this._signal(\"singleSelect\");\n\t            this.session.$undoSelect = true;\n\t            this.rangeList.detach(this.session);\n\t        }\n\n\t        lastRange = lastRange || this.ranges[0];\n\t        if (lastRange && !lastRange.isEqual(this.getRange()))\n\t            this.fromOrientedRange(lastRange);\n\t    };\n\t    this.$initRangeList = function() {\n\t        if (this.rangeList)\n\t            return;\n\n\t        this.rangeList = new RangeList();\n\t        this.ranges = [];\n\t        this.rangeCount = 0;\n\t    };\n\t    this.getAllRanges = function() {\n\t        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];\n\t    };\n\n\t    this.splitIntoLines = function () {\n\t        if (this.rangeCount > 1) {\n\t            var ranges = this.rangeList.ranges;\n\t            var lastRange = ranges[ranges.length - 1];\n\t            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n\t            this.toSingleRange();\n\t            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n\t        } else {\n\t            var range = this.getRange();\n\t            var isBackwards = this.isBackwards();\n\t            var startRow = range.start.row;\n\t            var endRow = range.end.row;\n\t            if (startRow == endRow) {\n\t                if (isBackwards)\n\t                    var start = range.end, end = range.start;\n\t                else\n\t                    var start = range.start, end = range.end;\n\t                \n\t                this.addRange(Range.fromPoints(end, end));\n\t                this.addRange(Range.fromPoints(start, start));\n\t                return;\n\t            }\n\n\t            var rectSel = [];\n\t            var r = this.getLineRange(startRow, true);\n\t            r.start.column = range.start.column;\n\t            rectSel.push(r);\n\n\t            for (var i = startRow + 1; i < endRow; i++)\n\t                rectSel.push(this.getLineRange(i, true));\n\n\t            r = this.getLineRange(endRow, true);\n\t            r.end.column = range.end.column;\n\t            rectSel.push(r);\n\n\t            rectSel.forEach(this.addRange, this);\n\t        }\n\t    };\n\t    this.toggleBlockSelection = function () {\n\t        if (this.rangeCount > 1) {\n\t            var ranges = this.rangeList.ranges;\n\t            var lastRange = ranges[ranges.length - 1];\n\t            var range = Range.fromPoints(ranges[0].start, lastRange.end);\n\n\t            this.toSingleRange();\n\t            this.setSelectionRange(range, lastRange.cursor == lastRange.start);\n\t        } else {\n\t            var cursor = this.session.documentToScreenPosition(this.selectionLead);\n\t            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);\n\n\t            var rectSel = this.rectangularRangeBlock(cursor, anchor);\n\t            rectSel.forEach(this.addRange, this);\n\t        }\n\t    };\n\t    this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {\n\t        var rectSel = [];\n\n\t        var xBackwards = screenCursor.column < screenAnchor.column;\n\t        if (xBackwards) {\n\t            var startColumn = screenCursor.column;\n\t            var endColumn = screenAnchor.column;\n\t        } else {\n\t            var startColumn = screenAnchor.column;\n\t            var endColumn = screenCursor.column;\n\t        }\n\n\t        var yBackwards = screenCursor.row < screenAnchor.row;\n\t        if (yBackwards) {\n\t            var startRow = screenCursor.row;\n\t            var endRow = screenAnchor.row;\n\t        } else {\n\t            var startRow = screenAnchor.row;\n\t            var endRow = screenCursor.row;\n\t        }\n\n\t        if (startColumn < 0)\n\t            startColumn = 0;\n\t        if (startRow < 0)\n\t            startRow = 0;\n\n\t        if (startRow == endRow)\n\t            includeEmptyLines = true;\n\n\t        for (var row = startRow; row <= endRow; row++) {\n\t            var range = Range.fromPoints(\n\t                this.session.screenToDocumentPosition(row, startColumn),\n\t                this.session.screenToDocumentPosition(row, endColumn)\n\t            );\n\t            if (range.isEmpty()) {\n\t                if (docEnd && isSamePoint(range.end, docEnd))\n\t                    break;\n\t                var docEnd = range.end;\n\t            }\n\t            range.cursor = xBackwards ? range.start : range.end;\n\t            rectSel.push(range);\n\t        }\n\n\t        if (yBackwards)\n\t            rectSel.reverse();\n\n\t        if (!includeEmptyLines) {\n\t            var end = rectSel.length - 1;\n\t            while (rectSel[end].isEmpty() && end > 0)\n\t                end--;\n\t            if (end > 0) {\n\t                var start = 0;\n\t                while (rectSel[start].isEmpty())\n\t                    start++;\n\t            }\n\t            for (var i = end; i >= start; i--) {\n\t                if (rectSel[i].isEmpty())\n\t                    rectSel.splice(i, 1);\n\t            }\n\t        }\n\n\t        return rectSel;\n\t    };\n\t}).call(Selection.prototype);\n\tvar Editor = acequire(\"./editor\").Editor;\n\t(function() {\n\t    this.updateSelectionMarkers = function() {\n\t        this.renderer.updateCursor();\n\t        this.renderer.updateBackMarkers();\n\t    };\n\t    this.addSelectionMarker = function(orientedRange) {\n\t        if (!orientedRange.cursor)\n\t            orientedRange.cursor = orientedRange.end;\n\n\t        var style = this.getSelectionStyle();\n\t        orientedRange.marker = this.session.addMarker(orientedRange, \"ace_selection\", style);\n\n\t        this.session.$selectionMarkers.push(orientedRange);\n\t        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n\t        return orientedRange;\n\t    };\n\t    this.removeSelectionMarker = function(range) {\n\t        if (!range.marker)\n\t            return;\n\t        this.session.removeMarker(range.marker);\n\t        var index = this.session.$selectionMarkers.indexOf(range);\n\t        if (index != -1)\n\t            this.session.$selectionMarkers.splice(index, 1);\n\t        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;\n\t    };\n\n\t    this.removeSelectionMarkers = function(ranges) {\n\t        var markerList = this.session.$selectionMarkers;\n\t        for (var i = ranges.length; i--; ) {\n\t            var range = ranges[i];\n\t            if (!range.marker)\n\t                continue;\n\t            this.session.removeMarker(range.marker);\n\t            var index = markerList.indexOf(range);\n\t            if (index != -1)\n\t                markerList.splice(index, 1);\n\t        }\n\t        this.session.selectionMarkerCount = markerList.length;\n\t    };\n\n\t    this.$onAddRange = function(e) {\n\t        this.addSelectionMarker(e.range);\n\t        this.renderer.updateCursor();\n\t        this.renderer.updateBackMarkers();\n\t    };\n\n\t    this.$onRemoveRange = function(e) {\n\t        this.removeSelectionMarkers(e.ranges);\n\t        this.renderer.updateCursor();\n\t        this.renderer.updateBackMarkers();\n\t    };\n\n\t    this.$onMultiSelect = function(e) {\n\t        if (this.inMultiSelectMode)\n\t            return;\n\t        this.inMultiSelectMode = true;\n\n\t        this.setStyle(\"ace_multiselect\");\n\t        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);\n\t        this.commands.setDefaultHandler(\"exec\", this.$onMultiSelectExec);\n\n\t        this.renderer.updateCursor();\n\t        this.renderer.updateBackMarkers();\n\t    };\n\n\t    this.$onSingleSelect = function(e) {\n\t        if (this.session.multiSelect.inVirtualMode)\n\t            return;\n\t        this.inMultiSelectMode = false;\n\n\t        this.unsetStyle(\"ace_multiselect\");\n\t        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);\n\n\t        this.commands.removeDefaultHandler(\"exec\", this.$onMultiSelectExec);\n\t        this.renderer.updateCursor();\n\t        this.renderer.updateBackMarkers();\n\t        this._emit(\"changeSelection\");\n\t    };\n\n\t    this.$onMultiSelectExec = function(e) {\n\t        var command = e.command;\n\t        var editor = e.editor;\n\t        if (!editor.multiSelect)\n\t            return;\n\t        if (!command.multiSelectAction) {\n\t            var result = command.exec(editor, e.args || {});\n\t            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());\n\t            editor.multiSelect.mergeOverlappingRanges();\n\t        } else if (command.multiSelectAction == \"forEach\") {\n\t            result = editor.forEachSelection(command, e.args);\n\t        } else if (command.multiSelectAction == \"forEachLine\") {\n\t            result = editor.forEachSelection(command, e.args, true);\n\t        } else if (command.multiSelectAction == \"single\") {\n\t            editor.exitMultiSelectMode();\n\t            result = command.exec(editor, e.args || {});\n\t        } else {\n\t            result = command.multiSelectAction(editor, e.args || {});\n\t        }\n\t        return result;\n\t    }; \n\t    this.forEachSelection = function(cmd, args, options) {\n\t        if (this.inVirtualSelectionMode)\n\t            return;\n\t        var keepOrder = options && options.keepOrder;\n\t        var $byLines = options == true || options && options.$byLines\n\t        var session = this.session;\n\t        var selection = this.selection;\n\t        var rangeList = selection.rangeList;\n\t        var ranges = (keepOrder ? selection : rangeList).ranges;\n\t        var result;\n\t        \n\t        if (!ranges.length)\n\t            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n\t        \n\t        var reg = selection._eventRegistry;\n\t        selection._eventRegistry = {};\n\n\t        var tmpSel = new Selection(session);\n\t        this.inVirtualSelectionMode = true;\n\t        for (var i = ranges.length; i--;) {\n\t            if ($byLines) {\n\t                while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)\n\t                    i--;\n\t            }\n\t            tmpSel.fromOrientedRange(ranges[i]);\n\t            tmpSel.index = i;\n\t            this.selection = session.selection = tmpSel;\n\t            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});\n\t            if (!result && cmdResult !== undefined)\n\t                result = cmdResult;\n\t            tmpSel.toOrientedRange(ranges[i]);\n\t        }\n\t        tmpSel.detach();\n\n\t        this.selection = session.selection = selection;\n\t        this.inVirtualSelectionMode = false;\n\t        selection._eventRegistry = reg;\n\t        selection.mergeOverlappingRanges();\n\t        \n\t        var anim = this.renderer.$scrollAnimation;\n\t        this.onCursorChange();\n\t        this.onSelectionChange();\n\t        if (anim && anim.from == anim.to)\n\t            this.renderer.animateScrolling(anim.from);\n\t        \n\t        return result;\n\t    };\n\t    this.exitMultiSelectMode = function() {\n\t        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n\t            return;\n\t        this.multiSelect.toSingleRange();\n\t    };\n\n\t    this.getSelectedText = function() {\n\t        var text = \"\";\n\t        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n\t            var ranges = this.multiSelect.rangeList.ranges;\n\t            var buf = [];\n\t            for (var i = 0; i < ranges.length; i++) {\n\t                buf.push(this.session.getTextRange(ranges[i]));\n\t            }\n\t            var nl = this.session.getDocument().getNewLineCharacter();\n\t            text = buf.join(nl);\n\t            if (text.length == (buf.length - 1) * nl.length)\n\t                text = \"\";\n\t        } else if (!this.selection.isEmpty()) {\n\t            text = this.session.getTextRange(this.getSelectionRange());\n\t        }\n\t        return text;\n\t    };\n\t    \n\t    this.$checkMultiselectChange = function(e, anchor) {\n\t        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {\n\t            var range = this.multiSelect.ranges[0];\n\t            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)\n\t                return;\n\t            var pos = anchor == this.multiSelect.anchor\n\t                ? range.cursor == range.start ? range.end : range.start\n\t                : range.cursor;\n\t            if (!isSamePoint(pos, anchor))\n\t                this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());\n\t        }\n\t    };\n\t    this.onPaste = function(text) {\n\t        if (this.$readOnly)\n\t            return;\n\n\n\t        var e = {text: text};\n\t        this._signal(\"paste\", e);\n\t        text = e.text;\n\t        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)\n\t            return this.insert(text);\n\n\t        var lines = text.split(/\\r\\n|\\r|\\n/);\n\t        var ranges = this.selection.rangeList.ranges;\n\n\t        if (lines.length > ranges.length || lines.length < 2 || !lines[1])\n\t            return this.commands.exec(\"insertstring\", this, text);\n\n\t        for (var i = ranges.length; i--;) {\n\t            var range = ranges[i];\n\t            if (!range.isEmpty())\n\t                this.session.remove(range);\n\n\t            this.session.insert(range.start, lines[i]);\n\t        }\n\t    };\n\t    this.findAll = function(needle, options, additive) {\n\t        options = options || {};\n\t        options.needle = needle || options.needle;\n\t        if (options.needle == undefined) {\n\t            var range = this.selection.isEmpty()\n\t                ? this.selection.getWordRange()\n\t                : this.selection.getRange();\n\t            options.needle = this.session.getTextRange(range);\n\t        }    \n\t        this.$search.set(options);\n\t        \n\t        var ranges = this.$search.findAll(this.session);\n\t        if (!ranges.length)\n\t            return 0;\n\n\t        this.$blockScrolling += 1;\n\t        var selection = this.multiSelect;\n\n\t        if (!additive)\n\t            selection.toSingleRange(ranges[0]);\n\n\t        for (var i = ranges.length; i--; )\n\t            selection.addRange(ranges[i], true);\n\t        if (range && selection.rangeList.rangeAtPoint(range.start))\n\t            selection.addRange(range, true);\n\t        \n\t        this.$blockScrolling -= 1;\n\n\t        return ranges.length;\n\t    };\n\t    this.selectMoreLines = function(dir, skip) {\n\t        var range = this.selection.toOrientedRange();\n\t        var isBackwards = range.cursor == range.end;\n\n\t        var screenLead = this.session.documentToScreenPosition(range.cursor);\n\t        if (this.selection.$desiredColumn)\n\t            screenLead.column = this.selection.$desiredColumn;\n\n\t        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);\n\n\t        if (!range.isEmpty()) {\n\t            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);\n\t            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);\n\t        } else {\n\t            var anchor = lead;\n\t        }\n\n\t        if (isBackwards) {\n\t            var newRange = Range.fromPoints(lead, anchor);\n\t            newRange.cursor = newRange.start;\n\t        } else {\n\t            var newRange = Range.fromPoints(anchor, lead);\n\t            newRange.cursor = newRange.end;\n\t        }\n\n\t        newRange.desiredColumn = screenLead.column;\n\t        if (!this.selection.inMultiSelectMode) {\n\t            this.selection.addRange(range);\n\t        } else {\n\t            if (skip)\n\t                var toRemove = range.cursor;\n\t        }\n\n\t        this.selection.addRange(newRange);\n\t        if (toRemove)\n\t            this.selection.substractPoint(toRemove);\n\t    };\n\t    this.transposeSelections = function(dir) {\n\t        var session = this.session;\n\t        var sel = session.multiSelect;\n\t        var all = sel.ranges;\n\n\t        for (var i = all.length; i--; ) {\n\t            var range = all[i];\n\t            if (range.isEmpty()) {\n\t                var tmp = session.getWordRange(range.start.row, range.start.column);\n\t                range.start.row = tmp.start.row;\n\t                range.start.column = tmp.start.column;\n\t                range.end.row = tmp.end.row;\n\t                range.end.column = tmp.end.column;\n\t            }\n\t        }\n\t        sel.mergeOverlappingRanges();\n\n\t        var words = [];\n\t        for (var i = all.length; i--; ) {\n\t            var range = all[i];\n\t            words.unshift(session.getTextRange(range));\n\t        }\n\n\t        if (dir < 0)\n\t            words.unshift(words.pop());\n\t        else\n\t            words.push(words.shift());\n\n\t        for (var i = all.length; i--; ) {\n\t            var range = all[i];\n\t            var tmp = range.clone();\n\t            session.replace(range, words[i]);\n\t            range.start.row = tmp.start.row;\n\t            range.start.column = tmp.start.column;\n\t        }\n\t    };\n\t    this.selectMore = function(dir, skip, stopAtFirst) {\n\t        var session = this.session;\n\t        var sel = session.multiSelect;\n\n\t        var range = sel.toOrientedRange();\n\t        if (range.isEmpty()) {\n\t            range = session.getWordRange(range.start.row, range.start.column);\n\t            range.cursor = dir == -1 ? range.start : range.end;\n\t            this.multiSelect.addRange(range);\n\t            if (stopAtFirst)\n\t                return;\n\t        }\n\t        var needle = session.getTextRange(range);\n\n\t        var newRange = find(session, needle, dir);\n\t        if (newRange) {\n\t            newRange.cursor = dir == -1 ? newRange.start : newRange.end;\n\t            this.$blockScrolling += 1;\n\t            this.session.unfold(newRange);\n\t            this.multiSelect.addRange(newRange);\n\t            this.$blockScrolling -= 1;\n\t            this.renderer.scrollCursorIntoView(null, 0.5);\n\t        }\n\t        if (skip)\n\t            this.multiSelect.substractPoint(range.cursor);\n\t    };\n\t    this.alignCursors = function() {\n\t        var session = this.session;\n\t        var sel = session.multiSelect;\n\t        var ranges = sel.ranges;\n\t        var row = -1;\n\t        var sameRowRanges = ranges.filter(function(r) {\n\t            if (r.cursor.row == row)\n\t                return true;\n\t            row = r.cursor.row;\n\t        });\n\t        \n\t        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {\n\t            var range = this.selection.getRange();\n\t            var fr = range.start.row, lr = range.end.row;\n\t            var guessRange = fr == lr;\n\t            if (guessRange) {\n\t                var max = this.session.getLength();\n\t                var line;\n\t                do {\n\t                    line = this.session.getLine(lr);\n\t                } while (/[=:]/.test(line) && ++lr < max);\n\t                do {\n\t                    line = this.session.getLine(fr);\n\t                } while (/[=:]/.test(line) && --fr > 0);\n\t                \n\t                if (fr < 0) fr = 0;\n\t                if (lr >= max) lr = max - 1;\n\t            }\n\t            var lines = this.session.doc.removeLines(fr, lr);\n\t            lines = this.$reAlignText(lines, guessRange);\n\t            this.session.doc.insert({row: fr, column: 0}, lines.join(\"\\n\") + \"\\n\");\n\t            if (!guessRange) {\n\t                range.start.column = 0;\n\t                range.end.column = lines[lines.length - 1].length;\n\t            }\n\t            this.selection.setRange(range);\n\t        } else {\n\t            sameRowRanges.forEach(function(r) {\n\t                sel.substractPoint(r.cursor);\n\t            });\n\n\t            var maxCol = 0;\n\t            var minSpace = Infinity;\n\t            var spaceOffsets = ranges.map(function(r) {\n\t                var p = r.cursor;\n\t                var line = session.getLine(p.row);\n\t                var spaceOffset = line.substr(p.column).search(/\\S/g);\n\t                if (spaceOffset == -1)\n\t                    spaceOffset = 0;\n\n\t                if (p.column > maxCol)\n\t                    maxCol = p.column;\n\t                if (spaceOffset < minSpace)\n\t                    minSpace = spaceOffset;\n\t                return spaceOffset;\n\t            });\n\t            ranges.forEach(function(r, i) {\n\t                var p = r.cursor;\n\t                var l = maxCol - p.column;\n\t                var d = spaceOffsets[i] - minSpace;\n\t                if (l > d)\n\t                    session.insert(p, lang.stringRepeat(\" \", l - d));\n\t                else\n\t                    session.remove(new Range(p.row, p.column, p.row, p.column - l + d));\n\n\t                r.start.column = r.end.column = maxCol;\n\t                r.start.row = r.end.row = p.row;\n\t                r.cursor = r.end;\n\t            });\n\t            sel.fromOrientedRange(ranges[0]);\n\t            this.renderer.updateCursor();\n\t            this.renderer.updateBackMarkers();\n\t        }\n\t    };\n\n\t    this.$reAlignText = function(lines, forceLeft) {\n\t        var isLeftAligned = true, isRightAligned = true;\n\t        var startW, textW, endW;\n\n\t        return lines.map(function(line) {\n\t            var m = line.match(/(\\s*)(.*?)(\\s*)([=:].*)/);\n\t            if (!m)\n\t                return [line];\n\n\t            if (startW == null) {\n\t                startW = m[1].length;\n\t                textW = m[2].length;\n\t                endW = m[3].length;\n\t                return m;\n\t            }\n\n\t            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)\n\t                isRightAligned = false;\n\t            if (startW != m[1].length)\n\t                isLeftAligned = false;\n\n\t            if (startW > m[1].length)\n\t                startW = m[1].length;\n\t            if (textW < m[2].length)\n\t                textW = m[2].length;\n\t            if (endW > m[3].length)\n\t                endW = m[3].length;\n\n\t            return m;\n\t        }).map(forceLeft ? alignLeft :\n\t            isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);\n\n\t        function spaces(n) {\n\t            return lang.stringRepeat(\" \", n);\n\t        }\n\n\t        function alignLeft(m) {\n\t            return !m[2] ? m[0] : spaces(startW) + m[2]\n\t                + spaces(textW - m[2].length + endW)\n\t                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n\t        }\n\t        function alignRight(m) {\n\t            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]\n\t                + spaces(endW, \" \")\n\t                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n\t        }\n\t        function unAlign(m) {\n\t            return !m[2] ? m[0] : spaces(startW) + m[2]\n\t                + spaces(endW)\n\t                + m[4].replace(/^([=:])\\s+/, \"$1 \");\n\t        }\n\t    };\n\t}).call(Editor.prototype);\n\n\n\tfunction isSamePoint(p1, p2) {\n\t    return p1.row == p2.row && p1.column == p2.column;\n\t}\n\texports.onSessionChange = function(e) {\n\t    var session = e.session;\n\t    if (session && !session.multiSelect) {\n\t        session.$selectionMarkers = [];\n\t        session.selection.$initRangeList();\n\t        session.multiSelect = session.selection;\n\t    }\n\t    this.multiSelect = session && session.multiSelect;\n\n\t    var oldSession = e.oldSession;\n\t    if (oldSession) {\n\t        oldSession.multiSelect.off(\"addRange\", this.$onAddRange);\n\t        oldSession.multiSelect.off(\"removeRange\", this.$onRemoveRange);\n\t        oldSession.multiSelect.off(\"multiSelect\", this.$onMultiSelect);\n\t        oldSession.multiSelect.off(\"singleSelect\", this.$onSingleSelect);\n\t        oldSession.multiSelect.lead.off(\"change\",  this.$checkMultiselectChange);\n\t        oldSession.multiSelect.anchor.off(\"change\",  this.$checkMultiselectChange);\n\t    }\n\n\t    if (session) {\n\t        session.multiSelect.on(\"addRange\", this.$onAddRange);\n\t        session.multiSelect.on(\"removeRange\", this.$onRemoveRange);\n\t        session.multiSelect.on(\"multiSelect\", this.$onMultiSelect);\n\t        session.multiSelect.on(\"singleSelect\", this.$onSingleSelect);\n\t        session.multiSelect.lead.on(\"change\",  this.$checkMultiselectChange);\n\t        session.multiSelect.anchor.on(\"change\",  this.$checkMultiselectChange);\n\t    }\n\n\t    if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {\n\t        if (session.selection.inMultiSelectMode)\n\t            this.$onMultiSelect();\n\t        else\n\t            this.$onSingleSelect();\n\t    }\n\t};\n\tfunction MultiSelect(editor) {\n\t    if (editor.$multiselectOnSessionChange)\n\t        return;\n\t    editor.$onAddRange = editor.$onAddRange.bind(editor);\n\t    editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);\n\t    editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);\n\t    editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);\n\t    editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);\n\t    editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);\n\n\t    editor.$multiselectOnSessionChange(editor);\n\t    editor.on(\"changeSession\", editor.$multiselectOnSessionChange);\n\n\t    editor.on(\"mousedown\", onMouseDown);\n\t    editor.commands.addCommands(commands.defaultCommands);\n\n\t    addAltCursorListeners(editor);\n\t}\n\n\tfunction addAltCursorListeners(editor){\n\t    var el = editor.textInput.getElement();\n\t    var altCursor = false;\n\t    event.addListener(el, \"keydown\", function(e) {\n\t        if (e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey)) {\n\t            if (!altCursor) {\n\t                editor.renderer.setMouseCursor(\"crosshair\");\n\t                altCursor = true;\n\t            }\n\t        } else if (altCursor) {\n\t            reset();\n\t        }\n\t    });\n\n\t    event.addListener(el, \"keyup\", reset);\n\t    event.addListener(el, \"blur\", reset);\n\t    function reset(e) {\n\t        if (altCursor) {\n\t            editor.renderer.setMouseCursor(\"\");\n\t            altCursor = false;\n\t        }\n\t    }\n\t}\n\n\texports.MultiSelect = MultiSelect;\n\n\n\tacequire(\"./config\").defineOptions(Editor.prototype, \"editor\", {\n\t    enableMultiselect: {\n\t        set: function(val) {\n\t            MultiSelect(this);\n\t            if (val) {\n\t                this.on(\"changeSession\", this.$multiselectOnSessionChange);\n\t                this.on(\"mousedown\", onMouseDown);\n\t            } else {\n\t                this.off(\"changeSession\", this.$multiselectOnSessionChange);\n\t                this.off(\"mousedown\", onMouseDown);\n\t            }\n\t        },\n\t        value: true\n\t    }\n\t});\n\n\n\n\t});\n\n\tace.define(\"ace/mode/folding/fold_mode\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"../../range\").Range;\n\n\tvar FoldMode = exports.FoldMode = function() {};\n\n\t(function() {\n\n\t    this.foldingStartMarker = null;\n\t    this.foldingStopMarker = null;\n\t    this.getFoldWidget = function(session, foldStyle, row) {\n\t        var line = session.getLine(row);\n\t        if (this.foldingStartMarker.test(line))\n\t            return \"start\";\n\t        if (foldStyle == \"markbeginend\"\n\t                && this.foldingStopMarker\n\t                && this.foldingStopMarker.test(line))\n\t            return \"end\";\n\t        return \"\";\n\t    };\n\n\t    this.getFoldWidgetRange = function(session, foldStyle, row) {\n\t        return null;\n\t    };\n\n\t    this.indentationBlock = function(session, row, column) {\n\t        var re = /\\S/;\n\t        var line = session.getLine(row);\n\t        var startLevel = line.search(re);\n\t        if (startLevel == -1)\n\t            return;\n\n\t        var startColumn = column || line.length;\n\t        var maxRow = session.getLength();\n\t        var startRow = row;\n\t        var endRow = row;\n\n\t        while (++row < maxRow) {\n\t            var level = session.getLine(row).search(re);\n\n\t            if (level == -1)\n\t                continue;\n\n\t            if (level <= startLevel)\n\t                break;\n\n\t            endRow = row;\n\t        }\n\n\t        if (endRow > startRow) {\n\t            var endColumn = session.getLine(endRow).length;\n\t            return new Range(startRow, startColumn, endRow, endColumn);\n\t        }\n\t    };\n\n\t    this.openingBracketBlock = function(session, bracket, row, column, typeRe) {\n\t        var start = {row: row, column: column + 1};\n\t        var end = session.$findClosingBracket(bracket, start, typeRe);\n\t        if (!end)\n\t            return;\n\n\t        var fw = session.foldWidgets[end.row];\n\t        if (fw == null)\n\t            fw = session.getFoldWidget(end.row);\n\n\t        if (fw == \"start\" && end.row > start.row) {\n\t            end.row --;\n\t            end.column = session.getLine(end.row).length;\n\t        }\n\t        return Range.fromPoints(start, end);\n\t    };\n\n\t    this.closingBracketBlock = function(session, bracket, row, column, typeRe) {\n\t        var end = {row: row, column: column};\n\t        var start = session.$findOpeningBracket(bracket, end);\n\n\t        if (!start)\n\t            return;\n\n\t        start.column++;\n\t        end.column--;\n\n\t        return  Range.fromPoints(start, end);\n\t    };\n\t}).call(FoldMode.prototype);\n\n\t});\n\n\tace.define(\"ace/theme/textmate\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\texports.isDark = false;\n\texports.cssClass = \"ace-tm\";\n\texports.cssText = \".ace-tm .ace_gutter {\\\n\tbackground: #f0f0f0;\\\n\tcolor: #333;\\\n\t}\\\n\t.ace-tm .ace_print-margin {\\\n\twidth: 1px;\\\n\tbackground: #e8e8e8;\\\n\t}\\\n\t.ace-tm .ace_fold {\\\n\tbackground-color: #6B72E6;\\\n\t}\\\n\t.ace-tm {\\\n\tbackground-color: #FFFFFF;\\\n\tcolor: black;\\\n\t}\\\n\t.ace-tm .ace_cursor {\\\n\tcolor: black;\\\n\t}\\\n\t.ace-tm .ace_invisible {\\\n\tcolor: rgb(191, 191, 191);\\\n\t}\\\n\t.ace-tm .ace_storage,\\\n\t.ace-tm .ace_keyword {\\\n\tcolor: blue;\\\n\t}\\\n\t.ace-tm .ace_constant {\\\n\tcolor: rgb(197, 6, 11);\\\n\t}\\\n\t.ace-tm .ace_constant.ace_buildin {\\\n\tcolor: rgb(88, 72, 246);\\\n\t}\\\n\t.ace-tm .ace_constant.ace_language {\\\n\tcolor: rgb(88, 92, 246);\\\n\t}\\\n\t.ace-tm .ace_constant.ace_library {\\\n\tcolor: rgb(6, 150, 14);\\\n\t}\\\n\t.ace-tm .ace_invalid {\\\n\tbackground-color: rgba(255, 0, 0, 0.1);\\\n\tcolor: red;\\\n\t}\\\n\t.ace-tm .ace_support.ace_function {\\\n\tcolor: rgb(60, 76, 114);\\\n\t}\\\n\t.ace-tm .ace_support.ace_constant {\\\n\tcolor: rgb(6, 150, 14);\\\n\t}\\\n\t.ace-tm .ace_support.ace_type,\\\n\t.ace-tm .ace_support.ace_class {\\\n\tcolor: rgb(109, 121, 222);\\\n\t}\\\n\t.ace-tm .ace_keyword.ace_operator {\\\n\tcolor: rgb(104, 118, 135);\\\n\t}\\\n\t.ace-tm .ace_string {\\\n\tcolor: rgb(3, 106, 7);\\\n\t}\\\n\t.ace-tm .ace_comment {\\\n\tcolor: rgb(76, 136, 107);\\\n\t}\\\n\t.ace-tm .ace_comment.ace_doc {\\\n\tcolor: rgb(0, 102, 255);\\\n\t}\\\n\t.ace-tm .ace_comment.ace_doc.ace_tag {\\\n\tcolor: rgb(128, 159, 191);\\\n\t}\\\n\t.ace-tm .ace_constant.ace_numeric {\\\n\tcolor: rgb(0, 0, 205);\\\n\t}\\\n\t.ace-tm .ace_variable {\\\n\tcolor: rgb(49, 132, 149);\\\n\t}\\\n\t.ace-tm .ace_xml-pe {\\\n\tcolor: rgb(104, 104, 91);\\\n\t}\\\n\t.ace-tm .ace_entity.ace_name.ace_function {\\\n\tcolor: #0000A2;\\\n\t}\\\n\t.ace-tm .ace_heading {\\\n\tcolor: rgb(12, 7, 255);\\\n\t}\\\n\t.ace-tm .ace_list {\\\n\tcolor:rgb(185, 6, 144);\\\n\t}\\\n\t.ace-tm .ace_meta.ace_tag {\\\n\tcolor:rgb(0, 22, 142);\\\n\t}\\\n\t.ace-tm .ace_string.ace_regex {\\\n\tcolor: rgb(255, 0, 0)\\\n\t}\\\n\t.ace-tm .ace_marker-layer .ace_selection {\\\n\tbackground: rgb(181, 213, 255);\\\n\t}\\\n\t.ace-tm.ace_multiselect .ace_selection.ace_start {\\\n\tbox-shadow: 0 0 3px 0px white;\\\n\tborder-radius: 2px;\\\n\t}\\\n\t.ace-tm .ace_marker-layer .ace_step {\\\n\tbackground: rgb(252, 255, 0);\\\n\t}\\\n\t.ace-tm .ace_marker-layer .ace_stack {\\\n\tbackground: rgb(164, 229, 101);\\\n\t}\\\n\t.ace-tm .ace_marker-layer .ace_bracket {\\\n\tmargin: -1px 0 0 -1px;\\\n\tborder: 1px solid rgb(192, 192, 192);\\\n\t}\\\n\t.ace-tm .ace_marker-layer .ace_active-line {\\\n\tbackground: rgba(0, 0, 0, 0.07);\\\n\t}\\\n\t.ace-tm .ace_gutter-active-line {\\\n\tbackground-color : #dcdcdc;\\\n\t}\\\n\t.ace-tm .ace_marker-layer .ace_selected-word {\\\n\tbackground: rgb(250, 250, 255);\\\n\tborder: 1px solid rgb(200, 200, 250);\\\n\t}\\\n\t.ace-tm .ace_indent-guide {\\\n\tbackground: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\\\") right repeat-y;\\\n\t}\\\n\t\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tdom.importCssString(exports.cssText, exports.cssClass);\n\t});\n\n\tace.define(\"ace/line_widgets\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/dom\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"./lib/oop\");\n\tvar dom = acequire(\"./lib/dom\");\n\tvar Range = acequire(\"./range\").Range;\n\n\n\tfunction LineWidgets(session) {\n\t    this.session = session;\n\t    this.session.widgetManager = this;\n\t    this.session.getRowLength = this.getRowLength;\n\t    this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;\n\t    this.updateOnChange = this.updateOnChange.bind(this);\n\t    this.renderWidgets = this.renderWidgets.bind(this);\n\t    this.measureWidgets = this.measureWidgets.bind(this);\n\t    this.session._changedWidgets = [];\n\t    this.$onChangeEditor = this.$onChangeEditor.bind(this);\n\t    \n\t    this.session.on(\"change\", this.updateOnChange);\n\t    this.session.on(\"changeEditor\", this.$onChangeEditor);\n\t}\n\n\t(function() {\n\t    this.getRowLength = function(row) {\n\t        var h;\n\t        if (this.lineWidgets)\n\t            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;\n\t        else \n\t            h = 0;\n\t        if (!this.$useWrapMode || !this.$wrapData[row]) {\n\t            return 1 + h;\n\t        } else {\n\t            return this.$wrapData[row].length + 1 + h;\n\t        }\n\t    };\n\n\t    this.$getWidgetScreenLength = function() {\n\t        var screenRows = 0;\n\t        this.lineWidgets.forEach(function(w){\n\t            if (w && w.rowCount)\n\t                screenRows +=w.rowCount;\n\t        });\n\t        return screenRows;\n\t    };    \n\t    \n\t    this.$onChangeEditor = function(e) {\n\t        this.attach(e.editor);\n\t    };\n\n\t    this.attach = function(editor) {\n\t        if (editor  && editor.widgetManager && editor.widgetManager != this)\n\t            editor.widgetManager.detach();\n\n\t        if (this.editor == editor)\n\t            return;\n\n\t        this.detach();\n\t        this.editor = editor;\n\t        \n\t        if (editor) {\n\t            editor.widgetManager = this;\n\t            editor.renderer.on(\"beforeRender\", this.measureWidgets);\n\t            editor.renderer.on(\"afterRender\", this.renderWidgets);\n\t        }\n\t    };\n\t    this.detach = function(e) {\n\t        var editor = this.editor;\n\t        if (!editor)\n\t            return;\n\t        \n\t        this.editor = null;\n\t        editor.widgetManager = null;\n\t        \n\t        editor.renderer.off(\"beforeRender\", this.measureWidgets);\n\t        editor.renderer.off(\"afterRender\", this.renderWidgets);\n\t        var lineWidgets = this.session.lineWidgets;\n\t        lineWidgets && lineWidgets.forEach(function(w) {\n\t            if (w && w.el && w.el.parentNode) {\n\t                w._inDocument = false;\n\t                w.el.parentNode.removeChild(w.el);\n\t            }\n\t        });\n\t    };\n\n\t    this.updateOnChange = function(e) {\n\t        var lineWidgets = this.session.lineWidgets;\n\t        if (!lineWidgets) return;\n\t            \n\t        var delta = e.data;\n\t        var range = delta.range;\n\t        var startRow = range.start.row;\n\t        var len = range.end.row - startRow;\n\n\t        if (len === 0) {\n\t        } else if (delta.action == \"removeText\" || delta.action == \"removeLines\") {\n\t            var removed = lineWidgets.splice(startRow + 1, len);\n\t            removed.forEach(function(w) {\n\t                w && this.removeLineWidget(w);\n\t            }, this);\n\t            this.$updateRows();\n\t        } else {\n\t            var args = new Array(len);\n\t            args.unshift(startRow, 0);\n\t            lineWidgets.splice.apply(lineWidgets, args);\n\t            this.$updateRows();\n\t        }\n\t    };\n\t    \n\t    this.$updateRows = function() {\n\t        var lineWidgets = this.session.lineWidgets;\n\t        if (!lineWidgets) return;\n\t        var noWidgets = true;\n\t        lineWidgets.forEach(function(w, i) {\n\t            if (w) {\n\t                noWidgets = false;\n\t                w.row = i;\n\t            }\n\t        });\n\t        if (noWidgets)\n\t            this.session.lineWidgets = null;\n\t    };\n\n\t    this.addLineWidget = function(w) {\n\t        if (!this.session.lineWidgets)\n\t            this.session.lineWidgets = new Array(this.session.getLength());\n\t        \n\t        this.session.lineWidgets[w.row] = w;\n\t        \n\t        var renderer = this.editor.renderer;\n\t        if (w.html && !w.el) {\n\t            w.el = dom.createElement(\"div\");\n\t            w.el.innerHTML = w.html;\n\t        }\n\t        if (w.el) {\n\t            dom.addCssClass(w.el, \"ace_lineWidgetContainer\");\n\t            w.el.style.position = \"absolute\";\n\t            w.el.style.zIndex = 5;\n\t            renderer.container.appendChild(w.el);\n\t            w._inDocument = true;\n\t        }\n\t        \n\t        if (!w.coverGutter) {\n\t            w.el.style.zIndex = 3;\n\t        }\n\t        if (!w.pixelHeight) {\n\t            w.pixelHeight = w.el.offsetHeight;\n\t        }\n\t        if (w.rowCount == null)\n\t            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;\n\t        \n\t        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n\t        \n\t        this.$updateRows();\n\t        this.renderWidgets(null, renderer);\n\t        return w;\n\t    };\n\t    \n\t    this.removeLineWidget = function(w) {\n\t        w._inDocument = false;\n\t        if (w.el && w.el.parentNode)\n\t            w.el.parentNode.removeChild(w.el);\n\t        if (w.editor && w.editor.destroy) try {\n\t            w.editor.destroy();\n\t        } catch(e){}\n\t        if (this.session.lineWidgets)\n\t            this.session.lineWidgets[w.row] = undefined;\n\t        this.session._emit(\"changeFold\", {data:{start:{row: w.row}}});\n\t        this.$updateRows();\n\t    };\n\t    \n\t    this.onWidgetChanged = function(w) {\n\t        this.session._changedWidgets.push(w);\n\t        this.editor && this.editor.renderer.updateFull();\n\t    };\n\t    \n\t    this.measureWidgets = function(e, renderer) {\n\t        var changedWidgets = this.session._changedWidgets;\n\t        var config = renderer.layerConfig;\n\t        \n\t        if (!changedWidgets || !changedWidgets.length) return;\n\t        var min = Infinity;\n\t        for (var i = 0; i < changedWidgets.length; i++) {\n\t            var w = changedWidgets[i];\n\t            if (!w._inDocument) {\n\t                w._inDocument = true;\n\t                renderer.container.appendChild(w.el);\n\t            }\n\t            \n\t            w.h = w.el.offsetHeight;\n\t            \n\t            if (!w.fixedWidth) {\n\t                w.w = w.el.offsetWidth;\n\t                w.screenWidth = Math.ceil(w.w / config.characterWidth);\n\t            }\n\t            \n\t            var rowCount = w.h / config.lineHeight;\n\t            if (w.coverLine) {\n\t                rowCount -= this.session.getRowLineCount(w.row);\n\t                if (rowCount < 0)\n\t                    rowCount = 0;\n\t            }\n\t            if (w.rowCount != rowCount) {\n\t                w.rowCount = rowCount;\n\t                if (w.row < min)\n\t                    min = w.row;\n\t            }\n\t        }\n\t        if (min != Infinity) {\n\t            this.session._emit(\"changeFold\", {data:{start:{row: min}}});\n\t            this.session.lineWidgetWidth = null;\n\t        }\n\t        this.session._changedWidgets = [];\n\t    };\n\t    \n\t    this.renderWidgets = function(e, renderer) {\n\t        var config = renderer.layerConfig;\n\t        var lineWidgets = this.session.lineWidgets;\n\t        if (!lineWidgets)\n\t            return;\n\t        var first = Math.min(this.firstRow, config.firstRow);\n\t        var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);\n\t        \n\t        while (first > 0 && !lineWidgets[first])\n\t            first--;\n\t        \n\t        this.firstRow = config.firstRow;\n\t        this.lastRow = config.lastRow;\n\n\t        renderer.$cursorLayer.config = config;\n\t        for (var i = first; i <= last; i++) {\n\t            var w = lineWidgets[i];\n\t            if (!w || !w.el) continue;\n\n\t            if (!w._inDocument) {\n\t                w._inDocument = true;\n\t                renderer.container.appendChild(w.el);\n\t            }\n\t            var top = renderer.$cursorLayer.getPixelPosition({row: i, column:0}, true).top;\n\t            if (!w.coverLine)\n\t                top += config.lineHeight * this.session.getRowLineCount(w.row);\n\t            w.el.style.top = top - config.offset + \"px\";\n\t            \n\t            var left = w.coverGutter ? 0 : renderer.gutterWidth;\n\t            if (!w.fixedWidth)\n\t                left -= renderer.scrollLeft;\n\t            w.el.style.left = left + \"px\";\n\n\t            if (w.fixedWidth) {\n\t                w.el.style.right = renderer.scrollBar.getWidth() + \"px\";\n\t            } else {\n\t                w.el.style.right = \"\";\n\t            }\n\t        }\n\t    };\n\t    \n\t}).call(LineWidgets.prototype);\n\n\n\texports.LineWidgets = LineWidgets;\n\n\t});\n\n\tace.define(\"ace/ext/error_marker\",[\"require\",\"exports\",\"module\",\"ace/line_widgets\",\"ace/lib/dom\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\tvar LineWidgets = acequire(\"../line_widgets\").LineWidgets;\n\tvar dom = acequire(\"../lib/dom\");\n\tvar Range = acequire(\"../range\").Range;\n\n\tfunction binarySearch(array, needle, comparator) {\n\t    var first = 0;\n\t    var last = array.length - 1;\n\n\t    while (first <= last) {\n\t        var mid = (first + last) >> 1;\n\t        var c = comparator(needle, array[mid]);\n\t        if (c > 0)\n\t            first = mid + 1;\n\t        else if (c < 0)\n\t            last = mid - 1;\n\t        else\n\t            return mid;\n\t    }\n\t    return -(first + 1);\n\t}\n\n\tfunction findAnnotations(session, row, dir) {\n\t    var annotations = session.getAnnotations().sort(Range.comparePoints);\n\t    if (!annotations.length)\n\t        return;\n\t    \n\t    var i = binarySearch(annotations, {row: row, column: -1}, Range.comparePoints);\n\t    if (i < 0)\n\t        i = -i - 1;\n\t    \n\t    if (i >= annotations.length - 1)\n\t        i = dir > 0 ? 0 : annotations.length - 1;\n\t    else if (i === 0 && dir < 0)\n\t        i = annotations.length - 1;\n\t    \n\t    var annotation = annotations[i];\n\t    if (!annotation || !dir)\n\t        return;\n\n\t    if (annotation.row === row) {\n\t        do {\n\t            annotation = annotations[i += dir];\n\t        } while (annotation && annotation.row === row);\n\t        if (!annotation)\n\t            return annotations.slice();\n\t    }\n\t    \n\t    \n\t    var matched = [];\n\t    row = annotation.row;\n\t    do {\n\t        matched[dir < 0 ? \"unshift\" : \"push\"](annotation);\n\t        annotation = annotations[i += dir];\n\t    } while (annotation && annotation.row == row);\n\t    return matched.length && matched;\n\t}\n\n\texports.showErrorMarker = function(editor, dir) {\n\t    var session = editor.session;\n\t    if (!session.widgetManager) {\n\t        session.widgetManager = new LineWidgets(session);\n\t        session.widgetManager.attach(editor);\n\t    }\n\t    \n\t    var pos = editor.getCursorPosition();\n\t    var row = pos.row;\n\t    var oldWidget = session.lineWidgets && session.lineWidgets[row];\n\t    if (oldWidget) {\n\t        oldWidget.destroy();\n\t    } else {\n\t        row -= dir;\n\t    }\n\t    var annotations = findAnnotations(session, row, dir);\n\t    var gutterAnno;\n\t    if (annotations) {\n\t        var annotation = annotations[0];\n\t        pos.column = (annotation.pos && typeof annotation.column != \"number\"\n\t            ? annotation.pos.sc\n\t            : annotation.column) || 0;\n\t        pos.row = annotation.row;\n\t        gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];\n\t    } else if (oldWidget) {\n\t        return;\n\t    } else {\n\t        gutterAnno = {\n\t            text: [\"Looks good!\"],\n\t            className: \"ace_ok\"\n\t        };\n\t    }\n\t    editor.session.unfold(pos.row);\n\t    editor.selection.moveToPosition(pos);\n\t    \n\t    var w = {\n\t        row: pos.row, \n\t        fixedWidth: true,\n\t        coverGutter: true,\n\t        el: dom.createElement(\"div\")\n\t    };\n\t    var el = w.el.appendChild(dom.createElement(\"div\"));\n\t    var arrow = w.el.appendChild(dom.createElement(\"div\"));\n\t    arrow.className = \"error_widget_arrow \" + gutterAnno.className;\n\t    \n\t    var left = editor.renderer.$cursorLayer\n\t        .getPixelPosition(pos).left;\n\t    arrow.style.left = left + editor.renderer.gutterWidth - 5 + \"px\";\n\t    \n\t    w.el.className = \"error_widget_wrapper\";\n\t    el.className = \"error_widget \" + gutterAnno.className;\n\t    el.innerHTML = gutterAnno.text.join(\"<br>\");\n\t    \n\t    el.appendChild(dom.createElement(\"div\"));\n\t    \n\t    var kb = function(_, hashId, keyString) {\n\t        if (hashId === 0 && (keyString === \"esc\" || keyString === \"return\")) {\n\t            w.destroy();\n\t            return {command: \"null\"};\n\t        }\n\t    };\n\t    \n\t    w.destroy = function() {\n\t        if (editor.$mouseHandler.isMousePressed)\n\t            return;\n\t        editor.keyBinding.removeKeyboardHandler(kb);\n\t        session.widgetManager.removeLineWidget(w);\n\t        editor.off(\"changeSelection\", w.destroy);\n\t        editor.off(\"changeSession\", w.destroy);\n\t        editor.off(\"mouseup\", w.destroy);\n\t        editor.off(\"change\", w.destroy);\n\t    };\n\t    \n\t    editor.keyBinding.addKeyboardHandler(kb);\n\t    editor.on(\"changeSelection\", w.destroy);\n\t    editor.on(\"changeSession\", w.destroy);\n\t    editor.on(\"mouseup\", w.destroy);\n\t    editor.on(\"change\", w.destroy);\n\t    \n\t    editor.session.widgetManager.addLineWidget(w);\n\t    \n\t    w.el.onmousedown = editor.focus.bind(editor);\n\t    \n\t    editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});\n\t};\n\n\n\tdom.importCssString(\"\\\n\t    .error_widget_wrapper {\\\n\t        background: inherit;\\\n\t        color: inherit;\\\n\t        border:none\\\n\t    }\\\n\t    .error_widget {\\\n\t        border-top: solid 2px;\\\n\t        border-bottom: solid 2px;\\\n\t        margin: 5px 0;\\\n\t        padding: 10px 40px;\\\n\t        white-space: pre-wrap;\\\n\t    }\\\n\t    .error_widget.ace_error, .error_widget_arrow.ace_error{\\\n\t        border-color: #ff5a5a\\\n\t    }\\\n\t    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\\\n\t        border-color: #F1D817\\\n\t    }\\\n\t    .error_widget.ace_info, .error_widget_arrow.ace_info{\\\n\t        border-color: #5a5a5a\\\n\t    }\\\n\t    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\\\n\t        border-color: #5aaa5a\\\n\t    }\\\n\t    .error_widget_arrow {\\\n\t        position: absolute;\\\n\t        border: solid 5px;\\\n\t        border-top-color: transparent!important;\\\n\t        border-right-color: transparent!important;\\\n\t        border-left-color: transparent!important;\\\n\t        top: -5px;\\\n\t    }\\\n\t\", \"\");\n\n\t});\n\n\tace.define(\"ace/ace\",[\"require\",\"exports\",\"module\",\"ace/lib/fixoldbrowsers\",\"ace/lib/dom\",\"ace/lib/event\",\"ace/editor\",\"ace/edit_session\",\"ace/undomanager\",\"ace/virtual_renderer\",\"ace/worker/worker_client\",\"ace/keyboard/hash_handler\",\"ace/placeholder\",\"ace/multi_select\",\"ace/mode/folding/fold_mode\",\"ace/theme/textmate\",\"ace/ext/error_marker\",\"ace/config\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tacequire(\"./lib/fixoldbrowsers\");\n\n\tvar dom = acequire(\"./lib/dom\");\n\tvar event = acequire(\"./lib/event\");\n\n\tvar Editor = acequire(\"./editor\").Editor;\n\tvar EditSession = acequire(\"./edit_session\").EditSession;\n\tvar UndoManager = acequire(\"./undomanager\").UndoManager;\n\tvar Renderer = acequire(\"./virtual_renderer\").VirtualRenderer;\n\tacequire(\"./worker/worker_client\");\n\tacequire(\"./keyboard/hash_handler\");\n\tacequire(\"./placeholder\");\n\tacequire(\"./multi_select\");\n\tacequire(\"./mode/folding/fold_mode\");\n\tacequire(\"./theme/textmate\");\n\tacequire(\"./ext/error_marker\");\n\n\texports.config = acequire(\"./config\");\n\texports.acequire = acequire;\n\texports.edit = function(el) {\n\t    if (typeof(el) == \"string\") {\n\t        var _id = el;\n\t        el = document.getElementById(_id);\n\t        if (!el)\n\t            throw new Error(\"ace.edit can't find div #\" + _id);\n\t    }\n\n\t    if (el && el.env && el.env.editor instanceof Editor)\n\t        return el.env.editor;\n\n\t    var value = \"\";\n\t    if (el && /input|textarea/i.test(el.tagName)) {\n\t        var oldNode = el;\n\t        value = oldNode.value;\n\t        el = dom.createElement(\"pre\");\n\t        oldNode.parentNode.replaceChild(el, oldNode);\n\t    } else {\n\t        value = dom.getInnerText(el);\n\t        el.innerHTML = '';\n\t    }\n\n\t    var doc = exports.createEditSession(value);\n\n\t    var editor = new Editor(new Renderer(el));\n\t    editor.setSession(doc);\n\n\t    var env = {\n\t        document: doc,\n\t        editor: editor,\n\t        onResize: editor.resize.bind(editor, null)\n\t    };\n\t    if (oldNode) env.textarea = oldNode;\n\t    event.addListener(window, \"resize\", env.onResize);\n\t    editor.on(\"destroy\", function() {\n\t        event.removeListener(window, \"resize\", env.onResize);\n\t        env.editor.container.env = null; // prevent memory leak on old ie\n\t    });\n\t    editor.container.env = editor.env = env;\n\t    return editor;\n\t};\n\texports.createEditSession = function(text, mode) {\n\t    var doc = new EditSession(text, mode);\n\t    doc.setUndoManager(new UndoManager());\n\t    return doc;\n\t}\n\texports.EditSession = EditSession;\n\texports.UndoManager = UndoManager;\n\t});\n\t            (function() {\n\t                ace.acequire([\"ace/ace\"], function(a) {\n\t                    a && a.config.init(true);\n\t                    if (!window.ace)\n\t                        window.ace = a;\n\t                    for (var key in a) if (a.hasOwnProperty(key))\n\t                        window.ace[key] = a[key];\n\t                });\n\t            })();\n\t        \n\tmodule.exports = window.ace.acequire(\"ace/ace\");\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tace.define(\"ace/mode/json_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../lib/oop\");\n\tvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\n\tvar JsonHighlightRules = function() {\n\t    this.$rules = {\n\t        \"start\" : [\n\t            {\n\t                token : \"variable\", // single line\n\t                regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]\\\\s*(?=:)'\n\t            }, {\n\t                token : \"string\", // single line\n\t                regex : '\"',\n\t                next  : \"string\"\n\t            }, {\n\t                token : \"constant.numeric\", // hex\n\t                regex : \"0[xX][0-9a-fA-F]+\\\\b\"\n\t            }, {\n\t                token : \"constant.numeric\", // float\n\t                regex : \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\"\n\t            }, {\n\t                token : \"constant.language.boolean\",\n\t                regex : \"(?:true|false)\\\\b\"\n\t            }, {\n\t                token : \"invalid.illegal\", // single quoted strings are not allowed\n\t                regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n\t            }, {\n\t                token : \"invalid.illegal\", // comments are not allowed\n\t                regex : \"\\\\/\\\\/.*$\"\n\t            }, {\n\t                token : \"paren.lparen\",\n\t                regex : \"[[({]\"\n\t            }, {\n\t                token : \"paren.rparen\",\n\t                regex : \"[\\\\])}]\"\n\t            }, {\n\t                token : \"text\",\n\t                regex : \"\\\\s+\"\n\t            }\n\t        ],\n\t        \"string\" : [\n\t            {\n\t                token : \"constant.language.escape\",\n\t                regex : /\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|[\"\\\\\\/bfnrt])/\n\t            }, {\n\t                token : \"string\",\n\t                regex : '[^\"\\\\\\\\]+'\n\t            }, {\n\t                token : \"string\",\n\t                regex : '\"',\n\t                next  : \"start\"\n\t            }, {\n\t                token : \"string\",\n\t                regex : \"\",\n\t                next  : \"start\"\n\t            }\n\t        ]\n\t    };\n\t    \n\t};\n\n\toop.inherits(JsonHighlightRules, TextHighlightRules);\n\n\texports.JsonHighlightRules = JsonHighlightRules;\n\t});\n\n\tace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar Range = acequire(\"../range\").Range;\n\n\tvar MatchingBraceOutdent = function() {};\n\n\t(function() {\n\n\t    this.checkOutdent = function(line, input) {\n\t        if (! /^\\s+$/.test(line))\n\t            return false;\n\n\t        return /^\\s*\\}/.test(input);\n\t    };\n\n\t    this.autoOutdent = function(doc, row) {\n\t        var line = doc.getLine(row);\n\t        var match = line.match(/^(\\s*\\})/);\n\n\t        if (!match) return 0;\n\n\t        var column = match[1].length;\n\t        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n\t        if (!openBracePos || openBracePos.row == row) return 0;\n\n\t        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n\t        doc.replace(new Range(row, 0, row, column-1), indent);\n\t    };\n\n\t    this.$getIndent = function(line) {\n\t        return line.match(/^\\s*/)[0];\n\t    };\n\n\t}).call(MatchingBraceOutdent.prototype);\n\n\texports.MatchingBraceOutdent = MatchingBraceOutdent;\n\t});\n\n\tace.define(\"ace/mode/behaviour/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/behaviour\",\"ace/token_iterator\",\"ace/lib/lang\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../../lib/oop\");\n\tvar Behaviour = acequire(\"../behaviour\").Behaviour;\n\tvar TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\n\tvar lang = acequire(\"../../lib/lang\");\n\n\tvar SAFE_INSERT_IN_TOKENS =\n\t    [\"text\", \"paren.rparen\", \"punctuation.operator\"];\n\tvar SAFE_INSERT_BEFORE_TOKENS =\n\t    [\"text\", \"paren.rparen\", \"punctuation.operator\", \"comment\"];\n\n\tvar context;\n\tvar contextCache = {};\n\tvar initContext = function(editor) {\n\t    var id = -1;\n\t    if (editor.multiSelect) {\n\t        id = editor.selection.index;\n\t        if (contextCache.rangeCount != editor.multiSelect.rangeCount)\n\t            contextCache = {rangeCount: editor.multiSelect.rangeCount};\n\t    }\n\t    if (contextCache[id])\n\t        return context = contextCache[id];\n\t    context = contextCache[id] = {\n\t        autoInsertedBrackets: 0,\n\t        autoInsertedRow: -1,\n\t        autoInsertedLineEnd: \"\",\n\t        maybeInsertedBrackets: 0,\n\t        maybeInsertedRow: -1,\n\t        maybeInsertedLineStart: \"\",\n\t        maybeInsertedLineEnd: \"\"\n\t    };\n\t};\n\n\tvar CstyleBehaviour = function() {\n\t    this.add(\"braces\", \"insertion\", function(state, action, editor, session, text) {\n\t        var cursor = editor.getCursorPosition();\n\t        var line = session.doc.getLine(cursor.row);\n\t        if (text == '{') {\n\t            initContext(editor);\n\t            var selection = editor.getSelectionRange();\n\t            var selected = session.doc.getTextRange(selection);\n\t            if (selected !== \"\" && selected !== \"{\" && editor.getWrapBehavioursEnabled()) {\n\t                return {\n\t                    text: '{' + selected + '}',\n\t                    selection: false\n\t                };\n\t            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n\t                if (/[\\]\\}\\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {\n\t                    CstyleBehaviour.recordAutoInsert(editor, session, \"}\");\n\t                    return {\n\t                        text: '{}',\n\t                        selection: [1, 1]\n\t                    };\n\t                } else {\n\t                    CstyleBehaviour.recordMaybeInsert(editor, session, \"{\");\n\t                    return {\n\t                        text: '{',\n\t                        selection: [1, 1]\n\t                    };\n\t                }\n\t            }\n\t        } else if (text == '}') {\n\t            initContext(editor);\n\t            var rightChar = line.substring(cursor.column, cursor.column + 1);\n\t            if (rightChar == '}') {\n\t                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});\n\t                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n\t                    CstyleBehaviour.popAutoInsertedClosing();\n\t                    return {\n\t                        text: '',\n\t                        selection: [1, 1]\n\t                    };\n\t                }\n\t            }\n\t        } else if (text == \"\\n\" || text == \"\\r\\n\") {\n\t            initContext(editor);\n\t            var closing = \"\";\n\t            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {\n\t                closing = lang.stringRepeat(\"}\", context.maybeInsertedBrackets);\n\t                CstyleBehaviour.clearMaybeInsertedClosing();\n\t            }\n\t            var rightChar = line.substring(cursor.column, cursor.column + 1);\n\t            if (rightChar === '}') {\n\t                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');\n\t                if (!openBracePos)\n\t                     return null;\n\t                var next_indent = this.$getIndent(session.getLine(openBracePos.row));\n\t            } else if (closing) {\n\t                var next_indent = this.$getIndent(line);\n\t            } else {\n\t                CstyleBehaviour.clearMaybeInsertedClosing();\n\t                return;\n\t            }\n\t            var indent = next_indent + session.getTabString();\n\n\t            return {\n\t                text: '\\n' + indent + '\\n' + next_indent + closing,\n\t                selection: [1, indent.length, 1, indent.length]\n\t            };\n\t        } else {\n\t            CstyleBehaviour.clearMaybeInsertedClosing();\n\t        }\n\t    });\n\n\t    this.add(\"braces\", \"deletion\", function(state, action, editor, session, range) {\n\t        var selected = session.doc.getTextRange(range);\n\t        if (!range.isMultiLine() && selected == '{') {\n\t            initContext(editor);\n\t            var line = session.doc.getLine(range.start.row);\n\t            var rightChar = line.substring(range.end.column, range.end.column + 1);\n\t            if (rightChar == '}') {\n\t                range.end.column++;\n\t                return range;\n\t            } else {\n\t                context.maybeInsertedBrackets--;\n\t            }\n\t        }\n\t    });\n\n\t    this.add(\"parens\", \"insertion\", function(state, action, editor, session, text) {\n\t        if (text == '(') {\n\t            initContext(editor);\n\t            var selection = editor.getSelectionRange();\n\t            var selected = session.doc.getTextRange(selection);\n\t            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n\t                return {\n\t                    text: '(' + selected + ')',\n\t                    selection: false\n\t                };\n\t            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n\t                CstyleBehaviour.recordAutoInsert(editor, session, \")\");\n\t                return {\n\t                    text: '()',\n\t                    selection: [1, 1]\n\t                };\n\t            }\n\t        } else if (text == ')') {\n\t            initContext(editor);\n\t            var cursor = editor.getCursorPosition();\n\t            var line = session.doc.getLine(cursor.row);\n\t            var rightChar = line.substring(cursor.column, cursor.column + 1);\n\t            if (rightChar == ')') {\n\t                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});\n\t                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n\t                    CstyleBehaviour.popAutoInsertedClosing();\n\t                    return {\n\t                        text: '',\n\t                        selection: [1, 1]\n\t                    };\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    this.add(\"parens\", \"deletion\", function(state, action, editor, session, range) {\n\t        var selected = session.doc.getTextRange(range);\n\t        if (!range.isMultiLine() && selected == '(') {\n\t            initContext(editor);\n\t            var line = session.doc.getLine(range.start.row);\n\t            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n\t            if (rightChar == ')') {\n\t                range.end.column++;\n\t                return range;\n\t            }\n\t        }\n\t    });\n\n\t    this.add(\"brackets\", \"insertion\", function(state, action, editor, session, text) {\n\t        if (text == '[') {\n\t            initContext(editor);\n\t            var selection = editor.getSelectionRange();\n\t            var selected = session.doc.getTextRange(selection);\n\t            if (selected !== \"\" && editor.getWrapBehavioursEnabled()) {\n\t                return {\n\t                    text: '[' + selected + ']',\n\t                    selection: false\n\t                };\n\t            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {\n\t                CstyleBehaviour.recordAutoInsert(editor, session, \"]\");\n\t                return {\n\t                    text: '[]',\n\t                    selection: [1, 1]\n\t                };\n\t            }\n\t        } else if (text == ']') {\n\t            initContext(editor);\n\t            var cursor = editor.getCursorPosition();\n\t            var line = session.doc.getLine(cursor.row);\n\t            var rightChar = line.substring(cursor.column, cursor.column + 1);\n\t            if (rightChar == ']') {\n\t                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});\n\t                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {\n\t                    CstyleBehaviour.popAutoInsertedClosing();\n\t                    return {\n\t                        text: '',\n\t                        selection: [1, 1]\n\t                    };\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    this.add(\"brackets\", \"deletion\", function(state, action, editor, session, range) {\n\t        var selected = session.doc.getTextRange(range);\n\t        if (!range.isMultiLine() && selected == '[') {\n\t            initContext(editor);\n\t            var line = session.doc.getLine(range.start.row);\n\t            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n\t            if (rightChar == ']') {\n\t                range.end.column++;\n\t                return range;\n\t            }\n\t        }\n\t    });\n\n\t    this.add(\"string_dquotes\", \"insertion\", function(state, action, editor, session, text) {\n\t        if (text == '\"' || text == \"'\") {\n\t            initContext(editor);\n\t            var quote = text;\n\t            var selection = editor.getSelectionRange();\n\t            var selected = session.doc.getTextRange(selection);\n\t            if (selected !== \"\" && selected !== \"'\" && selected != '\"' && editor.getWrapBehavioursEnabled()) {\n\t                return {\n\t                    text: quote + selected + quote,\n\t                    selection: false\n\t                };\n\t            } else {\n\t                var cursor = editor.getCursorPosition();\n\t                var line = session.doc.getLine(cursor.row);\n\t                var leftChar = line.substring(cursor.column-1, cursor.column);\n\t                if (leftChar == '\\\\') {\n\t                    return null;\n\t                }\n\t                var tokens = session.getTokens(selection.start.row);\n\t                var col = 0, token;\n\t                var quotepos = -1; // Track whether we're inside an open quote.\n\n\t                for (var x = 0; x < tokens.length; x++) {\n\t                    token = tokens[x];\n\t                    if (token.type == \"string\") {\n\t                      quotepos = -1;\n\t                    } else if (quotepos < 0) {\n\t                      quotepos = token.value.indexOf(quote);\n\t                    }\n\t                    if ((token.value.length + col) > selection.start.column) {\n\t                        break;\n\t                    }\n\t                    col += tokens[x].value.length;\n\t                }\n\t                if (!token || (quotepos < 0 && token.type !== \"comment\" && (token.type !== \"string\" || ((selection.start.column !== token.value.length+col-1) && token.value.lastIndexOf(quote) === token.value.length-1)))) {\n\t                    if (!CstyleBehaviour.isSaneInsertion(editor, session))\n\t                        return;\n\t                    return {\n\t                        text: quote + quote,\n\t                        selection: [1,1]\n\t                    };\n\t                } else if (token && token.type === \"string\") {\n\t                    var rightChar = line.substring(cursor.column, cursor.column + 1);\n\t                    if (rightChar == quote) {\n\t                        return {\n\t                            text: '',\n\t                            selection: [1, 1]\n\t                        };\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\n\t        var selected = session.doc.getTextRange(range);\n\t        if (!range.isMultiLine() && (selected == '\"' || selected == \"'\")) {\n\t            initContext(editor);\n\t            var line = session.doc.getLine(range.start.row);\n\t            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\n\t            if (rightChar == selected) {\n\t                range.end.column++;\n\t                return range;\n\t            }\n\t        }\n\t    });\n\n\t};\n\n\t    \n\tCstyleBehaviour.isSaneInsertion = function(editor, session) {\n\t    var cursor = editor.getCursorPosition();\n\t    var iterator = new TokenIterator(session, cursor.row, cursor.column);\n\t    if (!this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS)) {\n\t        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);\n\t        if (!this.$matchTokenType(iterator2.getCurrentToken() || \"text\", SAFE_INSERT_IN_TOKENS))\n\t            return false;\n\t    }\n\t    iterator.stepForward();\n\t    return iterator.getCurrentTokenRow() !== cursor.row ||\n\t        this.$matchTokenType(iterator.getCurrentToken() || \"text\", SAFE_INSERT_BEFORE_TOKENS);\n\t};\n\n\tCstyleBehaviour.$matchTokenType = function(token, types) {\n\t    return types.indexOf(token.type || token) > -1;\n\t};\n\n\tCstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {\n\t    var cursor = editor.getCursorPosition();\n\t    var line = session.doc.getLine(cursor.row);\n\t    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))\n\t        context.autoInsertedBrackets = 0;\n\t    context.autoInsertedRow = cursor.row;\n\t    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);\n\t    context.autoInsertedBrackets++;\n\t};\n\n\tCstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {\n\t    var cursor = editor.getCursorPosition();\n\t    var line = session.doc.getLine(cursor.row);\n\t    if (!this.isMaybeInsertedClosing(cursor, line))\n\t        context.maybeInsertedBrackets = 0;\n\t    context.maybeInsertedRow = cursor.row;\n\t    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;\n\t    context.maybeInsertedLineEnd = line.substr(cursor.column);\n\t    context.maybeInsertedBrackets++;\n\t};\n\n\tCstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {\n\t    return context.autoInsertedBrackets > 0 &&\n\t        cursor.row === context.autoInsertedRow &&\n\t        bracket === context.autoInsertedLineEnd[0] &&\n\t        line.substr(cursor.column) === context.autoInsertedLineEnd;\n\t};\n\n\tCstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {\n\t    return context.maybeInsertedBrackets > 0 &&\n\t        cursor.row === context.maybeInsertedRow &&\n\t        line.substr(cursor.column) === context.maybeInsertedLineEnd &&\n\t        line.substr(0, cursor.column) == context.maybeInsertedLineStart;\n\t};\n\n\tCstyleBehaviour.popAutoInsertedClosing = function() {\n\t    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);\n\t    context.autoInsertedBrackets--;\n\t};\n\n\tCstyleBehaviour.clearMaybeInsertedClosing = function() {\n\t    if (context) {\n\t        context.maybeInsertedBrackets = 0;\n\t        context.maybeInsertedRow = -1;\n\t    }\n\t};\n\n\n\n\toop.inherits(CstyleBehaviour, Behaviour);\n\n\texports.CstyleBehaviour = CstyleBehaviour;\n\t});\n\n\tace.define(\"ace/mode/folding/cstyle\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/range\",\"ace/mode/folding/fold_mode\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../../lib/oop\");\n\tvar Range = acequire(\"../../range\").Range;\n\tvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\n\n\tvar FoldMode = exports.FoldMode = function(commentRegex) {\n\t    if (commentRegex) {\n\t        this.foldingStartMarker = new RegExp(\n\t            this.foldingStartMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.start)\n\t        );\n\t        this.foldingStopMarker = new RegExp(\n\t            this.foldingStopMarker.source.replace(/\\|[^|]*?$/, \"|\" + commentRegex.end)\n\t        );\n\t    }\n\t};\n\toop.inherits(FoldMode, BaseFoldMode);\n\n\t(function() {\n\n\t    this.foldingStartMarker = /(\\{|\\[)[^\\}\\]]*$|^\\s*(\\/\\*)/;\n\t    this.foldingStopMarker = /^[^\\[\\{]*(\\}|\\])|^[\\s\\*]*(\\*\\/)/;\n\n\t    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {\n\t        var line = session.getLine(row);\n\t        var match = line.match(this.foldingStartMarker);\n\t        if (match) {\n\t            var i = match.index;\n\n\t            if (match[1])\n\t                return this.openingBracketBlock(session, match[1], row, i);\n\t                \n\t            var range = session.getCommentFoldRange(row, i + match[0].length, 1);\n\t            \n\t            if (range && !range.isMultiLine()) {\n\t                if (forceMultiline) {\n\t                    range = this.getSectionRange(session, row);\n\t                } else if (foldStyle != \"all\")\n\t                    range = null;\n\t            }\n\t            \n\t            return range;\n\t        }\n\n\t        if (foldStyle === \"markbegin\")\n\t            return;\n\n\t        var match = line.match(this.foldingStopMarker);\n\t        if (match) {\n\t            var i = match.index + match[0].length;\n\n\t            if (match[1])\n\t                return this.closingBracketBlock(session, match[1], row, i);\n\n\t            return session.getCommentFoldRange(row, i, -1);\n\t        }\n\t    };\n\t    \n\t    this.getSectionRange = function(session, row) {\n\t        var line = session.getLine(row);\n\t        var startIndent = line.search(/\\S/);\n\t        var startRow = row;\n\t        var startColumn = line.length;\n\t        row = row + 1;\n\t        var endRow = row;\n\t        var maxRow = session.getLength();\n\t        while (++row < maxRow) {\n\t            line = session.getLine(row);\n\t            var indent = line.search(/\\S/);\n\t            if (indent === -1)\n\t                continue;\n\t            if  (startIndent > indent)\n\t                break;\n\t            var subRange = this.getFoldWidgetRange(session, \"all\", row);\n\t            \n\t            if (subRange) {\n\t                if (subRange.start.row <= startRow) {\n\t                    break;\n\t                } else if (subRange.isMultiLine()) {\n\t                    row = subRange.end.row;\n\t                } else if (startIndent == indent) {\n\t                    break;\n\t                }\n\t            }\n\t            endRow = row;\n\t        }\n\t        \n\t        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);\n\t    };\n\n\t}).call(FoldMode.prototype);\n\n\t});\n\n\tace.define(\"ace/mode/json\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/json_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/cstyle\",\"ace/worker/worker_client\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar oop = acequire(\"../lib/oop\");\n\tvar TextMode = acequire(\"./text\").Mode;\n\tvar HighlightRules = acequire(\"./json_highlight_rules\").JsonHighlightRules;\n\tvar MatchingBraceOutdent = acequire(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\tvar CstyleBehaviour = acequire(\"./behaviour/cstyle\").CstyleBehaviour;\n\tvar CStyleFoldMode = acequire(\"./folding/cstyle\").FoldMode;\n\tvar WorkerClient = acequire(\"../worker/worker_client\").WorkerClient;\n\n\tvar Mode = function() {\n\t    this.HighlightRules = HighlightRules;\n\t    this.$outdent = new MatchingBraceOutdent();\n\t    this.$behaviour = new CstyleBehaviour();\n\t    this.foldingRules = new CStyleFoldMode();\n\t};\n\toop.inherits(Mode, TextMode);\n\n\t(function() {\n\n\t    this.getNextLineIndent = function(state, line, tab) {\n\t        var indent = this.$getIndent(line);\n\n\t        if (state == \"start\") {\n\t            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n\t            if (match) {\n\t                indent += tab;\n\t            }\n\t        }\n\n\t        return indent;\n\t    };\n\n\t    this.checkOutdent = function(state, line, input) {\n\t        return this.$outdent.checkOutdent(line, input);\n\t    };\n\n\t    this.autoOutdent = function(state, doc, row) {\n\t        this.$outdent.autoOutdent(doc, row);\n\t    };\n\n\t    this.createWorker = function(session) {\n\t        var worker = new WorkerClient([\"ace\"], __webpack_require__(17), \"JsonWorker\");\n\t        worker.attachToDocument(session.getDocument());\n\n\t        worker.on(\"error\", function(e) {\n\t            session.setAnnotations([e.data]);\n\t        });\n\n\t        worker.on(\"ok\", function() {\n\t            session.clearAnnotations();\n\t        });\n\n\t        return worker;\n\t    };\n\n\n\t    this.$id = \"ace/mode/json\";\n\t}).call(Mode.prototype);\n\n\texports.Mode = Mode;\n\t});\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tace.define(\"ace/ext/searchbox\",[\"require\",\"exports\",\"module\",\"ace/lib/dom\",\"ace/lib/lang\",\"ace/lib/event\",\"ace/keyboard/hash_handler\",\"ace/lib/keys\"], function(acequire, exports, module) {\n\t\"use strict\";\n\n\tvar dom = acequire(\"../lib/dom\");\n\tvar lang = acequire(\"../lib/lang\");\n\tvar event = acequire(\"../lib/event\");\n\tvar searchboxCss = \"\\\n\t.ace_search {\\\n\tbackground-color: #ddd;\\\n\tborder: 1px solid #cbcbcb;\\\n\tborder-top: 0 none;\\\n\tmax-width: 325px;\\\n\toverflow: hidden;\\\n\tmargin: 0;\\\n\tpadding: 4px;\\\n\tpadding-right: 6px;\\\n\tpadding-bottom: 0;\\\n\tposition: absolute;\\\n\ttop: 0px;\\\n\tz-index: 99;\\\n\twhite-space: normal;\\\n\t}\\\n\t.ace_search.left {\\\n\tborder-left: 0 none;\\\n\tborder-radius: 0px 0px 5px 0px;\\\n\tleft: 0;\\\n\t}\\\n\t.ace_search.right {\\\n\tborder-radius: 0px 0px 0px 5px;\\\n\tborder-right: 0 none;\\\n\tright: 0;\\\n\t}\\\n\t.ace_search_form, .ace_replace_form {\\\n\tborder-radius: 3px;\\\n\tborder: 1px solid #cbcbcb;\\\n\tfloat: left;\\\n\tmargin-bottom: 4px;\\\n\toverflow: hidden;\\\n\t}\\\n\t.ace_search_form.ace_nomatch {\\\n\toutline: 1px solid red;\\\n\t}\\\n\t.ace_search_field {\\\n\tbackground-color: white;\\\n\tborder-right: 1px solid #cbcbcb;\\\n\tborder: 0 none;\\\n\t-webkit-box-sizing: border-box;\\\n\t-moz-box-sizing: border-box;\\\n\tbox-sizing: border-box;\\\n\tfloat: left;\\\n\theight: 22px;\\\n\toutline: 0;\\\n\tpadding: 0 7px;\\\n\twidth: 214px;\\\n\tmargin: 0;\\\n\t}\\\n\t.ace_searchbtn,\\\n\t.ace_replacebtn {\\\n\tbackground: #fff;\\\n\tborder: 0 none;\\\n\tborder-left: 1px solid #dcdcdc;\\\n\tcursor: pointer;\\\n\tfloat: left;\\\n\theight: 22px;\\\n\tmargin: 0;\\\n\tpadding: 0;\\\n\tposition: relative;\\\n\t}\\\n\t.ace_searchbtn:last-child,\\\n\t.ace_replacebtn:last-child {\\\n\tborder-top-right-radius: 3px;\\\n\tborder-bottom-right-radius: 3px;\\\n\t}\\\n\t.ace_searchbtn:disabled {\\\n\tbackground: none;\\\n\tcursor: default;\\\n\t}\\\n\t.ace_searchbtn {\\\n\tbackground-position: 50% 50%;\\\n\tbackground-repeat: no-repeat;\\\n\twidth: 27px;\\\n\t}\\\n\t.ace_searchbtn.prev {\\\n\tbackground-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADFJREFUeNpiSU1NZUAC/6E0I0yACYskCpsJiySKIiY0SUZk40FyTEgCjGgKwTRAgAEAQJUIPCE+qfkAAAAASUVORK5CYII=);    \\\n\t}\\\n\t.ace_searchbtn.next {\\\n\tbackground-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAYAAAB4ka1VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADRJREFUeNpiTE1NZQCC/0DMyIAKwGJMUAYDEo3M/s+EpvM/mkKwCQxYjIeLMaELoLMBAgwAU7UJObTKsvAAAAAASUVORK5CYII=);    \\\n\t}\\\n\t.ace_searchbtn_close {\\\n\tbackground: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAcCAYAAABRVo5BAAAAZ0lEQVR42u2SUQrAMAhDvazn8OjZBilCkYVVxiis8H4CT0VrAJb4WHT3C5xU2a2IQZXJjiQIRMdkEoJ5Q2yMqpfDIo+XY4k6h+YXOyKqTIj5REaxloNAd0xiKmAtsTHqW8sR2W5f7gCu5nWFUpVjZwAAAABJRU5ErkJggg==) no-repeat 50% 0;\\\n\tborder-radius: 50%;\\\n\tborder: 0 none;\\\n\tcolor: #656565;\\\n\tcursor: pointer;\\\n\tfloat: right;\\\n\tfont: 16px/16px Arial;\\\n\theight: 14px;\\\n\tmargin: 5px 1px 9px 5px;\\\n\tpadding: 0;\\\n\ttext-align: center;\\\n\twidth: 14px;\\\n\t}\\\n\t.ace_searchbtn_close:hover {\\\n\tbackground-color: #656565;\\\n\tbackground-position: 50% 100%;\\\n\tcolor: white;\\\n\t}\\\n\t.ace_replacebtn.prev {\\\n\twidth: 54px\\\n\t}\\\n\t.ace_replacebtn.next {\\\n\twidth: 27px\\\n\t}\\\n\t.ace_button {\\\n\tmargin-left: 2px;\\\n\tcursor: pointer;\\\n\t-webkit-user-select: none;\\\n\t-moz-user-select: none;\\\n\t-o-user-select: none;\\\n\t-ms-user-select: none;\\\n\tuser-select: none;\\\n\toverflow: hidden;\\\n\topacity: 0.7;\\\n\tborder: 1px solid rgba(100,100,100,0.23);\\\n\tpadding: 1px;\\\n\t-moz-box-sizing: border-box;\\\n\tbox-sizing:    border-box;\\\n\tcolor: black;\\\n\t}\\\n\t.ace_button:hover {\\\n\tbackground-color: #eee;\\\n\topacity:1;\\\n\t}\\\n\t.ace_button:active {\\\n\tbackground-color: #ddd;\\\n\t}\\\n\t.ace_button.checked {\\\n\tborder-color: #3399ff;\\\n\topacity:1;\\\n\t}\\\n\t.ace_search_options{\\\n\tmargin-bottom: 3px;\\\n\ttext-align: right;\\\n\t-webkit-user-select: none;\\\n\t-moz-user-select: none;\\\n\t-o-user-select: none;\\\n\t-ms-user-select: none;\\\n\tuser-select: none;\\\n\t}\";\n\tvar HashHandler = acequire(\"../keyboard/hash_handler\").HashHandler;\n\tvar keyUtil = acequire(\"../lib/keys\");\n\n\tdom.importCssString(searchboxCss, \"ace_searchbox\");\n\n\tvar html = '<div class=\"ace_search right\">\\\n\t    <button type=\"button\" action=\"hide\" class=\"ace_searchbtn_close\"></button>\\\n\t    <div class=\"ace_search_form\">\\\n\t        <input class=\"ace_search_field\" placeholder=\"Search for\" spellcheck=\"false\"></input>\\\n\t        <button type=\"button\" action=\"findNext\" class=\"ace_searchbtn next\"></button>\\\n\t        <button type=\"button\" action=\"findPrev\" class=\"ace_searchbtn prev\"></button>\\\n\t        <button type=\"button\" action=\"findAll\" class=\"ace_searchbtn\" title=\"Alt-Enter\">All</button>\\\n\t    </div>\\\n\t    <div class=\"ace_replace_form\">\\\n\t        <input class=\"ace_search_field\" placeholder=\"Replace with\" spellcheck=\"false\"></input>\\\n\t        <button type=\"button\" action=\"replaceAndFindNext\" class=\"ace_replacebtn\">Replace</button>\\\n\t        <button type=\"button\" action=\"replaceAll\" class=\"ace_replacebtn\">All</button>\\\n\t    </div>\\\n\t    <div class=\"ace_search_options\">\\\n\t        <span action=\"toggleRegexpMode\" class=\"ace_button\" title=\"RegExp Search\">.*</span>\\\n\t        <span action=\"toggleCaseSensitive\" class=\"ace_button\" title=\"CaseSensitive Search\">Aa</span>\\\n\t        <span action=\"toggleWholeWords\" class=\"ace_button\" title=\"Whole Word Search\">\\\\b</span>\\\n\t    </div>\\\n\t</div>'.replace(/>\\s+/g, \">\");\n\n\tvar SearchBox = function(editor, range, showReplaceForm) {\n\t    var div = dom.createElement(\"div\");\n\t    div.innerHTML = html;\n\t    this.element = div.firstChild;\n\n\t    this.$init();\n\t    this.setEditor(editor);\n\t};\n\n\t(function() {\n\t    this.setEditor = function(editor) {\n\t        editor.searchBox = this;\n\t        editor.container.appendChild(this.element);\n\t        this.editor = editor;\n\t    };\n\n\t    this.$initElements = function(sb) {\n\t        this.searchBox = sb.querySelector(\".ace_search_form\");\n\t        this.replaceBox = sb.querySelector(\".ace_replace_form\");\n\t        this.searchOptions = sb.querySelector(\".ace_search_options\");\n\t        this.regExpOption = sb.querySelector(\"[action=toggleRegexpMode]\");\n\t        this.caseSensitiveOption = sb.querySelector(\"[action=toggleCaseSensitive]\");\n\t        this.wholeWordOption = sb.querySelector(\"[action=toggleWholeWords]\");\n\t        this.searchInput = this.searchBox.querySelector(\".ace_search_field\");\n\t        this.replaceInput = this.replaceBox.querySelector(\".ace_search_field\");\n\t    };\n\t    \n\t    this.$init = function() {\n\t        var sb = this.element;\n\t        \n\t        this.$initElements(sb);\n\t        \n\t        var _this = this;\n\t        event.addListener(sb, \"mousedown\", function(e) {\n\t            setTimeout(function(){\n\t                _this.activeInput.focus();\n\t            }, 0);\n\t            event.stopPropagation(e);\n\t        });\n\t        event.addListener(sb, \"click\", function(e) {\n\t            var t = e.target || e.srcElement;\n\t            var action = t.getAttribute(\"action\");\n\t            if (action && _this[action])\n\t                _this[action]();\n\t            else if (_this.$searchBarKb.commands[action])\n\t                _this.$searchBarKb.commands[action].exec(_this);\n\t            event.stopPropagation(e);\n\t        });\n\n\t        event.addCommandKeyListener(sb, function(e, hashId, keyCode) {\n\t            var keyString = keyUtil.keyCodeToString(keyCode);\n\t            var command = _this.$searchBarKb.findKeyCommand(hashId, keyString);\n\t            if (command && command.exec) {\n\t                command.exec(_this);\n\t                event.stopEvent(e);\n\t            }\n\t        });\n\n\t        this.$onChange = lang.delayedCall(function() {\n\t            _this.find(false, false);\n\t        });\n\n\t        event.addListener(this.searchInput, \"input\", function() {\n\t            _this.$onChange.schedule(20);\n\t        });\n\t        event.addListener(this.searchInput, \"focus\", function() {\n\t            _this.activeInput = _this.searchInput;\n\t            _this.searchInput.value && _this.highlight();\n\t        });\n\t        event.addListener(this.replaceInput, \"focus\", function() {\n\t            _this.activeInput = _this.replaceInput;\n\t            _this.searchInput.value && _this.highlight();\n\t        });\n\t    };\n\t    this.$closeSearchBarKb = new HashHandler([{\n\t        bindKey: \"Esc\",\n\t        name: \"closeSearchBar\",\n\t        exec: function(editor) {\n\t            editor.searchBox.hide();\n\t        }\n\t    }]);\n\t    this.$searchBarKb = new HashHandler();\n\t    this.$searchBarKb.bindKeys({\n\t        \"Ctrl-f|Command-f|Ctrl-H|Command-Option-F\": function(sb) {\n\t            var isReplace = sb.isReplace = !sb.isReplace;\n\t            sb.replaceBox.style.display = isReplace ? \"\" : \"none\";\n\t            sb[isReplace ? \"replaceInput\" : \"searchInput\"].focus();\n\t        },\n\t        \"Ctrl-G|Command-G\": function(sb) {\n\t            sb.findNext();\n\t        },\n\t        \"Ctrl-Shift-G|Command-Shift-G\": function(sb) {\n\t            sb.findPrev();\n\t        },\n\t        \"esc\": function(sb) {\n\t            setTimeout(function() { sb.hide();});\n\t        },\n\t        \"Return\": function(sb) {\n\t            if (sb.activeInput == sb.replaceInput)\n\t                sb.replace();\n\t            sb.findNext();\n\t        },\n\t        \"Shift-Return\": function(sb) {\n\t            if (sb.activeInput == sb.replaceInput)\n\t                sb.replace();\n\t            sb.findPrev();\n\t        },\n\t        \"Alt-Return\": function(sb) {\n\t            if (sb.activeInput == sb.replaceInput)\n\t                sb.replaceAll();\n\t            sb.findAll();\n\t        },\n\t        \"Tab\": function(sb) {\n\t            (sb.activeInput == sb.replaceInput ? sb.searchInput : sb.replaceInput).focus();\n\t        }\n\t    });\n\n\t    this.$searchBarKb.addCommands([{\n\t        name: \"toggleRegexpMode\",\n\t        bindKey: {win: \"Alt-R|Alt-/\", mac: \"Ctrl-Alt-R|Ctrl-Alt-/\"},\n\t        exec: function(sb) {\n\t            sb.regExpOption.checked = !sb.regExpOption.checked;\n\t            sb.$syncOptions();\n\t        }\n\t    }, {\n\t        name: \"toggleCaseSensitive\",\n\t        bindKey: {win: \"Alt-C|Alt-I\", mac: \"Ctrl-Alt-R|Ctrl-Alt-I\"},\n\t        exec: function(sb) {\n\t            sb.caseSensitiveOption.checked = !sb.caseSensitiveOption.checked;\n\t            sb.$syncOptions();\n\t        }\n\t    }, {\n\t        name: \"toggleWholeWords\",\n\t        bindKey: {win: \"Alt-B|Alt-W\", mac: \"Ctrl-Alt-B|Ctrl-Alt-W\"},\n\t        exec: function(sb) {\n\t            sb.wholeWordOption.checked = !sb.wholeWordOption.checked;\n\t            sb.$syncOptions();\n\t        }\n\t    }]);\n\n\t    this.$syncOptions = function() {\n\t        dom.setCssClass(this.regExpOption, \"checked\", this.regExpOption.checked);\n\t        dom.setCssClass(this.wholeWordOption, \"checked\", this.wholeWordOption.checked);\n\t        dom.setCssClass(this.caseSensitiveOption, \"checked\", this.caseSensitiveOption.checked);\n\t        this.find(false, false);\n\t    };\n\n\t    this.highlight = function(re) {\n\t        this.editor.session.highlight(re || this.editor.$search.$options.re);\n\t        this.editor.renderer.updateBackMarkers()\n\t    };\n\t    this.find = function(skipCurrent, backwards) {\n\t        var range = this.editor.find(this.searchInput.value, {\n\t            skipCurrent: skipCurrent,\n\t            backwards: backwards,\n\t            wrap: true,\n\t            regExp: this.regExpOption.checked,\n\t            caseSensitive: this.caseSensitiveOption.checked,\n\t            wholeWord: this.wholeWordOption.checked\n\t        });\n\t        var noMatch = !range && this.searchInput.value;\n\t        dom.setCssClass(this.searchBox, \"ace_nomatch\", noMatch);\n\t        this.editor._emit(\"findSearchBox\", { match: !noMatch });\n\t        this.highlight();\n\t    };\n\t    this.findNext = function() {\n\t        this.find(true, false);\n\t    };\n\t    this.findPrev = function() {\n\t        this.find(true, true);\n\t    };\n\t    this.findAll = function(){\n\t        var range = this.editor.findAll(this.searchInput.value, {\n\t            regExp: this.regExpOption.checked,\n\t            caseSensitive: this.caseSensitiveOption.checked,\n\t            wholeWord: this.wholeWordOption.checked\n\t        });\n\t        var noMatch = !range && this.searchInput.value;\n\t        dom.setCssClass(this.searchBox, \"ace_nomatch\", noMatch);\n\t        this.editor._emit(\"findSearchBox\", { match: !noMatch });\n\t        this.highlight();\n\t        this.hide();\n\t    };\n\t    this.replace = function() {\n\t        if (!this.editor.getReadOnly())\n\t            this.editor.replace(this.replaceInput.value);\n\t    };    \n\t    this.replaceAndFindNext = function() {\n\t        if (!this.editor.getReadOnly()) {\n\t            this.editor.replace(this.replaceInput.value);\n\t            this.findNext()\n\t        }\n\t    };\n\t    this.replaceAll = function() {\n\t        if (!this.editor.getReadOnly())\n\t            this.editor.replaceAll(this.replaceInput.value);\n\t    };\n\n\t    this.hide = function() {\n\t        this.element.style.display = \"none\";\n\t        this.editor.keyBinding.removeKeyboardHandler(this.$closeSearchBarKb);\n\t        this.editor.focus();\n\t    };\n\t    this.show = function(value, isReplace) {\n\t        this.element.style.display = \"\";\n\t        this.replaceBox.style.display = isReplace ? \"\" : \"none\";\n\n\t        this.isReplace = isReplace;\n\n\t        if (value)\n\t            this.searchInput.value = value;\n\t        this.searchInput.focus();\n\t        this.searchInput.select();\n\n\t        this.editor.keyBinding.addKeyboardHandler(this.$closeSearchBarKb);\n\t    };\n\n\t    this.isFocused = function() {\n\t        var el = document.activeElement;\n\t        return el == this.searchInput || el == this.replaceInput;\n\t    }\n\t}).call(SearchBox.prototype);\n\n\texports.SearchBox = SearchBox;\n\n\texports.Search = function(editor, isReplace) {\n\t    var sb = editor.searchBox || new SearchBox(editor);\n\t    sb.show(editor.session.getTextRange(), isReplace);\n\t};\n\n\t});\n\t                (function() {\n\t                    ace.acequire([\"ace/ext/searchbox\"], function() {});\n\t                })();\n\t            \n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports.id = 'ace/mode/json_worker';\n\tmodule.exports.src = \"\\\"no use strict\\\";(function(window){if(void 0===window.window||!window.document){window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\\\"log\\\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console,window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\\\"error\\\",data:{message:message,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\\\"!\\\")){var chunks=moduleName.split(\\\"!\\\");return window.normalizeModule(parentId,chunks[0])+\\\"!\\\"+window.normalizeModule(parentId,chunks[1])}if(\\\".\\\"==moduleName.charAt(0)){var base=parentId.split(\\\"/\\\").slice(0,-1).join(\\\"/\\\");for(moduleName=(base?base+\\\"/\\\":\\\"\\\")+moduleName;-1!==moduleName.indexOf(\\\".\\\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\\\.\\\\//,\\\"\\\").replace(/\\\\/\\\\.\\\\//,\\\"/\\\").replace(/[^\\\\/]+\\\\/\\\\.\\\\.\\\\//,\\\"\\\")}}return moduleName},window.acequire=function(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\\\"worker.js acequire() accepts only (parentId, id) as arguments\\\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;var chunks=id.split(\\\"/\\\");if(!window.acequire.tlns)return console.log(\\\"unable to load \\\"+id);chunks[0]=window.acequire.tlns[chunks[0]]||chunks[0];var path=chunks.join(\\\"/\\\")+\\\".js\\\";return window.acequire.id=id,importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\\\"string\\\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\\\"function\\\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\\\"require\\\",\\\"exports\\\",\\\"module\\\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\\\"require\\\":return req;case\\\"exports\\\":return module.exports;case\\\"module\\\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},window.initBaseUrls=function initBaseUrls(topLevelNamespaces){acequire.tlns=topLevelNamespaces},window.initSender=function initSender(){var EventEmitter=window.acequire(\\\"ace/lib/event_emitter\\\").EventEmitter,oop=window.acequire(\\\"ace/lib/oop\\\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\\\"call\\\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\\\"event\\\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.command){if(!main[msg.command])throw Error(\\\"Unknown command:\\\"+msg.command);main[msg.command].apply(main,msg.args)}else if(msg.init){initBaseUrls(msg.tlns),acequire(\\\"ace/lib/es5-shim\\\"),sender=window.sender=initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}else msg.event&&sender&&sender._signal(msg.event,msg.data)}}})(this),ace.define(\\\"ace/lib/oop\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\"],function(acequire,exports){\\\"use strict\\\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\\\"ace/lib/event_emitter\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\"],function(acequire,exports){\\\"use strict\\\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\\\"object\\\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\\\"unshift\\\":\\\"push\\\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\\\"ace/range\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\"],function(acequire,exports){\\\"use strict\\\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\\\"Range: [\\\"+this.start.row+\\\"/\\\"+this.start.column+\\\"] -> [\\\"+this.end.row+\\\"/\\\"+this.end.column+\\\"]\\\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\\\"object\\\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\\\"object\\\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\\\"ace/anchor\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\",\\\"ace/lib/oop\\\",\\\"ace/lib/event_emitter\\\"],function(acequire,exports){\\\"use strict\\\";var oop=acequire(\\\"./lib/oop\\\"),EventEmitter=acequire(\\\"./lib/event_emitter\\\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(e){var delta=e.data,range=delta.range;if(!(range.start.row==range.end.row&&range.start.row!=this.row||range.start.row>this.row||range.start.row==this.row&&range.start.column>this.column)){var row=this.row,column=this.column,start=range.start,end=range.end;\\\"insertText\\\"===delta.action?start.row===row&&column>=start.column?start.column===column&&this.$insertRight||(start.row===end.row?column+=end.column-start.column:(column-=start.column,row+=end.row-start.row)):start.row!==end.row&&row>start.row&&(row+=end.row-start.row):\\\"insertLines\\\"===delta.action?start.row===row&&0===column&&this.$insertRight||row>=start.row&&(row+=end.row-start.row):\\\"removeText\\\"===delta.action?start.row===row&&column>start.column?column=end.column>=column?start.column:Math.max(0,column-(end.column-start.column)):start.row!==end.row&&row>start.row?(end.row===row&&(column=Math.max(0,column-end.column)+start.column),row-=end.row-start.row):end.row===row&&(row-=end.row-start.row,column=Math.max(0,column-end.column)+start.column):\\\"removeLines\\\"==delta.action&&row>=start.row&&(row>=end.row?row-=end.row-start.row:(row=start.row,column=0)),this.setPosition(row,column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\\\"change\\\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\\\"change\\\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\\\"change\\\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\\\"ace/document\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\",\\\"ace/lib/oop\\\",\\\"ace/lib/event_emitter\\\",\\\"ace/range\\\",\\\"ace/anchor\\\"],function(acequire,exports){\\\"use strict\\\";var oop=acequire(\\\"./lib/oop\\\"),EventEmitter=acequire(\\\"./lib/event_emitter\\\").EventEmitter,Range=acequire(\\\"./range\\\").Range,Anchor=acequire(\\\"./anchor\\\").Anchor,Document=function(text){this.$lines=[],0===text.length?this.$lines=[\\\"\\\"]:Array.isArray(text)?this._insertLines(0,text):this.insert({row:0,column:0},text)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength();this.remove(new Range(0,0,len,this.getLine(len-1).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\\\"aaa\\\".split(/a/).length?function(text){return text.replace(/\\\\r\\\\n|\\\\r/g,\\\"\\\\n\\\").split(\\\"\\\\n\\\")}:function(text){return text.split(/\\\\r\\\\n|\\\\r|\\\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\\\r\\\\n|\\\\r|\\\\n)/m);this.$autoNewLine=match?match[1]:\\\"\\\\n\\\",this._signal(\\\"changeNewLineMode\\\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\\\"windows\\\":return\\\"\\\\r\\\\n\\\";case\\\"unix\\\":return\\\"\\\\n\\\";default:return this.$autoNewLine||\\\"\\\\n\\\"}},this.$autoNewLine=\\\"\\\",this.$newLineMode=\\\"auto\\\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\\\"changeNewLineMode\\\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\\\"\\\\r\\\\n\\\"==text||\\\"\\\\r\\\"==text||\\\"\\\\n\\\"==text},this.getLine=function(row){return this.$lines[row]||\\\"\\\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){if(range.start.row==range.end.row)return this.getLine(range.start.row).substring(range.start.column,range.end.column);var lines=this.getLines(range.start.row,range.end.row);lines[0]=(lines[0]||\\\"\\\").substring(range.start.column);var l=lines.length-1;return range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column)),lines.join(this.getNewLineCharacter())},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):0>position.row&&(position.row=0),position},this.insert=function(position,text){if(!text||0===text.length)return position;position=this.$clipPosition(position),1>=this.getLength()&&this.$detectNewLine(text);var lines=this.$split(text),firstLine=lines.splice(0,1)[0],lastLine=0==lines.length?null:lines.splice(lines.length-1,1)[0];return position=this.insertInLine(position,firstLine),null!==lastLine&&(position=this.insertNewLine(position),position=this._insertLines(position.row,lines),position=this.insertInLine(position,lastLine||\\\"\\\")),position},this.insertLines=function(row,lines){return row>=this.getLength()?this.insert({row:row,column:0},\\\"\\\\n\\\"+lines.join(\\\"\\\\n\\\")):this._insertLines(Math.max(row,0),lines)},this._insertLines=function(row,lines){if(0==lines.length)return{row:row,column:0};for(;lines.length>61440;){var end=this._insertLines(row,lines.slice(0,61440));lines=lines.slice(61440),row=end.row}var args=[row,0];args.push.apply(args,lines),this.$lines.splice.apply(this.$lines,args);var range=new Range(row,0,row+lines.length,0),delta={action:\\\"insertLines\\\",range:range,lines:lines};return this._signal(\\\"change\\\",{data:delta}),range.end},this.insertNewLine=function(position){position=this.$clipPosition(position);var line=this.$lines[position.row]||\\\"\\\";this.$lines[position.row]=line.substring(0,position.column),this.$lines.splice(position.row+1,0,line.substring(position.column,line.length));var end={row:position.row+1,column:0},delta={action:\\\"insertText\\\",range:Range.fromPoints(position,end),text:this.getNewLineCharacter()};return this._signal(\\\"change\\\",{data:delta}),end},this.insertInLine=function(position,text){if(0==text.length)return position;var line=this.$lines[position.row]||\\\"\\\";this.$lines[position.row]=line.substring(0,position.column)+text+line.substring(position.column);var end={row:position.row,column:position.column+text.length},delta={action:\\\"insertText\\\",range:Range.fromPoints(position,end),text:text};return this._signal(\\\"change\\\",{data:delta}),end},this.remove=function(range){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),range.start=this.$clipPosition(range.start),range.end=this.$clipPosition(range.end),range.isEmpty())return range.start;var firstRow=range.start.row,lastRow=range.end.row;if(range.isMultiLine()){var firstFullRow=0==range.start.column?firstRow:firstRow+1,lastFullRow=lastRow-1;range.end.column>0&&this.removeInLine(lastRow,0,range.end.column),lastFullRow>=firstFullRow&&this._removeLines(firstFullRow,lastFullRow),firstFullRow!=firstRow&&(this.removeInLine(firstRow,range.start.column,this.getLine(firstRow).length),this.removeNewLine(range.start.row))}else this.removeInLine(firstRow,range.start.column,range.end.column);return range.start},this.removeInLine=function(row,startColumn,endColumn){if(startColumn!=endColumn){var range=new Range(row,startColumn,row,endColumn),line=this.getLine(row),removed=line.substring(startColumn,endColumn),newLine=line.substring(0,startColumn)+line.substring(endColumn,line.length);this.$lines.splice(row,1,newLine);var delta={action:\\\"removeText\\\",range:range,text:removed};return this._signal(\\\"change\\\",{data:delta}),range.start}},this.removeLines=function(firstRow,lastRow){return 0>firstRow||lastRow>=this.getLength()?this.remove(new Range(firstRow,0,lastRow+1,0)):this._removeLines(firstRow,lastRow)},this._removeLines=function(firstRow,lastRow){var range=new Range(firstRow,0,lastRow+1,0),removed=this.$lines.splice(firstRow,lastRow-firstRow+1),delta={action:\\\"removeLines\\\",range:range,nl:this.getNewLineCharacter(),lines:removed};return this._signal(\\\"change\\\",{data:delta}),removed},this.removeNewLine=function(row){var firstLine=this.getLine(row),secondLine=this.getLine(row+1),range=new Range(row,firstLine.length,row+1,0),line=firstLine+secondLine;this.$lines.splice(row,2,line);var delta={action:\\\"removeText\\\",range:range,text:this.getNewLineCharacter()};this._signal(\\\"change\\\",{data:delta})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0==text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;if(this.remove(range),text)var end=this.insert(range.start,text);else end=range.start;return end},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\\\"insertLines\\\"==delta.action?this.insertLines(range.start.row,delta.lines):\\\"insertText\\\"==delta.action?this.insert(range.start,delta.text):\\\"removeLines\\\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\\\"removeText\\\"==delta.action&&this.remove(range)}},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\\\"insertLines\\\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\\\"insertText\\\"==delta.action?this.remove(range):\\\"removeLines\\\"==delta.action?this._insertLines(range.start.row,delta.lines):\\\"removeText\\\"==delta.action&&this.insert(range.start,delta.text)}},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\\\"ace/lib/lang\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\"],function(acequire,exports){\\\"use strict\\\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\\\"\\\").reverse().join(\\\"\\\")},exports.stringRepeat=function(string,count){for(var result=\\\"\\\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\\\s\\\\s*/,trimEndRegexp=/\\\\s\\\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\\\"\\\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\\\"\\\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\\\"object\\\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function(obj){if(\\\"object\\\"!=typeof obj||!obj)return obj;var cons=obj.constructor;if(cons===RegExp)return obj;var copy=cons();for(var key in obj)copy[key]=\\\"object\\\"==typeof obj[key]?exports.deepCopy(obj[key]):obj[key];return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\\\]\\\\/\\\\\\\\])/g,\\\"\\\\\\\\$1\\\")},exports.escapeHTML=function(str){return str.replace(/&/g,\\\"&#38;\\\").replace(/\\\"/g,\\\"&#34;\\\").replace(/'/g,\\\"&#39;\\\").replace(/</g,\\\"&#60;\\\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\\\"ace/worker/mirror\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\",\\\"ace/document\\\",\\\"ace/lib/lang\\\"],function(acequire,exports){\\\"use strict\\\";var Document=acequire(\\\"../document\\\").Document,lang=acequire(\\\"../lib/lang\\\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\\\"\\\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\\\"change\\\",function(e){return doc.applyDeltas(e.data),_self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\\\"ace/mode/json/json_parse\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\"],function(){\\\"use strict\\\";var at,ch,text,value,escapee={'\\\"':'\\\"',\\\"\\\\\\\\\\\":\\\"\\\\\\\\\\\",\\\"/\\\":\\\"/\\\",b:\\\"\\\\b\\\",f:\\\"\\\\f\\\",n:\\\"\\\\n\\\",r:\\\"\\\\r\\\",t:\\\"\\t\\\"},error=function(m){throw{name:\\\"SyntaxError\\\",message:m,at:at,text:text}},next=function(c){return c&&c!==ch&&error(\\\"Expected '\\\"+c+\\\"' instead of '\\\"+ch+\\\"'\\\"),ch=text.charAt(at),at+=1,ch},number=function(){var number,string=\\\"\\\";for(\\\"-\\\"===ch&&(string=\\\"-\\\",next(\\\"-\\\"));ch>=\\\"0\\\"&&\\\"9\\\">=ch;)string+=ch,next();if(\\\".\\\"===ch)for(string+=\\\".\\\";next()&&ch>=\\\"0\\\"&&\\\"9\\\">=ch;)string+=ch;if(\\\"e\\\"===ch||\\\"E\\\"===ch)for(string+=ch,next(),(\\\"-\\\"===ch||\\\"+\\\"===ch)&&(string+=ch,next());ch>=\\\"0\\\"&&\\\"9\\\">=ch;)string+=ch,next();return number=+string,isNaN(number)?(error(\\\"Bad number\\\"),void 0):number},string=function(){var hex,i,uffff,string=\\\"\\\";if('\\\"'===ch)for(;next();){if('\\\"'===ch)return next(),string;if(\\\"\\\\\\\\\\\"===ch)if(next(),\\\"u\\\"===ch){for(uffff=0,i=0;4>i&&(hex=parseInt(next(),16),isFinite(hex));i+=1)uffff=16*uffff+hex;string+=String.fromCharCode(uffff)}else{if(\\\"string\\\"!=typeof escapee[ch])break;string+=escapee[ch]}else string+=ch}error(\\\"Bad string\\\")},white=function(){for(;ch&&\\\" \\\">=ch;)next()},word=function(){switch(ch){case\\\"t\\\":return next(\\\"t\\\"),next(\\\"r\\\"),next(\\\"u\\\"),next(\\\"e\\\"),!0;case\\\"f\\\":return next(\\\"f\\\"),next(\\\"a\\\"),next(\\\"l\\\"),next(\\\"s\\\"),next(\\\"e\\\"),!1;case\\\"n\\\":return next(\\\"n\\\"),next(\\\"u\\\"),next(\\\"l\\\"),next(\\\"l\\\"),null}error(\\\"Unexpected '\\\"+ch+\\\"'\\\")},array=function(){var array=[];if(\\\"[\\\"===ch){if(next(\\\"[\\\"),white(),\\\"]\\\"===ch)return next(\\\"]\\\"),array;for(;ch;){if(array.push(value()),white(),\\\"]\\\"===ch)return next(\\\"]\\\"),array;next(\\\",\\\"),white()}}error(\\\"Bad array\\\")},object=function(){var key,object={};if(\\\"{\\\"===ch){if(next(\\\"{\\\"),white(),\\\"}\\\"===ch)return next(\\\"}\\\"),object;for(;ch;){if(key=string(),white(),next(\\\":\\\"),Object.hasOwnProperty.call(object,key)&&error('Duplicate key \\\"'+key+'\\\"'),object[key]=value(),white(),\\\"}\\\"===ch)return next(\\\"}\\\"),object;next(\\\",\\\"),white()}}error(\\\"Bad object\\\")};return value=function(){switch(white(),ch){case\\\"{\\\":return object();case\\\"[\\\":return array();case'\\\"':return string();case\\\"-\\\":return number();default:return ch>=\\\"0\\\"&&\\\"9\\\">=ch?number():word()}},function(source,reviver){var result;return text=source,at=0,ch=\\\" \\\",result=value(),white(),ch&&error(\\\"Syntax error\\\"),\\\"function\\\"==typeof reviver?function walk(holder,key){var k,v,value=holder[key];if(value&&\\\"object\\\"==typeof value)for(k in value)Object.hasOwnProperty.call(value,k)&&(v=walk(value,k),void 0!==v?value[k]=v:delete value[k]);return reviver.call(holder,key,value)}({\\\"\\\":result},\\\"\\\"):result}}),ace.define(\\\"ace/mode/json_worker\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\",\\\"ace/lib/oop\\\",\\\"ace/worker/mirror\\\",\\\"ace/mode/json/json_parse\\\"],function(acequire,exports){\\\"use strict\\\";var oop=acequire(\\\"../lib/oop\\\"),Mirror=acequire(\\\"../worker/mirror\\\").Mirror,parse=acequire(\\\"./json/json_parse\\\"),JsonWorker=exports.JsonWorker=function(sender){Mirror.call(this,sender),this.setTimeout(200)};oop.inherits(JsonWorker,Mirror),function(){this.onUpdate=function(){var value=this.doc.getValue();try{value&&parse(value)}catch(e){var pos=this.doc.indexToPosition(e.at-1);return this.sender.emit(\\\"error\\\",{row:pos.row,column:pos.column,text:e.message,type:\\\"error\\\"}),void 0}this.sender.emit(\\\"ok\\\")}}.call(JsonWorker.prototype)}),ace.define(\\\"ace/lib/es5-shim\\\",[\\\"require\\\",\\\"exports\\\",\\\"module\\\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\\\"sentinel\\\",{}),\\\"sentinel\\\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\\\"function\\\"!=typeof target)throw new TypeError(\\\"Function.prototype.bind called on incompatible \\\"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\\\"__defineGetter__\\\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\\\"XXX\\\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\\\"[object Array]\\\"==_toString(obj)});var boxedString=Object(\\\"a\\\"),splitString=\\\"a\\\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError;\\nfor(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError(fun+\\\" is not a function\\\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError(fun+\\\" is not a function\\\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,length=self.length>>>0,thisp=arguments[1];if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError(fun+\\\" is not a function\\\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,length=self.length>>>0,thisp=arguments[1];if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError(fun+\\\" is not a function\\\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,length=self.length>>>0;if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError(fun+\\\" is not a function\\\");if(!length&&1==arguments.length)throw new TypeError(\\\"reduce of empty array with no initial value\\\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\\\"reduce of empty array with no initial value\\\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):object,length=self.length>>>0;if(\\\"[object Function]\\\"!=_toString(fun))throw new TypeError(fun+\\\" is not a function\\\");if(!length&&1==arguments.length)throw new TypeError(\\\"reduceRight of empty array with no initial value\\\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\\\"reduceRight of empty array with no initial value\\\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\\\"[object String]\\\"==_toString(this)?this.split(\\\"\\\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\\\"Object.getOwnPropertyDescriptor called on a non-object: \\\";Object.getOwnPropertyDescriptor=function(object,property){if(\\\"object\\\"!=typeof object&&\\\"function\\\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\\\"object\\\"!=typeof prototype)throw new TypeError(\\\"typeof prototype[\\\"+typeof prototype+\\\"] != 'object'\\\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\\\"undefined\\\"==typeof document||doesDefinePropertyWork(document.createElement(\\\"div\\\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\\\"Property description must be an object: \\\",ERR_NON_OBJECT_TARGET=\\\"Object.defineProperty called on non-object: \\\",ERR_ACCESSORS_NOT_SUPPORTED=\\\"getters & setters can not be defined on this javascript engine\\\";Object.defineProperty=function(object,property,descriptor){if(\\\"object\\\"!=typeof object&&\\\"function\\\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\\\"object\\\"!=typeof descriptor&&\\\"function\\\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\\\"value\\\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\\\"get\\\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\\\"set\\\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\\\"function\\\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\\\"\\\";owns(object,name);)name+=\\\"?\\\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\\\"toString\\\",\\\"toLocaleString\\\",\\\"valueOf\\\",\\\"hasOwnProperty\\\",\\\"isPrototypeOf\\\",\\\"propertyIsEnumerable\\\",\\\"constructor\\\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\\\"object\\\"!=typeof object&&\\\"function\\\"!=typeof object||null===object)throw new TypeError(\\\"Object.keys called on a non-object\\\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\\\"\\t\\\\n\\u000b\\\\f\\\\r \\\\u2028\\\\u2029\\\";if(!String.prototype.trim||ws.trim()){ws=\\\"[\\\"+ws+\\\"]\\\";var trimBeginRegexp=RegExp(\\\"^\\\"+ws+ws+\\\"*\\\"),trimEndRegexp=RegExp(ws+ws+\\\"*$\\\");String.prototype.trim=function(){return(this+\\\"\\\").replace(trimBeginRegexp,\\\"\\\").replace(trimEndRegexp,\\\"\\\")}}var toObject=function(o){if(null==o)throw new TypeError(\\\"can't convert \\\"+o+\\\" to object\\\");return Object(o)}});\";\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = get_blob()\n\n\tfunction get_blob() {\n\t  if(global.Blob) {\n\t    try {\n\t      new Blob(['asdf'], {type: 'text/plain'})\n\t      return Blob\n\t    } catch(err) {}\n\t  }\n\n\t  var Builder = global.WebKitBlobBuilder ||\n\t                global.MozBlobBuilder ||\n\t                global.MSBlobBuilder\n\n\t  return function(parts, bag) {\n\t    var builder = new Builder\n\t      , endings = bag.endings\n\t      , type = bag.type\n\n\t    if(endings) for(var i = 0, len = parts.length; i < len; ++i) {\n\t      builder.append(parts[i], endings)\n\t    } else for(var i = 0, len = parts.length; i < len; ++i) {\n\t      builder.append(parts[i])\n\t    }\n\n\t    return type ? builder.getBlob(type) : builder.getBlob()\n\t  }\n\t}\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ])\n});\n;"

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(48))

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = "/*\n AngularJS v1.4.2\n (c) 2010-2015 Google, Inc. http://angularjs.org\n License: MIT\n*/\n(function(O,U,t){'use strict';function J(b){return function(){var a=arguments[0],c;c=\"[\"+(b?b+\":\":\"\")+a+\"] http://errors.angularjs.org/1.4.2/\"+(b?b+\"/\":\"\")+a;for(a=1;a<arguments.length;a++){c=c+(1==a?\"?\":\"&\")+\"p\"+(a-1)+\"=\";var d=encodeURIComponent,e;e=arguments[a];e=\"function\"==typeof e?e.toString().replace(/ \\{[\\s\\S]*$/,\"\"):\"undefined\"==typeof e?\"undefined\":\"string\"!=typeof e?JSON.stringify(e):e;c+=d(e)}return Error(c)}}function Ea(b){if(null==b||Wa(b))return!1;var a=\"length\"in Object(b)&&b.length;\nreturn b.nodeType===qa&&a?!0:L(b)||G(b)||0===a||\"number\"===typeof a&&0<a&&a-1 in b}function m(b,a,c){var d,e;if(b)if(z(b))for(d in b)\"prototype\"==d||\"length\"==d||\"name\"==d||b.hasOwnProperty&&!b.hasOwnProperty(d)||a.call(c,b[d],d,b);else if(G(b)||Ea(b)){var f=\"object\"!==typeof b;d=0;for(e=b.length;d<e;d++)(f||d in b)&&a.call(c,b[d],d,b)}else if(b.forEach&&b.forEach!==m)b.forEach(a,c,b);else if(nc(b))for(d in b)a.call(c,b[d],d,b);else if(\"function\"===typeof b.hasOwnProperty)for(d in b)b.hasOwnProperty(d)&&\na.call(c,b[d],d,b);else for(d in b)Xa.call(b,d)&&a.call(c,b[d],d,b);return b}function oc(b,a,c){for(var d=Object.keys(b).sort(),e=0;e<d.length;e++)a.call(c,b[d[e]],d[e]);return d}function pc(b){return function(a,c){b(c,a)}}function Ud(){return++nb}function qc(b,a){a?b.$$hashKey=a:delete b.$$hashKey}function Nb(b,a,c){for(var d=b.$$hashKey,e=0,f=a.length;e<f;++e){var g=a[e];if(H(g)||z(g))for(var h=Object.keys(g),l=0,k=h.length;l<k;l++){var n=h[l],r=g[n];c&&H(r)?aa(r)?b[n]=new Date(r.valueOf()):(H(b[n])||\n(b[n]=G(r)?[]:{}),Nb(b[n],[r],!0)):b[n]=r}}qc(b,d);return b}function P(b){return Nb(b,za.call(arguments,1),!1)}function Vd(b){return Nb(b,za.call(arguments,1),!0)}function W(b){return parseInt(b,10)}function Ob(b,a){return P(Object.create(b),a)}function v(){}function Ya(b){return b}function ra(b){return function(){return b}}function rc(b){return z(b.toString)&&b.toString!==Object.prototype.toString}function A(b){return\"undefined\"===typeof b}function w(b){return\"undefined\"!==typeof b}function H(b){return null!==\nb&&\"object\"===typeof b}function nc(b){return null!==b&&\"object\"===typeof b&&!sc(b)}function L(b){return\"string\"===typeof b}function V(b){return\"number\"===typeof b}function aa(b){return\"[object Date]\"===sa.call(b)}function z(b){return\"function\"===typeof b}function Za(b){return\"[object RegExp]\"===sa.call(b)}function Wa(b){return b&&b.window===b}function $a(b){return b&&b.$evalAsync&&b.$watch}function ab(b){return\"boolean\"===typeof b}function tc(b){return!(!b||!(b.nodeName||b.prop&&b.attr&&b.find))}\nfunction Wd(b){var a={};b=b.split(\",\");var c;for(c=0;c<b.length;c++)a[b[c]]=!0;return a}function ta(b){return M(b.nodeName||b[0]&&b[0].nodeName)}function bb(b,a){var c=b.indexOf(a);0<=c&&b.splice(c,1);return c}function fa(b,a,c,d){if(Wa(b)||$a(b))throw Fa(\"cpws\");if(uc.test(sa.call(a)))throw Fa(\"cpta\");if(a){if(b===a)throw Fa(\"cpi\");c=c||[];d=d||[];H(b)&&(c.push(b),d.push(a));var e;if(G(b))for(e=a.length=0;e<b.length;e++)a.push(fa(b[e],null,c,d));else{var f=a.$$hashKey;G(a)?a.length=0:m(a,function(b,\nc){delete a[c]});if(nc(b))for(e in b)a[e]=fa(b[e],null,c,d);else if(b&&\"function\"===typeof b.hasOwnProperty)for(e in b)b.hasOwnProperty(e)&&(a[e]=fa(b[e],null,c,d));else for(e in b)Xa.call(b,e)&&(a[e]=fa(b[e],null,c,d));qc(a,f)}}else if(a=b,H(b)){if(c&&-1!==(f=c.indexOf(b)))return d[f];if(G(b))return fa(b,[],c,d);if(uc.test(sa.call(b)))a=new b.constructor(b);else if(aa(b))a=new Date(b.getTime());else if(Za(b))a=new RegExp(b.source,b.toString().match(/[^\\/]*$/)[0]),a.lastIndex=b.lastIndex;else return e=\nObject.create(sc(b)),fa(b,e,c,d);d&&(c.push(b),d.push(a))}return a}function ia(b,a){if(G(b)){a=a||[];for(var c=0,d=b.length;c<d;c++)a[c]=b[c]}else if(H(b))for(c in a=a||{},b)if(\"$\"!==c.charAt(0)||\"$\"!==c.charAt(1))a[c]=b[c];return a||b}function ka(b,a){if(b===a)return!0;if(null===b||null===a)return!1;if(b!==b&&a!==a)return!0;var c=typeof b,d;if(c==typeof a&&\"object\"==c)if(G(b)){if(!G(a))return!1;if((c=b.length)==a.length){for(d=0;d<c;d++)if(!ka(b[d],a[d]))return!1;return!0}}else{if(aa(b))return aa(a)?\nka(b.getTime(),a.getTime()):!1;if(Za(b))return Za(a)?b.toString()==a.toString():!1;if($a(b)||$a(a)||Wa(b)||Wa(a)||G(a)||aa(a)||Za(a))return!1;c=ga();for(d in b)if(\"$\"!==d.charAt(0)&&!z(b[d])){if(!ka(b[d],a[d]))return!1;c[d]=!0}for(d in a)if(!(d in c||\"$\"===d.charAt(0)||a[d]===t||z(a[d])))return!1;return!0}return!1}function cb(b,a,c){return b.concat(za.call(a,c))}function vc(b,a){var c=2<arguments.length?za.call(arguments,2):[];return!z(a)||a instanceof RegExp?a:c.length?function(){return arguments.length?\na.apply(b,cb(c,arguments,0)):a.apply(b,c)}:function(){return arguments.length?a.apply(b,arguments):a.call(b)}}function Xd(b,a){var c=a;\"string\"===typeof b&&\"$\"===b.charAt(0)&&\"$\"===b.charAt(1)?c=t:Wa(a)?c=\"$WINDOW\":a&&U===a?c=\"$DOCUMENT\":$a(a)&&(c=\"$SCOPE\");return c}function db(b,a){if(\"undefined\"===typeof b)return t;V(a)||(a=a?2:null);return JSON.stringify(b,Xd,a)}function wc(b){return L(b)?JSON.parse(b):b}function xc(b,a){var c=Date.parse(\"Jan 01, 1970 00:00:00 \"+b)/6E4;return isNaN(c)?a:c}function Pb(b,\na,c){c=c?-1:1;var d=xc(a,b.getTimezoneOffset());a=b;b=c*(d-b.getTimezoneOffset());a=new Date(a.getTime());a.setMinutes(a.getMinutes()+b);return a}function ua(b){b=y(b).clone();try{b.empty()}catch(a){}var c=y(\"<div>\").append(b).html();try{return b[0].nodeType===Na?M(c):c.match(/^(<[^>]+>)/)[1].replace(/^<([\\w\\-]+)/,function(a,b){return\"<\"+M(b)})}catch(d){return M(c)}}function yc(b){try{return decodeURIComponent(b)}catch(a){}}function zc(b){var a={},c,d;m((b||\"\").split(\"&\"),function(b){b&&(c=b.replace(/\\+/g,\n\"%20\").split(\"=\"),d=yc(c[0]),w(d)&&(b=w(c[1])?yc(c[1]):!0,Xa.call(a,d)?G(a[d])?a[d].push(b):a[d]=[a[d],b]:a[d]=b))});return a}function Qb(b){var a=[];m(b,function(b,d){G(b)?m(b,function(b){a.push(ma(d,!0)+(!0===b?\"\":\"=\"+ma(b,!0)))}):a.push(ma(d,!0)+(!0===b?\"\":\"=\"+ma(b,!0)))});return a.length?a.join(\"&\"):\"\"}function ob(b){return ma(b,!0).replace(/%26/gi,\"&\").replace(/%3D/gi,\"=\").replace(/%2B/gi,\"+\")}function ma(b,a){return encodeURIComponent(b).replace(/%40/gi,\"@\").replace(/%3A/gi,\":\").replace(/%24/g,\n\"$\").replace(/%2C/gi,\",\").replace(/%3B/gi,\";\").replace(/%20/g,a?\"%20\":\"+\")}function Yd(b,a){var c,d,e=Oa.length;for(d=0;d<e;++d)if(c=Oa[d]+a,L(c=b.getAttribute(c)))return c;return null}function Zd(b,a){var c,d,e={};m(Oa,function(a){a+=\"app\";!c&&b.hasAttribute&&b.hasAttribute(a)&&(c=b,d=b.getAttribute(a))});m(Oa,function(a){a+=\"app\";var e;!c&&(e=b.querySelector(\"[\"+a.replace(\":\",\"\\\\:\")+\"]\"))&&(c=e,d=e.getAttribute(a))});c&&(e.strictDi=null!==Yd(c,\"strict-di\"),a(c,d?[d]:[],e))}function Ac(b,a,c){H(c)||\n(c={});c=P({strictDi:!1},c);var d=function(){b=y(b);if(b.injector()){var d=b[0]===U?\"document\":ua(b);throw Fa(\"btstrpd\",d.replace(/</,\"&lt;\").replace(/>/,\"&gt;\"));}a=a||[];a.unshift([\"$provide\",function(a){a.value(\"$rootElement\",b)}]);c.debugInfoEnabled&&a.push([\"$compileProvider\",function(a){a.debugInfoEnabled(!0)}]);a.unshift(\"ng\");d=eb(a,c.strictDi);d.invoke([\"$rootScope\",\"$rootElement\",\"$compile\",\"$injector\",function(a,b,c,d){a.$apply(function(){b.data(\"$injector\",d);c(b)(a)})}]);return d},e=\n/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;O&&e.test(O.name)&&(c.debugInfoEnabled=!0,O.name=O.name.replace(e,\"\"));if(O&&!f.test(O.name))return d();O.name=O.name.replace(f,\"\");ca.resumeBootstrap=function(b){m(b,function(b){a.push(b)});return d()};z(ca.resumeDeferredBootstrap)&&ca.resumeDeferredBootstrap()}function $d(){O.name=\"NG_ENABLE_DEBUG_INFO!\"+O.name;O.location.reload()}function ae(b){b=ca.element(b).injector();if(!b)throw Fa(\"test\");return b.get(\"$$testability\")}function Bc(b,a){a=a||\n\"_\";return b.replace(be,function(b,d){return(d?a:\"\")+b.toLowerCase()})}function ce(){var b;if(!Cc){var a=pb();la=O.jQuery;w(a)&&(la=null===a?t:O[a]);la&&la.fn.on?(y=la,P(la.fn,{scope:Pa.scope,isolateScope:Pa.isolateScope,controller:Pa.controller,injector:Pa.injector,inheritedData:Pa.inheritedData}),b=la.cleanData,la.cleanData=function(a){var d;if(Rb)Rb=!1;else for(var e=0,f;null!=(f=a[e]);e++)(d=la._data(f,\"events\"))&&d.$destroy&&la(f).triggerHandler(\"$destroy\");b(a)}):y=Q;ca.element=y;Cc=!0}}function Sb(b,\na,c){if(!b)throw Fa(\"areq\",a||\"?\",c||\"required\");return b}function Qa(b,a,c){c&&G(b)&&(b=b[b.length-1]);Sb(z(b),a,\"not a function, got \"+(b&&\"object\"===typeof b?b.constructor.name||\"Object\":typeof b));return b}function Ra(b,a){if(\"hasOwnProperty\"===b)throw Fa(\"badname\",a);}function Dc(b,a,c){if(!a)return b;a=a.split(\".\");for(var d,e=b,f=a.length,g=0;g<f;g++)d=a[g],b&&(b=(e=b)[d]);return!c&&z(b)?vc(e,b):b}function qb(b){var a=b[0];b=b[b.length-1];var c=[a];do{a=a.nextSibling;if(!a)break;c.push(a)}while(a!==\nb);return y(c)}function ga(){return Object.create(null)}function de(b){function a(a,b,c){return a[b]||(a[b]=c())}var c=J(\"$injector\"),d=J(\"ng\");b=a(b,\"angular\",Object);b.$$minErr=b.$$minErr||J;return a(b,\"module\",function(){var b={};return function(f,g,h){if(\"hasOwnProperty\"===f)throw d(\"badname\",\"module\");g&&b.hasOwnProperty(f)&&(b[f]=null);return a(b,f,function(){function a(b,c,e,f){f||(f=d);return function(){f[e||\"push\"]([b,c,arguments]);return C}}function b(a,c){return function(b,e){e&&z(e)&&\n(e.$$moduleName=f);d.push([a,c,arguments]);return C}}if(!g)throw c(\"nomod\",f);var d=[],e=[],s=[],x=a(\"$injector\",\"invoke\",\"push\",e),C={_invokeQueue:d,_configBlocks:e,_runBlocks:s,requires:g,name:f,provider:b(\"$provide\",\"provider\"),factory:b(\"$provide\",\"factory\"),service:b(\"$provide\",\"service\"),value:a(\"$provide\",\"value\"),constant:a(\"$provide\",\"constant\",\"unshift\"),decorator:b(\"$provide\",\"decorator\"),animation:b(\"$animateProvider\",\"register\"),filter:b(\"$filterProvider\",\"register\"),controller:b(\"$controllerProvider\",\n\"register\"),directive:b(\"$compileProvider\",\"directive\"),config:x,run:function(a){s.push(a);return this}};h&&x(h);return C})}})}function ee(b){P(b,{bootstrap:Ac,copy:fa,extend:P,merge:Vd,equals:ka,element:y,forEach:m,injector:eb,noop:v,bind:vc,toJson:db,fromJson:wc,identity:Ya,isUndefined:A,isDefined:w,isString:L,isFunction:z,isObject:H,isNumber:V,isElement:tc,isArray:G,version:fe,isDate:aa,lowercase:M,uppercase:rb,callbacks:{counter:0},getTestability:ae,$$minErr:J,$$csp:fb,reloadWithDebugInfo:$d});\ngb=de(O);try{gb(\"ngLocale\")}catch(a){gb(\"ngLocale\",[]).provider(\"$locale\",ge)}gb(\"ng\",[\"ngLocale\"],[\"$provide\",function(a){a.provider({$$sanitizeUri:he});a.provider(\"$compile\",Ec).directive({a:ie,input:Fc,textarea:Fc,form:je,script:ke,select:le,style:me,option:ne,ngBind:oe,ngBindHtml:pe,ngBindTemplate:qe,ngClass:re,ngClassEven:se,ngClassOdd:te,ngCloak:ue,ngController:ve,ngForm:we,ngHide:xe,ngIf:ye,ngInclude:ze,ngInit:Ae,ngNonBindable:Be,ngPluralize:Ce,ngRepeat:De,ngShow:Ee,ngStyle:Fe,ngSwitch:Ge,\nngSwitchWhen:He,ngSwitchDefault:Ie,ngOptions:Je,ngTransclude:Ke,ngModel:Le,ngList:Me,ngChange:Ne,pattern:Gc,ngPattern:Gc,required:Hc,ngRequired:Hc,minlength:Ic,ngMinlength:Ic,maxlength:Jc,ngMaxlength:Jc,ngValue:Oe,ngModelOptions:Pe}).directive({ngInclude:Qe}).directive(sb).directive(Kc);a.provider({$anchorScroll:Re,$animate:Se,$$animateQueue:Te,$$AnimateRunner:Ue,$browser:Ve,$cacheFactory:We,$controller:Xe,$document:Ye,$exceptionHandler:Ze,$filter:Lc,$interpolate:$e,$interval:af,$http:bf,$httpParamSerializer:cf,\n$httpParamSerializerJQLike:df,$httpBackend:ef,$location:ff,$log:gf,$parse:hf,$rootScope:jf,$q:kf,$$q:lf,$sce:mf,$sceDelegate:nf,$sniffer:of,$templateCache:pf,$templateRequest:qf,$$testability:rf,$timeout:sf,$window:tf,$$rAF:uf,$$asyncCallback:vf,$$jqLite:wf,$$HashMap:xf,$$cookieReader:yf})}])}function hb(b){return b.replace(zf,function(a,b,d,e){return e?d.toUpperCase():d}).replace(Af,\"Moz$1\")}function Mc(b){b=b.nodeType;return b===qa||!b||9===b}function Nc(b,a){var c,d,e=a.createDocumentFragment(),\nf=[];if(Tb.test(b)){c=c||e.appendChild(a.createElement(\"div\"));d=(Bf.exec(b)||[\"\",\"\"])[1].toLowerCase();d=na[d]||na._default;c.innerHTML=d[1]+b.replace(Cf,\"<$1></$2>\")+d[2];for(d=d[0];d--;)c=c.lastChild;f=cb(f,c.childNodes);c=e.firstChild;c.textContent=\"\"}else f.push(a.createTextNode(b));e.textContent=\"\";e.innerHTML=\"\";m(f,function(a){e.appendChild(a)});return e}function Q(b){if(b instanceof Q)return b;var a;L(b)&&(b=R(b),a=!0);if(!(this instanceof Q)){if(a&&\"<\"!=b.charAt(0))throw Ub(\"nosel\");return new Q(b)}if(a){a=\nU;var c;b=(c=Df.exec(b))?[a.createElement(c[1])]:(c=Nc(b,a))?c.childNodes:[]}Oc(this,b)}function Vb(b){return b.cloneNode(!0)}function tb(b,a){a||ub(b);if(b.querySelectorAll)for(var c=b.querySelectorAll(\"*\"),d=0,e=c.length;d<e;d++)ub(c[d])}function Pc(b,a,c,d){if(w(d))throw Ub(\"offargs\");var e=(d=vb(b))&&d.events,f=d&&d.handle;if(f)if(a)m(a.split(\" \"),function(a){if(w(c)){var d=e[a];bb(d||[],c);if(d&&0<d.length)return}b.removeEventListener(a,f,!1);delete e[a]});else for(a in e)\"$destroy\"!==a&&b.removeEventListener(a,\nf,!1),delete e[a]}function ub(b,a){var c=b.ng339,d=c&&ib[c];d&&(a?delete d.data[a]:(d.handle&&(d.events.$destroy&&d.handle({},\"$destroy\"),Pc(b)),delete ib[c],b.ng339=t))}function vb(b,a){var c=b.ng339,c=c&&ib[c];a&&!c&&(b.ng339=c=++Ef,c=ib[c]={events:{},data:{},handle:t});return c}function Wb(b,a,c){if(Mc(b)){var d=w(c),e=!d&&a&&!H(a),f=!a;b=(b=vb(b,!e))&&b.data;if(d)b[a]=c;else{if(f)return b;if(e)return b&&b[a];P(b,a)}}}function wb(b,a){return b.getAttribute?-1<(\" \"+(b.getAttribute(\"class\")||\"\")+\n\" \").replace(/[\\n\\t]/g,\" \").indexOf(\" \"+a+\" \"):!1}function xb(b,a){a&&b.setAttribute&&m(a.split(\" \"),function(a){b.setAttribute(\"class\",R((\" \"+(b.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \").replace(\" \"+R(a)+\" \",\" \")))})}function yb(b,a){if(a&&b.setAttribute){var c=(\" \"+(b.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \");m(a.split(\" \"),function(a){a=R(a);-1===c.indexOf(\" \"+a+\" \")&&(c+=a+\" \")});b.setAttribute(\"class\",R(c))}}function Oc(b,a){if(a)if(a.nodeType)b[b.length++]=a;else{var c=\na.length;if(\"number\"===typeof c&&a.window!==a){if(c)for(var d=0;d<c;d++)b[b.length++]=a[d]}else b[b.length++]=a}}function Qc(b,a){return zb(b,\"$\"+(a||\"ngController\")+\"Controller\")}function zb(b,a,c){9==b.nodeType&&(b=b.documentElement);for(a=G(a)?a:[a];b;){for(var d=0,e=a.length;d<e;d++)if((c=y.data(b,a[d]))!==t)return c;b=b.parentNode||11===b.nodeType&&b.host}}function Rc(b){for(tb(b,!0);b.firstChild;)b.removeChild(b.firstChild)}function Xb(b,a){a||tb(b);var c=b.parentNode;c&&c.removeChild(b)}function Ff(b,\na){a=a||O;if(\"complete\"===a.document.readyState)a.setTimeout(b);else y(a).on(\"load\",b)}function Sc(b,a){var c=Ab[a.toLowerCase()];return c&&Tc[ta(b)]&&c}function Gf(b,a){var c=b.nodeName;return(\"INPUT\"===c||\"TEXTAREA\"===c)&&Uc[a]}function Hf(b,a){var c=function(c,e){c.isDefaultPrevented=function(){return c.defaultPrevented};var f=a[e||c.type],g=f?f.length:0;if(g){if(A(c.immediatePropagationStopped)){var h=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=\n!0;c.stopPropagation&&c.stopPropagation();h&&h.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};1<g&&(f=ia(f));for(var l=0;l<g;l++)c.isImmediatePropagationStopped()||f[l].call(b,c)}};c.elem=b;return c}function wf(){this.$get=function(){return P(Q,{hasClass:function(b,a){b.attr&&(b=b[0]);return wb(b,a)},addClass:function(b,a){b.attr&&(b=b[0]);return yb(b,a)},removeClass:function(b,a){b.attr&&(b=b[0]);return xb(b,a)}})}}function Ga(b,a){var c=b&&b.$$hashKey;\nif(c)return\"function\"===typeof c&&(c=b.$$hashKey()),c;c=typeof b;return c=\"function\"==c||\"object\"==c&&null!==b?b.$$hashKey=c+\":\"+(a||Ud)():c+\":\"+b}function Sa(b,a){if(a){var c=0;this.nextUid=function(){return++c}}m(b,this.put,this)}function If(b){return(b=b.toString().replace(Vc,\"\").match(Wc))?\"function(\"+(b[1]||\"\").replace(/[\\s\\r\\n]+/,\" \")+\")\":\"fn\"}function eb(b,a){function c(a){return function(b,c){if(H(b))m(b,pc(a));else return a(b,c)}}function d(a,b){Ra(a,\"service\");if(z(b)||G(b))b=s.instantiate(b);\nif(!b.$get)throw Ha(\"pget\",a);return r[a+\"Provider\"]=b}function e(a,b){return function(){var c=C.invoke(b,this);if(A(c))throw Ha(\"undef\",a);return c}}function f(a,b,c){return d(a,{$get:!1!==c?e(a,b):b})}function g(a){var b=[],c;m(a,function(a){function d(a){var b,c;b=0;for(c=a.length;b<c;b++){var e=a[b],f=s.get(e[0]);f[e[1]].apply(f,e[2])}}if(!n.get(a)){n.put(a,!0);try{L(a)?(c=gb(a),b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):z(a)?b.push(s.invoke(a)):G(a)?\nb.push(s.invoke(a)):Qa(a,\"module\")}catch(e){throw G(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1==e.stack.indexOf(e.message)&&(e=e.message+\"\\n\"+e.stack),Ha(\"modulerr\",a,e.stack||e.message||e);}}});return b}function h(b,c){function d(a,e){if(b.hasOwnProperty(a)){if(b[a]===l)throw Ha(\"cdep\",a+\" <- \"+k.join(\" <- \"));return b[a]}try{return k.unshift(a),b[a]=l,b[a]=c(a,e)}catch(f){throw b[a]===l&&delete b[a],f;}finally{k.shift()}}function e(b,c,f,g){\"string\"===typeof f&&(g=f,f=null);var h=[],k=eb.$$annotate(b,\na,g),l,s,n;s=0;for(l=k.length;s<l;s++){n=k[s];if(\"string\"!==typeof n)throw Ha(\"itkn\",n);h.push(f&&f.hasOwnProperty(n)?f[n]:d(n,g))}G(b)&&(b=b[l]);return b.apply(c,h)}return{invoke:e,instantiate:function(a,b,c){var d=Object.create((G(a)?a[a.length-1]:a).prototype||null);a=e(a,d,b,c);return H(a)||z(a)?a:d},get:d,annotate:eb.$$annotate,has:function(a){return r.hasOwnProperty(a+\"Provider\")||b.hasOwnProperty(a)}}}a=!0===a;var l={},k=[],n=new Sa([],!0),r={$provide:{provider:c(d),factory:c(f),service:c(function(a,\nb){return f(a,[\"$injector\",function(a){return a.instantiate(b)}])}),value:c(function(a,b){return f(a,ra(b),!1)}),constant:c(function(a,b){Ra(a,\"constant\");r[a]=b;x[a]=b}),decorator:function(a,b){var c=s.get(a+\"Provider\"),d=c.$get;c.$get=function(){var a=C.invoke(d,c);return C.invoke(b,null,{$delegate:a})}}}},s=r.$injector=h(r,function(a,b){ca.isString(b)&&k.push(b);throw Ha(\"unpr\",k.join(\" <- \"));}),x={},C=x.$injector=h(x,function(a,b){var c=s.get(a+\"Provider\",b);return C.invoke(c.$get,c,t,a)});m(g(b),\nfunction(a){a&&C.invoke(a)});return C}function Re(){var b=!0;this.disableAutoScrolling=function(){b=!1};this.$get=[\"$window\",\"$location\",\"$rootScope\",function(a,c,d){function e(a){var b=null;Array.prototype.some.call(a,function(a){if(\"a\"===ta(a))return b=a,!0});return b}function f(b){if(b){b.scrollIntoView();var c;c=g.yOffset;z(c)?c=c():tc(c)?(c=c[0],c=\"fixed\"!==a.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):V(c)||(c=0);c&&(b=b.getBoundingClientRect().top,a.scrollBy(0,b-c))}else a.scrollTo(0,\n0)}function g(a){a=L(a)?a:c.hash();var b;a?(b=h.getElementById(a))?f(b):(b=e(h.getElementsByName(a)))?f(b):\"top\"===a&&f(null):f(null)}var h=a.document;b&&d.$watch(function(){return c.hash()},function(a,b){a===b&&\"\"===a||Ff(function(){d.$evalAsync(g)})});return g}]}function jb(b,a){if(!b&&!a)return\"\";if(!b)return a;if(!a)return b;G(b)&&(b=b.join(\" \"));G(a)&&(a=a.join(\" \"));return b+\" \"+a}function Jf(b){L(b)&&(b=b.split(\" \"));var a=ga();m(b,function(b){b.length&&(a[b]=!0)});return a}function Ia(b){return H(b)?\nb:{}}function vf(){this.$get=[\"$$rAF\",\"$timeout\",function(b,a){return b.supported?function(a){return b(a)}:function(b){return a(b,0,!1)}}]}function Kf(b,a,c,d){function e(a){try{a.apply(null,za.call(arguments,1))}finally{if(C--,0===C)for(;F.length;)try{F.pop()()}catch(b){c.error(b)}}}function f(){g();h()}function g(){a:{try{u=n.state;break a}catch(a){}u=void 0}u=A(u)?null:u;ka(u,D)&&(u=D);D=u}function h(){if(K!==l.url()||p!==u)K=l.url(),p=u,m(B,function(a){a(l.url(),u)})}var l=this,k=b.location,n=\nb.history,r=b.setTimeout,s=b.clearTimeout,x={};l.isMock=!1;var C=0,F=[];l.$$completeOutstandingRequest=e;l.$$incOutstandingRequestCount=function(){C++};l.notifyWhenNoOutstandingRequests=function(a){0===C?a():F.push(a)};var u,p,K=k.href,q=a.find(\"base\"),I=null;g();p=u;l.url=function(a,c,e){A(e)&&(e=null);k!==b.location&&(k=b.location);n!==b.history&&(n=b.history);if(a){var f=p===e;if(K===a&&(!d.history||f))return l;var h=K&&Ja(K)===Ja(a);K=a;p=e;if(!d.history||h&&f){if(!h||I)I=a;c?k.replace(a):h?(c=\nk,e=a.indexOf(\"#\"),a=-1===e?\"\":a.substr(e),c.hash=a):k.href=a}else n[c?\"replaceState\":\"pushState\"](e,\"\",a),g(),p=u;return l}return I||k.href.replace(/%27/g,\"'\")};l.state=function(){return u};var B=[],N=!1,D=null;l.onUrlChange=function(a){if(!N){if(d.history)y(b).on(\"popstate\",f);y(b).on(\"hashchange\",f);N=!0}B.push(a);return a};l.$$applicationDestroyed=function(){y(b).off(\"hashchange popstate\",f)};l.$$checkUrlChange=h;l.baseHref=function(){var a=q.attr(\"href\");return a?a.replace(/^(https?\\:)?\\/\\/[^\\/]*/,\n\"\"):\"\"};l.defer=function(a,b){var c;C++;c=r(function(){delete x[c];e(a)},b||0);x[c]=!0;return c};l.defer.cancel=function(a){return x[a]?(delete x[a],s(a),e(v),!0):!1}}function Ve(){this.$get=[\"$window\",\"$log\",\"$sniffer\",\"$document\",function(b,a,c,d){return new Kf(b,d,a,c)}]}function We(){this.$get=function(){function b(b,d){function e(a){a!=r&&(s?s==a&&(s=a.n):s=a,f(a.n,a.p),f(a,r),r=a,r.n=null)}function f(a,b){a!=b&&(a&&(a.p=b),b&&(b.n=a))}if(b in a)throw J(\"$cacheFactory\")(\"iid\",b);var g=0,h=P({},\nd,{id:b}),l={},k=d&&d.capacity||Number.MAX_VALUE,n={},r=null,s=null;return a[b]={put:function(a,b){if(!A(b)){if(k<Number.MAX_VALUE){var c=n[a]||(n[a]={key:a});e(c)}a in l||g++;l[a]=b;g>k&&this.remove(s.key);return b}},get:function(a){if(k<Number.MAX_VALUE){var b=n[a];if(!b)return;e(b)}return l[a]},remove:function(a){if(k<Number.MAX_VALUE){var b=n[a];if(!b)return;b==r&&(r=b.p);b==s&&(s=b.n);f(b.n,b.p);delete n[a]}delete l[a];g--},removeAll:function(){l={};g=0;n={};r=s=null},destroy:function(){n=h=\nl=null;delete a[b]},info:function(){return P({},h,{size:g})}}}var a={};b.info=function(){var b={};m(a,function(a,e){b[e]=a.info()});return b};b.get=function(b){return a[b]};return b}}function pf(){this.$get=[\"$cacheFactory\",function(b){return b(\"templates\")}]}function Ec(b,a){function c(a,b,c){var d=/^\\s*([@&]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/,e={};m(a,function(a,f){var g=a.match(d);if(!g)throw ea(\"iscp\",b,f,a,c?\"controller bindings definition\":\"isolate scope definition\");e[f]={mode:g[1][0],collection:\"*\"===\ng[2],optional:\"?\"===g[3],attrName:g[4]||f}});return e}function d(a){var b=a.charAt(0);if(!b||b!==M(b))throw ea(\"baddir\",a);if(a!==a.trim())throw ea(\"baddir\",a);}var e={},f=/^\\s*directive\\:\\s*([\\w\\-]+)\\s+(.*)$/,g=/(([\\w\\-]+)(?:\\:([^;]+))?;?)/,h=Wd(\"ngSrc,ngSrcset,src,srcset\"),l=/^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/,k=/^(on[a-z]+|formaction)$/;this.directive=function s(a,f){Ra(a,\"directive\");L(a)?(d(a),Sb(f,\"directiveFactory\"),e.hasOwnProperty(a)||(e[a]=[],b.factory(a+\"Directive\",[\"$injector\",\"$exceptionHandler\",\nfunction(b,d){var f=[];m(e[a],function(e,g){try{var h=b.invoke(e);z(h)?h={compile:ra(h)}:!h.compile&&h.link&&(h.compile=ra(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||a;h.require=h.require||h.controller&&h.name;h.restrict=h.restrict||\"EA\";var k=h,l=h,s=h.name,n={isolateScope:null,bindToController:null};H(l.scope)&&(!0===l.bindToController?(n.bindToController=c(l.scope,s,!0),n.isolateScope={}):n.isolateScope=c(l.scope,s,!1));H(l.bindToController)&&(n.bindToController=c(l.bindToController,\ns,!0));if(H(n.bindToController)){var C=l.controller,$=l.controllerAs;if(!C)throw ea(\"noctrl\",s);var ha;a:if($&&L($))ha=$;else{if(L(C)){var m=Xc.exec(C);if(m){ha=m[3];break a}}ha=void 0}if(!ha)throw ea(\"noident\",s);}var q=k.$$bindings=n;H(q.isolateScope)&&(h.$$isolateBindings=q.isolateScope);h.$$moduleName=e.$$moduleName;f.push(h)}catch(t){d(t)}});return f}])),e[a].push(f)):m(a,pc(s));return this};this.aHrefSanitizationWhitelist=function(b){return w(b)?(a.aHrefSanitizationWhitelist(b),this):a.aHrefSanitizationWhitelist()};\nthis.imgSrcSanitizationWhitelist=function(b){return w(b)?(a.imgSrcSanitizationWhitelist(b),this):a.imgSrcSanitizationWhitelist()};var n=!0;this.debugInfoEnabled=function(a){return w(a)?(n=a,this):n};this.$get=[\"$injector\",\"$interpolate\",\"$exceptionHandler\",\"$templateRequest\",\"$parse\",\"$controller\",\"$rootScope\",\"$document\",\"$sce\",\"$animate\",\"$$sanitizeUri\",function(a,b,c,d,u,p,K,q,I,B,N){function D(a,b){try{a.addClass(b)}catch(c){}}function Z(a,b,c,d,e){a instanceof y||(a=y(a));m(a,function(b,c){b.nodeType==\nNa&&b.nodeValue.match(/\\S+/)&&(a[c]=y(b).wrap(\"<span></span>\").parent()[0])});var f=S(a,b,a,c,d,e);Z.$$addScopeClass(a);var g=null;return function(b,c,d){Sb(b,\"scope\");d=d||{};var e=d.parentBoundTranscludeFn,h=d.transcludeControllers;d=d.futureParentElement;e&&e.$$boundTransclude&&(e=e.$$boundTransclude);g||(g=(d=d&&d[0])?\"foreignobject\"!==ta(d)&&d.toString().match(/SVG/)?\"svg\":\"html\":\"html\");d=\"html\"!==g?y(Yb(g,y(\"<div>\").append(a).html())):c?Pa.clone.call(a):a;if(h)for(var k in h)d.data(\"$\"+k+\"Controller\",\nh[k].instance);Z.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,e);return d}}function S(a,b,c,d,e,f){function g(a,c,d,e){var f,k,l,s,n,B,C;if(p)for(C=Array(c.length),s=0;s<h.length;s+=3)f=h[s],C[f]=c[f];else C=c;s=0;for(n=h.length;s<n;)if(k=C[h[s++]],c=h[s++],f=h[s++],c){if(c.scope){if(l=a.$new(),Z.$$addScopeInfo(y(k),l),B=c.$$destroyBindings)c.$$destroyBindings=null,l.$on(\"$destroyed\",B)}else l=a;B=c.transcludeOnThisElement?$(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?$(a,b):null;c(f,l,k,d,\nB,c)}else f&&f(a,k.childNodes,t,e)}for(var h=[],k,l,s,n,p,B=0;B<a.length;B++){k=new aa;l=ha(a[B],[],k,0===B?d:t,e);(f=l.length?E(l,a[B],k,b,c,null,[],[],f):null)&&f.scope&&Z.$$addScopeClass(k.$$element);k=f&&f.terminal||!(s=a[B].childNodes)||!s.length?null:S(s,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||k)h.push(B,f,k),n=!0,p=p||f;f=null}return n?g:null}function $(a,b,c){return function(d,e,f,g,h){d||(d=a.$new(!1,h),d.$$transcluded=!0);return b(d,e,{parentBoundTranscludeFn:c,\ntranscludeControllers:f,futureParentElement:g})}}function ha(a,b,c,d,e){var h=c.$attr,k;switch(a.nodeType){case qa:w(b,wa(ta(a)),\"E\",d,e);for(var l,s,n,p=a.attributes,B=0,C=p&&p.length;B<C;B++){var x=!1,S=!1;l=p[B];k=l.name;s=R(l.value);l=wa(k);if(n=ia.test(l))k=k.replace(Zc,\"\").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()});var F=l.replace(/(Start|End)$/,\"\");A(F)&&l===F+\"Start\"&&(x=k,S=k.substr(0,k.length-5)+\"end\",k=k.substr(0,k.length-6));l=wa(k.toLowerCase());h[l]=k;if(n||!c.hasOwnProperty(l))c[l]=\ns,Sc(a,l)&&(c[l]=!0);V(a,b,s,l,n);w(b,l,\"A\",d,e,x,S)}a=a.className;H(a)&&(a=a.animVal);if(L(a)&&\"\"!==a)for(;k=g.exec(a);)l=wa(k[2]),w(b,l,\"C\",d,e)&&(c[l]=R(k[3])),a=a.substr(k.index+k[0].length);break;case Na:if(11===Ua)for(;a.parentNode&&a.nextSibling&&a.nextSibling.nodeType===Na;)a.nodeValue+=a.nextSibling.nodeValue,a.parentNode.removeChild(a.nextSibling);xa(b,a.nodeValue);break;case 8:try{if(k=f.exec(a.nodeValue))l=wa(k[1]),w(b,l,\"M\",d,e)&&(c[l]=R(k[2]))}catch($){}}b.sort(Aa);return b}function va(a,\nb,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw ea(\"uterdir\",b,c);a.nodeType==qa&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return y(d)}function Yc(a,b,c){return function(d,e,f,g,h){e=va(e[0],b,c);return a(d,e,f,g,h)}}function E(a,b,d,e,f,g,h,k,s){function n(a,b,c,d){if(a){c&&(a=Yc(a,c,d));a.require=E.require;a.directiveName=w;if(u===E||E.$$isolateScope)a=X(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=Yc(b,c,d));b.require=\nE.require;b.directiveName=w;if(u===E||E.$$isolateScope)b=X(b,{isolateScope:!0});k.push(b)}}function B(a,b,c,d){var e;if(L(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f=\"?\"===f[2];\"^^\"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;e||(d=\"$\"+b+\"Controller\",e=g?c.inheritedData(d):c.data(d));if(!e&&!f)throw ea(\"ctreq\",b,a);}else if(G(b))for(e=[],g=0,f=b.length;g<f;g++)e[g]=B(a,b[g],c,d);return e||null}function x(a,b,c,d,e,f){var g=ga(),h;for(h in d){var k=d[h],l={$scope:k===u||k.$$isolateScope?\ne:f,$element:a,$attrs:b,$transclude:c},s=k.controller;\"@\"==s&&(s=b[k.name]);l=p(s,l,!0,k.controllerAs);g[k.name]=l;q||a.data(\"$\"+k.name+\"Controller\",l.instance)}return g}function S(a,c,e,f,g,l){function s(a,b,c){var d;$a(a)||(c=b,b=a,a=t);q&&(d=m);c||(c=q?ja.parent():ja);return g(a,b,d,c,va)}var n,p,C,F,m,ha,ja;b===e?(f=d,ja=d.$$element):(ja=y(e),f=new aa(ja,d));u&&(F=c.$new(!0));g&&(ha=s,ha.$$boundTransclude=g);N&&(m=x(ja,f,ha,N,F,c));u&&(Z.$$addScopeInfo(ja,F,!0,!(D&&(D===u||D===u.$$originalDirective))),\nZ.$$addScopeClass(ja,!0),F.$$isolateBindings=u.$$isolateBindings,W(c,f,F,F.$$isolateBindings,u,F));if(m){var K=u||$,I;K&&m[K.name]&&(p=K.$$bindings.bindToController,(C=m[K.name])&&C.identifier&&p&&(I=C,l.$$destroyBindings=W(c,f,C.instance,p,K)));for(n in m){C=m[n];var E=C();E!==C.instance&&(C.instance=E,ja.data(\"$\"+n+\"Controller\",E),C===I&&(l.$$destroyBindings(),l.$$destroyBindings=W(c,f,E,p,K)))}}n=0;for(l=h.length;n<l;n++)p=h[n],Y(p,p.isolateScope?F:c,ja,f,p.require&&B(p.directiveName,p.require,\nja,m),ha);var va=c;u&&(u.template||null===u.templateUrl)&&(va=F);a&&a(va,e.childNodes,t,g);for(n=k.length-1;0<=n;n--)p=k[n],Y(p,p.isolateScope?F:c,ja,f,p.require&&B(p.directiveName,p.require,ja,m),ha)}s=s||{};for(var F=-Number.MAX_VALUE,$=s.newScopeDirective,N=s.controllerDirectives,u=s.newIsolateScopeDirective,D=s.templateDirective,m=s.nonTlbTranscludeDirective,K=!1,I=!1,q=s.hasElementTranscludeDirective,ba=d.$$element=y(b),E,w,v,A=e,Aa,xa=0,Ta=a.length;xa<Ta;xa++){E=a[xa];var M=E.$$start,P=E.$$end;\nM&&(ba=va(b,M,P));v=t;if(F>E.priority)break;if(v=E.scope)E.templateUrl||(H(v)?(O(\"new/isolated scope\",u||$,E,ba),u=E):O(\"new/isolated scope\",u,E,ba)),$=$||E;w=E.name;!E.templateUrl&&E.controller&&(v=E.controller,N=N||ga(),O(\"'\"+w+\"' controller\",N[w],E,ba),N[w]=E);if(v=E.transclude)K=!0,E.$$tlb||(O(\"transclusion\",m,E,ba),m=E),\"element\"==v?(q=!0,F=E.priority,v=ba,ba=d.$$element=y(U.createComment(\" \"+w+\": \"+d[w]+\" \")),b=ba[0],T(f,za.call(v,0),b),A=Z(v,e,F,g&&g.name,{nonTlbTranscludeDirective:m})):(v=\ny(Vb(b)).contents(),ba.empty(),A=Z(v,e));if(E.template)if(I=!0,O(\"template\",D,E,ba),D=E,v=z(E.template)?E.template(ba,d):E.template,v=fa(v),E.replace){g=E;v=Tb.test(v)?$c(Yb(E.templateNamespace,R(v))):[];b=v[0];if(1!=v.length||b.nodeType!==qa)throw ea(\"tplrt\",w,\"\");T(f,ba,b);Ta={$attr:{}};v=ha(b,[],Ta);var Q=a.splice(xa+1,a.length-(xa+1));u&&ad(v);a=a.concat(v).concat(Q);J(d,Ta);Ta=a.length}else ba.html(v);if(E.templateUrl)I=!0,O(\"template\",D,E,ba),D=E,E.replace&&(g=E),S=Mf(a.splice(xa,a.length-xa),\nba,d,f,K&&A,h,k,{controllerDirectives:N,newScopeDirective:$!==E&&$,newIsolateScopeDirective:u,templateDirective:D,nonTlbTranscludeDirective:m}),Ta=a.length;else if(E.compile)try{Aa=E.compile(ba,d,A),z(Aa)?n(null,Aa,M,P):Aa&&n(Aa.pre,Aa.post,M,P)}catch(Lf){c(Lf,ua(ba))}E.terminal&&(S.terminal=!0,F=Math.max(F,E.priority))}S.scope=$&&!0===$.scope;S.transcludeOnThisElement=K;S.templateOnThisElement=I;S.transclude=A;s.hasElementTranscludeDirective=q;return S}function ad(a){for(var b=0,c=a.length;b<c;b++)a[b]=\nOb(a[b],{$$isolateScope:!0})}function w(b,d,f,g,h,k,l){if(d===h)return null;h=null;if(e.hasOwnProperty(d)){var n;d=a.get(d+\"Directive\");for(var p=0,B=d.length;p<B;p++)try{n=d[p],(g===t||g>n.priority)&&-1!=n.restrict.indexOf(f)&&(k&&(n=Ob(n,{$$start:k,$$end:l})),b.push(n),h=n)}catch(x){c(x)}}return h}function A(b){if(e.hasOwnProperty(b))for(var c=a.get(b+\"Directive\"),d=0,f=c.length;d<f;d++)if(b=c[d],b.multiElement)return!0;return!1}function J(a,b){var c=b.$attr,d=a.$attr,e=a.$$element;m(a,function(d,\ne){\"$\"!=e.charAt(0)&&(b[e]&&b[e]!==d&&(d+=(\"style\"===e?\";\":\" \")+b[e]),a.$set(e,d,!0,c[e]))});m(b,function(b,f){\"class\"==f?(D(e,b),a[\"class\"]=(a[\"class\"]?a[\"class\"]+\" \":\"\")+b):\"style\"==f?(e.attr(\"style\",e.attr(\"style\")+\";\"+b),a.style=(a.style?a.style+\";\":\"\")+b):\"$\"==f.charAt(0)||a.hasOwnProperty(f)||(a[f]=b,d[f]=c[f])})}function Mf(a,b,c,e,f,g,h,k){var l=[],s,n,p=b[0],B=a.shift(),C=Ob(B,{templateUrl:null,transclude:null,replace:null,$$originalDirective:B}),x=z(B.templateUrl)?B.templateUrl(b,c):B.templateUrl,\nN=B.templateNamespace;b.empty();d(x).then(function(d){var F,u;d=fa(d);if(B.replace){d=Tb.test(d)?$c(Yb(N,R(d))):[];F=d[0];if(1!=d.length||F.nodeType!==qa)throw ea(\"tplrt\",B.name,x);d={$attr:{}};T(e,b,F);var K=ha(F,[],d);H(B.scope)&&ad(K);a=K.concat(a);J(c,d)}else F=p,b.html(d);a.unshift(C);s=E(a,F,c,f,b,B,g,h,k);m(e,function(a,c){a==F&&(e[c]=b[0])});for(n=S(b[0].childNodes,f);l.length;){d=l.shift();u=l.shift();var I=l.shift(),va=l.shift(),K=b[0];if(!d.$$destroyed){if(u!==p){var Z=u.className;k.hasElementTranscludeDirective&&\nB.replace||(K=Vb(F));T(I,y(u),K);D(y(K),Z)}u=s.transcludeOnThisElement?$(d,s.transclude,va):va;s(n,d,K,e,u,s)}}l=null});return function(a,b,c,d,e){a=e;b.$$destroyed||(l?l.push(b,c,d,a):(s.transcludeOnThisElement&&(a=$(b,s.transclude,e)),s(n,b,c,d,a,s)))}}function Aa(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function O(a,b,c,d){function e(a){return a?\" (module: \"+a+\")\":\"\"}if(b)throw ea(\"multidir\",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),\na,ua(d));}function xa(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&Z.$$addBindingClass(a);return function(a,c){var e=c.parent();b||Z.$$addBindingClass(e);Z.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function Yb(a,b){a=M(a||\"html\");switch(a){case \"svg\":case \"math\":var c=U.createElement(\"div\");c.innerHTML=\"<\"+a+\">\"+b+\"</\"+a+\">\";return c.childNodes[0].childNodes;default:return b}}function Q(a,b){if(\"srcdoc\"==b)return I.HTML;\nvar c=ta(a);if(\"xlinkHref\"==b||\"form\"==c&&\"action\"==b||\"img\"!=c&&(\"src\"==b||\"ngSrc\"==b))return I.RESOURCE_URL}function V(a,c,d,e,f){var g=Q(a,e);f=h[e]||f;var l=b(d,!0,g,f);if(l){if(\"multiple\"===e&&\"select\"===ta(a))throw ea(\"selmulti\",ua(a));c.push({priority:100,compile:function(){return{pre:function(a,c,h){c=h.$$observers||(h.$$observers={});if(k.test(e))throw ea(\"nodomevents\");var s=h[e];s!==d&&(l=s&&b(s,!0,g,f),d=s);l&&(h[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(h.$$observers&&h.$$observers[e].$$scope||\na).$watch(l,function(a,b){\"class\"===e&&a!=b?h.$updateClass(a,b):h.$set(e,a)}))}}}})}}function T(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]==d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=U.createDocumentFragment();a.appendChild(d);y.hasData(d)&&(y(c).data(y(d).data()),la?(Rb=!0,la.cleanData([d])):delete y.cache[d[y.expando]]);d=1;for(e=b.length;d<e;d++)f=\nb[d],y(f).remove(),a.appendChild(f),delete b[d];b[0]=c;b.length=1}function X(a,b){return P(function(){return a.apply(null,arguments)},a,b)}function Y(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,ua(d))}}function W(a,c,d,e,f,g){var h;m(e,function(e,g){var k=e.attrName,l=e.optional,s=e.mode,n,p,B,C;Xa.call(c,k)||(c[k]=t);switch(s){case \"@\":c[k]||l||(d[g]=t);c.$observe(k,function(a){d[g]=a});c.$$observers[k].$$scope=a;c[k]&&(d[g]=b(c[k])(a));break;case \"=\":if(l&&!c[k])break;p=u(c[k]);C=p.literal?ka:function(a,\nb){return a===b||a!==a&&b!==b};B=p.assign||function(){n=d[g]=p(a);throw ea(\"nonassign\",c[k],f.name);};n=d[g]=p(a);l=function(b){C(b,d[g])||(C(b,n)?B(a,b=d[g]):d[g]=b);return n=b};l.$stateful=!0;l=e.collection?a.$watchCollection(c[k],l):a.$watch(u(c[k],l),null,p.literal);h=h||[];h.push(l);break;case \"&\":p=u(c[k]);if(p===v&&l)break;d[g]=function(b){return p(a,b)}}});e=h?function(){for(var a=0,b=h.length;a<b;++a)h[a]()}:v;return g&&e!==v?(g.$on(\"$destroy\",e),v):e}var aa=function(a,b){if(b){var c=Object.keys(b),\nd,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a};aa.prototype={$normalize:wa,$addClass:function(a){a&&0<a.length&&B.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&B.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=bd(a,b);c&&c.length&&B.addClass(this.$$element,c);(c=bd(b,a))&&c.length&&B.removeClass(this.$$element,c)},$set:function(a,b,d,e){var f=this.$$element[0],g=Sc(f,a),h=Gf(f,a),f=a;g?(this.$$element.prop(a,b),e=g):\nh&&(this[h]=b,f=h);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Bc(a,\"-\"));g=ta(this.$$element);if(\"a\"===g&&\"href\"===a||\"img\"===g&&\"src\"===a)this[a]=b=N(b,\"src\"===a);else if(\"img\"===g&&\"srcset\"===a){for(var g=\"\",h=R(b),k=/(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/,k=/\\s/.test(h)?k:/(,)/,h=h.split(k),k=Math.floor(h.length/2),l=0;l<k;l++)var s=2*l,g=g+N(R(h[s]),!0),g=g+(\" \"+R(h[s+1]));h=R(h[2*l]).split(/\\s/);g+=N(R(h[0]),!0);2===h.length&&(g+=\" \"+R(h[1]));this[a]=b=g}!1!==d&&(null===b||\nb===t?this.$$element.removeAttr(e):this.$$element.attr(e,b));(a=this.$$observers)&&m(a[f],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=ga()),e=d[a]||(d[a]=[]);e.push(b);K.$evalAsync(function(){!e.$$inter&&c.hasOwnProperty(a)&&b(c[a])});return function(){bb(e,b)}}};var ca=b.startSymbol(),da=b.endSymbol(),fa=\"{{\"==ca||\"}}\"==da?Ya:function(a){return a.replace(/\\{\\{/g,ca).replace(/}}/g,da)},ia=/^ngAttr[A-Z]/;Z.$$addBindingInfo=n?function(a,b){var c=\na.data(\"$binding\")||[];G(b)?c=c.concat(b):c.push(b);a.data(\"$binding\",c)}:v;Z.$$addBindingClass=n?function(a){D(a,\"ng-binding\")}:v;Z.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?\"$isolateScopeNoTemplate\":\"$isolateScope\":\"$scope\",b)}:v;Z.$$addScopeClass=n?function(a,b){D(a,b?\"ng-isolate-scope\":\"ng-scope\")}:v;return Z}]}function wa(b){return hb(b.replace(Zc,\"\"))}function bd(b,a){var c=\"\",d=b.split(/\\s+/),e=a.split(/\\s+/),f=0;a:for(;f<d.length;f++){for(var g=d[f],h=0;h<e.length;h++)if(g==e[h])continue a;\nc+=(0<c.length?\" \":\"\")+g}return c}function $c(b){b=y(b);var a=b.length;if(1>=a)return b;for(;a--;)8===b[a].nodeType&&Nf.call(b,a,1);return b}function Xe(){var b={},a=!1;this.register=function(a,d){Ra(a,\"controller\");H(a)?P(b,a):b[a]=d};this.allowGlobals=function(){a=!0};this.$get=[\"$injector\",\"$window\",function(c,d){function e(a,b,c,d){if(!a||!H(a.$scope))throw J(\"$controller\")(\"noscp\",d,b);a.$scope[b]=c}return function(f,g,h,l){var k,n,r;h=!0===h;l&&L(l)&&(r=l);if(L(f)){l=f.match(Xc);if(!l)throw Of(\"ctrlfmt\",\nf);n=l[1];r=r||l[3];f=b.hasOwnProperty(n)?b[n]:Dc(g.$scope,n,!0)||(a?Dc(d,n,!0):t);Qa(f,n,!0)}if(h)return h=(G(f)?f[f.length-1]:f).prototype,k=Object.create(h||null),r&&e(g,r,k,n||f.name),P(function(){var a=c.invoke(f,k,g,n);a!==k&&(H(a)||z(a))&&(k=a,r&&e(g,r,k,n||f.name));return k},{instance:k,identifier:r});k=c.instantiate(f,g,n);r&&e(g,r,k,n||f.name);return k}}]}function Ye(){this.$get=[\"$window\",function(b){return y(b.document)}]}function Ze(){this.$get=[\"$log\",function(b){return function(a,c){b.error.apply(b,\narguments)}}]}function Zb(b){return H(b)?aa(b)?b.toISOString():db(b):b}function cf(){this.$get=function(){return function(b){if(!b)return\"\";var a=[];oc(b,function(b,d){null===b||A(b)||(G(b)?m(b,function(b,c){a.push(ma(d)+\"=\"+ma(Zb(b)))}):a.push(ma(d)+\"=\"+ma(Zb(b))))});return a.join(\"&\")}}}function df(){this.$get=function(){return function(b){function a(b,e,f){null===b||A(b)||(G(b)?m(b,function(b){a(b,e+\"[]\")}):H(b)&&!aa(b)?oc(b,function(b,c){a(b,e+(f?\"\":\"[\")+c+(f?\"\":\"]\"))}):c.push(ma(e)+\"=\"+ma(Zb(b))))}\nif(!b)return\"\";var c=[];a(b,\"\",!0);return c.join(\"&\")}}}function $b(b,a){if(L(b)){var c=b.replace(Pf,\"\").trim();if(c){var d=a(\"Content-Type\");(d=d&&0===d.indexOf(cd))||(d=(d=c.match(Qf))&&Rf[d[0]].test(c));d&&(b=wc(c))}}return b}function dd(b){var a=ga(),c;L(b)?m(b.split(\"\\n\"),function(b){c=b.indexOf(\":\");var e=M(R(b.substr(0,c)));b=R(b.substr(c+1));e&&(a[e]=a[e]?a[e]+\", \"+b:b)}):H(b)&&m(b,function(b,c){var f=M(c),g=R(b);f&&(a[f]=a[f]?a[f]+\", \"+g:g)});return a}function ed(b){var a;return function(c){a||\n(a=dd(b));return c?(c=a[M(c)],void 0===c&&(c=null),c):a}}function fd(b,a,c,d){if(z(d))return d(b,a,c);m(d,function(d){b=d(b,a,c)});return b}function bf(){var b=this.defaults={transformResponse:[$b],transformRequest:[function(a){return H(a)&&\"[object File]\"!==sa.call(a)&&\"[object Blob]\"!==sa.call(a)&&\"[object FormData]\"!==sa.call(a)?db(a):a}],headers:{common:{Accept:\"application/json, text/plain, */*\"},post:ia(ac),put:ia(ac),patch:ia(ac)},xsrfCookieName:\"XSRF-TOKEN\",xsrfHeaderName:\"X-XSRF-TOKEN\",paramSerializer:\"$httpParamSerializer\"},\na=!1;this.useApplyAsync=function(b){return w(b)?(a=!!b,this):a};var c=this.interceptors=[];this.$get=[\"$httpBackend\",\"$$cookieReader\",\"$cacheFactory\",\"$rootScope\",\"$q\",\"$injector\",function(d,e,f,g,h,l){function k(a){function c(a){var b=P({},a);b.data=a.data?fd(a.data,a.headers,a.status,e.transformResponse):a.data;a=a.status;return 200<=a&&300>a?b:h.reject(b)}function d(a,b){var c,e={};m(a,function(a,d){z(a)?(c=a(b),null!=c&&(e[d]=c)):e[d]=a});return e}if(!ca.isObject(a))throw J(\"$http\")(\"badreq\",\na);var e=P({method:\"get\",transformRequest:b.transformRequest,transformResponse:b.transformResponse,paramSerializer:b.paramSerializer},a);e.headers=function(a){var c=b.headers,e=P({},a.headers),f,g,h,c=P({},c.common,c[M(a.method)]);a:for(f in c){g=M(f);for(h in e)if(M(h)===g)continue a;e[f]=c[f]}return d(e,ia(a))}(a);e.method=rb(e.method);e.paramSerializer=L(e.paramSerializer)?l.get(e.paramSerializer):e.paramSerializer;var f=[function(a){var d=a.headers,e=fd(a.data,ed(d),t,a.transformRequest);A(e)&&\nm(d,function(a,b){\"content-type\"===M(b)&&delete d[b]});A(a.withCredentials)&&!A(b.withCredentials)&&(a.withCredentials=b.withCredentials);return n(a,e).then(c,c)},t],g=h.when(e);for(m(x,function(a){(a.request||a.requestError)&&f.unshift(a.request,a.requestError);(a.response||a.responseError)&&f.push(a.response,a.responseError)});f.length;){a=f.shift();var k=f.shift(),g=g.then(a,k)}g.success=function(a){Qa(a,\"fn\");g.then(function(b){a(b.data,b.status,b.headers,e)});return g};g.error=function(a){Qa(a,\n\"fn\");g.then(null,function(b){a(b.data,b.status,b.headers,e)});return g};return g}function n(c,f){function l(b,c,d,e){function f(){n(c,b,d,e)}N&&(200<=b&&300>b?N.put(S,[b,c,dd(d),e]):N.remove(S));a?g.$applyAsync(f):(f(),g.$$phase||g.$apply())}function n(a,b,d,e){b=Math.max(b,0);(200<=b&&300>b?I.resolve:I.reject)({data:a,status:b,headers:ed(d),config:c,statusText:e})}function x(a){n(a.data,a.status,ia(a.headers()),a.statusText)}function m(){var a=k.pendingRequests.indexOf(c);-1!==a&&k.pendingRequests.splice(a,\n1)}var I=h.defer(),B=I.promise,N,D,q=c.headers,S=r(c.url,c.paramSerializer(c.params));k.pendingRequests.push(c);B.then(m,m);!c.cache&&!b.cache||!1===c.cache||\"GET\"!==c.method&&\"JSONP\"!==c.method||(N=H(c.cache)?c.cache:H(b.cache)?b.cache:s);N&&(D=N.get(S),w(D)?D&&z(D.then)?D.then(x,x):G(D)?n(D[1],D[0],ia(D[2]),D[3]):n(D,200,{},\"OK\"):N.put(S,B));A(D)&&((D=gd(c.url)?e()[c.xsrfCookieName||b.xsrfCookieName]:t)&&(q[c.xsrfHeaderName||b.xsrfHeaderName]=D),d(c.method,S,f,l,q,c.timeout,c.withCredentials,c.responseType));\nreturn B}function r(a,b){0<b.length&&(a+=(-1==a.indexOf(\"?\")?\"?\":\"&\")+b);return a}var s=f(\"$http\");b.paramSerializer=L(b.paramSerializer)?l.get(b.paramSerializer):b.paramSerializer;var x=[];m(c,function(a){x.unshift(L(a)?l.get(a):l.invoke(a))});k.pendingRequests=[];(function(a){m(arguments,function(a){k[a]=function(b,c){return k(P({},c||{},{method:a,url:b}))}})})(\"get\",\"delete\",\"head\",\"jsonp\");(function(a){m(arguments,function(a){k[a]=function(b,c,d){return k(P({},d||{},{method:a,url:b,data:c}))}})})(\"post\",\n\"put\",\"patch\");k.defaults=b;return k}]}function Sf(){return new O.XMLHttpRequest}function ef(){this.$get=[\"$browser\",\"$window\",\"$document\",function(b,a,c){return Tf(b,Sf,b.defer,a.angular.callbacks,c[0])}]}function Tf(b,a,c,d,e){function f(a,b,c){var f=e.createElement(\"script\"),n=null;f.type=\"text/javascript\";f.src=a;f.async=!0;n=function(a){f.removeEventListener(\"load\",n,!1);f.removeEventListener(\"error\",n,!1);e.body.removeChild(f);f=null;var g=-1,x=\"unknown\";a&&(\"load\"!==a.type||d[b].called||(a=\n{type:\"error\"}),x=a.type,g=\"error\"===a.type?404:200);c&&c(g,x)};f.addEventListener(\"load\",n,!1);f.addEventListener(\"error\",n,!1);e.body.appendChild(f);return n}return function(e,h,l,k,n,r,s,x){function C(){p&&p();K&&K.abort()}function F(a,d,e,f,g){I!==t&&c.cancel(I);p=K=null;a(d,e,f,g);b.$$completeOutstandingRequest(v)}b.$$incOutstandingRequestCount();h=h||b.url();if(\"jsonp\"==M(e)){var u=\"_\"+(d.counter++).toString(36);d[u]=function(a){d[u].data=a;d[u].called=!0};var p=f(h.replace(\"JSON_CALLBACK\",\n\"angular.callbacks.\"+u),u,function(a,b){F(k,a,d[u].data,\"\",b);d[u]=v})}else{var K=a();K.open(e,h,!0);m(n,function(a,b){w(a)&&K.setRequestHeader(b,a)});K.onload=function(){var a=K.statusText||\"\",b=\"response\"in K?K.response:K.responseText,c=1223===K.status?204:K.status;0===c&&(c=b?200:\"file\"==Ba(h).protocol?404:0);F(k,c,b,K.getAllResponseHeaders(),a)};e=function(){F(k,-1,null,null,\"\")};K.onerror=e;K.onabort=e;s&&(K.withCredentials=!0);if(x)try{K.responseType=x}catch(q){if(\"json\"!==x)throw q;}K.send(l)}if(0<\nr)var I=c(C,r);else r&&z(r.then)&&r.then(C)}}function $e(){var b=\"{{\",a=\"}}\";this.startSymbol=function(a){return a?(b=a,this):b};this.endSymbol=function(b){return b?(a=b,this):a};this.$get=[\"$parse\",\"$exceptionHandler\",\"$sce\",function(c,d,e){function f(a){return\"\\\\\\\\\\\\\"+a}function g(c){return c.replace(n,b).replace(r,a)}function h(f,h,n,r){function u(a){try{var b=a;a=n?e.getTrusted(n,b):e.valueOf(b);var c;if(r&&!w(a))c=a;else if(null==a)c=\"\";else{switch(typeof a){case \"string\":break;case \"number\":a=\n\"\"+a;break;default:a=db(a)}c=a}return c}catch(g){d(Ka.interr(f,g))}}r=!!r;for(var p,m,q=0,I=[],B=[],N=f.length,D=[],t=[];q<N;)if(-1!=(p=f.indexOf(b,q))&&-1!=(m=f.indexOf(a,p+l)))q!==p&&D.push(g(f.substring(q,p))),q=f.substring(p+l,m),I.push(q),B.push(c(q,u)),q=m+k,t.push(D.length),D.push(\"\");else{q!==N&&D.push(g(f.substring(q)));break}n&&1<D.length&&Ka.throwNoconcat(f);if(!h||I.length){var S=function(a){for(var b=0,c=I.length;b<c;b++){if(r&&A(a[b]))return;D[t[b]]=a[b]}return D.join(\"\")};return P(function(a){var b=\n0,c=I.length,e=Array(c);try{for(;b<c;b++)e[b]=B[b](a);return S(e)}catch(g){d(Ka.interr(f,g))}},{exp:f,expressions:I,$$watchDelegate:function(a,b){var c;return a.$watchGroup(B,function(d,e){var f=S(d);z(b)&&b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=b.length,k=a.length,n=new RegExp(b.replace(/./g,f),\"g\"),r=new RegExp(a.replace(/./g,f),\"g\");h.startSymbol=function(){return b};h.endSymbol=function(){return a};return h}]}function af(){this.$get=[\"$rootScope\",\"$window\",\"$q\",\"$$q\",function(b,a,c,d){function e(e,\nh,l,k){var n=4<arguments.length,r=n?za.call(arguments,4):[],s=a.setInterval,x=a.clearInterval,C=0,F=w(k)&&!k,u=(F?d:c).defer(),p=u.promise;l=w(l)?l:0;p.then(null,null,n?function(){e.apply(null,r)}:e);p.$$intervalId=s(function(){u.notify(C++);0<l&&C>=l&&(u.resolve(C),x(p.$$intervalId),delete f[p.$$intervalId]);F||b.$apply()},h);f[p.$$intervalId]=u;return p}var f={};e.cancel=function(b){return b&&b.$$intervalId in f?(f[b.$$intervalId].reject(\"canceled\"),a.clearInterval(b.$$intervalId),delete f[b.$$intervalId],\n!0):!1};return e}]}function ge(){this.$get=function(){return{id:\"en-us\",NUMBER_FORMATS:{DECIMAL_SEP:\".\",GROUP_SEP:\",\",PATTERNS:[{minInt:1,minFrac:0,maxFrac:3,posPre:\"\",posSuf:\"\",negPre:\"-\",negSuf:\"\",gSize:3,lgSize:3},{minInt:1,minFrac:2,maxFrac:2,posPre:\"\\u00a4\",posSuf:\"\",negPre:\"(\\u00a4\",negSuf:\")\",gSize:3,lgSize:3}],CURRENCY_SYM:\"$\"},DATETIME_FORMATS:{MONTH:\"January February March April May June July August September October November December\".split(\" \"),SHORTMONTH:\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\nDAY:\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),SHORTDAY:\"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),AMPMS:[\"AM\",\"PM\"],medium:\"MMM d, y h:mm:ss a\",\"short\":\"M/d/yy h:mm a\",fullDate:\"EEEE, MMMM d, y\",longDate:\"MMMM d, y\",mediumDate:\"MMM d, y\",shortDate:\"M/d/yy\",mediumTime:\"h:mm:ss a\",shortTime:\"h:mm a\",ERANAMES:[\"Before Christ\",\"Anno Domini\"],ERAS:[\"BC\",\"AD\"]},pluralCat:function(b){return 1===b?\"one\":\"other\"}}}}function bc(b){b=b.split(\"/\");for(var a=b.length;a--;)b[a]=ob(b[a]);\nreturn b.join(\"/\")}function hd(b,a){var c=Ba(b);a.$$protocol=c.protocol;a.$$host=c.hostname;a.$$port=W(c.port)||Uf[c.protocol]||null}function id(b,a){var c=\"/\"!==b.charAt(0);c&&(b=\"/\"+b);var d=Ba(b);a.$$path=decodeURIComponent(c&&\"/\"===d.pathname.charAt(0)?d.pathname.substring(1):d.pathname);a.$$search=zc(d.search);a.$$hash=decodeURIComponent(d.hash);a.$$path&&\"/\"!=a.$$path.charAt(0)&&(a.$$path=\"/\"+a.$$path)}function ya(b,a){if(0===a.indexOf(b))return a.substr(b.length)}function Ja(b){var a=b.indexOf(\"#\");\nreturn-1==a?b:b.substr(0,a)}function Bb(b){return b.replace(/(#.+)|#$/,\"$1\")}function cc(b){return b.substr(0,Ja(b).lastIndexOf(\"/\")+1)}function dc(b,a){this.$$html5=!0;a=a||\"\";var c=cc(b);hd(b,this);this.$$parse=function(a){var b=ya(c,a);if(!L(b))throw Cb(\"ipthprfx\",a,c);id(b,this);this.$$path||(this.$$path=\"/\");this.$$compose()};this.$$compose=function(){var a=Qb(this.$$search),b=this.$$hash?\"#\"+ob(this.$$hash):\"\";this.$$url=bc(this.$$path)+(a?\"?\"+a:\"\")+b;this.$$absUrl=c+this.$$url.substr(1)};this.$$parseLinkUrl=\nfunction(d,e){if(e&&\"#\"===e[0])return this.hash(e.slice(1)),!0;var f,g;(f=ya(b,d))!==t?(g=f,g=(f=ya(a,f))!==t?c+(ya(\"/\",f)||f):b+g):(f=ya(c,d))!==t?g=c+f:c==d+\"/\"&&(g=c);g&&this.$$parse(g);return!!g}}function ec(b,a){var c=cc(b);hd(b,this);this.$$parse=function(d){var e=ya(b,d)||ya(c,d),f;A(e)||\"#\"!==e.charAt(0)?this.$$html5?f=e:(f=\"\",A(e)&&(b=d,this.replace())):(f=ya(a,e),A(f)&&(f=e));id(f,this);d=this.$$path;var e=b,g=/^\\/[A-Z]:(\\/.*)/;0===f.indexOf(e)&&(f=f.replace(e,\"\"));g.exec(f)||(d=(f=g.exec(d))?\nf[1]:d);this.$$path=d;this.$$compose()};this.$$compose=function(){var c=Qb(this.$$search),e=this.$$hash?\"#\"+ob(this.$$hash):\"\";this.$$url=bc(this.$$path)+(c?\"?\"+c:\"\")+e;this.$$absUrl=b+(this.$$url?a+this.$$url:\"\")};this.$$parseLinkUrl=function(a,c){return Ja(b)==Ja(a)?(this.$$parse(a),!0):!1}}function jd(b,a){this.$$html5=!0;ec.apply(this,arguments);var c=cc(b);this.$$parseLinkUrl=function(d,e){if(e&&\"#\"===e[0])return this.hash(e.slice(1)),!0;var f,g;b==Ja(d)?f=d:(g=ya(c,d))?f=b+a+g:c===d+\"/\"&&(f=\nc);f&&this.$$parse(f);return!!f};this.$$compose=function(){var c=Qb(this.$$search),e=this.$$hash?\"#\"+ob(this.$$hash):\"\";this.$$url=bc(this.$$path)+(c?\"?\"+c:\"\")+e;this.$$absUrl=b+a+this.$$url}}function Db(b){return function(){return this[b]}}function kd(b,a){return function(c){if(A(c))return this[b];this[b]=a(c);this.$$compose();return this}}function ff(){var b=\"\",a={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(a){return w(a)?(b=a,this):b};this.html5Mode=function(b){return ab(b)?\n(a.enabled=b,this):H(b)?(ab(b.enabled)&&(a.enabled=b.enabled),ab(b.requireBase)&&(a.requireBase=b.requireBase),ab(b.rewriteLinks)&&(a.rewriteLinks=b.rewriteLinks),this):a};this.$get=[\"$rootScope\",\"$browser\",\"$sniffer\",\"$rootElement\",\"$window\",function(c,d,e,f,g){function h(a,b,c){var e=k.url(),f=k.$$state;try{d.url(a,b,c),k.$$state=d.state()}catch(g){throw k.url(e),k.$$state=f,g;}}function l(a,b){c.$broadcast(\"$locationChangeSuccess\",k.absUrl(),a,k.$$state,b)}var k,n;n=d.baseHref();var r=d.url(),\ns;if(a.enabled){if(!n&&a.requireBase)throw Cb(\"nobase\");s=r.substring(0,r.indexOf(\"/\",r.indexOf(\"//\")+2))+(n||\"/\");n=e.history?dc:jd}else s=Ja(r),n=ec;k=new n(s,\"#\"+b);k.$$parseLinkUrl(r,r);k.$$state=d.state();var x=/^\\s*(javascript|mailto):/i;f.on(\"click\",function(b){if(a.rewriteLinks&&!b.ctrlKey&&!b.metaKey&&!b.shiftKey&&2!=b.which&&2!=b.button){for(var e=y(b.target);\"a\"!==ta(e[0]);)if(e[0]===f[0]||!(e=e.parent())[0])return;var h=e.prop(\"href\"),l=e.attr(\"href\")||e.attr(\"xlink:href\");H(h)&&\"[object SVGAnimatedString]\"===\nh.toString()&&(h=Ba(h.animVal).href);x.test(h)||!h||e.attr(\"target\")||b.isDefaultPrevented()||!k.$$parseLinkUrl(h,l)||(b.preventDefault(),k.absUrl()!=d.url()&&(c.$apply(),g.angular[\"ff-684208-preventDefault\"]=!0))}});Bb(k.absUrl())!=Bb(r)&&d.url(k.absUrl(),!0);var C=!0;d.onUrlChange(function(a,b){c.$evalAsync(function(){var d=k.absUrl(),e=k.$$state,f;k.$$parse(a);k.$$state=b;f=c.$broadcast(\"$locationChangeStart\",a,d,b,e).defaultPrevented;k.absUrl()===a&&(f?(k.$$parse(d),k.$$state=e,h(d,!1,e)):(C=\n!1,l(d,e)))});c.$$phase||c.$digest()});c.$watch(function(){var a=Bb(d.url()),b=Bb(k.absUrl()),f=d.state(),g=k.$$replace,n=a!==b||k.$$html5&&e.history&&f!==k.$$state;if(C||n)C=!1,c.$evalAsync(function(){var b=k.absUrl(),d=c.$broadcast(\"$locationChangeStart\",b,a,k.$$state,f).defaultPrevented;k.absUrl()===b&&(d?(k.$$parse(a),k.$$state=f):(n&&h(b,g,f===k.$$state?null:k.$$state),l(a,f)))});k.$$replace=!1});return k}]}function gf(){var b=!0,a=this;this.debugEnabled=function(a){return w(a)?(b=a,this):b};\nthis.$get=[\"$window\",function(c){function d(a){a instanceof Error&&(a.stack?a=a.message&&-1===a.stack.indexOf(a.message)?\"Error: \"+a.message+\"\\n\"+a.stack:a.stack:a.sourceURL&&(a=a.message+\"\\n\"+a.sourceURL+\":\"+a.line));return a}function e(a){var b=c.console||{},e=b[a]||b.log||v;a=!1;try{a=!!e.apply}catch(l){}return a?function(){var a=[];m(arguments,function(b){a.push(d(b))});return e.apply(b,a)}:function(a,b){e(a,null==b?\"\":b)}}return{log:e(\"log\"),info:e(\"info\"),warn:e(\"warn\"),error:e(\"error\"),debug:function(){var c=\ne(\"debug\");return function(){b&&c.apply(a,arguments)}}()}}]}function Ca(b,a){if(\"__defineGetter__\"===b||\"__defineSetter__\"===b||\"__lookupGetter__\"===b||\"__lookupSetter__\"===b||\"__proto__\"===b)throw da(\"isecfld\",a);return b}function oa(b,a){if(b){if(b.constructor===b)throw da(\"isecfn\",a);if(b.window===b)throw da(\"isecwindow\",a);if(b.children&&(b.nodeName||b.prop&&b.attr&&b.find))throw da(\"isecdom\",a);if(b===Object)throw da(\"isecobj\",a);}return b}function ld(b,a){if(b){if(b.constructor===b)throw da(\"isecfn\",\na);if(b===Vf||b===Wf||b===Xf)throw da(\"isecff\",a);}}function Yf(b,a){return\"undefined\"!==typeof b?b:a}function md(b,a){return\"undefined\"===typeof b?a:\"undefined\"===typeof a?b:b+a}function T(b,a){var c,d;switch(b.type){case q.Program:c=!0;m(b.body,function(b){T(b.expression,a);c=c&&b.expression.constant});b.constant=c;break;case q.Literal:b.constant=!0;b.toWatch=[];break;case q.UnaryExpression:T(b.argument,a);b.constant=b.argument.constant;b.toWatch=b.argument.toWatch;break;case q.BinaryExpression:T(b.left,\na);T(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=b.left.toWatch.concat(b.right.toWatch);break;case q.LogicalExpression:T(b.left,a);T(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=b.constant?[]:[b];break;case q.ConditionalExpression:T(b.test,a);T(b.alternate,a);T(b.consequent,a);b.constant=b.test.constant&&b.alternate.constant&&b.consequent.constant;b.toWatch=b.constant?[]:[b];break;case q.Identifier:b.constant=!1;b.toWatch=[b];break;case q.MemberExpression:T(b.object,\na);b.computed&&T(b.property,a);b.constant=b.object.constant&&(!b.computed||b.property.constant);b.toWatch=[b];break;case q.CallExpression:c=b.filter?!a(b.callee.name).$stateful:!1;d=[];m(b.arguments,function(b){T(b,a);c=c&&b.constant;b.constant||d.push.apply(d,b.toWatch)});b.constant=c;b.toWatch=b.filter&&!a(b.callee.name).$stateful?d:[b];break;case q.AssignmentExpression:T(b.left,a);T(b.right,a);b.constant=b.left.constant&&b.right.constant;b.toWatch=[b];break;case q.ArrayExpression:c=!0;d=[];m(b.elements,\nfunction(b){T(b,a);c=c&&b.constant;b.constant||d.push.apply(d,b.toWatch)});b.constant=c;b.toWatch=d;break;case q.ObjectExpression:c=!0;d=[];m(b.properties,function(b){T(b.value,a);c=c&&b.value.constant;b.value.constant||d.push.apply(d,b.value.toWatch)});b.constant=c;b.toWatch=d;break;case q.ThisExpression:b.constant=!1,b.toWatch=[]}}function nd(b){if(1==b.length){b=b[0].expression;var a=b.toWatch;return 1!==a.length?a:a[0]!==b?a:t}}function od(b){return b.type===q.Identifier||b.type===q.MemberExpression}\nfunction pd(b){if(1===b.body.length&&od(b.body[0].expression))return{type:q.AssignmentExpression,left:b.body[0].expression,right:{type:q.NGValueParameter},operator:\"=\"}}function qd(b){return 0===b.body.length||1===b.body.length&&(b.body[0].expression.type===q.Literal||b.body[0].expression.type===q.ArrayExpression||b.body[0].expression.type===q.ObjectExpression)}function rd(b,a){this.astBuilder=b;this.$filter=a}function sd(b,a){this.astBuilder=b;this.$filter=a}function Eb(b,a,c,d){oa(b,d);a=a.split(\".\");\nfor(var e,f=0;1<a.length;f++){e=Ca(a.shift(),d);var g=oa(b[e],d);g||(g={},b[e]=g);b=g}e=Ca(a.shift(),d);oa(b[e],d);return b[e]=c}function Fb(b){return\"constructor\"==b}function fc(b){return z(b.valueOf)?b.valueOf():Zf.call(b)}function hf(){var b=ga(),a=ga();this.$get=[\"$filter\",\"$sniffer\",function(c,d){function e(a,b){return null==a||null==b?a===b:\"object\"===typeof a&&(a=fc(a),\"object\"===typeof a)?!1:a===b||a!==a&&b!==b}function f(a,b,c,d,f){var g=d.inputs,h;if(1===g.length){var k=e,g=g[0];return a.$watch(function(a){var b=\ng(a);e(b,k)||(h=d(a,t,t,[b]),k=b&&fc(b));return h},b,c,f)}for(var l=[],n=[],r=0,m=g.length;r<m;r++)l[r]=e,n[r]=null;return a.$watch(function(a){for(var b=!1,c=0,f=g.length;c<f;c++){var k=g[c](a);if(b||(b=!e(k,l[c])))n[c]=k,l[c]=k&&fc(k)}b&&(h=d(a,t,t,n));return h},b,c,f)}function g(a,b,c,d){var e,f;return e=a.$watch(function(a){return d(a)},function(a,c,d){f=a;z(b)&&b.apply(this,arguments);w(a)&&d.$$postDigest(function(){w(f)&&e()})},c)}function h(a,b,c,d){function e(a){var b=!0;m(a,function(a){w(a)||\n(b=!1)});return b}var f,g;return f=a.$watch(function(a){return d(a)},function(a,c,d){g=a;z(b)&&b.call(this,a,c,d);e(a)&&d.$$postDigest(function(){e(g)&&f()})},c)}function l(a,b,c,d){var e;return e=a.$watch(function(a){return d(a)},function(a,c,d){z(b)&&b.apply(this,arguments);e()},c)}function k(a,b){if(!b)return a;var c=a.$$watchDelegate,c=c!==h&&c!==g?function(c,d,e,f){e=a(c,d,e,f);return b(e,c,d)}:function(c,d,e,f){e=a(c,d,e,f);c=b(e,c,d);return w(e)?c:e};a.$$watchDelegate&&a.$$watchDelegate!==\nf?c.$$watchDelegate=a.$$watchDelegate:b.$stateful||(c.$$watchDelegate=f,c.inputs=a.inputs?a.inputs:[a]);return c}var n={csp:d.csp,expensiveChecks:!1},r={csp:d.csp,expensiveChecks:!0};return function(d,e,C){var m,u,p;switch(typeof d){case \"string\":p=d=d.trim();var q=C?a:b;m=q[p];m||(\":\"===d.charAt(0)&&\":\"===d.charAt(1)&&(u=!0,d=d.substring(2)),C=C?r:n,m=new gc(C),m=(new hc(m,c,C)).parse(d),m.constant?m.$$watchDelegate=l:u?m.$$watchDelegate=m.literal?h:g:m.inputs&&(m.$$watchDelegate=f),q[p]=m);return k(m,\ne);case \"function\":return k(d,e);default:return v}}}]}function kf(){this.$get=[\"$rootScope\",\"$exceptionHandler\",function(b,a){return td(function(a){b.$evalAsync(a)},a)}]}function lf(){this.$get=[\"$browser\",\"$exceptionHandler\",function(b,a){return td(function(a){b.defer(a)},a)}]}function td(b,a){function c(a,b,c){function d(b){return function(c){e||(e=!0,b.call(a,c))}}var e=!1;return[d(b),d(c)]}function d(){this.$$state={status:0}}function e(a,b){return function(c){b.call(a,c)}}function f(c){!c.processScheduled&&\nc.pending&&(c.processScheduled=!0,b(function(){var b,d,e;e=c.pending;c.processScheduled=!1;c.pending=t;for(var f=0,g=e.length;f<g;++f){d=e[f][0];b=e[f][c.status];try{z(b)?d.resolve(b(c.value)):1===c.status?d.resolve(c.value):d.reject(c.value)}catch(h){d.reject(h),a(h)}}}))}function g(){this.promise=new d;this.resolve=e(this,this.resolve);this.reject=e(this,this.reject);this.notify=e(this,this.notify)}var h=J(\"$q\",TypeError);d.prototype={then:function(a,b,c){var d=new g;this.$$state.pending=this.$$state.pending||\n[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&f(this.$$state);return d.promise},\"catch\":function(a){return this.then(null,a)},\"finally\":function(a,b){return this.then(function(b){return k(b,!0,a)},function(b){return k(b,!1,a)},b)}};g.prototype={resolve:function(a){this.promise.$$state.status||(a===this.promise?this.$$reject(h(\"qcycle\",a)):this.$$resolve(a))},$$resolve:function(b){var d,e;e=c(this,this.$$resolve,this.$$reject);try{if(H(b)||z(b))d=b&&b.then;z(d)?(this.promise.$$state.status=\n-1,d.call(b,e[0],e[1],this.notify)):(this.promise.$$state.value=b,this.promise.$$state.status=1,f(this.promise.$$state))}catch(g){e[1](g),a(g)}},reject:function(a){this.promise.$$state.status||this.$$reject(a)},$$reject:function(a){this.promise.$$state.value=a;this.promise.$$state.status=2;f(this.promise.$$state)},notify:function(c){var d=this.promise.$$state.pending;0>=this.promise.$$state.status&&d&&d.length&&b(function(){for(var b,e,f=0,g=d.length;f<g;f++){e=d[f][0];b=d[f][3];try{e.notify(z(b)?\nb(c):c)}catch(h){a(h)}}})}};var l=function(a,b){var c=new g;b?c.resolve(a):c.reject(a);return c.promise},k=function(a,b,c){var d=null;try{z(c)&&(d=c())}catch(e){return l(e,!1)}return d&&z(d.then)?d.then(function(){return l(a,b)},function(a){return l(a,!1)}):l(a,b)},n=function(a,b,c,d){var e=new g;e.resolve(a);return e.promise.then(b,c,d)},r=function x(a){if(!z(a))throw h(\"norslvr\",a);if(!(this instanceof x))return new x(a);var b=new g;a(function(a){b.resolve(a)},function(a){b.reject(a)});return b.promise};\nr.defer=function(){return new g};r.reject=function(a){var b=new g;b.reject(a);return b.promise};r.when=n;r.resolve=n;r.all=function(a){var b=new g,c=0,d=G(a)?[]:{};m(a,function(a,e){c++;n(a).then(function(a){d.hasOwnProperty(e)||(d[e]=a,--c||b.resolve(d))},function(a){d.hasOwnProperty(e)||b.reject(a)})});0===c&&b.resolve(d);return b.promise};return r}function uf(){this.$get=[\"$window\",\"$timeout\",function(b,a){function c(){for(var a=0;a<n.length;a++){var b=n[a];b&&(n[a]=null,b())}k=n.length=0}function d(a){var b=\nn.length;k++;n.push(a);0===b&&(l=h(c));return function(){0<=b&&(b=n[b]=null,0===--k&&l&&(l(),l=null,n.length=0))}}var e=b.requestAnimationFrame||b.webkitRequestAnimationFrame,f=b.cancelAnimationFrame||b.webkitCancelAnimationFrame||b.webkitCancelRequestAnimationFrame,g=!!e,h=g?function(a){var b=e(a);return function(){f(b)}}:function(b){var c=a(b,16.66,!1);return function(){a.cancel(c)}};d.supported=g;var l,k=0,n=[];return d}]}function jf(){function b(a){function b(){this.$$watchers=this.$$nextSibling=\nthis.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++nb;this.$$ChildScope=null}b.prototype=a;return b}var a=10,c=J(\"$rootScope\"),d=null,e=null;this.digestTtl=function(b){arguments.length&&(a=b);return a};this.$get=[\"$injector\",\"$exceptionHandler\",\"$parse\",\"$browser\",function(f,g,h,l){function k(a){a.currentScope.$$destroyed=!0}function n(){this.$id=++nb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=\nthis.$$childTail=null;this.$root=this;this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function r(a){if(p.$$phase)throw c(\"inprog\",p.$$phase);p.$$phase=a}function s(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function x(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function q(){}function F(){for(;I.length;)try{I.shift()()}catch(a){g(a)}e=null}function u(){null===e&&(e=\nl.defer(function(){p.$apply(F)}))}n.prototype={constructor:n,$new:function(a,c){var d;c=c||this;a?(d=new n,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=b(this)),d=new this.$$ChildScope);d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(a||c!=this)&&d.$on(\"$destroy\",k);return d},$watch:function(a,b,c,e){var f=h(a);if(f.$$watchDelegate)return f.$$watchDelegate(this,b,c,f,a);var g=this,k=g.$$watchers,l=\n{fn:b,last:q,get:f,exp:e||a,eq:!!c};d=null;z(b)||(l.fn=v);k||(k=g.$$watchers=[]);k.unshift(l);s(this,1);return function(){0<=bb(k,l)&&s(g,-1);d=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});m(a,function(a,b){var k=g.$watch(a,function(a,\nf){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!A(e)){if(H(e))if(Ea(e))for(f!==r&&(f=r,m=f.length=0,l++),a=e.length,m!==a&&(l++,f.length=m=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==s&&(f=s={},m=0,l++);a=0;for(b in e)e.hasOwnProperty(b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(m++,f[b]=g,l++));if(m>a)for(b in l++,f)e.hasOwnProperty(b)||\n(m--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,g,k=1<b.length,l=0,n=h(a,c),r=[],s={},p=!0,m=0;return this.$watch(n,function(){p?(p=!1,b(e,e,d)):b(e,g,d);if(k)if(H(e))if(Ea(e)){g=Array(e.length);for(var a=0;a<e.length;a++)g[a]=e[a]}else for(a in g={},e)Xa.call(e,a)&&(g[a]=e[a]);else g=e})},$digest:function(){var b,f,h,k,n,s,m=a,x,u=[],E,I;r(\"$digest\");l.$$checkUrlChange();this===p&&null!==e&&(l.defer.cancel(e),F());d=null;do{s=!1;for(x=this;t.length;){try{I=t.shift(),\nI.scope.$eval(I.expression,I.locals)}catch(v){g(v)}d=null}a:do{if(k=x.$$watchers)for(n=k.length;n--;)try{if(b=k[n])if((f=b.get(x))!==(h=b.last)&&!(b.eq?ka(f,h):\"number\"===typeof f&&\"number\"===typeof h&&isNaN(f)&&isNaN(h)))s=!0,d=b,b.last=b.eq?fa(f,null):f,b.fn(f,h===q?f:h,x),5>m&&(E=4-m,u[E]||(u[E]=[]),u[E].push({msg:z(b.exp)?\"fn: \"+(b.exp.name||b.exp.toString()):b.exp,newVal:f,oldVal:h}));else if(b===d){s=!1;break a}}catch(A){g(A)}if(!(k=x.$$watchersCount&&x.$$childHead||x!==this&&x.$$nextSibling))for(;x!==\nthis&&!(k=x.$$nextSibling);)x=x.$parent}while(x=k);if((s||t.length)&&!m--)throw p.$$phase=null,c(\"infdig\",a,u);}while(s||t.length);for(p.$$phase=null;w.length;)try{w.shift()()}catch(y){g(y)}},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast(\"$destroy\");this.$$destroyed=!0;this===p&&l.$$applicationDestroyed();s(this,-this.$$watchersCount);for(var b in this.$$listenerCount)x(this,this.$$listenerCount[b],b);a&&a.$$childHead==this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail==\nthis&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=v;this.$on=this.$watch=this.$watchGroup=function(){return v};this.$$listeners={};this.$parent=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=this.$root=this.$$watchers=null}},$eval:function(a,b){return h(a)(this,b)},\n$evalAsync:function(a,b){p.$$phase||t.length||l.defer(function(){t.length&&p.$digest()});t.push({scope:this,expression:a,locals:b})},$$postDigest:function(a){w.push(a)},$apply:function(a){try{return r(\"$apply\"),this.$eval(a)}catch(b){g(b)}finally{p.$$phase=null;try{p.$digest()}catch(c){throw g(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&I.push(b);u()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||\n(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(c[d]=null,x(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,f=!1,h={name:a,targetScope:e,stopPropagation:function(){f=!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=cb([h],arguments,1),l,n;do{d=e.$$listeners[a]||c;h.currentScope=e;l=0;for(n=d.length;l<n;l++)if(d[l])try{d[l].apply(null,k)}catch(r){g(r)}else d.splice(l,1),l--,n--;if(f)return h.currentScope=\nnull,h;e=e.$parent}while(e);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var f=cb([e],arguments,1),h,k;c=d;){e.currentScope=c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,f)}catch(l){g(l)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=\nc.$$nextSibling);)c=c.$parent}e.currentScope=null;return e}};var p=new n,t=p.$$asyncQueue=[],w=p.$$postDigestQueue=[],I=p.$$applyAsyncQueue=[];return p}]}function he(){var b=/^\\s*(https?|ftp|mailto|tel|file):/,a=/^\\s*((https?|ftp|file|blob):|data:image\\/)/;this.aHrefSanitizationWhitelist=function(a){return w(a)?(b=a,this):b};this.imgSrcSanitizationWhitelist=function(b){return w(b)?(a=b,this):a};this.$get=function(){return function(c,d){var e=d?a:b,f;f=Ba(c).href;return\"\"===f||f.match(e)?c:\"unsafe:\"+\nf}}}function $f(b){if(\"self\"===b)return b;if(L(b)){if(-1<b.indexOf(\"***\"))throw Da(\"iwcard\",b);b=ud(b).replace(\"\\\\*\\\\*\",\".*\").replace(\"\\\\*\",\"[^:/.?&;]*\");return new RegExp(\"^\"+b+\"$\")}if(Za(b))return new RegExp(\"^\"+b.source+\"$\");throw Da(\"imatcher\");}function vd(b){var a=[];w(b)&&m(b,function(b){a.push($f(b))});return a}function nf(){this.SCE_CONTEXTS=pa;var b=[\"self\"],a=[];this.resourceUrlWhitelist=function(a){arguments.length&&(b=vd(a));return b};this.resourceUrlBlacklist=function(b){arguments.length&&\n(a=vd(b));return a};this.$get=[\"$injector\",function(c){function d(a,b){return\"self\"===a?gd(b):!!a.exec(b.href)}function e(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var f=function(a){throw Da(\"unsafe\");};c.has(\"$sanitize\")&&(f=c.get(\"$sanitize\"));var g=e(),h={};h[pa.HTML]=e(g);h[pa.CSS]=e(g);h[pa.URL]=\ne(g);h[pa.JS]=e(g);h[pa.RESOURCE_URL]=e(h[pa.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw Da(\"icontext\",a,b);if(null===b||b===t||\"\"===b)return b;if(\"string\"!==typeof b)throw Da(\"itype\",a);return new c(b)},getTrusted:function(c,e){if(null===e||e===t||\"\"===e)return e;var g=h.hasOwnProperty(c)?h[c]:null;if(g&&e instanceof g)return e.$$unwrapTrustedValue();if(c===pa.RESOURCE_URL){var g=Ba(e.toString()),r,s,m=!1;r=0;for(s=b.length;r<s;r++)if(d(b[r],g)){m=!0;break}if(m)for(r=\n0,s=a.length;r<s;r++)if(d(a[r],g)){m=!1;break}if(m)return e;throw Da(\"insecurl\",e.toString());}if(c===pa.HTML)return f(e);throw Da(\"unsafe\");},valueOf:function(a){return a instanceof g?a.$$unwrapTrustedValue():a}}}]}function mf(){var b=!0;this.enabled=function(a){arguments.length&&(b=!!a);return b};this.$get=[\"$parse\",\"$sceDelegate\",function(a,c){if(b&&8>Ua)throw Da(\"iequirks\");var d=ia(pa);d.isEnabled=function(){return b};d.trustAs=c.trustAs;d.getTrusted=c.getTrusted;d.valueOf=c.valueOf;b||(d.trustAs=\nd.getTrusted=function(a,b){return b},d.valueOf=Ya);d.parseAs=function(b,c){var e=a(c);return e.literal&&e.constant?e:a(c,function(a){return d.getTrusted(b,a)})};var e=d.parseAs,f=d.getTrusted,g=d.trustAs;m(pa,function(a,b){var c=M(b);d[hb(\"parse_as_\"+c)]=function(b){return e(a,b)};d[hb(\"get_trusted_\"+c)]=function(b){return f(a,b)};d[hb(\"trust_as_\"+c)]=function(b){return g(a,b)}});return d}]}function of(){this.$get=[\"$window\",\"$document\",function(b,a){var c={},d=W((/android (\\d+)/.exec(M((b.navigator||\n{}).userAgent))||[])[1]),e=/Boxee/i.test((b.navigator||{}).userAgent),f=a[0]||{},g,h=/^(Moz|webkit|ms)(?=[A-Z])/,l=f.body&&f.body.style,k=!1,n=!1;if(l){for(var r in l)if(k=h.exec(r)){g=k[0];g=g.substr(0,1).toUpperCase()+g.substr(1);break}g||(g=\"WebkitOpacity\"in l&&\"webkit\");k=!!(\"transition\"in l||g+\"Transition\"in l);n=!!(\"animation\"in l||g+\"Animation\"in l);!d||k&&n||(k=L(l.webkitTransition),n=L(l.webkitAnimation))}return{history:!(!b.history||!b.history.pushState||4>d||e),hasEvent:function(a){if(\"input\"===\na&&11>=Ua)return!1;if(A(c[a])){var b=f.createElement(\"div\");c[a]=\"on\"+a in b}return c[a]},csp:fb(),vendorPrefix:g,transitions:k,animations:n,android:d}}]}function qf(){this.$get=[\"$templateCache\",\"$http\",\"$q\",\"$sce\",function(b,a,c,d){function e(f,g){e.totalPendingRequests++;L(f)&&b.get(f)||(f=d.getTrustedResourceUrl(f));var h=a.defaults&&a.defaults.transformResponse;G(h)?h=h.filter(function(a){return a!==$b}):h===$b&&(h=null);return a.get(f,{cache:b,transformResponse:h})[\"finally\"](function(){e.totalPendingRequests--}).then(function(a){b.put(f,\na.data);return a.data},function(a){if(!g)throw ea(\"tpload\",f,a.status,a.statusText);return c.reject(a)})}e.totalPendingRequests=0;return e}]}function rf(){this.$get=[\"$rootScope\",\"$browser\",\"$location\",function(b,a,c){return{findBindings:function(a,b,c){a=a.getElementsByClassName(\"ng-binding\");var g=[];m(a,function(a){var d=ca.element(a).data(\"$binding\");d&&m(d,function(d){c?(new RegExp(\"(^|\\\\s)\"+ud(b)+\"(\\\\s|\\\\||$)\")).test(d)&&g.push(a):-1!=d.indexOf(b)&&g.push(a)})});return g},findModels:function(a,\nb,c){for(var g=[\"ng-\",\"data-ng-\",\"ng\\\\:\"],h=0;h<g.length;++h){var l=a.querySelectorAll(\"[\"+g[h]+\"model\"+(c?\"=\":\"*=\")+'\"'+b+'\"]');if(l.length)return l}},getLocation:function(){return c.url()},setLocation:function(a){a!==c.url()&&(c.url(a),b.$digest())},whenStable:function(b){a.notifyWhenNoOutstandingRequests(b)}}}]}function sf(){this.$get=[\"$rootScope\",\"$browser\",\"$q\",\"$$q\",\"$exceptionHandler\",function(b,a,c,d,e){function f(f,l,k){z(f)||(k=l,l=f,f=v);var n=za.call(arguments,3),r=w(k)&&!k,s=(r?d:c).defer(),\nm=s.promise,q;q=a.defer(function(){try{s.resolve(f.apply(null,n))}catch(a){s.reject(a),e(a)}finally{delete g[m.$$timeoutId]}r||b.$apply()},l);m.$$timeoutId=q;g[q]=s;return m}var g={};f.cancel=function(b){return b&&b.$$timeoutId in g?(g[b.$$timeoutId].reject(\"canceled\"),delete g[b.$$timeoutId],a.defer.cancel(b.$$timeoutId)):!1};return f}]}function Ba(b){Ua&&(X.setAttribute(\"href\",b),b=X.href);X.setAttribute(\"href\",b);return{href:X.href,protocol:X.protocol?X.protocol.replace(/:$/,\"\"):\"\",host:X.host,\nsearch:X.search?X.search.replace(/^\\?/,\"\"):\"\",hash:X.hash?X.hash.replace(/^#/,\"\"):\"\",hostname:X.hostname,port:X.port,pathname:\"/\"===X.pathname.charAt(0)?X.pathname:\"/\"+X.pathname}}function gd(b){b=L(b)?Ba(b):b;return b.protocol===wd.protocol&&b.host===wd.host}function tf(){this.$get=ra(O)}function xd(b){function a(a){try{return decodeURIComponent(a)}catch(b){return a}}var c=b[0]||{},d={},e=\"\";return function(){var b,g,h,l,k;b=c.cookie||\"\";if(b!==e)for(e=b,b=e.split(\"; \"),d={},h=0;h<b.length;h++)g=\nb[h],l=g.indexOf(\"=\"),0<l&&(k=a(g.substring(0,l)),d[k]===t&&(d[k]=a(g.substring(l+1))));return d}}function yf(){this.$get=xd}function Lc(b){function a(c,d){if(H(c)){var e={};m(c,function(b,c){e[c]=a(c,b)});return e}return b.factory(c+\"Filter\",d)}this.register=a;this.$get=[\"$injector\",function(a){return function(b){return a.get(b+\"Filter\")}}];a(\"currency\",yd);a(\"date\",zd);a(\"filter\",ag);a(\"json\",bg);a(\"limitTo\",cg);a(\"lowercase\",dg);a(\"number\",Ad);a(\"orderBy\",Bd);a(\"uppercase\",eg)}function ag(){return function(b,\na,c){if(!Ea(b)){if(null==b)return b;throw J(\"filter\")(\"notarray\",b);}var d;switch(ic(a)){case \"function\":break;case \"boolean\":case \"null\":case \"number\":case \"string\":d=!0;case \"object\":a=fg(a,c,d);break;default:return b}return Array.prototype.filter.call(b,a)}}function fg(b,a,c){var d=H(b)&&\"$\"in b;!0===a?a=ka:z(a)||(a=function(a,b){if(A(a))return!1;if(null===a||null===b)return a===b;if(H(b)||H(a)&&!rc(a))return!1;a=M(\"\"+a);b=M(\"\"+b);return-1!==a.indexOf(b)});return function(e){return d&&!H(e)?La(e,\nb.$,a,!1):La(e,b,a,c)}}function La(b,a,c,d,e){var f=ic(b),g=ic(a);if(\"string\"===g&&\"!\"===a.charAt(0))return!La(b,a.substring(1),c,d);if(G(b))return b.some(function(b){return La(b,a,c,d)});switch(f){case \"object\":var h;if(d){for(h in b)if(\"$\"!==h.charAt(0)&&La(b[h],a,c,!0))return!0;return e?!1:La(b,a,c,!1)}if(\"object\"===g){for(h in a)if(e=a[h],!z(e)&&!A(e)&&(f=\"$\"===h,!La(f?b:b[h],e,c,f,f)))return!1;return!0}return c(b,a);case \"function\":return!1;default:return c(b,a)}}function ic(b){return null===\nb?\"null\":typeof b}function yd(b){var a=b.NUMBER_FORMATS;return function(b,d,e){A(d)&&(d=a.CURRENCY_SYM);A(e)&&(e=a.PATTERNS[1].maxFrac);return null==b?b:Cd(b,a.PATTERNS[1],a.GROUP_SEP,a.DECIMAL_SEP,e).replace(/\\u00A4/g,d)}}function Ad(b){var a=b.NUMBER_FORMATS;return function(b,d){return null==b?b:Cd(b,a.PATTERNS[0],a.GROUP_SEP,a.DECIMAL_SEP,d)}}function Cd(b,a,c,d,e){if(H(b))return\"\";var f=0>b;b=Math.abs(b);var g=Infinity===b;if(!g&&!isFinite(b))return\"\";var h=b+\"\",l=\"\",k=!1,n=[];g&&(l=\"\\u221e\");\nif(!g&&-1!==h.indexOf(\"e\")){var r=h.match(/([\\d\\.]+)e(-?)(\\d+)/);r&&\"-\"==r[2]&&r[3]>e+1?b=0:(l=h,k=!0)}if(g||k)0<e&&1>b&&(l=b.toFixed(e),b=parseFloat(l));else{g=(h.split(Dd)[1]||\"\").length;A(e)&&(e=Math.min(Math.max(a.minFrac,g),a.maxFrac));b=+(Math.round(+(b.toString()+\"e\"+e)).toString()+\"e\"+-e);var g=(\"\"+b).split(Dd),h=g[0],g=g[1]||\"\",r=0,s=a.lgSize,m=a.gSize;if(h.length>=s+m)for(r=h.length-s,k=0;k<r;k++)0===(r-k)%m&&0!==k&&(l+=c),l+=h.charAt(k);for(k=r;k<h.length;k++)0===(h.length-k)%s&&0!==k&&\n(l+=c),l+=h.charAt(k);for(;g.length<e;)g+=\"0\";e&&\"0\"!==e&&(l+=d+g.substr(0,e))}0===b&&(f=!1);n.push(f?a.negPre:a.posPre,l,f?a.negSuf:a.posSuf);return n.join(\"\")}function Gb(b,a,c){var d=\"\";0>b&&(d=\"-\",b=-b);for(b=\"\"+b;b.length<a;)b=\"0\"+b;c&&(b=b.substr(b.length-a));return d+b}function Y(b,a,c,d){c=c||0;return function(e){e=e[\"get\"+b]();if(0<c||e>-c)e+=c;0===e&&-12==c&&(e=12);return Gb(e,a,d)}}function Hb(b,a){return function(c,d){var e=c[\"get\"+b](),f=rb(a?\"SHORT\"+b:b);return d[f][e]}}function Ed(b){var a=\n(new Date(b,0,1)).getDay();return new Date(b,0,(4>=a?5:12)-a)}function Fd(b){return function(a){var c=Ed(a.getFullYear());a=+new Date(a.getFullYear(),a.getMonth(),a.getDate()+(4-a.getDay()))-+c;a=1+Math.round(a/6048E5);return Gb(a,b)}}function jc(b,a){return 0>=b.getFullYear()?a.ERAS[0]:a.ERAS[1]}function zd(b){function a(a){var b;if(b=a.match(c)){a=new Date(0);var f=0,g=0,h=b[8]?a.setUTCFullYear:a.setFullYear,l=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=W(b[9]+b[10]),g=W(b[9]+b[11]));h.call(a,W(b[1]),\nW(b[2])-1,W(b[3]));f=W(b[4]||0)-f;g=W(b[5]||0)-g;h=W(b[6]||0);b=Math.round(1E3*parseFloat(\"0.\"+(b[7]||0)));l.call(a,f,g,h,b)}return a}var c=/^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;return function(c,e,f){var g=\"\",h=[],l,k;e=e||\"mediumDate\";e=b.DATETIME_FORMATS[e]||e;L(c)&&(c=gg.test(c)?W(c):a(c));V(c)&&(c=new Date(c));if(!aa(c)||!isFinite(c.getTime()))return c;for(;e;)(k=hg.exec(e))?(h=cb(h,k,1),e=h.pop()):(h.push(e),e=null);var n=c.getTimezoneOffset();\nf&&(n=xc(f,c.getTimezoneOffset()),c=Pb(c,f,!0));m(h,function(a){l=ig[a];g+=l?l(c,b.DATETIME_FORMATS,n):a.replace(/(^'|'$)/g,\"\").replace(/''/g,\"'\")});return g}}function bg(){return function(b,a){A(a)&&(a=2);return db(b,a)}}function cg(){return function(b,a,c){a=Infinity===Math.abs(Number(a))?Number(a):W(a);if(isNaN(a))return b;V(b)&&(b=b.toString());if(!G(b)&&!L(b))return b;c=!c||isNaN(c)?0:W(c);c=0>c&&c>=-b.length?b.length+c:c;return 0<=a?b.slice(c,c+a):0===c?b.slice(a,b.length):b.slice(Math.max(0,\nc+a),c)}}function Bd(b){function a(a,c){c=c?-1:1;return a.map(function(a){var d=1,h=Ya;if(z(a))h=a;else if(L(a)){if(\"+\"==a.charAt(0)||\"-\"==a.charAt(0))d=\"-\"==a.charAt(0)?-1:1,a=a.substring(1);if(\"\"!==a&&(h=b(a),h.constant))var l=h(),h=function(a){return a[l]}}return{get:h,descending:d*c}})}function c(a){switch(typeof a){case \"number\":case \"boolean\":case \"string\":return!0;default:return!1}}return function(b,e,f){if(!Ea(b))return b;G(e)||(e=[e]);0===e.length&&(e=[\"+\"]);var g=a(e,f);b=Array.prototype.map.call(b,\nfunction(a,b){return{value:a,predicateValues:g.map(function(d){var e=d.get(a);d=typeof e;if(null===e)d=\"string\",e=\"null\";else if(\"string\"===d)e=e.toLowerCase();else if(\"object\"===d)a:{if(\"function\"===typeof e.valueOf&&(e=e.valueOf(),c(e)))break a;if(rc(e)&&(e=e.toString(),c(e)))break a;e=b}return{value:e,type:d}})}});b.sort(function(a,b){for(var c=0,d=0,e=g.length;d<e;++d){var c=a.predicateValues[d],f=b.predicateValues[d],m=0;c.type===f.type?c.value!==f.value&&(m=c.value<f.value?-1:1):m=c.type<f.type?\n-1:1;if(c=m*g[d].descending)break}return c});return b=b.map(function(a){return a.value})}}function Ma(b){z(b)&&(b={link:b});b.restrict=b.restrict||\"AC\";return ra(b)}function Gd(b,a,c,d,e){var f=this,g=[],h=f.$$parentForm=b.parent().controller(\"form\")||Ib;f.$error={};f.$$success={};f.$pending=t;f.$name=e(a.name||a.ngForm||\"\")(c);f.$dirty=!1;f.$pristine=!0;f.$valid=!0;f.$invalid=!1;f.$submitted=!1;h.$addControl(f);f.$rollbackViewValue=function(){m(g,function(a){a.$rollbackViewValue()})};f.$commitViewValue=\nfunction(){m(g,function(a){a.$commitViewValue()})};f.$addControl=function(a){Ra(a.$name,\"input\");g.push(a);a.$name&&(f[a.$name]=a)};f.$$renameControl=function(a,b){var c=a.$name;f[c]===a&&delete f[c];f[b]=a;a.$name=b};f.$removeControl=function(a){a.$name&&f[a.$name]===a&&delete f[a.$name];m(f.$pending,function(b,c){f.$setValidity(c,null,a)});m(f.$error,function(b,c){f.$setValidity(c,null,a)});m(f.$$success,function(b,c){f.$setValidity(c,null,a)});bb(g,a)};Hd({ctrl:this,$element:b,set:function(a,b,\nc){var d=a[b];d?-1===d.indexOf(c)&&d.push(c):a[b]=[c]},unset:function(a,b,c){var d=a[b];d&&(bb(d,c),0===d.length&&delete a[b])},parentForm:h,$animate:d});f.$setDirty=function(){d.removeClass(b,Va);d.addClass(b,Jb);f.$dirty=!0;f.$pristine=!1;h.$setDirty()};f.$setPristine=function(){d.setClass(b,Va,Jb+\" ng-submitted\");f.$dirty=!1;f.$pristine=!0;f.$submitted=!1;m(g,function(a){a.$setPristine()})};f.$setUntouched=function(){m(g,function(a){a.$setUntouched()})};f.$setSubmitted=function(){d.addClass(b,\n\"ng-submitted\");f.$submitted=!0;h.$setSubmitted()}}function kc(b){b.$formatters.push(function(a){return b.$isEmpty(a)?a:a.toString()})}function kb(b,a,c,d,e,f){var g=M(a[0].type);if(!e.android){var h=!1;a.on(\"compositionstart\",function(a){h=!0});a.on(\"compositionend\",function(){h=!1;l()})}var l=function(b){k&&(f.defer.cancel(k),k=null);if(!h){var e=a.val();b=b&&b.type;\"password\"===g||c.ngTrim&&\"false\"===c.ngTrim||(e=R(e));(d.$viewValue!==e||\"\"===e&&d.$$hasNativeValidators)&&d.$setViewValue(e,b)}};\nif(e.hasEvent(\"input\"))a.on(\"input\",l);else{var k,n=function(a,b,c){k||(k=f.defer(function(){k=null;b&&b.value===c||l(a)}))};a.on(\"keydown\",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||n(a,this,this.value)});if(e.hasEvent(\"paste\"))a.on(\"paste cut\",n)}a.on(\"change\",l);d.$render=function(){a.val(d.$isEmpty(d.$viewValue)?\"\":d.$viewValue)}}function Kb(b,a){return function(c,d){var e,f;if(aa(c))return c;if(L(c)){'\"'==c.charAt(0)&&'\"'==c.charAt(c.length-1)&&(c=c.substring(1,c.length-1));\nif(jg.test(c))return new Date(c);b.lastIndex=0;if(e=b.exec(c))return e.shift(),f=d?{yyyy:d.getFullYear(),MM:d.getMonth()+1,dd:d.getDate(),HH:d.getHours(),mm:d.getMinutes(),ss:d.getSeconds(),sss:d.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},m(e,function(b,c){c<a.length&&(f[a[c]]=+b)}),new Date(f.yyyy,f.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0)}return NaN}}function lb(b,a,c,d){return function(e,f,g,h,l,k,n){function r(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function s(a){return w(a)?\naa(a)?a:c(a):t}Id(e,f,g,h);kb(e,f,g,h,l,k);var m=h&&h.$options&&h.$options.timezone,q;h.$$parserName=b;h.$parsers.push(function(b){return h.$isEmpty(b)?null:a.test(b)?(b=c(b,q),m&&(b=Pb(b,m)),b):t});h.$formatters.push(function(a){if(a&&!aa(a))throw Lb(\"datefmt\",a);if(r(a))return(q=a)&&m&&(q=Pb(q,m,!0)),n(\"date\")(a,d,m);q=null;return\"\"});if(w(g.min)||g.ngMin){var F;h.$validators.min=function(a){return!r(a)||A(F)||c(a)>=F};g.$observe(\"min\",function(a){F=s(a);h.$validate()})}if(w(g.max)||g.ngMax){var u;\nh.$validators.max=function(a){return!r(a)||A(u)||c(a)<=u};g.$observe(\"max\",function(a){u=s(a);h.$validate()})}}}function Id(b,a,c,d){(d.$$hasNativeValidators=H(a[0].validity))&&d.$parsers.push(function(b){var c=a.prop(\"validity\")||{};return c.badInput&&!c.typeMismatch?t:b})}function Jd(b,a,c,d,e){if(w(d)){b=b(d);if(!b.constant)throw J(\"ngModel\")(\"constexpr\",c,d);return b(a)}return e}function lc(b,a){b=\"ngClass\"+b;return[\"$animate\",function(c){function d(a,b){var c=[],d=0;a:for(;d<a.length;d++){for(var e=\na[d],n=0;n<b.length;n++)if(e==b[n])continue a;c.push(e)}return c}function e(a){var b=[];return G(a)?(m(a,function(a){b=b.concat(e(a))}),b):L(a)?a.split(\" \"):H(a)?(m(a,function(a,c){a&&(b=b.concat(c.split(\" \")))}),b):a}return{restrict:\"AC\",link:function(f,g,h){function l(a,b){var c=g.data(\"$classCounts\")||ga(),d=[];m(a,function(a){if(0<b||c[a])c[a]=(c[a]||0)+b,c[a]===+(0<b)&&d.push(a)});g.data(\"$classCounts\",c);return d.join(\" \")}function k(b){if(!0===a||f.$index%2===a){var k=e(b||[]);if(!n){var m=\nl(k,1);h.$addClass(m)}else if(!ka(b,n)){var q=e(n),m=d(k,q),k=d(q,k),m=l(m,1),k=l(k,-1);m&&m.length&&c.addClass(g,m);k&&k.length&&c.removeClass(g,k)}}n=ia(b)}var n;f.$watch(h[b],k,!0);h.$observe(\"class\",function(a){k(f.$eval(h[b]))});\"ngClass\"!==b&&f.$watch(\"$index\",function(c,d){var g=c&1;if(g!==(d&1)){var k=e(f.$eval(h[b]));g===a?(g=l(k,1),h.$addClass(g)):(g=l(k,-1),h.$removeClass(g))}})}}}]}function Hd(b){function a(a,b){b&&!f[a]?(k.addClass(e,a),f[a]=!0):!b&&f[a]&&(k.removeClass(e,a),f[a]=!1)}\nfunction c(b,c){b=b?\"-\"+Bc(b,\"-\"):\"\";a(mb+b,!0===c);a(Kd+b,!1===c)}var d=b.ctrl,e=b.$element,f={},g=b.set,h=b.unset,l=b.parentForm,k=b.$animate;f[Kd]=!(f[mb]=e.hasClass(mb));d.$setValidity=function(b,e,f){e===t?(d.$pending||(d.$pending={}),g(d.$pending,b,f)):(d.$pending&&h(d.$pending,b,f),Ld(d.$pending)&&(d.$pending=t));ab(e)?e?(h(d.$error,b,f),g(d.$$success,b,f)):(g(d.$error,b,f),h(d.$$success,b,f)):(h(d.$error,b,f),h(d.$$success,b,f));d.$pending?(a(Md,!0),d.$valid=d.$invalid=t,c(\"\",null)):(a(Md,\n!1),d.$valid=Ld(d.$error),d.$invalid=!d.$valid,c(\"\",d.$valid));e=d.$pending&&d.$pending[b]?t:d.$error[b]?!1:d.$$success[b]?!0:null;c(b,e);l.$setValidity(b,e,d)}}function Ld(b){if(b)for(var a in b)if(b.hasOwnProperty(a))return!1;return!0}var kg=/^\\/(.+)\\/([a-z]*)$/,M=function(b){return L(b)?b.toLowerCase():b},Xa=Object.prototype.hasOwnProperty,rb=function(b){return L(b)?b.toUpperCase():b},Ua,y,la,za=[].slice,Nf=[].splice,lg=[].push,sa=Object.prototype.toString,sc=Object.getPrototypeOf,Fa=J(\"ng\"),ca=\nO.angular||(O.angular={}),gb,nb=0;Ua=U.documentMode;v.$inject=[];Ya.$inject=[];var G=Array.isArray,uc=/^\\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\\]$/,R=function(b){return L(b)?b.trim():b},ud=function(b){return b.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g,\"\\\\$1\").replace(/\\x08/g,\"\\\\x08\")},fb=function(){if(w(fb.isActive_))return fb.isActive_;var b=!(!U.querySelector(\"[ng-csp]\")&&!U.querySelector(\"[data-ng-csp]\"));if(!b)try{new Function(\"\")}catch(a){b=!0}return fb.isActive_=\nb},pb=function(){if(w(pb.name_))return pb.name_;var b,a,c=Oa.length,d,e;for(a=0;a<c;++a)if(d=Oa[a],b=U.querySelector(\"[\"+d.replace(\":\",\"\\\\:\")+\"jq]\")){e=b.getAttribute(d+\"jq\");break}return pb.name_=e},Oa=[\"ng-\",\"data-ng-\",\"ng:\",\"x-ng-\"],be=/[A-Z]/g,Cc=!1,Rb,qa=1,Na=3,fe={full:\"1.4.2\",major:1,minor:4,dot:2,codeName:\"nebular-readjustment\"};Q.expando=\"ng339\";var ib=Q.cache={},Ef=1;Q._data=function(b){return this.cache[b[this.expando]]||{}};var zf=/([\\:\\-\\_]+(.))/g,Af=/^moz([A-Z])/,mg={mouseleave:\"mouseout\",\nmouseenter:\"mouseover\"},Ub=J(\"jqLite\"),Df=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,Tb=/<|&#?\\w+;/,Bf=/<([\\w:]+)/,Cf=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,na={option:[1,'<select multiple=\"multiple\">',\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};na.optgroup=na.option;na.tbody=na.tfoot=na.colgroup=na.caption=na.thead;\nna.th=na.td;var Pa=Q.prototype={ready:function(b){function a(){c||(c=!0,b())}var c=!1;\"complete\"===U.readyState?setTimeout(a):(this.on(\"DOMContentLoaded\",a),Q(O).on(\"load\",a))},toString:function(){var b=[];m(this,function(a){b.push(\"\"+a)});return\"[\"+b.join(\", \")+\"]\"},eq:function(b){return 0<=b?y(this[b]):y(this[this.length+b])},length:0,push:lg,sort:[].sort,splice:[].splice},Ab={};m(\"multiple selected checked disabled readOnly required open\".split(\" \"),function(b){Ab[M(b)]=b});var Tc={};m(\"input select option textarea button form details\".split(\" \"),\nfunction(b){Tc[b]=!0});var Uc={ngMinlength:\"minlength\",ngMaxlength:\"maxlength\",ngMin:\"min\",ngMax:\"max\",ngPattern:\"pattern\"};m({data:Wb,removeData:ub,hasData:function(b){for(var a in ib[b.ng339])return!0;return!1}},function(b,a){Q[a]=b});m({data:Wb,inheritedData:zb,scope:function(b){return y.data(b,\"$scope\")||zb(b.parentNode||b,[\"$isolateScope\",\"$scope\"])},isolateScope:function(b){return y.data(b,\"$isolateScope\")||y.data(b,\"$isolateScopeNoTemplate\")},controller:Qc,injector:function(b){return zb(b,\n\"$injector\")},removeAttr:function(b,a){b.removeAttribute(a)},hasClass:wb,css:function(b,a,c){a=hb(a);if(w(c))b.style[a]=c;else return b.style[a]},attr:function(b,a,c){var d=b.nodeType;if(d!==Na&&2!==d&&8!==d)if(d=M(a),Ab[d])if(w(c))c?(b[a]=!0,b.setAttribute(a,d)):(b[a]=!1,b.removeAttribute(d));else return b[a]||(b.attributes.getNamedItem(a)||v).specified?d:t;else if(w(c))b.setAttribute(a,c);else if(b.getAttribute)return b=b.getAttribute(a,2),null===b?t:b},prop:function(b,a,c){if(w(c))b[a]=c;else return b[a]},\ntext:function(){function b(a,b){if(A(b)){var d=a.nodeType;return d===qa||d===Na?a.textContent:\"\"}a.textContent=b}b.$dv=\"\";return b}(),val:function(b,a){if(A(a)){if(b.multiple&&\"select\"===ta(b)){var c=[];m(b.options,function(a){a.selected&&c.push(a.value||a.text)});return 0===c.length?null:c}return b.value}b.value=a},html:function(b,a){if(A(a))return b.innerHTML;tb(b,!0);b.innerHTML=a},empty:Rc},function(b,a){Q.prototype[a]=function(a,d){var e,f,g=this.length;if(b!==Rc&&(2==b.length&&b!==wb&&b!==Qc?\na:d)===t){if(H(a)){for(e=0;e<g;e++)if(b===Wb)b(this[e],a);else for(f in a)b(this[e],f,a[f]);return this}e=b.$dv;g=e===t?Math.min(g,1):g;for(f=0;f<g;f++){var h=b(this[f],a,d);e=e?e+h:h}return e}for(e=0;e<g;e++)b(this[e],a,d);return this}});m({removeData:ub,on:function a(c,d,e,f){if(w(f))throw Ub(\"onargs\");if(Mc(c)){var g=vb(c,!0);f=g.events;var h=g.handle;h||(h=g.handle=Hf(c,f));for(var g=0<=d.indexOf(\" \")?d.split(\" \"):[d],l=g.length;l--;){d=g[l];var k=f[d];k||(f[d]=[],\"mouseenter\"===d||\"mouseleave\"===\nd?a(c,mg[d],function(a){var c=a.relatedTarget;c&&(c===this||this.contains(c))||h(a,d)}):\"$destroy\"!==d&&c.addEventListener(d,h,!1),k=f[d]);k.push(e)}}},off:Pc,one:function(a,c,d){a=y(a);a.on(c,function f(){a.off(c,d);a.off(c,f)});a.on(c,d)},replaceWith:function(a,c){var d,e=a.parentNode;tb(a);m(new Q(c),function(c){d?e.insertBefore(c,d.nextSibling):e.replaceChild(c,a);d=c})},children:function(a){var c=[];m(a.childNodes,function(a){a.nodeType===qa&&c.push(a)});return c},contents:function(a){return a.contentDocument||\na.childNodes||[]},append:function(a,c){var d=a.nodeType;if(d===qa||11===d){c=new Q(c);for(var d=0,e=c.length;d<e;d++)a.appendChild(c[d])}},prepend:function(a,c){if(a.nodeType===qa){var d=a.firstChild;m(new Q(c),function(c){a.insertBefore(c,d)})}},wrap:function(a,c){c=y(c).eq(0).clone()[0];var d=a.parentNode;d&&d.replaceChild(c,a);c.appendChild(a)},remove:Xb,detach:function(a){Xb(a,!0)},after:function(a,c){var d=a,e=a.parentNode;c=new Q(c);for(var f=0,g=c.length;f<g;f++){var h=c[f];e.insertBefore(h,\nd.nextSibling);d=h}},addClass:yb,removeClass:xb,toggleClass:function(a,c,d){c&&m(c.split(\" \"),function(c){var f=d;A(f)&&(f=!wb(a,c));(f?yb:xb)(a,c)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,c){return a.getElementsByTagName?a.getElementsByTagName(c):[]},clone:Vb,triggerHandler:function(a,c,d){var e,f,g=c.type||c,h=vb(a);if(h=(h=h&&h.events)&&h[g])e={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===\nthis.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:v,type:g,target:a},c.type&&(e=P(e,c)),c=ia(h),f=d?[e].concat(d):[e],m(c,function(c){e.isImmediatePropagationStopped()||c.apply(a,f)})}},function(a,c){Q.prototype[c]=function(c,e,f){for(var g,h=0,l=this.length;h<l;h++)A(g)?(g=a(this[h],c,e,f),w(g)&&(g=y(g))):Oc(g,a(this[h],c,e,f));return w(g)?g:this};Q.prototype.bind=\nQ.prototype.on;Q.prototype.unbind=Q.prototype.off});Sa.prototype={put:function(a,c){this[Ga(a,this.nextUid)]=c},get:function(a){return this[Ga(a,this.nextUid)]},remove:function(a){var c=this[a=Ga(a,this.nextUid)];delete this[a];return c}};var xf=[function(){this.$get=[function(){return Sa}]}],Wc=/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m,ng=/,/,og=/^\\s*(_?)(\\S+?)\\1\\s*$/,Vc=/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,Ha=J(\"$injector\");eb.$$annotate=function(a,c,d){var e;if(\"function\"===typeof a){if(!(e=a.$inject)){e=\n[];if(a.length){if(c)throw L(d)&&d||(d=a.name||If(a)),Ha(\"strictdi\",d);c=a.toString().replace(Vc,\"\");c=c.match(Wc);m(c[1].split(ng),function(a){a.replace(og,function(a,c,d){e.push(d)})})}a.$inject=e}}else G(a)?(c=a.length-1,Qa(a[c],\"fn\"),e=a.slice(0,c)):Qa(a,\"fn\",!0);return e};var Nd=J(\"$animate\"),Ue=function(){this.$get=[\"$q\",\"$$rAF\",function(a,c){function d(){}d.all=v;d.chain=v;d.prototype={end:v,cancel:v,resume:v,pause:v,complete:v,then:function(d,f){return a(function(a){c(function(){a()})}).then(d,\nf)}};return d}]},Te=function(){var a=new Sa,c=[];this.$get=[\"$$AnimateRunner\",\"$rootScope\",function(d,e){function f(d,f,l){var k=a.get(d);k||(a.put(d,k={}),c.push(d));f&&m(f.split(\" \"),function(a){a&&(k[a]=!0)});l&&m(l.split(\" \"),function(a){a&&(k[a]=!1)});1<c.length||e.$$postDigest(function(){m(c,function(c){var d=a.get(c);if(d){var e=Jf(c.attr(\"class\")),f=\"\",g=\"\";m(d,function(a,c){a!==!!e[c]&&(a?f+=(f.length?\" \":\"\")+c:g+=(g.length?\" \":\"\")+c)});m(c,function(a){f&&yb(a,f);g&&xb(a,g)});a.remove(c)}});\nc.length=0})}return{enabled:v,on:v,off:v,pin:v,push:function(a,c,e,k){k&&k();e=e||{};e.from&&a.css(e.from);e.to&&a.css(e.to);(e.addClass||e.removeClass)&&f(a,e.addClass,e.removeClass);return new d}}}]},Se=[\"$provide\",function(a){var c=this;this.$$registeredAnimations=Object.create(null);this.register=function(d,e){if(d&&\".\"!==d.charAt(0))throw Nd(\"notcsel\",d);var f=d+\"-animation\";c.$$registeredAnimations[d.substr(1)]=f;a.factory(f,e)};this.classNameFilter=function(a){if(1===arguments.length&&(this.$$classNameFilter=\na instanceof RegExp?a:null)&&/(\\s+|\\/)ng-animate(\\s+|\\/)/.test(this.$$classNameFilter.toString()))throw Nd(\"nongcls\",\"ng-animate\");return this.$$classNameFilter};this.$get=[\"$$animateQueue\",function(a){function c(a,d,e){if(e){var l;a:{for(l=0;l<e.length;l++){var k=e[l];if(1===k.nodeType){l=k;break a}}l=void 0}!l||l.parentNode||l.previousElementSibling||(e=null)}e?e.after(a):d.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},enter:function(f,g,h,l){g=\ng&&y(g);h=h&&y(h);g=g||h.parent();c(f,g,h);return a.push(f,\"enter\",Ia(l))},move:function(f,g,h,l){g=g&&y(g);h=h&&y(h);g=g||h.parent();c(f,g,h);return a.push(f,\"move\",Ia(l))},leave:function(c,e){return a.push(c,\"leave\",Ia(e),function(){c.remove()})},addClass:function(c,e,h){h=Ia(h);h.addClass=jb(h.addclass,e);return a.push(c,\"addClass\",h)},removeClass:function(c,e,h){h=Ia(h);h.removeClass=jb(h.removeClass,e);return a.push(c,\"removeClass\",h)},setClass:function(c,e,h,l){l=Ia(l);l.addClass=jb(l.addClass,\ne);l.removeClass=jb(l.removeClass,h);return a.push(c,\"setClass\",l)},animate:function(c,e,h,l,k){k=Ia(k);k.from=k.from?P(k.from,e):e;k.to=k.to?P(k.to,h):h;k.tempClasses=jb(k.tempClasses,l||\"ng-inline-animate\");return a.push(c,\"animate\",k)}}}]}],ea=J(\"$compile\");Ec.$inject=[\"$provide\",\"$$sanitizeUriProvider\"];var Zc=/^((?:x|data)[\\:\\-_])/i,Of=J(\"$controller\"),Xc=/^(\\S+)(\\s+as\\s+(\\w+))?$/,cd=\"application/json\",ac={\"Content-Type\":cd+\";charset=utf-8\"},Qf=/^\\[|^\\{(?!\\{)/,Rf={\"[\":/]$/,\"{\":/}$/},Pf=/^\\)\\]\\}',?\\n/,\nKa=ca.$interpolateMinErr=J(\"$interpolate\");Ka.throwNoconcat=function(a){throw Ka(\"noconcat\",a);};Ka.interr=function(a,c){return Ka(\"interr\",a,c.toString())};var pg=/^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/,Uf={http:80,https:443,ftp:21},Cb=J(\"$location\"),qg={$$html5:!1,$$replace:!1,absUrl:Db(\"$$absUrl\"),url:function(a){if(A(a))return this.$$url;var c=pg.exec(a);(c[1]||\"\"===a)&&this.path(decodeURIComponent(c[1]));(c[2]||c[1]||\"\"===a)&&this.search(c[3]||\"\");this.hash(c[5]||\"\");return this},protocol:Db(\"$$protocol\"),\nhost:Db(\"$$host\"),port:Db(\"$$port\"),path:kd(\"$$path\",function(a){a=null!==a?a.toString():\"\";return\"/\"==a.charAt(0)?a:\"/\"+a}),search:function(a,c){switch(arguments.length){case 0:return this.$$search;case 1:if(L(a)||V(a))a=a.toString(),this.$$search=zc(a);else if(H(a))a=fa(a,{}),m(a,function(c,e){null==c&&delete a[e]}),this.$$search=a;else throw Cb(\"isrcharg\");break;default:A(c)||null===c?delete this.$$search[a]:this.$$search[a]=c}this.$$compose();return this},hash:kd(\"$$hash\",function(a){return null!==\na?a.toString():\"\"}),replace:function(){this.$$replace=!0;return this}};m([jd,ec,dc],function(a){a.prototype=Object.create(qg);a.prototype.state=function(c){if(!arguments.length)return this.$$state;if(a!==dc||!this.$$html5)throw Cb(\"nostate\");this.$$state=A(c)?null:c;return this}});var da=J(\"$parse\"),Vf=Function.prototype.call,Wf=Function.prototype.apply,Xf=Function.prototype.bind,Mb=ga();m(\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),function(a){Mb[a]=!0});var rg={n:\"\\n\",f:\"\\f\",r:\"\\r\",\nt:\"\\t\",v:\"\\v\",\"'\":\"'\",'\"':'\"'},gc=function(a){this.options=a};gc.prototype={constructor:gc,lex:function(a){this.text=a;this.index=0;for(this.tokens=[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'\"'===a||\"'\"===a)this.readString(a);else if(this.isNumber(a)||\".\"===a&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdent(a))this.readIdent();else if(this.is(a,\"(){}[].,;:?\"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;\nelse{var c=a+this.peek(),d=c+this.peek(2),e=Mb[c],f=Mb[d];Mb[a]||e||f?(a=f?d:e?c:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=a.length):this.throwError(\"Unexpected next character \",this.index,this.index+1)}return this.tokens},is:function(a,c){return-1!==c.indexOf(a)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return\"0\"<=a&&\"9\">=a&&\"string\"===typeof a},isWhitespace:function(a){return\" \"===a||\"\\r\"===a||\n\"\\t\"===a||\"\\n\"===a||\"\\v\"===a||\"\\u00a0\"===a},isIdent:function(a){return\"a\"<=a&&\"z\">=a||\"A\"<=a&&\"Z\">=a||\"_\"===a||\"$\"===a},isExpOperator:function(a){return\"-\"===a||\"+\"===a||this.isNumber(a)},throwError:function(a,c,d){d=d||this.index;c=w(c)?\"s \"+c+\"-\"+this.index+\" [\"+this.text.substring(c,d)+\"]\":\" \"+d;throw da(\"lexerr\",a,c,this.text);},readNumber:function(){for(var a=\"\",c=this.index;this.index<this.text.length;){var d=M(this.text.charAt(this.index));if(\".\"==d||this.isNumber(d))a+=d;else{var e=this.peek();\nif(\"e\"==d&&this.isExpOperator(e))a+=d;else if(this.isExpOperator(d)&&e&&this.isNumber(e)&&\"e\"==a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||e&&this.isNumber(e)||\"e\"!=a.charAt(a.length-1))break;else this.throwError(\"Invalid exponent\")}this.index++}this.tokens.push({index:c,text:a,constant:!0,value:Number(a)})},readIdent:function(){for(var a=this.index;this.index<this.text.length;){var c=this.text.charAt(this.index);if(!this.isIdent(c)&&!this.isNumber(c))break;this.index++}this.tokens.push({index:a,\ntext:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var c=this.index;this.index++;for(var d=\"\",e=a,f=!1;this.index<this.text.length;){var g=this.text.charAt(this.index),e=e+g;if(f)\"u\"===g?(f=this.text.substring(this.index+1,this.index+5),f.match(/[\\da-f]{4}/i)||this.throwError(\"Invalid unicode escape [\\\\u\"+f+\"]\"),this.index+=4,d+=String.fromCharCode(parseInt(f,16))):d+=rg[g]||g,f=!1;else if(\"\\\\\"===g)f=!0;else{if(g===a){this.index++;this.tokens.push({index:c,text:e,constant:!0,\nvalue:d});return}d+=g}this.index++}this.throwError(\"Unterminated quote\",c)}};var q=function(a,c){this.lexer=a;this.options=c};q.Program=\"Program\";q.ExpressionStatement=\"ExpressionStatement\";q.AssignmentExpression=\"AssignmentExpression\";q.ConditionalExpression=\"ConditionalExpression\";q.LogicalExpression=\"LogicalExpression\";q.BinaryExpression=\"BinaryExpression\";q.UnaryExpression=\"UnaryExpression\";q.CallExpression=\"CallExpression\";q.MemberExpression=\"MemberExpression\";q.Identifier=\"Identifier\";q.Literal=\n\"Literal\";q.ArrayExpression=\"ArrayExpression\";q.Property=\"Property\";q.ObjectExpression=\"ObjectExpression\";q.ThisExpression=\"ThisExpression\";q.NGValueParameter=\"NGValueParameter\";q.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError(\"is an unexpected token\",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek(\"}\",\")\",\";\",\"]\")&&a.push(this.expressionStatement()),!this.expect(\";\"))return{type:q.Program,\nbody:a}},expressionStatement:function(){return{type:q.ExpressionStatement,expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect(\"|\");)a=this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();this.expect(\"=\")&&(a={type:q.AssignmentExpression,left:a,right:this.assignment(),operator:\"=\"});return a},ternary:function(){var a=this.logicalOR(),c,d;return this.expect(\"?\")&&(c=this.expression(),this.consume(\":\"))?\n(d=this.expression(),{type:q.ConditionalExpression,test:a,alternate:c,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect(\"||\");)a={type:q.LogicalExpression,operator:\"||\",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect(\"&&\");)a={type:q.LogicalExpression,operator:\"&&\",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),c;c=this.expect(\"==\",\"!=\",\"===\",\"!==\");)a={type:q.BinaryExpression,\noperator:c.text,left:a,right:this.relational()};return a},relational:function(){for(var a=this.additive(),c;c=this.expect(\"<\",\">\",\"<=\",\">=\");)a={type:q.BinaryExpression,operator:c.text,left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),c;c=this.expect(\"+\",\"-\");)a={type:q.BinaryExpression,operator:c.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),c;c=this.expect(\"*\",\"/\",\"%\");)a={type:q.BinaryExpression,operator:c.text,\nleft:a,right:this.unary()};return a},unary:function(){var a;return(a=this.expect(\"+\",\"-\",\"!\"))?{type:q.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect(\"(\")?(a=this.filterChain(),this.consume(\")\")):this.expect(\"[\")?a=this.arrayDeclaration():this.expect(\"{\")?a=this.object():this.constants.hasOwnProperty(this.peek().text)?a=fa(this.constants[this.consume().text]):this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():\nthis.throwError(\"not a primary expression\",this.peek());for(var c;c=this.expect(\"(\",\"[\",\".\");)\"(\"===c.text?(a={type:q.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(\")\")):\"[\"===c.text?(a={type:q.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume(\"]\")):\".\"===c.text?a={type:q.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError(\"IMPOSSIBLE\");return a},filter:function(a){a=[a];for(var c={type:q.CallExpression,callee:this.identifier(),\narguments:a,filter:!0};this.expect(\":\");)a.push(this.expression());return c},parseArguments:function(){var a=[];if(\")\"!==this.peekToken().text){do a.push(this.expression());while(this.expect(\",\"))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError(\"is not a valid identifier\",a);return{type:q.Identifier,name:a.text}},constant:function(){return{type:q.Literal,value:this.consume().value}},arrayDeclaration:function(){var a=[];if(\"]\"!==this.peekToken().text){do{if(this.peek(\"]\"))break;\na.push(this.expression())}while(this.expect(\",\"))}this.consume(\"]\");return{type:q.ArrayExpression,elements:a}},object:function(){var a=[],c;if(\"}\"!==this.peekToken().text){do{if(this.peek(\"}\"))break;c={type:q.Property,kind:\"init\"};this.peek().constant?c.key=this.constant():this.peek().identifier?c.key=this.identifier():this.throwError(\"invalid key\",this.peek());this.consume(\":\");c.value=this.expression();a.push(c)}while(this.expect(\",\"))}this.consume(\"}\");return{type:q.ObjectExpression,properties:a}},\nthrowError:function(a,c){throw da(\"syntax\",c.text,a,c.index+1,this.text,this.text.substring(c.index));},consume:function(a){if(0===this.tokens.length)throw da(\"ueoe\",this.text);var c=this.expect(a);c||this.throwError(\"is unexpected, expecting [\"+a+\"]\",this.peek());return c},peekToken:function(){if(0===this.tokens.length)throw da(\"ueoe\",this.text);return this.tokens[0]},peek:function(a,c,d,e){return this.peekAhead(0,a,c,d,e)},peekAhead:function(a,c,d,e,f){if(this.tokens.length>a){a=this.tokens[a];\nvar g=a.text;if(g===c||g===d||g===e||g===f||!(c||d||e||f))return a}return!1},expect:function(a,c,d,e){return(a=this.peek(a,c,d,e))?(this.tokens.shift(),a):!1},constants:{\"true\":{type:q.Literal,value:!0},\"false\":{type:q.Literal,value:!1},\"null\":{type:q.Literal,value:null},undefined:{type:q.Literal,value:t},\"this\":{type:q.ThisExpression}}};rd.prototype={compile:function(a,c){var d=this,e=this.astBuilder.ast(a);this.state={nextId:0,filters:{},expensiveChecks:c,fn:{vars:[],body:[],own:{}},assign:{vars:[],\nbody:[],own:{}},inputs:[]};T(e,d.$filter);var f=\"\",g;this.stage=\"assign\";if(g=pd(e))this.state.computing=\"assign\",f=this.nextId(),this.recurse(g,f),f=\"fn.assign=\"+this.generateFunction(\"assign\",\"s,v,l\");g=nd(e.body);d.stage=\"inputs\";m(g,function(a,c){var e=\"fn\"+c;d.state[e]={vars:[],body:[],own:{}};d.state.computing=e;var f=d.nextId();d.recurse(a,f);d.return_(f);d.state.inputs.push(e);a.watchId=c});this.state.computing=\"fn\";this.stage=\"main\";this.recurse(e);f='\"'+this.USE+\" \"+this.STRICT+'\";\\n'+this.filterPrefix()+\n\"var fn=\"+this.generateFunction(\"fn\",\"s,l,a,i\")+f+this.watchFns()+\"return fn;\";f=(new Function(\"$filter\",\"ensureSafeMemberName\",\"ensureSafeObject\",\"ensureSafeFunction\",\"ifDefined\",\"plus\",\"text\",f))(this.$filter,Ca,oa,ld,Yf,md,a);this.state=this.stage=t;f.literal=qd(e);f.constant=e.constant;return f},USE:\"use\",STRICT:\"strict\",watchFns:function(){var a=[],c=this.state.inputs,d=this;m(c,function(c){a.push(\"var \"+c+\"=\"+d.generateFunction(c,\"s\"))});c.length&&a.push(\"fn.inputs=[\"+c.join(\",\")+\"];\");return a.join(\"\")},\ngenerateFunction:function(a,c){return\"function(\"+c+\"){\"+this.varsPrefix(a)+this.body(a)+\"};\"},filterPrefix:function(){var a=[],c=this;m(this.state.filters,function(d,e){a.push(d+\"=$filter(\"+c.escape(e)+\")\")});return a.length?\"var \"+a.join(\",\")+\";\":\"\"},varsPrefix:function(a){return this.state[a].vars.length?\"var \"+this.state[a].vars.join(\",\")+\";\":\"\"},body:function(a){return this.state[a].body.join(\"\")},recurse:function(a,c,d,e,f,g){var h,l,k=this,n,r;e=e||v;if(!g&&w(a.watchId))c=c||this.nextId(),this.if_(\"i\",\nthis.lazyAssign(c,this.computedMember(\"i\",a.watchId)),this.lazyRecurse(a,c,d,e,f,!0));else switch(a.type){case q.Program:m(a.body,function(c,d){k.recurse(c.expression,t,t,function(a){l=a});d!==a.body.length-1?k.current().body.push(l,\";\"):k.return_(l)});break;case q.Literal:r=this.escape(a.value);this.assign(c,r);e(r);break;case q.UnaryExpression:this.recurse(a.argument,t,t,function(a){l=a});r=a.operator+\"(\"+this.ifDefined(l,0)+\")\";this.assign(c,r);e(r);break;case q.BinaryExpression:this.recurse(a.left,\nt,t,function(a){h=a});this.recurse(a.right,t,t,function(a){l=a});r=\"+\"===a.operator?this.plus(h,l):\"-\"===a.operator?this.ifDefined(h,0)+a.operator+this.ifDefined(l,0):\"(\"+h+\")\"+a.operator+\"(\"+l+\")\";this.assign(c,r);e(r);break;case q.LogicalExpression:c=c||this.nextId();k.recurse(a.left,c);k.if_(\"&&\"===a.operator?c:k.not(c),k.lazyRecurse(a.right,c));e(c);break;case q.ConditionalExpression:c=c||this.nextId();k.recurse(a.test,c);k.if_(c,k.lazyRecurse(a.alternate,c),k.lazyRecurse(a.consequent,c));e(c);\nbreak;case q.Identifier:c=c||this.nextId();d&&(d.context=\"inputs\"===k.stage?\"s\":this.assign(this.nextId(),this.getHasOwnProperty(\"l\",a.name)+\"?l:s\"),d.computed=!1,d.name=a.name);Ca(a.name);k.if_(\"inputs\"===k.stage||k.not(k.getHasOwnProperty(\"l\",a.name)),function(){k.if_(\"inputs\"===k.stage||\"s\",function(){f&&1!==f&&k.if_(k.not(k.nonComputedMember(\"s\",a.name)),k.lazyAssign(k.nonComputedMember(\"s\",a.name),\"{}\"));k.assign(c,k.nonComputedMember(\"s\",a.name))})},c&&k.lazyAssign(c,k.nonComputedMember(\"l\",\na.name)));(k.state.expensiveChecks||Fb(a.name))&&k.addEnsureSafeObject(c);e(c);break;case q.MemberExpression:h=d&&(d.context=this.nextId())||this.nextId();c=c||this.nextId();k.recurse(a.object,h,t,function(){k.if_(k.notNull(h),function(){if(a.computed)l=k.nextId(),k.recurse(a.property,l),k.addEnsureSafeMemberName(l),f&&1!==f&&k.if_(k.not(k.computedMember(h,l)),k.lazyAssign(k.computedMember(h,l),\"{}\")),r=k.ensureSafeObject(k.computedMember(h,l)),k.assign(c,r),d&&(d.computed=!0,d.name=l);else{Ca(a.property.name);\nf&&1!==f&&k.if_(k.not(k.nonComputedMember(h,a.property.name)),k.lazyAssign(k.nonComputedMember(h,a.property.name),\"{}\"));r=k.nonComputedMember(h,a.property.name);if(k.state.expensiveChecks||Fb(a.property.name))r=k.ensureSafeObject(r);k.assign(c,r);d&&(d.computed=!1,d.name=a.property.name)}},function(){k.assign(c,\"undefined\")});e(c)},!!f);break;case q.CallExpression:c=c||this.nextId();a.filter?(l=k.filter(a.callee.name),n=[],m(a.arguments,function(a){var c=k.nextId();k.recurse(a,c);n.push(c)}),r=l+\n\"(\"+n.join(\",\")+\")\",k.assign(c,r),e(c)):(l=k.nextId(),h={},n=[],k.recurse(a.callee,l,h,function(){k.if_(k.notNull(l),function(){k.addEnsureSafeFunction(l);m(a.arguments,function(a){k.recurse(a,k.nextId(),t,function(a){n.push(k.ensureSafeObject(a))})});h.name?(k.state.expensiveChecks||k.addEnsureSafeObject(h.context),r=k.member(h.context,h.name,h.computed)+\"(\"+n.join(\",\")+\")\"):r=l+\"(\"+n.join(\",\")+\")\";r=k.ensureSafeObject(r);k.assign(c,r)},function(){k.assign(c,\"undefined\")});e(c)}));break;case q.AssignmentExpression:l=\nthis.nextId();h={};if(!od(a.left))throw da(\"lval\");this.recurse(a.left,t,h,function(){k.if_(k.notNull(h.context),function(){k.recurse(a.right,l);k.addEnsureSafeObject(k.member(h.context,h.name,h.computed));r=k.member(h.context,h.name,h.computed)+a.operator+l;k.assign(c,r);e(c||r)})},1);break;case q.ArrayExpression:n=[];m(a.elements,function(a){k.recurse(a,k.nextId(),t,function(a){n.push(a)})});r=\"[\"+n.join(\",\")+\"]\";this.assign(c,r);e(r);break;case q.ObjectExpression:n=[];m(a.properties,function(a){k.recurse(a.value,\nk.nextId(),t,function(c){n.push(k.escape(a.key.type===q.Identifier?a.key.name:\"\"+a.key.value)+\":\"+c)})});r=\"{\"+n.join(\",\")+\"}\";this.assign(c,r);e(r);break;case q.ThisExpression:this.assign(c,\"s\");e(\"s\");break;case q.NGValueParameter:this.assign(c,\"v\"),e(\"v\")}},getHasOwnProperty:function(a,c){var d=a+\".\"+c,e=this.current().own;e.hasOwnProperty(d)||(e[d]=this.nextId(!1,a+\"&&(\"+this.escape(c)+\" in \"+a+\")\"));return e[d]},assign:function(a,c){if(a)return this.current().body.push(a,\"=\",c,\";\"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||\n(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,c){return\"ifDefined(\"+a+\",\"+this.escape(c)+\")\"},plus:function(a,c){return\"plus(\"+a+\",\"+c+\")\"},return_:function(a){this.current().body.push(\"return \",a,\";\")},if_:function(a,c,d){if(!0===a)c();else{var e=this.current().body;e.push(\"if(\",a,\"){\");c();e.push(\"}\");d&&(e.push(\"else{\"),d(),e.push(\"}\"))}},not:function(a){return\"!(\"+a+\")\"},notNull:function(a){return a+\"!=null\"},nonComputedMember:function(a,c){return a+\n\".\"+c},computedMember:function(a,c){return a+\"[\"+c+\"]\"},member:function(a,c,d){return d?this.computedMember(a,c):this.nonComputedMember(a,c)},addEnsureSafeObject:function(a){this.current().body.push(this.ensureSafeObject(a),\";\")},addEnsureSafeMemberName:function(a){this.current().body.push(this.ensureSafeMemberName(a),\";\")},addEnsureSafeFunction:function(a){this.current().body.push(this.ensureSafeFunction(a),\";\")},ensureSafeObject:function(a){return\"ensureSafeObject(\"+a+\",text)\"},ensureSafeMemberName:function(a){return\"ensureSafeMemberName(\"+\na+\",text)\"},ensureSafeFunction:function(a){return\"ensureSafeFunction(\"+a+\",text)\"},lazyRecurse:function(a,c,d,e,f,g){var h=this;return function(){h.recurse(a,c,d,e,f,g)}},lazyAssign:function(a,c){var d=this;return function(){d.assign(a,c)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(L(a))return\"'\"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+\"'\";if(V(a))return a.toString();if(!0===a)return\"true\";\nif(!1===a)return\"false\";if(null===a)return\"null\";if(\"undefined\"===typeof a)return\"undefined\";throw da(\"esc\");},nextId:function(a,c){var d=\"v\"+this.state.nextId++;a||this.current().vars.push(d+(c?\"=\"+c:\"\"));return d},current:function(){return this.state[this.state.computing]}};sd.prototype={compile:function(a,c){var d=this,e=this.astBuilder.ast(a);this.expression=a;this.expensiveChecks=c;T(e,d.$filter);var f,g;if(f=pd(e))g=this.recurse(f);f=nd(e.body);var h;f&&(h=[],m(f,function(a,c){var e=d.recurse(a);\na.input=e;h.push(e);a.watchId=c}));var l=[];m(e.body,function(a){l.push(d.recurse(a.expression))});f=0===e.body.length?function(){}:1===e.body.length?l[0]:function(a,c){var d;m(l,function(e){d=e(a,c)});return d};g&&(f.assign=function(a,c,d){return g(a,d,c)});h&&(f.inputs=h);f.literal=qd(e);f.constant=e.constant;return f},recurse:function(a,c,d){var e,f,g=this,h;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case q.Literal:return this.value(a.value,c);case q.UnaryExpression:return f=\nthis.recurse(a.argument),this[\"unary\"+a.operator](f,c);case q.BinaryExpression:return e=this.recurse(a.left),f=this.recurse(a.right),this[\"binary\"+a.operator](e,f,c);case q.LogicalExpression:return e=this.recurse(a.left),f=this.recurse(a.right),this[\"binary\"+a.operator](e,f,c);case q.ConditionalExpression:return this[\"ternary?:\"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),c);case q.Identifier:return Ca(a.name,g.expression),g.identifier(a.name,g.expensiveChecks||Fb(a.name),\nc,d,g.expression);case q.MemberExpression:return e=this.recurse(a.object,!1,!!d),a.computed||(Ca(a.property.name,g.expression),f=a.property.name),a.computed&&(f=this.recurse(a.property)),a.computed?this.computedMember(e,f,c,d,g.expression):this.nonComputedMember(e,f,g.expensiveChecks,c,d,g.expression);case q.CallExpression:return h=[],m(a.arguments,function(a){h.push(g.recurse(a))}),a.filter&&(f=this.$filter(a.callee.name)),a.filter||(f=this.recurse(a.callee,!0)),a.filter?function(a,d,e,g){for(var m=\n[],q=0;q<h.length;++q)m.push(h[q](a,d,e,g));a=f.apply(t,m,g);return c?{context:t,name:t,value:a}:a}:function(a,d,e,r){var m=f(a,d,e,r),q;if(null!=m.value){oa(m.context,g.expression);ld(m.value,g.expression);q=[];for(var t=0;t<h.length;++t)q.push(oa(h[t](a,d,e,r),g.expression));q=oa(m.value.apply(m.context,q),g.expression)}return c?{value:q}:q};case q.AssignmentExpression:return e=this.recurse(a.left,!0,1),f=this.recurse(a.right),function(a,d,h,r){var m=e(a,d,h,r);a=f(a,d,h,r);oa(m.value,g.expression);\nm.context[m.name]=a;return c?{value:a}:a};case q.ArrayExpression:return h=[],m(a.elements,function(a){h.push(g.recurse(a))}),function(a,d,e,f){for(var g=[],m=0;m<h.length;++m)g.push(h[m](a,d,e,f));return c?{value:g}:g};case q.ObjectExpression:return h=[],m(a.properties,function(a){h.push({key:a.key.type===q.Identifier?a.key.name:\"\"+a.key.value,value:g.recurse(a.value)})}),function(a,d,e,f){for(var g={},m=0;m<h.length;++m)g[h[m].key]=h[m].value(a,d,e,f);return c?{value:g}:g};case q.ThisExpression:return function(a){return c?\n{value:a}:a};case q.NGValueParameter:return function(a,d,e,f){return c?{value:e}:e}}},\"unary+\":function(a,c){return function(d,e,f,g){d=a(d,e,f,g);d=w(d)?+d:0;return c?{value:d}:d}},\"unary-\":function(a,c){return function(d,e,f,g){d=a(d,e,f,g);d=w(d)?-d:0;return c?{value:d}:d}},\"unary!\":function(a,c){return function(d,e,f,g){d=!a(d,e,f,g);return c?{value:d}:d}},\"binary+\":function(a,c,d){return function(e,f,g,h){var l=a(e,f,g,h);e=c(e,f,g,h);l=md(l,e);return d?{value:l}:l}},\"binary-\":function(a,c,d){return function(e,\nf,g,h){var l=a(e,f,g,h);e=c(e,f,g,h);l=(w(l)?l:0)-(w(e)?e:0);return d?{value:l}:l}},\"binary*\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)*c(e,f,g,h);return d?{value:e}:e}},\"binary/\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)/c(e,f,g,h);return d?{value:e}:e}},\"binary%\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)%c(e,f,g,h);return d?{value:e}:e}},\"binary===\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)===c(e,f,g,h);return d?{value:e}:e}},\"binary!==\":function(a,\nc,d){return function(e,f,g,h){e=a(e,f,g,h)!==c(e,f,g,h);return d?{value:e}:e}},\"binary==\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)==c(e,f,g,h);return d?{value:e}:e}},\"binary!=\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)!=c(e,f,g,h);return d?{value:e}:e}},\"binary<\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)<c(e,f,g,h);return d?{value:e}:e}},\"binary>\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)>c(e,f,g,h);return d?{value:e}:e}},\"binary<=\":function(a,c,d){return function(e,\nf,g,h){e=a(e,f,g,h)<=c(e,f,g,h);return d?{value:e}:e}},\"binary>=\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)>=c(e,f,g,h);return d?{value:e}:e}},\"binary&&\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)&&c(e,f,g,h);return d?{value:e}:e}},\"binary||\":function(a,c,d){return function(e,f,g,h){e=a(e,f,g,h)||c(e,f,g,h);return d?{value:e}:e}},\"ternary?:\":function(a,c,d,e){return function(f,g,h,l){f=a(f,g,h,l)?c(f,g,h,l):d(f,g,h,l);return e?{value:f}:f}},value:function(a,c){return function(){return c?\n{context:t,name:t,value:a}:a}},identifier:function(a,c,d,e,f){return function(g,h,l,k){g=h&&a in h?h:g;e&&1!==e&&g&&!g[a]&&(g[a]={});h=g?g[a]:t;c&&oa(h,f);return d?{context:g,name:a,value:h}:h}},computedMember:function(a,c,d,e,f){return function(g,h,l,k){var n=a(g,h,l,k),m,s;null!=n&&(m=c(g,h,l,k),Ca(m,f),e&&1!==e&&n&&!n[m]&&(n[m]={}),s=n[m],oa(s,f));return d?{context:n,name:m,value:s}:s}},nonComputedMember:function(a,c,d,e,f,g){return function(h,l,k,n){h=a(h,l,k,n);f&&1!==f&&h&&!h[c]&&(h[c]={});\nl=null!=h?h[c]:t;(d||Fb(c))&&oa(l,g);return e?{context:h,name:c,value:l}:l}},inputs:function(a,c){return function(d,e,f,g){return g?g[c]:a(d,e,f)}}};var hc=function(a,c,d){this.lexer=a;this.$filter=c;this.options=d;this.ast=new q(this.lexer);this.astCompiler=d.csp?new sd(this.ast,c):new rd(this.ast,c)};hc.prototype={constructor:hc,parse:function(a){return this.astCompiler.compile(a,this.options.expensiveChecks)}};ga();ga();var Zf=Object.prototype.valueOf,Da=J(\"$sce\"),pa={HTML:\"html\",CSS:\"css\",URL:\"url\",\nRESOURCE_URL:\"resourceUrl\",JS:\"js\"},ea=J(\"$compile\"),X=U.createElement(\"a\"),wd=Ba(O.location.href);xd.$inject=[\"$document\"];Lc.$inject=[\"$provide\"];yd.$inject=[\"$locale\"];Ad.$inject=[\"$locale\"];var Dd=\".\",ig={yyyy:Y(\"FullYear\",4),yy:Y(\"FullYear\",2,0,!0),y:Y(\"FullYear\",1),MMMM:Hb(\"Month\"),MMM:Hb(\"Month\",!0),MM:Y(\"Month\",2,1),M:Y(\"Month\",1,1),dd:Y(\"Date\",2),d:Y(\"Date\",1),HH:Y(\"Hours\",2),H:Y(\"Hours\",1),hh:Y(\"Hours\",2,-12),h:Y(\"Hours\",1,-12),mm:Y(\"Minutes\",2),m:Y(\"Minutes\",1),ss:Y(\"Seconds\",2),s:Y(\"Seconds\",\n1),sss:Y(\"Milliseconds\",3),EEEE:Hb(\"Day\"),EEE:Hb(\"Day\",!0),a:function(a,c){return 12>a.getHours()?c.AMPMS[0]:c.AMPMS[1]},Z:function(a,c,d){a=-1*d;return a=(0<=a?\"+\":\"\")+(Gb(Math[0<a?\"floor\":\"ceil\"](a/60),2)+Gb(Math.abs(a%60),2))},ww:Fd(2),w:Fd(1),G:jc,GG:jc,GGG:jc,GGGG:function(a,c){return 0>=a.getFullYear()?c.ERANAMES[0]:c.ERANAMES[1]}},hg=/((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,gg=/^\\-?\\d+$/;zd.$inject=[\"$locale\"];var dg=ra(M),eg=ra(rb);Bd.$inject=\n[\"$parse\"];var ie=ra({restrict:\"E\",compile:function(a,c){if(!c.href&&!c.xlinkHref)return function(a,c){if(\"a\"===c[0].nodeName.toLowerCase()){var f=\"[object SVGAnimatedString]\"===sa.call(c.prop(\"href\"))?\"xlink:href\":\"href\";c.on(\"click\",function(a){c.attr(f)||a.preventDefault()})}}}}),sb={};m(Ab,function(a,c){function d(a,d,f){a.$watch(f[e],function(a){f.$set(c,!!a)})}if(\"multiple\"!=a){var e=wa(\"ng-\"+c),f=d;\"checked\"===a&&(f=function(a,c,f){f.ngModel!==f[e]&&d(a,c,f)});sb[e]=function(){return{restrict:\"A\",\npriority:100,link:f}}}});m(Uc,function(a,c){sb[c]=function(){return{priority:100,link:function(a,e,f){if(\"ngPattern\"===c&&\"/\"==f.ngPattern.charAt(0)&&(e=f.ngPattern.match(kg))){f.$set(\"ngPattern\",new RegExp(e[1],e[2]));return}a.$watch(f[c],function(a){f.$set(c,a)})}}}});m([\"src\",\"srcset\",\"href\"],function(a){var c=wa(\"ng-\"+a);sb[c]=function(){return{priority:99,link:function(d,e,f){var g=a,h=a;\"href\"===a&&\"[object SVGAnimatedString]\"===sa.call(e.prop(\"href\"))&&(h=\"xlinkHref\",f.$attr[h]=\"xlink:href\",\ng=null);f.$observe(c,function(c){c?(f.$set(h,c),Ua&&g&&e.prop(g,f[h])):\"href\"===a&&f.$set(h,null)})}}}});var Ib={$addControl:v,$$renameControl:function(a,c){a.$name=c},$removeControl:v,$setValidity:v,$setDirty:v,$setPristine:v,$setSubmitted:v};Gd.$inject=[\"$element\",\"$attrs\",\"$scope\",\"$animate\",\"$interpolate\"];var Od=function(a){return[\"$timeout\",function(c){return{name:\"form\",restrict:a?\"EAC\":\"E\",controller:Gd,compile:function(d,e){d.addClass(Va).addClass(mb);var f=e.name?\"name\":a&&e.ngForm?\"ngForm\":\n!1;return{pre:function(a,d,e,k){if(!(\"action\"in e)){var n=function(c){a.$apply(function(){k.$commitViewValue();k.$setSubmitted()});c.preventDefault()};d[0].addEventListener(\"submit\",n,!1);d.on(\"$destroy\",function(){c(function(){d[0].removeEventListener(\"submit\",n,!1)},0,!1)})}var m=k.$$parentForm;f&&(Eb(a,k.$name,k,k.$name),e.$observe(f,function(c){k.$name!==c&&(Eb(a,k.$name,t,k.$name),m.$$renameControl(k,c),Eb(a,k.$name,k,k.$name))}));d.on(\"$destroy\",function(){m.$removeControl(k);f&&Eb(a,e[f],t,\nk.$name);P(k,Ib)})}}}}}]},je=Od(),we=Od(!0),jg=/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/,sg=/^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,tg=/^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,ug=/^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))([eE][+-]?\\d+)?\\s*$/,Pd=/^(\\d{4})-(\\d{2})-(\\d{2})$/,Qd=/^(\\d{4})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,mc=/^(\\d{4})-W(\\d\\d)$/,Rd=/^(\\d{4})-(\\d\\d)$/,\nSd=/^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,Td={text:function(a,c,d,e,f,g){kb(a,c,d,e,f,g);kc(e)},date:lb(\"date\",Pd,Kb(Pd,[\"yyyy\",\"MM\",\"dd\"]),\"yyyy-MM-dd\"),\"datetime-local\":lb(\"datetimelocal\",Qd,Kb(Qd,\"yyyy MM dd HH mm ss sss\".split(\" \")),\"yyyy-MM-ddTHH:mm:ss.sss\"),time:lb(\"time\",Sd,Kb(Sd,[\"HH\",\"mm\",\"ss\",\"sss\"]),\"HH:mm:ss.sss\"),week:lb(\"week\",mc,function(a,c){if(aa(a))return a;if(L(a)){mc.lastIndex=0;var d=mc.exec(a);if(d){var e=+d[1],f=+d[2],g=d=0,h=0,l=0,k=Ed(e),f=7*(f-1);c&&(d=c.getHours(),g=\nc.getMinutes(),h=c.getSeconds(),l=c.getMilliseconds());return new Date(e,0,k.getDate()+f,d,g,h,l)}}return NaN},\"yyyy-Www\"),month:lb(\"month\",Rd,Kb(Rd,[\"yyyy\",\"MM\"]),\"yyyy-MM\"),number:function(a,c,d,e,f,g){Id(a,c,d,e);kb(a,c,d,e,f,g);e.$$parserName=\"number\";e.$parsers.push(function(a){return e.$isEmpty(a)?null:ug.test(a)?parseFloat(a):t});e.$formatters.push(function(a){if(!e.$isEmpty(a)){if(!V(a))throw Lb(\"numfmt\",a);a=a.toString()}return a});if(w(d.min)||d.ngMin){var h;e.$validators.min=function(a){return e.$isEmpty(a)||\nA(h)||a>=h};d.$observe(\"min\",function(a){w(a)&&!V(a)&&(a=parseFloat(a,10));h=V(a)&&!isNaN(a)?a:t;e.$validate()})}if(w(d.max)||d.ngMax){var l;e.$validators.max=function(a){return e.$isEmpty(a)||A(l)||a<=l};d.$observe(\"max\",function(a){w(a)&&!V(a)&&(a=parseFloat(a,10));l=V(a)&&!isNaN(a)?a:t;e.$validate()})}},url:function(a,c,d,e,f,g){kb(a,c,d,e,f,g);kc(e);e.$$parserName=\"url\";e.$validators.url=function(a,c){var d=a||c;return e.$isEmpty(d)||sg.test(d)}},email:function(a,c,d,e,f,g){kb(a,c,d,e,f,g);kc(e);\ne.$$parserName=\"email\";e.$validators.email=function(a,c){var d=a||c;return e.$isEmpty(d)||tg.test(d)}},radio:function(a,c,d,e){A(d.name)&&c.attr(\"name\",++nb);c.on(\"click\",function(a){c[0].checked&&e.$setViewValue(d.value,a&&a.type)});e.$render=function(){c[0].checked=d.value==e.$viewValue};d.$observe(\"value\",e.$render)},checkbox:function(a,c,d,e,f,g,h,l){var k=Jd(l,a,\"ngTrueValue\",d.ngTrueValue,!0),n=Jd(l,a,\"ngFalseValue\",d.ngFalseValue,!1);c.on(\"click\",function(a){e.$setViewValue(c[0].checked,a&&\na.type)});e.$render=function(){c[0].checked=e.$viewValue};e.$isEmpty=function(a){return!1===a};e.$formatters.push(function(a){return ka(a,k)});e.$parsers.push(function(a){return a?k:n})},hidden:v,button:v,submit:v,reset:v,file:v},Fc=[\"$browser\",\"$sniffer\",\"$filter\",\"$parse\",function(a,c,d,e){return{restrict:\"E\",require:[\"?ngModel\"],link:{pre:function(f,g,h,l){l[0]&&(Td[M(h.type)]||Td.text)(f,g,h,l[0],c,a,d,e)}}}}],vg=/^(true|false|\\d+)$/,Oe=function(){return{restrict:\"A\",priority:100,compile:function(a,\nc){return vg.test(c.ngValue)?function(a,c,f){f.$set(\"value\",a.$eval(f.ngValue))}:function(a,c,f){a.$watch(f.ngValue,function(a){f.$set(\"value\",a)})}}}},oe=[\"$compile\",function(a){return{restrict:\"AC\",compile:function(c){a.$$addBindingClass(c);return function(c,e,f){a.$$addBindingInfo(e,f.ngBind);e=e[0];c.$watch(f.ngBind,function(a){e.textContent=a===t?\"\":a})}}}}],qe=[\"$interpolate\",\"$compile\",function(a,c){return{compile:function(d){c.$$addBindingClass(d);return function(d,f,g){d=a(f.attr(g.$attr.ngBindTemplate));\nc.$$addBindingInfo(f,d.expressions);f=f[0];g.$observe(\"ngBindTemplate\",function(a){f.textContent=a===t?\"\":a})}}}}],pe=[\"$sce\",\"$parse\",\"$compile\",function(a,c,d){return{restrict:\"A\",compile:function(e,f){var g=c(f.ngBindHtml),h=c(f.ngBindHtml,function(a){return(a||\"\").toString()});d.$$addBindingClass(e);return function(c,e,f){d.$$addBindingInfo(e,f.ngBindHtml);c.$watch(h,function(){e.html(a.getTrustedHtml(g(c))||\"\")})}}}}],Ne=ra({restrict:\"A\",require:\"ngModel\",link:function(a,c,d,e){e.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),\nre=lc(\"\",!0),te=lc(\"Odd\",0),se=lc(\"Even\",1),ue=Ma({compile:function(a,c){c.$set(\"ngCloak\",t);a.removeClass(\"ng-cloak\")}}),ve=[function(){return{restrict:\"A\",scope:!0,controller:\"@\",priority:500}}],Kc={},wg={blur:!0,focus:!0};m(\"click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste\".split(\" \"),function(a){var c=wa(\"ng-\"+a);Kc[c]=[\"$parse\",\"$rootScope\",function(d,e){return{restrict:\"A\",compile:function(f,g){var h=\nd(g[c],null,!0);return function(c,d){d.on(a,function(d){var f=function(){h(c,{$event:d})};wg[a]&&e.$$phase?c.$evalAsync(f):c.$apply(f)})}}}}]});var ye=[\"$animate\",function(a){return{multiElement:!0,transclude:\"element\",priority:600,terminal:!0,restrict:\"A\",$$tlb:!0,link:function(c,d,e,f,g){var h,l,k;c.$watch(e.ngIf,function(c){c?l||g(function(c,f){l=f;c[c.length++]=U.createComment(\" end ngIf: \"+e.ngIf+\" \");h={clone:c};a.enter(c,d.parent(),d)}):(k&&(k.remove(),k=null),l&&(l.$destroy(),l=null),h&&(k=\nqb(h.clone),a.leave(k).then(function(){k=null}),h=null))})}}}],ze=[\"$templateRequest\",\"$anchorScroll\",\"$animate\",function(a,c,d){return{restrict:\"ECA\",priority:400,terminal:!0,transclude:\"element\",controller:ca.noop,compile:function(e,f){var g=f.ngInclude||f.src,h=f.onload||\"\",l=f.autoscroll;return function(e,f,m,s,q){var t=0,F,u,p,v=function(){u&&(u.remove(),u=null);F&&(F.$destroy(),F=null);p&&(d.leave(p).then(function(){u=null}),u=p,p=null)};e.$watch(g,function(g){var m=function(){!w(l)||l&&!e.$eval(l)||\nc()},r=++t;g?(a(g,!0).then(function(a){if(r===t){var c=e.$new();s.template=a;a=q(c,function(a){v();d.enter(a,null,f).then(m)});F=c;p=a;F.$emit(\"$includeContentLoaded\",g);e.$eval(h)}},function(){r===t&&(v(),e.$emit(\"$includeContentError\",g))}),e.$emit(\"$includeContentRequested\",g)):(v(),s.template=null)})}}}}],Qe=[\"$compile\",function(a){return{restrict:\"ECA\",priority:-400,require:\"ngInclude\",link:function(c,d,e,f){/SVG/.test(d[0].toString())?(d.empty(),a(Nc(f.template,U).childNodes)(c,function(a){d.append(a)},\n{futureParentElement:d})):(d.html(f.template),a(d.contents())(c))}}}],Ae=Ma({priority:450,compile:function(){return{pre:function(a,c,d){a.$eval(d.ngInit)}}}}),Me=function(){return{restrict:\"A\",priority:100,require:\"ngModel\",link:function(a,c,d,e){var f=c.attr(d.$attr.ngList)||\", \",g=\"false\"!==d.ngTrim,h=g?R(f):f;e.$parsers.push(function(a){if(!A(a)){var c=[];a&&m(a.split(h),function(a){a&&c.push(g?R(a):a)});return c}});e.$formatters.push(function(a){return G(a)?a.join(f):t});e.$isEmpty=function(a){return!a||\n!a.length}}}},mb=\"ng-valid\",Kd=\"ng-invalid\",Va=\"ng-pristine\",Jb=\"ng-dirty\",Md=\"ng-pending\",Lb=new J(\"ngModel\"),xg=[\"$scope\",\"$exceptionHandler\",\"$attrs\",\"$element\",\"$parse\",\"$animate\",\"$timeout\",\"$rootScope\",\"$q\",\"$interpolate\",function(a,c,d,e,f,g,h,l,k,n){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=t;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=\n!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=t;this.$name=n(d.name||\"\",!1)(a);var r=f(d.ngModel),s=r.assign,q=r,C=s,F=null,u,p=this;this.$$setOptions=function(a){if((p.$options=a)&&a.getterSetter){var c=f(d.ngModel+\"()\"),g=f(d.ngModel+\"($$$p)\");q=function(a){var d=r(a);z(d)&&(d=c(a));return d};C=function(a,c){z(r(a))?g(a,{$$$p:p.$modelValue}):s(a,p.$modelValue)}}else if(!r.assign)throw Lb(\"nonassign\",d.ngModel,ua(e));};this.$render=v;this.$isEmpty=function(a){return A(a)||\n\"\"===a||null===a||a!==a};var K=e.inheritedData(\"$formController\")||Ib,y=0;Hd({ctrl:this,$element:e,set:function(a,c){a[c]=!0},unset:function(a,c){delete a[c]},parentForm:K,$animate:g});this.$setPristine=function(){p.$dirty=!1;p.$pristine=!0;g.removeClass(e,Jb);g.addClass(e,Va)};this.$setDirty=function(){p.$dirty=!0;p.$pristine=!1;g.removeClass(e,Va);g.addClass(e,Jb);K.$setDirty()};this.$setUntouched=function(){p.$touched=!1;p.$untouched=!0;g.setClass(e,\"ng-untouched\",\"ng-touched\")};this.$setTouched=\nfunction(){p.$touched=!0;p.$untouched=!1;g.setClass(e,\"ng-touched\",\"ng-untouched\")};this.$rollbackViewValue=function(){h.cancel(F);p.$viewValue=p.$$lastCommittedViewValue;p.$render()};this.$validate=function(){if(!V(p.$modelValue)||!isNaN(p.$modelValue)){var a=p.$$rawModelValue,c=p.$valid,d=p.$modelValue,e=p.$options&&p.$options.allowInvalid;p.$$runValidators(a,p.$$lastCommittedViewValue,function(f){e||c===f||(p.$modelValue=f?a:t,p.$modelValue!==d&&p.$$writeModelToScope())})}};this.$$runValidators=\nfunction(a,c,d){function e(){var d=!0;m(p.$validators,function(e,f){var h=e(a,c);d=d&&h;g(f,h)});return d?!0:(m(p.$asyncValidators,function(a,c){g(c,null)}),!1)}function f(){var d=[],e=!0;m(p.$asyncValidators,function(f,h){var k=f(a,c);if(!k||!z(k.then))throw Lb(\"$asyncValidators\",k);g(h,t);d.push(k.then(function(){g(h,!0)},function(a){e=!1;g(h,!1)}))});d.length?k.all(d).then(function(){h(e)},v):h(!0)}function g(a,c){l===y&&p.$setValidity(a,c)}function h(a){l===y&&d(a)}y++;var l=y;(function(){var a=\np.$$parserName||\"parse\";if(u===t)g(a,null);else return u||(m(p.$validators,function(a,c){g(c,null)}),m(p.$asyncValidators,function(a,c){g(c,null)})),g(a,u),u;return!0})()?e()?f():h(!1):h(!1)};this.$commitViewValue=function(){var a=p.$viewValue;h.cancel(F);if(p.$$lastCommittedViewValue!==a||\"\"===a&&p.$$hasNativeValidators)p.$$lastCommittedViewValue=a,p.$pristine&&this.$setDirty(),this.$$parseAndValidate()};this.$$parseAndValidate=function(){var c=p.$$lastCommittedViewValue;if(u=A(c)?t:!0)for(var d=\n0;d<p.$parsers.length;d++)if(c=p.$parsers[d](c),A(c)){u=!1;break}V(p.$modelValue)&&isNaN(p.$modelValue)&&(p.$modelValue=q(a));var e=p.$modelValue,f=p.$options&&p.$options.allowInvalid;p.$$rawModelValue=c;f&&(p.$modelValue=c,p.$modelValue!==e&&p.$$writeModelToScope());p.$$runValidators(c,p.$$lastCommittedViewValue,function(a){f||(p.$modelValue=a?c:t,p.$modelValue!==e&&p.$$writeModelToScope())})};this.$$writeModelToScope=function(){C(a,p.$modelValue);m(p.$viewChangeListeners,function(a){try{a()}catch(d){c(d)}})};\nthis.$setViewValue=function(a,c){p.$viewValue=a;p.$options&&!p.$options.updateOnDefault||p.$$debounceViewValueCommit(c)};this.$$debounceViewValueCommit=function(c){var d=0,e=p.$options;e&&w(e.debounce)&&(e=e.debounce,V(e)?d=e:V(e[c])?d=e[c]:V(e[\"default\"])&&(d=e[\"default\"]));h.cancel(F);d?F=h(function(){p.$commitViewValue()},d):l.$$phase?p.$commitViewValue():a.$apply(function(){p.$commitViewValue()})};a.$watch(function(){var c=q(a);if(c!==p.$modelValue&&(p.$modelValue===p.$modelValue||c===c)){p.$modelValue=\np.$$rawModelValue=c;u=t;for(var d=p.$formatters,e=d.length,f=c;e--;)f=d[e](f);p.$viewValue!==f&&(p.$viewValue=p.$$lastCommittedViewValue=f,p.$render(),p.$$runValidators(c,f,v))}return c})}],Le=[\"$rootScope\",function(a){return{restrict:\"A\",require:[\"ngModel\",\"^?form\",\"^?ngModelOptions\"],controller:xg,priority:1,compile:function(c){c.addClass(Va).addClass(\"ng-untouched\").addClass(mb);return{pre:function(a,c,f,g){var h=g[0],l=g[1]||Ib;h.$$setOptions(g[2]&&g[2].$options);l.$addControl(h);f.$observe(\"name\",\nfunction(a){h.$name!==a&&l.$$renameControl(h,a)});a.$on(\"$destroy\",function(){l.$removeControl(h)})},post:function(c,e,f,g){var h=g[0];if(h.$options&&h.$options.updateOn)e.on(h.$options.updateOn,function(a){h.$$debounceViewValueCommit(a&&a.type)});e.on(\"blur\",function(e){h.$touched||(a.$$phase?c.$evalAsync(h.$setTouched):c.$apply(h.$setTouched))})}}}}}],yg=/(\\s+|^)default(\\s+|$)/,Pe=function(){return{restrict:\"A\",controller:[\"$scope\",\"$attrs\",function(a,c){var d=this;this.$options=fa(a.$eval(c.ngModelOptions));\nthis.$options.updateOn!==t?(this.$options.updateOnDefault=!1,this.$options.updateOn=R(this.$options.updateOn.replace(yg,function(){d.$options.updateOnDefault=!0;return\" \"}))):this.$options.updateOnDefault=!0}]}},Be=Ma({terminal:!0,priority:1E3}),zg=J(\"ngOptions\"),Ag=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/,\nJe=[\"$compile\",\"$parse\",function(a,c){function d(a,d,e){function f(a,c,d,e,g){this.selectValue=a;this.viewValue=c;this.label=d;this.group=e;this.disabled=g}function n(a){var c;if(!q&&Ea(a))c=a;else{c=[];for(var d in a)a.hasOwnProperty(d)&&\"$\"!==d.charAt(0)&&c.push(d)}return c}var m=a.match(Ag);if(!m)throw zg(\"iexp\",a,ua(d));var s=m[5]||m[7],q=m[6];a=/ as /.test(m[0])&&m[1];var t=m[9];d=c(m[2]?m[1]:s);var v=a&&c(a)||d,u=t&&c(t),p=t?function(a,c){return u(e,c)}:function(a){return Ga(a)},w=function(a,\nc){return p(a,z(a,c))},y=c(m[2]||m[1]),A=c(m[3]||\"\"),B=c(m[4]||\"\"),N=c(m[8]),D={},z=q?function(a,c){D[q]=c;D[s]=a;return D}:function(a){D[s]=a;return D};return{trackBy:t,getTrackByValue:w,getWatchables:c(N,function(a){var c=[];a=a||[];for(var d=n(a),f=d.length,g=0;g<f;g++){var h=a===d?g:d[g],k=z(a[h],h),h=p(a[h],k);c.push(h);if(m[2]||m[1])h=y(e,k),c.push(h);m[4]&&(k=B(e,k),c.push(k))}return c}),getOptions:function(){for(var a=[],c={},d=N(e)||[],g=n(d),h=g.length,m=0;m<h;m++){var r=d===g?m:g[m],s=\nz(d[r],r),q=v(e,s),r=p(q,s),u=y(e,s),x=A(e,s),s=B(e,s),q=new f(r,q,u,x,s);a.push(q);c[r]=q}return{items:a,selectValueMap:c,getOptionFromViewValue:function(a){return c[w(a)]},getViewValueFromOption:function(a){return t?ca.copy(a.viewValue):a.viewValue}}}}}var e=U.createElement(\"option\"),f=U.createElement(\"optgroup\");return{restrict:\"A\",terminal:!0,require:[\"select\",\"?ngModel\"],link:function(c,h,l,k){function n(a,c){a.element=c;c.disabled=a.disabled;a.value!==c.value&&(c.value=a.selectValue);a.label!==\nc.label&&(c.label=a.label,c.textContent=a.label)}function r(a,c,d,e){c&&M(c.nodeName)===d?d=c:(d=e.cloneNode(!1),c?a.insertBefore(d,c):a.appendChild(d));return d}function s(a){for(var c;a;)c=a.nextSibling,Xb(a),a=c}function q(a){var c=p&&p[0],d=N&&N[0];if(c||d)for(;a&&(a===c||a===d);)a=a.nextSibling;return a}function t(){var a=D&&u.readValue();D=z.getOptions();var c={},d=h[0].firstChild;B&&h.prepend(p);d=q(d);D.items.forEach(function(a){var g,k;a.group?(g=c[a.group],g||(g=r(h[0],d,\"optgroup\",f),d=\ng.nextSibling,g.label=a.group,g=c[a.group]={groupElement:g,currentOptionElement:g.firstChild}),k=r(g.groupElement,g.currentOptionElement,\"option\",e),n(a,k),g.currentOptionElement=k.nextSibling):(k=r(h[0],d,\"option\",e),n(a,k),d=k.nextSibling)});Object.keys(c).forEach(function(a){s(c[a].currentOptionElement)});s(d);v.$render();if(!v.$isEmpty(a)){var g=u.readValue();(z.trackBy?ka(a,g):a===g)||(v.$setViewValue(g),v.$render())}}var v=k[1];if(v){var u=k[0];k=l.multiple;for(var p,w=0,A=h.children(),I=A.length;w<\nI;w++)if(\"\"===A[w].value){p=A.eq(w);break}var B=!!p,N=y(e.cloneNode(!1));N.val(\"?\");var D,z=d(l.ngOptions,h,c);k?(v.$isEmpty=function(a){return!a||0===a.length},u.writeValue=function(a){D.items.forEach(function(a){a.element.selected=!1});a&&a.forEach(function(a){(a=D.getOptionFromViewValue(a))&&!a.disabled&&(a.element.selected=!0)})},u.readValue=function(){var a=h.val()||[],c=[];m(a,function(a){a=D.selectValueMap[a];a.disabled||c.push(D.getViewValueFromOption(a))});return c},z.trackBy&&c.$watchCollection(function(){if(G(v.$viewValue))return v.$viewValue.map(function(a){return z.getTrackByValue(a)})},\nfunction(){v.$render()})):(u.writeValue=function(a){var c=D.getOptionFromViewValue(a);c&&!c.disabled?h[0].value!==c.selectValue&&(N.remove(),B||p.remove(),h[0].value=c.selectValue,c.element.selected=!0,c.element.setAttribute(\"selected\",\"selected\")):null===a||B?(N.remove(),B||h.prepend(p),h.val(\"\"),p.prop(\"selected\",!0),p.attr(\"selected\",!0)):(B||p.remove(),h.prepend(N),h.val(\"?\"),N.prop(\"selected\",!0),N.attr(\"selected\",!0))},u.readValue=function(){var a=D.selectValueMap[h.val()];return a&&!a.disabled?\n(B||p.remove(),N.remove(),D.getViewValueFromOption(a)):null},z.trackBy&&c.$watch(function(){return z.getTrackByValue(v.$viewValue)},function(){v.$render()}));B?(p.remove(),a(p)(c),p.removeClass(\"ng-scope\")):p=y(e.cloneNode(!1));t();c.$watchCollection(z.getWatchables,t)}}}}],Ce=[\"$locale\",\"$interpolate\",\"$log\",function(a,c,d){var e=/{}/g,f=/^when(Minus)?(.+)$/;return{link:function(g,h,l){function k(a){h.text(a||\"\")}var n=l.count,r=l.$attr.when&&h.attr(l.$attr.when),s=l.offset||0,q=g.$eval(r)||{},t=\n{},w=c.startSymbol(),u=c.endSymbol(),p=w+n+\"-\"+s+u,y=ca.noop,z;m(l,function(a,c){var d=f.exec(c);d&&(d=(d[1]?\"-\":\"\")+M(d[2]),q[d]=h.attr(l.$attr[c]))});m(q,function(a,d){t[d]=c(a.replace(e,p))});g.$watch(n,function(c){var e=parseFloat(c),f=isNaN(e);f||e in q||(e=a.pluralCat(e-s));e===z||f&&V(z)&&isNaN(z)||(y(),f=t[e],A(f)?(null!=c&&d.debug(\"ngPluralize: no rule defined for '\"+e+\"' in \"+r),y=v,k()):y=g.$watch(f,k),z=e)})}}}],De=[\"$parse\",\"$animate\",function(a,c){var d=J(\"ngRepeat\"),e=function(a,c,\nd,e,k,m,r){a[d]=e;k&&(a[k]=m);a.$index=c;a.$first=0===c;a.$last=c===r-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(c&1))};return{restrict:\"A\",multiElement:!0,transclude:\"element\",priority:1E3,terminal:!0,$$tlb:!0,compile:function(f,g){var h=g.ngRepeat,l=U.createComment(\" end ngRepeat: \"+h+\" \"),k=h.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);if(!k)throw d(\"iexp\",h);var n=k[1],r=k[2],s=k[3],q=k[4],k=n.match(/^(?:(\\s*[\\$\\w]+)|\\(\\s*([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\s*\\))$/);\nif(!k)throw d(\"iidexp\",n);var v=k[3]||k[1],w=k[2];if(s&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(s)||/^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(s)))throw d(\"badident\",s);var u,p,z,A,I={$id:Ga};q?u=a(q):(z=function(a,c){return Ga(c)},A=function(a){return a});return function(a,f,g,k,n){u&&(p=function(c,d,e){w&&(I[w]=c);I[v]=d;I.$index=e;return u(a,I)});var q=ga();a.$watchCollection(r,function(g){var k,r,u=f[0],x,D=ga(),I,H,L,G,M,J,O;s&&(a[s]=g);if(Ea(g))M=\ng,r=p||z;else for(O in r=p||A,M=[],g)g.hasOwnProperty(O)&&\"$\"!==O.charAt(0)&&M.push(O);I=M.length;O=Array(I);for(k=0;k<I;k++)if(H=g===M?k:M[k],L=g[H],G=r(H,L,k),q[G])J=q[G],delete q[G],D[G]=J,O[k]=J;else{if(D[G])throw m(O,function(a){a&&a.scope&&(q[a.id]=a)}),d(\"dupes\",h,G,L);O[k]={id:G,scope:t,clone:t};D[G]=!0}for(x in q){J=q[x];G=qb(J.clone);c.leave(G);if(G[0].parentNode)for(k=0,r=G.length;k<r;k++)G[k].$$NG_REMOVED=!0;J.scope.$destroy()}for(k=0;k<I;k++)if(H=g===M?k:M[k],L=g[H],J=O[k],J.scope){x=\nu;do x=x.nextSibling;while(x&&x.$$NG_REMOVED);J.clone[0]!=x&&c.move(qb(J.clone),null,y(u));u=J.clone[J.clone.length-1];e(J.scope,k,v,L,w,H,I)}else n(function(a,d){J.scope=d;var f=l.cloneNode(!1);a[a.length++]=f;c.enter(a,null,y(u));u=f;J.clone=a;D[J.id]=J;e(J.scope,k,v,L,w,H,I)});q=D})}}}}],Ee=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(c,d,e){c.$watch(e.ngShow,function(c){a[c?\"removeClass\":\"addClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],xe=[\"$animate\",\nfunction(a){return{restrict:\"A\",multiElement:!0,link:function(c,d,e){c.$watch(e.ngHide,function(c){a[c?\"addClass\":\"removeClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],Fe=Ma(function(a,c,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&m(d,function(a,d){c.css(d,\"\")});a&&c.css(a)},!0)}),Ge=[\"$animate\",function(a){return{require:\"ngSwitch\",controller:[\"$scope\",function(){this.cases={}}],link:function(c,d,e,f){var g=[],h=[],l=[],k=[],n=function(a,c){return function(){a.splice(c,1)}};c.$watch(e.ngSwitch||\ne.on,function(c){var d,e;d=0;for(e=l.length;d<e;++d)a.cancel(l[d]);d=l.length=0;for(e=k.length;d<e;++d){var q=qb(h[d].clone);k[d].$destroy();(l[d]=a.leave(q)).then(n(l,d))}h.length=0;k.length=0;(g=f.cases[\"!\"+c]||f.cases[\"?\"])&&m(g,function(c){c.transclude(function(d,e){k.push(e);var f=c.element;d[d.length++]=U.createComment(\" end ngSwitchWhen: \");h.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],He=Ma({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,c,d,e,\nf){e.cases[\"!\"+d.ngSwitchWhen]=e.cases[\"!\"+d.ngSwitchWhen]||[];e.cases[\"!\"+d.ngSwitchWhen].push({transclude:f,element:c})}}),Ie=Ma({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,c,d,e,f){e.cases[\"?\"]=e.cases[\"?\"]||[];e.cases[\"?\"].push({transclude:f,element:c})}}),Ke=Ma({restrict:\"EAC\",link:function(a,c,d,e,f){if(!f)throw J(\"ngTransclude\")(\"orphan\",ua(c));f(function(a){c.empty();c.append(a)})}}),ke=[\"$templateCache\",function(a){return{restrict:\"E\",terminal:!0,\ncompile:function(c,d){\"text/ng-template\"==d.type&&a.put(d.id,c[0].text)}}}],Bg={$setViewValue:v,$render:v},Cg=[\"$element\",\"$scope\",\"$attrs\",function(a,c,d){var e=this,f=new Sa;e.ngModelCtrl=Bg;e.unknownOption=y(U.createElement(\"option\"));e.renderUnknownOption=function(c){c=\"? \"+Ga(c)+\" ?\";e.unknownOption.val(c);a.prepend(e.unknownOption);a.val(c)};c.$on(\"$destroy\",function(){e.renderUnknownOption=v});e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.readValue=\nfunction(){e.removeUnknownOption();return a.val()};e.writeValue=function(c){e.hasOption(c)?(e.removeUnknownOption(),a.val(c),\"\"===c&&e.emptyOption.prop(\"selected\",!0)):null==c&&e.emptyOption?(e.removeUnknownOption(),a.val(\"\")):e.renderUnknownOption(c)};e.addOption=function(a,c){Ra(a,'\"option value\"');\"\"===a&&(e.emptyOption=c);var d=f.get(a)||0;f.put(a,d+1)};e.removeOption=function(a){var c=f.get(a);c&&(1===c?(f.remove(a),\"\"===a&&(e.emptyOption=t)):f.put(a,c-1))};e.hasOption=function(a){return!!f.get(a)}}],\nle=function(){return{restrict:\"E\",require:[\"select\",\"?ngModel\"],controller:Cg,link:function(a,c,d,e){var f=e[1];if(f){var g=e[0];g.ngModelCtrl=f;f.$render=function(){g.writeValue(f.$viewValue)};c.on(\"change\",function(){a.$apply(function(){f.$setViewValue(g.readValue())})});if(d.multiple){g.readValue=function(){var a=[];m(c.find(\"option\"),function(c){c.selected&&a.push(c.value)});return a};g.writeValue=function(a){var d=new Sa(a);m(c.find(\"option\"),function(a){a.selected=w(d.get(a.value))})};var h,\nl=NaN;a.$watch(function(){l!==f.$viewValue||ka(h,f.$viewValue)||(h=ia(f.$viewValue),f.$render());l=f.$viewValue});f.$isEmpty=function(a){return!a||0===a.length}}}}}},ne=[\"$interpolate\",function(a){function c(a){a[0].hasAttribute(\"selected\")&&(a[0].selected=!0)}return{restrict:\"E\",priority:100,compile:function(d,e){if(A(e.value)){var f=a(d.text(),!0);f||e.$set(\"value\",d.text())}return function(a,d,e){var k=d.parent(),m=k.data(\"$selectController\")||k.parent().data(\"$selectController\");m&&m.ngModelCtrl&&\n(f?a.$watch(f,function(a,f){e.$set(\"value\",a);f!==a&&m.removeOption(f);m.addOption(a,d);m.ngModelCtrl.$render();c(d)}):(m.addOption(e.value,d),m.ngModelCtrl.$render(),c(d)),d.on(\"$destroy\",function(){m.removeOption(e.value);m.ngModelCtrl.$render()}))}}}}],me=ra({restrict:\"E\",terminal:!1}),Hc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,c,d,e){e&&(d.required=!0,e.$validators.required=function(a,c){return!d.required||!e.$isEmpty(c)},d.$observe(\"required\",function(){e.$validate()}))}}},\nGc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,c,d,e){if(e){var f,g=d.ngPattern||d.pattern;d.$observe(\"pattern\",function(a){L(a)&&0<a.length&&(a=new RegExp(\"^\"+a+\"$\"));if(a&&!a.test)throw J(\"ngPattern\")(\"noregexp\",g,a,ua(c));f=a||t;e.$validate()});e.$validators.pattern=function(a){return e.$isEmpty(a)||A(f)||f.test(a)}}}}},Jc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,c,d,e){if(e){var f=-1;d.$observe(\"maxlength\",function(a){a=W(a);f=isNaN(a)?-1:a;e.$validate()});\ne.$validators.maxlength=function(a,c){return 0>f||e.$isEmpty(c)||c.length<=f}}}}},Ic=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,c,d,e){if(e){var f=0;d.$observe(\"minlength\",function(a){f=W(a)||0;e.$validate()});e.$validators.minlength=function(a,c){return e.$isEmpty(c)||c.length>=f}}}}};O.angular.bootstrap?console.log(\"WARNING: Tried to load angular more than once.\"):(ce(),ee(ca),y(U).ready(function(){Zd(U,Ac)}))})(window,document);!window.angular.$$csp()&&window.angular.element(document).find(\"head\").prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');\n//# sourceMappingURL=angular.min.js.map\n"

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(50))

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = "/*\n AngularJS v1.2.0\n (c) 2010-2012 Google, Inc. http://angularjs.org\n License: MIT\n*/\n(function(t,c,B){'use strict';function w(s,r,g,a,h){return{restrict:\"ECA\",terminal:!0,priority:400,transclude:\"element\",compile:function(k,d,A){return function(u,k,d){function v(){l&&(l.$destroy(),l=null);m&&(h.leave(m),m=null)}function x(){var f=s.current&&s.current.locals,y=f&&f.$template;if(y){var z=u.$new();A(z,function(e){e.html(y);h.enter(e,null,m||k,function(){!c.isDefined(n)||n&&!u.$eval(n)||r()});v();var p=g(e.contents()),q=s.current;l=q.scope=z;m=e;if(q.controller){f.$scope=l;var d=a(q.controller,\nf);q.controllerAs&&(l[q.controllerAs]=d);e.data(\"$ngControllerController\",d);e.children().data(\"$ngControllerController\",d)}p(l);l.$emit(\"$viewContentLoaded\");l.$eval(b)})}else v()}var l,m,n=d.autoscroll,b=d.onload||\"\";u.$on(\"$routeChangeSuccess\",x);x()}}}}t=c.module(\"ngRoute\",[\"ng\"]).provider(\"$route\",function(){function s(a,h){return c.extend(new (c.extend(function(){},{prototype:a})),h)}function r(a,c){var k=c.caseInsensitiveMatch,d={originalPath:a,regexp:a},g=d.keys=[];a=a.replace(/([().])/g,\n\"\\\\$1\").replace(/(\\/)?:(\\w+)([\\?|\\*])?/g,function(a,c,h,d){a=\"?\"===d?d:null;d=\"*\"===d?d:null;g.push({name:h,optional:!!a});c=c||\"\";return\"\"+(a?\"\":c)+\"(?:\"+(a?c:\"\")+(d&&\"(.+?)\"||\"([^/]+)\")+(a||\"\")+\")\"+(a||\"\")}).replace(/([\\/$\\*])/g,\"\\\\$1\");d.regexp=RegExp(\"^\"+a+\"$\",k?\"i\":\"\");return d}var g={};this.when=function(a,h){g[a]=c.extend({reloadOnSearch:!0},h,a&&r(a,h));if(a){var k=\"/\"==a[a.length-1]?a.substr(0,a.length-1):a+\"/\";g[k]=c.extend({redirectTo:a},r(k,h))}return this};this.otherwise=function(a){this.when(null,\na);return this};this.$get=[\"$rootScope\",\"$location\",\"$routeParams\",\"$q\",\"$injector\",\"$http\",\"$templateCache\",\"$sce\",function(a,h,k,d,r,u,t,w){function v(){var b=x(),f=n.current;if(b&&f&&b.$$route===f.$$route&&c.equals(b.pathParams,f.pathParams)&&!b.reloadOnSearch&&!m)f.params=b.params,c.copy(f.params,k),a.$broadcast(\"$routeUpdate\",f);else if(b||f)m=!1,a.$broadcast(\"$routeChangeStart\",b,f),(n.current=b)&&b.redirectTo&&(c.isString(b.redirectTo)?h.path(l(b.redirectTo,b.params)).search(b.params).replace():\nh.url(b.redirectTo(b.pathParams,h.path(),h.search())).replace()),d.when(b).then(function(){if(b){var a=c.extend({},b.resolve),f,e;c.forEach(a,function(b,f){a[f]=c.isString(b)?r.get(b):r.invoke(b)});c.isDefined(f=b.template)?c.isFunction(f)&&(f=f(b.params)):c.isDefined(e=b.templateUrl)&&(c.isFunction(e)&&(e=e(b.params)),e=w.getTrustedResourceUrl(e),c.isDefined(e)&&(b.loadedTemplateUrl=e,f=u.get(e,{cache:t}).then(function(b){return b.data})));c.isDefined(f)&&(a.$template=f);return d.all(a)}}).then(function(d){b==\nn.current&&(b&&(b.locals=d,c.copy(b.params,k)),a.$broadcast(\"$routeChangeSuccess\",b,f))},function(c){b==n.current&&a.$broadcast(\"$routeChangeError\",b,f,c)})}function x(){var b,a;c.forEach(g,function(d,l){var e;if(e=!a){var p=h.path();e=d.keys;var q={};if(d.regexp)if(p=d.regexp.exec(p)){for(var g=1,k=p.length;g<k;++g){var m=e[g-1],n=\"string\"==typeof p[g]?decodeURIComponent(p[g]):p[g];m&&n&&(q[m.name]=n)}e=q}else e=null;else e=null;e=b=e}e&&(a=s(d,{params:c.extend({},h.search(),b),pathParams:b}),a.$$route=\nd)});return a||g[null]&&s(g[null],{params:{},pathParams:{}})}function l(a,d){var g=[];c.forEach((a||\"\").split(\":\"),function(a,b){if(0===b)g.push(a);else{var c=a.match(/(\\w+)(.*)/),h=c[1];g.push(d[h]);g.push(c[2]||\"\");delete d[h]}});return g.join(\"\")}var m=!1,n={routes:g,reload:function(){m=!0;a.$evalAsync(v)}};a.$on(\"$locationChangeSuccess\",v);return n}]});t.provider(\"$routeParams\",function(){this.$get=function(){return{}}});t.directive(\"ngView\",w);w.$inject=[\"$route\",\"$anchorScroll\",\"$compile\",\"$controller\",\n\"$animate\"]})(window,window.angular);\n//# sourceMappingURL=angular-route.min.js.map\n"

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(52))

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = "/*\n AngularJS v1.3.15\n (c) 2010-2014 Google, Inc. http://angularjs.org\n License: MIT\n*/\n(function(I,d,B){'use strict';function D(f,q){q=q||{};d.forEach(q,function(d,h){delete q[h]});for(var h in f)!f.hasOwnProperty(h)||\"$\"===h.charAt(0)&&\"$\"===h.charAt(1)||(q[h]=f[h]);return q}var w=d.$$minErr(\"$resource\"),C=/^(\\.[a-zA-Z_$][0-9a-zA-Z_$]*)+$/;d.module(\"ngResource\",[\"ng\"]).provider(\"$resource\",function(){var f=this;this.defaults={stripTrailingSlashes:!0,actions:{get:{method:\"GET\"},save:{method:\"POST\"},query:{method:\"GET\",isArray:!0},remove:{method:\"DELETE\"},\"delete\":{method:\"DELETE\"}}};\nthis.$get=[\"$http\",\"$q\",function(q,h){function t(d,g){this.template=d;this.defaults=s({},f.defaults,g);this.urlParams={}}function v(x,g,l,m){function c(b,k){var c={};k=s({},g,k);r(k,function(a,k){u(a)&&(a=a());var d;if(a&&a.charAt&&\"@\"==a.charAt(0)){d=b;var e=a.substr(1);if(null==e||\"\"===e||\"hasOwnProperty\"===e||!C.test(\".\"+e))throw w(\"badmember\",e);for(var e=e.split(\".\"),n=0,g=e.length;n<g&&d!==B;n++){var h=e[n];d=null!==d?d[h]:B}}else d=a;c[k]=d});return c}function F(b){return b.resource}function e(b){D(b||\n{},this)}var G=new t(x,m);l=s({},f.defaults.actions,l);e.prototype.toJSON=function(){var b=s({},this);delete b.$promise;delete b.$resolved;return b};r(l,function(b,k){var g=/^(POST|PUT|PATCH)$/i.test(b.method);e[k]=function(a,y,m,x){var n={},f,l,z;switch(arguments.length){case 4:z=x,l=m;case 3:case 2:if(u(y)){if(u(a)){l=a;z=y;break}l=y;z=m}else{n=a;f=y;l=m;break}case 1:u(a)?l=a:g?f=a:n=a;break;case 0:break;default:throw w(\"badargs\",arguments.length);}var t=this instanceof e,p=t?f:b.isArray?[]:new e(f),\nA={},v=b.interceptor&&b.interceptor.response||F,C=b.interceptor&&b.interceptor.responseError||B;r(b,function(b,a){\"params\"!=a&&\"isArray\"!=a&&\"interceptor\"!=a&&(A[a]=H(b))});g&&(A.data=f);G.setUrlParams(A,s({},c(f,b.params||{}),n),b.url);n=q(A).then(function(a){var c=a.data,g=p.$promise;if(c){if(d.isArray(c)!==!!b.isArray)throw w(\"badcfg\",k,b.isArray?\"array\":\"object\",d.isArray(c)?\"array\":\"object\");b.isArray?(p.length=0,r(c,function(a){\"object\"===typeof a?p.push(new e(a)):p.push(a)})):(D(c,p),p.$promise=\ng)}p.$resolved=!0;a.resource=p;return a},function(a){p.$resolved=!0;(z||E)(a);return h.reject(a)});n=n.then(function(a){var b=v(a);(l||E)(b,a.headers);return b},C);return t?n:(p.$promise=n,p.$resolved=!1,p)};e.prototype[\"$\"+k]=function(a,b,c){u(a)&&(c=b,b=a,a={});a=e[k].call(this,a,this,b,c);return a.$promise||a}});e.bind=function(b){return v(x,s({},g,b),l)};return e}var E=d.noop,r=d.forEach,s=d.extend,H=d.copy,u=d.isFunction;t.prototype={setUrlParams:function(f,g,l){var m=this,c=l||m.template,h,\ne,q=m.urlParams={};r(c.split(/\\W/),function(b){if(\"hasOwnProperty\"===b)throw w(\"badname\");!/^\\d+$/.test(b)&&b&&(new RegExp(\"(^|[^\\\\\\\\]):\"+b+\"(\\\\W|$)\")).test(c)&&(q[b]=!0)});c=c.replace(/\\\\:/g,\":\");g=g||{};r(m.urlParams,function(b,k){h=g.hasOwnProperty(k)?g[k]:m.defaults[k];d.isDefined(h)&&null!==h?(e=encodeURIComponent(h).replace(/%40/gi,\"@\").replace(/%3A/gi,\":\").replace(/%24/g,\"$\").replace(/%2C/gi,\",\").replace(/%20/g,\"%20\").replace(/%26/gi,\"&\").replace(/%3D/gi,\"=\").replace(/%2B/gi,\"+\"),c=c.replace(new RegExp(\":\"+\nk+\"(\\\\W|$)\",\"g\"),function(b,a){return e+a})):c=c.replace(new RegExp(\"(/?):\"+k+\"(\\\\W|$)\",\"g\"),function(b,a,c){return\"/\"==c.charAt(0)?c:a+c})});m.defaults.stripTrailingSlashes&&(c=c.replace(/\\/+$/,\"\")||\"/\");c=c.replace(/\\/\\.(?=\\w+($|\\?))/,\".\");f.url=c.replace(/\\/\\\\\\./,\"/.\");r(g,function(b,c){m.urlParams[c]||(f.params=f.params||{},f.params[c]=b)})}};return v}]})})(window,window.angular);\n//# sourceMappingURL=angular-resource.min.js.map\n"

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(54))

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 1.1.1 - 2016-01-25\n * License: MIT\n */angular.module(\"ui.bootstrap\",[\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]),angular.module(\"ui.bootstrap.collapse\",[]).directive(\"uibCollapse\",[\"$animate\",\"$q\",\"$parse\",\"$injector\",function(a,b,c,d){var e=d.has(\"$animateCss\")?d.get(\"$animateCss\"):null;return{link:function(d,f,g){function h(){f.hasClass(\"collapse\")&&f.hasClass(\"in\")||b.resolve(l(d)).then(function(){f.removeClass(\"collapse\").addClass(\"collapsing\").attr(\"aria-expanded\",!0).attr(\"aria-hidden\",!1),e?e(f,{addClass:\"in\",easing:\"ease\",to:{height:f[0].scrollHeight+\"px\"}}).start()[\"finally\"](i):a.addClass(f,\"in\",{to:{height:f[0].scrollHeight+\"px\"}}).then(i)})}function i(){f.removeClass(\"collapsing\").addClass(\"collapse\").css({height:\"auto\"}),m(d)}function j(){return f.hasClass(\"collapse\")||f.hasClass(\"in\")?void b.resolve(n(d)).then(function(){f.css({height:f[0].scrollHeight+\"px\"}).removeClass(\"collapse\").addClass(\"collapsing\").attr(\"aria-expanded\",!1).attr(\"aria-hidden\",!0),e?e(f,{removeClass:\"in\",to:{height:\"0\"}}).start()[\"finally\"](k):a.removeClass(f,\"in\",{to:{height:\"0\"}}).then(k)}):k()}function k(){f.css({height:\"0\"}),f.removeClass(\"collapsing\").addClass(\"collapse\"),o(d)}var l=c(g.expanding),m=c(g.expanded),n=c(g.collapsing),o=c(g.collapsed);d.$eval(g.uibCollapse)||f.addClass(\"in\").addClass(\"collapse\").attr(\"aria-expanded\",!0).attr(\"aria-hidden\",!1).css({height:\"auto\"}),d.$watch(g.uibCollapse,function(a){a?j():h()})}}}]),angular.module(\"ui.bootstrap.accordion\",[\"ui.bootstrap.collapse\"]).constant(\"uibAccordionConfig\",{closeOthers:!0}).controller(\"UibAccordionController\",[\"$scope\",\"$attrs\",\"uibAccordionConfig\",function(a,b,c){this.groups=[],this.closeOthers=function(d){var e=angular.isDefined(b.closeOthers)?a.$eval(b.closeOthers):c.closeOthers;e&&angular.forEach(this.groups,function(a){a!==d&&(a.isOpen=!1)})},this.addGroup=function(a){var b=this;this.groups.push(a),a.$on(\"$destroy\",function(c){b.removeGroup(a)})},this.removeGroup=function(a){var b=this.groups.indexOf(a);-1!==b&&this.groups.splice(b,1)}}]).directive(\"uibAccordion\",function(){return{controller:\"UibAccordionController\",controllerAs:\"accordion\",transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/accordion/accordion.html\"}}}).directive(\"uibAccordionGroup\",function(){return{require:\"^uibAccordion\",transclude:!0,replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/accordion/accordion-group.html\"},scope:{heading:\"@\",isOpen:\"=?\",isDisabled:\"=?\"},controller:function(){this.setHeading=function(a){this.heading=a}},link:function(a,b,c,d){d.addGroup(a),a.openClass=c.openClass||\"panel-open\",a.panelClass=c.panelClass||\"panel-default\",a.$watch(\"isOpen\",function(c){b.toggleClass(a.openClass,!!c),c&&d.closeOthers(a)}),a.toggleOpen=function(b){a.isDisabled||b&&32!==b.which||(a.isOpen=!a.isOpen)}}}}).directive(\"uibAccordionHeading\",function(){return{transclude:!0,template:\"\",replace:!0,require:\"^uibAccordionGroup\",link:function(a,b,c,d,e){d.setHeading(e(a,angular.noop))}}}).directive(\"uibAccordionTransclude\",function(){return{require:\"^uibAccordionGroup\",link:function(a,b,c,d){a.$watch(function(){return d[c.uibAccordionTransclude]},function(a){a&&(b.find(\"span\").html(\"\"),b.find(\"span\").append(a))})}}}),angular.module(\"ui.bootstrap.alert\",[]).controller(\"UibAlertController\",[\"$scope\",\"$attrs\",\"$interpolate\",\"$timeout\",function(a,b,c,d){a.closeable=!!b.close;var e=angular.isDefined(b.dismissOnTimeout)?c(b.dismissOnTimeout)(a.$parent):null;e&&d(function(){a.close()},parseInt(e,10))}]).directive(\"uibAlert\",function(){return{controller:\"UibAlertController\",controllerAs:\"alert\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/alert/alert.html\"},transclude:!0,replace:!0,scope:{type:\"@\",close:\"&\"}}}),angular.module(\"ui.bootstrap.buttons\",[]).constant(\"uibButtonConfig\",{activeClass:\"active\",toggleEvent:\"click\"}).controller(\"UibButtonsController\",[\"uibButtonConfig\",function(a){this.activeClass=a.activeClass||\"active\",this.toggleEvent=a.toggleEvent||\"click\"}]).directive(\"uibBtnRadio\",[\"$parse\",function(a){return{require:[\"uibBtnRadio\",\"ngModel\"],controller:\"UibButtonsController\",controllerAs:\"buttons\",link:function(b,c,d,e){var f=e[0],g=e[1],h=a(d.uibUncheckable);c.find(\"input\").css({display:\"none\"}),g.$render=function(){c.toggleClass(f.activeClass,angular.equals(g.$modelValue,b.$eval(d.uibBtnRadio)))},c.on(f.toggleEvent,function(){if(!d.disabled){var a=c.hasClass(f.activeClass);(!a||angular.isDefined(d.uncheckable))&&b.$apply(function(){g.$setViewValue(a?null:b.$eval(d.uibBtnRadio)),g.$render()})}}),d.uibUncheckable&&b.$watch(h,function(a){d.$set(\"uncheckable\",a?\"\":null)})}}}]).directive(\"uibBtnCheckbox\",function(){return{require:[\"uibBtnCheckbox\",\"ngModel\"],controller:\"UibButtonsController\",controllerAs:\"button\",link:function(a,b,c,d){function e(){return g(c.btnCheckboxTrue,!0)}function f(){return g(c.btnCheckboxFalse,!1)}function g(b,c){return angular.isDefined(b)?a.$eval(b):c}var h=d[0],i=d[1];b.find(\"input\").css({display:\"none\"}),i.$render=function(){b.toggleClass(h.activeClass,angular.equals(i.$modelValue,e()))},b.on(h.toggleEvent,function(){c.disabled||a.$apply(function(){i.$setViewValue(b.hasClass(h.activeClass)?f():e()),i.$render()})})}}}),angular.module(\"ui.bootstrap.carousel\",[]).controller(\"UibCarouselController\",[\"$scope\",\"$element\",\"$interval\",\"$timeout\",\"$animate\",function(a,b,c,d,e){function f(){for(;s.length;)s.shift()}function g(a){if(angular.isUndefined(p[a].index))return p[a];for(var b=0,c=p.length;c>b;++b)if(p[b].index===a)return p[b]}function h(c,d,g){t||(angular.extend(c,{direction:g,active:!0}),angular.extend(o.currentSlide||{},{direction:g,active:!1}),e.enabled(b)&&!a.$currentTransition&&c.$element&&o.slides.length>1&&(c.$element.data(q,c.direction),o.currentSlide&&o.currentSlide.$element&&o.currentSlide.$element.data(q,c.direction),a.$currentTransition=!0,e.on(\"addClass\",c.$element,function(b,c){if(\"close\"===c&&(a.$currentTransition=null,e.off(\"addClass\",b),s.length)){var d=s.pop(),g=a.indexOfSlide(d),i=g>o.getCurrentIndex()?\"next\":\"prev\";f(),h(d,g,i)}})),o.currentSlide=c,r=d,k())}function i(){m&&(c.cancel(m),m=null)}function j(b){b.length||(a.$currentTransition=null,f())}function k(){i();var b=+a.interval;!isNaN(b)&&b>0&&(m=c(l,b))}function l(){var b=+a.interval;n&&!isNaN(b)&&b>0&&p.length?a.next():a.pause()}var m,n,o=this,p=o.slides=a.slides=[],q=\"uib-slideDirection\",r=-1,s=[];o.currentSlide=null;var t=!1;o.addSlide=function(b,c){b.$element=c,p.push(b),1===p.length||b.active?(a.$currentTransition&&(a.$currentTransition=null),o.select(p[p.length-1]),1===p.length&&a.play()):b.active=!1},o.getCurrentIndex=function(){return o.currentSlide&&angular.isDefined(o.currentSlide.index)?+o.currentSlide.index:r},o.next=a.next=function(){var b=(o.getCurrentIndex()+1)%p.length;return 0===b&&a.noWrap()?void a.pause():o.select(g(b),\"next\")},o.prev=a.prev=function(){var b=o.getCurrentIndex()-1<0?p.length-1:o.getCurrentIndex()-1;return a.noWrap()&&b===p.length-1?void a.pause():o.select(g(b),\"prev\")},o.removeSlide=function(a){angular.isDefined(a.index)&&p.sort(function(a,b){return+a.index>+b.index});var b=s.indexOf(a);-1!==b&&s.splice(b,1);var c=p.indexOf(a);p.splice(c,1),d(function(){p.length>0&&a.active?c>=p.length?o.select(p[c-1]):o.select(p[c]):r>c&&r--}),0===p.length&&(o.currentSlide=null,f())},o.select=a.select=function(b,c){var d=a.indexOfSlide(b);void 0===c&&(c=d>o.getCurrentIndex()?\"next\":\"prev\"),b&&b!==o.currentSlide&&!a.$currentTransition?h(b,d,c):b&&b!==o.currentSlide&&a.$currentTransition&&(s.push(b),b.active=!1)},a.indexOfSlide=function(a){return angular.isDefined(a.index)?+a.index:p.indexOf(a)},a.isActive=function(a){return o.currentSlide===a},a.pause=function(){a.noPause||(n=!1,i())},a.play=function(){n||(n=!0,k())},a.$on(\"$destroy\",function(){t=!0,i()}),a.$watch(\"noTransition\",function(a){e.enabled(b,!a)}),a.$watch(\"interval\",k),a.$watchCollection(\"slides\",j)}]).directive(\"uibCarousel\",function(){return{transclude:!0,replace:!0,controller:\"UibCarouselController\",controllerAs:\"carousel\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/carousel/carousel.html\"},scope:{interval:\"=\",noTransition:\"=\",noPause:\"=\",noWrap:\"&\"}}}).directive(\"uibSlide\",function(){return{require:\"^uibCarousel\",transclude:!0,replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/carousel/slide.html\"},scope:{active:\"=?\",actual:\"=?\",index:\"=?\"},link:function(a,b,c,d){d.addSlide(a,b),a.$on(\"$destroy\",function(){d.removeSlide(a)}),a.$watch(\"active\",function(b){b&&d.select(a)})}}}).animation(\".item\",[\"$animateCss\",function(a){function b(a,b,c){a.removeClass(b),c&&c()}var c=\"uib-slideDirection\";return{beforeAddClass:function(d,e,f){if(\"active\"===e){var g=!1,h=d.data(c),i=\"next\"===h?\"left\":\"right\",j=b.bind(this,d,i+\" \"+h,f);return d.addClass(h),a(d,{addClass:i}).start().done(j),function(){g=!0}}f()},beforeRemoveClass:function(d,e,f){if(\"active\"===e){var g=!1,h=d.data(c),i=\"next\"===h?\"left\":\"right\",j=b.bind(this,d,i,f);return a(d,{addClass:i}).start().done(j),function(){g=!0}}f()}}}]),angular.module(\"ui.bootstrap.dateparser\",[]).service(\"uibDateParser\",[\"$log\",\"$locale\",\"orderByFilter\",function(a,b,c){function d(a){var b=[],d=a.split(\"\"),e=a.indexOf(\"'\");if(e>-1){var f=!1;a=a.split(\"\");for(var g=e;g<a.length;g++)f?(\"'\"===a[g]&&(g+1<a.length&&\"'\"===a[g+1]?(a[g+1]=\"$\",d[g+1]=\"\"):(d[g]=\"\",f=!1)),a[g]=\"$\"):\"'\"===a[g]&&(a[g]=\"$\",d[g]=\"\",f=!0);a=a.join(\"\")}return angular.forEach(m,function(c){var e=a.indexOf(c.key);if(e>-1){a=a.split(\"\"),d[e]=\"(\"+c.regex+\")\",a[e]=\"$\";for(var f=e+1,g=e+c.key.length;g>f;f++)d[f]=\"\",a[f]=\"$\";a=a.join(\"\"),b.push({index:e,apply:c.apply,matcher:c.regex})}}),{regex:new RegExp(\"^\"+d.join(\"\")+\"$\"),map:c(b,\"index\")}}function e(a,b,c){return 1>c?!1:1===b&&c>28?29===c&&(a%4===0&&a%100!==0||a%400===0):3===b||5===b||8===b||10===b?31>c:!0}function f(a){return parseInt(a,10)}function g(a,b){return a&&b?k(a,b):a}function h(a,b){return a&&b?k(a,b,!0):a}function i(a,b){var c=Date.parse(\"Jan 01, 1970 00:00:00 \"+a)/6e4;return isNaN(c)?b:c}function j(a,b){return a=new Date(a.getTime()),a.setMinutes(a.getMinutes()+b),a}function k(a,b,c){c=c?-1:1;var d=i(b,a.getTimezoneOffset());return j(a,c*(d-a.getTimezoneOffset()))}var l,m,n=/[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;this.init=function(){l=b.id,this.parsers={},m=[{key:\"yyyy\",regex:\"\\\\d{4}\",apply:function(a){this.year=+a}},{key:\"yy\",regex:\"\\\\d{2}\",apply:function(a){this.year=+a+2e3}},{key:\"y\",regex:\"\\\\d{1,4}\",apply:function(a){this.year=+a}},{key:\"M!\",regex:\"0?[1-9]|1[0-2]\",apply:function(a){this.month=a-1}},{key:\"MMMM\",regex:b.DATETIME_FORMATS.MONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.MONTH.indexOf(a)}},{key:\"MMM\",regex:b.DATETIME_FORMATS.SHORTMONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.SHORTMONTH.indexOf(a)}},{key:\"MM\",regex:\"0[1-9]|1[0-2]\",apply:function(a){this.month=a-1}},{key:\"M\",regex:\"[1-9]|1[0-2]\",apply:function(a){this.month=a-1}},{key:\"d!\",regex:\"[0-2]?[0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a}},{key:\"dd\",regex:\"[0-2][0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a}},{key:\"d\",regex:\"[1-2]?[0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a}},{key:\"EEEE\",regex:b.DATETIME_FORMATS.DAY.join(\"|\")},{key:\"EEE\",regex:b.DATETIME_FORMATS.SHORTDAY.join(\"|\")},{key:\"HH\",regex:\"(?:0|1)[0-9]|2[0-3]\",apply:function(a){this.hours=+a}},{key:\"hh\",regex:\"0[0-9]|1[0-2]\",apply:function(a){this.hours=+a}},{key:\"H\",regex:\"1?[0-9]|2[0-3]\",apply:function(a){this.hours=+a}},{key:\"h\",regex:\"[0-9]|1[0-2]\",apply:function(a){this.hours=+a}},{key:\"mm\",regex:\"[0-5][0-9]\",apply:function(a){this.minutes=+a}},{key:\"m\",regex:\"[0-9]|[1-5][0-9]\",apply:function(a){this.minutes=+a}},{key:\"sss\",regex:\"[0-9][0-9][0-9]\",apply:function(a){this.milliseconds=+a}},{key:\"ss\",regex:\"[0-5][0-9]\",apply:function(a){this.seconds=+a}},{key:\"s\",regex:\"[0-9]|[1-5][0-9]\",apply:function(a){this.seconds=+a}},{key:\"a\",regex:b.DATETIME_FORMATS.AMPMS.join(\"|\"),apply:function(a){12===this.hours&&(this.hours=0),\"PM\"===a&&(this.hours+=12)}},{key:\"Z\",regex:\"[+-]\\\\d{4}\",apply:function(a){var b=a.match(/([+-])(\\d{2})(\\d{2})/),c=b[1],d=b[2],e=b[3];this.hours+=f(c+d),this.minutes+=f(c+e)}},{key:\"ww\",regex:\"[0-4][0-9]|5[0-3]\"},{key:\"w\",regex:\"[0-9]|[1-4][0-9]|5[0-3]\"},{key:\"GGGG\",regex:b.DATETIME_FORMATS.ERANAMES.join(\"|\").replace(/\\s/g,\"\\\\s\")},{key:\"GGG\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\")},{key:\"GG\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\")},{key:\"G\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\")}]},this.init(),this.parse=function(c,f,g){if(!angular.isString(c)||!f)return c;f=b.DATETIME_FORMATS[f]||f,f=f.replace(n,\"\\\\$&\"),b.id!==l&&this.init(),this.parsers[f]||(this.parsers[f]=d(f));var h=this.parsers[f],i=h.regex,j=h.map,k=c.match(i),m=!1;if(k&&k.length){var o,p;angular.isDate(g)&&!isNaN(g.getTime())?o={year:g.getFullYear(),month:g.getMonth(),date:g.getDate(),hours:g.getHours(),minutes:g.getMinutes(),seconds:g.getSeconds(),milliseconds:g.getMilliseconds()}:(g&&a.warn(\"dateparser:\",\"baseDate is not a valid date\"),o={year:1900,month:0,date:1,hours:0,minutes:0,seconds:0,milliseconds:0});for(var q=1,r=k.length;r>q;q++){var s=j[q-1];\"Z\"===s.matcher&&(m=!0),s.apply&&s.apply.call(o,k[q])}var t=m?Date.prototype.setUTCFullYear:Date.prototype.setFullYear,u=m?Date.prototype.setUTCHours:Date.prototype.setHours;return e(o.year,o.month,o.date)&&(!angular.isDate(g)||isNaN(g.getTime())||m?(p=new Date(0),t.call(p,o.year,o.month,o.date),u.call(p,o.hours||0,o.minutes||0,o.seconds||0,o.milliseconds||0)):(p=new Date(g),t.call(p,o.year,o.month,o.date),u.call(p,o.hours,o.minutes,o.seconds,o.milliseconds))),p}},this.toTimezone=g,this.fromTimezone=h,this.timezoneToOffset=i,this.addDateMinutes=j,this.convertTimezoneToLocal=k}]),angular.module(\"ui.bootstrap.isClass\",[]).directive(\"uibIsClass\",[\"$animate\",function(a){var b=/^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/,c=/^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;return{restrict:\"A\",compile:function(d,e){function f(a,b,c){i.push(a),j.push({scope:a,element:b}),o.forEach(function(b,c){g(b,a)}),a.$on(\"$destroy\",h)}function g(b,d){var e=b.match(c),f=d.$eval(e[1]),g=e[2],h=k[b];if(!h){var i=function(b){var c=null;j.some(function(a){var d=a.scope.$eval(m);return d===b?(c=a,!0):void 0}),h.lastActivated!==c&&(h.lastActivated&&a.removeClass(h.lastActivated.element,f),c&&a.addClass(c.element,f),h.lastActivated=c)};k[b]=h={lastActivated:null,scope:d,watchFn:i,compareWithExp:g,watcher:d.$watch(g,i)}}h.watchFn(d.$eval(g))}function h(a){var b=a.targetScope,c=i.indexOf(b);if(i.splice(c,1),j.splice(c,1),i.length){var d=i[0];angular.forEach(k,function(a){a.scope===b&&(a.watcher=d.$watch(a.compareWithExp,a.watchFn),a.scope=d)})}else k={}}var i=[],j=[],k={},l=e.uibIsClass.match(b),m=l[2],n=l[1],o=n.split(\",\");return f}}}]),angular.module(\"ui.bootstrap.position\",[]).factory(\"$uibPosition\",[\"$document\",\"$window\",function(a,b){var c,d={normal:/(auto|scroll)/,hidden:/(auto|scroll|hidden)/},e={auto:/\\s?auto?\\s?/i,primary:/^(top|bottom|left|right)$/,secondary:/^(top|bottom|left|right|center)$/,vertical:/^(top|bottom)$/};return{getRawNode:function(a){return a[0]||a},parseStyle:function(a){return a=parseFloat(a),isFinite(a)?a:0},offsetParent:function(c){function d(a){return\"static\"===(b.getComputedStyle(a).position||\"static\")}c=this.getRawNode(c);for(var e=c.offsetParent||a[0].documentElement;e&&e!==a[0].documentElement&&d(e);)e=e.offsetParent;return e||a[0].documentElement},scrollbarWidth:function(){if(angular.isUndefined(c)){var b=angular.element('<div style=\"position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;\"></div>');a.find(\"body\").append(b),c=b[0].offsetWidth-b[0].clientWidth,c=isFinite(c)?c:0,b.remove()}return c},scrollParent:function(c,e){c=this.getRawNode(c);var f=e?d.hidden:d.normal,g=a[0].documentElement,h=b.getComputedStyle(c),i=\"absolute\"===h.position,j=c.parentElement||g;if(j===g||\"fixed\"===h.position)return g;for(;j.parentElement&&j!==g;){var k=b.getComputedStyle(j);if(i&&\"static\"!==k.position&&(i=!1),!i&&f.test(k.overflow+k.overflowY+k.overflowX))break;j=j.parentElement}return j},position:function(c,d){c=this.getRawNode(c);var e=this.offset(c);if(d){var f=b.getComputedStyle(c);e.top-=this.parseStyle(f.marginTop),e.left-=this.parseStyle(f.marginLeft)}var g=this.offsetParent(c),h={top:0,left:0};return g!==a[0].documentElement&&(h=this.offset(g),h.top+=g.clientTop-g.scrollTop,h.left+=g.clientLeft-g.scrollLeft),{width:Math.round(angular.isNumber(e.width)?e.width:c.offsetWidth),height:Math.round(angular.isNumber(e.height)?e.height:c.offsetHeight),top:Math.round(e.top-h.top),left:Math.round(e.left-h.left)}},offset:function(c){c=this.getRawNode(c);var d=c.getBoundingClientRect();return{width:Math.round(angular.isNumber(d.width)?d.width:c.offsetWidth),height:Math.round(angular.isNumber(d.height)?d.height:c.offsetHeight),top:Math.round(d.top+(b.pageYOffset||a[0].documentElement.scrollTop)),left:Math.round(d.left+(b.pageXOffset||a[0].documentElement.scrollLeft))}},viewportOffset:function(c,d,e){c=this.getRawNode(c),e=e!==!1?!0:!1;var f=c.getBoundingClientRect(),g={top:0,left:0,bottom:0,right:0},h=d?a[0].documentElement:this.scrollParent(c),i=h.getBoundingClientRect();if(g.top=i.top+h.clientTop,g.left=i.left+h.clientLeft,h===a[0].documentElement&&(g.top+=b.pageYOffset,g.left+=b.pageXOffset),g.bottom=g.top+h.clientHeight,g.right=g.left+h.clientWidth,e){var j=b.getComputedStyle(h);g.top+=this.parseStyle(j.paddingTop),g.bottom-=this.parseStyle(j.paddingBottom),g.left+=this.parseStyle(j.paddingLeft),g.right-=this.parseStyle(j.paddingRight)}return{top:Math.round(f.top-g.top),bottom:Math.round(g.bottom-f.bottom),left:Math.round(f.left-g.left),right:Math.round(g.right-f.right)}},parsePlacement:function(a){var b=e.auto.test(a);return b&&(a=a.replace(e.auto,\"\")),a=a.split(\"-\"),a[0]=a[0]||\"top\",e.primary.test(a[0])||(a[0]=\"top\"),a[1]=a[1]||\"center\",e.secondary.test(a[1])||(a[1]=\"center\"),b?a[2]=!0:a[2]=!1,a},positionElements:function(a,c,d,f){a=this.getRawNode(a),c=this.getRawNode(c);var g=angular.isDefined(c.offsetWidth)?c.offsetWidth:c.prop(\"offsetWidth\"),h=angular.isDefined(c.offsetHeight)?c.offsetHeight:c.prop(\"offsetHeight\");d=this.parsePlacement(d);var i=f?this.offset(a):this.position(a),j={top:0,left:0,placement:\"\"};if(d[2]){var k=this.viewportOffset(a),l=b.getComputedStyle(c),m={width:g+Math.round(Math.abs(this.parseStyle(l.marginLeft)+this.parseStyle(l.marginRight))),height:h+Math.round(Math.abs(this.parseStyle(l.marginTop)+this.parseStyle(l.marginBottom)))};if(d[0]=\"top\"===d[0]&&m.height>k.top&&m.height<=k.bottom?\"bottom\":\"bottom\"===d[0]&&m.height>k.bottom&&m.height<=k.top?\"top\":\"left\"===d[0]&&m.width>k.left&&m.width<=k.right?\"right\":\"right\"===d[0]&&m.width>k.right&&m.width<=k.left?\"left\":d[0],d[1]=\"top\"===d[1]&&m.height-i.height>k.bottom&&m.height-i.height<=k.top?\"bottom\":\"bottom\"===d[1]&&m.height-i.height>k.top&&m.height-i.height<=k.bottom?\"top\":\"left\"===d[1]&&m.width-i.width>k.right&&m.width-i.width<=k.left?\"right\":\"right\"===d[1]&&m.width-i.width>k.left&&m.width-i.width<=k.right?\"left\":d[1],\"center\"===d[1])if(e.vertical.test(d[0])){var n=i.width/2-g/2;k.left+n<0&&m.width-i.width<=k.right?d[1]=\"left\":k.right+n<0&&m.width-i.width<=k.left&&(d[1]=\"right\")}else{var o=i.height/2-m.height/2;k.top+o<0&&m.height-i.height<=k.bottom?d[1]=\"top\":k.bottom+o<0&&m.height-i.height<=k.top&&(d[1]=\"bottom\")}}switch(d[0]){case\"top\":j.top=i.top-h;break;case\"bottom\":j.top=i.top+i.height;break;case\"left\":j.left=i.left-g;break;case\"right\":j.left=i.left+i.width}switch(d[1]){case\"top\":j.top=i.top;break;case\"bottom\":j.top=i.top+i.height-h;break;case\"left\":j.left=i.left;break;case\"right\":j.left=i.left+i.width-g;break;case\"center\":e.vertical.test(d[0])?j.left=i.left+i.width/2-g/2:j.top=i.top+i.height/2-h/2}return j.top=Math.round(j.top),j.left=Math.round(j.left),j.placement=\"center\"===d[1]?d[0]:d[0]+\"-\"+d[1],j},positionArrow:function(a,c){a=this.getRawNode(a);var d=a.querySelector(\".tooltip-inner, .popover-inner\");if(d){var f=angular.element(d).hasClass(\"tooltip-inner\"),g=f?a.querySelector(\".tooltip-arrow\"):a.querySelector(\".arrow\");if(g){if(c=this.parsePlacement(c),\"center\"===c[1])return void angular.element(g).css({top:\"\",bottom:\"\",right:\"\",left:\"\",margin:\"\"});var h=\"border-\"+c[0]+\"-width\",i=b.getComputedStyle(g)[h],j=\"border-\";j+=e.vertical.test(c[0])?c[0]+\"-\"+c[1]:c[1]+\"-\"+c[0],j+=\"-radius\";var k=b.getComputedStyle(f?d:a)[j],l={top:\"auto\",bottom:\"auto\",left:\"auto\",right:\"auto\",margin:0};switch(c[0]){case\"top\":l.bottom=f?\"0\":\"-\"+i;break;case\"bottom\":l.top=f?\"0\":\"-\"+i;break;case\"left\":l.right=f?\"0\":\"-\"+i;break;case\"right\":l.left=f?\"0\":\"-\"+i}l[c[1]]=k,angular.element(g).css(l)}}}}}]),angular.module(\"ui.bootstrap.datepicker\",[\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\"]).value(\"$datepickerSuppressError\",!1).constant(\"uibDatepickerConfig\",{datepickerMode:\"day\",formatDay:\"dd\",formatMonth:\"MMMM\",formatYear:\"yyyy\",formatDayHeader:\"EEE\",formatDayTitle:\"MMMM yyyy\",formatMonthTitle:\"yyyy\",maxDate:null,maxMode:\"year\",minDate:null,minMode:\"day\",ngModelOptions:{},shortcutPropagation:!1,showWeeks:!0,yearColumns:5,yearRows:4}).controller(\"UibDatepickerController\",[\"$scope\",\"$attrs\",\"$parse\",\"$interpolate\",\"$locale\",\"$log\",\"dateFilter\",\"uibDatepickerConfig\",\"$datepickerSuppressError\",\"uibDateParser\",function(a,b,c,d,e,f,g,h,i,j){var k=this,l={$setViewValue:angular.noop},m={},n=[];this.modes=[\"day\",\"month\",\"year\"],angular.forEach([\"formatDay\",\"formatMonth\",\"formatYear\",\"formatDayHeader\",\"formatDayTitle\",\"formatMonthTitle\"],function(c){k[c]=angular.isDefined(b[c])?d(b[c])(a.$parent):h[c]}),angular.forEach([\"showWeeks\",\"yearRows\",\"yearColumns\",\"shortcutPropagation\"],function(c){k[c]=angular.isDefined(b[c])?a.$parent.$eval(b[c]):h[c]}),angular.isDefined(b.startingDay)?k.startingDay=a.$parent.$eval(b.startingDay):angular.isNumber(h.startingDay)?k.startingDay=h.startingDay:k.startingDay=(e.DATETIME_FORMATS.FIRSTDAYOFWEEK+8)%7,angular.forEach([\"minDate\",\"maxDate\"],function(c){b[c]?n.push(a.$parent.$watch(b[c],function(a){k[c]=a?angular.isDate(a)?j.fromTimezone(new Date(a),m.timezone):new Date(g(a,\"medium\")):null,k.refreshView()})):k[c]=h[c]?j.fromTimezone(new Date(h[c]),m.timezone):null}),angular.forEach([\"minMode\",\"maxMode\"],function(c){b[c]?n.push(a.$parent.$watch(b[c],function(d){k[c]=a[c]=angular.isDefined(d)?d:b[c],(\"minMode\"===c&&k.modes.indexOf(a.datepickerMode)<k.modes.indexOf(k[c])||\"maxMode\"===c&&k.modes.indexOf(a.datepickerMode)>k.modes.indexOf(k[c]))&&(a.datepickerMode=k[c])})):k[c]=a[c]=h[c]||null}),a.datepickerMode=a.datepickerMode||h.datepickerMode,a.uniqueId=\"datepicker-\"+a.$id+\"-\"+Math.floor(1e4*Math.random()),angular.isDefined(b.initDate)?(this.activeDate=j.fromTimezone(a.$parent.$eval(b.initDate),m.timezone)||new Date,n.push(a.$parent.$watch(b.initDate,function(a){a&&(l.$isEmpty(l.$modelValue)||l.$invalid)&&(k.activeDate=j.fromTimezone(a,m.timezone),k.refreshView())}))):this.activeDate=new Date,a.disabled=angular.isDefined(b.disabled)||!1,angular.isDefined(b.ngDisabled)&&n.push(a.$parent.$watch(b.ngDisabled,function(b){a.disabled=b,k.refreshView()})),a.isActive=function(b){return 0===k.compare(b.date,k.activeDate)?(a.activeDateId=b.uid,!0):!1},this.init=function(a){l=a,m=a.$options||h.ngModelOptions,l.$modelValue&&(this.activeDate=l.$modelValue),l.$render=function(){k.render()}},this.render=function(){if(l.$viewValue){var a=new Date(l.$viewValue),b=!isNaN(a);b?this.activeDate=j.fromTimezone(a,m.timezone):i||f.error('Datepicker directive: \"ng-model\" value must be a Date object')}this.refreshView()},this.refreshView=function(){if(this.element){a.selectedDt=null,this._refreshView(),a.activeDt&&(a.activeDateId=a.activeDt.uid);var b=l.$viewValue?new Date(l.$viewValue):null;b=j.fromTimezone(b,m.timezone),l.$setValidity(\"dateDisabled\",!b||this.element&&!this.isDisabled(b))}},this.createDateObject=function(b,c){var d=l.$viewValue?new Date(l.$viewValue):null;d=j.fromTimezone(d,m.timezone);var e={date:b,label:g(b,c.replace(/d!/,\"dd\")).replace(/M!/,\"MM\"),selected:d&&0===this.compare(b,d),disabled:this.isDisabled(b),current:0===this.compare(b,new Date),customClass:this.customClass(b)||null};return d&&0===this.compare(b,d)&&(a.selectedDt=e),k.activeDate&&0===this.compare(e.date,k.activeDate)&&(a.activeDt=e),e},this.isDisabled=function(c){return a.disabled||this.minDate&&this.compare(c,this.minDate)<0||this.maxDate&&this.compare(c,this.maxDate)>0||b.dateDisabled&&a.dateDisabled({date:c,mode:a.datepickerMode})},this.customClass=function(b){return a.customClass({date:b,mode:a.datepickerMode})},this.split=function(a,b){for(var c=[];a.length>0;)c.push(a.splice(0,b));return c},a.select=function(b){if(a.datepickerMode===k.minMode){var c=l.$viewValue?j.fromTimezone(new Date(l.$viewValue),m.timezone):new Date(0,0,0,0,0,0,0);c.setFullYear(b.getFullYear(),b.getMonth(),b.getDate()),c=j.toTimezone(c,m.timezone),l.$setViewValue(c),l.$render()}else k.activeDate=b,a.datepickerMode=k.modes[k.modes.indexOf(a.datepickerMode)-1]},a.move=function(a){var b=k.activeDate.getFullYear()+a*(k.step.years||0),c=k.activeDate.getMonth()+a*(k.step.months||0);k.activeDate.setFullYear(b,c,1),k.refreshView()},a.toggleMode=function(b){b=b||1,a.datepickerMode===k.maxMode&&1===b||a.datepickerMode===k.minMode&&-1===b||(a.datepickerMode=k.modes[k.modes.indexOf(a.datepickerMode)+b])},a.keys={13:\"enter\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\"};var o=function(){k.element[0].focus()};a.$on(\"uib:datepicker.focus\",o),a.keydown=function(b){var c=a.keys[b.which];if(c&&!b.shiftKey&&!b.altKey&&!a.disabled)if(b.preventDefault(),k.shortcutPropagation||b.stopPropagation(),\"enter\"===c||\"space\"===c){if(k.isDisabled(k.activeDate))return;a.select(k.activeDate)}else!b.ctrlKey||\"up\"!==c&&\"down\"!==c?(k.handleKeyDown(c,b),k.refreshView()):a.toggleMode(\"up\"===c?1:-1)},a.$on(\"$destroy\",function(){for(;n.length;)n.shift()()})}]).controller(\"UibDaypickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){function d(a,b){return 1!==b||a%4!==0||a%100===0&&a%400!==0?f[b]:29}function e(a){var b=new Date(a);b.setDate(b.getDate()+4-(b.getDay()||7));var c=b.getTime();return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1}var f=[31,28,31,30,31,30,31,31,30,31,30,31];this.step={months:1},this.element=b,this.init=function(b){angular.extend(b,this),a.showWeeks=b.showWeeks,b.refreshView()},this.getDates=function(a,b){for(var c,d=new Array(b),e=new Date(a),f=0;b>f;)c=new Date(e),d[f++]=c,e.setDate(e.getDate()+1);return d},this._refreshView=function(){var b=this.activeDate.getFullYear(),d=this.activeDate.getMonth(),f=new Date(this.activeDate);f.setFullYear(b,d,1);var g=this.startingDay-f.getDay(),h=g>0?7-g:-g,i=new Date(f);h>0&&i.setDate(-h+1);for(var j=this.getDates(i,42),k=0;42>k;k++)j[k]=angular.extend(this.createDateObject(j[k],this.formatDay),{secondary:j[k].getMonth()!==d,uid:a.uniqueId+\"-\"+k});a.labels=new Array(7);for(var l=0;7>l;l++)a.labels[l]={abbr:c(j[l].date,this.formatDayHeader),full:c(j[l].date,\"EEEE\")};if(a.title=c(this.activeDate,this.formatDayTitle),a.rows=this.split(j,7),a.showWeeks){a.weekNumbers=[];for(var m=(11-this.startingDay)%7,n=a.rows.length,o=0;n>o;o++)a.weekNumbers.push(e(a.rows[o][m].date))}},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth(),a.getDate()),d=new Date(b.getFullYear(),b.getMonth(),b.getDate());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getDate();if(\"left\"===a)c-=1;else if(\"up\"===a)c-=7;else if(\"right\"===a)c+=1;else if(\"down\"===a)c+=7;else if(\"pageup\"===a||\"pagedown\"===a){var e=this.activeDate.getMonth()+(\"pageup\"===a?-1:1);this.activeDate.setMonth(e,1),c=Math.min(d(this.activeDate.getFullYear(),this.activeDate.getMonth()),c)}else\"home\"===a?c=1:\"end\"===a&&(c=d(this.activeDate.getFullYear(),this.activeDate.getMonth()));this.activeDate.setDate(c)}}]).controller(\"UibMonthpickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){this.step={years:1},this.element=b,this.init=function(a){angular.extend(a,this),a.refreshView()},this._refreshView=function(){for(var b,d=new Array(12),e=this.activeDate.getFullYear(),f=0;12>f;f++)b=new Date(this.activeDate),b.setFullYear(e,f,1),d[f]=angular.extend(this.createDateObject(b,this.formatMonth),{uid:a.uniqueId+\"-\"+f});a.title=c(this.activeDate,this.formatMonthTitle),a.rows=this.split(d,3)},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth()),d=new Date(b.getFullYear(),b.getMonth());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getMonth();if(\"left\"===a)c-=1;else if(\"up\"===a)c-=3;else if(\"right\"===a)c+=1;else if(\"down\"===a)c+=3;else if(\"pageup\"===a||\"pagedown\"===a){var d=this.activeDate.getFullYear()+(\"pageup\"===a?-1:1);this.activeDate.setFullYear(d)}else\"home\"===a?c=0:\"end\"===a&&(c=11);this.activeDate.setMonth(c)}}]).controller(\"UibYearpickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){function d(a){return parseInt((a-1)/f,10)*f+1}var e,f;this.element=b,this.yearpickerInit=function(){e=this.yearColumns,f=this.yearRows*e,this.step={years:f}},this._refreshView=function(){for(var b,c=new Array(f),g=0,h=d(this.activeDate.getFullYear());f>g;g++)b=new Date(this.activeDate),b.setFullYear(h+g,0,1),c[g]=angular.extend(this.createDateObject(b,this.formatYear),{uid:a.uniqueId+\"-\"+g});a.title=[c[0].label,c[f-1].label].join(\" - \"),a.rows=this.split(c,e),a.columns=e},this.compare=function(a,b){return a.getFullYear()-b.getFullYear()},this.handleKeyDown=function(a,b){var c=this.activeDate.getFullYear();\"left\"===a?c-=1:\"up\"===a?c-=e:\"right\"===a?c+=1:\"down\"===a?c+=e:\"pageup\"===a||\"pagedown\"===a?c+=(\"pageup\"===a?-1:1)*f:\"home\"===a?c=d(this.activeDate.getFullYear()):\"end\"===a&&(c=d(this.activeDate.getFullYear())+f-1),this.activeDate.setFullYear(c)}}]).directive(\"uibDatepicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/datepicker.html\"},scope:{datepickerMode:\"=?\",dateDisabled:\"&\",customClass:\"&\",shortcutPropagation:\"&?\"},require:[\"uibDatepicker\",\"^ngModel\"],controller:\"UibDatepickerController\",controllerAs:\"datepicker\",link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}).directive(\"uibDaypicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/day.html\"},require:[\"^uibDatepicker\",\"uibDaypicker\"],controller:\"UibDaypickerController\",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibMonthpicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/month.html\"},require:[\"^uibDatepicker\",\"uibMonthpicker\"],controller:\"UibMonthpickerController\",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibYearpicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/year.html\"},require:[\"^uibDatepicker\",\"uibYearpicker\"],controller:\"UibYearpickerController\",link:function(a,b,c,d){var e=d[0];angular.extend(e,d[1]),e.yearpickerInit(),e.refreshView()}}}).constant(\"uibDatepickerPopupConfig\",{altInputFormats:[],appendToBody:!1,clearText:\"Clear\",closeOnDateSelection:!0,closeText:\"Done\",currentText:\"Today\",datepickerPopup:\"yyyy-MM-dd\",datepickerPopupTemplateUrl:\"uib/template/datepicker/popup.html\",datepickerTemplateUrl:\"uib/template/datepicker/datepicker.html\",html5Types:{date:\"yyyy-MM-dd\",\"datetime-local\":\"yyyy-MM-ddTHH:mm:ss.sss\",month:\"yyyy-MM\"},onOpenFocus:!0,showButtonBar:!0\n}).controller(\"UibDatepickerPopupController\",[\"$scope\",\"$element\",\"$attrs\",\"$compile\",\"$parse\",\"$document\",\"$rootScope\",\"$uibPosition\",\"dateFilter\",\"uibDateParser\",\"uibDatepickerPopupConfig\",\"$timeout\",\"uibDatepickerConfig\",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(a){return a.replace(/([A-Z])/g,function(a){return\"-\"+a.toLowerCase()})}function o(b){var c=j.parse(b,t,a.date);if(isNaN(c))for(var d=0;d<E.length;d++)if(c=j.parse(b,E[d],a.date),!isNaN(c))return c;return c}function p(a){if(angular.isNumber(a)&&(a=new Date(a)),!a)return null;if(angular.isDate(a)&&!isNaN(a))return a;if(angular.isString(a)){var b=o(a);if(!isNaN(b))return j.toTimezone(b,C.timezone)}return B.$options&&B.$options.allowInvalid?a:void 0}function q(a,b){var d=a||b;return c.ngRequired||d?(angular.isNumber(d)&&(d=new Date(d)),d?angular.isDate(d)&&!isNaN(d)?!0:angular.isString(d)?!isNaN(o(b)):!1:!0):!0}function r(c){if(a.isOpen||!a.disabled){var d=D[0],e=b[0].contains(c.target),f=void 0!==d.contains&&d.contains(c.target);!a.isOpen||e||f||a.$apply(function(){a.isOpen=!1})}}function s(c){27===c.which&&a.isOpen?(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!1}),b[0].focus()):40!==c.which||a.isOpen||(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!0}))}var t,u,v,w,x,y,z,A,B,C,D,E,F={},G=!1,H=[];a.watchData={},this.init=function(h){if(B=h,C=h.$options||m.ngModelOptions,u=angular.isDefined(c.closeOnDateSelection)?a.$parent.$eval(c.closeOnDateSelection):k.closeOnDateSelection,v=angular.isDefined(c.datepickerAppendToBody)?a.$parent.$eval(c.datepickerAppendToBody):k.appendToBody,w=angular.isDefined(c.onOpenFocus)?a.$parent.$eval(c.onOpenFocus):k.onOpenFocus,x=angular.isDefined(c.datepickerPopupTemplateUrl)?c.datepickerPopupTemplateUrl:k.datepickerPopupTemplateUrl,y=angular.isDefined(c.datepickerTemplateUrl)?c.datepickerTemplateUrl:k.datepickerTemplateUrl,E=angular.isDefined(c.altInputFormats)?a.$parent.$eval(c.altInputFormats):k.altInputFormats,a.showButtonBar=angular.isDefined(c.showButtonBar)?a.$parent.$eval(c.showButtonBar):k.showButtonBar,k.html5Types[c.type]?(t=k.html5Types[c.type],G=!0):(t=c.uibDatepickerPopup||k.datepickerPopup,c.$observe(\"uibDatepickerPopup\",function(a,b){var c=a||k.datepickerPopup;if(c!==t&&(t=c,B.$modelValue=null,!t))throw new Error(\"uibDatepickerPopup must have a date format specified.\")})),!t)throw new Error(\"uibDatepickerPopup must have a date format specified.\");if(G&&c.uibDatepickerPopup)throw new Error(\"HTML5 date input types do not support custom formats.\");z=angular.element(\"<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>\"),a.ngModelOptions=angular.copy(C),a.ngModelOptions.timezone=null,z.attr({\"ng-model\":\"date\",\"ng-model-options\":\"ngModelOptions\",\"ng-change\":\"dateSelection(date)\",\"template-url\":x}),A=angular.element(z.children()[0]),A.attr(\"template-url\",y),G&&\"month\"===c.type&&(A.attr(\"datepicker-mode\",'\"month\"'),A.attr(\"min-mode\",\"month\")),a.datepickerOptions&&angular.forEach(a.datepickerOptions,function(a,b){-1===[\"minDate\",\"maxDate\",\"minMode\",\"maxMode\",\"initDate\",\"datepickerMode\"].indexOf(b)?A.attr(n(b),a):A.attr(n(b),\"datepickerOptions.\"+b)}),angular.forEach([\"minMode\",\"maxMode\",\"datepickerMode\",\"shortcutPropagation\"],function(b){if(c[b]){var d=e(c[b]),f={get:function(){return d(a.$parent)}};if(A.attr(n(b),\"watchData.\"+b),\"datepickerMode\"===b){var g=d.assign;f.set=function(b){g(a.$parent,b)}}Object.defineProperty(a.watchData,b,f)}}),angular.forEach([\"minDate\",\"maxDate\",\"initDate\"],function(b){if(c[b]){var d=e(c[b]);H.push(a.$parent.$watch(d,function(c){\"minDate\"===b||\"maxDate\"===b?(null===c?F[b]=null:angular.isDate(c)?F[b]=j.fromTimezone(new Date(c),C.timezone):F[b]=new Date(i(c,\"medium\")),a.watchData[b]=null===c?null:F[b]):a.watchData[b]=j.fromTimezone(new Date(c),C.timezone)})),A.attr(n(b),\"watchData.\"+b)}}),c.dateDisabled&&A.attr(\"date-disabled\",\"dateDisabled({ date: date, mode: mode })\"),angular.forEach([\"formatDay\",\"formatMonth\",\"formatYear\",\"formatDayHeader\",\"formatDayTitle\",\"formatMonthTitle\",\"showWeeks\",\"startingDay\",\"yearRows\",\"yearColumns\"],function(a){angular.isDefined(c[a])&&A.attr(n(a),c[a])}),c.customClass&&A.attr(\"custom-class\",\"customClass({ date: date, mode: mode })\"),G?B.$formatters.push(function(b){return a.date=j.fromTimezone(b,C.timezone),b}):(B.$$parserName=\"date\",B.$validators.date=q,B.$parsers.unshift(p),B.$formatters.push(function(b){return B.$isEmpty(b)?(a.date=b,b):(a.date=j.fromTimezone(b,C.timezone),t=t.replace(/M!/,\"MM\").replace(/d!/,\"dd\"),i(a.date,t))})),B.$viewChangeListeners.push(function(){a.date=o(B.$viewValue)}),b.on(\"keydown\",s),D=d(z)(a),z.remove(),v?f.find(\"body\").append(D):b.after(D),a.$on(\"$destroy\",function(){for(a.isOpen===!0&&(g.$$phase||a.$apply(function(){a.isOpen=!1})),D.remove(),b.off(\"keydown\",s),f.off(\"click\",r);H.length;)H.shift()()})},a.getText=function(b){return a[b+\"Text\"]||k[b+\"Text\"]},a.isDisabled=function(b){return\"today\"===b&&(b=new Date),a.watchData.minDate&&a.compare(b,F.minDate)<0||a.watchData.maxDate&&a.compare(b,F.maxDate)>0},a.compare=function(a,b){return new Date(a.getFullYear(),a.getMonth(),a.getDate())-new Date(b.getFullYear(),b.getMonth(),b.getDate())},a.dateSelection=function(c){angular.isDefined(c)&&(a.date=c);var d=a.date?i(a.date,t):null;b.val(d),B.$setViewValue(d),u&&(a.isOpen=!1,b[0].focus())},a.keydown=function(c){27===c.which&&(c.stopPropagation(),a.isOpen=!1,b[0].focus())},a.select=function(b){if(\"today\"===b){var c=new Date;angular.isDate(a.date)?(b=new Date(a.date),b.setFullYear(c.getFullYear(),c.getMonth(),c.getDate())):b=new Date(c.setHours(0,0,0,0))}a.dateSelection(b)},a.close=function(){a.isOpen=!1,b[0].focus()},a.disabled=angular.isDefined(c.disabled)||!1,c.ngDisabled&&H.push(a.$parent.$watch(e(c.ngDisabled),function(b){a.disabled=b})),a.$watch(\"isOpen\",function(c){c?a.disabled?a.isOpen=!1:(a.position=v?h.offset(b):h.position(b),a.position.top=a.position.top+b.prop(\"offsetHeight\"),l(function(){w&&a.$broadcast(\"uib:datepicker.focus\"),f.on(\"click\",r)},0,!1)):f.off(\"click\",r)})}]).directive(\"uibDatepickerPopup\",function(){return{require:[\"ngModel\",\"uibDatepickerPopup\"],controller:\"UibDatepickerPopupController\",scope:{datepickerOptions:\"=?\",isOpen:\"=?\",currentText:\"@\",clearText:\"@\",closeText:\"@\",dateDisabled:\"&\",customClass:\"&\"},link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibDatepickerPopupWrap\",function(){return{replace:!0,transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/popup.html\"}}}),angular.module(\"ui.bootstrap.debounce\",[]).factory(\"$$debounce\",[\"$timeout\",function(a){return function(b,c){var d;return function(){var e=this,f=Array.prototype.slice.call(arguments);d&&a.cancel(d),d=a(function(){b.apply(e,f)},c)}}}]),angular.module(\"ui.bootstrap.dropdown\",[\"ui.bootstrap.position\"]).constant(\"uibDropdownConfig\",{appendToOpenClass:\"uib-dropdown-open\",openClass:\"open\"}).service(\"uibDropdownService\",[\"$document\",\"$rootScope\",function(a,b){var c=null;this.open=function(b){c||(a.on(\"click\",d),a.on(\"keydown\",e)),c&&c!==b&&(c.isOpen=!1),c=b},this.close=function(b){c===b&&(c=null,a.off(\"click\",d),a.off(\"keydown\",e))};var d=function(a){if(c&&!(a&&\"disabled\"===c.getAutoClose()||a&&3===a.which)){var d=c.getToggleElement();if(!(a&&d&&d[0].contains(a.target))){var e=c.getDropdownElement();a&&\"outsideClick\"===c.getAutoClose()&&e&&e[0].contains(a.target)||(c.isOpen=!1,b.$$phase||c.$apply())}}},e=function(a){27===a.which?(c.focusToggleElement(),d()):c.isKeynavEnabled()&&-1!==[38,40].indexOf(a.which)&&c.isOpen&&(a.preventDefault(),a.stopPropagation(),c.focusDropdownEntry(a.which))}}]).controller(\"UibDropdownController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"uibDropdownConfig\",\"uibDropdownService\",\"$animate\",\"$uibPosition\",\"$document\",\"$compile\",\"$templateRequest\",function(a,b,c,d,e,f,g,h,i,j,k){var l,m,n=this,o=a.$new(),p=e.appendToOpenClass,q=e.openClass,r=angular.noop,s=c.onToggle?d(c.onToggle):angular.noop,t=!1,u=null,v=!1,w=i.find(\"body\");b.addClass(\"dropdown\"),this.init=function(){if(c.isOpen&&(m=d(c.isOpen),r=m.assign,a.$watch(m,function(a){o.isOpen=!!a})),angular.isDefined(c.dropdownAppendTo)){var e=d(c.dropdownAppendTo)(o);e&&(u=angular.element(e))}t=angular.isDefined(c.dropdownAppendToBody),v=angular.isDefined(c.keyboardNav),t&&!u&&(u=w),u&&n.dropdownMenu&&(u.append(n.dropdownMenu),b.on(\"$destroy\",function(){n.dropdownMenu.remove()}))},this.toggle=function(a){return o.isOpen=arguments.length?!!a:!o.isOpen},this.isOpen=function(){return o.isOpen},o.getToggleElement=function(){return n.toggleElement},o.getAutoClose=function(){return c.autoClose||\"always\"},o.getElement=function(){return b},o.isKeynavEnabled=function(){return v},o.focusDropdownEntry=function(a){var c=n.dropdownMenu?angular.element(n.dropdownMenu).find(\"a\"):b.find(\"ul\").eq(0).find(\"a\");switch(a){case 40:angular.isNumber(n.selectedOption)?n.selectedOption=n.selectedOption===c.length-1?n.selectedOption:n.selectedOption+1:n.selectedOption=0;break;case 38:angular.isNumber(n.selectedOption)?n.selectedOption=0===n.selectedOption?0:n.selectedOption-1:n.selectedOption=c.length-1}c[n.selectedOption].focus()},o.getDropdownElement=function(){return n.dropdownMenu},o.focusToggleElement=function(){n.toggleElement&&n.toggleElement[0].focus()},o.$watch(\"isOpen\",function(c,d){if(u&&n.dropdownMenu){var e,i,m=h.positionElements(b,n.dropdownMenu,\"bottom-left\",!0);if(e={top:m.top+\"px\",display:c?\"block\":\"none\"},i=n.dropdownMenu.hasClass(\"dropdown-menu-right\"),i?(e.left=\"auto\",e.right=window.innerWidth-(m.left+b.prop(\"offsetWidth\"))+\"px\"):(e.left=m.left+\"px\",e.right=\"auto\"),!t){var v=h.offset(u);e.top=m.top-v.top+\"px\",i?e.right=window.innerWidth-(m.left-v.left+b.prop(\"offsetWidth\"))+\"px\":e.left=m.left-v.left+\"px\"}n.dropdownMenu.css(e)}var w=u?u:b;if(g[c?\"addClass\":\"removeClass\"](w,u?p:q).then(function(){angular.isDefined(c)&&c!==d&&s(a,{open:!!c})}),c)n.dropdownMenuTemplateUrl&&k(n.dropdownMenuTemplateUrl).then(function(a){l=o.$new(),j(a.trim())(l,function(a){var b=a;n.dropdownMenu.replaceWith(b),n.dropdownMenu=b})}),o.focusToggleElement(),f.open(o);else{if(n.dropdownMenuTemplateUrl){l&&l.$destroy();var x=angular.element('<ul class=\"dropdown-menu\"></ul>');n.dropdownMenu.replaceWith(x),n.dropdownMenu=x}f.close(o),n.selectedOption=null}angular.isFunction(r)&&r(a,c)}),a.$on(\"$locationChangeSuccess\",function(){\"disabled\"!==o.getAutoClose()&&(o.isOpen=!1)})}]).directive(\"uibDropdown\",function(){return{controller:\"UibDropdownController\",link:function(a,b,c,d){d.init()}}}).directive(\"uibDropdownMenu\",function(){return{restrict:\"A\",require:\"?^uibDropdown\",link:function(a,b,c,d){if(d&&!angular.isDefined(c.dropdownNested)){b.addClass(\"dropdown-menu\");var e=c.templateUrl;e&&(d.dropdownMenuTemplateUrl=e),d.dropdownMenu||(d.dropdownMenu=b)}}}}).directive(\"uibDropdownToggle\",function(){return{require:\"?^uibDropdown\",link:function(a,b,c,d){if(d){b.addClass(\"dropdown-toggle\"),d.toggleElement=b;var e=function(e){e.preventDefault(),b.hasClass(\"disabled\")||c.disabled||a.$apply(function(){d.toggle()})};b.bind(\"click\",e),b.attr({\"aria-haspopup\":!0,\"aria-expanded\":!1}),a.$watch(d.isOpen,function(a){b.attr(\"aria-expanded\",!!a)}),a.$on(\"$destroy\",function(){b.unbind(\"click\",e)})}}}}),angular.module(\"ui.bootstrap.stackedMap\",[]).factory(\"$$stackedMap\",function(){return{createNew:function(){var a=[];return{add:function(b,c){a.push({key:b,value:c})},get:function(b){for(var c=0;c<a.length;c++)if(b===a[c].key)return a[c]},keys:function(){for(var b=[],c=0;c<a.length;c++)b.push(a[c].key);return b},top:function(){return a[a.length-1]},remove:function(b){for(var c=-1,d=0;d<a.length;d++)if(b===a[d].key){c=d;break}return a.splice(c,1)[0]},removeTop:function(){return a.splice(a.length-1,1)[0]},length:function(){return a.length}}}}}),angular.module(\"ui.bootstrap.modal\",[\"ui.bootstrap.stackedMap\"]).factory(\"$$multiMap\",function(){return{createNew:function(){var a={};return{entries:function(){return Object.keys(a).map(function(b){return{key:b,value:a[b]}})},get:function(b){return a[b]},hasKey:function(b){return!!a[b]},keys:function(){return Object.keys(a)},put:function(b,c){a[b]||(a[b]=[]),a[b].push(c)},remove:function(b,c){var d=a[b];if(d){var e=d.indexOf(c);-1!==e&&d.splice(e,1),d.length||delete a[b]}}}}}}).provider(\"$uibResolve\",function(){var a=this;this.resolver=null,this.setResolver=function(a){this.resolver=a},this.$get=[\"$injector\",\"$q\",function(b,c){var d=a.resolver?b.get(a.resolver):null;return{resolve:function(a,e,f,g){if(d)return d.resolve(a,e,f,g);var h=[];return angular.forEach(a,function(a){angular.isFunction(a)||angular.isArray(a)?h.push(c.resolve(b.invoke(a))):angular.isString(a)?h.push(c.resolve(b.get(a))):h.push(c.resolve(a))}),c.all(h).then(function(b){var c={},d=0;return angular.forEach(a,function(a,e){c[e]=b[d++]}),c})}}}]}).directive(\"uibModalBackdrop\",[\"$animateCss\",\"$injector\",\"$uibModalStack\",function(a,b,c){function d(b,d,e){e.modalInClass&&(a(d,{addClass:e.modalInClass}).start(),b.$on(c.NOW_CLOSING_EVENT,function(c,f){var g=f();b.modalOptions.animation?a(d,{removeClass:e.modalInClass}).start().then(g):g()}))}return{replace:!0,templateUrl:\"uib/template/modal/backdrop.html\",compile:function(a,b){return a.addClass(b.backdropClass),d}}}]).directive(\"uibModalWindow\",[\"$uibModalStack\",\"$q\",\"$animate\",\"$animateCss\",\"$document\",function(a,b,c,d,e){return{scope:{index:\"@\"},replace:!0,transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/modal/window.html\"},link:function(f,g,h){g.addClass(h.windowClass||\"\"),g.addClass(h.windowTopClass||\"\"),f.size=h.size,f.close=function(b){var c=a.getTop();c&&c.value.backdrop&&\"static\"!==c.value.backdrop&&b.target===b.currentTarget&&(b.preventDefault(),b.stopPropagation(),a.dismiss(c.key,\"backdrop click\"))},g.on(\"click\",f.close),f.$isRendered=!0;var i=b.defer();h.$observe(\"modalRender\",function(a){\"true\"===a&&i.resolve()}),i.promise.then(function(){var i=null;h.modalInClass&&(i=d(g,{addClass:h.modalInClass}).start(),f.$on(a.NOW_CLOSING_EVENT,function(a,b){var e=b();d?d(g,{removeClass:h.modalInClass}).start().then(e):c.removeClass(g,h.modalInClass).then(e)})),b.when(i).then(function(){if(!e[0].activeElement||!g[0].contains(e[0].activeElement)){var a=g[0].querySelector(\"[autofocus]\");a?a.focus():g[0].focus()}});var j=a.getTop();j&&a.modalRendered(j.key)})}}}]).directive(\"uibModalAnimationClass\",function(){return{compile:function(a,b){b.modalAnimation&&a.addClass(b.uibModalAnimationClass)}}}).directive(\"uibModalTransclude\",function(){return{link:function(a,b,c,d,e){e(a.$parent,function(a){b.empty(),b.append(a)})}}}).factory(\"$uibModalStack\",[\"$animate\",\"$animateCss\",\"$document\",\"$compile\",\"$rootScope\",\"$q\",\"$$multiMap\",\"$$stackedMap\",function(a,b,c,d,e,f,g,h){function i(){for(var a=-1,b=t.keys(),c=0;c<b.length;c++)t.get(b[c]).value.backdrop&&(a=c);return a}function j(a,b){var c=t.get(a).value,d=c.appendTo;t.remove(a),m(c.modalDomEl,c.modalScope,function(){var b=c.openedClass||s;u.remove(b,a),d.toggleClass(b,u.hasKey(b)),k(!0)},c.closedDeferred),l(),b&&b.focus?b.focus():d.focus&&d.focus()}function k(a){var b;t.length()>0&&(b=t.top().value,b.modalDomEl.toggleClass(b.windowTopClass||\"\",a))}function l(){if(p&&-1===i()){var a=q;m(p,q,function(){a=null}),p=void 0,q=void 0}}function m(a,c,d,e){function g(){g.done||(g.done=!0,b(a,{event:\"leave\"}).start().then(function(){a.remove(),e&&e.resolve()}),c.$destroy(),d&&d())}var h,i=null,j=function(){return h||(h=f.defer(),i=h.promise),function(){h.resolve()}};return c.$broadcast(v.NOW_CLOSING_EVENT,j),f.when(i).then(g)}function n(a){if(a.isDefaultPrevented())return a;var b=t.top();if(b)switch(a.which){case 27:b.value.keyboard&&(a.preventDefault(),e.$apply(function(){v.dismiss(b.key,\"escape key press\")}));break;case 9:v.loadFocusElementList(b);var c=!1;a.shiftKey?v.isFocusInFirstItem(a)&&(c=v.focusLastFocusableElement()):v.isFocusInLastItem(a)&&(c=v.focusFirstFocusableElement()),c&&(a.preventDefault(),a.stopPropagation())}}function o(a,b,c){return!a.value.modalScope.$broadcast(\"modal.closing\",b,c).defaultPrevented}var p,q,r,s=\"modal-open\",t=h.createNew(),u=g.createNew(),v={NOW_CLOSING_EVENT:\"modal.stack.now-closing\"},w=0,x=\"a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]\";return e.$watch(i,function(a){q&&(q.index=a)}),c.on(\"keydown\",n),e.$on(\"$destroy\",function(){c.off(\"keydown\",n)}),v.open=function(b,f){var g=c[0].activeElement,h=f.openedClass||s;k(!1),t.add(b,{deferred:f.deferred,renderDeferred:f.renderDeferred,closedDeferred:f.closedDeferred,modalScope:f.scope,backdrop:f.backdrop,keyboard:f.keyboard,openedClass:f.openedClass,windowTopClass:f.windowTopClass,animation:f.animation,appendTo:f.appendTo}),u.put(h,b);var j=f.appendTo,l=i();if(!j.length)throw new Error(\"appendTo element not found. Make sure that the element passed is in DOM.\");l>=0&&!p&&(q=e.$new(!0),q.modalOptions=f,q.index=l,p=angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>'),p.attr(\"backdrop-class\",f.backdropClass),f.animation&&p.attr(\"modal-animation\",\"true\"),d(p)(q),a.enter(p,j));var m=angular.element('<div uib-modal-window=\"modal-window\"></div>');m.attr({\"template-url\":f.windowTemplateUrl,\"window-class\":f.windowClass,\"window-top-class\":f.windowTopClass,size:f.size,index:t.length()-1,animate:\"animate\"}).html(f.content),f.animation&&m.attr(\"modal-animation\",\"true\"),a.enter(d(m)(f.scope),j).then(function(){a.addClass(j,h)}),t.top().value.modalDomEl=m,t.top().value.modalOpener=g,v.clearFocusListCache()},v.close=function(a,b){var c=t.get(a);return c&&o(c,b,!0)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.resolve(b),j(a,c.value.modalOpener),!0):!c},v.dismiss=function(a,b){var c=t.get(a);return c&&o(c,b,!1)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.reject(b),j(a,c.value.modalOpener),!0):!c},v.dismissAll=function(a){for(var b=this.getTop();b&&this.dismiss(b.key,a);)b=this.getTop()},v.getTop=function(){return t.top()},v.modalRendered=function(a){var b=t.get(a);b&&b.value.renderDeferred.resolve()},v.focusFirstFocusableElement=function(){return r.length>0?(r[0].focus(),!0):!1},v.focusLastFocusableElement=function(){return r.length>0?(r[r.length-1].focus(),!0):!1},v.isFocusInFirstItem=function(a){return r.length>0?(a.target||a.srcElement)===r[0]:!1},v.isFocusInLastItem=function(a){return r.length>0?(a.target||a.srcElement)===r[r.length-1]:!1},v.clearFocusListCache=function(){r=[],w=0},v.loadFocusElementList=function(a){if((void 0===r||!r.length)&&a){var b=a.value.modalDomEl;b&&b.length&&(r=b[0].querySelectorAll(x))}},v}]).provider(\"$uibModal\",function(){var a={options:{animation:!0,backdrop:!0,keyboard:!0},$get:[\"$rootScope\",\"$q\",\"$document\",\"$templateRequest\",\"$controller\",\"$uibResolve\",\"$uibModalStack\",function(b,c,d,e,f,g,h){function i(a){return a.template?c.when(a.template):e(angular.isFunction(a.templateUrl)?a.templateUrl():a.templateUrl)}var j={},k=null;return j.getPromiseChain=function(){return k},j.open=function(e){function j(){return r}var l=c.defer(),m=c.defer(),n=c.defer(),o=c.defer(),p={result:l.promise,opened:m.promise,closed:n.promise,rendered:o.promise,close:function(a){return h.close(p,a)},dismiss:function(a){return h.dismiss(p,a)}};if(e=angular.extend({},a.options,e),e.resolve=e.resolve||{},e.appendTo=e.appendTo||d.find(\"body\").eq(0),!e.template&&!e.templateUrl)throw new Error(\"One of template or templateUrl options is required.\");var q,r=c.all([i(e),g.resolve(e.resolve,{},null,null)]);return q=k=c.all([k]).then(j,j).then(function(a){var c=e.scope||b,d=c.$new();d.$close=p.close,d.$dismiss=p.dismiss,d.$on(\"$destroy\",function(){d.$$uibDestructionScheduled||d.$dismiss(\"$uibUnscheduledDestruction\")});var g,i={};e.controller&&(i.$scope=d,i.$uibModalInstance=p,angular.forEach(a[1],function(a,b){i[b]=a}),g=f(e.controller,i),e.controllerAs&&(e.bindToController&&(g.$close=d.$close,g.$dismiss=d.$dismiss,angular.extend(g,c)),d[e.controllerAs]=g)),h.open(p,{scope:d,deferred:l,renderDeferred:o,closedDeferred:n,content:a[0],animation:e.animation,backdrop:e.backdrop,keyboard:e.keyboard,backdropClass:e.backdropClass,windowTopClass:e.windowTopClass,windowClass:e.windowClass,windowTemplateUrl:e.windowTemplateUrl,size:e.size,openedClass:e.openedClass,appendTo:e.appendTo}),m.resolve(!0)},function(a){m.reject(a),l.reject(a)})[\"finally\"](function(){k===q&&(k=null)}),p},j}]};return a}),angular.module(\"ui.bootstrap.paging\",[]).factory(\"uibPaging\",[\"$parse\",function(a){return{create:function(b,c,d){b.setNumPages=d.numPages?a(d.numPages).assign:angular.noop,b.ngModelCtrl={$setViewValue:angular.noop},b._watchers=[],b.init=function(e,f){b.ngModelCtrl=e,b.config=f,e.$render=function(){b.render()},d.itemsPerPage?b._watchers.push(c.$parent.$watch(a(d.itemsPerPage),function(a){b.itemsPerPage=parseInt(a,10),c.totalPages=b.calculateTotalPages(),b.updatePage()})):b.itemsPerPage=f.itemsPerPage,c.$watch(\"totalItems\",function(a,d){(angular.isDefined(a)||a!==d)&&(c.totalPages=b.calculateTotalPages(),b.updatePage())})},b.calculateTotalPages=function(){var a=b.itemsPerPage<1?1:Math.ceil(c.totalItems/b.itemsPerPage);return Math.max(a||0,1)},b.render=function(){c.page=parseInt(b.ngModelCtrl.$viewValue,10)||1},c.selectPage=function(a,d){d&&d.preventDefault();var e=!c.ngDisabled||!d;e&&c.page!==a&&a>0&&a<=c.totalPages&&(d&&d.target&&d.target.blur(),b.ngModelCtrl.$setViewValue(a),b.ngModelCtrl.$render())},c.getText=function(a){return c[a+\"Text\"]||b.config[a+\"Text\"]},c.noPrevious=function(){return 1===c.page},c.noNext=function(){return c.page===c.totalPages},b.updatePage=function(){b.setNumPages(c.$parent,c.totalPages),c.page>c.totalPages?c.selectPage(c.totalPages):b.ngModelCtrl.$render()},c.$on(\"$destroy\",function(){for(;b._watchers.length;)b._watchers.shift()()})}}}]),angular.module(\"ui.bootstrap.pager\",[\"ui.bootstrap.paging\"]).controller(\"UibPagerController\",[\"$scope\",\"$attrs\",\"uibPaging\",\"uibPagerConfig\",function(a,b,c,d){a.align=angular.isDefined(b.align)?a.$parent.$eval(b.align):d.align,c.create(this,a,b)}]).constant(\"uibPagerConfig\",{itemsPerPage:10,previousText:\" Previous\",nextText:\"Next \",align:!0}).directive(\"uibPager\",[\"uibPagerConfig\",function(a){return{scope:{totalItems:\"=\",previousText:\"@\",nextText:\"@\",ngDisabled:\"=\"},require:[\"uibPager\",\"?ngModel\"],controller:\"UibPagerController\",controllerAs:\"pager\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/pager/pager.html\"},replace:!0,link:function(b,c,d,e){var f=e[0],g=e[1];g&&f.init(g,a)}}}]),angular.module(\"ui.bootstrap.pagination\",[\"ui.bootstrap.paging\"]).controller(\"UibPaginationController\",[\"$scope\",\"$attrs\",\"$parse\",\"uibPaging\",\"uibPaginationConfig\",function(a,b,c,d,e){function f(a,b,c){return{number:a,text:b,active:c}}function g(a,b){var c=[],d=1,e=b,g=angular.isDefined(i)&&b>i;g&&(j?(d=Math.max(a-Math.floor(i/2),1),e=d+i-1,e>b&&(e=b,d=e-i+1)):(d=(Math.ceil(a/i)-1)*i+1,e=Math.min(d+i-1,b)));for(var h=d;e>=h;h++){var m=f(h,h,h===a);c.push(m)}if(g&&i>0&&(!j||k||l)){if(d>1){if(!l||d>3){var n=f(d-1,\"...\",!1);c.unshift(n)}if(l){if(3===d){var o=f(2,\"2\",!1);c.unshift(o)}var p=f(1,\"1\",!1);c.unshift(p)}}if(b>e){if(!l||b-2>e){var q=f(e+1,\"...\",!1);c.push(q)}if(l){if(e===b-2){var r=f(b-1,b-1,!1);c.push(r)}var s=f(b,b,!1);c.push(s)}}}return c}var h=this,i=angular.isDefined(b.maxSize)?a.$parent.$eval(b.maxSize):e.maxSize,j=angular.isDefined(b.rotate)?a.$parent.$eval(b.rotate):e.rotate,k=angular.isDefined(b.forceEllipses)?a.$parent.$eval(b.forceEllipses):e.forceEllipses,l=angular.isDefined(b.boundaryLinkNumbers)?a.$parent.$eval(b.boundaryLinkNumbers):e.boundaryLinkNumbers;a.boundaryLinks=angular.isDefined(b.boundaryLinks)?a.$parent.$eval(b.boundaryLinks):e.boundaryLinks,a.directionLinks=angular.isDefined(b.directionLinks)?a.$parent.$eval(b.directionLinks):e.directionLinks,d.create(this,a,b),b.maxSize&&h._watchers.push(a.$parent.$watch(c(b.maxSize),function(a){i=parseInt(a,10),h.render()}));var m=this.render;this.render=function(){m(),a.page>0&&a.page<=a.totalPages&&(a.pages=g(a.page,a.totalPages))}}]).constant(\"uibPaginationConfig\",{itemsPerPage:10,boundaryLinks:!1,boundaryLinkNumbers:!1,directionLinks:!0,firstText:\"First\",previousText:\"Previous\",nextText:\"Next\",lastText:\"Last\",rotate:!0,forceEllipses:!1}).directive(\"uibPagination\",[\"$parse\",\"uibPaginationConfig\",function(a,b){return{scope:{totalItems:\"=\",firstText:\"@\",previousText:\"@\",nextText:\"@\",lastText:\"@\",ngDisabled:\"=\"},require:[\"uibPagination\",\"?ngModel\"],controller:\"UibPaginationController\",controllerAs:\"pagination\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/pagination/pagination.html\"},replace:!0,link:function(a,c,d,e){var f=e[0],g=e[1];g&&f.init(g,b)}}}]),angular.module(\"ui.bootstrap.tooltip\",[\"ui.bootstrap.position\",\"ui.bootstrap.stackedMap\"]).provider(\"$uibTooltip\",function(){function a(a){var b=/[A-Z]/g,c=\"-\";return a.replace(b,function(a,b){return(b?c:\"\")+a.toLowerCase()})}var b={placement:\"top\",placementClassPrefix:\"\",animation:!0,popupDelay:0,popupCloseDelay:0,useContentExp:!1},c={mouseenter:\"mouseleave\",click:\"click\",outsideClick:\"outsideClick\",focus:\"blur\",none:\"\"},d={};this.options=function(a){angular.extend(d,a)},this.setTriggers=function(a){angular.extend(c,a)},this.$get=[\"$window\",\"$compile\",\"$timeout\",\"$document\",\"$uibPosition\",\"$interpolate\",\"$rootScope\",\"$parse\",\"$$stackedMap\",function(e,f,g,h,i,j,k,l,m){function n(a){if(27===a.which){var b=o.top();b&&(b.value.close(),o.removeTop(),b=null)}}var o=m.createNew();return h.on(\"keypress\",n),k.$on(\"$destroy\",function(){h.off(\"keypress\",n)}),function(e,k,m,n){function p(a){var b=(a||n.trigger||m).split(\" \"),d=b.map(function(a){return c[a]||a});return{show:b,hide:d}}n=angular.extend({},b,d,n);var q=a(e),r=j.startSymbol(),s=j.endSymbol(),t=\"<div \"+q+'-popup title=\"'+r+\"title\"+s+'\" '+(n.useContentExp?'content-exp=\"contentExp()\" ':'content=\"'+r+\"content\"+s+'\" ')+'placement=\"'+r+\"placement\"+s+'\" popup-class=\"'+r+\"popupClass\"+s+'\" animation=\"animation\" is-open=\"isOpen\"origin-scope=\"origScope\" style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"></div>';return{compile:function(a,b){var c=f(t);return function(a,b,d,f){function j(){M.isOpen?q():m()}function m(){(!L||a.$eval(d[k+\"Enable\"]))&&(u(),x(),M.popupDelay?G||(G=g(r,M.popupDelay,!1)):r())}function q(){s(),M.popupCloseDelay?H||(H=g(t,M.popupCloseDelay,!1)):t()}function r(){return s(),u(),M.content?(v(),void M.$evalAsync(function(){M.isOpen=!0,y(!0),R()})):angular.noop}function s(){G&&(g.cancel(G),G=null),I&&(g.cancel(I),I=null)}function t(){M&&M.$evalAsync(function(){M&&(M.isOpen=!1,y(!1),M.animation?F||(F=g(w,150,!1)):w())})}function u(){H&&(g.cancel(H),H=null),F&&(g.cancel(F),F=null)}function v(){D||(E=M.$new(),D=c(E,function(a){J?h.find(\"body\").append(a):b.after(a)}),z())}function w(){s(),u(),A(),D&&(D.remove(),D=null),E&&(E.$destroy(),E=null)}function x(){M.title=d[k+\"Title\"],P?M.content=P(a):M.content=d[e],M.popupClass=d[k+\"Class\"],M.placement=angular.isDefined(d[k+\"Placement\"])?d[k+\"Placement\"]:n.placement;var b=parseInt(d[k+\"PopupDelay\"],10),c=parseInt(d[k+\"PopupCloseDelay\"],10);M.popupDelay=isNaN(b)?n.popupDelay:b,M.popupCloseDelay=isNaN(c)?n.popupCloseDelay:c}function y(b){O&&angular.isFunction(O.assign)&&O.assign(a,b)}function z(){Q.length=0,P?(Q.push(a.$watch(P,function(a){M.content=a,!a&&M.isOpen&&t()})),Q.push(E.$watch(function(){N||(N=!0,E.$$postDigest(function(){N=!1,M&&M.isOpen&&R()}))}))):Q.push(d.$observe(e,function(a){M.content=a,!a&&M.isOpen?t():R()})),Q.push(d.$observe(k+\"Title\",function(a){M.title=a,M.isOpen&&R()})),Q.push(d.$observe(k+\"Placement\",function(a){M.placement=a?a:n.placement,M.isOpen&&R()}))}function A(){Q.length&&(angular.forEach(Q,function(a){a()}),Q.length=0)}function B(a){M&&M.isOpen&&D&&(b[0].contains(a.target)||D[0].contains(a.target)||q())}function C(){var a=d[k+\"Trigger\"];S(),K=p(a),\"none\"!==K.show&&K.show.forEach(function(a,c){\"outsideClick\"===a?(b.on(\"click\",j),h.on(\"click\",B)):a===K.hide[c]?b.on(a,j):a&&(b.on(a,m),b.on(K.hide[c],q)),b.on(\"keypress\",function(a){27===a.which&&q()})})}var D,E,F,G,H,I,J=angular.isDefined(n.appendToBody)?n.appendToBody:!1,K=p(void 0),L=angular.isDefined(d[k+\"Enable\"]),M=a.$new(!0),N=!1,O=angular.isDefined(d[k+\"IsOpen\"])?l(d[k+\"IsOpen\"]):!1,P=n.useContentExp?l(d[e]):!1,Q=[],R=function(){D&&D.html()&&(I||(I=g(function(){D.css({top:0,left:0});var a=i.positionElements(b,D,M.placement,J);D.css({top:a.top+\"px\",left:a.left+\"px\",visibility:\"visible\"}),n.placementClassPrefix&&D.removeClass(\"top bottom left right\"),D.removeClass(n.placementClassPrefix+\"top \"+n.placementClassPrefix+\"top-left \"+n.placementClassPrefix+\"top-right \"+n.placementClassPrefix+\"bottom \"+n.placementClassPrefix+\"bottom-left \"+n.placementClassPrefix+\"bottom-right \"+n.placementClassPrefix+\"left \"+n.placementClassPrefix+\"left-top \"+n.placementClassPrefix+\"left-bottom \"+n.placementClassPrefix+\"right \"+n.placementClassPrefix+\"right-top \"+n.placementClassPrefix+\"right-bottom\");var c=a.placement.split(\"-\");D.addClass(c[0]+\" \"+n.placementClassPrefix+a.placement),i.positionArrow(D,a.placement),I=null},0,!1)))};M.origScope=a,M.isOpen=!1,o.add(M,{close:t}),M.contentExp=function(){return M.content},d.$observe(\"disabled\",function(a){a&&s(),a&&M.isOpen&&t()}),O&&a.$watch(O,function(a){M&&!a===M.isOpen&&j()});var S=function(){K.show.forEach(function(a){\"outsideClick\"===a?b.off(\"click\",j):(b.off(a,m),b.off(a,j))}),K.hide.forEach(function(a){\"outsideClick\"===a?h.off(\"click\",B):b.off(a,q)})};C();var T=a.$eval(d[k+\"Animation\"]);M.animation=angular.isDefined(T)?!!T:n.animation;var U,V=k+\"AppendToBody\";U=V in d&&void 0===d[V]?!0:a.$eval(d[V]),J=angular.isDefined(U)?U:J,J&&a.$on(\"$locationChangeSuccess\",function(){M.isOpen&&t()}),a.$on(\"$destroy\",function(){S(),w(),o.remove(M),M=null})}}}}}]}).directive(\"uibTooltipTemplateTransclude\",[\"$animate\",\"$sce\",\"$compile\",\"$templateRequest\",function(a,b,c,d){return{link:function(e,f,g){var h,i,j,k=e.$eval(g.tooltipTemplateTranscludeScope),l=0,m=function(){i&&(i.remove(),i=null),h&&(h.$destroy(),h=null),j&&(a.leave(j).then(function(){i=null}),i=j,j=null)};e.$watch(b.parseAsResourceUrl(g.uibTooltipTemplateTransclude),function(b){var g=++l;b?(d(b,!0).then(function(d){if(g===l){var e=k.$new(),i=d,n=c(i)(e,function(b){m(),a.enter(b,f)});h=e,j=n,h.$emit(\"$includeContentLoaded\",b)}},function(){g===l&&(m(),e.$emit(\"$includeContentError\",b))}),e.$emit(\"$includeContentRequested\",b)):m()}),e.$on(\"$destroy\",m)}}}]).directive(\"uibTooltipClasses\",[\"$uibPosition\",function(a){return{restrict:\"A\",link:function(b,c,d){if(b.placement){var e=a.parsePlacement(b.placement);c.addClass(e[0])}else c.addClass(\"top\");b.popupClass&&c.addClass(b.popupClass),b.animation()&&c.addClass(d.tooltipAnimationClass)}}}]).directive(\"uibTooltipPopup\",function(){return{replace:!0,scope:{content:\"@\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-popup.html\"}}).directive(\"uibTooltip\",[\"$uibTooltip\",function(a){return a(\"uibTooltip\",\"tooltip\",\"mouseenter\")}]).directive(\"uibTooltipTemplatePopup\",function(){return{replace:!0,scope:{contentExp:\"&\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\",originScope:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-template-popup.html\"}}).directive(\"uibTooltipTemplate\",[\"$uibTooltip\",function(a){return a(\"uibTooltipTemplate\",\"tooltip\",\"mouseenter\",{useContentExp:!0})}]).directive(\"uibTooltipHtmlPopup\",function(){return{replace:!0,scope:{contentExp:\"&\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-html-popup.html\"}}).directive(\"uibTooltipHtml\",[\"$uibTooltip\",function(a){return a(\"uibTooltipHtml\",\"tooltip\",\"mouseenter\",{useContentExp:!0})}]),angular.module(\"ui.bootstrap.popover\",[\"ui.bootstrap.tooltip\"]).directive(\"uibPopoverTemplatePopup\",function(){return{replace:!0,scope:{title:\"@\",contentExp:\"&\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\",originScope:\"&\"},templateUrl:\"uib/template/popover/popover-template.html\"}}).directive(\"uibPopoverTemplate\",[\"$uibTooltip\",function(a){\nreturn a(\"uibPopoverTemplate\",\"popover\",\"click\",{useContentExp:!0})}]).directive(\"uibPopoverHtmlPopup\",function(){return{replace:!0,scope:{contentExp:\"&\",title:\"@\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/popover/popover-html.html\"}}).directive(\"uibPopoverHtml\",[\"$uibTooltip\",function(a){return a(\"uibPopoverHtml\",\"popover\",\"click\",{useContentExp:!0})}]).directive(\"uibPopoverPopup\",function(){return{replace:!0,scope:{title:\"@\",content:\"@\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/popover/popover.html\"}}).directive(\"uibPopover\",[\"$uibTooltip\",function(a){return a(\"uibPopover\",\"popover\",\"click\")}]),angular.module(\"ui.bootstrap.progressbar\",[]).constant(\"uibProgressConfig\",{animate:!0,max:100}).controller(\"UibProgressController\",[\"$scope\",\"$attrs\",\"uibProgressConfig\",function(a,b,c){var d=this,e=angular.isDefined(b.animate)?a.$parent.$eval(b.animate):c.animate;this.bars=[],a.max=angular.isDefined(a.max)?a.max:c.max,this.addBar=function(b,c,f){e||c.css({transition:\"none\"}),this.bars.push(b),b.max=a.max,b.title=f&&angular.isDefined(f.title)?f.title:\"progressbar\",b.$watch(\"value\",function(a){b.recalculatePercentage()}),b.recalculatePercentage=function(){var a=d.bars.reduce(function(a,b){return b.percent=+(100*b.value/b.max).toFixed(2),a+b.percent},0);a>100&&(b.percent-=a-100)},b.$on(\"$destroy\",function(){c=null,d.removeBar(b)})},this.removeBar=function(a){this.bars.splice(this.bars.indexOf(a),1),this.bars.forEach(function(a){a.recalculatePercentage()})},a.$watch(\"max\",function(b){d.bars.forEach(function(b){b.max=a.max,b.recalculatePercentage()})})}]).directive(\"uibProgress\",function(){return{replace:!0,transclude:!0,controller:\"UibProgressController\",require:\"uibProgress\",scope:{max:\"=?\"},templateUrl:\"uib/template/progressbar/progress.html\"}}).directive(\"uibBar\",function(){return{replace:!0,transclude:!0,require:\"^uibProgress\",scope:{value:\"=\",type:\"@\"},templateUrl:\"uib/template/progressbar/bar.html\",link:function(a,b,c,d){d.addBar(a,b,c)}}}).directive(\"uibProgressbar\",function(){return{replace:!0,transclude:!0,controller:\"UibProgressController\",scope:{value:\"=\",max:\"=?\",type:\"@\"},templateUrl:\"uib/template/progressbar/progressbar.html\",link:function(a,b,c,d){d.addBar(a,angular.element(b.children()[0]),{title:c.title})}}}),angular.module(\"ui.bootstrap.rating\",[]).constant(\"uibRatingConfig\",{max:5,stateOn:null,stateOff:null,titles:[\"one\",\"two\",\"three\",\"four\",\"five\"]}).controller(\"UibRatingController\",[\"$scope\",\"$attrs\",\"uibRatingConfig\",function(a,b,c){var d={$setViewValue:angular.noop};this.init=function(e){d=e,d.$render=this.render,d.$formatters.push(function(a){return angular.isNumber(a)&&a<<0!==a&&(a=Math.round(a)),a}),this.stateOn=angular.isDefined(b.stateOn)?a.$parent.$eval(b.stateOn):c.stateOn,this.stateOff=angular.isDefined(b.stateOff)?a.$parent.$eval(b.stateOff):c.stateOff;var f=angular.isDefined(b.titles)?a.$parent.$eval(b.titles):c.titles;this.titles=angular.isArray(f)&&f.length>0?f:c.titles;var g=angular.isDefined(b.ratingStates)?a.$parent.$eval(b.ratingStates):new Array(angular.isDefined(b.max)?a.$parent.$eval(b.max):c.max);a.range=this.buildTemplateObjects(g)},this.buildTemplateObjects=function(a){for(var b=0,c=a.length;c>b;b++)a[b]=angular.extend({index:b},{stateOn:this.stateOn,stateOff:this.stateOff,title:this.getTitle(b)},a[b]);return a},this.getTitle=function(a){return a>=this.titles.length?a+1:this.titles[a]},a.rate=function(b){!a.readonly&&b>=0&&b<=a.range.length&&(d.$setViewValue(d.$viewValue===b?0:b),d.$render())},a.enter=function(b){a.readonly||(a.value=b),a.onHover({value:b})},a.reset=function(){a.value=d.$viewValue,a.onLeave()},a.onKeydown=function(b){/(37|38|39|40)/.test(b.which)&&(b.preventDefault(),b.stopPropagation(),a.rate(a.value+(38===b.which||39===b.which?1:-1)))},this.render=function(){a.value=d.$viewValue}}]).directive(\"uibRating\",function(){return{require:[\"uibRating\",\"ngModel\"],scope:{readonly:\"=?\",onHover:\"&\",onLeave:\"&\"},controller:\"UibRatingController\",templateUrl:\"uib/template/rating/rating.html\",replace:!0,link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}),angular.module(\"ui.bootstrap.tabs\",[]).controller(\"UibTabsetController\",[\"$scope\",function(a){var b=this,c=b.tabs=a.tabs=[];b.select=function(a){angular.forEach(c,function(b){b.active&&b!==a&&(b.active=!1,b.onDeselect(),a.selectCalled=!1)}),a.active=!0,a.selectCalled||(a.onSelect(),a.selectCalled=!0)},b.addTab=function(a){c.push(a),1===c.length&&a.active!==!1?a.active=!0:a.active?b.select(a):a.active=!1},b.removeTab=function(a){var e=c.indexOf(a);if(a.active&&c.length>1&&!d){var f=e===c.length-1?e-1:e+1;b.select(c[f])}c.splice(e,1)};var d;a.$on(\"$destroy\",function(){d=!0})}]).directive(\"uibTabset\",function(){return{transclude:!0,replace:!0,scope:{type:\"@\"},controller:\"UibTabsetController\",templateUrl:\"uib/template/tabs/tabset.html\",link:function(a,b,c){a.vertical=angular.isDefined(c.vertical)?a.$parent.$eval(c.vertical):!1,a.justified=angular.isDefined(c.justified)?a.$parent.$eval(c.justified):!1}}}).directive(\"uibTab\",[\"$parse\",function(a){return{require:\"^uibTabset\",replace:!0,templateUrl:\"uib/template/tabs/tab.html\",transclude:!0,scope:{active:\"=?\",heading:\"@\",onSelect:\"&select\",onDeselect:\"&deselect\"},controller:function(){},controllerAs:\"tab\",link:function(b,c,d,e,f){b.$watch(\"active\",function(a){a&&e.select(b)}),b.disabled=!1,d.disable&&b.$parent.$watch(a(d.disable),function(a){b.disabled=!!a}),b.select=function(){b.disabled||(b.active=!0)},e.addTab(b),b.$on(\"$destroy\",function(){e.removeTab(b)}),b.$transcludeFn=f}}}]).directive(\"uibTabHeadingTransclude\",function(){return{restrict:\"A\",require:\"^uibTab\",link:function(a,b){a.$watch(\"headingElement\",function(a){a&&(b.html(\"\"),b.append(a))})}}}).directive(\"uibTabContentTransclude\",function(){function a(a){return a.tagName&&(a.hasAttribute(\"uib-tab-heading\")||a.hasAttribute(\"data-uib-tab-heading\")||a.hasAttribute(\"x-uib-tab-heading\")||\"uib-tab-heading\"===a.tagName.toLowerCase()||\"data-uib-tab-heading\"===a.tagName.toLowerCase()||\"x-uib-tab-heading\"===a.tagName.toLowerCase())}return{restrict:\"A\",require:\"^uibTabset\",link:function(b,c,d){var e=b.$eval(d.uibTabContentTransclude);e.$transcludeFn(e.$parent,function(b){angular.forEach(b,function(b){a(b)?e.headingElement=b:c.append(b)})})}}}),angular.module(\"ui.bootstrap.timepicker\",[]).constant(\"uibTimepickerConfig\",{hourStep:1,minuteStep:1,secondStep:1,showMeridian:!0,showSeconds:!1,meridians:null,readonlyInput:!1,mousewheel:!0,arrowkeys:!0,showSpinners:!0,templateUrl:\"uib/template/timepicker/timepicker.html\"}).controller(\"UibTimepickerController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"$log\",\"$locale\",\"uibTimepickerConfig\",function(a,b,c,d,e,f,g){function h(){var b=+a.hours,c=a.showMeridian?b>0&&13>b:b>=0&&24>b;return c?(a.showMeridian&&(12===b&&(b=0),a.meridian===u[1]&&(b+=12)),b):void 0}function i(){var b=+a.minutes;return b>=0&&60>b?b:void 0}function j(){var b=+a.seconds;return b>=0&&60>b?b:void 0}function k(a){return null===a?\"\":angular.isDefined(a)&&a.toString().length<2?\"0\"+a:a.toString()}function l(a){m(),t.$setViewValue(new Date(r)),n(a)}function m(){t.$setValidity(\"time\",!0),a.invalidHours=!1,a.invalidMinutes=!1,a.invalidSeconds=!1}function n(b){if(t.$modelValue){var c=r.getHours(),d=r.getMinutes(),e=r.getSeconds();a.showMeridian&&(c=0===c||12===c?12:c%12),a.hours=\"h\"===b?c:k(c),\"m\"!==b&&(a.minutes=k(d)),a.meridian=r.getHours()<12?u[0]:u[1],\"s\"!==b&&(a.seconds=k(e)),a.meridian=r.getHours()<12?u[0]:u[1]}else a.hours=null,a.minutes=null,a.seconds=null,a.meridian=u[0]}function o(a){r=q(r,a),l()}function p(a,b){return q(a,60*b)}function q(a,b){var c=new Date(a.getTime()+1e3*b),d=new Date(a);return d.setHours(c.getHours(),c.getMinutes(),c.getSeconds()),d}var r=new Date,s=[],t={$setViewValue:angular.noop},u=angular.isDefined(c.meridians)?a.$parent.$eval(c.meridians):g.meridians||f.DATETIME_FORMATS.AMPMS;a.tabindex=angular.isDefined(c.tabindex)?c.tabindex:0,b.removeAttr(\"tabindex\"),this.init=function(b,d){t=b,t.$render=this.render,t.$formatters.unshift(function(a){return a?new Date(a):null});var e=d.eq(0),f=d.eq(1),h=d.eq(2),i=angular.isDefined(c.mousewheel)?a.$parent.$eval(c.mousewheel):g.mousewheel;i&&this.setupMousewheelEvents(e,f,h);var j=angular.isDefined(c.arrowkeys)?a.$parent.$eval(c.arrowkeys):g.arrowkeys;j&&this.setupArrowkeyEvents(e,f,h),a.readonlyInput=angular.isDefined(c.readonlyInput)?a.$parent.$eval(c.readonlyInput):g.readonlyInput,this.setupInputEvents(e,f,h)};var v=g.hourStep;c.hourStep&&s.push(a.$parent.$watch(d(c.hourStep),function(a){v=+a}));var w=g.minuteStep;c.minuteStep&&s.push(a.$parent.$watch(d(c.minuteStep),function(a){w=+a}));var x;s.push(a.$parent.$watch(d(c.min),function(a){var b=new Date(a);x=isNaN(b)?void 0:b}));var y;s.push(a.$parent.$watch(d(c.max),function(a){var b=new Date(a);y=isNaN(b)?void 0:b}));var z=!1;c.ngDisabled&&s.push(a.$parent.$watch(d(c.ngDisabled),function(a){z=a})),a.noIncrementHours=function(){var a=p(r,60*v);return z||a>y||r>a&&x>a},a.noDecrementHours=function(){var a=p(r,60*-v);return z||x>a||a>r&&a>y},a.noIncrementMinutes=function(){var a=p(r,w);return z||a>y||r>a&&x>a},a.noDecrementMinutes=function(){var a=p(r,-w);return z||x>a||a>r&&a>y},a.noIncrementSeconds=function(){var a=q(r,A);return z||a>y||r>a&&x>a},a.noDecrementSeconds=function(){var a=q(r,-A);return z||x>a||a>r&&a>y},a.noToggleMeridian=function(){return r.getHours()<12?z||p(r,720)>y:z||p(r,-720)<x};var A=g.secondStep;c.secondStep&&s.push(a.$parent.$watch(d(c.secondStep),function(a){A=+a})),a.showSeconds=g.showSeconds,c.showSeconds&&s.push(a.$parent.$watch(d(c.showSeconds),function(b){a.showSeconds=!!b})),a.showMeridian=g.showMeridian,c.showMeridian&&s.push(a.$parent.$watch(d(c.showMeridian),function(b){if(a.showMeridian=!!b,t.$error.time){var c=h(),d=i();angular.isDefined(c)&&angular.isDefined(d)&&(r.setHours(c),l())}else n()})),this.setupMousewheelEvents=function(b,c,d){var e=function(a){a.originalEvent&&(a=a.originalEvent);var b=a.wheelDelta?a.wheelDelta:-a.deltaY;return a.detail||b>0};b.bind(\"mousewheel wheel\",function(b){z||a.$apply(e(b)?a.incrementHours():a.decrementHours()),b.preventDefault()}),c.bind(\"mousewheel wheel\",function(b){z||a.$apply(e(b)?a.incrementMinutes():a.decrementMinutes()),b.preventDefault()}),d.bind(\"mousewheel wheel\",function(b){z||a.$apply(e(b)?a.incrementSeconds():a.decrementSeconds()),b.preventDefault()})},this.setupArrowkeyEvents=function(b,c,d){b.bind(\"keydown\",function(b){z||(38===b.which?(b.preventDefault(),a.incrementHours(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementHours(),a.$apply()))}),c.bind(\"keydown\",function(b){z||(38===b.which?(b.preventDefault(),a.incrementMinutes(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementMinutes(),a.$apply()))}),d.bind(\"keydown\",function(b){z||(38===b.which?(b.preventDefault(),a.incrementSeconds(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementSeconds(),a.$apply()))})},this.setupInputEvents=function(b,c,d){if(a.readonlyInput)return a.updateHours=angular.noop,a.updateMinutes=angular.noop,void(a.updateSeconds=angular.noop);var e=function(b,c,d){t.$setViewValue(null),t.$setValidity(\"time\",!1),angular.isDefined(b)&&(a.invalidHours=b),angular.isDefined(c)&&(a.invalidMinutes=c),angular.isDefined(d)&&(a.invalidSeconds=d)};a.updateHours=function(){var a=h(),b=i();t.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(r.setHours(a),r.setMinutes(b),x>r||r>y?e(!0):l(\"h\")):e(!0)},b.bind(\"blur\",function(b){t.$setTouched(),null===a.hours||\"\"===a.hours?e(!0):!a.invalidHours&&a.hours<10&&a.$apply(function(){a.hours=k(a.hours)})}),a.updateMinutes=function(){var a=i(),b=h();t.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(r.setHours(b),r.setMinutes(a),x>r||r>y?e(void 0,!0):l(\"m\")):e(void 0,!0)},c.bind(\"blur\",function(b){t.$setTouched(),null===a.minutes?e(void 0,!0):!a.invalidMinutes&&a.minutes<10&&a.$apply(function(){a.minutes=k(a.minutes)})}),a.updateSeconds=function(){var a=j();t.$setDirty(),angular.isDefined(a)?(r.setSeconds(a),l(\"s\")):e(void 0,void 0,!0)},d.bind(\"blur\",function(b){!a.invalidSeconds&&a.seconds<10&&a.$apply(function(){a.seconds=k(a.seconds)})})},this.render=function(){var b=t.$viewValue;isNaN(b)?(t.$setValidity(\"time\",!1),e.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')):(b&&(r=b),x>r||r>y?(t.$setValidity(\"time\",!1),a.invalidHours=!0,a.invalidMinutes=!0):m(),n())},a.showSpinners=angular.isDefined(c.showSpinners)?a.$parent.$eval(c.showSpinners):g.showSpinners,a.incrementHours=function(){a.noIncrementHours()||o(60*v*60)},a.decrementHours=function(){a.noDecrementHours()||o(60*-v*60)},a.incrementMinutes=function(){a.noIncrementMinutes()||o(60*w)},a.decrementMinutes=function(){a.noDecrementMinutes()||o(60*-w)},a.incrementSeconds=function(){a.noIncrementSeconds()||o(A)},a.decrementSeconds=function(){a.noDecrementSeconds()||o(-A)},a.toggleMeridian=function(){var b=i(),c=h();a.noToggleMeridian()||(angular.isDefined(b)&&angular.isDefined(c)?o(720*(r.getHours()<12?60:-60)):a.meridian=a.meridian===u[0]?u[1]:u[0])},a.blur=function(){t.$setTouched()},a.$on(\"$destroy\",function(){for(;s.length;)s.shift()()})}]).directive(\"uibTimepicker\",[\"uibTimepickerConfig\",function(a){return{require:[\"uibTimepicker\",\"?^ngModel\"],controller:\"UibTimepickerController\",controllerAs:\"timepicker\",replace:!0,scope:{},templateUrl:function(b,c){return c.templateUrl||a.templateUrl},link:function(a,b,c,d){var e=d[0],f=d[1];f&&e.init(f,b.find(\"input\"))}}}]),angular.module(\"ui.bootstrap.typeahead\",[\"ui.bootstrap.debounce\",\"ui.bootstrap.position\"]).factory(\"uibTypeaheadParser\",[\"$parse\",function(a){var b=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;return{parse:function(c){var d=c.match(b);if(!d)throw new Error('Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\" but got \"'+c+'\".');return{itemName:d[3],source:a(d[4]),viewMapper:a(d[2]||d[1]),modelMapper:a(d[1])}}}}]).controller(\"UibTypeaheadController\",[\"$scope\",\"$element\",\"$attrs\",\"$compile\",\"$parse\",\"$q\",\"$timeout\",\"$document\",\"$window\",\"$rootScope\",\"$$debounce\",\"$uibPosition\",\"uibTypeaheadParser\",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(){N.moveInProgress||(N.moveInProgress=!0,N.$digest()),Y()}function o(){N.position=D?l.offset(b):l.position(b),N.position.top+=b.prop(\"offsetHeight\")}var p,q,r=[9,13,27,38,40],s=200,t=a.$eval(c.typeaheadMinLength);t||0===t||(t=1);var u=a.$eval(c.typeaheadWaitMs)||0,v=a.$eval(c.typeaheadEditable)!==!1;a.$watch(c.typeaheadEditable,function(a){v=a!==!1});var w,x,y=e(c.typeaheadLoading).assign||angular.noop,z=e(c.typeaheadOnSelect),A=angular.isDefined(c.typeaheadSelectOnBlur)?a.$eval(c.typeaheadSelectOnBlur):!1,B=e(c.typeaheadNoResults).assign||angular.noop,C=c.typeaheadInputFormatter?e(c.typeaheadInputFormatter):void 0,D=c.typeaheadAppendToBody?a.$eval(c.typeaheadAppendToBody):!1,E=c.typeaheadAppendTo?a.$eval(c.typeaheadAppendTo):null,F=a.$eval(c.typeaheadFocusFirst)!==!1,G=c.typeaheadSelectOnExact?a.$eval(c.typeaheadSelectOnExact):!1,H=e(c.typeaheadIsOpen).assign||angular.noop,I=a.$eval(c.typeaheadShowHint)||!1,J=e(c.ngModel),K=e(c.ngModel+\"($$$p)\"),L=function(b,c){return angular.isFunction(J(a))&&q&&q.$options&&q.$options.getterSetter?K(b,{$$$p:c}):J.assign(b,c)},M=m.parse(c.uibTypeahead),N=a.$new(),O=a.$on(\"$destroy\",function(){N.$destroy()});N.$on(\"$destroy\",O);var P=\"typeahead-\"+N.$id+\"-\"+Math.floor(1e4*Math.random());b.attr({\"aria-autocomplete\":\"list\",\"aria-expanded\":!1,\"aria-owns\":P});var Q,R;I&&(Q=angular.element(\"<div></div>\"),Q.css(\"position\",\"relative\"),b.after(Q),R=b.clone(),R.attr(\"placeholder\",\"\"),R.val(\"\"),R.css({position:\"absolute\",top:\"0px\",left:\"0px\",\"border-color\":\"transparent\",\"box-shadow\":\"none\",opacity:1,background:\"none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)\",color:\"#999\"}),b.css({position:\"relative\",\"vertical-align\":\"top\",\"background-color\":\"transparent\"}),Q.append(R),R.after(b));var S=angular.element(\"<div uib-typeahead-popup></div>\");S.attr({id:P,matches:\"matches\",active:\"activeIdx\",select:\"select(activeIdx, evt)\",\"move-in-progress\":\"moveInProgress\",query:\"query\",position:\"position\",\"assign-is-open\":\"assignIsOpen(isOpen)\",debounce:\"debounceUpdate\"}),angular.isDefined(c.typeaheadTemplateUrl)&&S.attr(\"template-url\",c.typeaheadTemplateUrl),angular.isDefined(c.typeaheadPopupTemplateUrl)&&S.attr(\"popup-template-url\",c.typeaheadPopupTemplateUrl);var T=function(){I&&R.val(\"\")},U=function(){N.matches=[],N.activeIdx=-1,b.attr(\"aria-expanded\",!1),T()},V=function(a){return P+\"-option-\"+a};N.$watch(\"activeIdx\",function(a){0>a?b.removeAttr(\"aria-activedescendant\"):b.attr(\"aria-activedescendant\",V(a))});var W=function(a,b){return N.matches.length>b&&a?a.toUpperCase()===N.matches[b].label.toUpperCase():!1},X=function(c,d){var e={$viewValue:c};y(a,!0),B(a,!1),f.when(M.source(a,e)).then(function(f){var g=c===p.$viewValue;if(g&&w)if(f&&f.length>0){N.activeIdx=F?0:-1,B(a,!1),N.matches.length=0;for(var h=0;h<f.length;h++)e[M.itemName]=f[h],N.matches.push({id:V(h),label:M.viewMapper(N,e),model:f[h]});if(N.query=c,o(),b.attr(\"aria-expanded\",!0),G&&1===N.matches.length&&W(c,0)&&(angular.isNumber(N.debounceUpdate)||angular.isObject(N.debounceUpdate)?k(function(){N.select(0,d)},angular.isNumber(N.debounceUpdate)?N.debounceUpdate:N.debounceUpdate[\"default\"]):N.select(0,d)),I){var i=N.matches[0].label;c.length>0&&i.slice(0,c.length).toUpperCase()===c.toUpperCase()?R.val(c+i.slice(c.length)):R.val(\"\")}}else U(),B(a,!0);g&&y(a,!1)},function(){U(),y(a,!1),B(a,!0)})};D&&(angular.element(i).on(\"resize\",n),h.find(\"body\").on(\"scroll\",n));var Y=k(function(){N.matches.length&&o(),N.moveInProgress=!1},s);N.moveInProgress=!1,N.query=void 0;var Z,$=function(a){Z=g(function(){X(a)},u)},_=function(){Z&&g.cancel(Z)};U(),N.assignIsOpen=function(b){H(a,b)},N.select=function(d,e){var f,h,i={};x=!0,i[M.itemName]=h=N.matches[d].model,f=M.modelMapper(a,i),L(a,f),p.$setValidity(\"editable\",!0),p.$setValidity(\"parse\",!0),z(a,{$item:h,$model:f,$label:M.viewMapper(a,i),$event:e}),U(),N.$eval(c.typeaheadFocusOnSelect)!==!1&&g(function(){b[0].focus()},0,!1)},b.on(\"keydown\",function(a){if(0!==N.matches.length&&-1!==r.indexOf(a.which)){if(-1===N.activeIdx&&(9===a.which||13===a.which))return U(),void N.$digest();a.preventDefault();var b;switch(a.which){case 9:case 13:N.$apply(function(){angular.isNumber(N.debounceUpdate)||angular.isObject(N.debounceUpdate)?k(function(){N.select(N.activeIdx,a)},angular.isNumber(N.debounceUpdate)?N.debounceUpdate:N.debounceUpdate[\"default\"]):N.select(N.activeIdx,a)});break;case 27:a.stopPropagation(),U(),N.$digest();break;case 38:N.activeIdx=(N.activeIdx>0?N.activeIdx:N.matches.length)-1,N.$digest(),b=S.find(\"li\")[N.activeIdx],b.parentNode.scrollTop=b.offsetTop;break;case 40:N.activeIdx=(N.activeIdx+1)%N.matches.length,N.$digest(),b=S.find(\"li\")[N.activeIdx],b.parentNode.scrollTop=b.offsetTop}}}),b.bind(\"focus\",function(a){w=!0,0!==t||p.$viewValue||g(function(){X(p.$viewValue,a)},0)}),b.bind(\"blur\",function(a){A&&N.matches.length&&-1!==N.activeIdx&&!x&&(x=!0,N.$apply(function(){angular.isObject(N.debounceUpdate)&&angular.isNumber(N.debounceUpdate.blur)?k(function(){N.select(N.activeIdx,a)},N.debounceUpdate.blur):N.select(N.activeIdx,a)})),!v&&p.$error.editable&&(p.$viewValue=\"\",b.val(\"\")),w=!1,x=!1});var aa=function(a){b[0]!==a.target&&3!==a.which&&0!==N.matches.length&&(U(),j.$$phase||N.$digest())};h.on(\"click\",aa),a.$on(\"$destroy\",function(){h.off(\"click\",aa),(D||E)&&ba.remove(),D&&(angular.element(i).off(\"resize\",n),h.find(\"body\").off(\"scroll\",n)),S.remove(),I&&Q.remove()});var ba=d(S)(N);D?h.find(\"body\").append(ba):E?angular.element(E).eq(0).append(ba):b.after(ba),this.init=function(b,c){p=b,q=c,N.debounceUpdate=p.$options&&e(p.$options.debounce)(a),p.$parsers.unshift(function(b){return w=!0,0===t||b&&b.length>=t?u>0?(_(),$(b)):X(b):(y(a,!1),_(),U()),v?b:b?void p.$setValidity(\"editable\",!1):(p.$setValidity(\"editable\",!0),null)}),p.$formatters.push(function(b){var c,d,e={};return v||p.$setValidity(\"editable\",!0),C?(e.$model=b,C(a,e)):(e[M.itemName]=b,c=M.viewMapper(a,e),e[M.itemName]=void 0,d=M.viewMapper(a,e),c!==d?c:b)})}}]).directive(\"uibTypeahead\",function(){return{controller:\"UibTypeaheadController\",require:[\"ngModel\",\"^?ngModelOptions\",\"uibTypeahead\"],link:function(a,b,c,d){d[2].init(d[0],d[1])}}}).directive(\"uibTypeaheadPopup\",[\"$$debounce\",function(a){return{scope:{matches:\"=\",query:\"=\",active:\"=\",position:\"&\",moveInProgress:\"=\",select:\"&\",assignIsOpen:\"&\",debounce:\"&\"},replace:!0,templateUrl:function(a,b){return b.popupTemplateUrl||\"uib/template/typeahead/typeahead-popup.html\"},link:function(b,c,d){b.templateUrl=d.templateUrl,b.isOpen=function(){var a=b.matches.length>0;return b.assignIsOpen({isOpen:a}),a},b.isActive=function(a){return b.active===a},b.selectActive=function(a){b.active=a},b.selectMatch=function(c,d){var e=b.debounce();angular.isNumber(e)||angular.isObject(e)?a(function(){b.select({activeIdx:c,evt:d})},angular.isNumber(e)?e:e[\"default\"]):b.select({activeIdx:c,evt:d})}}}}]).directive(\"uibTypeaheadMatch\",[\"$templateRequest\",\"$compile\",\"$parse\",function(a,b,c){return{scope:{index:\"=\",match:\"=\",query:\"=\"},link:function(d,e,f){var g=c(f.templateUrl)(d.$parent)||\"uib/template/typeahead/typeahead-match.html\";a(g).then(function(a){var c=angular.element(a.trim());e.replaceWith(c),b(c)(d)})}}}]).filter(\"uibTypeaheadHighlight\",[\"$sce\",\"$injector\",\"$log\",function(a,b,c){function d(a){return a.replace(/([.?*+^$[\\]\\\\(){}|-])/g,\"\\\\$1\")}function e(a){return/<.*>/g.test(a)}var f;return f=b.has(\"$sanitize\"),function(b,g){return!f&&e(b)&&c.warn(\"Unsafe use of typeahead please use ngSanitize\"),b=g?(\"\"+b).replace(new RegExp(d(g),\"gi\"),\"<strong>$&</strong>\"):b,f||(b=a.trustAsHtml(b)),b}}]),angular.module(\"ui.bootstrap.carousel\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>')}),angular.module(\"ui.bootstrap.datepicker\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>')}),angular.module(\"ui.bootstrap.timepicker\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>')}),angular.module(\"ui.bootstrap.typeahead\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>')});"

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(56))

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = "/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 1.1.1 - 2016-01-25\n * License: MIT\n */angular.module(\"ui.bootstrap\",[\"ui.bootstrap.tpls\",\"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]),angular.module(\"ui.bootstrap.tpls\",[\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/popup.html\",\"uib/template/datepicker/year.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]),angular.module(\"ui.bootstrap.collapse\",[]).directive(\"uibCollapse\",[\"$animate\",\"$q\",\"$parse\",\"$injector\",function(a,b,c,d){var e=d.has(\"$animateCss\")?d.get(\"$animateCss\"):null;return{link:function(d,f,g){function h(){f.hasClass(\"collapse\")&&f.hasClass(\"in\")||b.resolve(l(d)).then(function(){f.removeClass(\"collapse\").addClass(\"collapsing\").attr(\"aria-expanded\",!0).attr(\"aria-hidden\",!1),e?e(f,{addClass:\"in\",easing:\"ease\",to:{height:f[0].scrollHeight+\"px\"}}).start()[\"finally\"](i):a.addClass(f,\"in\",{to:{height:f[0].scrollHeight+\"px\"}}).then(i)})}function i(){f.removeClass(\"collapsing\").addClass(\"collapse\").css({height:\"auto\"}),m(d)}function j(){return f.hasClass(\"collapse\")||f.hasClass(\"in\")?void b.resolve(n(d)).then(function(){f.css({height:f[0].scrollHeight+\"px\"}).removeClass(\"collapse\").addClass(\"collapsing\").attr(\"aria-expanded\",!1).attr(\"aria-hidden\",!0),e?e(f,{removeClass:\"in\",to:{height:\"0\"}}).start()[\"finally\"](k):a.removeClass(f,\"in\",{to:{height:\"0\"}}).then(k)}):k()}function k(){f.css({height:\"0\"}),f.removeClass(\"collapsing\").addClass(\"collapse\"),o(d)}var l=c(g.expanding),m=c(g.expanded),n=c(g.collapsing),o=c(g.collapsed);d.$eval(g.uibCollapse)||f.addClass(\"in\").addClass(\"collapse\").attr(\"aria-expanded\",!0).attr(\"aria-hidden\",!1).css({height:\"auto\"}),d.$watch(g.uibCollapse,function(a){a?j():h()})}}}]),angular.module(\"ui.bootstrap.accordion\",[\"ui.bootstrap.collapse\"]).constant(\"uibAccordionConfig\",{closeOthers:!0}).controller(\"UibAccordionController\",[\"$scope\",\"$attrs\",\"uibAccordionConfig\",function(a,b,c){this.groups=[],this.closeOthers=function(d){var e=angular.isDefined(b.closeOthers)?a.$eval(b.closeOthers):c.closeOthers;e&&angular.forEach(this.groups,function(a){a!==d&&(a.isOpen=!1)})},this.addGroup=function(a){var b=this;this.groups.push(a),a.$on(\"$destroy\",function(c){b.removeGroup(a)})},this.removeGroup=function(a){var b=this.groups.indexOf(a);-1!==b&&this.groups.splice(b,1)}}]).directive(\"uibAccordion\",function(){return{controller:\"UibAccordionController\",controllerAs:\"accordion\",transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/accordion/accordion.html\"}}}).directive(\"uibAccordionGroup\",function(){return{require:\"^uibAccordion\",transclude:!0,replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/accordion/accordion-group.html\"},scope:{heading:\"@\",isOpen:\"=?\",isDisabled:\"=?\"},controller:function(){this.setHeading=function(a){this.heading=a}},link:function(a,b,c,d){d.addGroup(a),a.openClass=c.openClass||\"panel-open\",a.panelClass=c.panelClass||\"panel-default\",a.$watch(\"isOpen\",function(c){b.toggleClass(a.openClass,!!c),c&&d.closeOthers(a)}),a.toggleOpen=function(b){a.isDisabled||b&&32!==b.which||(a.isOpen=!a.isOpen)}}}}).directive(\"uibAccordionHeading\",function(){return{transclude:!0,template:\"\",replace:!0,require:\"^uibAccordionGroup\",link:function(a,b,c,d,e){d.setHeading(e(a,angular.noop))}}}).directive(\"uibAccordionTransclude\",function(){return{require:\"^uibAccordionGroup\",link:function(a,b,c,d){a.$watch(function(){return d[c.uibAccordionTransclude]},function(a){a&&(b.find(\"span\").html(\"\"),b.find(\"span\").append(a))})}}}),angular.module(\"ui.bootstrap.alert\",[]).controller(\"UibAlertController\",[\"$scope\",\"$attrs\",\"$interpolate\",\"$timeout\",function(a,b,c,d){a.closeable=!!b.close;var e=angular.isDefined(b.dismissOnTimeout)?c(b.dismissOnTimeout)(a.$parent):null;e&&d(function(){a.close()},parseInt(e,10))}]).directive(\"uibAlert\",function(){return{controller:\"UibAlertController\",controllerAs:\"alert\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/alert/alert.html\"},transclude:!0,replace:!0,scope:{type:\"@\",close:\"&\"}}}),angular.module(\"ui.bootstrap.buttons\",[]).constant(\"uibButtonConfig\",{activeClass:\"active\",toggleEvent:\"click\"}).controller(\"UibButtonsController\",[\"uibButtonConfig\",function(a){this.activeClass=a.activeClass||\"active\",this.toggleEvent=a.toggleEvent||\"click\"}]).directive(\"uibBtnRadio\",[\"$parse\",function(a){return{require:[\"uibBtnRadio\",\"ngModel\"],controller:\"UibButtonsController\",controllerAs:\"buttons\",link:function(b,c,d,e){var f=e[0],g=e[1],h=a(d.uibUncheckable);c.find(\"input\").css({display:\"none\"}),g.$render=function(){c.toggleClass(f.activeClass,angular.equals(g.$modelValue,b.$eval(d.uibBtnRadio)))},c.on(f.toggleEvent,function(){if(!d.disabled){var a=c.hasClass(f.activeClass);(!a||angular.isDefined(d.uncheckable))&&b.$apply(function(){g.$setViewValue(a?null:b.$eval(d.uibBtnRadio)),g.$render()})}}),d.uibUncheckable&&b.$watch(h,function(a){d.$set(\"uncheckable\",a?\"\":null)})}}}]).directive(\"uibBtnCheckbox\",function(){return{require:[\"uibBtnCheckbox\",\"ngModel\"],controller:\"UibButtonsController\",controllerAs:\"button\",link:function(a,b,c,d){function e(){return g(c.btnCheckboxTrue,!0)}function f(){return g(c.btnCheckboxFalse,!1)}function g(b,c){return angular.isDefined(b)?a.$eval(b):c}var h=d[0],i=d[1];b.find(\"input\").css({display:\"none\"}),i.$render=function(){b.toggleClass(h.activeClass,angular.equals(i.$modelValue,e()))},b.on(h.toggleEvent,function(){c.disabled||a.$apply(function(){i.$setViewValue(b.hasClass(h.activeClass)?f():e()),i.$render()})})}}}),angular.module(\"ui.bootstrap.carousel\",[]).controller(\"UibCarouselController\",[\"$scope\",\"$element\",\"$interval\",\"$timeout\",\"$animate\",function(a,b,c,d,e){function f(){for(;s.length;)s.shift()}function g(a){if(angular.isUndefined(p[a].index))return p[a];for(var b=0,c=p.length;c>b;++b)if(p[b].index===a)return p[b]}function h(c,d,g){t||(angular.extend(c,{direction:g,active:!0}),angular.extend(o.currentSlide||{},{direction:g,active:!1}),e.enabled(b)&&!a.$currentTransition&&c.$element&&o.slides.length>1&&(c.$element.data(q,c.direction),o.currentSlide&&o.currentSlide.$element&&o.currentSlide.$element.data(q,c.direction),a.$currentTransition=!0,e.on(\"addClass\",c.$element,function(b,c){if(\"close\"===c&&(a.$currentTransition=null,e.off(\"addClass\",b),s.length)){var d=s.pop(),g=a.indexOfSlide(d),i=g>o.getCurrentIndex()?\"next\":\"prev\";f(),h(d,g,i)}})),o.currentSlide=c,r=d,k())}function i(){m&&(c.cancel(m),m=null)}function j(b){b.length||(a.$currentTransition=null,f())}function k(){i();var b=+a.interval;!isNaN(b)&&b>0&&(m=c(l,b))}function l(){var b=+a.interval;n&&!isNaN(b)&&b>0&&p.length?a.next():a.pause()}var m,n,o=this,p=o.slides=a.slides=[],q=\"uib-slideDirection\",r=-1,s=[];o.currentSlide=null;var t=!1;o.addSlide=function(b,c){b.$element=c,p.push(b),1===p.length||b.active?(a.$currentTransition&&(a.$currentTransition=null),o.select(p[p.length-1]),1===p.length&&a.play()):b.active=!1},o.getCurrentIndex=function(){return o.currentSlide&&angular.isDefined(o.currentSlide.index)?+o.currentSlide.index:r},o.next=a.next=function(){var b=(o.getCurrentIndex()+1)%p.length;return 0===b&&a.noWrap()?void a.pause():o.select(g(b),\"next\")},o.prev=a.prev=function(){var b=o.getCurrentIndex()-1<0?p.length-1:o.getCurrentIndex()-1;return a.noWrap()&&b===p.length-1?void a.pause():o.select(g(b),\"prev\")},o.removeSlide=function(a){angular.isDefined(a.index)&&p.sort(function(a,b){return+a.index>+b.index});var b=s.indexOf(a);-1!==b&&s.splice(b,1);var c=p.indexOf(a);p.splice(c,1),d(function(){p.length>0&&a.active?c>=p.length?o.select(p[c-1]):o.select(p[c]):r>c&&r--}),0===p.length&&(o.currentSlide=null,f())},o.select=a.select=function(b,c){var d=a.indexOfSlide(b);void 0===c&&(c=d>o.getCurrentIndex()?\"next\":\"prev\"),b&&b!==o.currentSlide&&!a.$currentTransition?h(b,d,c):b&&b!==o.currentSlide&&a.$currentTransition&&(s.push(b),b.active=!1)},a.indexOfSlide=function(a){return angular.isDefined(a.index)?+a.index:p.indexOf(a)},a.isActive=function(a){return o.currentSlide===a},a.pause=function(){a.noPause||(n=!1,i())},a.play=function(){n||(n=!0,k())},a.$on(\"$destroy\",function(){t=!0,i()}),a.$watch(\"noTransition\",function(a){e.enabled(b,!a)}),a.$watch(\"interval\",k),a.$watchCollection(\"slides\",j)}]).directive(\"uibCarousel\",function(){return{transclude:!0,replace:!0,controller:\"UibCarouselController\",controllerAs:\"carousel\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/carousel/carousel.html\"},scope:{interval:\"=\",noTransition:\"=\",noPause:\"=\",noWrap:\"&\"}}}).directive(\"uibSlide\",function(){return{require:\"^uibCarousel\",transclude:!0,replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/carousel/slide.html\"},scope:{active:\"=?\",actual:\"=?\",index:\"=?\"},link:function(a,b,c,d){d.addSlide(a,b),a.$on(\"$destroy\",function(){d.removeSlide(a)}),a.$watch(\"active\",function(b){b&&d.select(a)})}}}).animation(\".item\",[\"$animateCss\",function(a){function b(a,b,c){a.removeClass(b),c&&c()}var c=\"uib-slideDirection\";return{beforeAddClass:function(d,e,f){if(\"active\"===e){var g=!1,h=d.data(c),i=\"next\"===h?\"left\":\"right\",j=b.bind(this,d,i+\" \"+h,f);return d.addClass(h),a(d,{addClass:i}).start().done(j),function(){g=!0}}f()},beforeRemoveClass:function(d,e,f){if(\"active\"===e){var g=!1,h=d.data(c),i=\"next\"===h?\"left\":\"right\",j=b.bind(this,d,i,f);return a(d,{addClass:i}).start().done(j),function(){g=!0}}f()}}}]),angular.module(\"ui.bootstrap.dateparser\",[]).service(\"uibDateParser\",[\"$log\",\"$locale\",\"orderByFilter\",function(a,b,c){function d(a){var b=[],d=a.split(\"\"),e=a.indexOf(\"'\");if(e>-1){var f=!1;a=a.split(\"\");for(var g=e;g<a.length;g++)f?(\"'\"===a[g]&&(g+1<a.length&&\"'\"===a[g+1]?(a[g+1]=\"$\",d[g+1]=\"\"):(d[g]=\"\",f=!1)),a[g]=\"$\"):\"'\"===a[g]&&(a[g]=\"$\",d[g]=\"\",f=!0);a=a.join(\"\")}return angular.forEach(m,function(c){var e=a.indexOf(c.key);if(e>-1){a=a.split(\"\"),d[e]=\"(\"+c.regex+\")\",a[e]=\"$\";for(var f=e+1,g=e+c.key.length;g>f;f++)d[f]=\"\",a[f]=\"$\";a=a.join(\"\"),b.push({index:e,apply:c.apply,matcher:c.regex})}}),{regex:new RegExp(\"^\"+d.join(\"\")+\"$\"),map:c(b,\"index\")}}function e(a,b,c){return 1>c?!1:1===b&&c>28?29===c&&(a%4===0&&a%100!==0||a%400===0):3===b||5===b||8===b||10===b?31>c:!0}function f(a){return parseInt(a,10)}function g(a,b){return a&&b?k(a,b):a}function h(a,b){return a&&b?k(a,b,!0):a}function i(a,b){var c=Date.parse(\"Jan 01, 1970 00:00:00 \"+a)/6e4;return isNaN(c)?b:c}function j(a,b){return a=new Date(a.getTime()),a.setMinutes(a.getMinutes()+b),a}function k(a,b,c){c=c?-1:1;var d=i(b,a.getTimezoneOffset());return j(a,c*(d-a.getTimezoneOffset()))}var l,m,n=/[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;this.init=function(){l=b.id,this.parsers={},m=[{key:\"yyyy\",regex:\"\\\\d{4}\",apply:function(a){this.year=+a}},{key:\"yy\",regex:\"\\\\d{2}\",apply:function(a){this.year=+a+2e3}},{key:\"y\",regex:\"\\\\d{1,4}\",apply:function(a){this.year=+a}},{key:\"M!\",regex:\"0?[1-9]|1[0-2]\",apply:function(a){this.month=a-1}},{key:\"MMMM\",regex:b.DATETIME_FORMATS.MONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.MONTH.indexOf(a)}},{key:\"MMM\",regex:b.DATETIME_FORMATS.SHORTMONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.SHORTMONTH.indexOf(a)}},{key:\"MM\",regex:\"0[1-9]|1[0-2]\",apply:function(a){this.month=a-1}},{key:\"M\",regex:\"[1-9]|1[0-2]\",apply:function(a){this.month=a-1}},{key:\"d!\",regex:\"[0-2]?[0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a}},{key:\"dd\",regex:\"[0-2][0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a}},{key:\"d\",regex:\"[1-2]?[0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a}},{key:\"EEEE\",regex:b.DATETIME_FORMATS.DAY.join(\"|\")},{key:\"EEE\",regex:b.DATETIME_FORMATS.SHORTDAY.join(\"|\")},{key:\"HH\",regex:\"(?:0|1)[0-9]|2[0-3]\",apply:function(a){this.hours=+a}},{key:\"hh\",regex:\"0[0-9]|1[0-2]\",apply:function(a){this.hours=+a}},{key:\"H\",regex:\"1?[0-9]|2[0-3]\",apply:function(a){this.hours=+a}},{key:\"h\",regex:\"[0-9]|1[0-2]\",apply:function(a){this.hours=+a}},{key:\"mm\",regex:\"[0-5][0-9]\",apply:function(a){this.minutes=+a}},{key:\"m\",regex:\"[0-9]|[1-5][0-9]\",apply:function(a){this.minutes=+a}},{key:\"sss\",regex:\"[0-9][0-9][0-9]\",apply:function(a){this.milliseconds=+a}},{key:\"ss\",regex:\"[0-5][0-9]\",apply:function(a){this.seconds=+a}},{key:\"s\",regex:\"[0-9]|[1-5][0-9]\",apply:function(a){this.seconds=+a}},{key:\"a\",regex:b.DATETIME_FORMATS.AMPMS.join(\"|\"),apply:function(a){12===this.hours&&(this.hours=0),\"PM\"===a&&(this.hours+=12)}},{key:\"Z\",regex:\"[+-]\\\\d{4}\",apply:function(a){var b=a.match(/([+-])(\\d{2})(\\d{2})/),c=b[1],d=b[2],e=b[3];this.hours+=f(c+d),this.minutes+=f(c+e)}},{key:\"ww\",regex:\"[0-4][0-9]|5[0-3]\"},{key:\"w\",regex:\"[0-9]|[1-4][0-9]|5[0-3]\"},{key:\"GGGG\",regex:b.DATETIME_FORMATS.ERANAMES.join(\"|\").replace(/\\s/g,\"\\\\s\")},{key:\"GGG\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\")},{key:\"GG\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\")},{key:\"G\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\")}]},this.init(),this.parse=function(c,f,g){if(!angular.isString(c)||!f)return c;f=b.DATETIME_FORMATS[f]||f,f=f.replace(n,\"\\\\$&\"),b.id!==l&&this.init(),this.parsers[f]||(this.parsers[f]=d(f));var h=this.parsers[f],i=h.regex,j=h.map,k=c.match(i),m=!1;if(k&&k.length){var o,p;angular.isDate(g)&&!isNaN(g.getTime())?o={year:g.getFullYear(),month:g.getMonth(),date:g.getDate(),hours:g.getHours(),minutes:g.getMinutes(),seconds:g.getSeconds(),milliseconds:g.getMilliseconds()}:(g&&a.warn(\"dateparser:\",\"baseDate is not a valid date\"),o={year:1900,month:0,date:1,hours:0,minutes:0,seconds:0,milliseconds:0});for(var q=1,r=k.length;r>q;q++){var s=j[q-1];\"Z\"===s.matcher&&(m=!0),s.apply&&s.apply.call(o,k[q])}var t=m?Date.prototype.setUTCFullYear:Date.prototype.setFullYear,u=m?Date.prototype.setUTCHours:Date.prototype.setHours;return e(o.year,o.month,o.date)&&(!angular.isDate(g)||isNaN(g.getTime())||m?(p=new Date(0),t.call(p,o.year,o.month,o.date),u.call(p,o.hours||0,o.minutes||0,o.seconds||0,o.milliseconds||0)):(p=new Date(g),t.call(p,o.year,o.month,o.date),u.call(p,o.hours,o.minutes,o.seconds,o.milliseconds))),p}},this.toTimezone=g,this.fromTimezone=h,this.timezoneToOffset=i,this.addDateMinutes=j,this.convertTimezoneToLocal=k}]),angular.module(\"ui.bootstrap.isClass\",[]).directive(\"uibIsClass\",[\"$animate\",function(a){var b=/^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/,c=/^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;return{restrict:\"A\",compile:function(d,e){function f(a,b,c){i.push(a),j.push({scope:a,element:b}),o.forEach(function(b,c){g(b,a)}),a.$on(\"$destroy\",h)}function g(b,d){var e=b.match(c),f=d.$eval(e[1]),g=e[2],h=k[b];if(!h){var i=function(b){var c=null;j.some(function(a){var d=a.scope.$eval(m);return d===b?(c=a,!0):void 0}),h.lastActivated!==c&&(h.lastActivated&&a.removeClass(h.lastActivated.element,f),c&&a.addClass(c.element,f),h.lastActivated=c)};k[b]=h={lastActivated:null,scope:d,watchFn:i,compareWithExp:g,watcher:d.$watch(g,i)}}h.watchFn(d.$eval(g))}function h(a){var b=a.targetScope,c=i.indexOf(b);if(i.splice(c,1),j.splice(c,1),i.length){var d=i[0];angular.forEach(k,function(a){a.scope===b&&(a.watcher=d.$watch(a.compareWithExp,a.watchFn),a.scope=d)})}else k={}}var i=[],j=[],k={},l=e.uibIsClass.match(b),m=l[2],n=l[1],o=n.split(\",\");return f}}}]),angular.module(\"ui.bootstrap.position\",[]).factory(\"$uibPosition\",[\"$document\",\"$window\",function(a,b){var c,d={normal:/(auto|scroll)/,hidden:/(auto|scroll|hidden)/},e={auto:/\\s?auto?\\s?/i,primary:/^(top|bottom|left|right)$/,secondary:/^(top|bottom|left|right|center)$/,vertical:/^(top|bottom)$/};return{getRawNode:function(a){return a[0]||a},parseStyle:function(a){return a=parseFloat(a),isFinite(a)?a:0},offsetParent:function(c){function d(a){return\"static\"===(b.getComputedStyle(a).position||\"static\")}c=this.getRawNode(c);for(var e=c.offsetParent||a[0].documentElement;e&&e!==a[0].documentElement&&d(e);)e=e.offsetParent;return e||a[0].documentElement},scrollbarWidth:function(){if(angular.isUndefined(c)){var b=angular.element('<div style=\"position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;\"></div>');a.find(\"body\").append(b),c=b[0].offsetWidth-b[0].clientWidth,c=isFinite(c)?c:0,b.remove()}return c},scrollParent:function(c,e){c=this.getRawNode(c);var f=e?d.hidden:d.normal,g=a[0].documentElement,h=b.getComputedStyle(c),i=\"absolute\"===h.position,j=c.parentElement||g;if(j===g||\"fixed\"===h.position)return g;for(;j.parentElement&&j!==g;){var k=b.getComputedStyle(j);if(i&&\"static\"!==k.position&&(i=!1),!i&&f.test(k.overflow+k.overflowY+k.overflowX))break;j=j.parentElement}return j},position:function(c,d){c=this.getRawNode(c);var e=this.offset(c);if(d){var f=b.getComputedStyle(c);e.top-=this.parseStyle(f.marginTop),e.left-=this.parseStyle(f.marginLeft)}var g=this.offsetParent(c),h={top:0,left:0};return g!==a[0].documentElement&&(h=this.offset(g),h.top+=g.clientTop-g.scrollTop,h.left+=g.clientLeft-g.scrollLeft),{width:Math.round(angular.isNumber(e.width)?e.width:c.offsetWidth),height:Math.round(angular.isNumber(e.height)?e.height:c.offsetHeight),top:Math.round(e.top-h.top),left:Math.round(e.left-h.left)}},offset:function(c){c=this.getRawNode(c);var d=c.getBoundingClientRect();return{width:Math.round(angular.isNumber(d.width)?d.width:c.offsetWidth),height:Math.round(angular.isNumber(d.height)?d.height:c.offsetHeight),top:Math.round(d.top+(b.pageYOffset||a[0].documentElement.scrollTop)),left:Math.round(d.left+(b.pageXOffset||a[0].documentElement.scrollLeft))}},viewportOffset:function(c,d,e){c=this.getRawNode(c),e=e!==!1?!0:!1;var f=c.getBoundingClientRect(),g={top:0,left:0,bottom:0,right:0},h=d?a[0].documentElement:this.scrollParent(c),i=h.getBoundingClientRect();if(g.top=i.top+h.clientTop,g.left=i.left+h.clientLeft,h===a[0].documentElement&&(g.top+=b.pageYOffset,g.left+=b.pageXOffset),g.bottom=g.top+h.clientHeight,g.right=g.left+h.clientWidth,e){var j=b.getComputedStyle(h);g.top+=this.parseStyle(j.paddingTop),g.bottom-=this.parseStyle(j.paddingBottom),g.left+=this.parseStyle(j.paddingLeft),g.right-=this.parseStyle(j.paddingRight)}return{top:Math.round(f.top-g.top),bottom:Math.round(g.bottom-f.bottom),left:Math.round(f.left-g.left),right:Math.round(g.right-f.right)}},parsePlacement:function(a){var b=e.auto.test(a);return b&&(a=a.replace(e.auto,\"\")),a=a.split(\"-\"),a[0]=a[0]||\"top\",e.primary.test(a[0])||(a[0]=\"top\"),a[1]=a[1]||\"center\",e.secondary.test(a[1])||(a[1]=\"center\"),b?a[2]=!0:a[2]=!1,a},positionElements:function(a,c,d,f){a=this.getRawNode(a),c=this.getRawNode(c);var g=angular.isDefined(c.offsetWidth)?c.offsetWidth:c.prop(\"offsetWidth\"),h=angular.isDefined(c.offsetHeight)?c.offsetHeight:c.prop(\"offsetHeight\");d=this.parsePlacement(d);var i=f?this.offset(a):this.position(a),j={top:0,left:0,placement:\"\"};if(d[2]){var k=this.viewportOffset(a),l=b.getComputedStyle(c),m={width:g+Math.round(Math.abs(this.parseStyle(l.marginLeft)+this.parseStyle(l.marginRight))),height:h+Math.round(Math.abs(this.parseStyle(l.marginTop)+this.parseStyle(l.marginBottom)))};if(d[0]=\"top\"===d[0]&&m.height>k.top&&m.height<=k.bottom?\"bottom\":\"bottom\"===d[0]&&m.height>k.bottom&&m.height<=k.top?\"top\":\"left\"===d[0]&&m.width>k.left&&m.width<=k.right?\"right\":\"right\"===d[0]&&m.width>k.right&&m.width<=k.left?\"left\":d[0],d[1]=\"top\"===d[1]&&m.height-i.height>k.bottom&&m.height-i.height<=k.top?\"bottom\":\"bottom\"===d[1]&&m.height-i.height>k.top&&m.height-i.height<=k.bottom?\"top\":\"left\"===d[1]&&m.width-i.width>k.right&&m.width-i.width<=k.left?\"right\":\"right\"===d[1]&&m.width-i.width>k.left&&m.width-i.width<=k.right?\"left\":d[1],\"center\"===d[1])if(e.vertical.test(d[0])){var n=i.width/2-g/2;k.left+n<0&&m.width-i.width<=k.right?d[1]=\"left\":k.right+n<0&&m.width-i.width<=k.left&&(d[1]=\"right\")}else{var o=i.height/2-m.height/2;k.top+o<0&&m.height-i.height<=k.bottom?d[1]=\"top\":k.bottom+o<0&&m.height-i.height<=k.top&&(d[1]=\"bottom\")}}switch(d[0]){case\"top\":j.top=i.top-h;break;case\"bottom\":j.top=i.top+i.height;break;case\"left\":j.left=i.left-g;break;case\"right\":j.left=i.left+i.width}switch(d[1]){case\"top\":j.top=i.top;break;case\"bottom\":j.top=i.top+i.height-h;break;case\"left\":j.left=i.left;break;case\"right\":j.left=i.left+i.width-g;break;case\"center\":e.vertical.test(d[0])?j.left=i.left+i.width/2-g/2:j.top=i.top+i.height/2-h/2}return j.top=Math.round(j.top),j.left=Math.round(j.left),j.placement=\"center\"===d[1]?d[0]:d[0]+\"-\"+d[1],j},positionArrow:function(a,c){a=this.getRawNode(a);var d=a.querySelector(\".tooltip-inner, .popover-inner\");if(d){var f=angular.element(d).hasClass(\"tooltip-inner\"),g=f?a.querySelector(\".tooltip-arrow\"):a.querySelector(\".arrow\");if(g){if(c=this.parsePlacement(c),\"center\"===c[1])return void angular.element(g).css({top:\"\",bottom:\"\",right:\"\",left:\"\",margin:\"\"});var h=\"border-\"+c[0]+\"-width\",i=b.getComputedStyle(g)[h],j=\"border-\";j+=e.vertical.test(c[0])?c[0]+\"-\"+c[1]:c[1]+\"-\"+c[0],j+=\"-radius\";var k=b.getComputedStyle(f?d:a)[j],l={top:\"auto\",bottom:\"auto\",left:\"auto\",right:\"auto\",margin:0};switch(c[0]){case\"top\":l.bottom=f?\"0\":\"-\"+i;break;case\"bottom\":l.top=f?\"0\":\"-\"+i;break;case\"left\":l.right=f?\"0\":\"-\"+i;break;case\"right\":l.left=f?\"0\":\"-\"+i}l[c[1]]=k,angular.element(g).css(l)}}}}}]),angular.module(\"ui.bootstrap.datepicker\",[\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.position\"]).value(\"$datepickerSuppressError\",!1).constant(\"uibDatepickerConfig\",{datepickerMode:\"day\",formatDay:\"dd\",formatMonth:\"MMMM\",formatYear:\"yyyy\",formatDayHeader:\"EEE\",formatDayTitle:\"MMMM yyyy\",formatMonthTitle:\"yyyy\",maxDate:null,maxMode:\"year\",minDate:null,minMode:\"day\",ngModelOptions:{},shortcutPropagation:!1,showWeeks:!0,yearColumns:5,yearRows:4}).controller(\"UibDatepickerController\",[\"$scope\",\"$attrs\",\"$parse\",\"$interpolate\",\"$locale\",\"$log\",\"dateFilter\",\"uibDatepickerConfig\",\"$datepickerSuppressError\",\"uibDateParser\",function(a,b,c,d,e,f,g,h,i,j){var k=this,l={$setViewValue:angular.noop},m={},n=[];this.modes=[\"day\",\"month\",\"year\"],angular.forEach([\"formatDay\",\"formatMonth\",\"formatYear\",\"formatDayHeader\",\"formatDayTitle\",\"formatMonthTitle\"],function(c){k[c]=angular.isDefined(b[c])?d(b[c])(a.$parent):h[c]}),angular.forEach([\"showWeeks\",\"yearRows\",\"yearColumns\",\"shortcutPropagation\"],function(c){k[c]=angular.isDefined(b[c])?a.$parent.$eval(b[c]):h[c]}),angular.isDefined(b.startingDay)?k.startingDay=a.$parent.$eval(b.startingDay):angular.isNumber(h.startingDay)?k.startingDay=h.startingDay:k.startingDay=(e.DATETIME_FORMATS.FIRSTDAYOFWEEK+8)%7,angular.forEach([\"minDate\",\"maxDate\"],function(c){b[c]?n.push(a.$parent.$watch(b[c],function(a){k[c]=a?angular.isDate(a)?j.fromTimezone(new Date(a),m.timezone):new Date(g(a,\"medium\")):null,k.refreshView()})):k[c]=h[c]?j.fromTimezone(new Date(h[c]),m.timezone):null}),angular.forEach([\"minMode\",\"maxMode\"],function(c){b[c]?n.push(a.$parent.$watch(b[c],function(d){k[c]=a[c]=angular.isDefined(d)?d:b[c],(\"minMode\"===c&&k.modes.indexOf(a.datepickerMode)<k.modes.indexOf(k[c])||\"maxMode\"===c&&k.modes.indexOf(a.datepickerMode)>k.modes.indexOf(k[c]))&&(a.datepickerMode=k[c])})):k[c]=a[c]=h[c]||null}),a.datepickerMode=a.datepickerMode||h.datepickerMode,a.uniqueId=\"datepicker-\"+a.$id+\"-\"+Math.floor(1e4*Math.random()),angular.isDefined(b.initDate)?(this.activeDate=j.fromTimezone(a.$parent.$eval(b.initDate),m.timezone)||new Date,n.push(a.$parent.$watch(b.initDate,function(a){a&&(l.$isEmpty(l.$modelValue)||l.$invalid)&&(k.activeDate=j.fromTimezone(a,m.timezone),k.refreshView())}))):this.activeDate=new Date,a.disabled=angular.isDefined(b.disabled)||!1,angular.isDefined(b.ngDisabled)&&n.push(a.$parent.$watch(b.ngDisabled,function(b){a.disabled=b,k.refreshView()})),a.isActive=function(b){return 0===k.compare(b.date,k.activeDate)?(a.activeDateId=b.uid,!0):!1},this.init=function(a){l=a,m=a.$options||h.ngModelOptions,l.$modelValue&&(this.activeDate=l.$modelValue),l.$render=function(){k.render()}},this.render=function(){if(l.$viewValue){var a=new Date(l.$viewValue),b=!isNaN(a);b?this.activeDate=j.fromTimezone(a,m.timezone):i||f.error('Datepicker directive: \"ng-model\" value must be a Date object')}this.refreshView()},this.refreshView=function(){if(this.element){a.selectedDt=null,this._refreshView(),a.activeDt&&(a.activeDateId=a.activeDt.uid);var b=l.$viewValue?new Date(l.$viewValue):null;b=j.fromTimezone(b,m.timezone),l.$setValidity(\"dateDisabled\",!b||this.element&&!this.isDisabled(b))}},this.createDateObject=function(b,c){var d=l.$viewValue?new Date(l.$viewValue):null;d=j.fromTimezone(d,m.timezone);var e={date:b,label:g(b,c.replace(/d!/,\"dd\")).replace(/M!/,\"MM\"),selected:d&&0===this.compare(b,d),disabled:this.isDisabled(b),current:0===this.compare(b,new Date),customClass:this.customClass(b)||null};return d&&0===this.compare(b,d)&&(a.selectedDt=e),k.activeDate&&0===this.compare(e.date,k.activeDate)&&(a.activeDt=e),e},this.isDisabled=function(c){return a.disabled||this.minDate&&this.compare(c,this.minDate)<0||this.maxDate&&this.compare(c,this.maxDate)>0||b.dateDisabled&&a.dateDisabled({date:c,mode:a.datepickerMode})},this.customClass=function(b){return a.customClass({date:b,mode:a.datepickerMode})},this.split=function(a,b){for(var c=[];a.length>0;)c.push(a.splice(0,b));return c},a.select=function(b){if(a.datepickerMode===k.minMode){var c=l.$viewValue?j.fromTimezone(new Date(l.$viewValue),m.timezone):new Date(0,0,0,0,0,0,0);c.setFullYear(b.getFullYear(),b.getMonth(),b.getDate()),c=j.toTimezone(c,m.timezone),l.$setViewValue(c),l.$render()}else k.activeDate=b,a.datepickerMode=k.modes[k.modes.indexOf(a.datepickerMode)-1]},a.move=function(a){var b=k.activeDate.getFullYear()+a*(k.step.years||0),c=k.activeDate.getMonth()+a*(k.step.months||0);k.activeDate.setFullYear(b,c,1),k.refreshView()},a.toggleMode=function(b){b=b||1,a.datepickerMode===k.maxMode&&1===b||a.datepickerMode===k.minMode&&-1===b||(a.datepickerMode=k.modes[k.modes.indexOf(a.datepickerMode)+b])},a.keys={13:\"enter\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\"};var o=function(){k.element[0].focus()};a.$on(\"uib:datepicker.focus\",o),a.keydown=function(b){var c=a.keys[b.which];if(c&&!b.shiftKey&&!b.altKey&&!a.disabled)if(b.preventDefault(),k.shortcutPropagation||b.stopPropagation(),\"enter\"===c||\"space\"===c){if(k.isDisabled(k.activeDate))return;a.select(k.activeDate)}else!b.ctrlKey||\"up\"!==c&&\"down\"!==c?(k.handleKeyDown(c,b),k.refreshView()):a.toggleMode(\"up\"===c?1:-1)},a.$on(\"$destroy\",function(){for(;n.length;)n.shift()()})}]).controller(\"UibDaypickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){function d(a,b){return 1!==b||a%4!==0||a%100===0&&a%400!==0?f[b]:29}function e(a){var b=new Date(a);b.setDate(b.getDate()+4-(b.getDay()||7));var c=b.getTime();return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1}var f=[31,28,31,30,31,30,31,31,30,31,30,31];this.step={months:1},this.element=b,this.init=function(b){angular.extend(b,this),a.showWeeks=b.showWeeks,b.refreshView()},this.getDates=function(a,b){for(var c,d=new Array(b),e=new Date(a),f=0;b>f;)c=new Date(e),d[f++]=c,e.setDate(e.getDate()+1);return d},this._refreshView=function(){var b=this.activeDate.getFullYear(),d=this.activeDate.getMonth(),f=new Date(this.activeDate);f.setFullYear(b,d,1);var g=this.startingDay-f.getDay(),h=g>0?7-g:-g,i=new Date(f);h>0&&i.setDate(-h+1);for(var j=this.getDates(i,42),k=0;42>k;k++)j[k]=angular.extend(this.createDateObject(j[k],this.formatDay),{secondary:j[k].getMonth()!==d,uid:a.uniqueId+\"-\"+k});a.labels=new Array(7);for(var l=0;7>l;l++)a.labels[l]={abbr:c(j[l].date,this.formatDayHeader),full:c(j[l].date,\"EEEE\")};if(a.title=c(this.activeDate,this.formatDayTitle),a.rows=this.split(j,7),a.showWeeks){a.weekNumbers=[];for(var m=(11-this.startingDay)%7,n=a.rows.length,o=0;n>o;o++)a.weekNumbers.push(e(a.rows[o][m].date))}},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth(),a.getDate()),d=new Date(b.getFullYear(),b.getMonth(),b.getDate());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getDate();if(\"left\"===a)c-=1;else if(\"up\"===a)c-=7;else if(\"right\"===a)c+=1;else if(\"down\"===a)c+=7;else if(\"pageup\"===a||\"pagedown\"===a){var e=this.activeDate.getMonth()+(\"pageup\"===a?-1:1);this.activeDate.setMonth(e,1),c=Math.min(d(this.activeDate.getFullYear(),this.activeDate.getMonth()),c)}else\"home\"===a?c=1:\"end\"===a&&(c=d(this.activeDate.getFullYear(),this.activeDate.getMonth()));this.activeDate.setDate(c)}}]).controller(\"UibMonthpickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){this.step={years:1},this.element=b,this.init=function(a){angular.extend(a,this),a.refreshView()},this._refreshView=function(){for(var b,d=new Array(12),e=this.activeDate.getFullYear(),f=0;12>f;f++)b=new Date(this.activeDate),b.setFullYear(e,f,1),d[f]=angular.extend(this.createDateObject(b,this.formatMonth),{uid:a.uniqueId+\"-\"+f});a.title=c(this.activeDate,this.formatMonthTitle),a.rows=this.split(d,3)},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth()),d=new Date(b.getFullYear(),b.getMonth());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getMonth();if(\"left\"===a)c-=1;else if(\"up\"===a)c-=3;else if(\"right\"===a)c+=1;else if(\"down\"===a)c+=3;else if(\"pageup\"===a||\"pagedown\"===a){var d=this.activeDate.getFullYear()+(\"pageup\"===a?-1:1);this.activeDate.setFullYear(d)}else\"home\"===a?c=0:\"end\"===a&&(c=11);this.activeDate.setMonth(c)}}]).controller(\"UibYearpickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){function d(a){return parseInt((a-1)/f,10)*f+1}var e,f;this.element=b,this.yearpickerInit=function(){e=this.yearColumns,f=this.yearRows*e,this.step={years:f}},this._refreshView=function(){for(var b,c=new Array(f),g=0,h=d(this.activeDate.getFullYear());f>g;g++)b=new Date(this.activeDate),b.setFullYear(h+g,0,1),c[g]=angular.extend(this.createDateObject(b,this.formatYear),{uid:a.uniqueId+\"-\"+g});a.title=[c[0].label,c[f-1].label].join(\" - \"),a.rows=this.split(c,e),a.columns=e},this.compare=function(a,b){return a.getFullYear()-b.getFullYear()},this.handleKeyDown=function(a,b){var c=this.activeDate.getFullYear();\"left\"===a?c-=1:\"up\"===a?c-=e:\"right\"===a?c+=1:\"down\"===a?c+=e:\"pageup\"===a||\"pagedown\"===a?c+=(\"pageup\"===a?-1:1)*f:\"home\"===a?c=d(this.activeDate.getFullYear()):\"end\"===a&&(c=d(this.activeDate.getFullYear())+f-1),this.activeDate.setFullYear(c)}}]).directive(\"uibDatepicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/datepicker.html\"},scope:{datepickerMode:\"=?\",dateDisabled:\"&\",customClass:\"&\",shortcutPropagation:\"&?\"},require:[\"uibDatepicker\",\"^ngModel\"],controller:\"UibDatepickerController\",controllerAs:\"datepicker\",link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}).directive(\"uibDaypicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/day.html\";\n},require:[\"^uibDatepicker\",\"uibDaypicker\"],controller:\"UibDaypickerController\",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibMonthpicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/month.html\"},require:[\"^uibDatepicker\",\"uibMonthpicker\"],controller:\"UibMonthpickerController\",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibYearpicker\",function(){return{replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/year.html\"},require:[\"^uibDatepicker\",\"uibYearpicker\"],controller:\"UibYearpickerController\",link:function(a,b,c,d){var e=d[0];angular.extend(e,d[1]),e.yearpickerInit(),e.refreshView()}}}).constant(\"uibDatepickerPopupConfig\",{altInputFormats:[],appendToBody:!1,clearText:\"Clear\",closeOnDateSelection:!0,closeText:\"Done\",currentText:\"Today\",datepickerPopup:\"yyyy-MM-dd\",datepickerPopupTemplateUrl:\"uib/template/datepicker/popup.html\",datepickerTemplateUrl:\"uib/template/datepicker/datepicker.html\",html5Types:{date:\"yyyy-MM-dd\",\"datetime-local\":\"yyyy-MM-ddTHH:mm:ss.sss\",month:\"yyyy-MM\"},onOpenFocus:!0,showButtonBar:!0}).controller(\"UibDatepickerPopupController\",[\"$scope\",\"$element\",\"$attrs\",\"$compile\",\"$parse\",\"$document\",\"$rootScope\",\"$uibPosition\",\"dateFilter\",\"uibDateParser\",\"uibDatepickerPopupConfig\",\"$timeout\",\"uibDatepickerConfig\",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(a){return a.replace(/([A-Z])/g,function(a){return\"-\"+a.toLowerCase()})}function o(b){var c=j.parse(b,t,a.date);if(isNaN(c))for(var d=0;d<E.length;d++)if(c=j.parse(b,E[d],a.date),!isNaN(c))return c;return c}function p(a){if(angular.isNumber(a)&&(a=new Date(a)),!a)return null;if(angular.isDate(a)&&!isNaN(a))return a;if(angular.isString(a)){var b=o(a);if(!isNaN(b))return j.toTimezone(b,C.timezone)}return B.$options&&B.$options.allowInvalid?a:void 0}function q(a,b){var d=a||b;return c.ngRequired||d?(angular.isNumber(d)&&(d=new Date(d)),d?angular.isDate(d)&&!isNaN(d)?!0:angular.isString(d)?!isNaN(o(b)):!1:!0):!0}function r(c){if(a.isOpen||!a.disabled){var d=D[0],e=b[0].contains(c.target),f=void 0!==d.contains&&d.contains(c.target);!a.isOpen||e||f||a.$apply(function(){a.isOpen=!1})}}function s(c){27===c.which&&a.isOpen?(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!1}),b[0].focus()):40!==c.which||a.isOpen||(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!0}))}var t,u,v,w,x,y,z,A,B,C,D,E,F={},G=!1,H=[];a.watchData={},this.init=function(h){if(B=h,C=h.$options||m.ngModelOptions,u=angular.isDefined(c.closeOnDateSelection)?a.$parent.$eval(c.closeOnDateSelection):k.closeOnDateSelection,v=angular.isDefined(c.datepickerAppendToBody)?a.$parent.$eval(c.datepickerAppendToBody):k.appendToBody,w=angular.isDefined(c.onOpenFocus)?a.$parent.$eval(c.onOpenFocus):k.onOpenFocus,x=angular.isDefined(c.datepickerPopupTemplateUrl)?c.datepickerPopupTemplateUrl:k.datepickerPopupTemplateUrl,y=angular.isDefined(c.datepickerTemplateUrl)?c.datepickerTemplateUrl:k.datepickerTemplateUrl,E=angular.isDefined(c.altInputFormats)?a.$parent.$eval(c.altInputFormats):k.altInputFormats,a.showButtonBar=angular.isDefined(c.showButtonBar)?a.$parent.$eval(c.showButtonBar):k.showButtonBar,k.html5Types[c.type]?(t=k.html5Types[c.type],G=!0):(t=c.uibDatepickerPopup||k.datepickerPopup,c.$observe(\"uibDatepickerPopup\",function(a,b){var c=a||k.datepickerPopup;if(c!==t&&(t=c,B.$modelValue=null,!t))throw new Error(\"uibDatepickerPopup must have a date format specified.\")})),!t)throw new Error(\"uibDatepickerPopup must have a date format specified.\");if(G&&c.uibDatepickerPopup)throw new Error(\"HTML5 date input types do not support custom formats.\");z=angular.element(\"<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>\"),a.ngModelOptions=angular.copy(C),a.ngModelOptions.timezone=null,z.attr({\"ng-model\":\"date\",\"ng-model-options\":\"ngModelOptions\",\"ng-change\":\"dateSelection(date)\",\"template-url\":x}),A=angular.element(z.children()[0]),A.attr(\"template-url\",y),G&&\"month\"===c.type&&(A.attr(\"datepicker-mode\",'\"month\"'),A.attr(\"min-mode\",\"month\")),a.datepickerOptions&&angular.forEach(a.datepickerOptions,function(a,b){-1===[\"minDate\",\"maxDate\",\"minMode\",\"maxMode\",\"initDate\",\"datepickerMode\"].indexOf(b)?A.attr(n(b),a):A.attr(n(b),\"datepickerOptions.\"+b)}),angular.forEach([\"minMode\",\"maxMode\",\"datepickerMode\",\"shortcutPropagation\"],function(b){if(c[b]){var d=e(c[b]),f={get:function(){return d(a.$parent)}};if(A.attr(n(b),\"watchData.\"+b),\"datepickerMode\"===b){var g=d.assign;f.set=function(b){g(a.$parent,b)}}Object.defineProperty(a.watchData,b,f)}}),angular.forEach([\"minDate\",\"maxDate\",\"initDate\"],function(b){if(c[b]){var d=e(c[b]);H.push(a.$parent.$watch(d,function(c){\"minDate\"===b||\"maxDate\"===b?(null===c?F[b]=null:angular.isDate(c)?F[b]=j.fromTimezone(new Date(c),C.timezone):F[b]=new Date(i(c,\"medium\")),a.watchData[b]=null===c?null:F[b]):a.watchData[b]=j.fromTimezone(new Date(c),C.timezone)})),A.attr(n(b),\"watchData.\"+b)}}),c.dateDisabled&&A.attr(\"date-disabled\",\"dateDisabled({ date: date, mode: mode })\"),angular.forEach([\"formatDay\",\"formatMonth\",\"formatYear\",\"formatDayHeader\",\"formatDayTitle\",\"formatMonthTitle\",\"showWeeks\",\"startingDay\",\"yearRows\",\"yearColumns\"],function(a){angular.isDefined(c[a])&&A.attr(n(a),c[a])}),c.customClass&&A.attr(\"custom-class\",\"customClass({ date: date, mode: mode })\"),G?B.$formatters.push(function(b){return a.date=j.fromTimezone(b,C.timezone),b}):(B.$$parserName=\"date\",B.$validators.date=q,B.$parsers.unshift(p),B.$formatters.push(function(b){return B.$isEmpty(b)?(a.date=b,b):(a.date=j.fromTimezone(b,C.timezone),t=t.replace(/M!/,\"MM\").replace(/d!/,\"dd\"),i(a.date,t))})),B.$viewChangeListeners.push(function(){a.date=o(B.$viewValue)}),b.on(\"keydown\",s),D=d(z)(a),z.remove(),v?f.find(\"body\").append(D):b.after(D),a.$on(\"$destroy\",function(){for(a.isOpen===!0&&(g.$$phase||a.$apply(function(){a.isOpen=!1})),D.remove(),b.off(\"keydown\",s),f.off(\"click\",r);H.length;)H.shift()()})},a.getText=function(b){return a[b+\"Text\"]||k[b+\"Text\"]},a.isDisabled=function(b){return\"today\"===b&&(b=new Date),a.watchData.minDate&&a.compare(b,F.minDate)<0||a.watchData.maxDate&&a.compare(b,F.maxDate)>0},a.compare=function(a,b){return new Date(a.getFullYear(),a.getMonth(),a.getDate())-new Date(b.getFullYear(),b.getMonth(),b.getDate())},a.dateSelection=function(c){angular.isDefined(c)&&(a.date=c);var d=a.date?i(a.date,t):null;b.val(d),B.$setViewValue(d),u&&(a.isOpen=!1,b[0].focus())},a.keydown=function(c){27===c.which&&(c.stopPropagation(),a.isOpen=!1,b[0].focus())},a.select=function(b){if(\"today\"===b){var c=new Date;angular.isDate(a.date)?(b=new Date(a.date),b.setFullYear(c.getFullYear(),c.getMonth(),c.getDate())):b=new Date(c.setHours(0,0,0,0))}a.dateSelection(b)},a.close=function(){a.isOpen=!1,b[0].focus()},a.disabled=angular.isDefined(c.disabled)||!1,c.ngDisabled&&H.push(a.$parent.$watch(e(c.ngDisabled),function(b){a.disabled=b})),a.$watch(\"isOpen\",function(c){c?a.disabled?a.isOpen=!1:(a.position=v?h.offset(b):h.position(b),a.position.top=a.position.top+b.prop(\"offsetHeight\"),l(function(){w&&a.$broadcast(\"uib:datepicker.focus\"),f.on(\"click\",r)},0,!1)):f.off(\"click\",r)})}]).directive(\"uibDatepickerPopup\",function(){return{require:[\"ngModel\",\"uibDatepickerPopup\"],controller:\"UibDatepickerPopupController\",scope:{datepickerOptions:\"=?\",isOpen:\"=?\",currentText:\"@\",clearText:\"@\",closeText:\"@\",dateDisabled:\"&\",customClass:\"&\"},link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibDatepickerPopupWrap\",function(){return{replace:!0,transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/popup.html\"}}}),angular.module(\"ui.bootstrap.debounce\",[]).factory(\"$$debounce\",[\"$timeout\",function(a){return function(b,c){var d;return function(){var e=this,f=Array.prototype.slice.call(arguments);d&&a.cancel(d),d=a(function(){b.apply(e,f)},c)}}}]),angular.module(\"ui.bootstrap.dropdown\",[\"ui.bootstrap.position\"]).constant(\"uibDropdownConfig\",{appendToOpenClass:\"uib-dropdown-open\",openClass:\"open\"}).service(\"uibDropdownService\",[\"$document\",\"$rootScope\",function(a,b){var c=null;this.open=function(b){c||(a.on(\"click\",d),a.on(\"keydown\",e)),c&&c!==b&&(c.isOpen=!1),c=b},this.close=function(b){c===b&&(c=null,a.off(\"click\",d),a.off(\"keydown\",e))};var d=function(a){if(c&&!(a&&\"disabled\"===c.getAutoClose()||a&&3===a.which)){var d=c.getToggleElement();if(!(a&&d&&d[0].contains(a.target))){var e=c.getDropdownElement();a&&\"outsideClick\"===c.getAutoClose()&&e&&e[0].contains(a.target)||(c.isOpen=!1,b.$$phase||c.$apply())}}},e=function(a){27===a.which?(c.focusToggleElement(),d()):c.isKeynavEnabled()&&-1!==[38,40].indexOf(a.which)&&c.isOpen&&(a.preventDefault(),a.stopPropagation(),c.focusDropdownEntry(a.which))}}]).controller(\"UibDropdownController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"uibDropdownConfig\",\"uibDropdownService\",\"$animate\",\"$uibPosition\",\"$document\",\"$compile\",\"$templateRequest\",function(a,b,c,d,e,f,g,h,i,j,k){var l,m,n=this,o=a.$new(),p=e.appendToOpenClass,q=e.openClass,r=angular.noop,s=c.onToggle?d(c.onToggle):angular.noop,t=!1,u=null,v=!1,w=i.find(\"body\");b.addClass(\"dropdown\"),this.init=function(){if(c.isOpen&&(m=d(c.isOpen),r=m.assign,a.$watch(m,function(a){o.isOpen=!!a})),angular.isDefined(c.dropdownAppendTo)){var e=d(c.dropdownAppendTo)(o);e&&(u=angular.element(e))}t=angular.isDefined(c.dropdownAppendToBody),v=angular.isDefined(c.keyboardNav),t&&!u&&(u=w),u&&n.dropdownMenu&&(u.append(n.dropdownMenu),b.on(\"$destroy\",function(){n.dropdownMenu.remove()}))},this.toggle=function(a){return o.isOpen=arguments.length?!!a:!o.isOpen},this.isOpen=function(){return o.isOpen},o.getToggleElement=function(){return n.toggleElement},o.getAutoClose=function(){return c.autoClose||\"always\"},o.getElement=function(){return b},o.isKeynavEnabled=function(){return v},o.focusDropdownEntry=function(a){var c=n.dropdownMenu?angular.element(n.dropdownMenu).find(\"a\"):b.find(\"ul\").eq(0).find(\"a\");switch(a){case 40:angular.isNumber(n.selectedOption)?n.selectedOption=n.selectedOption===c.length-1?n.selectedOption:n.selectedOption+1:n.selectedOption=0;break;case 38:angular.isNumber(n.selectedOption)?n.selectedOption=0===n.selectedOption?0:n.selectedOption-1:n.selectedOption=c.length-1}c[n.selectedOption].focus()},o.getDropdownElement=function(){return n.dropdownMenu},o.focusToggleElement=function(){n.toggleElement&&n.toggleElement[0].focus()},o.$watch(\"isOpen\",function(c,d){if(u&&n.dropdownMenu){var e,i,m=h.positionElements(b,n.dropdownMenu,\"bottom-left\",!0);if(e={top:m.top+\"px\",display:c?\"block\":\"none\"},i=n.dropdownMenu.hasClass(\"dropdown-menu-right\"),i?(e.left=\"auto\",e.right=window.innerWidth-(m.left+b.prop(\"offsetWidth\"))+\"px\"):(e.left=m.left+\"px\",e.right=\"auto\"),!t){var v=h.offset(u);e.top=m.top-v.top+\"px\",i?e.right=window.innerWidth-(m.left-v.left+b.prop(\"offsetWidth\"))+\"px\":e.left=m.left-v.left+\"px\"}n.dropdownMenu.css(e)}var w=u?u:b;if(g[c?\"addClass\":\"removeClass\"](w,u?p:q).then(function(){angular.isDefined(c)&&c!==d&&s(a,{open:!!c})}),c)n.dropdownMenuTemplateUrl&&k(n.dropdownMenuTemplateUrl).then(function(a){l=o.$new(),j(a.trim())(l,function(a){var b=a;n.dropdownMenu.replaceWith(b),n.dropdownMenu=b})}),o.focusToggleElement(),f.open(o);else{if(n.dropdownMenuTemplateUrl){l&&l.$destroy();var x=angular.element('<ul class=\"dropdown-menu\"></ul>');n.dropdownMenu.replaceWith(x),n.dropdownMenu=x}f.close(o),n.selectedOption=null}angular.isFunction(r)&&r(a,c)}),a.$on(\"$locationChangeSuccess\",function(){\"disabled\"!==o.getAutoClose()&&(o.isOpen=!1)})}]).directive(\"uibDropdown\",function(){return{controller:\"UibDropdownController\",link:function(a,b,c,d){d.init()}}}).directive(\"uibDropdownMenu\",function(){return{restrict:\"A\",require:\"?^uibDropdown\",link:function(a,b,c,d){if(d&&!angular.isDefined(c.dropdownNested)){b.addClass(\"dropdown-menu\");var e=c.templateUrl;e&&(d.dropdownMenuTemplateUrl=e),d.dropdownMenu||(d.dropdownMenu=b)}}}}).directive(\"uibDropdownToggle\",function(){return{require:\"?^uibDropdown\",link:function(a,b,c,d){if(d){b.addClass(\"dropdown-toggle\"),d.toggleElement=b;var e=function(e){e.preventDefault(),b.hasClass(\"disabled\")||c.disabled||a.$apply(function(){d.toggle()})};b.bind(\"click\",e),b.attr({\"aria-haspopup\":!0,\"aria-expanded\":!1}),a.$watch(d.isOpen,function(a){b.attr(\"aria-expanded\",!!a)}),a.$on(\"$destroy\",function(){b.unbind(\"click\",e)})}}}}),angular.module(\"ui.bootstrap.stackedMap\",[]).factory(\"$$stackedMap\",function(){return{createNew:function(){var a=[];return{add:function(b,c){a.push({key:b,value:c})},get:function(b){for(var c=0;c<a.length;c++)if(b===a[c].key)return a[c]},keys:function(){for(var b=[],c=0;c<a.length;c++)b.push(a[c].key);return b},top:function(){return a[a.length-1]},remove:function(b){for(var c=-1,d=0;d<a.length;d++)if(b===a[d].key){c=d;break}return a.splice(c,1)[0]},removeTop:function(){return a.splice(a.length-1,1)[0]},length:function(){return a.length}}}}}),angular.module(\"ui.bootstrap.modal\",[\"ui.bootstrap.stackedMap\"]).factory(\"$$multiMap\",function(){return{createNew:function(){var a={};return{entries:function(){return Object.keys(a).map(function(b){return{key:b,value:a[b]}})},get:function(b){return a[b]},hasKey:function(b){return!!a[b]},keys:function(){return Object.keys(a)},put:function(b,c){a[b]||(a[b]=[]),a[b].push(c)},remove:function(b,c){var d=a[b];if(d){var e=d.indexOf(c);-1!==e&&d.splice(e,1),d.length||delete a[b]}}}}}}).provider(\"$uibResolve\",function(){var a=this;this.resolver=null,this.setResolver=function(a){this.resolver=a},this.$get=[\"$injector\",\"$q\",function(b,c){var d=a.resolver?b.get(a.resolver):null;return{resolve:function(a,e,f,g){if(d)return d.resolve(a,e,f,g);var h=[];return angular.forEach(a,function(a){angular.isFunction(a)||angular.isArray(a)?h.push(c.resolve(b.invoke(a))):angular.isString(a)?h.push(c.resolve(b.get(a))):h.push(c.resolve(a))}),c.all(h).then(function(b){var c={},d=0;return angular.forEach(a,function(a,e){c[e]=b[d++]}),c})}}}]}).directive(\"uibModalBackdrop\",[\"$animateCss\",\"$injector\",\"$uibModalStack\",function(a,b,c){function d(b,d,e){e.modalInClass&&(a(d,{addClass:e.modalInClass}).start(),b.$on(c.NOW_CLOSING_EVENT,function(c,f){var g=f();b.modalOptions.animation?a(d,{removeClass:e.modalInClass}).start().then(g):g()}))}return{replace:!0,templateUrl:\"uib/template/modal/backdrop.html\",compile:function(a,b){return a.addClass(b.backdropClass),d}}}]).directive(\"uibModalWindow\",[\"$uibModalStack\",\"$q\",\"$animate\",\"$animateCss\",\"$document\",function(a,b,c,d,e){return{scope:{index:\"@\"},replace:!0,transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/modal/window.html\"},link:function(f,g,h){g.addClass(h.windowClass||\"\"),g.addClass(h.windowTopClass||\"\"),f.size=h.size,f.close=function(b){var c=a.getTop();c&&c.value.backdrop&&\"static\"!==c.value.backdrop&&b.target===b.currentTarget&&(b.preventDefault(),b.stopPropagation(),a.dismiss(c.key,\"backdrop click\"))},g.on(\"click\",f.close),f.$isRendered=!0;var i=b.defer();h.$observe(\"modalRender\",function(a){\"true\"===a&&i.resolve()}),i.promise.then(function(){var i=null;h.modalInClass&&(i=d(g,{addClass:h.modalInClass}).start(),f.$on(a.NOW_CLOSING_EVENT,function(a,b){var e=b();d?d(g,{removeClass:h.modalInClass}).start().then(e):c.removeClass(g,h.modalInClass).then(e)})),b.when(i).then(function(){if(!e[0].activeElement||!g[0].contains(e[0].activeElement)){var a=g[0].querySelector(\"[autofocus]\");a?a.focus():g[0].focus()}});var j=a.getTop();j&&a.modalRendered(j.key)})}}}]).directive(\"uibModalAnimationClass\",function(){return{compile:function(a,b){b.modalAnimation&&a.addClass(b.uibModalAnimationClass)}}}).directive(\"uibModalTransclude\",function(){return{link:function(a,b,c,d,e){e(a.$parent,function(a){b.empty(),b.append(a)})}}}).factory(\"$uibModalStack\",[\"$animate\",\"$animateCss\",\"$document\",\"$compile\",\"$rootScope\",\"$q\",\"$$multiMap\",\"$$stackedMap\",function(a,b,c,d,e,f,g,h){function i(){for(var a=-1,b=t.keys(),c=0;c<b.length;c++)t.get(b[c]).value.backdrop&&(a=c);return a}function j(a,b){var c=t.get(a).value,d=c.appendTo;t.remove(a),m(c.modalDomEl,c.modalScope,function(){var b=c.openedClass||s;u.remove(b,a),d.toggleClass(b,u.hasKey(b)),k(!0)},c.closedDeferred),l(),b&&b.focus?b.focus():d.focus&&d.focus()}function k(a){var b;t.length()>0&&(b=t.top().value,b.modalDomEl.toggleClass(b.windowTopClass||\"\",a))}function l(){if(p&&-1===i()){var a=q;m(p,q,function(){a=null}),p=void 0,q=void 0}}function m(a,c,d,e){function g(){g.done||(g.done=!0,b(a,{event:\"leave\"}).start().then(function(){a.remove(),e&&e.resolve()}),c.$destroy(),d&&d())}var h,i=null,j=function(){return h||(h=f.defer(),i=h.promise),function(){h.resolve()}};return c.$broadcast(v.NOW_CLOSING_EVENT,j),f.when(i).then(g)}function n(a){if(a.isDefaultPrevented())return a;var b=t.top();if(b)switch(a.which){case 27:b.value.keyboard&&(a.preventDefault(),e.$apply(function(){v.dismiss(b.key,\"escape key press\")}));break;case 9:v.loadFocusElementList(b);var c=!1;a.shiftKey?v.isFocusInFirstItem(a)&&(c=v.focusLastFocusableElement()):v.isFocusInLastItem(a)&&(c=v.focusFirstFocusableElement()),c&&(a.preventDefault(),a.stopPropagation())}}function o(a,b,c){return!a.value.modalScope.$broadcast(\"modal.closing\",b,c).defaultPrevented}var p,q,r,s=\"modal-open\",t=h.createNew(),u=g.createNew(),v={NOW_CLOSING_EVENT:\"modal.stack.now-closing\"},w=0,x=\"a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]\";return e.$watch(i,function(a){q&&(q.index=a)}),c.on(\"keydown\",n),e.$on(\"$destroy\",function(){c.off(\"keydown\",n)}),v.open=function(b,f){var g=c[0].activeElement,h=f.openedClass||s;k(!1),t.add(b,{deferred:f.deferred,renderDeferred:f.renderDeferred,closedDeferred:f.closedDeferred,modalScope:f.scope,backdrop:f.backdrop,keyboard:f.keyboard,openedClass:f.openedClass,windowTopClass:f.windowTopClass,animation:f.animation,appendTo:f.appendTo}),u.put(h,b);var j=f.appendTo,l=i();if(!j.length)throw new Error(\"appendTo element not found. Make sure that the element passed is in DOM.\");l>=0&&!p&&(q=e.$new(!0),q.modalOptions=f,q.index=l,p=angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>'),p.attr(\"backdrop-class\",f.backdropClass),f.animation&&p.attr(\"modal-animation\",\"true\"),d(p)(q),a.enter(p,j));var m=angular.element('<div uib-modal-window=\"modal-window\"></div>');m.attr({\"template-url\":f.windowTemplateUrl,\"window-class\":f.windowClass,\"window-top-class\":f.windowTopClass,size:f.size,index:t.length()-1,animate:\"animate\"}).html(f.content),f.animation&&m.attr(\"modal-animation\",\"true\"),a.enter(d(m)(f.scope),j).then(function(){a.addClass(j,h)}),t.top().value.modalDomEl=m,t.top().value.modalOpener=g,v.clearFocusListCache()},v.close=function(a,b){var c=t.get(a);return c&&o(c,b,!0)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.resolve(b),j(a,c.value.modalOpener),!0):!c},v.dismiss=function(a,b){var c=t.get(a);return c&&o(c,b,!1)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.reject(b),j(a,c.value.modalOpener),!0):!c},v.dismissAll=function(a){for(var b=this.getTop();b&&this.dismiss(b.key,a);)b=this.getTop()},v.getTop=function(){return t.top()},v.modalRendered=function(a){var b=t.get(a);b&&b.value.renderDeferred.resolve()},v.focusFirstFocusableElement=function(){return r.length>0?(r[0].focus(),!0):!1},v.focusLastFocusableElement=function(){return r.length>0?(r[r.length-1].focus(),!0):!1},v.isFocusInFirstItem=function(a){return r.length>0?(a.target||a.srcElement)===r[0]:!1},v.isFocusInLastItem=function(a){return r.length>0?(a.target||a.srcElement)===r[r.length-1]:!1},v.clearFocusListCache=function(){r=[],w=0},v.loadFocusElementList=function(a){if((void 0===r||!r.length)&&a){var b=a.value.modalDomEl;b&&b.length&&(r=b[0].querySelectorAll(x))}},v}]).provider(\"$uibModal\",function(){var a={options:{animation:!0,backdrop:!0,keyboard:!0},$get:[\"$rootScope\",\"$q\",\"$document\",\"$templateRequest\",\"$controller\",\"$uibResolve\",\"$uibModalStack\",function(b,c,d,e,f,g,h){function i(a){return a.template?c.when(a.template):e(angular.isFunction(a.templateUrl)?a.templateUrl():a.templateUrl)}var j={},k=null;return j.getPromiseChain=function(){return k},j.open=function(e){function j(){return r}var l=c.defer(),m=c.defer(),n=c.defer(),o=c.defer(),p={result:l.promise,opened:m.promise,closed:n.promise,rendered:o.promise,close:function(a){return h.close(p,a)},dismiss:function(a){return h.dismiss(p,a)}};if(e=angular.extend({},a.options,e),e.resolve=e.resolve||{},e.appendTo=e.appendTo||d.find(\"body\").eq(0),!e.template&&!e.templateUrl)throw new Error(\"One of template or templateUrl options is required.\");var q,r=c.all([i(e),g.resolve(e.resolve,{},null,null)]);return q=k=c.all([k]).then(j,j).then(function(a){var c=e.scope||b,d=c.$new();d.$close=p.close,d.$dismiss=p.dismiss,d.$on(\"$destroy\",function(){d.$$uibDestructionScheduled||d.$dismiss(\"$uibUnscheduledDestruction\")});var g,i={};e.controller&&(i.$scope=d,i.$uibModalInstance=p,angular.forEach(a[1],function(a,b){i[b]=a}),g=f(e.controller,i),e.controllerAs&&(e.bindToController&&(g.$close=d.$close,g.$dismiss=d.$dismiss,angular.extend(g,c)),d[e.controllerAs]=g)),h.open(p,{scope:d,deferred:l,renderDeferred:o,closedDeferred:n,content:a[0],animation:e.animation,backdrop:e.backdrop,keyboard:e.keyboard,backdropClass:e.backdropClass,windowTopClass:e.windowTopClass,windowClass:e.windowClass,windowTemplateUrl:e.windowTemplateUrl,size:e.size,openedClass:e.openedClass,appendTo:e.appendTo}),m.resolve(!0)},function(a){m.reject(a),l.reject(a)})[\"finally\"](function(){k===q&&(k=null)}),p},j}]};return a}),angular.module(\"ui.bootstrap.paging\",[]).factory(\"uibPaging\",[\"$parse\",function(a){return{create:function(b,c,d){b.setNumPages=d.numPages?a(d.numPages).assign:angular.noop,b.ngModelCtrl={$setViewValue:angular.noop},b._watchers=[],b.init=function(e,f){b.ngModelCtrl=e,b.config=f,e.$render=function(){b.render()},d.itemsPerPage?b._watchers.push(c.$parent.$watch(a(d.itemsPerPage),function(a){b.itemsPerPage=parseInt(a,10),c.totalPages=b.calculateTotalPages(),b.updatePage()})):b.itemsPerPage=f.itemsPerPage,c.$watch(\"totalItems\",function(a,d){(angular.isDefined(a)||a!==d)&&(c.totalPages=b.calculateTotalPages(),b.updatePage())})},b.calculateTotalPages=function(){var a=b.itemsPerPage<1?1:Math.ceil(c.totalItems/b.itemsPerPage);return Math.max(a||0,1)},b.render=function(){c.page=parseInt(b.ngModelCtrl.$viewValue,10)||1},c.selectPage=function(a,d){d&&d.preventDefault();var e=!c.ngDisabled||!d;e&&c.page!==a&&a>0&&a<=c.totalPages&&(d&&d.target&&d.target.blur(),b.ngModelCtrl.$setViewValue(a),b.ngModelCtrl.$render())},c.getText=function(a){return c[a+\"Text\"]||b.config[a+\"Text\"]},c.noPrevious=function(){return 1===c.page},c.noNext=function(){return c.page===c.totalPages},b.updatePage=function(){b.setNumPages(c.$parent,c.totalPages),c.page>c.totalPages?c.selectPage(c.totalPages):b.ngModelCtrl.$render()},c.$on(\"$destroy\",function(){for(;b._watchers.length;)b._watchers.shift()()})}}}]),angular.module(\"ui.bootstrap.pager\",[\"ui.bootstrap.paging\"]).controller(\"UibPagerController\",[\"$scope\",\"$attrs\",\"uibPaging\",\"uibPagerConfig\",function(a,b,c,d){a.align=angular.isDefined(b.align)?a.$parent.$eval(b.align):d.align,c.create(this,a,b)}]).constant(\"uibPagerConfig\",{itemsPerPage:10,previousText:\" Previous\",nextText:\"Next \",align:!0}).directive(\"uibPager\",[\"uibPagerConfig\",function(a){return{scope:{totalItems:\"=\",previousText:\"@\",nextText:\"@\",ngDisabled:\"=\"},require:[\"uibPager\",\"?ngModel\"],controller:\"UibPagerController\",controllerAs:\"pager\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/pager/pager.html\"},replace:!0,link:function(b,c,d,e){var f=e[0],g=e[1];g&&f.init(g,a)}}}]),angular.module(\"ui.bootstrap.pagination\",[\"ui.bootstrap.paging\"]).controller(\"UibPaginationController\",[\"$scope\",\"$attrs\",\"$parse\",\"uibPaging\",\"uibPaginationConfig\",function(a,b,c,d,e){function f(a,b,c){return{number:a,text:b,active:c}}function g(a,b){var c=[],d=1,e=b,g=angular.isDefined(i)&&b>i;g&&(j?(d=Math.max(a-Math.floor(i/2),1),e=d+i-1,e>b&&(e=b,d=e-i+1)):(d=(Math.ceil(a/i)-1)*i+1,e=Math.min(d+i-1,b)));for(var h=d;e>=h;h++){var m=f(h,h,h===a);c.push(m)}if(g&&i>0&&(!j||k||l)){if(d>1){if(!l||d>3){var n=f(d-1,\"...\",!1);c.unshift(n)}if(l){if(3===d){var o=f(2,\"2\",!1);c.unshift(o)}var p=f(1,\"1\",!1);c.unshift(p)}}if(b>e){if(!l||b-2>e){var q=f(e+1,\"...\",!1);c.push(q)}if(l){if(e===b-2){var r=f(b-1,b-1,!1);c.push(r)}var s=f(b,b,!1);c.push(s)}}}return c}var h=this,i=angular.isDefined(b.maxSize)?a.$parent.$eval(b.maxSize):e.maxSize,j=angular.isDefined(b.rotate)?a.$parent.$eval(b.rotate):e.rotate,k=angular.isDefined(b.forceEllipses)?a.$parent.$eval(b.forceEllipses):e.forceEllipses,l=angular.isDefined(b.boundaryLinkNumbers)?a.$parent.$eval(b.boundaryLinkNumbers):e.boundaryLinkNumbers;a.boundaryLinks=angular.isDefined(b.boundaryLinks)?a.$parent.$eval(b.boundaryLinks):e.boundaryLinks,a.directionLinks=angular.isDefined(b.directionLinks)?a.$parent.$eval(b.directionLinks):e.directionLinks,d.create(this,a,b),b.maxSize&&h._watchers.push(a.$parent.$watch(c(b.maxSize),function(a){i=parseInt(a,10),h.render()}));var m=this.render;this.render=function(){m(),a.page>0&&a.page<=a.totalPages&&(a.pages=g(a.page,a.totalPages))}}]).constant(\"uibPaginationConfig\",{itemsPerPage:10,boundaryLinks:!1,boundaryLinkNumbers:!1,directionLinks:!0,firstText:\"First\",previousText:\"Previous\",nextText:\"Next\",lastText:\"Last\",rotate:!0,forceEllipses:!1}).directive(\"uibPagination\",[\"$parse\",\"uibPaginationConfig\",function(a,b){return{scope:{totalItems:\"=\",firstText:\"@\",previousText:\"@\",nextText:\"@\",lastText:\"@\",ngDisabled:\"=\"},require:[\"uibPagination\",\"?ngModel\"],controller:\"UibPaginationController\",controllerAs:\"pagination\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/pagination/pagination.html\"},replace:!0,link:function(a,c,d,e){var f=e[0],g=e[1];g&&f.init(g,b)}}}]),angular.module(\"ui.bootstrap.tooltip\",[\"ui.bootstrap.position\",\"ui.bootstrap.stackedMap\"]).provider(\"$uibTooltip\",function(){function a(a){var b=/[A-Z]/g,c=\"-\";return a.replace(b,function(a,b){return(b?c:\"\")+a.toLowerCase()})}var b={placement:\"top\",placementClassPrefix:\"\",animation:!0,popupDelay:0,popupCloseDelay:0,useContentExp:!1},c={mouseenter:\"mouseleave\",click:\"click\",outsideClick:\"outsideClick\",focus:\"blur\",none:\"\"},d={};this.options=function(a){angular.extend(d,a)},this.setTriggers=function(a){angular.extend(c,a)},this.$get=[\"$window\",\"$compile\",\"$timeout\",\"$document\",\"$uibPosition\",\"$interpolate\",\"$rootScope\",\"$parse\",\"$$stackedMap\",function(e,f,g,h,i,j,k,l,m){function n(a){if(27===a.which){var b=o.top();b&&(b.value.close(),o.removeTop(),b=null)}}var o=m.createNew();return h.on(\"keypress\",n),k.$on(\"$destroy\",function(){h.off(\"keypress\",n)}),function(e,k,m,n){function p(a){var b=(a||n.trigger||m).split(\" \"),d=b.map(function(a){return c[a]||a});return{show:b,hide:d}}n=angular.extend({},b,d,n);var q=a(e),r=j.startSymbol(),s=j.endSymbol(),t=\"<div \"+q+'-popup title=\"'+r+\"title\"+s+'\" '+(n.useContentExp?'content-exp=\"contentExp()\" ':'content=\"'+r+\"content\"+s+'\" ')+'placement=\"'+r+\"placement\"+s+'\" popup-class=\"'+r+\"popupClass\"+s+'\" animation=\"animation\" is-open=\"isOpen\"origin-scope=\"origScope\" style=\"visibility: hidden; display: block; top: -9999px; left: -9999px;\"></div>';return{compile:function(a,b){var c=f(t);return function(a,b,d,f){function j(){M.isOpen?q():m()}function m(){(!L||a.$eval(d[k+\"Enable\"]))&&(u(),x(),M.popupDelay?G||(G=g(r,M.popupDelay,!1)):r())}function q(){s(),M.popupCloseDelay?H||(H=g(t,M.popupCloseDelay,!1)):t()}function r(){return s(),u(),M.content?(v(),void M.$evalAsync(function(){M.isOpen=!0,y(!0),R()})):angular.noop}function s(){G&&(g.cancel(G),G=null),I&&(g.cancel(I),I=null)}function t(){M&&M.$evalAsync(function(){M&&(M.isOpen=!1,y(!1),M.animation?F||(F=g(w,150,!1)):w())})}function u(){H&&(g.cancel(H),H=null),F&&(g.cancel(F),F=null)}function v(){D||(E=M.$new(),D=c(E,function(a){J?h.find(\"body\").append(a):b.after(a)}),z())}function w(){s(),u(),A(),D&&(D.remove(),D=null),E&&(E.$destroy(),E=null)}function x(){M.title=d[k+\"Title\"],P?M.content=P(a):M.content=d[e],M.popupClass=d[k+\"Class\"],M.placement=angular.isDefined(d[k+\"Placement\"])?d[k+\"Placement\"]:n.placement;var b=parseInt(d[k+\"PopupDelay\"],10),c=parseInt(d[k+\"PopupCloseDelay\"],10);M.popupDelay=isNaN(b)?n.popupDelay:b,M.popupCloseDelay=isNaN(c)?n.popupCloseDelay:c}function y(b){O&&angular.isFunction(O.assign)&&O.assign(a,b)}function z(){Q.length=0,P?(Q.push(a.$watch(P,function(a){M.content=a,!a&&M.isOpen&&t()})),Q.push(E.$watch(function(){N||(N=!0,E.$$postDigest(function(){N=!1,M&&M.isOpen&&R()}))}))):Q.push(d.$observe(e,function(a){M.content=a,!a&&M.isOpen?t():R()})),Q.push(d.$observe(k+\"Title\",function(a){M.title=a,M.isOpen&&R()})),Q.push(d.$observe(k+\"Placement\",function(a){M.placement=a?a:n.placement,M.isOpen&&R()}))}function A(){Q.length&&(angular.forEach(Q,function(a){a()}),Q.length=0)}function B(a){M&&M.isOpen&&D&&(b[0].contains(a.target)||D[0].contains(a.target)||q())}function C(){var a=d[k+\"Trigger\"];S(),K=p(a),\"none\"!==K.show&&K.show.forEach(function(a,c){\"outsideClick\"===a?(b.on(\"click\",j),h.on(\"click\",B)):a===K.hide[c]?b.on(a,j):a&&(b.on(a,m),b.on(K.hide[c],q)),b.on(\"keypress\",function(a){27===a.which&&q()})})}var D,E,F,G,H,I,J=angular.isDefined(n.appendToBody)?n.appendToBody:!1,K=p(void 0),L=angular.isDefined(d[k+\"Enable\"]),M=a.$new(!0),N=!1,O=angular.isDefined(d[k+\"IsOpen\"])?l(d[k+\"IsOpen\"]):!1,P=n.useContentExp?l(d[e]):!1,Q=[],R=function(){D&&D.html()&&(I||(I=g(function(){D.css({top:0,left:0});var a=i.positionElements(b,D,M.placement,J);D.css({top:a.top+\"px\",left:a.left+\"px\",visibility:\"visible\"}),n.placementClassPrefix&&D.removeClass(\"top bottom left right\"),D.removeClass(n.placementClassPrefix+\"top \"+n.placementClassPrefix+\"top-left \"+n.placementClassPrefix+\"top-right \"+n.placementClassPrefix+\"bottom \"+n.placementClassPrefix+\"bottom-left \"+n.placementClassPrefix+\"bottom-right \"+n.placementClassPrefix+\"left \"+n.placementClassPrefix+\"left-top \"+n.placementClassPrefix+\"left-bottom \"+n.placementClassPrefix+\"right \"+n.placementClassPrefix+\"right-top \"+n.placementClassPrefix+\"right-bottom\");var c=a.placement.split(\"-\");D.addClass(c[0]+\" \"+n.placementClassPrefix+a.placement),i.positionArrow(D,a.placement),I=null},0,!1)))};M.origScope=a,M.isOpen=!1,o.add(M,{close:t}),M.contentExp=function(){return M.content},d.$observe(\"disabled\",function(a){a&&s(),a&&M.isOpen&&t()}),O&&a.$watch(O,function(a){M&&!a===M.isOpen&&j()});var S=function(){K.show.forEach(function(a){\"outsideClick\"===a?b.off(\"click\",j):(b.off(a,m),b.off(a,j))}),K.hide.forEach(function(a){\"outsideClick\"===a?h.off(\"click\",B):b.off(a,q)})};C();var T=a.$eval(d[k+\"Animation\"]);M.animation=angular.isDefined(T)?!!T:n.animation;var U,V=k+\"AppendToBody\";U=V in d&&void 0===d[V]?!0:a.$eval(d[V]),J=angular.isDefined(U)?U:J,J&&a.$on(\"$locationChangeSuccess\",function(){M.isOpen&&t()}),a.$on(\"$destroy\",function(){S(),w(),o.remove(M),M=null})}}}}}]}).directive(\"uibTooltipTemplateTransclude\",[\"$animate\",\"$sce\",\"$compile\",\"$templateRequest\",function(a,b,c,d){return{link:function(e,f,g){var h,i,j,k=e.$eval(g.tooltipTemplateTranscludeScope),l=0,m=function(){i&&(i.remove(),i=null),h&&(h.$destroy(),h=null),j&&(a.leave(j).then(function(){i=null}),i=j,j=null)};e.$watch(b.parseAsResourceUrl(g.uibTooltipTemplateTransclude),function(b){var g=++l;b?(d(b,!0).then(function(d){if(g===l){var e=k.$new(),i=d,n=c(i)(e,function(b){m(),a.enter(b,f)});h=e,j=n,h.$emit(\"$includeContentLoaded\",b)}},function(){g===l&&(m(),e.$emit(\"$includeContentError\",b))}),e.$emit(\"$includeContentRequested\",b)):m()}),e.$on(\"$destroy\",m)}}}]).directive(\"uibTooltipClasses\",[\"$uibPosition\",function(a){return{restrict:\"A\",link:function(b,c,d){if(b.placement){var e=a.parsePlacement(b.placement);c.addClass(e[0])}else c.addClass(\"top\");b.popupClass&&c.addClass(b.popupClass),b.animation()&&c.addClass(d.tooltipAnimationClass)}}}]).directive(\"uibTooltipPopup\",function(){return{replace:!0,scope:{content:\"@\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"\n},templateUrl:\"uib/template/tooltip/tooltip-popup.html\"}}).directive(\"uibTooltip\",[\"$uibTooltip\",function(a){return a(\"uibTooltip\",\"tooltip\",\"mouseenter\")}]).directive(\"uibTooltipTemplatePopup\",function(){return{replace:!0,scope:{contentExp:\"&\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\",originScope:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-template-popup.html\"}}).directive(\"uibTooltipTemplate\",[\"$uibTooltip\",function(a){return a(\"uibTooltipTemplate\",\"tooltip\",\"mouseenter\",{useContentExp:!0})}]).directive(\"uibTooltipHtmlPopup\",function(){return{replace:!0,scope:{contentExp:\"&\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-html-popup.html\"}}).directive(\"uibTooltipHtml\",[\"$uibTooltip\",function(a){return a(\"uibTooltipHtml\",\"tooltip\",\"mouseenter\",{useContentExp:!0})}]),angular.module(\"ui.bootstrap.popover\",[\"ui.bootstrap.tooltip\"]).directive(\"uibPopoverTemplatePopup\",function(){return{replace:!0,scope:{title:\"@\",contentExp:\"&\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\",originScope:\"&\"},templateUrl:\"uib/template/popover/popover-template.html\"}}).directive(\"uibPopoverTemplate\",[\"$uibTooltip\",function(a){return a(\"uibPopoverTemplate\",\"popover\",\"click\",{useContentExp:!0})}]).directive(\"uibPopoverHtmlPopup\",function(){return{replace:!0,scope:{contentExp:\"&\",title:\"@\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/popover/popover-html.html\"}}).directive(\"uibPopoverHtml\",[\"$uibTooltip\",function(a){return a(\"uibPopoverHtml\",\"popover\",\"click\",{useContentExp:!0})}]).directive(\"uibPopoverPopup\",function(){return{replace:!0,scope:{title:\"@\",content:\"@\",placement:\"@\",popupClass:\"@\",animation:\"&\",isOpen:\"&\"},templateUrl:\"uib/template/popover/popover.html\"}}).directive(\"uibPopover\",[\"$uibTooltip\",function(a){return a(\"uibPopover\",\"popover\",\"click\")}]),angular.module(\"ui.bootstrap.progressbar\",[]).constant(\"uibProgressConfig\",{animate:!0,max:100}).controller(\"UibProgressController\",[\"$scope\",\"$attrs\",\"uibProgressConfig\",function(a,b,c){var d=this,e=angular.isDefined(b.animate)?a.$parent.$eval(b.animate):c.animate;this.bars=[],a.max=angular.isDefined(a.max)?a.max:c.max,this.addBar=function(b,c,f){e||c.css({transition:\"none\"}),this.bars.push(b),b.max=a.max,b.title=f&&angular.isDefined(f.title)?f.title:\"progressbar\",b.$watch(\"value\",function(a){b.recalculatePercentage()}),b.recalculatePercentage=function(){var a=d.bars.reduce(function(a,b){return b.percent=+(100*b.value/b.max).toFixed(2),a+b.percent},0);a>100&&(b.percent-=a-100)},b.$on(\"$destroy\",function(){c=null,d.removeBar(b)})},this.removeBar=function(a){this.bars.splice(this.bars.indexOf(a),1),this.bars.forEach(function(a){a.recalculatePercentage()})},a.$watch(\"max\",function(b){d.bars.forEach(function(b){b.max=a.max,b.recalculatePercentage()})})}]).directive(\"uibProgress\",function(){return{replace:!0,transclude:!0,controller:\"UibProgressController\",require:\"uibProgress\",scope:{max:\"=?\"},templateUrl:\"uib/template/progressbar/progress.html\"}}).directive(\"uibBar\",function(){return{replace:!0,transclude:!0,require:\"^uibProgress\",scope:{value:\"=\",type:\"@\"},templateUrl:\"uib/template/progressbar/bar.html\",link:function(a,b,c,d){d.addBar(a,b,c)}}}).directive(\"uibProgressbar\",function(){return{replace:!0,transclude:!0,controller:\"UibProgressController\",scope:{value:\"=\",max:\"=?\",type:\"@\"},templateUrl:\"uib/template/progressbar/progressbar.html\",link:function(a,b,c,d){d.addBar(a,angular.element(b.children()[0]),{title:c.title})}}}),angular.module(\"ui.bootstrap.rating\",[]).constant(\"uibRatingConfig\",{max:5,stateOn:null,stateOff:null,titles:[\"one\",\"two\",\"three\",\"four\",\"five\"]}).controller(\"UibRatingController\",[\"$scope\",\"$attrs\",\"uibRatingConfig\",function(a,b,c){var d={$setViewValue:angular.noop};this.init=function(e){d=e,d.$render=this.render,d.$formatters.push(function(a){return angular.isNumber(a)&&a<<0!==a&&(a=Math.round(a)),a}),this.stateOn=angular.isDefined(b.stateOn)?a.$parent.$eval(b.stateOn):c.stateOn,this.stateOff=angular.isDefined(b.stateOff)?a.$parent.$eval(b.stateOff):c.stateOff;var f=angular.isDefined(b.titles)?a.$parent.$eval(b.titles):c.titles;this.titles=angular.isArray(f)&&f.length>0?f:c.titles;var g=angular.isDefined(b.ratingStates)?a.$parent.$eval(b.ratingStates):new Array(angular.isDefined(b.max)?a.$parent.$eval(b.max):c.max);a.range=this.buildTemplateObjects(g)},this.buildTemplateObjects=function(a){for(var b=0,c=a.length;c>b;b++)a[b]=angular.extend({index:b},{stateOn:this.stateOn,stateOff:this.stateOff,title:this.getTitle(b)},a[b]);return a},this.getTitle=function(a){return a>=this.titles.length?a+1:this.titles[a]},a.rate=function(b){!a.readonly&&b>=0&&b<=a.range.length&&(d.$setViewValue(d.$viewValue===b?0:b),d.$render())},a.enter=function(b){a.readonly||(a.value=b),a.onHover({value:b})},a.reset=function(){a.value=d.$viewValue,a.onLeave()},a.onKeydown=function(b){/(37|38|39|40)/.test(b.which)&&(b.preventDefault(),b.stopPropagation(),a.rate(a.value+(38===b.which||39===b.which?1:-1)))},this.render=function(){a.value=d.$viewValue}}]).directive(\"uibRating\",function(){return{require:[\"uibRating\",\"ngModel\"],scope:{readonly:\"=?\",onHover:\"&\",onLeave:\"&\"},controller:\"UibRatingController\",templateUrl:\"uib/template/rating/rating.html\",replace:!0,link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}),angular.module(\"ui.bootstrap.tabs\",[]).controller(\"UibTabsetController\",[\"$scope\",function(a){var b=this,c=b.tabs=a.tabs=[];b.select=function(a){angular.forEach(c,function(b){b.active&&b!==a&&(b.active=!1,b.onDeselect(),a.selectCalled=!1)}),a.active=!0,a.selectCalled||(a.onSelect(),a.selectCalled=!0)},b.addTab=function(a){c.push(a),1===c.length&&a.active!==!1?a.active=!0:a.active?b.select(a):a.active=!1},b.removeTab=function(a){var e=c.indexOf(a);if(a.active&&c.length>1&&!d){var f=e===c.length-1?e-1:e+1;b.select(c[f])}c.splice(e,1)};var d;a.$on(\"$destroy\",function(){d=!0})}]).directive(\"uibTabset\",function(){return{transclude:!0,replace:!0,scope:{type:\"@\"},controller:\"UibTabsetController\",templateUrl:\"uib/template/tabs/tabset.html\",link:function(a,b,c){a.vertical=angular.isDefined(c.vertical)?a.$parent.$eval(c.vertical):!1,a.justified=angular.isDefined(c.justified)?a.$parent.$eval(c.justified):!1}}}).directive(\"uibTab\",[\"$parse\",function(a){return{require:\"^uibTabset\",replace:!0,templateUrl:\"uib/template/tabs/tab.html\",transclude:!0,scope:{active:\"=?\",heading:\"@\",onSelect:\"&select\",onDeselect:\"&deselect\"},controller:function(){},controllerAs:\"tab\",link:function(b,c,d,e,f){b.$watch(\"active\",function(a){a&&e.select(b)}),b.disabled=!1,d.disable&&b.$parent.$watch(a(d.disable),function(a){b.disabled=!!a}),b.select=function(){b.disabled||(b.active=!0)},e.addTab(b),b.$on(\"$destroy\",function(){e.removeTab(b)}),b.$transcludeFn=f}}}]).directive(\"uibTabHeadingTransclude\",function(){return{restrict:\"A\",require:\"^uibTab\",link:function(a,b){a.$watch(\"headingElement\",function(a){a&&(b.html(\"\"),b.append(a))})}}}).directive(\"uibTabContentTransclude\",function(){function a(a){return a.tagName&&(a.hasAttribute(\"uib-tab-heading\")||a.hasAttribute(\"data-uib-tab-heading\")||a.hasAttribute(\"x-uib-tab-heading\")||\"uib-tab-heading\"===a.tagName.toLowerCase()||\"data-uib-tab-heading\"===a.tagName.toLowerCase()||\"x-uib-tab-heading\"===a.tagName.toLowerCase())}return{restrict:\"A\",require:\"^uibTabset\",link:function(b,c,d){var e=b.$eval(d.uibTabContentTransclude);e.$transcludeFn(e.$parent,function(b){angular.forEach(b,function(b){a(b)?e.headingElement=b:c.append(b)})})}}}),angular.module(\"ui.bootstrap.timepicker\",[]).constant(\"uibTimepickerConfig\",{hourStep:1,minuteStep:1,secondStep:1,showMeridian:!0,showSeconds:!1,meridians:null,readonlyInput:!1,mousewheel:!0,arrowkeys:!0,showSpinners:!0,templateUrl:\"uib/template/timepicker/timepicker.html\"}).controller(\"UibTimepickerController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"$log\",\"$locale\",\"uibTimepickerConfig\",function(a,b,c,d,e,f,g){function h(){var b=+a.hours,c=a.showMeridian?b>0&&13>b:b>=0&&24>b;return c?(a.showMeridian&&(12===b&&(b=0),a.meridian===u[1]&&(b+=12)),b):void 0}function i(){var b=+a.minutes;return b>=0&&60>b?b:void 0}function j(){var b=+a.seconds;return b>=0&&60>b?b:void 0}function k(a){return null===a?\"\":angular.isDefined(a)&&a.toString().length<2?\"0\"+a:a.toString()}function l(a){m(),t.$setViewValue(new Date(r)),n(a)}function m(){t.$setValidity(\"time\",!0),a.invalidHours=!1,a.invalidMinutes=!1,a.invalidSeconds=!1}function n(b){if(t.$modelValue){var c=r.getHours(),d=r.getMinutes(),e=r.getSeconds();a.showMeridian&&(c=0===c||12===c?12:c%12),a.hours=\"h\"===b?c:k(c),\"m\"!==b&&(a.minutes=k(d)),a.meridian=r.getHours()<12?u[0]:u[1],\"s\"!==b&&(a.seconds=k(e)),a.meridian=r.getHours()<12?u[0]:u[1]}else a.hours=null,a.minutes=null,a.seconds=null,a.meridian=u[0]}function o(a){r=q(r,a),l()}function p(a,b){return q(a,60*b)}function q(a,b){var c=new Date(a.getTime()+1e3*b),d=new Date(a);return d.setHours(c.getHours(),c.getMinutes(),c.getSeconds()),d}var r=new Date,s=[],t={$setViewValue:angular.noop},u=angular.isDefined(c.meridians)?a.$parent.$eval(c.meridians):g.meridians||f.DATETIME_FORMATS.AMPMS;a.tabindex=angular.isDefined(c.tabindex)?c.tabindex:0,b.removeAttr(\"tabindex\"),this.init=function(b,d){t=b,t.$render=this.render,t.$formatters.unshift(function(a){return a?new Date(a):null});var e=d.eq(0),f=d.eq(1),h=d.eq(2),i=angular.isDefined(c.mousewheel)?a.$parent.$eval(c.mousewheel):g.mousewheel;i&&this.setupMousewheelEvents(e,f,h);var j=angular.isDefined(c.arrowkeys)?a.$parent.$eval(c.arrowkeys):g.arrowkeys;j&&this.setupArrowkeyEvents(e,f,h),a.readonlyInput=angular.isDefined(c.readonlyInput)?a.$parent.$eval(c.readonlyInput):g.readonlyInput,this.setupInputEvents(e,f,h)};var v=g.hourStep;c.hourStep&&s.push(a.$parent.$watch(d(c.hourStep),function(a){v=+a}));var w=g.minuteStep;c.minuteStep&&s.push(a.$parent.$watch(d(c.minuteStep),function(a){w=+a}));var x;s.push(a.$parent.$watch(d(c.min),function(a){var b=new Date(a);x=isNaN(b)?void 0:b}));var y;s.push(a.$parent.$watch(d(c.max),function(a){var b=new Date(a);y=isNaN(b)?void 0:b}));var z=!1;c.ngDisabled&&s.push(a.$parent.$watch(d(c.ngDisabled),function(a){z=a})),a.noIncrementHours=function(){var a=p(r,60*v);return z||a>y||r>a&&x>a},a.noDecrementHours=function(){var a=p(r,60*-v);return z||x>a||a>r&&a>y},a.noIncrementMinutes=function(){var a=p(r,w);return z||a>y||r>a&&x>a},a.noDecrementMinutes=function(){var a=p(r,-w);return z||x>a||a>r&&a>y},a.noIncrementSeconds=function(){var a=q(r,A);return z||a>y||r>a&&x>a},a.noDecrementSeconds=function(){var a=q(r,-A);return z||x>a||a>r&&a>y},a.noToggleMeridian=function(){return r.getHours()<12?z||p(r,720)>y:z||p(r,-720)<x};var A=g.secondStep;c.secondStep&&s.push(a.$parent.$watch(d(c.secondStep),function(a){A=+a})),a.showSeconds=g.showSeconds,c.showSeconds&&s.push(a.$parent.$watch(d(c.showSeconds),function(b){a.showSeconds=!!b})),a.showMeridian=g.showMeridian,c.showMeridian&&s.push(a.$parent.$watch(d(c.showMeridian),function(b){if(a.showMeridian=!!b,t.$error.time){var c=h(),d=i();angular.isDefined(c)&&angular.isDefined(d)&&(r.setHours(c),l())}else n()})),this.setupMousewheelEvents=function(b,c,d){var e=function(a){a.originalEvent&&(a=a.originalEvent);var b=a.wheelDelta?a.wheelDelta:-a.deltaY;return a.detail||b>0};b.bind(\"mousewheel wheel\",function(b){z||a.$apply(e(b)?a.incrementHours():a.decrementHours()),b.preventDefault()}),c.bind(\"mousewheel wheel\",function(b){z||a.$apply(e(b)?a.incrementMinutes():a.decrementMinutes()),b.preventDefault()}),d.bind(\"mousewheel wheel\",function(b){z||a.$apply(e(b)?a.incrementSeconds():a.decrementSeconds()),b.preventDefault()})},this.setupArrowkeyEvents=function(b,c,d){b.bind(\"keydown\",function(b){z||(38===b.which?(b.preventDefault(),a.incrementHours(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementHours(),a.$apply()))}),c.bind(\"keydown\",function(b){z||(38===b.which?(b.preventDefault(),a.incrementMinutes(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementMinutes(),a.$apply()))}),d.bind(\"keydown\",function(b){z||(38===b.which?(b.preventDefault(),a.incrementSeconds(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementSeconds(),a.$apply()))})},this.setupInputEvents=function(b,c,d){if(a.readonlyInput)return a.updateHours=angular.noop,a.updateMinutes=angular.noop,void(a.updateSeconds=angular.noop);var e=function(b,c,d){t.$setViewValue(null),t.$setValidity(\"time\",!1),angular.isDefined(b)&&(a.invalidHours=b),angular.isDefined(c)&&(a.invalidMinutes=c),angular.isDefined(d)&&(a.invalidSeconds=d)};a.updateHours=function(){var a=h(),b=i();t.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(r.setHours(a),r.setMinutes(b),x>r||r>y?e(!0):l(\"h\")):e(!0)},b.bind(\"blur\",function(b){t.$setTouched(),null===a.hours||\"\"===a.hours?e(!0):!a.invalidHours&&a.hours<10&&a.$apply(function(){a.hours=k(a.hours)})}),a.updateMinutes=function(){var a=i(),b=h();t.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(r.setHours(b),r.setMinutes(a),x>r||r>y?e(void 0,!0):l(\"m\")):e(void 0,!0)},c.bind(\"blur\",function(b){t.$setTouched(),null===a.minutes?e(void 0,!0):!a.invalidMinutes&&a.minutes<10&&a.$apply(function(){a.minutes=k(a.minutes)})}),a.updateSeconds=function(){var a=j();t.$setDirty(),angular.isDefined(a)?(r.setSeconds(a),l(\"s\")):e(void 0,void 0,!0)},d.bind(\"blur\",function(b){!a.invalidSeconds&&a.seconds<10&&a.$apply(function(){a.seconds=k(a.seconds)})})},this.render=function(){var b=t.$viewValue;isNaN(b)?(t.$setValidity(\"time\",!1),e.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')):(b&&(r=b),x>r||r>y?(t.$setValidity(\"time\",!1),a.invalidHours=!0,a.invalidMinutes=!0):m(),n())},a.showSpinners=angular.isDefined(c.showSpinners)?a.$parent.$eval(c.showSpinners):g.showSpinners,a.incrementHours=function(){a.noIncrementHours()||o(60*v*60)},a.decrementHours=function(){a.noDecrementHours()||o(60*-v*60)},a.incrementMinutes=function(){a.noIncrementMinutes()||o(60*w)},a.decrementMinutes=function(){a.noDecrementMinutes()||o(60*-w)},a.incrementSeconds=function(){a.noIncrementSeconds()||o(A)},a.decrementSeconds=function(){a.noDecrementSeconds()||o(-A)},a.toggleMeridian=function(){var b=i(),c=h();a.noToggleMeridian()||(angular.isDefined(b)&&angular.isDefined(c)?o(720*(r.getHours()<12?60:-60)):a.meridian=a.meridian===u[0]?u[1]:u[0])},a.blur=function(){t.$setTouched()},a.$on(\"$destroy\",function(){for(;s.length;)s.shift()()})}]).directive(\"uibTimepicker\",[\"uibTimepickerConfig\",function(a){return{require:[\"uibTimepicker\",\"?^ngModel\"],controller:\"UibTimepickerController\",controllerAs:\"timepicker\",replace:!0,scope:{},templateUrl:function(b,c){return c.templateUrl||a.templateUrl},link:function(a,b,c,d){var e=d[0],f=d[1];f&&e.init(f,b.find(\"input\"))}}}]),angular.module(\"ui.bootstrap.typeahead\",[\"ui.bootstrap.debounce\",\"ui.bootstrap.position\"]).factory(\"uibTypeaheadParser\",[\"$parse\",function(a){var b=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;return{parse:function(c){var d=c.match(b);if(!d)throw new Error('Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\" but got \"'+c+'\".');return{itemName:d[3],source:a(d[4]),viewMapper:a(d[2]||d[1]),modelMapper:a(d[1])}}}}]).controller(\"UibTypeaheadController\",[\"$scope\",\"$element\",\"$attrs\",\"$compile\",\"$parse\",\"$q\",\"$timeout\",\"$document\",\"$window\",\"$rootScope\",\"$$debounce\",\"$uibPosition\",\"uibTypeaheadParser\",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(){N.moveInProgress||(N.moveInProgress=!0,N.$digest()),Y()}function o(){N.position=D?l.offset(b):l.position(b),N.position.top+=b.prop(\"offsetHeight\")}var p,q,r=[9,13,27,38,40],s=200,t=a.$eval(c.typeaheadMinLength);t||0===t||(t=1);var u=a.$eval(c.typeaheadWaitMs)||0,v=a.$eval(c.typeaheadEditable)!==!1;a.$watch(c.typeaheadEditable,function(a){v=a!==!1});var w,x,y=e(c.typeaheadLoading).assign||angular.noop,z=e(c.typeaheadOnSelect),A=angular.isDefined(c.typeaheadSelectOnBlur)?a.$eval(c.typeaheadSelectOnBlur):!1,B=e(c.typeaheadNoResults).assign||angular.noop,C=c.typeaheadInputFormatter?e(c.typeaheadInputFormatter):void 0,D=c.typeaheadAppendToBody?a.$eval(c.typeaheadAppendToBody):!1,E=c.typeaheadAppendTo?a.$eval(c.typeaheadAppendTo):null,F=a.$eval(c.typeaheadFocusFirst)!==!1,G=c.typeaheadSelectOnExact?a.$eval(c.typeaheadSelectOnExact):!1,H=e(c.typeaheadIsOpen).assign||angular.noop,I=a.$eval(c.typeaheadShowHint)||!1,J=e(c.ngModel),K=e(c.ngModel+\"($$$p)\"),L=function(b,c){return angular.isFunction(J(a))&&q&&q.$options&&q.$options.getterSetter?K(b,{$$$p:c}):J.assign(b,c)},M=m.parse(c.uibTypeahead),N=a.$new(),O=a.$on(\"$destroy\",function(){N.$destroy()});N.$on(\"$destroy\",O);var P=\"typeahead-\"+N.$id+\"-\"+Math.floor(1e4*Math.random());b.attr({\"aria-autocomplete\":\"list\",\"aria-expanded\":!1,\"aria-owns\":P});var Q,R;I&&(Q=angular.element(\"<div></div>\"),Q.css(\"position\",\"relative\"),b.after(Q),R=b.clone(),R.attr(\"placeholder\",\"\"),R.val(\"\"),R.css({position:\"absolute\",top:\"0px\",left:\"0px\",\"border-color\":\"transparent\",\"box-shadow\":\"none\",opacity:1,background:\"none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)\",color:\"#999\"}),b.css({position:\"relative\",\"vertical-align\":\"top\",\"background-color\":\"transparent\"}),Q.append(R),R.after(b));var S=angular.element(\"<div uib-typeahead-popup></div>\");S.attr({id:P,matches:\"matches\",active:\"activeIdx\",select:\"select(activeIdx, evt)\",\"move-in-progress\":\"moveInProgress\",query:\"query\",position:\"position\",\"assign-is-open\":\"assignIsOpen(isOpen)\",debounce:\"debounceUpdate\"}),angular.isDefined(c.typeaheadTemplateUrl)&&S.attr(\"template-url\",c.typeaheadTemplateUrl),angular.isDefined(c.typeaheadPopupTemplateUrl)&&S.attr(\"popup-template-url\",c.typeaheadPopupTemplateUrl);var T=function(){I&&R.val(\"\")},U=function(){N.matches=[],N.activeIdx=-1,b.attr(\"aria-expanded\",!1),T()},V=function(a){return P+\"-option-\"+a};N.$watch(\"activeIdx\",function(a){0>a?b.removeAttr(\"aria-activedescendant\"):b.attr(\"aria-activedescendant\",V(a))});var W=function(a,b){return N.matches.length>b&&a?a.toUpperCase()===N.matches[b].label.toUpperCase():!1},X=function(c,d){var e={$viewValue:c};y(a,!0),B(a,!1),f.when(M.source(a,e)).then(function(f){var g=c===p.$viewValue;if(g&&w)if(f&&f.length>0){N.activeIdx=F?0:-1,B(a,!1),N.matches.length=0;for(var h=0;h<f.length;h++)e[M.itemName]=f[h],N.matches.push({id:V(h),label:M.viewMapper(N,e),model:f[h]});if(N.query=c,o(),b.attr(\"aria-expanded\",!0),G&&1===N.matches.length&&W(c,0)&&(angular.isNumber(N.debounceUpdate)||angular.isObject(N.debounceUpdate)?k(function(){N.select(0,d)},angular.isNumber(N.debounceUpdate)?N.debounceUpdate:N.debounceUpdate[\"default\"]):N.select(0,d)),I){var i=N.matches[0].label;c.length>0&&i.slice(0,c.length).toUpperCase()===c.toUpperCase()?R.val(c+i.slice(c.length)):R.val(\"\")}}else U(),B(a,!0);g&&y(a,!1)},function(){U(),y(a,!1),B(a,!0)})};D&&(angular.element(i).on(\"resize\",n),h.find(\"body\").on(\"scroll\",n));var Y=k(function(){N.matches.length&&o(),N.moveInProgress=!1},s);N.moveInProgress=!1,N.query=void 0;var Z,$=function(a){Z=g(function(){X(a)},u)},_=function(){Z&&g.cancel(Z)};U(),N.assignIsOpen=function(b){H(a,b)},N.select=function(d,e){var f,h,i={};x=!0,i[M.itemName]=h=N.matches[d].model,f=M.modelMapper(a,i),L(a,f),p.$setValidity(\"editable\",!0),p.$setValidity(\"parse\",!0),z(a,{$item:h,$model:f,$label:M.viewMapper(a,i),$event:e}),U(),N.$eval(c.typeaheadFocusOnSelect)!==!1&&g(function(){b[0].focus()},0,!1)},b.on(\"keydown\",function(a){if(0!==N.matches.length&&-1!==r.indexOf(a.which)){if(-1===N.activeIdx&&(9===a.which||13===a.which))return U(),void N.$digest();a.preventDefault();var b;switch(a.which){case 9:case 13:N.$apply(function(){angular.isNumber(N.debounceUpdate)||angular.isObject(N.debounceUpdate)?k(function(){N.select(N.activeIdx,a)},angular.isNumber(N.debounceUpdate)?N.debounceUpdate:N.debounceUpdate[\"default\"]):N.select(N.activeIdx,a)});break;case 27:a.stopPropagation(),U(),N.$digest();break;case 38:N.activeIdx=(N.activeIdx>0?N.activeIdx:N.matches.length)-1,N.$digest(),b=S.find(\"li\")[N.activeIdx],b.parentNode.scrollTop=b.offsetTop;break;case 40:N.activeIdx=(N.activeIdx+1)%N.matches.length,N.$digest(),b=S.find(\"li\")[N.activeIdx],b.parentNode.scrollTop=b.offsetTop}}}),b.bind(\"focus\",function(a){w=!0,0!==t||p.$viewValue||g(function(){X(p.$viewValue,a)},0)}),b.bind(\"blur\",function(a){A&&N.matches.length&&-1!==N.activeIdx&&!x&&(x=!0,N.$apply(function(){angular.isObject(N.debounceUpdate)&&angular.isNumber(N.debounceUpdate.blur)?k(function(){N.select(N.activeIdx,a)},N.debounceUpdate.blur):N.select(N.activeIdx,a)})),!v&&p.$error.editable&&(p.$viewValue=\"\",b.val(\"\")),w=!1,x=!1});var aa=function(a){b[0]!==a.target&&3!==a.which&&0!==N.matches.length&&(U(),j.$$phase||N.$digest())};h.on(\"click\",aa),a.$on(\"$destroy\",function(){h.off(\"click\",aa),(D||E)&&ba.remove(),D&&(angular.element(i).off(\"resize\",n),h.find(\"body\").off(\"scroll\",n)),S.remove(),I&&Q.remove()});var ba=d(S)(N);D?h.find(\"body\").append(ba):E?angular.element(E).eq(0).append(ba):b.after(ba),this.init=function(b,c){p=b,q=c,N.debounceUpdate=p.$options&&e(p.$options.debounce)(a),p.$parsers.unshift(function(b){return w=!0,0===t||b&&b.length>=t?u>0?(_(),$(b)):X(b):(y(a,!1),_(),U()),v?b:b?void p.$setValidity(\"editable\",!1):(p.$setValidity(\"editable\",!0),null)}),p.$formatters.push(function(b){var c,d,e={};return v||p.$setValidity(\"editable\",!0),C?(e.$model=b,C(a,e)):(e[M.itemName]=b,c=M.viewMapper(a,e),e[M.itemName]=void 0,d=M.viewMapper(a,e),c!==d?c:b)})}}]).directive(\"uibTypeahead\",function(){return{controller:\"UibTypeaheadController\",require:[\"ngModel\",\"^?ngModelOptions\",\"uibTypeahead\"],link:function(a,b,c,d){d[2].init(d[0],d[1])}}}).directive(\"uibTypeaheadPopup\",[\"$$debounce\",function(a){return{scope:{matches:\"=\",query:\"=\",active:\"=\",position:\"&\",moveInProgress:\"=\",select:\"&\",assignIsOpen:\"&\",debounce:\"&\"},replace:!0,templateUrl:function(a,b){return b.popupTemplateUrl||\"uib/template/typeahead/typeahead-popup.html\"},link:function(b,c,d){b.templateUrl=d.templateUrl,b.isOpen=function(){var a=b.matches.length>0;return b.assignIsOpen({isOpen:a}),a},b.isActive=function(a){return b.active===a},b.selectActive=function(a){b.active=a},b.selectMatch=function(c,d){var e=b.debounce();angular.isNumber(e)||angular.isObject(e)?a(function(){b.select({activeIdx:c,evt:d})},angular.isNumber(e)?e:e[\"default\"]):b.select({activeIdx:c,evt:d})}}}}]).directive(\"uibTypeaheadMatch\",[\"$templateRequest\",\"$compile\",\"$parse\",function(a,b,c){return{scope:{index:\"=\",match:\"=\",query:\"=\"},link:function(d,e,f){var g=c(f.templateUrl)(d.$parent)||\"uib/template/typeahead/typeahead-match.html\";a(g).then(function(a){var c=angular.element(a.trim());e.replaceWith(c),b(c)(d)})}}}]).filter(\"uibTypeaheadHighlight\",[\"$sce\",\"$injector\",\"$log\",function(a,b,c){function d(a){return a.replace(/([.?*+^$[\\]\\\\(){}|-])/g,\"\\\\$1\")}function e(a){return/<.*>/g.test(a)}var f;return f=b.has(\"$sanitize\"),function(b,g){return!f&&e(b)&&c.warn(\"Unsafe use of typeahead please use ngSanitize\"),b=g?(\"\"+b).replace(new RegExp(d(g),\"gi\"),\"<strong>$&</strong>\"):b,f||(b=a.trustAsHtml(b)),b}}]),angular.module(\"uib/template/accordion/accordion-group.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/accordion/accordion-group.html\",'<div class=\"panel\" ng-class=\"panelClass || \\'panel-default\\'\">\\n  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\\n    <h4 class=\"panel-title\">\\n      <a href tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span ng-class=\"{\\'text-muted\\': isDisabled}\">{{heading}}</span></a>\\n    </h4>\\n  </div>\\n  <div class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\\n\t  <div class=\"panel-body\" ng-transclude></div>\\n  </div>\\n</div>\\n')}]),angular.module(\"uib/template/accordion/accordion.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/accordion/accordion.html\",'<div class=\"panel-group\" ng-transclude></div>')}]),angular.module(\"uib/template/alert/alert.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/alert/alert.html\",'<div class=\"alert\" ng-class=\"[\\'alert-\\' + (type || \\'warning\\'), closeable ? \\'alert-dismissible\\' : null]\" role=\"alert\">\\n    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\\n        <span aria-hidden=\"true\">&times;</span>\\n        <span class=\"sr-only\">Close</span>\\n    </button>\\n    <div ng-transclude></div>\\n</div>\\n')}]),angular.module(\"uib/template/carousel/carousel.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/carousel/carousel.html\",'<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\\n  <div class=\"carousel-inner\" ng-transclude></div>\\n  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\\n    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\\n    <span class=\"sr-only\">previous</span>\\n  </a>\\n  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\\n    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\\n    <span class=\"sr-only\">next</span>\\n  </a>\\n  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\\n    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\\n      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\\n    </li>\\n  </ol>\\n</div>')}]),angular.module(\"uib/template/carousel/slide.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/carousel/slide.html\",'<div ng-class=\"{\\n    \\'active\\': active\\n  }\" class=\"item text-center\" ng-transclude></div>\\n')}]),angular.module(\"uib/template/datepicker/datepicker.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/datepicker.html\",'<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\\n  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\\n  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\\n  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\\n</div>')}]),angular.module(\"uib/template/datepicker/day.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/day.html\",'<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\\n  <thead>\\n    <tr>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\\n      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\\n    </tr>\\n    <tr>\\n      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\\n      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\\n      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\\n      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\\n        id=\"{{::dt.uid}}\"\\n        ng-class=\"::dt.customClass\">\\n        <button type=\"button\" class=\"btn btn-default btn-sm\"\\n          uib-is-class=\"\\n            \\'btn-info\\' for selectedDt,\\n            \\'active\\' for activeDt\\n            on dt\"\\n          ng-click=\"select(dt.date)\"\\n          ng-disabled=\"::dt.disabled\"\\n          tabindex=\"-1\"><span ng-class=\"::{\\'text-muted\\': dt.secondary, \\'text-info\\': dt.current}\">{{::dt.label}}</span></button>\\n      </td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/datepicker/month.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/month.html\",'<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\\n  <thead>\\n    <tr>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\\n      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\\n      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\\n        id=\"{{::dt.uid}}\"\\n        ng-class=\"::dt.customClass\">\\n        <button type=\"button\" class=\"btn btn-default\"\\n          uib-is-class=\"\\n            \\'btn-info\\' for selectedDt,\\n            \\'active\\' for activeDt\\n            on dt\"\\n          ng-click=\"select(dt.date)\"\\n          ng-disabled=\"::dt.disabled\"\\n          tabindex=\"-1\"><span ng-class=\"::{\\'text-info\\': dt.current}\">{{::dt.label}}</span></button>\\n      </td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/datepicker/popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/popup.html\",'<div>\\n  <ul class=\"uib-datepicker-popup dropdown-menu\" dropdown-nested ng-if=\"isOpen\" ng-style=\"{top: position.top+\\'px\\', left: position.left+\\'px\\'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\\n    <li ng-transclude></li>\\n    <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\\n    <span class=\"btn-group pull-left\">\\n      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select(\\'today\\')\" ng-disabled=\"isDisabled(\\'today\\')\">{{ getText(\\'current\\') }}</button>\\n      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null)\">{{ getText(\\'clear\\') }}</button>\\n    </span>\\n      <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close()\">{{ getText(\\'close\\') }}</button>\\n    </li>\\n  </ul>\\n</div>\\n')}]),angular.module(\"uib/template/datepicker/year.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/year.html\",'<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\\n  <thead>\\n    <tr>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\\n      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\\n      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\\n        id=\"{{::dt.uid}}\"\\n        ng-class=\"::dt.customClass\">\\n        <button type=\"button\" class=\"btn btn-default\"\\n          uib-is-class=\"\\n            \\'btn-info\\' for selectedDt,\\n            \\'active\\' for activeDt\\n            on dt\"\\n          ng-click=\"select(dt.date)\"\\n          ng-disabled=\"::dt.disabled\"\\n          tabindex=\"-1\"><span ng-class=\"::{\\'text-info\\': dt.current}\">{{::dt.label}}</span></button>\\n      </td>\\n    </tr>\\n  </tbody>\\n</table>\\n');\n}]),angular.module(\"uib/template/modal/backdrop.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/modal/backdrop.html\",'<div class=\"modal-backdrop\"\\n     uib-modal-animation-class=\"fade\"\\n     modal-in-class=\"in\"\\n     ng-style=\"{\\'z-index\\': 1040 + (index && 1 || 0) + index*10}\"\\n></div>\\n')}]),angular.module(\"uib/template/modal/window.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/modal/window.html\",'<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\\n    uib-modal-animation-class=\"fade\"\\n    modal-in-class=\"in\"\\n    ng-style=\"{\\'z-index\\': 1050 + index*10, display: \\'block\\'}\">\\n    <div class=\"modal-dialog {{size ? \\'modal-\\' + size : \\'\\'}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\\n</div>\\n')}]),angular.module(\"uib/template/pager/pager.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/pager/pager.html\",'<ul class=\"pager\">\\n  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText(\\'previous\\')}}</a></li>\\n  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText(\\'next\\')}}</a></li>\\n</ul>\\n')}]),angular.module(\"uib/template/pagination/pagination.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/pagination/pagination.html\",'<ul class=\"pagination\">\\n  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText(\\'first\\')}}</a></li>\\n  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText(\\'previous\\')}}</a></li>\\n  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\\n  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText(\\'next\\')}}</a></li>\\n  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText(\\'last\\')}}</a></li>\\n</ul>\\n')}]),angular.module(\"uib/template/tooltip/tooltip-html-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tooltip/tooltip-html-popup.html\",'<div class=\"tooltip\"\\n  tooltip-animation-class=\"fade\"\\n  uib-tooltip-classes\\n  ng-class=\"{ in: isOpen() }\">\\n  <div class=\"tooltip-arrow\"></div>\\n  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/tooltip/tooltip-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tooltip/tooltip-popup.html\",'<div class=\"tooltip\"\\n  tooltip-animation-class=\"fade\"\\n  uib-tooltip-classes\\n  ng-class=\"{ in: isOpen() }\">\\n  <div class=\"tooltip-arrow\"></div>\\n  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/tooltip/tooltip-template-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tooltip/tooltip-template-popup.html\",'<div class=\"tooltip\"\\n  tooltip-animation-class=\"fade\"\\n  uib-tooltip-classes\\n  ng-class=\"{ in: isOpen() }\">\\n  <div class=\"tooltip-arrow\"></div>\\n  <div class=\"tooltip-inner\"\\n    uib-tooltip-template-transclude=\"contentExp()\"\\n    tooltip-template-transclude-scope=\"originScope()\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/popover/popover-html.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/popover/popover-html.html\",'<div class=\"popover\"\\n  tooltip-animation-class=\"fade\"\\n  uib-tooltip-classes\\n  ng-class=\"{ in: isOpen() }\">\\n  <div class=\"arrow\"></div>\\n\\n  <div class=\"popover-inner\">\\n      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\\n      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\\n  </div>\\n</div>\\n')}]),angular.module(\"uib/template/popover/popover-template.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/popover/popover-template.html\",'<div class=\"popover\"\\n  tooltip-animation-class=\"fade\"\\n  uib-tooltip-classes\\n  ng-class=\"{ in: isOpen() }\">\\n  <div class=\"arrow\"></div>\\n\\n  <div class=\"popover-inner\">\\n      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\\n      <div class=\"popover-content\"\\n        uib-tooltip-template-transclude=\"contentExp()\"\\n        tooltip-template-transclude-scope=\"originScope()\"></div>\\n  </div>\\n</div>\\n')}]),angular.module(\"uib/template/popover/popover.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/popover/popover.html\",'<div class=\"popover\"\\n  tooltip-animation-class=\"fade\"\\n  uib-tooltip-classes\\n  ng-class=\"{ in: isOpen() }\">\\n  <div class=\"arrow\"></div>\\n\\n  <div class=\"popover-inner\">\\n      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\\n      <div class=\"popover-content\" ng-bind=\"content\"></div>\\n  </div>\\n</div>\\n')}]),angular.module(\"uib/template/progressbar/bar.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/progressbar/bar.html\",'<div class=\"progress-bar\" ng-class=\"type && \\'progress-bar-\\' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + \\'%\\'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\\n')}]),angular.module(\"uib/template/progressbar/progress.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/progressbar/progress.html\",'<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>')}]),angular.module(\"uib/template/progressbar/progressbar.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/progressbar/progressbar.html\",'<div class=\"progress\">\\n  <div class=\"progress-bar\" ng-class=\"type && \\'progress-bar-\\' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + \\'%\\'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\\n</div>\\n')}]),angular.module(\"uib/template/rating/rating.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/rating/rating.html\",'<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\\n    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? \\'*\\' : \\' \\' }})</span>\\n    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || \\'glyphicon-star\\') || (r.stateOff || \\'glyphicon-star-empty\\')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"></i>\\n</span>\\n')}]),angular.module(\"uib/template/tabs/tab.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tabs/tab.html\",'<li ng-class=\"{active: active, disabled: disabled}\" class=\"uib-tab\">\\n  <a href ng-click=\"select()\" uib-tab-heading-transclude>{{heading}}</a>\\n</li>\\n')}]),angular.module(\"uib/template/tabs/tabset.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tabs/tabset.html\",'<div>\\n  <ul class=\"nav nav-{{type || \\'tabs\\'}}\" ng-class=\"{\\'nav-stacked\\': vertical, \\'nav-justified\\': justified}\" ng-transclude></ul>\\n  <div class=\"tab-content\">\\n    <div class=\"tab-pane\" \\n         ng-repeat=\"tab in tabs\" \\n         ng-class=\"{active: tab.active}\"\\n         uib-tab-content-transclude=\"tab\">\\n    </div>\\n  </div>\\n</div>\\n')}]),angular.module(\"uib/template/timepicker/timepicker.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/timepicker/timepicker.html\",'<table class=\"uib-timepicker\">\\n  <tbody>\\n    <tr class=\"text-center\" ng-show=\"::showSpinners\">\\n      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\\n      <td>&nbsp;</td>\\n      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\\n      <td ng-show=\"showSeconds\">&nbsp;</td>\\n      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\\n      <td ng-show=\"showMeridian\"></td>\\n    </tr>\\n    <tr>\\n      <td class=\"form-group uib-time hours\" ng-class=\"{\\'has-error\\': invalidHours}\">\\n        <input style=\"width:50px;\" type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\\n      </td>\\n      <td class=\"uib-separator\">:</td>\\n      <td class=\"form-group uib-time minutes\" ng-class=\"{\\'has-error\\': invalidMinutes}\">\\n        <input style=\"width:50px;\" type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\\n      </td>\\n      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\\n      <td class=\"form-group uib-time seconds\" ng-class=\"{\\'has-error\\': invalidSeconds}\" ng-show=\"showSeconds\">\\n        <input style=\"width:50px;\" type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\\n      </td>\\n      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\\n    </tr>\\n    <tr class=\"text-center\" ng-show=\"::showSpinners\">\\n      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\\n      <td>&nbsp;</td>\\n      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\\n      <td ng-show=\"showSeconds\">&nbsp;</td>\\n      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\\n      <td ng-show=\"showMeridian\"></td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/typeahead/typeahead-match.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/typeahead/typeahead-match.html\",'<a href\\n   tabindex=\"-1\"\\n   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\\n   ng-attr-title=\"{{match.label}}\"></a>\\n')}]),angular.module(\"uib/template/typeahead/typeahead-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/typeahead/typeahead-popup.html\",'<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+\\'px\\', left: position().left+\\'px\\'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\\n    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\\n        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\\n    </li>\\n</ul>\\n')}]),angular.module(\"ui.bootstrap.carousel\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>')}),angular.module(\"ui.bootstrap.datepicker\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-datepicker-popup.dropdown-menu{display:block;}.uib-button-bar{padding:10px 9px 2px;}</style>')}),angular.module(\"ui.bootstrap.timepicker\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>')}),angular.module(\"ui.bootstrap.typeahead\").run(function(){!angular.$$csp().noInlineStyle&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>')});"

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(58))

/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "angular.module('ie8provider', []).provider('ie8', function() {\n  this.$get = angular.noop;\n  var customTags = this.customTags = [];\n  var createDocumentFragment = document.createDocumentFragment;\n  if(createDocumentFragment.call(document).createElement) {\n    document.createDocumentFragment = function () {\n      var fragment = createDocumentFragment.call(document);\n      for (var i = 0; i < customTags.length; i++) {\n        fragment.createElement(customTags[i]);\n      }\n      return fragment;\n    };\n  }\n});\n\n"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(60))

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = "(function () {\n    var module = angular.module('ng.jsoneditor', []);\n    module.constant('ngJsoneditorConfig', {});\n\n    module.directive('ngJsoneditor', ['ngJsoneditorConfig', '$timeout', function (ngJsoneditorConfig, $timeout) {\n        var defaults = ngJsoneditorConfig || {};\n\n        return {\n            restrict: 'A',\n            require: 'ngModel',\n            scope: {'options': '=', 'ngJsoneditor': '=', 'preferText': '='},\n            link: function ($scope, element, attrs, ngModel) {\n                var debounceTo, debounceFrom;\n                var editor;\n                var internalTrigger = false;\n\n                if (!angular.isDefined(window.JSONEditor)) {\n                    throw new Error(\"Please add the jsoneditor.js script first!\");\n                }\n\n                function _createEditor(options) {\n                    var settings = angular.extend({}, defaults, options);\n                    var theOptions = angular.extend({}, settings, {\n                        change: function () {\n                            if (typeof debounceTo !== 'undefined') {\n                                $timeout.cancel(debounceTo);\n                            }\n\n                            debounceTo = $timeout(function () {\n                                if (editor) {\n                                    internalTrigger = true;\n                                    ngModel.$setViewValue($scope.preferText === true ? editor.getText() : editor.get());\n                                    internalTrigger = false;\n\n                                    if (settings && settings.hasOwnProperty('change')) {\n                                        settings.change();\n                                    }\n                                }\n                            }, settings.timeout || 100);\n                        }\n                    });\n\n                    element.html('');\n\n                    var instance = new JSONEditor(element[0], theOptions);\n\n                    if ($scope.ngJsoneditor instanceof Function) {\n                        $timeout(function () { $scope.ngJsoneditor(instance);});\n                    }\n\n                    return instance;\n                }\n\n                $scope.$watch('options', function (newValue, oldValue) {\n                    for (var k in newValue) {\n                        if (newValue.hasOwnProperty(k)) {\n                            var v = newValue[k];\n\n                            if (newValue[k] !== oldValue[k]) {\n                                if (k === 'mode') {\n                                    editor.setMode(v);\n                                } else if (k === 'name') {\n                                    editor.setName(v);\n                                } else { //other settings cannot be changed without re-creating the JsonEditor\n                                    editor = _createEditor(newValue);\n                                    $scope.updateJsonEditor();\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }, true);\n\n                $scope.$on('$destroy', function () {\n                    //remove jsoneditor?\n                });\n\n                $scope.updateJsonEditor = function (newValue) {\n                    if (internalTrigger) return; //ignore if called by $setViewValue\n\n                    if (typeof debounceFrom !== 'undefined') {\n                        $timeout.cancel(debounceFrom);\n                    }\n\n                    debounceFrom = $timeout(function () {\n                        if (($scope.preferText === true) && !angular.isObject(ngModel.$viewValue)) {\n                            editor.setText(ngModel.$viewValue || '{}');\n                        } else {\n                            editor.set(ngModel.$viewValue || {});\n                        }\n                    }, $scope.options.timeout || 100);\n                };\n\n                editor = _createEditor($scope.options);\n\n                if ($scope.options.hasOwnProperty('expanded')) {\n                    $timeout($scope.options.expanded ? function () {editor.expandAll()} : function () {editor.collapseAll()}, ($scope.options.timeout || 100) + 100);\n                }\n\n                ngModel.$render = $scope.updateJsonEditor;\n                $scope.$watch(function () { return ngModel.$modelValue; }, $scope.updateJsonEditor, true); //if someone changes ng-model from outside\n            }\n        };\n    }]);\n})();\n"

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(43)(__webpack_require__(62))

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = ";(function(window, document, undefined) {\n  \"use strict\";\n  \n  (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n// SweetAlert\n// 2014-2015 (c) - Tristan Edwards\n// github.com/t4t5/sweetalert\n\n/*\n * jQuery-like functions for manipulating the DOM\n */\n\nvar _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation = require('./modules/handle-dom');\n\n/*\n * Handy utilities\n */\n\nvar _extend$hexToRgb$isIE8$logStr$colorLuminance = require('./modules/utils');\n\n/*\n *  Handle sweetAlert's DOM elements\n */\n\nvar _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition = require('./modules/handle-swal-dom');\n\n// Handle button events and keyboard events\n\nvar _handleButton$handleConfirm$handleCancel = require('./modules/handle-click');\n\nvar _handleKeyDown = require('./modules/handle-key');\n\nvar _handleKeyDown2 = _interopRequireWildcard(_handleKeyDown);\n\n// Default values\n\nvar _defaultParams = require('./modules/default-params');\n\nvar _defaultParams2 = _interopRequireWildcard(_defaultParams);\n\nvar _setParameters = require('./modules/set-params');\n\nvar _setParameters2 = _interopRequireWildcard(_setParameters);\n\n/*\n * Remember state in cases where opening and handling a modal will fiddle with it.\n * (We also use window.previousActiveElement as a global variable)\n */\nvar previousWindowKeyDown;\nvar lastFocusedButton;\n\n/*\n * Global sweetAlert function\n * (this is what the user calls)\n */\nvar sweetAlert, swal;\n\nexports['default'] = sweetAlert = swal = function () {\n  var customizations = arguments[0];\n\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.addClass(document.body, 'stop-scrolling');\n  _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.resetInput();\n\n  /*\n   * Use argument if defined or default value from params object otherwise.\n   * Supports the case where a default value is boolean true and should be\n   * overridden by a corresponding explicit argument which is boolean false.\n   */\n  function argumentOrDefault(key) {\n    var args = customizations;\n    return args[key] === undefined ? _defaultParams2['default'][key] : args[key];\n  }\n\n  if (customizations === undefined) {\n    _extend$hexToRgb$isIE8$logStr$colorLuminance.logStr('SweetAlert expects at least 1 attribute!');\n    return false;\n  }\n\n  var params = _extend$hexToRgb$isIE8$logStr$colorLuminance.extend({}, _defaultParams2['default']);\n\n  switch (typeof customizations) {\n\n    // Ex: swal(\"Hello\", \"Just testing\", \"info\");\n    case 'string':\n      params.title = customizations;\n      params.text = arguments[1] || '';\n      params.type = arguments[2] || '';\n      break;\n\n    // Ex: swal({ title:\"Hello\", text: \"Just testing\", type: \"info\" });\n    case 'object':\n      if (customizations.title === undefined) {\n        _extend$hexToRgb$isIE8$logStr$colorLuminance.logStr('Missing \"title\" argument!');\n        return false;\n      }\n\n      params.title = customizations.title;\n\n      for (var customName in _defaultParams2['default']) {\n        params[customName] = argumentOrDefault(customName);\n      }\n\n      // Show \"Confirm\" instead of \"OK\" if cancel button is visible\n      params.confirmButtonText = params.showCancelButton ? 'Confirm' : _defaultParams2['default'].confirmButtonText;\n      params.confirmButtonText = argumentOrDefault('confirmButtonText');\n\n      // Callback function when clicking on \"OK\"/\"Cancel\"\n      params.doneFunction = arguments[1] || null;\n\n      break;\n\n    default:\n      _extend$hexToRgb$isIE8$logStr$colorLuminance.logStr('Unexpected type of argument! Expected \"string\" or \"object\", got ' + typeof customizations);\n      return false;\n\n  }\n\n  _setParameters2['default'](params);\n  _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.fixVerticalPosition();\n  _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.openModal(arguments[1]);\n\n  // Modal interactions\n  var modal = _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getModal();\n\n  /*\n   * Make sure all modal buttons respond to all events\n   */\n  var $buttons = modal.querySelectorAll('button');\n  var buttonEvents = ['onclick', 'onmouseover', 'onmouseout', 'onmousedown', 'onmouseup', 'onfocus'];\n  var onButtonEvent = function onButtonEvent(e) {\n    return _handleButton$handleConfirm$handleCancel.handleButton(e, params, modal);\n  };\n\n  for (var btnIndex = 0; btnIndex < $buttons.length; btnIndex++) {\n    for (var evtIndex = 0; evtIndex < buttonEvents.length; evtIndex++) {\n      var btnEvt = buttonEvents[evtIndex];\n      $buttons[btnIndex][btnEvt] = onButtonEvent;\n    }\n  }\n\n  // Clicking outside the modal dismisses it (if allowed by user)\n  _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getOverlay().onclick = onButtonEvent;\n\n  previousWindowKeyDown = window.onkeydown;\n\n  var onKeyEvent = function onKeyEvent(e) {\n    return _handleKeyDown2['default'](e, params, modal);\n  };\n  window.onkeydown = onKeyEvent;\n\n  window.onfocus = function () {\n    // When the user has focused away and focused back from the whole window.\n    setTimeout(function () {\n      // Put in a timeout to jump out of the event sequence.\n      // Calling focus() in the event sequence confuses things.\n      if (lastFocusedButton !== undefined) {\n        lastFocusedButton.focus();\n        lastFocusedButton = undefined;\n      }\n    }, 0);\n  };\n\n  // Show alert with enabled buttons always\n  swal.enableButtons();\n};\n\n/*\n * Set default params for each popup\n * @param {Object} userParams\n */\nsweetAlert.setDefaults = swal.setDefaults = function (userParams) {\n  if (!userParams) {\n    throw new Error('userParams is required');\n  }\n  if (typeof userParams !== 'object') {\n    throw new Error('userParams has to be a object');\n  }\n\n  _extend$hexToRgb$isIE8$logStr$colorLuminance.extend(_defaultParams2['default'], userParams);\n};\n\n/*\n * Animation when closing modal\n */\nsweetAlert.close = swal.close = function () {\n  var modal = _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getModal();\n\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.fadeOut(_sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getOverlay(), 5);\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.fadeOut(modal, 5);\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass(modal, 'showSweetAlert');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.addClass(modal, 'hideSweetAlert');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass(modal, 'visible');\n\n  /*\n   * Reset icon animations\n   */\n  var $successIcon = modal.querySelector('.sa-icon.sa-success');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($successIcon, 'animate');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($successIcon.querySelector('.sa-tip'), 'animateSuccessTip');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($successIcon.querySelector('.sa-long'), 'animateSuccessLong');\n\n  var $errorIcon = modal.querySelector('.sa-icon.sa-error');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($errorIcon, 'animateErrorIcon');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($errorIcon.querySelector('.sa-x-mark'), 'animateXMark');\n\n  var $warningIcon = modal.querySelector('.sa-icon.sa-warning');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($warningIcon, 'pulseWarning');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($warningIcon.querySelector('.sa-body'), 'pulseWarningIns');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($warningIcon.querySelector('.sa-dot'), 'pulseWarningIns');\n\n  // Reset custom class (delay so that UI changes aren't visible)\n  setTimeout(function () {\n    var customClass = modal.getAttribute('data-custom-class');\n    _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass(modal, customClass);\n  }, 300);\n\n  // Make page scrollable again\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass(document.body, 'stop-scrolling');\n\n  // Reset the page to its previous state\n  window.onkeydown = previousWindowKeyDown;\n  if (window.previousActiveElement) {\n    window.previousActiveElement.focus();\n  }\n  lastFocusedButton = undefined;\n  clearTimeout(modal.timeout);\n\n  return true;\n};\n\n/*\n * Validation of the input field is done by user\n * If something is wrong => call showInputError with errorMessage\n */\nsweetAlert.showInputError = swal.showInputError = function (errorMessage) {\n  var modal = _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getModal();\n\n  var $errorIcon = modal.querySelector('.sa-input-error');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.addClass($errorIcon, 'show');\n\n  var $errorContainer = modal.querySelector('.sa-error-container');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.addClass($errorContainer, 'show');\n\n  $errorContainer.querySelector('p').innerHTML = errorMessage;\n\n  setTimeout(function () {\n    sweetAlert.enableButtons();\n  }, 1);\n\n  modal.querySelector('input').focus();\n};\n\n/*\n * Reset input error DOM elements\n */\nsweetAlert.resetInputError = swal.resetInputError = function (event) {\n  // If press enter => ignore\n  if (event && event.keyCode === 13) {\n    return false;\n  }\n\n  var $modal = _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getModal();\n\n  var $errorIcon = $modal.querySelector('.sa-input-error');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($errorIcon, 'show');\n\n  var $errorContainer = $modal.querySelector('.sa-error-container');\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide$isDescendant$getTopMargin$fadeIn$fadeOut$fireClick$stopEventPropagation.removeClass($errorContainer, 'show');\n};\n\n/*\n * Disable confirm and cancel buttons\n */\nsweetAlert.disableButtons = swal.disableButtons = function (event) {\n  var modal = _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getModal();\n  var $confirmButton = modal.querySelector('button.confirm');\n  var $cancelButton = modal.querySelector('button.cancel');\n  $confirmButton.disabled = true;\n  $cancelButton.disabled = true;\n};\n\n/*\n * Enable confirm and cancel buttons\n */\nsweetAlert.enableButtons = swal.enableButtons = function (event) {\n  var modal = _sweetAlertInitialize$getModal$getOverlay$getInput$setFocusStyle$openModal$resetInput$fixVerticalPosition.getModal();\n  var $confirmButton = modal.querySelector('button.confirm');\n  var $cancelButton = modal.querySelector('button.cancel');\n  $confirmButton.disabled = false;\n  $cancelButton.disabled = false;\n};\n\nif (typeof window !== 'undefined') {\n  // The 'handle-click' module requires\n  // that 'sweetAlert' was set as global.\n  window.sweetAlert = window.swal = sweetAlert;\n} else {\n  _extend$hexToRgb$isIE8$logStr$colorLuminance.logStr('SweetAlert is a frontend module!');\n}\nmodule.exports = exports['default'];\n\n},{\"./modules/default-params\":2,\"./modules/handle-click\":3,\"./modules/handle-dom\":4,\"./modules/handle-key\":5,\"./modules/handle-swal-dom\":6,\"./modules/set-params\":8,\"./modules/utils\":9}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar defaultParams = {\n  title: '',\n  text: '',\n  type: null,\n  allowOutsideClick: false,\n  showConfirmButton: true,\n  showCancelButton: false,\n  closeOnConfirm: true,\n  closeOnCancel: true,\n  confirmButtonText: 'OK',\n  confirmButtonColor: '#8CD4F5',\n  cancelButtonText: 'Cancel',\n  imageUrl: null,\n  imageSize: null,\n  timer: null,\n  customClass: '',\n  html: false,\n  animation: true,\n  allowEscapeKey: true,\n  inputType: 'text',\n  inputPlaceholder: '',\n  inputValue: '',\n  showLoaderOnConfirm: false\n};\n\nexports['default'] = defaultParams;\nmodule.exports = exports['default'];\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _colorLuminance = require('./utils');\n\nvar _getModal = require('./handle-swal-dom');\n\nvar _hasClass$isDescendant = require('./handle-dom');\n\n/*\n * User clicked on \"Confirm\"/\"OK\" or \"Cancel\"\n */\nvar handleButton = function handleButton(event, params, modal) {\n  var e = event || window.event;\n  var target = e.target || e.srcElement;\n\n  var targetedConfirm = target.className.indexOf('confirm') !== -1;\n  var targetedOverlay = target.className.indexOf('sweet-overlay') !== -1;\n  var modalIsVisible = _hasClass$isDescendant.hasClass(modal, 'visible');\n  var doneFunctionExists = params.doneFunction && modal.getAttribute('data-has-done-function') === 'true';\n\n  // Since the user can change the background-color of the confirm button programmatically,\n  // we must calculate what the color should be on hover/active\n  var normalColor, hoverColor, activeColor;\n  if (targetedConfirm && params.confirmButtonColor) {\n    normalColor = params.confirmButtonColor;\n    hoverColor = _colorLuminance.colorLuminance(normalColor, -0.04);\n    activeColor = _colorLuminance.colorLuminance(normalColor, -0.14);\n  }\n\n  function shouldSetConfirmButtonColor(color) {\n    if (targetedConfirm && params.confirmButtonColor) {\n      target.style.backgroundColor = color;\n    }\n  }\n\n  switch (e.type) {\n    case 'mouseover':\n      shouldSetConfirmButtonColor(hoverColor);\n      break;\n\n    case 'mouseout':\n      shouldSetConfirmButtonColor(normalColor);\n      break;\n\n    case 'mousedown':\n      shouldSetConfirmButtonColor(activeColor);\n      break;\n\n    case 'mouseup':\n      shouldSetConfirmButtonColor(hoverColor);\n      break;\n\n    case 'focus':\n      var $confirmButton = modal.querySelector('button.confirm');\n      var $cancelButton = modal.querySelector('button.cancel');\n\n      if (targetedConfirm) {\n        $cancelButton.style.boxShadow = 'none';\n      } else {\n        $confirmButton.style.boxShadow = 'none';\n      }\n      break;\n\n    case 'click':\n      var clickedOnModal = modal === target;\n      var clickedOnModalChild = _hasClass$isDescendant.isDescendant(modal, target);\n\n      // Ignore click outside if allowOutsideClick is false\n      if (!clickedOnModal && !clickedOnModalChild && modalIsVisible && !params.allowOutsideClick) {\n        break;\n      }\n\n      if (targetedConfirm && doneFunctionExists && modalIsVisible) {\n        handleConfirm(modal, params);\n      } else if (doneFunctionExists && modalIsVisible || targetedOverlay) {\n        handleCancel(modal, params);\n      } else if (_hasClass$isDescendant.isDescendant(modal, target) && target.tagName === 'BUTTON') {\n        sweetAlert.close();\n      }\n      break;\n  }\n};\n\n/*\n *  User clicked on \"Confirm\"/\"OK\"\n */\nvar handleConfirm = function handleConfirm(modal, params) {\n  var callbackValue = true;\n\n  if (_hasClass$isDescendant.hasClass(modal, 'show-input')) {\n    callbackValue = modal.querySelector('input').value;\n\n    if (!callbackValue) {\n      callbackValue = '';\n    }\n  }\n\n  params.doneFunction(callbackValue);\n\n  if (params.closeOnConfirm) {\n    sweetAlert.close();\n  }\n  // Disable cancel and confirm button if the parameter is true\n  if (params.showLoaderOnConfirm) {\n    sweetAlert.disableButtons();\n  }\n};\n\n/*\n *  User clicked on \"Cancel\"\n */\nvar handleCancel = function handleCancel(modal, params) {\n  // Check if callback function expects a parameter (to track cancel actions)\n  var functionAsStr = String(params.doneFunction).replace(/\\s/g, '');\n  var functionHandlesCancel = functionAsStr.substring(0, 9) === 'function(' && functionAsStr.substring(9, 10) !== ')';\n\n  if (functionHandlesCancel) {\n    params.doneFunction(false);\n  }\n\n  if (params.closeOnCancel) {\n    sweetAlert.close();\n  }\n};\n\nexports['default'] = {\n  handleButton: handleButton,\n  handleConfirm: handleConfirm,\n  handleCancel: handleCancel\n};\nmodule.exports = exports['default'];\n\n},{\"./handle-dom\":4,\"./handle-swal-dom\":6,\"./utils\":9}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar hasClass = function hasClass(elem, className) {\n  return new RegExp(' ' + className + ' ').test(' ' + elem.className + ' ');\n};\n\nvar addClass = function addClass(elem, className) {\n  if (!hasClass(elem, className)) {\n    elem.className += ' ' + className;\n  }\n};\n\nvar removeClass = function removeClass(elem, className) {\n  var newClass = ' ' + elem.className.replace(/[\\t\\r\\n]/g, ' ') + ' ';\n  if (hasClass(elem, className)) {\n    while (newClass.indexOf(' ' + className + ' ') >= 0) {\n      newClass = newClass.replace(' ' + className + ' ', ' ');\n    }\n    elem.className = newClass.replace(/^\\s+|\\s+$/g, '');\n  }\n};\n\nvar escapeHtml = function escapeHtml(str) {\n  var div = document.createElement('div');\n  div.appendChild(document.createTextNode(str));\n  return div.innerHTML;\n};\n\nvar _show = function _show(elem) {\n  elem.style.opacity = '';\n  elem.style.display = 'block';\n};\n\nvar show = function show(elems) {\n  if (elems && !elems.length) {\n    return _show(elems);\n  }\n  for (var i = 0; i < elems.length; ++i) {\n    _show(elems[i]);\n  }\n};\n\nvar _hide = function _hide(elem) {\n  elem.style.opacity = '';\n  elem.style.display = 'none';\n};\n\nvar hide = function hide(elems) {\n  if (elems && !elems.length) {\n    return _hide(elems);\n  }\n  for (var i = 0; i < elems.length; ++i) {\n    _hide(elems[i]);\n  }\n};\n\nvar isDescendant = function isDescendant(parent, child) {\n  var node = child.parentNode;\n  while (node !== null) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n};\n\nvar getTopMargin = function getTopMargin(elem) {\n  elem.style.left = '-9999px';\n  elem.style.display = 'block';\n\n  var height = elem.clientHeight,\n      padding;\n  if (typeof getComputedStyle !== 'undefined') {\n    // IE 8\n    padding = parseInt(getComputedStyle(elem).getPropertyValue('padding-top'), 10);\n  } else {\n    padding = parseInt(elem.currentStyle.padding);\n  }\n\n  elem.style.left = '';\n  elem.style.display = 'none';\n  return '-' + parseInt((height + padding) / 2) + 'px';\n};\n\nvar fadeIn = function fadeIn(elem, interval) {\n  if (+elem.style.opacity < 1) {\n    interval = interval || 16;\n    elem.style.opacity = 0;\n    elem.style.display = 'block';\n    var last = +new Date();\n    var tick = (function (_tick) {\n      function tick() {\n        return _tick.apply(this, arguments);\n      }\n\n      tick.toString = function () {\n        return _tick.toString();\n      };\n\n      return tick;\n    })(function () {\n      elem.style.opacity = +elem.style.opacity + (new Date() - last) / 100;\n      last = +new Date();\n\n      if (+elem.style.opacity < 1) {\n        setTimeout(tick, interval);\n      }\n    });\n    tick();\n  }\n  elem.style.display = 'block'; //fallback IE8\n};\n\nvar fadeOut = function fadeOut(elem, interval) {\n  interval = interval || 16;\n  elem.style.opacity = 1;\n  var last = +new Date();\n  var tick = (function (_tick2) {\n    function tick() {\n      return _tick2.apply(this, arguments);\n    }\n\n    tick.toString = function () {\n      return _tick2.toString();\n    };\n\n    return tick;\n  })(function () {\n    elem.style.opacity = +elem.style.opacity - (new Date() - last) / 100;\n    last = +new Date();\n\n    if (+elem.style.opacity > 0) {\n      setTimeout(tick, interval);\n    } else {\n      elem.style.display = 'none';\n    }\n  });\n  tick();\n};\n\nvar fireClick = function fireClick(node) {\n  // Taken from http://www.nonobtrusive.com/2011/11/29/programatically-fire-crossbrowser-click-event-with-javascript/\n  // Then fixed for today's Chrome browser.\n  if (typeof MouseEvent === 'function') {\n    // Up-to-date approach\n    var mevt = new MouseEvent('click', {\n      view: window,\n      bubbles: false,\n      cancelable: true\n    });\n    node.dispatchEvent(mevt);\n  } else if (document.createEvent) {\n    // Fallback\n    var evt = document.createEvent('MouseEvents');\n    evt.initEvent('click', false, false);\n    node.dispatchEvent(evt);\n  } else if (document.createEventObject) {\n    node.fireEvent('onclick');\n  } else if (typeof node.onclick === 'function') {\n    node.onclick();\n  }\n};\n\nvar stopEventPropagation = function stopEventPropagation(e) {\n  // In particular, make sure the space bar doesn't scroll the main window.\n  if (typeof e.stopPropagation === 'function') {\n    e.stopPropagation();\n    e.preventDefault();\n  } else if (window.event && window.event.hasOwnProperty('cancelBubble')) {\n    window.event.cancelBubble = true;\n  }\n};\n\nexports.hasClass = hasClass;\nexports.addClass = addClass;\nexports.removeClass = removeClass;\nexports.escapeHtml = escapeHtml;\nexports._show = _show;\nexports.show = show;\nexports._hide = _hide;\nexports.hide = hide;\nexports.isDescendant = isDescendant;\nexports.getTopMargin = getTopMargin;\nexports.fadeIn = fadeIn;\nexports.fadeOut = fadeOut;\nexports.fireClick = fireClick;\nexports.stopEventPropagation = stopEventPropagation;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _stopEventPropagation$fireClick = require('./handle-dom');\n\nvar _setFocusStyle = require('./handle-swal-dom');\n\nvar handleKeyDown = function handleKeyDown(event, params, modal) {\n  var e = event || window.event;\n  var keyCode = e.keyCode || e.which;\n\n  var $okButton = modal.querySelector('button.confirm');\n  var $cancelButton = modal.querySelector('button.cancel');\n  var $modalButtons = modal.querySelectorAll('button[tabindex]');\n\n  if ([9, 13, 32, 27].indexOf(keyCode) === -1) {\n    // Don't do work on keys we don't care about.\n    return;\n  }\n\n  var $targetElement = e.target || e.srcElement;\n\n  var btnIndex = -1; // Find the button - note, this is a nodelist, not an array.\n  for (var i = 0; i < $modalButtons.length; i++) {\n    if ($targetElement === $modalButtons[i]) {\n      btnIndex = i;\n      break;\n    }\n  }\n\n  if (keyCode === 9) {\n    // TAB\n    if (btnIndex === -1) {\n      // No button focused. Jump to the confirm button.\n      $targetElement = $okButton;\n    } else {\n      // Cycle to the next button\n      if (btnIndex === $modalButtons.length - 1) {\n        $targetElement = $modalButtons[0];\n      } else {\n        $targetElement = $modalButtons[btnIndex + 1];\n      }\n    }\n\n    _stopEventPropagation$fireClick.stopEventPropagation(e);\n    $targetElement.focus();\n\n    if (params.confirmButtonColor) {\n      _setFocusStyle.setFocusStyle($targetElement, params.confirmButtonColor);\n    }\n  } else {\n    if (keyCode === 13) {\n      if ($targetElement.tagName === 'INPUT') {\n        $targetElement = $okButton;\n        $okButton.focus();\n      }\n\n      if (btnIndex === -1) {\n        // ENTER/SPACE clicked outside of a button.\n        $targetElement = $okButton;\n      } else {\n        // Do nothing - let the browser handle it.\n        $targetElement = undefined;\n      }\n    } else if (keyCode === 27 && params.allowEscapeKey === true) {\n      $targetElement = $cancelButton;\n      _stopEventPropagation$fireClick.fireClick($targetElement, e);\n    } else {\n      // Fallback - let the browser handle it.\n      $targetElement = undefined;\n    }\n  }\n};\n\nexports['default'] = handleKeyDown;\nmodule.exports = exports['default'];\n\n},{\"./handle-dom\":4,\"./handle-swal-dom\":6}],6:[function(require,module,exports){\n'use strict';\n\nvar _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _hexToRgb = require('./utils');\n\nvar _removeClass$getTopMargin$fadeIn$show$addClass = require('./handle-dom');\n\nvar _defaultParams = require('./default-params');\n\nvar _defaultParams2 = _interopRequireWildcard(_defaultParams);\n\n/*\n * Add modal + overlay to DOM\n */\n\nvar _injectedHTML = require('./injected-html');\n\nvar _injectedHTML2 = _interopRequireWildcard(_injectedHTML);\n\nvar modalClass = '.sweet-alert';\nvar overlayClass = '.sweet-overlay';\n\nvar sweetAlertInitialize = function sweetAlertInitialize() {\n  var sweetWrap = document.createElement('div');\n  sweetWrap.innerHTML = _injectedHTML2['default'];\n\n  // Append elements to body\n  while (sweetWrap.firstChild) {\n    document.body.appendChild(sweetWrap.firstChild);\n  }\n};\n\n/*\n * Get DOM element of modal\n */\nvar getModal = (function (_getModal) {\n  function getModal() {\n    return _getModal.apply(this, arguments);\n  }\n\n  getModal.toString = function () {\n    return _getModal.toString();\n  };\n\n  return getModal;\n})(function () {\n  var $modal = document.querySelector(modalClass);\n\n  if (!$modal) {\n    sweetAlertInitialize();\n    $modal = getModal();\n  }\n\n  return $modal;\n});\n\n/*\n * Get DOM element of input (in modal)\n */\nvar getInput = function getInput() {\n  var $modal = getModal();\n  if ($modal) {\n    return $modal.querySelector('input');\n  }\n};\n\n/*\n * Get DOM element of overlay\n */\nvar getOverlay = function getOverlay() {\n  return document.querySelector(overlayClass);\n};\n\n/*\n * Add box-shadow style to button (depending on its chosen bg-color)\n */\nvar setFocusStyle = function setFocusStyle($button, bgColor) {\n  var rgbColor = _hexToRgb.hexToRgb(bgColor);\n  $button.style.boxShadow = '0 0 2px rgba(' + rgbColor + ', 0.8), inset 0 0 0 1px rgba(0, 0, 0, 0.05)';\n};\n\n/*\n * Animation when opening modal\n */\nvar openModal = function openModal(callback) {\n  var $modal = getModal();\n  _removeClass$getTopMargin$fadeIn$show$addClass.fadeIn(getOverlay(), 10);\n  _removeClass$getTopMargin$fadeIn$show$addClass.show($modal);\n  _removeClass$getTopMargin$fadeIn$show$addClass.addClass($modal, 'showSweetAlert');\n  _removeClass$getTopMargin$fadeIn$show$addClass.removeClass($modal, 'hideSweetAlert');\n\n  window.previousActiveElement = document.activeElement;\n  var $okButton = $modal.querySelector('button.confirm');\n  $okButton.focus();\n\n  setTimeout(function () {\n    _removeClass$getTopMargin$fadeIn$show$addClass.addClass($modal, 'visible');\n  }, 500);\n\n  var timer = $modal.getAttribute('data-timer');\n\n  if (timer !== 'null' && timer !== '') {\n    var timerCallback = callback;\n    $modal.timeout = setTimeout(function () {\n      var doneFunctionExists = (timerCallback || null) && $modal.getAttribute('data-has-done-function') === 'true';\n      if (doneFunctionExists) {\n        timerCallback(null);\n      } else {\n        sweetAlert.close();\n      }\n    }, timer);\n  }\n};\n\n/*\n * Reset the styling of the input\n * (for example if errors have been shown)\n */\nvar resetInput = function resetInput() {\n  var $modal = getModal();\n  var $input = getInput();\n\n  _removeClass$getTopMargin$fadeIn$show$addClass.removeClass($modal, 'show-input');\n  $input.value = _defaultParams2['default'].inputValue;\n  $input.setAttribute('type', _defaultParams2['default'].inputType);\n  $input.setAttribute('placeholder', _defaultParams2['default'].inputPlaceholder);\n\n  resetInputError();\n};\n\nvar resetInputError = function resetInputError(event) {\n  // If press enter => ignore\n  if (event && event.keyCode === 13) {\n    return false;\n  }\n\n  var $modal = getModal();\n\n  var $errorIcon = $modal.querySelector('.sa-input-error');\n  _removeClass$getTopMargin$fadeIn$show$addClass.removeClass($errorIcon, 'show');\n\n  var $errorContainer = $modal.querySelector('.sa-error-container');\n  _removeClass$getTopMargin$fadeIn$show$addClass.removeClass($errorContainer, 'show');\n};\n\n/*\n * Set \"margin-top\"-property on modal based on its computed height\n */\nvar fixVerticalPosition = function fixVerticalPosition() {\n  var $modal = getModal();\n  $modal.style.marginTop = _removeClass$getTopMargin$fadeIn$show$addClass.getTopMargin(getModal());\n};\n\nexports.sweetAlertInitialize = sweetAlertInitialize;\nexports.getModal = getModal;\nexports.getOverlay = getOverlay;\nexports.getInput = getInput;\nexports.setFocusStyle = setFocusStyle;\nexports.openModal = openModal;\nexports.resetInput = resetInput;\nexports.resetInputError = resetInputError;\nexports.fixVerticalPosition = fixVerticalPosition;\n\n},{\"./default-params\":2,\"./handle-dom\":4,\"./injected-html\":7,\"./utils\":9}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar injectedHTML =\n\n// Dark overlay\n\"<div class=\\\"sweet-overlay\\\" tabIndex=\\\"-1\\\"></div>\" +\n\n// Modal\n\"<div class=\\\"sweet-alert\\\">\" +\n\n// Error icon\n\"<div class=\\\"sa-icon sa-error\\\">\\n      <span class=\\\"sa-x-mark\\\">\\n        <span class=\\\"sa-line sa-left\\\"></span>\\n        <span class=\\\"sa-line sa-right\\\"></span>\\n      </span>\\n    </div>\" +\n\n// Warning icon\n\"<div class=\\\"sa-icon sa-warning\\\">\\n      <span class=\\\"sa-body\\\"></span>\\n      <span class=\\\"sa-dot\\\"></span>\\n    </div>\" +\n\n// Info icon\n\"<div class=\\\"sa-icon sa-info\\\"></div>\" +\n\n// Success icon\n\"<div class=\\\"sa-icon sa-success\\\">\\n      <span class=\\\"sa-line sa-tip\\\"></span>\\n      <span class=\\\"sa-line sa-long\\\"></span>\\n\\n      <div class=\\\"sa-placeholder\\\"></div>\\n      <div class=\\\"sa-fix\\\"></div>\\n    </div>\" + \"<div class=\\\"sa-icon sa-custom\\\"></div>\" +\n\n// Title, text and input\n\"<h2>Title</h2>\\n    <p>Text</p>\\n    <fieldset>\\n      <input type=\\\"text\\\" tabIndex=\\\"3\\\" />\\n      <div class=\\\"sa-input-error\\\"></div>\\n    </fieldset>\" +\n\n// Input errors\n\"<div class=\\\"sa-error-container\\\">\\n      <div class=\\\"icon\\\">!</div>\\n      <p>Not valid!</p>\\n    </div>\" +\n\n// Cancel and confirm buttons\n\"<div class=\\\"sa-button-container\\\">\\n      <button class=\\\"cancel\\\" tabIndex=\\\"2\\\">Cancel</button>\\n      <div class=\\\"sa-confirm-button-container\\\">\\n        <button class=\\\"confirm\\\" tabIndex=\\\"1\\\">OK</button>\" +\n\n// Loading animation\n\"<div class=\\\"la-ball-fall\\\">\\n          <div></div>\\n          <div></div>\\n          <div></div>\\n        </div>\\n      </div>\\n    </div>\" +\n\n// End of modal\n\"</div>\";\n\nexports[\"default\"] = injectedHTML;\nmodule.exports = exports[\"default\"];\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _isIE8 = require('./utils');\n\nvar _getModal$getInput$setFocusStyle = require('./handle-swal-dom');\n\nvar _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide = require('./handle-dom');\n\nvar alertTypes = ['error', 'warning', 'info', 'success', 'input', 'prompt'];\n\n/*\n * Set type, text and actions on modal\n */\nvar setParameters = function setParameters(params) {\n  var modal = _getModal$getInput$setFocusStyle.getModal();\n\n  var $title = modal.querySelector('h2');\n  var $text = modal.querySelector('p');\n  var $cancelBtn = modal.querySelector('button.cancel');\n  var $confirmBtn = modal.querySelector('button.confirm');\n\n  /*\n   * Title\n   */\n  $title.innerHTML = params.html ? params.title : _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.escapeHtml(params.title).split('\\n').join('<br>');\n\n  /*\n   * Text\n   */\n  $text.innerHTML = params.html ? params.text : _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.escapeHtml(params.text || '').split('\\n').join('<br>');\n  if (params.text) _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.show($text);\n\n  /*\n   * Custom class\n   */\n  if (params.customClass) {\n    _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass(modal, params.customClass);\n    modal.setAttribute('data-custom-class', params.customClass);\n  } else {\n    // Find previously set classes and remove them\n    var customClass = modal.getAttribute('data-custom-class');\n    _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.removeClass(modal, customClass);\n    modal.setAttribute('data-custom-class', '');\n  }\n\n  /*\n   * Icon\n   */\n  _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.hide(modal.querySelectorAll('.sa-icon'));\n\n  if (params.type && !_isIE8.isIE8()) {\n    var _ret = (function () {\n\n      var validType = false;\n\n      for (var i = 0; i < alertTypes.length; i++) {\n        if (params.type === alertTypes[i]) {\n          validType = true;\n          break;\n        }\n      }\n\n      if (!validType) {\n        logStr('Unknown alert type: ' + params.type);\n        return {\n          v: false\n        };\n      }\n\n      var typesWithIcons = ['success', 'error', 'warning', 'info'];\n      var $icon = undefined;\n\n      if (typesWithIcons.indexOf(params.type) !== -1) {\n        $icon = modal.querySelector('.sa-icon.' + 'sa-' + params.type);\n        _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.show($icon);\n      }\n\n      var $input = _getModal$getInput$setFocusStyle.getInput();\n\n      // Animate icon\n      switch (params.type) {\n\n        case 'success':\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon, 'animate');\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon.querySelector('.sa-tip'), 'animateSuccessTip');\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon.querySelector('.sa-long'), 'animateSuccessLong');\n          break;\n\n        case 'error':\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon, 'animateErrorIcon');\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon.querySelector('.sa-x-mark'), 'animateXMark');\n          break;\n\n        case 'warning':\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon, 'pulseWarning');\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon.querySelector('.sa-body'), 'pulseWarningIns');\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass($icon.querySelector('.sa-dot'), 'pulseWarningIns');\n          break;\n\n        case 'input':\n        case 'prompt':\n          $input.setAttribute('type', params.inputType);\n          $input.value = params.inputValue;\n          $input.setAttribute('placeholder', params.inputPlaceholder);\n          _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.addClass(modal, 'show-input');\n          setTimeout(function () {\n            $input.focus();\n            $input.addEventListener('keyup', swal.resetInputError);\n          }, 400);\n          break;\n      }\n    })();\n\n    if (typeof _ret === 'object') {\n      return _ret.v;\n    }\n  }\n\n  /*\n   * Custom image\n   */\n  if (params.imageUrl) {\n    var $customIcon = modal.querySelector('.sa-icon.sa-custom');\n\n    $customIcon.style.backgroundImage = 'url(' + params.imageUrl + ')';\n    _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.show($customIcon);\n\n    var _imgWidth = 80;\n    var _imgHeight = 80;\n\n    if (params.imageSize) {\n      var dimensions = params.imageSize.toString().split('x');\n      var imgWidth = dimensions[0];\n      var imgHeight = dimensions[1];\n\n      if (!imgWidth || !imgHeight) {\n        logStr('Parameter imageSize expects value with format WIDTHxHEIGHT, got ' + params.imageSize);\n      } else {\n        _imgWidth = imgWidth;\n        _imgHeight = imgHeight;\n      }\n    }\n\n    $customIcon.setAttribute('style', $customIcon.getAttribute('style') + 'width:' + _imgWidth + 'px; height:' + _imgHeight + 'px');\n  }\n\n  /*\n   * Show cancel button?\n   */\n  modal.setAttribute('data-has-cancel-button', params.showCancelButton);\n  if (params.showCancelButton) {\n    $cancelBtn.style.display = 'inline-block';\n  } else {\n    _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.hide($cancelBtn);\n  }\n\n  /*\n   * Show confirm button?\n   */\n  modal.setAttribute('data-has-confirm-button', params.showConfirmButton);\n  if (params.showConfirmButton) {\n    $confirmBtn.style.display = 'inline-block';\n  } else {\n    _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.hide($confirmBtn);\n  }\n\n  /*\n   * Custom text on cancel/confirm buttons\n   */\n  if (params.cancelButtonText) {\n    $cancelBtn.innerHTML = _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.escapeHtml(params.cancelButtonText);\n  }\n  if (params.confirmButtonText) {\n    $confirmBtn.innerHTML = _hasClass$addClass$removeClass$escapeHtml$_show$show$_hide$hide.escapeHtml(params.confirmButtonText);\n  }\n\n  /*\n   * Custom color on confirm button\n   */\n  if (params.confirmButtonColor) {\n    // Set confirm button to selected background color\n    $confirmBtn.style.backgroundColor = params.confirmButtonColor;\n\n    // Set the confirm button color to the loading ring\n    $confirmBtn.style.borderLeftColor = params.confirmLoadingButtonColor;\n    $confirmBtn.style.borderRightColor = params.confirmLoadingButtonColor;\n\n    // Set box-shadow to default focused button\n    _getModal$getInput$setFocusStyle.setFocusStyle($confirmBtn, params.confirmButtonColor);\n  }\n\n  /*\n   * Allow outside click\n   */\n  modal.setAttribute('data-allow-outside-click', params.allowOutsideClick);\n\n  /*\n   * Callback function\n   */\n  var hasDoneFunction = params.doneFunction ? true : false;\n  modal.setAttribute('data-has-done-function', hasDoneFunction);\n\n  /*\n   * Animation\n   */\n  if (!params.animation) {\n    modal.setAttribute('data-animation', 'none');\n  } else if (typeof params.animation === 'string') {\n    modal.setAttribute('data-animation', params.animation); // Custom animation\n  } else {\n    modal.setAttribute('data-animation', 'pop');\n  }\n\n  /*\n   * Timer\n   */\n  modal.setAttribute('data-timer', params.timer);\n};\n\nexports['default'] = setParameters;\nmodule.exports = exports['default'];\n\n},{\"./handle-dom\":4,\"./handle-swal-dom\":6,\"./utils\":9}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n/*\n * Allow user to pass their own params\n */\nvar extend = function extend(a, b) {\n  for (var key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n\n/*\n * Convert HEX codes to RGB values (#000000 -> rgb(0,0,0))\n */\nvar hexToRgb = function hexToRgb(hex) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? parseInt(result[1], 16) + ', ' + parseInt(result[2], 16) + ', ' + parseInt(result[3], 16) : null;\n};\n\n/*\n * Check if the user is using Internet Explorer 8 (for fallbacks)\n */\nvar isIE8 = function isIE8() {\n  return window.attachEvent && !window.addEventListener;\n};\n\n/*\n * IE compatible logging for developers\n */\nvar logStr = function logStr(string) {\n  if (window.console) {\n    // IE...\n    window.console.log('SweetAlert: ' + string);\n  }\n};\n\n/*\n * Set hover, active and focus-states for buttons \n * (source: http://www.sitepoint.com/javascript-generate-lighter-darker-color)\n */\nvar colorLuminance = function colorLuminance(hex, lum) {\n  // Validate hex string\n  hex = String(hex).replace(/[^0-9a-f]/gi, '');\n  if (hex.length < 6) {\n    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n  }\n  lum = lum || 0;\n\n  // Convert to decimal and change luminosity\n  var rgb = '#';\n  var c;\n  var i;\n\n  for (i = 0; i < 3; i++) {\n    c = parseInt(hex.substr(i * 2, 2), 16);\n    c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);\n    rgb += ('00' + c).substr(c.length);\n  }\n\n  return rgb;\n};\n\nexports.extend = extend;\nexports.hexToRgb = hexToRgb;\nexports.isIE8 = isIE8;\nexports.logStr = logStr;\nexports.colorLuminance = colorLuminance;\n\n},{}]},{},[1])\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvVHJpc3Rhbi9kZXYvU3dlZXRBbGVydC9kZXYvc3dlZXRhbGVydC5lczYuanMiLCIvVXNlcnMvVHJpc3Rhbi9kZXYvU3dlZXRBbGVydC9kZXYvbW9kdWxlcy9kZWZhdWx0LXBhcmFtcy5qcyIsIi9Vc2Vycy9UcmlzdGFuL2Rldi9Td2VldEFsZXJ0L2Rldi9tb2R1bGVzL2hhbmRsZS1jbGljay5qcyIsIi9Vc2Vycy9UcmlzdGFuL2Rldi9Td2VldEFsZXJ0L2Rldi9tb2R1bGVzL2hhbmRsZS1kb20uanMiLCIvVXNlcnMvVHJpc3Rhbi9kZXYvU3dlZXRBbGVydC9kZXYvbW9kdWxlcy9oYW5kbGUta2V5LmpzIiwiL1VzZXJzL1RyaXN0YW4vZGV2L1N3ZWV0QWxlcnQvZGV2L21vZHVsZXMvaGFuZGxlLXN3YWwtZG9tLmpzIiwiL1VzZXJzL1RyaXN0YW4vZGV2L1N3ZWV0QWxlcnQvZGV2L21vZHVsZXMvaW5qZWN0ZWQtaHRtbC5qcyIsIi9Vc2Vycy9UcmlzdGFuL2Rldi9Td2VldEFsZXJ0L2Rldi9tb2R1bGVzL3NldC1wYXJhbXMuanMiLCIvVXNlcnMvVHJpc3Rhbi9kZXYvU3dlZXRBbGVydC9kZXYvbW9kdWxlcy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztzSkNnQk8sc0JBQXNCOzs7Ozs7MkRBV3RCLGlCQUFpQjs7Ozs7O3dIQWNqQiwyQkFBMkI7Ozs7dURBSXdCLHdCQUF3Qjs7NkJBQ3hELHNCQUFzQjs7Ozs7OzZCQUl0QiwwQkFBMEI7Ozs7NkJBQzFCLHNCQUFzQjs7Ozs7Ozs7QUFNaEQsSUFBSSxxQkFBcUIsQ0FBQztBQUMxQixJQUFJLGlCQUFpQixDQUFDOzs7Ozs7QUFPdEIsSUFBSSxVQUFVLEVBQUUsSUFBSSxDQUFDOztxQkFFTixVQUFVLEdBQUcsSUFBSSxHQUFHLFlBQVc7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RyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3JFLE9BQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUEsQ0FBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQ3BDOztBQUVELFNBQU8sR0FBRyxDQUFDO0NBQ1osQ0FBQzs7UUFJQSxNQUFNLEdBQU4sTUFBTTtRQUNOLFFBQVEsR0FBUixRQUFRO1FBQ1IsS0FBSyxHQUFMLEtBQUs7UUFDTCxNQUFNLEdBQU4sTUFBTTtRQUNOLGNBQWMsR0FBZCxjQUFjIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIFN3ZWV0QWxlcnRcbi8vIDIwMTQtMjAxNSAoYykgLSBUcmlzdGFuIEVkd2FyZHNcbi8vIGdpdGh1Yi5jb20vdDR0NS9zd2VldGFsZXJ0XG5cbi8qXG4gKiBqUXVlcnktbGlrZSBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyB0aGUgRE9NXG4gKi9cbmltcG9ydCB7XG4gIGhhc0NsYXNzLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MsXG4gIGVzY2FwZUh0bWwsXG4gIF9zaG93LCBzaG93LCBfaGlkZSwgaGlkZSxcbiAgaXNEZXNjZW5kYW50LFxuICBnZXRUb3BNYXJnaW4sXG4gIGZhZGVJbiwgZmFkZU91dCxcbiAgZmlyZUNsaWNrLFxuICBzdG9wRXZlbnRQcm9wYWdhdGlvblxufSBmcm9tICcuL21vZHVsZXMvaGFuZGxlLWRvbSc7XG5cbi8qXG4gKiBIYW5keSB1dGlsaXRpZXNcbiAqL1xuaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBoZXhUb1JnYixcbiAgaXNJRTgsXG4gIGxvZ1N0cixcbiAgY29sb3JMdW1pbmFuY2Vcbn0gZnJvbSAnLi9tb2R1bGVzL3V0aWxzJztcblxuLypcbiAqICBIYW5kbGUgc3dlZXRBbGVydCdzIERPTSBlbGVtZW50c1xuICovXG5pbXBvcnQge1xuICBzd2VldEFsZXJ0SW5pdGlhbGl6ZSxcbiAgZ2V0TW9kYWwsXG4gIGdldE92ZXJsYXksXG4gIGdldElucHV0LFxuICBzZXRGb2N1c1N0eWxlLFxuICBvcGVuTW9kYWwsXG4gIHJlc2V0SW5wdXQsXG4gIGZpeFZlcnRpY2FsUG9zaXRpb25cbn0gZnJvbSAnLi9tb2R1bGVzL2hhbmRsZS1zd2FsLWRvbSc7XG5cblxuLy8gSGFuZGxlIGJ1dHRvbiBldmVudHMgYW5kIGtleWJvYXJkIGV2ZW50c1xuaW1wb3J0IHsgaGFuZGxlQnV0dG9uLCBoYW5kbGVDb25maXJtLCBoYW5kbGVDYW5jZWwgfSBmcm9tICcuL21vZHVsZXMvaGFuZGxlLWNsaWNrJztcbmltcG9ydCBoYW5kbGVLZXlEb3duIGZyb20gJy4vbW9kdWxlcy9oYW5kbGUta2V5JztcblxuXG4vLyBEZWZhdWx0IHZhbHVlc1xuaW1wb3J0IGRlZmF1bHRQYXJhbXMgZnJvbSAnLi9tb2R1bGVzL2RlZmF1bHQtcGFyYW1zJztcbmltcG9ydCBzZXRQYXJhbWV0ZXJzIGZyb20gJy4vbW9kdWxlcy9zZXQtcGFyYW1zJztcblxuLypcbiAqIFJlbWVtYmVyIHN0YXRlIGluIGNhc2VzIHdoZXJlIG9wZW5pbmcgYW5kIGhhbmRsaW5nIGEgbW9kYWwgd2lsbCBmaWRkbGUgd2l0aCBpdC5cbiAqIChXZSBhbHNvIHVzZSB3aW5kb3cucHJldmlvdXNBY3RpdmVFbGVtZW50IGFzIGEgZ2xvYmFsIHZhcmlhYmxlKVxuICovXG52YXIgcHJldmlvdXNXaW5kb3dLZXlEb3duO1xudmFyIGxhc3RGb2N1c2VkQnV0dG9uO1xuXG5cbi8qXG4gKiBHbG9iYWwgc3dlZXRBbGVydCBmdW5jdGlvblxuICogKHRoaXMgaXMgd2hhdCB0aGUgdXNlciBjYWxscylcbiAqL1xudmFyIHN3ZWV0QWxlcnQsIHN3YWw7XG5cbmV4cG9ydCBkZWZhdWx0IHN3ZWV0QWxlcnQgPSBzd2FsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXN0b21pemF0aW9ucyA9IGFyZ3VtZW50c1swXTtcblxuICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnc3RvcC1zY3JvbGxpbmcnKTtcbiAgcmVzZXRJbnB1dCgpO1xuXG4gIC8qXG4gICAqIFVzZSBhcmd1bWVudCBpZiBkZWZpbmVkIG9yIGRlZmF1bHQgdmFsdWUgZnJvbSBwYXJhbXMgb2JqZWN0IG90aGVyd2lzZS5cbiAgICogU3VwcG9ydHMgdGhlIGNhc2Ugd2hlcmUgYSBkZWZhdWx0IHZhbHVlIGlzIGJvb2xlYW4gdHJ1ZSBhbmQgc2hvdWxkIGJlXG4gICAqIG92ZXJyaWRkZW4gYnkgYSBjb3JyZXNwb25kaW5nIGV4cGxpY2l0IGFyZ3VtZW50IHdoaWNoIGlzIGJvb2xlYW4gZmFsc2UuXG4gICAqL1xuICBmdW5jdGlvbiBhcmd1bWVudE9yRGVmYXVsdChrZXkpIHtcbiAgICB2YXIgYXJncyA9IGN1c3RvbWl6YXRpb25zO1xuICAgIHJldHVybiAoYXJnc1trZXldID09PSB1bmRlZmluZWQpID8gIGRlZmF1bHRQYXJhbXNba2V5XSA6IGFyZ3Nba2V5XTtcbiAgfVxuXG4gIGlmIChjdXN0b21pemF0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbG9nU3RyKCdTd2VldEFsZXJ0IGV4cGVjdHMgYXQgbGVhc3QgMSBhdHRyaWJ1dGUhJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdFBhcmFtcyk7XG5cbiAgc3dpdGNoICh0eXBlb2YgY3VzdG9taXphdGlvbnMpIHtcblxuICAgIC8vIEV4OiBzd2FsKFwiSGVsbG9cIiwgXCJKdXN0IHRlc3RpbmdcIiwgXCJpbmZvXCIpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwYXJhbXMudGl0bGUgPSBjdXN0b21pemF0aW9ucztcbiAgICAgIHBhcmFtcy50ZXh0ICA9IGFyZ3VtZW50c1sxXSB8fCAnJztcbiAgICAgIHBhcmFtcy50eXBlICA9IGFyZ3VtZW50c1syXSB8fCAnJztcbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gRXg6IHN3YWwoeyB0aXRsZTpcIkhlbGxvXCIsIHRleHQ6IFwiSnVzdCB0ZXN0aW5nXCIsIHR5cGU6IFwiaW5mb1wiIH0pO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoY3VzdG9taXphdGlvbnMudGl0bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dTdHIoJ01pc3NpbmcgXCJ0aXRsZVwiIGFyZ3VtZW50IScpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHBhcmFtcy50aXRsZSA9IGN1c3RvbWl6YXRpb25zLnRpdGxlO1xuXG4gICAgICBmb3IgKGxldCBjdXN0b21OYW1lIGluIGRlZmF1bHRQYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zW2N1c3RvbU5hbWVdID0gYXJndW1lbnRPckRlZmF1bHQoY3VzdG9tTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3cgXCJDb25maXJtXCIgaW5zdGVhZCBvZiBcIk9LXCIgaWYgY2FuY2VsIGJ1dHRvbiBpcyB2aXNpYmxlXG4gICAgICBwYXJhbXMuY29uZmlybUJ1dHRvblRleHQgPSBwYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbiA/ICdDb25maXJtJyA6IGRlZmF1bHRQYXJhbXMuY29uZmlybUJ1dHRvblRleHQ7XG4gICAgICBwYXJhbXMuY29uZmlybUJ1dHRvblRleHQgPSBhcmd1bWVudE9yRGVmYXVsdCgnY29uZmlybUJ1dHRvblRleHQnKTtcblxuICAgICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBjbGlja2luZyBvbiBcIk9LXCIvXCJDYW5jZWxcIlxuICAgICAgcGFyYW1zLmRvbmVGdW5jdGlvbiA9IGFyZ3VtZW50c1sxXSB8fCBudWxsO1xuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dTdHIoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBhcmd1bWVudCEgRXhwZWN0ZWQgXCJzdHJpbmdcIiBvciBcIm9iamVjdFwiLCBnb3QgJyArIHR5cGVvZiBjdXN0b21pemF0aW9ucyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgfVxuXG4gIHNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgZml4VmVydGljYWxQb3NpdGlvbigpO1xuICBvcGVuTW9kYWwoYXJndW1lbnRzWzFdKTtcblxuICAvLyBNb2RhbCBpbnRlcmFjdGlvbnNcbiAgdmFyIG1vZGFsID0gZ2V0TW9kYWwoKTtcblxuXG4gIC8qXG4gICAqIE1ha2Ugc3VyZSBhbGwgbW9kYWwgYnV0dG9ucyByZXNwb25kIHRvIGFsbCBldmVudHNcbiAgICovXG4gIHZhciAkYnV0dG9ucyA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuICB2YXIgYnV0dG9uRXZlbnRzID0gWydvbmNsaWNrJywgJ29ubW91c2VvdmVyJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZXVwJywgJ29uZm9jdXMnXTtcbiAgdmFyIG9uQnV0dG9uRXZlbnQgPSAoZSkgPT4gaGFuZGxlQnV0dG9uKGUsIHBhcmFtcywgbW9kYWwpO1xuXG4gIGZvciAobGV0IGJ0bkluZGV4ID0gMDsgYnRuSW5kZXggPCAkYnV0dG9ucy5sZW5ndGg7IGJ0bkluZGV4KyspIHtcbiAgICBmb3IgKGxldCBldnRJbmRleCA9IDA7IGV2dEluZGV4IDwgYnV0dG9uRXZlbnRzLmxlbmd0aDsgZXZ0SW5kZXgrKykge1xuICAgICAgbGV0IGJ0bkV2dCA9IGJ1dHRvbkV2ZW50c1tldnRJbmRleF07XG4gICAgICAkYnV0dG9uc1tidG5JbmRleF1bYnRuRXZ0XSA9IG9uQnV0dG9uRXZlbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xpY2tpbmcgb3V0c2lkZSB0aGUgbW9kYWwgZGlzbWlzc2VzIGl0IChpZiBhbGxvd2VkIGJ5IHVzZXIpXG4gIGdldE92ZXJsYXkoKS5vbmNsaWNrID0gb25CdXR0b25FdmVudDtcblxuICBwcmV2aW91c1dpbmRvd0tleURvd24gPSB3aW5kb3cub25rZXlkb3duO1xuXG4gIHZhciBvbktleUV2ZW50ID0gKGUpID0+IGhhbmRsZUtleURvd24oZSwgcGFyYW1zLCBtb2RhbCk7XG4gIHdpbmRvdy5vbmtleWRvd24gPSBvbktleUV2ZW50O1xuXG4gIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdoZW4gdGhlIHVzZXIgaGFzIGZvY3VzZWQgYXdheSBhbmQgZm9jdXNlZCBiYWNrIGZyb20gdGhlIHdob2xlIHdpbmRvdy5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFB1dCBpbiBhIHRpbWVvdXQgdG8ganVtcCBvdXQgb2YgdGhlIGV2ZW50IHNlcXVlbmNlLlxuICAgICAgLy8gQ2FsbGluZyBmb2N1cygpIGluIHRoZSBldmVudCBzZXF1ZW5jZSBjb25mdXNlcyB0aGluZ3MuXG4gICAgICBpZiAobGFzdEZvY3VzZWRCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYXN0Rm9jdXNlZEJ1dHRvbi5mb2N1cygpO1xuICAgICAgICBsYXN0Rm9jdXNlZEJ1dHRvbiA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfTtcbiAgXG4gIC8vIFNob3cgYWxlcnQgd2l0aCBlbmFibGVkIGJ1dHRvbnMgYWx3YXlzXG4gIHN3YWwuZW5hYmxlQnV0dG9ucygpO1xufTtcblxuXG5cbi8qXG4gKiBTZXQgZGVmYXVsdCBwYXJhbXMgZm9yIGVhY2ggcG9wdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyUGFyYW1zXG4gKi9cbnN3ZWV0QWxlcnQuc2V0RGVmYXVsdHMgPSBzd2FsLnNldERlZmF1bHRzID0gZnVuY3Rpb24odXNlclBhcmFtcykge1xuICBpZiAoIXVzZXJQYXJhbXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJQYXJhbXMgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBpZiAodHlwZW9mIHVzZXJQYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFyYW1zIGhhcyB0byBiZSBhIG9iamVjdCcpO1xuICB9XG5cbiAgZXh0ZW5kKGRlZmF1bHRQYXJhbXMsIHVzZXJQYXJhbXMpO1xufTtcblxuXG4vKlxuICogQW5pbWF0aW9uIHdoZW4gY2xvc2luZyBtb2RhbFxuICovXG5zd2VldEFsZXJ0LmNsb3NlID0gc3dhbC5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbW9kYWwgPSBnZXRNb2RhbCgpO1xuXG4gIGZhZGVPdXQoZ2V0T3ZlcmxheSgpLCA1KTtcbiAgZmFkZU91dChtb2RhbCwgNSk7XG4gIHJlbW92ZUNsYXNzKG1vZGFsLCAnc2hvd1N3ZWV0QWxlcnQnKTtcbiAgYWRkQ2xhc3MobW9kYWwsICdoaWRlU3dlZXRBbGVydCcpO1xuICByZW1vdmVDbGFzcyhtb2RhbCwgJ3Zpc2libGUnKTtcblxuICAvKlxuICAgKiBSZXNldCBpY29uIGFuaW1hdGlvbnNcbiAgICovXG4gIHZhciAkc3VjY2Vzc0ljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaWNvbi5zYS1zdWNjZXNzJyk7XG4gIHJlbW92ZUNsYXNzKCRzdWNjZXNzSWNvbiwgJ2FuaW1hdGUnKTtcbiAgcmVtb3ZlQ2xhc3MoJHN1Y2Nlc3NJY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS10aXAnKSwgJ2FuaW1hdGVTdWNjZXNzVGlwJyk7XG4gIHJlbW92ZUNsYXNzKCRzdWNjZXNzSWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtbG9uZycpLCAnYW5pbWF0ZVN1Y2Nlc3NMb25nJyk7XG5cbiAgdmFyICRlcnJvckljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaWNvbi5zYS1lcnJvcicpO1xuICByZW1vdmVDbGFzcygkZXJyb3JJY29uLCAnYW5pbWF0ZUVycm9ySWNvbicpO1xuICByZW1vdmVDbGFzcygkZXJyb3JJY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS14LW1hcmsnKSwgJ2FuaW1hdGVYTWFyaycpO1xuXG4gIHZhciAkd2FybmluZ0ljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaWNvbi5zYS13YXJuaW5nJyk7XG4gIHJlbW92ZUNsYXNzKCR3YXJuaW5nSWNvbiwgJ3B1bHNlV2FybmluZycpO1xuICByZW1vdmVDbGFzcygkd2FybmluZ0ljb24ucXVlcnlTZWxlY3RvcignLnNhLWJvZHknKSwgJ3B1bHNlV2FybmluZ0lucycpO1xuICByZW1vdmVDbGFzcygkd2FybmluZ0ljb24ucXVlcnlTZWxlY3RvcignLnNhLWRvdCcpLCAncHVsc2VXYXJuaW5nSW5zJyk7XG5cbiAgLy8gUmVzZXQgY3VzdG9tIGNsYXNzIChkZWxheSBzbyB0aGF0IFVJIGNoYW5nZXMgYXJlbid0IHZpc2libGUpXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1c3RvbUNsYXNzID0gbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWN1c3RvbS1jbGFzcycpO1xuICAgIHJlbW92ZUNsYXNzKG1vZGFsLCBjdXN0b21DbGFzcyk7XG4gIH0sIDMwMCk7XG5cbiAgLy8gTWFrZSBwYWdlIHNjcm9sbGFibGUgYWdhaW5cbiAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3N0b3Atc2Nyb2xsaW5nJyk7XG5cbiAgLy8gUmVzZXQgdGhlIHBhZ2UgdG8gaXRzIHByZXZpb3VzIHN0YXRlXG4gIHdpbmRvdy5vbmtleWRvd24gPSBwcmV2aW91c1dpbmRvd0tleURvd247XG4gIGlmICh3aW5kb3cucHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XG4gICAgd2luZG93LnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gIGxhc3RGb2N1c2VkQnV0dG9uID0gdW5kZWZpbmVkO1xuICBjbGVhclRpbWVvdXQobW9kYWwudGltZW91dCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qXG4gKiBWYWxpZGF0aW9uIG9mIHRoZSBpbnB1dCBmaWVsZCBpcyBkb25lIGJ5IHVzZXJcbiAqIElmIHNvbWV0aGluZyBpcyB3cm9uZyA9PiBjYWxsIHNob3dJbnB1dEVycm9yIHdpdGggZXJyb3JNZXNzYWdlXG4gKi9cbnN3ZWV0QWxlcnQuc2hvd0lucHV0RXJyb3IgPSBzd2FsLnNob3dJbnB1dEVycm9yID0gZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gIHZhciBtb2RhbCA9IGdldE1vZGFsKCk7XG5cbiAgdmFyICRlcnJvckljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaW5wdXQtZXJyb3InKTtcbiAgYWRkQ2xhc3MoJGVycm9ySWNvbiwgJ3Nob3cnKTtcblxuICB2YXIgJGVycm9yQ29udGFpbmVyID0gbW9kYWwucXVlcnlTZWxlY3RvcignLnNhLWVycm9yLWNvbnRhaW5lcicpO1xuICBhZGRDbGFzcygkZXJyb3JDb250YWluZXIsICdzaG93Jyk7XG5cbiAgJGVycm9yQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3AnKS5pbm5lckhUTUwgPSBlcnJvck1lc3NhZ2U7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzd2VldEFsZXJ0LmVuYWJsZUJ1dHRvbnMoKTtcbiAgfSwgMSk7XG5cbiAgbW9kYWwucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpO1xufTtcblxuXG4vKlxuICogUmVzZXQgaW5wdXQgZXJyb3IgRE9NIGVsZW1lbnRzXG4gKi9cbnN3ZWV0QWxlcnQucmVzZXRJbnB1dEVycm9yID0gc3dhbC5yZXNldElucHV0RXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAvLyBJZiBwcmVzcyBlbnRlciA9PiBpZ25vcmVcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyICRtb2RhbCA9IGdldE1vZGFsKCk7XG5cbiAgdmFyICRlcnJvckljb24gPSAkbW9kYWwucXVlcnlTZWxlY3RvcignLnNhLWlucHV0LWVycm9yJyk7XG4gIHJlbW92ZUNsYXNzKCRlcnJvckljb24sICdzaG93Jyk7XG5cbiAgdmFyICRlcnJvckNvbnRhaW5lciA9ICRtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtZXJyb3ItY29udGFpbmVyJyk7XG4gIHJlbW92ZUNsYXNzKCRlcnJvckNvbnRhaW5lciwgJ3Nob3cnKTtcbn07XG5cbi8qXG4gKiBEaXNhYmxlIGNvbmZpcm0gYW5kIGNhbmNlbCBidXR0b25zXG4gKi9cbnN3ZWV0QWxlcnQuZGlzYWJsZUJ1dHRvbnMgPSBzd2FsLmRpc2FibGVCdXR0b25zID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIG1vZGFsID0gZ2V0TW9kYWwoKTtcbiAgdmFyICRjb25maXJtQnV0dG9uID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNvbmZpcm0nKTtcbiAgdmFyICRjYW5jZWxCdXR0b24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY2FuY2VsJyk7XG4gICRjb25maXJtQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgJGNhbmNlbEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG59O1xuXG4vKlxuICogRW5hYmxlIGNvbmZpcm0gYW5kIGNhbmNlbCBidXR0b25zXG4gKi9cbnN3ZWV0QWxlcnQuZW5hYmxlQnV0dG9ucyA9IHN3YWwuZW5hYmxlQnV0dG9ucyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciBtb2RhbCA9IGdldE1vZGFsKCk7XG4gIHZhciAkY29uZmlybUJ1dHRvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XG4gIHZhciAkY2FuY2VsQnV0dG9uID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNhbmNlbCcpO1xuICAkY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAkY2FuY2VsQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gVGhlICdoYW5kbGUtY2xpY2snIG1vZHVsZSByZXF1aXJlc1xuICAvLyB0aGF0ICdzd2VldEFsZXJ0JyB3YXMgc2V0IGFzIGdsb2JhbC5cbiAgd2luZG93LnN3ZWV0QWxlcnQgPSB3aW5kb3cuc3dhbCA9IHN3ZWV0QWxlcnQ7XG59IGVsc2Uge1xuICBsb2dTdHIoJ1N3ZWV0QWxlcnQgaXMgYSBmcm9udGVuZCBtb2R1bGUhJyk7XG59XG4iLCJ2YXIgZGVmYXVsdFBhcmFtcyA9IHtcbiAgdGl0bGU6ICcnLFxuICB0ZXh0OiAnJyxcbiAgdHlwZTogbnVsbCxcbiAgYWxsb3dPdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICBzaG93Q29uZmlybUJ1dHRvbjogdHJ1ZSxcbiAgc2hvd0NhbmNlbEJ1dHRvbjogZmFsc2UsXG4gIGNsb3NlT25Db25maXJtOiB0cnVlLFxuICBjbG9zZU9uQ2FuY2VsOiB0cnVlLFxuICBjb25maXJtQnV0dG9uVGV4dDogJ09LJyxcbiAgY29uZmlybUJ1dHRvbkNvbG9yOiAnIzhDRDRGNScsXG4gIGNhbmNlbEJ1dHRvblRleHQ6ICdDYW5jZWwnLFxuICBpbWFnZVVybDogbnVsbCxcbiAgaW1hZ2VTaXplOiBudWxsLFxuICB0aW1lcjogbnVsbCxcbiAgY3VzdG9tQ2xhc3M6ICcnLFxuICBodG1sOiBmYWxzZSxcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBhbGxvd0VzY2FwZUtleTogdHJ1ZSxcbiAgaW5wdXRUeXBlOiAndGV4dCcsXG4gIGlucHV0UGxhY2Vob2xkZXI6ICcnLFxuICBpbnB1dFZhbHVlOiAnJyxcbiAgc2hvd0xvYWRlck9uQ29uZmlybTogZmFsc2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRQYXJhbXM7XG4iLCJpbXBvcnQgeyBjb2xvckx1bWluYW5jZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0TW9kYWwgfSBmcm9tICcuL2hhbmRsZS1zd2FsLWRvbSc7XG5pbXBvcnQgeyBoYXNDbGFzcywgaXNEZXNjZW5kYW50IH0gZnJvbSAnLi9oYW5kbGUtZG9tJztcblxuXG4vKlxuICogVXNlciBjbGlja2VkIG9uIFwiQ29uZmlybVwiL1wiT0tcIiBvciBcIkNhbmNlbFwiXG4gKi9cbnZhciBoYW5kbGVCdXR0b24gPSBmdW5jdGlvbihldmVudCwgcGFyYW1zLCBtb2RhbCkge1xuICB2YXIgZSA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuICB2YXIgdGFyZ2V0ZWRDb25maXJtID0gdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCdjb25maXJtJykgIT09IC0xO1xuICB2YXIgdGFyZ2V0ZWRPdmVybGF5ID0gdGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKCdzd2VldC1vdmVybGF5JykgIT09IC0xO1xuICB2YXIgbW9kYWxJc1Zpc2libGUgID0gaGFzQ2xhc3MobW9kYWwsICd2aXNpYmxlJyk7XG4gIHZhciBkb25lRnVuY3Rpb25FeGlzdHMgPSAocGFyYW1zLmRvbmVGdW5jdGlvbiAmJiBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFzLWRvbmUtZnVuY3Rpb24nKSA9PT0gJ3RydWUnKTtcblxuICAvLyBTaW5jZSB0aGUgdXNlciBjYW4gY2hhbmdlIHRoZSBiYWNrZ3JvdW5kLWNvbG9yIG9mIHRoZSBjb25maXJtIGJ1dHRvbiBwcm9ncmFtbWF0aWNhbGx5LFxuICAvLyB3ZSBtdXN0IGNhbGN1bGF0ZSB3aGF0IHRoZSBjb2xvciBzaG91bGQgYmUgb24gaG92ZXIvYWN0aXZlXG4gIHZhciBub3JtYWxDb2xvciwgaG92ZXJDb2xvciwgYWN0aXZlQ29sb3I7XG4gIGlmICh0YXJnZXRlZENvbmZpcm0gJiYgcGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcikge1xuICAgIG5vcm1hbENvbG9yICA9IHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3I7XG4gICAgaG92ZXJDb2xvciAgID0gY29sb3JMdW1pbmFuY2Uobm9ybWFsQ29sb3IsIC0wLjA0KTtcbiAgICBhY3RpdmVDb2xvciAgPSBjb2xvckx1bWluYW5jZShub3JtYWxDb2xvciwgLTAuMTQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkU2V0Q29uZmlybUJ1dHRvbkNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRhcmdldGVkQ29uZmlybSAmJiBwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XG4gICAgICB0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAgc2hvdWxkU2V0Q29uZmlybUJ1dHRvbkNvbG9yKGhvdmVyQ29sb3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBzaG91bGRTZXRDb25maXJtQnV0dG9uQ29sb3Iobm9ybWFsQ29sb3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgc2hvdWxkU2V0Q29uZmlybUJ1dHRvbkNvbG9yKGFjdGl2ZUNvbG9yKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICBzaG91bGRTZXRDb25maXJtQnV0dG9uQ29sb3IoaG92ZXJDb2xvcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgIGxldCAkY29uZmlybUJ1dHRvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XG4gICAgICBsZXQgJGNhbmNlbEJ1dHRvbiAgPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY2FuY2VsJyk7XG5cbiAgICAgIGlmICh0YXJnZXRlZENvbmZpcm0pIHtcbiAgICAgICAgJGNhbmNlbEJ1dHRvbi5zdHlsZS5ib3hTaGFkb3cgPSAnbm9uZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkY29uZmlybUJ1dHRvbi5zdHlsZS5ib3hTaGFkb3cgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgIGxldCBjbGlja2VkT25Nb2RhbCA9IChtb2RhbCA9PT0gdGFyZ2V0KTtcbiAgICAgIGxldCBjbGlja2VkT25Nb2RhbENoaWxkID0gaXNEZXNjZW5kYW50KG1vZGFsLCB0YXJnZXQpO1xuXG4gICAgICAvLyBJZ25vcmUgY2xpY2sgb3V0c2lkZSBpZiBhbGxvd091dHNpZGVDbGljayBpcyBmYWxzZVxuICAgICAgaWYgKCFjbGlja2VkT25Nb2RhbCAmJiAhY2xpY2tlZE9uTW9kYWxDaGlsZCAmJiBtb2RhbElzVmlzaWJsZSAmJiAhcGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0ZWRDb25maXJtICYmIGRvbmVGdW5jdGlvbkV4aXN0cyAmJiBtb2RhbElzVmlzaWJsZSkge1xuICAgICAgICBoYW5kbGVDb25maXJtKG1vZGFsLCBwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChkb25lRnVuY3Rpb25FeGlzdHMgJiYgbW9kYWxJc1Zpc2libGUgfHwgdGFyZ2V0ZWRPdmVybGF5KSB7XG4gICAgICAgIGhhbmRsZUNhbmNlbChtb2RhbCwgcGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KG1vZGFsLCB0YXJnZXQpICYmIHRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJykge1xuICAgICAgICBzd2VldEFsZXJ0LmNsb3NlKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLypcbiAqICBVc2VyIGNsaWNrZWQgb24gXCJDb25maXJtXCIvXCJPS1wiXG4gKi9cbnZhciBoYW5kbGVDb25maXJtID0gZnVuY3Rpb24obW9kYWwsIHBhcmFtcykge1xuICB2YXIgY2FsbGJhY2tWYWx1ZSA9IHRydWU7XG5cbiAgaWYgKGhhc0NsYXNzKG1vZGFsLCAnc2hvdy1pbnB1dCcpKSB7XG4gICAgY2FsbGJhY2tWYWx1ZSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykudmFsdWU7XG5cbiAgICBpZiAoIWNhbGxiYWNrVmFsdWUpIHtcbiAgICAgIGNhbGxiYWNrVmFsdWUgPSAnJztcbiAgICB9XG4gIH1cblxuICBwYXJhbXMuZG9uZUZ1bmN0aW9uKGNhbGxiYWNrVmFsdWUpO1xuXG4gIGlmIChwYXJhbXMuY2xvc2VPbkNvbmZpcm0pIHtcbiAgICBzd2VldEFsZXJ0LmNsb3NlKCk7XG4gIH1cbiAgLy8gRGlzYWJsZSBjYW5jZWwgYW5kIGNvbmZpcm0gYnV0dG9uIGlmIHRoZSBwYXJhbWV0ZXIgaXMgdHJ1ZVxuICBpZiAocGFyYW1zLnNob3dMb2FkZXJPbkNvbmZpcm0pIHtcbiAgICBzd2VldEFsZXJ0LmRpc2FibGVCdXR0b25zKCk7XG4gIH1cbn07XG5cbi8qXG4gKiAgVXNlciBjbGlja2VkIG9uIFwiQ2FuY2VsXCJcbiAqL1xudmFyIGhhbmRsZUNhbmNlbCA9IGZ1bmN0aW9uKG1vZGFsLCBwYXJhbXMpIHtcbiAgLy8gQ2hlY2sgaWYgY2FsbGJhY2sgZnVuY3Rpb24gZXhwZWN0cyBhIHBhcmFtZXRlciAodG8gdHJhY2sgY2FuY2VsIGFjdGlvbnMpXG4gIHZhciBmdW5jdGlvbkFzU3RyID0gU3RyaW5nKHBhcmFtcy5kb25lRnVuY3Rpb24pLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gIHZhciBmdW5jdGlvbkhhbmRsZXNDYW5jZWwgPSBmdW5jdGlvbkFzU3RyLnN1YnN0cmluZygwLCA5KSA9PT0gJ2Z1bmN0aW9uKCcgJiYgZnVuY3Rpb25Bc1N0ci5zdWJzdHJpbmcoOSwgMTApICE9PSAnKSc7XG5cbiAgaWYgKGZ1bmN0aW9uSGFuZGxlc0NhbmNlbCkge1xuICAgIHBhcmFtcy5kb25lRnVuY3Rpb24oZmFsc2UpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5jbG9zZU9uQ2FuY2VsKSB7XG4gICAgc3dlZXRBbGVydC5jbG9zZSgpO1xuICB9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaGFuZGxlQnV0dG9uLFxuICBoYW5kbGVDb25maXJtLFxuICBoYW5kbGVDYW5jZWxcbn07XG4iLCJ2YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyAnICsgY2xhc3NOYW1lICsgJyAnKS50ZXN0KCcgJyArIGVsZW0uY2xhc3NOYW1lICsgJyAnKTtcbn07XG5cbnZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICBpZiAoIWhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkpIHtcbiAgICBlbGVtLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gIH1cbn07XG5cbnZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICB2YXIgbmV3Q2xhc3MgPSAnICcgKyBlbGVtLmNsYXNzTmFtZS5yZXBsYWNlKC9bXFx0XFxyXFxuXS9nLCAnICcpICsgJyAnO1xuICBpZiAoaGFzQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSkge1xuICAgIHdoaWxlIChuZXdDbGFzcy5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPj0gMCkge1xuICAgICAgbmV3Q2xhc3MgPSBuZXdDbGFzcy5yZXBsYWNlKCcgJyArIGNsYXNzTmFtZSArICcgJywgJyAnKTtcbiAgICB9XG4gICAgZWxlbS5jbGFzc05hbWUgPSBuZXdDbGFzcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH1cbn07XG5cbnZhciBlc2NhcGVIdG1sID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cikpO1xuICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn07XG5cbnZhciBfc2hvdyA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgZWxlbS5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG59O1xuXG52YXIgc2hvdyA9IGZ1bmN0aW9uKGVsZW1zKSB7XG4gIGlmIChlbGVtcyAmJiAhZWxlbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIF9zaG93KGVsZW1zKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgX3Nob3coZWxlbXNbaV0pO1xuICB9XG59O1xuXG52YXIgX2hpZGUgPSBmdW5jdGlvbihlbGVtKSB7XG4gIGVsZW0uc3R5bGUub3BhY2l0eSA9ICcnO1xuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuXG52YXIgaGlkZSA9IGZ1bmN0aW9uKGVsZW1zKSB7XG4gIGlmIChlbGVtcyAmJiAhZWxlbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIF9oaWRlKGVsZW1zKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgX2hpZGUoZWxlbXNbaV0pO1xuICB9XG59O1xuXG52YXIgaXNEZXNjZW5kYW50ID0gZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuICB2YXIgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGdldFRvcE1hcmdpbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgZWxlbS5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gIHZhciBoZWlnaHQgPSBlbGVtLmNsaWVudEhlaWdodCxcbiAgICAgIHBhZGRpbmc7XG4gIGlmICh0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gXCJ1bmRlZmluZWRcIikgeyAvLyBJRSA4XG4gICAgcGFkZGluZyA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZWxlbSkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApO1xuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSBwYXJzZUludChlbGVtLmN1cnJlbnRTdHlsZS5wYWRkaW5nKTtcbiAgfVxuXG4gIGVsZW0uc3R5bGUubGVmdCA9ICcnO1xuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJldHVybiAoJy0nICsgcGFyc2VJbnQoKGhlaWdodCArIHBhZGRpbmcpIC8gMikgKyAncHgnKTtcbn07XG5cbnZhciBmYWRlSW4gPSBmdW5jdGlvbihlbGVtLCBpbnRlcnZhbCkge1xuICBpZiAoK2VsZW0uc3R5bGUub3BhY2l0eSA8IDEpIHtcbiAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDE2O1xuICAgIGVsZW0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtLnN0eWxlLm9wYWNpdHkgPSArZWxlbS5zdHlsZS5vcGFjaXR5ICsgKG5ldyBEYXRlKCkgLSBsYXN0KSAvIDEwMDtcbiAgICAgIGxhc3QgPSArbmV3IERhdGUoKTtcblxuICAgICAgaWYgKCtlbGVtLnN0eWxlLm9wYWNpdHkgPCAxKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGljaywgaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGljaygpO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vZmFsbGJhY2sgSUU4XG59O1xuXG52YXIgZmFkZU91dCA9IGZ1bmN0aW9uKGVsZW0sIGludGVydmFsKSB7XG4gIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMTY7XG4gIGVsZW0uc3R5bGUub3BhY2l0eSA9IDE7XG4gIHZhciBsYXN0ID0gK25ldyBEYXRlKCk7XG4gIHZhciB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgZWxlbS5zdHlsZS5vcGFjaXR5ID0gK2VsZW0uc3R5bGUub3BhY2l0eSAtIChuZXcgRGF0ZSgpIC0gbGFzdCkgLyAxMDA7XG4gICAgbGFzdCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKCtlbGVtLnN0eWxlLm9wYWNpdHkgPiAwKSB7XG4gICAgICBzZXRUaW1lb3V0KHRpY2ssIGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgfTtcbiAgdGljaygpO1xufTtcblxudmFyIGZpcmVDbGljayA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3Lm5vbm9idHJ1c2l2ZS5jb20vMjAxMS8xMS8yOS9wcm9ncmFtYXRpY2FsbHktZmlyZS1jcm9zc2Jyb3dzZXItY2xpY2stZXZlbnQtd2l0aC1qYXZhc2NyaXB0L1xuICAvLyBUaGVuIGZpeGVkIGZvciB0b2RheSdzIENocm9tZSBicm93c2VyLlxuICBpZiAodHlwZW9mIE1vdXNlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVcC10by1kYXRlIGFwcHJvYWNoXG4gICAgdmFyIG1ldnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICB2aWV3OiB3aW5kb3csXG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQobWV2dCk7XG4gIH0gZWxzZSBpZiAoIGRvY3VtZW50LmNyZWF0ZUV2ZW50ICkge1xuICAgIC8vIEZhbGxiYWNrXG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuICAgIGV2dC5pbml0RXZlbnQoJ2NsaWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCkge1xuICAgIG5vZGUuZmlyZUV2ZW50KCdvbmNsaWNrJykgO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLm9uY2xpY2sgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgbm9kZS5vbmNsaWNrKCk7XG4gIH1cbn07XG5cbnZhciBzdG9wRXZlbnRQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKGUpIHtcbiAgLy8gSW4gcGFydGljdWxhciwgbWFrZSBzdXJlIHRoZSBzcGFjZSBiYXIgZG9lc24ndCBzY3JvbGwgdGhlIG1haW4gd2luZG93LlxuICBpZiAodHlwZW9mIGUuc3RvcFByb3BhZ2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSBpZiAod2luZG93LmV2ZW50ICYmIHdpbmRvdy5ldmVudC5oYXNPd25Qcm9wZXJ0eSgnY2FuY2VsQnViYmxlJykpIHtcbiAgICB3aW5kb3cuZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgfVxufTtcblxuZXhwb3J0IHsgXG4gIGhhc0NsYXNzLCBhZGRDbGFzcywgcmVtb3ZlQ2xhc3MsIFxuICBlc2NhcGVIdG1sLCBcbiAgX3Nob3csIHNob3csIF9oaWRlLCBoaWRlLCBcbiAgaXNEZXNjZW5kYW50LCBcbiAgZ2V0VG9wTWFyZ2luLFxuICBmYWRlSW4sIGZhZGVPdXQsXG4gIGZpcmVDbGljayxcbiAgc3RvcEV2ZW50UHJvcGFnYXRpb25cbn07XG4iLCJpbXBvcnQgeyBzdG9wRXZlbnRQcm9wYWdhdGlvbiwgZmlyZUNsaWNrIH0gZnJvbSAnLi9oYW5kbGUtZG9tJztcbmltcG9ydCB7IHNldEZvY3VzU3R5bGUgfSBmcm9tICcuL2hhbmRsZS1zd2FsLWRvbSc7XG5cblxudmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbihldmVudCwgcGFyYW1zLCBtb2RhbCkge1xuICB2YXIgZSA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGUgfHwgZS53aGljaDtcblxuICB2YXIgJG9rQnV0dG9uICAgICA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XG4gIHZhciAkY2FuY2VsQnV0dG9uID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNhbmNlbCcpO1xuICB2YXIgJG1vZGFsQnV0dG9ucyA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvblt0YWJpbmRleF0nKTtcblxuXG4gIGlmIChbOSwgMTMsIDMyLCAyN10uaW5kZXhPZihrZXlDb2RlKSA9PT0gLTEpIHtcbiAgICAvLyBEb24ndCBkbyB3b3JrIG9uIGtleXMgd2UgZG9uJ3QgY2FyZSBhYm91dC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgJHRhcmdldEVsZW1lbnQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cbiAgdmFyIGJ0bkluZGV4ID0gLTE7IC8vIEZpbmQgdGhlIGJ1dHRvbiAtIG5vdGUsIHRoaXMgaXMgYSBub2RlbGlzdCwgbm90IGFuIGFycmF5LlxuICBmb3IgKHZhciBpID0gMDsgaSA8ICRtb2RhbEJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoJHRhcmdldEVsZW1lbnQgPT09ICRtb2RhbEJ1dHRvbnNbaV0pIHtcbiAgICAgIGJ0bkluZGV4ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXlDb2RlID09PSA5KSB7XG4gICAgLy8gVEFCXG4gICAgaWYgKGJ0bkluZGV4ID09PSAtMSkge1xuICAgICAgLy8gTm8gYnV0dG9uIGZvY3VzZWQuIEp1bXAgdG8gdGhlIGNvbmZpcm0gYnV0dG9uLlxuICAgICAgJHRhcmdldEVsZW1lbnQgPSAkb2tCdXR0b247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN5Y2xlIHRvIHRoZSBuZXh0IGJ1dHRvblxuICAgICAgaWYgKGJ0bkluZGV4ID09PSAkbW9kYWxCdXR0b25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgJHRhcmdldEVsZW1lbnQgPSAkbW9kYWxCdXR0b25zWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHRhcmdldEVsZW1lbnQgPSAkbW9kYWxCdXR0b25zW2J0bkluZGV4ICsgMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RvcEV2ZW50UHJvcGFnYXRpb24oZSk7XG4gICAgJHRhcmdldEVsZW1lbnQuZm9jdXMoKTtcblxuICAgIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XG4gICAgICBzZXRGb2N1c1N0eWxlKCR0YXJnZXRFbGVtZW50LCBwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBpZiAoJHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAkdGFyZ2V0RWxlbWVudCA9ICRva0J1dHRvbjtcbiAgICAgICAgJG9rQnV0dG9uLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChidG5JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgLy8gRU5URVIvU1BBQ0UgY2xpY2tlZCBvdXRzaWRlIG9mIGEgYnV0dG9uLlxuICAgICAgICAkdGFyZ2V0RWxlbWVudCA9ICRva0J1dHRvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgLSBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIGl0LlxuICAgICAgICAkdGFyZ2V0RWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IDI3ICYmIHBhcmFtcy5hbGxvd0VzY2FwZUtleSA9PT0gdHJ1ZSkge1xuICAgICAgJHRhcmdldEVsZW1lbnQgPSAkY2FuY2VsQnV0dG9uO1xuICAgICAgZmlyZUNsaWNrKCR0YXJnZXRFbGVtZW50LCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgLSBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIGl0LlxuICAgICAgJHRhcmdldEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVLZXlEb3duO1xuIiwiaW1wb3J0IHsgaGV4VG9SZ2IgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHJlbW92ZUNsYXNzLCBnZXRUb3BNYXJnaW4sIGZhZGVJbiwgc2hvdywgYWRkQ2xhc3MgfSBmcm9tICcuL2hhbmRsZS1kb20nO1xuaW1wb3J0IGRlZmF1bHRQYXJhbXMgZnJvbSAnLi9kZWZhdWx0LXBhcmFtcyc7XG5cbnZhciBtb2RhbENsYXNzICAgPSAnLnN3ZWV0LWFsZXJ0JztcbnZhciBvdmVybGF5Q2xhc3MgPSAnLnN3ZWV0LW92ZXJsYXknO1xuXG4vKlxuICogQWRkIG1vZGFsICsgb3ZlcmxheSB0byBET01cbiAqL1xuaW1wb3J0IGluamVjdGVkSFRNTCBmcm9tICcuL2luamVjdGVkLWh0bWwnO1xuXG52YXIgc3dlZXRBbGVydEluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN3ZWV0V3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzd2VldFdyYXAuaW5uZXJIVE1MID0gaW5qZWN0ZWRIVE1MO1xuXG4gIC8vIEFwcGVuZCBlbGVtZW50cyB0byBib2R5XG4gIHdoaWxlIChzd2VldFdyYXAuZmlyc3RDaGlsZCkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3dlZXRXcmFwLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG4vKlxuICogR2V0IERPTSBlbGVtZW50IG9mIG1vZGFsXG4gKi9cbnZhciBnZXRNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgJG1vZGFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihtb2RhbENsYXNzKTtcblxuICBpZiAoISRtb2RhbCkge1xuICAgIHN3ZWV0QWxlcnRJbml0aWFsaXplKCk7XG4gICAgJG1vZGFsID0gZ2V0TW9kYWwoKTtcbiAgfVxuXG4gIHJldHVybiAkbW9kYWw7XG59O1xuXG4vKlxuICogR2V0IERPTSBlbGVtZW50IG9mIGlucHV0IChpbiBtb2RhbClcbiAqL1xudmFyIGdldElucHV0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciAkbW9kYWwgPSBnZXRNb2RhbCgpO1xuICBpZiAoJG1vZGFsKSB7XG4gICAgcmV0dXJuICRtb2RhbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG59O1xuXG4vKlxuICogR2V0IERPTSBlbGVtZW50IG9mIG92ZXJsYXlcbiAqL1xudmFyIGdldE92ZXJsYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3ZlcmxheUNsYXNzKTtcbn07XG5cbi8qXG4gKiBBZGQgYm94LXNoYWRvdyBzdHlsZSB0byBidXR0b24gKGRlcGVuZGluZyBvbiBpdHMgY2hvc2VuIGJnLWNvbG9yKVxuICovXG52YXIgc2V0Rm9jdXNTdHlsZSA9IGZ1bmN0aW9uKCRidXR0b24sIGJnQ29sb3IpIHtcbiAgdmFyIHJnYkNvbG9yID0gaGV4VG9SZ2IoYmdDb2xvcik7XG4gICRidXR0b24uc3R5bGUuYm94U2hhZG93ID0gJzAgMCAycHggcmdiYSgnICsgcmdiQ29sb3IgKyAnLCAwLjgpLCBpbnNldCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjA1KSc7XG59O1xuXG4vKlxuICogQW5pbWF0aW9uIHdoZW4gb3BlbmluZyBtb2RhbFxuICovXG52YXIgb3Blbk1vZGFsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyICRtb2RhbCA9IGdldE1vZGFsKCk7XG4gIGZhZGVJbihnZXRPdmVybGF5KCksIDEwKTtcbiAgc2hvdygkbW9kYWwpO1xuICBhZGRDbGFzcygkbW9kYWwsICdzaG93U3dlZXRBbGVydCcpO1xuICByZW1vdmVDbGFzcygkbW9kYWwsICdoaWRlU3dlZXRBbGVydCcpO1xuXG4gIHdpbmRvdy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB2YXIgJG9rQnV0dG9uID0gJG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XG4gICRva0J1dHRvbi5mb2N1cygpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGFkZENsYXNzKCRtb2RhbCwgJ3Zpc2libGUnKTtcbiAgfSwgNTAwKTtcblxuICB2YXIgdGltZXIgPSAkbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRpbWVyJyk7XG5cbiAgaWYgKHRpbWVyICE9PSAnbnVsbCcgJiYgdGltZXIgIT09ICcnKSB7XG4gICAgdmFyIHRpbWVyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAkbW9kYWwudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZG9uZUZ1bmN0aW9uRXhpc3RzID0gKCh0aW1lckNhbGxiYWNrIHx8IG51bGwpICYmICRtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFzLWRvbmUtZnVuY3Rpb24nKSA9PT0gJ3RydWUnKTtcbiAgICAgIGlmIChkb25lRnVuY3Rpb25FeGlzdHMpIHsgXG4gICAgICAgIHRpbWVyQ2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3dlZXRBbGVydC5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sIHRpbWVyKTtcbiAgfVxufTtcblxuLypcbiAqIFJlc2V0IHRoZSBzdHlsaW5nIG9mIHRoZSBpbnB1dFxuICogKGZvciBleGFtcGxlIGlmIGVycm9ycyBoYXZlIGJlZW4gc2hvd24pXG4gKi9cbnZhciByZXNldElucHV0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciAkbW9kYWwgPSBnZXRNb2RhbCgpO1xuICB2YXIgJGlucHV0ID0gZ2V0SW5wdXQoKTtcblxuICByZW1vdmVDbGFzcygkbW9kYWwsICdzaG93LWlucHV0Jyk7XG4gICRpbnB1dC52YWx1ZSA9IGRlZmF1bHRQYXJhbXMuaW5wdXRWYWx1ZTtcbiAgJGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsIGRlZmF1bHRQYXJhbXMuaW5wdXRUeXBlKTtcbiAgJGlucHV0LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBkZWZhdWx0UGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpO1xuXG4gIHJlc2V0SW5wdXRFcnJvcigpO1xufTtcblxuXG52YXIgcmVzZXRJbnB1dEVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgLy8gSWYgcHJlc3MgZW50ZXIgPT4gaWdub3JlXG4gIGlmIChldmVudCAmJiBldmVudC5rZXlDb2RlID09PSAxMykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciAkbW9kYWwgPSBnZXRNb2RhbCgpO1xuXG4gIHZhciAkZXJyb3JJY29uID0gJG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5zYS1pbnB1dC1lcnJvcicpO1xuICByZW1vdmVDbGFzcygkZXJyb3JJY29uLCAnc2hvdycpO1xuXG4gIHZhciAkZXJyb3JDb250YWluZXIgPSAkbW9kYWwucXVlcnlTZWxlY3RvcignLnNhLWVycm9yLWNvbnRhaW5lcicpO1xuICByZW1vdmVDbGFzcygkZXJyb3JDb250YWluZXIsICdzaG93Jyk7XG59O1xuXG5cbi8qXG4gKiBTZXQgXCJtYXJnaW4tdG9wXCItcHJvcGVydHkgb24gbW9kYWwgYmFzZWQgb24gaXRzIGNvbXB1dGVkIGhlaWdodFxuICovXG52YXIgZml4VmVydGljYWxQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgJG1vZGFsID0gZ2V0TW9kYWwoKTtcbiAgJG1vZGFsLnN0eWxlLm1hcmdpblRvcCA9IGdldFRvcE1hcmdpbihnZXRNb2RhbCgpKTtcbn07XG5cblxuZXhwb3J0IHsgXG4gIHN3ZWV0QWxlcnRJbml0aWFsaXplLFxuICBnZXRNb2RhbCxcbiAgZ2V0T3ZlcmxheSxcbiAgZ2V0SW5wdXQsXG4gIHNldEZvY3VzU3R5bGUsXG4gIG9wZW5Nb2RhbCxcbiAgcmVzZXRJbnB1dCxcbiAgcmVzZXRJbnB1dEVycm9yLFxuICBmaXhWZXJ0aWNhbFBvc2l0aW9uXG59O1xuIiwidmFyIGluamVjdGVkSFRNTCA9IFxuXG4gIC8vIERhcmsgb3ZlcmxheVxuICBgPGRpdiBjbGFzcz1cInN3ZWV0LW92ZXJsYXlcIiB0YWJJbmRleD1cIi0xXCI+PC9kaXY+YCArXG5cbiAgLy8gTW9kYWxcbiAgYDxkaXYgY2xhc3M9XCJzd2VldC1hbGVydFwiPmAgK1xuXG4gICAgLy8gRXJyb3IgaWNvblxuICAgIGA8ZGl2IGNsYXNzPVwic2EtaWNvbiBzYS1lcnJvclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJzYS14LW1hcmtcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzYS1saW5lIHNhLWxlZnRcIj48L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2EtbGluZSBzYS1yaWdodFwiPjwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5gICtcblxuICAgIC8vIFdhcm5pbmcgaWNvblxuICAgIGA8ZGl2IGNsYXNzPVwic2EtaWNvbiBzYS13YXJuaW5nXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInNhLWJvZHlcIj48L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cInNhLWRvdFwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5gICtcblxuICAgIC8vIEluZm8gaWNvblxuICAgIGA8ZGl2IGNsYXNzPVwic2EtaWNvbiBzYS1pbmZvXCI+PC9kaXY+YCArXG5cbiAgICAvLyBTdWNjZXNzIGljb25cbiAgICBgPGRpdiBjbGFzcz1cInNhLWljb24gc2Etc3VjY2Vzc1wiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJzYS1saW5lIHNhLXRpcFwiPjwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwic2EtbGluZSBzYS1sb25nXCI+PC9zcGFuPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwic2EtcGxhY2Vob2xkZXJcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzYS1maXhcIj48L2Rpdj5cbiAgICA8L2Rpdj5gICtcblxuICAgIGA8ZGl2IGNsYXNzPVwic2EtaWNvbiBzYS1jdXN0b21cIj48L2Rpdj5gICtcblxuICAgIC8vIFRpdGxlLCB0ZXh0IGFuZCBpbnB1dFxuICAgIGA8aDI+VGl0bGU8L2gyPlxuICAgIDxwPlRleHQ8L3A+XG4gICAgPGZpZWxkc2V0PlxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdGFiSW5kZXg9XCIzXCIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJzYS1pbnB1dC1lcnJvclwiPjwvZGl2PlxuICAgIDwvZmllbGRzZXQ+YCArXG5cbiAgICAvLyBJbnB1dCBlcnJvcnNcbiAgICBgPGRpdiBjbGFzcz1cInNhLWVycm9yLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImljb25cIj4hPC9kaXY+XG4gICAgICA8cD5Ob3QgdmFsaWQhPC9wPlxuICAgIDwvZGl2PmAgK1xuXG4gICAgLy8gQ2FuY2VsIGFuZCBjb25maXJtIGJ1dHRvbnNcbiAgICBgPGRpdiBjbGFzcz1cInNhLWJ1dHRvbi1jb250YWluZXJcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJjYW5jZWxcIiB0YWJJbmRleD1cIjJcIj5DYW5jZWw8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzYS1jb25maXJtLWJ1dHRvbi1jb250YWluZXJcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNvbmZpcm1cIiB0YWJJbmRleD1cIjFcIj5PSzwvYnV0dG9uPmAgKyBcblxuICAgICAgICAvLyBMb2FkaW5nIGFuaW1hdGlvblxuICAgICAgICBgPGRpdiBjbGFzcz1cImxhLWJhbGwtZmFsbFwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmAgK1xuXG4gIC8vIEVuZCBvZiBtb2RhbFxuICBgPC9kaXY+YDtcblxuZXhwb3J0IGRlZmF1bHQgaW5qZWN0ZWRIVE1MO1xuIiwidmFyIGFsZXJ0VHlwZXMgPSBbJ2Vycm9yJywgJ3dhcm5pbmcnLCAnaW5mbycsICdzdWNjZXNzJywgJ2lucHV0JywgJ3Byb21wdCddO1xuXG5pbXBvcnQge1xuICBpc0lFOFxufSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IHtcbiAgZ2V0TW9kYWwsXG4gIGdldElucHV0LFxuICBzZXRGb2N1c1N0eWxlXG59IGZyb20gJy4vaGFuZGxlLXN3YWwtZG9tJztcblxuaW1wb3J0IHtcbiAgaGFzQ2xhc3MsIGFkZENsYXNzLCByZW1vdmVDbGFzcyxcbiAgZXNjYXBlSHRtbCxcbiAgX3Nob3csIHNob3csIF9oaWRlLCBoaWRlXG59IGZyb20gJy4vaGFuZGxlLWRvbSc7XG5cblxuLypcbiAqIFNldCB0eXBlLCB0ZXh0IGFuZCBhY3Rpb25zIG9uIG1vZGFsXG4gKi9cbnZhciBzZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBtb2RhbCA9IGdldE1vZGFsKCk7XG5cbiAgdmFyICR0aXRsZSA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2gyJyk7XG4gIHZhciAkdGV4dCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ3AnKTtcbiAgdmFyICRjYW5jZWxCdG4gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY2FuY2VsJyk7XG4gIHZhciAkY29uZmlybUJ0biA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XG5cbiAgLypcbiAgICogVGl0bGVcbiAgICovXG4gICR0aXRsZS5pbm5lckhUTUwgPSBwYXJhbXMuaHRtbCA/IHBhcmFtcy50aXRsZSA6IGVzY2FwZUh0bWwocGFyYW1zLnRpdGxlKS5zcGxpdCgnXFxuJykuam9pbignPGJyPicpO1xuXG4gIC8qXG4gICAqIFRleHRcbiAgICovXG4gICR0ZXh0LmlubmVySFRNTCA9IHBhcmFtcy5odG1sID8gcGFyYW1zLnRleHQgOiBlc2NhcGVIdG1sKHBhcmFtcy50ZXh0IHx8ICcnKS5zcGxpdCgnXFxuJykuam9pbignPGJyPicpO1xuICBpZiAocGFyYW1zLnRleHQpIHNob3coJHRleHQpO1xuXG4gIC8qXG4gICAqIEN1c3RvbSBjbGFzc1xuICAgKi9cbiAgaWYgKHBhcmFtcy5jdXN0b21DbGFzcykge1xuICAgIGFkZENsYXNzKG1vZGFsLCBwYXJhbXMuY3VzdG9tQ2xhc3MpO1xuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1jdXN0b20tY2xhc3MnLCBwYXJhbXMuY3VzdG9tQ2xhc3MpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgcHJldmlvdXNseSBzZXQgY2xhc3NlcyBhbmQgcmVtb3ZlIHRoZW1cbiAgICBsZXQgY3VzdG9tQ2xhc3MgPSBtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY3VzdG9tLWNsYXNzJyk7XG4gICAgcmVtb3ZlQ2xhc3MobW9kYWwsIGN1c3RvbUNsYXNzKTtcbiAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY3VzdG9tLWNsYXNzJywgJycpO1xuICB9XG5cbiAgLypcbiAgICogSWNvblxuICAgKi9cbiAgaGlkZShtb2RhbC5xdWVyeVNlbGVjdG9yQWxsKCcuc2EtaWNvbicpKTtcblxuICBpZiAocGFyYW1zLnR5cGUgJiYgIWlzSUU4KCkpIHtcblxuICAgIGxldCB2YWxpZFR5cGUgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxlcnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhcmFtcy50eXBlID09PSBhbGVydFR5cGVzW2ldKSB7XG4gICAgICAgIHZhbGlkVHlwZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBsb2dTdHIoJ1Vua25vd24gYWxlcnQgdHlwZTogJyArIHBhcmFtcy50eXBlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdHlwZXNXaXRoSWNvbnMgPSBbJ3N1Y2Nlc3MnLCAnZXJyb3InLCAnd2FybmluZycsICdpbmZvJ107XG4gICAgbGV0ICRpY29uO1xuXG4gICAgaWYgKHR5cGVzV2l0aEljb25zLmluZGV4T2YocGFyYW1zLnR5cGUpICE9PSAtMSkge1xuICAgICAgJGljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaWNvbi4nICsgJ3NhLScgKyBwYXJhbXMudHlwZSk7XG4gICAgICBzaG93KCRpY29uKTtcbiAgICB9XG5cbiAgICBsZXQgJGlucHV0ID0gZ2V0SW5wdXQoKTtcblxuICAgIC8vIEFuaW1hdGUgaWNvblxuICAgIHN3aXRjaCAocGFyYW1zLnR5cGUpIHtcblxuICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgIGFkZENsYXNzKCRpY29uLCAnYW5pbWF0ZScpO1xuICAgICAgICBhZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtdGlwJyksICdhbmltYXRlU3VjY2Vzc1RpcCcpO1xuICAgICAgICBhZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtbG9uZycpLCAnYW5pbWF0ZVN1Y2Nlc3NMb25nJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIGFkZENsYXNzKCRpY29uLCAnYW5pbWF0ZUVycm9ySWNvbicpO1xuICAgICAgICBhZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EteC1tYXJrJyksICdhbmltYXRlWE1hcmsnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICBhZGRDbGFzcygkaWNvbiwgJ3B1bHNlV2FybmluZycpO1xuICAgICAgICBhZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtYm9keScpLCAncHVsc2VXYXJuaW5nSW5zJyk7XG4gICAgICAgIGFkZENsYXNzKCRpY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS1kb3QnKSwgJ3B1bHNlV2FybmluZ0lucycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgY2FzZSAncHJvbXB0JzpcbiAgICAgICAgJGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsIHBhcmFtcy5pbnB1dFR5cGUpO1xuICAgICAgICAkaW5wdXQudmFsdWUgPSBwYXJhbXMuaW5wdXRWYWx1ZTtcbiAgICAgICAgJGlucHV0LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcik7XG4gICAgICAgIGFkZENsYXNzKG1vZGFsLCAnc2hvdy1pbnB1dCcpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAkaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBzd2FsLnJlc2V0SW5wdXRFcnJvcik7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIEN1c3RvbSBpbWFnZVxuICAgKi9cbiAgaWYgKHBhcmFtcy5pbWFnZVVybCkge1xuICAgIGxldCAkY3VzdG9tSWNvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5zYS1pY29uLnNhLWN1c3RvbScpO1xuXG4gICAgJGN1c3RvbUljb24uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgcGFyYW1zLmltYWdlVXJsICsgJyknO1xuICAgIHNob3coJGN1c3RvbUljb24pO1xuXG4gICAgbGV0IF9pbWdXaWR0aCA9IDgwO1xuICAgIGxldCBfaW1nSGVpZ2h0ID0gODA7XG5cbiAgICBpZiAocGFyYW1zLmltYWdlU2l6ZSkge1xuICAgICAgbGV0IGRpbWVuc2lvbnMgPSBwYXJhbXMuaW1hZ2VTaXplLnRvU3RyaW5nKCkuc3BsaXQoJ3gnKTtcbiAgICAgIGxldCBpbWdXaWR0aCA9IGRpbWVuc2lvbnNbMF07XG4gICAgICBsZXQgaW1nSGVpZ2h0ID0gZGltZW5zaW9uc1sxXTtcblxuICAgICAgaWYgKCFpbWdXaWR0aCB8fCAhaW1nSGVpZ2h0KSB7XG4gICAgICAgIGxvZ1N0cignUGFyYW1ldGVyIGltYWdlU2l6ZSBleHBlY3RzIHZhbHVlIHdpdGggZm9ybWF0IFdJRFRIeEhFSUdIVCwgZ290ICcgKyBwYXJhbXMuaW1hZ2VTaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pbWdXaWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICBfaW1nSGVpZ2h0ID0gaW1nSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgICRjdXN0b21JY29uLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAkY3VzdG9tSWNvbi5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgKyAnd2lkdGg6JyArIF9pbWdXaWR0aCArICdweDsgaGVpZ2h0OicgKyBfaW1nSGVpZ2h0ICsgJ3B4Jyk7XG4gIH1cblxuICAvKlxuICAgKiBTaG93IGNhbmNlbCBidXR0b24/XG4gICAqL1xuICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaGFzLWNhbmNlbC1idXR0b24nLCBwYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbik7XG4gIGlmIChwYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbikge1xuICAgICRjYW5jZWxCdG4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoJGNhbmNlbEJ0bik7XG4gIH1cblxuICAvKlxuICAgKiBTaG93IGNvbmZpcm0gYnV0dG9uP1xuICAgKi9cbiAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWhhcy1jb25maXJtLWJ1dHRvbicsIHBhcmFtcy5zaG93Q29uZmlybUJ1dHRvbik7XG4gIGlmIChwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24pIHtcbiAgICAkY29uZmlybUJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gIH0gZWxzZSB7XG4gICAgaGlkZSgkY29uZmlybUJ0bik7XG4gIH1cblxuICAvKlxuICAgKiBDdXN0b20gdGV4dCBvbiBjYW5jZWwvY29uZmlybSBidXR0b25zXG4gICAqL1xuICBpZiAocGFyYW1zLmNhbmNlbEJ1dHRvblRleHQpIHtcbiAgICAkY2FuY2VsQnRuLmlubmVySFRNTCA9IGVzY2FwZUh0bWwocGFyYW1zLmNhbmNlbEJ1dHRvblRleHQpO1xuICB9XG4gIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvblRleHQpIHtcbiAgICAkY29uZmlybUJ0bi5pbm5lckhUTUwgPSBlc2NhcGVIdG1sKHBhcmFtcy5jb25maXJtQnV0dG9uVGV4dCk7XG4gIH1cblxuICAvKlxuICAgKiBDdXN0b20gY29sb3Igb24gY29uZmlybSBidXR0b25cbiAgICovXG4gIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XG4gICAgLy8gU2V0IGNvbmZpcm0gYnV0dG9uIHRvIHNlbGVjdGVkIGJhY2tncm91bmQgY29sb3JcbiAgICAkY29uZmlybUJ0bi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yO1xuXG4gICAgLy8gU2V0IHRoZSBjb25maXJtIGJ1dHRvbiBjb2xvciB0byB0aGUgbG9hZGluZyByaW5nXG4gICAgJGNvbmZpcm1CdG4uc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gcGFyYW1zLmNvbmZpcm1Mb2FkaW5nQnV0dG9uQ29sb3I7XG4gICAgJGNvbmZpcm1CdG4uc3R5bGUuYm9yZGVyUmlnaHRDb2xvciA9IHBhcmFtcy5jb25maXJtTG9hZGluZ0J1dHRvbkNvbG9yO1xuXG4gICAgLy8gU2V0IGJveC1zaGFkb3cgdG8gZGVmYXVsdCBmb2N1c2VkIGJ1dHRvblxuICAgIHNldEZvY3VzU3R5bGUoJGNvbmZpcm1CdG4sIHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3IpO1xuICB9XG5cbiAgLypcbiAgICogQWxsb3cgb3V0c2lkZSBjbGlja1xuICAgKi9cbiAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWFsbG93LW91dHNpZGUtY2xpY2snLCBwYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spO1xuXG4gIC8qXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICB2YXIgaGFzRG9uZUZ1bmN0aW9uID0gcGFyYW1zLmRvbmVGdW5jdGlvbiA/IHRydWUgOiBmYWxzZTtcbiAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWhhcy1kb25lLWZ1bmN0aW9uJywgaGFzRG9uZUZ1bmN0aW9uKTtcblxuICAvKlxuICAgKiBBbmltYXRpb25cbiAgICovXG4gIGlmICghcGFyYW1zLmFuaW1hdGlvbikge1xuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCAnbm9uZScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBwYXJhbXMuYW5pbWF0aW9uKTsgLy8gQ3VzdG9tIGFuaW1hdGlvblxuICB9IGVsc2Uge1xuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCAncG9wJyk7XG4gIH1cblxuICAvKlxuICAgKiBUaW1lclxuICAgKi9cbiAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLXRpbWVyJywgcGFyYW1zLnRpbWVyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHNldFBhcmFtZXRlcnM7XG4iLCIvKlxuICogQWxsb3cgdXNlciB0byBwYXNzIHRoZWlyIG93biBwYXJhbXNcbiAqL1xudmFyIGV4dGVuZCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLypcbiAqIENvbnZlcnQgSEVYIGNvZGVzIHRvIFJHQiB2YWx1ZXMgKCMwMDAwMDAgLT4gcmdiKDAsMCwwKSlcbiAqL1xudmFyIGhleFRvUmdiID0gZnVuY3Rpb24oaGV4KSB7XG4gIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcbiAgcmV0dXJuIHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpICsgJywgJyArIHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpICsgJywgJyArIHBhcnNlSW50KHJlc3VsdFszXSwgMTYpIDogbnVsbDtcbn07XG5cbi8qXG4gKiBDaGVjayBpZiB0aGUgdXNlciBpcyB1c2luZyBJbnRlcm5ldCBFeHBsb3JlciA4IChmb3IgZmFsbGJhY2tzKVxuICovXG52YXIgaXNJRTggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh3aW5kb3cuYXR0YWNoRXZlbnQgJiYgIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKTtcbn07XG5cbi8qXG4gKiBJRSBjb21wYXRpYmxlIGxvZ2dpbmcgZm9yIGRldmVsb3BlcnNcbiAqL1xudmFyIGxvZ1N0ciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAvLyBJRS4uLlxuICAgIHdpbmRvdy5jb25zb2xlLmxvZygnU3dlZXRBbGVydDogJyArIHN0cmluZyk7XG4gIH1cbn07XG5cbi8qXG4gKiBTZXQgaG92ZXIsIGFjdGl2ZSBhbmQgZm9jdXMtc3RhdGVzIGZvciBidXR0b25zIFxuICogKHNvdXJjZTogaHR0cDovL3d3dy5zaXRlcG9pbnQuY29tL2phdmFzY3JpcHQtZ2VuZXJhdGUtbGlnaHRlci1kYXJrZXItY29sb3IpXG4gKi9cbnZhciBjb2xvckx1bWluYW5jZSA9IGZ1bmN0aW9uKGhleCwgbHVtKSB7XG4gIC8vIFZhbGlkYXRlIGhleCBzdHJpbmdcbiAgaGV4ID0gU3RyaW5nKGhleCkucmVwbGFjZSgvW14wLTlhLWZdL2dpLCAnJyk7XG4gIGlmIChoZXgubGVuZ3RoIDwgNikge1xuICAgIGhleCA9IGhleFswXSArIGhleFswXSArIGhleFsxXSArIGhleFsxXSArIGhleFsyXSArIGhleFsyXTtcbiAgfVxuICBsdW0gPSBsdW0gfHwgMDtcblxuICAvLyBDb252ZXJ0IHRvIGRlY2ltYWwgYW5kIGNoYW5nZSBsdW1pbm9zaXR5XG4gIHZhciByZ2IgPSAnIyc7XG4gIHZhciBjO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgYyA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgYyA9IE1hdGgucm91bmQoTWF0aC5taW4oTWF0aC5tYXgoMCwgYyArIGMgKiBsdW0pLCAyNTUpKS50b1N0cmluZygxNik7XG4gICAgcmdiICs9ICgnMDAnICsgYykuc3Vic3RyKGMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiByZ2I7XG59O1xuXG5cbmV4cG9ydCB7XG4gIGV4dGVuZCxcbiAgaGV4VG9SZ2IsXG4gIGlzSUU4LFxuICBsb2dTdHIsXG4gIGNvbG9yTHVtaW5hbmNlXG59O1xuIl19\n\n  \n  /*\n   * Use SweetAlert with RequireJS\n   */\n  \n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return sweetAlert;\n    });\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = sweetAlert;\n  }\n\n})(window, document);"

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzUxMzg0NDdmMWQ1MWE4ZGZkOGY/NzYwNyIsIndlYnBhY2s6Ly8vLi9hcHAvdmVuZG9yLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2Jvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAuY3NzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvc3dlZXRhbGVydC9kaXN0L3N3ZWV0YWxlcnQuY3NzPzVlYjEiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9zd2VldGFsZXJ0L2Rpc3Qvc3dlZXRhbGVydC5jc3MiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9qc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvci5taW4uY3NzPzc3NmEiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9qc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvci5taW4uY3NzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvZXM1LXNoaW0vZXM1LXNoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9lczUtc2hpbS9lczUtc2hhbS5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2h0bWw1c2hpdi9kaXN0L2h0bWw1c2hpdi5taW4uanM/YjJhMSIsIndlYnBhY2s6Ly8vLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvaHRtbDVzaGl2L2Rpc3QvaHRtbDVzaGl2Lm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2pzb25lZGl0b3IvZGlzdC9qc29uZWRpdG9yLmpzPzIyMWIiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9qc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXIvYW5ndWxhci5taW4uanM/YWZhOSIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXIvYW5ndWxhci5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLXJvdXRlL2FuZ3VsYXItcm91dGUubWluLmpzPzdkZTYiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLXJvdXRlL2FuZ3VsYXItcm91dGUubWluLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1yZXNvdXJjZS9hbmd1bGFyLXJlc291cmNlLm1pbi5qcz9lYmI4Iiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1yZXNvdXJjZS9hbmd1bGFyLXJlc291cmNlLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC5taW4uanM/M2UxMyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWJvb3RzdHJhcC91aS1ib290c3RyYXAtdHBscy5taW4uanM/OTM0ZiIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItaWU4cHJvdmlkZXIvYW5ndWxhci1pZThwcm92aWRlci5qcz80ZGU1Iiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1pZThwcm92aWRlci9hbmd1bGFyLWllOHByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL2Jvd2VyX2NvbXBvbmVudHMvbmctanNvbmVkaXRvci9uZy1qc29uZWRpdG9yLmpzPzM5MTAiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9uZy1qc29uZWRpdG9yL25nLWpzb25lZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vYm93ZXJfY29tcG9uZW50cy9zd2VldGFsZXJ0L2Rpc3Qvc3dlZXRhbGVydC1kZXYuanM/YTk1NCIsIndlYnBhY2s6Ly8vLi9ib3dlcl9jb21wb25lbnRzL3N3ZWV0YWxlcnQvZGlzdC9zd2VldGFsZXJ0LWRldi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O3FCQ3RDTyxFQUFrQzs7cUJBQ2xDLEVBQXNDOztxQkFDdEMsRUFBMEM7O3FCQUMxQyxFQUFtQjs7cUJBQ25CLEVBQW1COztxQkFDbkIsRUFBcUM7O3FCQUNyQyxFQUFtQzs7cUJBQ25DLEVBQTRCOztxQkFDNUIsRUFBd0M7O3FCQUN4QyxFQUE4Qzs7cUJBQzlDLEVBQTJDOztxQkFDM0MsRUFBZ0Q7O3FCQUNoRCxFQUFnRDs7cUJBQ2hELEVBQW9DOztxQkFDcEMsRUFBdUMsRTs7Ozs7Ozs7O0FDZDlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFn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QjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7QUFDRDtBQUNBLGdEQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdFQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLEVBQUUsU0FBUyxFQUFFO0FBQy9CO0FBQ0EsdUJBQXNCLEVBQUU7QUFDeEIsdUJBQXNCLEVBQUU7QUFDeEI7QUFDQSx3QkFBdUIsRUFBRTtBQUN6Qix3QkFBdUIsRUFBRTtBQUN6QjtBQUNBLDRCQUEyQixFQUFFO0FBQzdCLGlDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsRUFBRTtBQUM1Qiw0QkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTRFOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsMEJBQTBCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSwrREFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQSxFQUFDOzs7Ozs7O0FDOTRDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FB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QUcsa0RBQWtELDJrOEVBQTJrOEUsMEJBQTBCLDBCQUEwQixPQUFPLEVBQUUsS0FBSyw0REFBNEQsa0NBQWtDLEtBQUssS0FBSyxvQkFBb0IsQyIsImZpbGUiOiJ2ZW5kb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIuL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMzUxMzg0NDdmMWQ1MWE4ZGZkOGZcbiAqKi8iLCJpbXBvcnQgJ2Jvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAuY3NzJztcbmltcG9ydCAnc3R5bGUhc3dlZXRhbGVydC9kaXN0L3N3ZWV0YWxlcnQuY3NzJztcbmltcG9ydCAnc3R5bGUhanNvbmVkaXRvci9kaXN0L2pzb25lZGl0b3IubWluLmNzcyc7XG5pbXBvcnQgJ2VzNS1zaGltL2VzNS1zaGltJztcbmltcG9ydCAnZXM1LXNoaW0vZXM1LXNoYW0nO1xuaW1wb3J0ICdzY3JpcHQhaHRtbDVzaGl2L2Rpc3QvaHRtbDVzaGl2Lm1pbic7XG5pbXBvcnQgJ3NjcmlwdCFqc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvcic7XG5pbXBvcnQgJ3NjcmlwdCFhbmd1bGFyL2FuZ3VsYXIubWluJztcbmltcG9ydCAnc2NyaXB0IWFuZ3VsYXItcm91dGUvYW5ndWxhci1yb3V0ZS5taW4nO1xuaW1wb3J0ICdzY3JpcHQhYW5ndWxhci1yZXNvdXJjZS9hbmd1bGFyLXJlc291cmNlLm1pbic7XG5pbXBvcnQgJ3NjcmlwdCFhbmd1bGFyLWJvb3RzdHJhcC91aS1ib290c3RyYXAubWluJztcbmltcG9ydCAnc2NyaXB0IWFuZ3VsYXItYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLm1pbic7XG5pbXBvcnQgJ3NjcmlwdCFhbmd1bGFyLWllOHByb3ZpZGVyL2FuZ3VsYXItaWU4cHJvdmlkZXInO1xuaW1wb3J0ICdzY3JpcHQhbmctanNvbmVkaXRvci9uZy1qc29uZWRpdG9yJztcbmltcG9ydCAnc2NyaXB0IXN3ZWV0YWxlcnQvZGlzdC9zd2VldGFsZXJ0LWRldic7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbmctYW5ub3RhdGUtbG9hZGVyL2xvYWRlci5qcz9hZGQ9dHJ1ZSEuL34vanNoaW50LWxvYWRlciEuL2FwcC92ZW5kb3IuanNcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KCkge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRoZWFkLmFwcGVuZENoaWxkKGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KCk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9ib3dlcl9jb21wb25lbnRzL2Jvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAuY3NzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwib21pdFxcXCI6MSxcXFwiZXh0cmFjdFxcXCI6dHJ1ZSxcXFwicmVtb3ZlXFxcIjp0cnVlfSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL3N3ZWV0YWxlcnQuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJvbWl0XFxcIjoxLFxcXCJleHRyYWN0XFxcIjp0cnVlLFxcXCJyZW1vdmVcXFwiOnRydWV9IS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dlZXRhbGVydC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwib21pdFxcXCI6MSxcXFwiZXh0cmFjdFxcXCI6dHJ1ZSxcXFwicmVtb3ZlXFxcIjp0cnVlfSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL3N3ZWV0YWxlcnQuY3NzXCIpO1xuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9zd2VldGFsZXJ0L2Rpc3Qvc3dlZXRhbGVydC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcIm9taXRcIjoxLFwiZXh0cmFjdFwiOnRydWUsXCJyZW1vdmVcIjp0cnVlfSEuL34vc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlciEuL2Jvd2VyX2NvbXBvbmVudHMvc3dlZXRhbGVydC9kaXN0L3N3ZWV0YWxlcnQuY3NzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwib21pdFxcXCI6MSxcXFwiZXh0cmFjdFxcXCI6dHJ1ZSxcXFwicmVtb3ZlXFxcIjp0cnVlfSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL2pzb25lZGl0b3IubWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vbG9hZGVyLmpzP3tcXFwib21pdFxcXCI6MSxcXFwiZXh0cmFjdFxcXCI6dHJ1ZSxcXFwicmVtb3ZlXFxcIjp0cnVlfSEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL2pzb25lZGl0b3IubWluLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/e1xcXCJvbWl0XFxcIjoxLFxcXCJleHRyYWN0XFxcIjp0cnVlLFxcXCJyZW1vdmVcXFwiOnRydWV9IS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vanNvbmVkaXRvci5taW4uY3NzXCIpO1xuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9qc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvci5taW4uY3NzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz97XCJvbWl0XCI6MSxcImV4dHJhY3RcIjp0cnVlLFwicmVtb3ZlXCI6dHJ1ZX0hLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL2pzb25lZGl0b3IvZGlzdC9qc29uZWRpdG9yLm1pbi5jc3NcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMTQgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cblxuLy8gVU1EIChVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24pXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4vLyBBZGQgc2VtaWNvbG9uIHRvIHByZXZlbnQgSUlGRSBmcm9tIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudCB0byBjb25jYXRlbmF0ZWQgY29kZS5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLypnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBCcmluZ3MgYW4gZW52aXJvbm1lbnQgYXMgY2xvc2UgdG8gRUNNQVNjcmlwdCA1IGNvbXBsaWFuY2VcbiAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gKlxuICogQW5ub3RhdGVkIEVTNTogaHR0cDovL2VzNS5naXRodWIuY29tLyAoc3BlY2lmaWMgbGlua3MgYmVsb3cpXG4gKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICogUmVxdWlyZWQgcmVhZGluZzogaHR0cDovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8yMDExLzEyLzA1L2V4dGVuZGluZy1qYXZhc2NyaXB0LW5hdGl2ZXMvXG4gKi9cblxuLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbi8vIGRlcmVmZXJlbmNlIHRoYXQgY29zdHMgdW5pdmVyc2FsbHkuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xudmFyIE51bWJlclByb3RvdHlwZSA9IE51bWJlci5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbnZhciBhcnJheV9zcGxpY2UgPSBBcnJheVByb3RvdHlwZS5zcGxpY2U7XG52YXIgYXJyYXlfcHVzaCA9IEFycmF5UHJvdG90eXBlLnB1c2g7XG52YXIgYXJyYXlfdW5zaGlmdCA9IEFycmF5UHJvdG90eXBlLnVuc2hpZnQ7XG52YXIgY2FsbCA9IEZ1bmN0aW9uUHJvdG90eXBlLmNhbGw7XG5cbi8vIEhhdmluZyBhIHRvU3RyaW5nIGxvY2FsIHZhcmlhYmxlIG5hbWUgYnJlYWtzIGluIE9wZXJhIHNvIHVzZSB0b19zdHJpbmcuXG52YXIgdG9fc3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdG9fc3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG52YXIgaXNSZWdleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdG9fc3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiB0b19zdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0b19zdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG52YXIgaXNBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgIHZhciBzdHIgPSB0b19zdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgdmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gICAgaWYgKCFpc0FyZ3MpIHtcbiAgICAgICAgaXNBcmdzID0gIWlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICAgICAgIGlzRnVuY3Rpb24odmFsdWUuY2FsbGVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJncztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShpbnB1dCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIHJldHVybiBpbnB1dCA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgdmFyIHZhbCwgdmFsdWVPZiwgdG9TdHI7XG4gICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIHZhbHVlT2YgPSBpbnB1dC52YWx1ZU9mO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlT2YpKSB7XG4gICAgICAgIHZhbCA9IHZhbHVlT2YuY2FsbChpbnB1dCk7XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyID0gaW5wdXQudG9TdHJpbmc7XG4gICAgaWYgKGlzRnVuY3Rpb24odG9TdHIpKSB7XG4gICAgICAgIHZhbCA9IHRvU3RyLmNhbGwoaW5wdXQpO1xuICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG59XG5cbnZhciBFUyA9IHtcbiAgICAvLyBFUzUgOS45XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS45XG4gICAgVG9PYmplY3Q6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIC8qanNoaW50IGVxbnVsbDogdHJ1ZSAqL1xuICAgICAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0KG8pO1xuICAgIH0sXG4gICAgVG9VaW50MzI6IGZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPj4+IDA7XG4gICAgfVxufTtcblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxudmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBib3VuZDtcbiAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy8gX1BsZWFzZSBub3RlOiBTaG9ydGN1dHMgYXJlIGRlZmluZWQgYWZ0ZXIgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBhcyB3ZVxuLy8gdXMgaXQgaW4gZGVmaW5pbmcgc2hvcnRjdXRzLlxudmFyIG93bnMgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuNC4xMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjEyXG52YXIgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IFsxLCAyXTtcbiAgICB2YXIgcmVzdWx0ID0gYS5zcGxpY2UoKTtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IDIgJiYgaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDA7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIC8vIFNhZmFyaSA1LjAgYnVnIHdoZXJlIC5zcGxpY2UoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxufSwgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxudmFyIHNwbGljZVdvcmtzV2l0aEVtcHR5T2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMTtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0b0ludGVnZXIodGhpcy5sZW5ndGgpLCAwKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWxldGVDb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMubGVuZ3RoIC0gc3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gdG9JbnRlZ2VyKGRlbGV0ZUNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbn0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG5cbi8vIEVTNSAxNS40LjQuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xM1xuLy8gUmV0dXJuIGxlbithcmdDb3VudC5cbi8vIFtidWdmaXgsIGllbHQ4XVxuLy8gSUUgPCA4IGJ1ZzogW10udW5zaGlmdCgwKSA9PT0gdW5kZWZpbmVkIGJ1dCBzaG91bGQgYmUgXCIxXCJcbnZhciBoYXNVbnNoaWZ0UmV0dXJuVmFsdWVCdWcgPSBbXS51bnNoaWZ0KDApICE9PSAxO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJyYXlfdW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxufSwgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnKTtcblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG4vLyBUaGUgSXNDYWxsYWJsZSgpIGNoZWNrIGluIHRoZSBBcnJheSBmdW5jdGlvbnNcbi8vIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYSBzdHJpY3QgY2hlY2sgb24gdGhlXG4vLyBpbnRlcm5hbCBjbGFzcyBvZiB0aGUgb2JqZWN0IHRvIHRyYXAgY2FzZXMgd2hlcmVcbi8vIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3YXMgYWN0dWFsbHkgYSByZWd1bGFyXG4vLyBleHByZXNzaW9uIGxpdGVyYWwsIHdoaWNoIGluIFY4IGFuZFxuLy8gSmF2YVNjcmlwdENvcmUgaXMgYSB0eXBlb2YgXCJmdW5jdGlvblwiLiAgT25seSBpblxuLy8gVjggYXJlIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFscyBwZXJtaXR0ZWQgYXNcbi8vIHJlZHVjZSBwYXJhbWV0ZXJzLCBzbyBpdCBpcyBkZXNpcmFibGUgaW4gdGhlXG4vLyBnZW5lcmFsIGNhc2UgZm9yIHRoZSBzaGltIHRvIG1hdGNoIHRoZSBtb3JlXG4vLyBzdHJpY3QgYW5kIGNvbW1vbiBiZWhhdmlvciBvZiByZWplY3RpbmcgcmVndWxhclxuLy8gZXhwcmVzc2lvbnMuXG5cbi8vIEVTNSAxNS40LjQuMThcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvYXJyYXkvZm9yRWFjaFxuXG4vLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xOVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE5XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L21hcFxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIG1hcDogZnVuY3Rpb24gbWFwKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5tYXApKTtcblxuLy8gRVM1IDE1LjQuNC4yMFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2ZpbHRlclxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGZ1biAvKiwgdGhpc3AgKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmW2ldO1xuICAgICAgICAgICAgICAgIGlmIChmdW4uY2FsbCh0aGlzcCwgdmFsdWUsIGksIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5maWx0ZXIpKTtcblxuLy8gRVM1IDE1LjQuNC4xNlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE2XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9ldmVyeVxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICFmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZXZlcnkpKTtcblxuLy8gRVM1IDE1LjQuNC4xN1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE3XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc29tZTogZnVuY3Rpb24gc29tZShmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5zb21lKSk7XG5cbi8vIEVTNSAxNS40LjQuMjFcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VcbnZhciByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbmlmIChBcnJheVByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlLmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7IHJldHVybiBsaXN0OyB9KSA9PT0gJ29iamVjdCc7XG59XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZnVuIC8qLCBpbml0aWFsKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKCFsZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAoKytpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuLmNhbGwodm9pZCAwLCByZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFyZWR1Y2VDb2VyY2VzVG9PYmplY3QpO1xuXG4vLyBFUzUgMTUuNC40LjIyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHRcbnZhciByZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCA9IGZhbHNlO1xuaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZVJpZ2h0KSB7XG4gICAgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHsgcmV0dXJuIGxpc3Q7IH0pID09PSAnb2JqZWN0Jztcbn1cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoZnVuIC8qLCBpbml0aWFsKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSwgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKCFsZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0LCBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuLmNhbGwodm9pZCAwLCByZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGktLSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59LCAhcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLykge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBFUy5Ub09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy8gRVM1IDE1LjQuNC4xNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9sYXN0SW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gyTGFzdEluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgJiYgWzAsIDFdLmxhc3RJbmRleE9mKDAsIC0zKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IE1hdGgubWluKGksIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IGxlbmd0aCAtIE1hdGguYWJzKGkpO1xuICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc291Z2h0ID09PSBzZWxmW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gyTGFzdEluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gT2JqZWN0XG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS4yLjMuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4vLyBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxudmFyIGhhc0RvbnRFbnVtQnVnID0gISh7J3RvU3RyaW5nJzogbnVsbH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpLFxuICAgIGhhc1Byb3RvRW51bUJ1ZyA9IGZ1bmN0aW9uICgpIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCdwcm90b3R5cGUnKSxcbiAgICBkb250RW51bXMgPSBbXG4gICAgICAgICd0b1N0cmluZycsXG4gICAgICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgICAgICd2YWx1ZU9mJyxcbiAgICAgICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAgICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAgICAgICAnY29uc3RydWN0b3InXG4gICAgXSxcbiAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG5kZWZpbmVQcm9wZXJ0aWVzKE9iamVjdCwge1xuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgIHZhciBpc0ZuID0gaXNGdW5jdGlvbihvYmplY3QpLFxuICAgICAgICAgICAgaXNBcmdzID0gaXNBcmd1bWVudHMob2JqZWN0KSxcbiAgICAgICAgICAgIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgaXNTdHIgPSBpc09iamVjdCAmJiBpc1N0cmluZyhvYmplY3QpO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QgJiYgIWlzRm4gJiYgIWlzQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoZUtleXMgPSBbXTtcbiAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0ZuO1xuICAgICAgICBpZiAoaXNTdHIgfHwgaXNBcmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICAgIHNraXBDb25zdHJ1Y3RvciA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG9iamVjdDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9udEVudW1zTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9udEVudW0gPSBkb250RW51bXNbal07XG4gICAgICAgICAgICAgICAgaWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtID09PSAnY29uc3RydWN0b3InKSAmJiBvd25zKG9iamVjdCwgZG9udEVudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUtleXMucHVzaChkb250RW51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVLZXlzO1xuICAgIH1cbn0pO1xuXG52YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9IE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2FmYXJpIDUuMCBidWdcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG59KDEsIDIpKTtcbnZhciBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cztcbmRlZmluZVByb3BlcnRpZXMoT2JqZWN0LCB7XG4gICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMoQXJyYXlQcm90b3R5cGUuc2xpY2UuY2FsbChvYmplY3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn0sICFrZXlzV29ya3NXaXRoQXJndW1lbnRzKTtcblxuLy9cbi8vIERhdGVcbi8vID09PT1cbi8vXG5cbi8vIEVTNSAxNS45LjUuNDNcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNS40M1xuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgU3RyaW5nIHZhbHVlIHJlcHJlc2VudCB0aGUgaW5zdGFuY2UgaW4gdGltZVxuLy8gcmVwcmVzZW50ZWQgYnkgdGhpcyBEYXRlIG9iamVjdC4gVGhlIGZvcm1hdCBvZiB0aGUgU3RyaW5nIGlzIHRoZSBEYXRlIFRpbWVcbi8vIHN0cmluZyBmb3JtYXQgZGVmaW5lZCBpbiAxNS45LjEuMTUuIEFsbCBmaWVsZHMgYXJlIHByZXNlbnQgaW4gdGhlIFN0cmluZy5cbi8vIFRoZSB0aW1lIHpvbmUgaXMgYWx3YXlzIFVUQywgZGVub3RlZCBieSB0aGUgc3VmZml4IFouIElmIHRoZSB0aW1lIHZhbHVlIG9mXG4vLyB0aGlzIG9iamVjdCBpcyBub3QgYSBmaW5pdGUgTnVtYmVyIGEgUmFuZ2VFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxudmFyIG5lZ2F0aXZlRGF0ZSA9IC02MjE5ODc1NTIwMDAwMDtcbnZhciBuZWdhdGl2ZVllYXJTdHJpbmcgPSAnLTAwMDAwMSc7XG52YXIgaGFzTmVnYXRpdmVEYXRlQnVnID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgbmV3IERhdGUobmVnYXRpdmVEYXRlKS50b0lTT1N0cmluZygpLmluZGV4T2YobmVnYXRpdmVZZWFyU3RyaW5nKSA9PT0gLTE7XG5cbmRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGxlbmd0aCwgdmFsdWUsIHllYXIsIG1vbnRoO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB5ZWFyID0gdGhpcy5nZXRVVENGdWxsWWVhcigpO1xuXG4gICAgICAgIG1vbnRoID0gdGhpcy5nZXRVVENNb250aCgpO1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xMTFcbiAgICAgICAgeWVhciArPSBNYXRoLmZsb29yKG1vbnRoIC8gMTIpO1xuICAgICAgICBtb250aCA9IChtb250aCAlIDEyICsgMTIpICUgMTI7XG5cbiAgICAgICAgLy8gdGhlIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0IGlzIHNwZWNpZmllZCBpbiAxNS45LjEuMTUuXG4gICAgICAgIHJlc3VsdCA9IFttb250aCArIDEsIHRoaXMuZ2V0VVRDRGF0ZSgpLCB0aGlzLmdldFVUQ0hvdXJzKCksIHRoaXMuZ2V0VVRDTWludXRlcygpLCB0aGlzLmdldFVUQ1NlY29uZHMoKV07XG4gICAgICAgIHllYXIgPSAoXG4gICAgICAgICAgICAoeWVhciA8IDAgPyAnLScgOiAoeWVhciA+IDk5OTkgPyAnKycgOiAnJykpICtcbiAgICAgICAgICAgICgnMDAwMDAnICsgTWF0aC5hYnMoeWVhcikpLnNsaWNlKDAgPD0geWVhciAmJiB5ZWFyIDw9IDk5OTkgPyAtNCA6IC02KVxuICAgICAgICApO1xuXG4gICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgICAgIC8vIHBhZCBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyB0byBoYXZlIHR3b1xuICAgICAgICAgICAgLy8gZGlnaXRzLlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMTApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9ICcwJyArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB5ZWFyICsgJy0nICsgcmVzdWx0LnNsaWNlKDAsIDIpLmpvaW4oJy0nKSArXG4gICAgICAgICAgICAnVCcgKyByZXN1bHQuc2xpY2UoMikuam9pbignOicpICsgJy4nICtcbiAgICAgICAgICAgICgnMDAwJyArIHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCkpLnNsaWNlKC0zKSArICdaJ1xuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlRGF0ZUJ1Zyk7XG5cblxuLy8gRVM1IDE1LjkuNS40NFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQ0XG4vLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRGF0ZSBvYmplY3QgZm9yIHVzZSBieVxuLy8gSlNPTi5zdHJpbmdpZnkgKDE1LjEyLjMpLlxudmFyIGRhdGVUb0pTT05Jc1N1cHBvcnRlZCA9IGZhbHNlO1xudHJ5IHtcbiAgICBkYXRlVG9KU09OSXNTdXBwb3J0ZWQgPSAoXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiAmJlxuICAgICAgICBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsICYmXG4gICAgICAgIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9KU09OKCkuaW5kZXhPZihuZWdhdGl2ZVllYXJTdHJpbmcpICE9PSAtMSAmJlxuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IC8vIGdlbmVyaWNcbiAgICAgICAgICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgKTtcbn0gY2F0Y2ggKGUpIHtcbn1cbmlmICghZGF0ZVRvSlNPTklzU3VwcG9ydGVkKSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgICAgICAvLyBXaGVuIHRoZSB0b0pTT04gbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50IGtleSwgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG5cbiAgICAgICAgLy8gMS4gIExldCBPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBUb09iamVjdCwgZ2l2aW5nIGl0IHRoZSB0aGlzXG4gICAgICAgIC8vIHZhbHVlIGFzIGl0cyBhcmd1bWVudC5cbiAgICAgICAgLy8gMi4gTGV0IHR2IGJlIHRvUHJpbWl0aXZlKE8sIGhpbnQgTnVtYmVyKS5cbiAgICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyksXG4gICAgICAgICAgICB0diA9IHRvUHJpbWl0aXZlKG8pLFxuICAgICAgICAgICAgdG9JU087XG4gICAgICAgIC8vIDMuIElmIHR2IGlzIGEgTnVtYmVyIGFuZCBpcyBub3QgZmluaXRlLCByZXR1cm4gbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiB0diA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHR2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNC4gTGV0IHRvSVNPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tHZXRdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgLy8gTyB3aXRoIGFyZ3VtZW50IFwidG9JU09TdHJpbmdcIi5cbiAgICAgICAgdG9JU08gPSBvLnRvSVNPU3RyaW5nO1xuICAgICAgICAvLyA1LiBJZiBJc0NhbGxhYmxlKHRvSVNPKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAodHlwZW9mIHRvSVNPICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0lTT1N0cmluZyBwcm9wZXJ0eSBpcyBub3QgY2FsbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA2LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgLy8gIHRvSVNPIHdpdGggTyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJndW1lbnQgbGlzdC5cbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwobyk7XG5cbiAgICAgICAgLy8gTk9URSAxIFRoZSBhcmd1bWVudCBpcyBpZ25vcmVkLlxuXG4gICAgICAgIC8vIE5PVEUgMiBUaGUgdG9KU09OIGZ1bmN0aW9uIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzsgaXQgZG9lcyBub3RcbiAgICAgICAgLy8gcmVxdWlyZSB0aGF0IGl0cyB0aGlzIHZhbHVlIGJlIGEgRGF0ZSBvYmplY3QuIFRoZXJlZm9yZSwgaXQgY2FuIGJlXG4gICAgICAgIC8vIHRyYW5zZmVycmVkIHRvIG90aGVyIGtpbmRzIG9mIG9iamVjdHMgZm9yIHVzZSBhcyBhIG1ldGhvZC4gSG93ZXZlcixcbiAgICAgICAgLy8gaXQgZG9lcyByZXF1aXJlIHRoYXQgYW55IHN1Y2ggb2JqZWN0IGhhdmUgYSB0b0lTT1N0cmluZyBtZXRob2QuIEFuXG4gICAgICAgIC8vIG9iamVjdCBpcyBmcmVlIHRvIHVzZSB0aGUgYXJndW1lbnQga2V5IHRvIGZpbHRlciBpdHNcbiAgICAgICAgLy8gc3RyaW5naWZpY2F0aW9uLlxuICAgIH07XG59XG5cbi8vIEVTNSAxNS45LjQuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS40LjJcbi8vIGJhc2VkIG9uIHdvcmsgc2hhcmVkIGJ5IERhbmllbCBGcmllc2VuIChkYW50bWFuKVxuLy8gaHR0cDovL2dpc3QuZ2l0aHViLmNvbS8zMDMyNDlcbnZhciBzdXBwb3J0c0V4dGVuZGVkWWVhcnMgPSBEYXRlLnBhcnNlKCcrMDMzNjU4LTA5LTI3VDAxOjQ2OjQwLjAwMFonKSA9PT0gMWUxNTtcbnZhciBhY2NlcHRzSW52YWxpZERhdGVzID0gIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMDQtMDRUMjQ6MDA6MDAuNTAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMS0zMVQyMzo1OTo1OS4wMDBaJykpO1xudmFyIGRvZXNOb3RQYXJzZVkyS05ld1llYXIgPSBpc05hTihEYXRlLnBhcnNlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG5pZiAoIURhdGUucGFyc2UgfHwgZG9lc05vdFBhcnNlWTJLTmV3WWVhciB8fCBhY2NlcHRzSW52YWxpZERhdGVzIHx8ICFzdXBwb3J0c0V4dGVuZGVkWWVhcnMpIHtcbiAgICAvLyBYWFggZ2xvYmFsIGFzc2lnbm1lbnQgd29uJ3Qgd29yayBpbiBlbWJlZGRpbmdzIHRoYXQgdXNlXG4gICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgLypnbG9iYWwgRGF0ZTogdHJ1ZSAqL1xuICAgIERhdGUgPSAoZnVuY3Rpb24gKE5hdGl2ZURhdGUpIHtcblxuICAgICAgICAvLyBEYXRlLmxlbmd0aCA9PT0gN1xuICAgICAgICBmdW5jdGlvbiBEYXRlKFksIE0sIEQsIGgsIG0sIHMsIG1zKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gbGVuZ3RoID09PSAxICYmIFN0cmluZyhZKSA9PT0gWSA/IC8vIGlzU3RyaW5nKFkpXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgcGFzcyBpdCB0aHJvdWdoIHBhcnNlOlxuICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZShEYXRlLnBhcnNlKFkpKSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgbWFrZSBjYWxscyBkZXBlbmRpbmcgb24gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDcgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzLCBtcykgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHMpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDUgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA0ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDIgPyBuZXcgTmF0aXZlRGF0ZShZLCBNKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAxID8gbmV3IE5hdGl2ZURhdGUoWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOYXRpdmVEYXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBtaXh1cHMgd2l0aCB1bmZpeGVkIERhdGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgZGF0ZS5jb25zdHJ1Y3RvciA9IERhdGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTmF0aXZlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMTUuOS4xLjE1IERhdGUgVGltZSBTdHJpbmcgRm9ybWF0LlxuICAgICAgICB2YXIgaXNvRGF0ZUV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKCdeJyArXG4gICAgICAgICAgICAnKFxcXFxkezR9fFsrLV1cXFxcZHs2fSknICsgLy8gZm91ci1kaWdpdCB5ZWFyIGNhcHR1cmUgb3Igc2lnbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgJyg/Oi0oXFxcXGR7Mn0pJyArIC8vIG9wdGlvbmFsIG1vbnRoIGNhcHR1cmVcbiAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBkYXkgY2FwdHVyZVxuICAgICAgICAgICAgJyg/OicgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAnVChcXFxcZHsyfSknICsgLy8gaG91cnMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICc6KFxcXFxkezJ9KScgKyAvLyBtaW51dGVzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICcoPzooXFxcXC5cXFxcZHsxLH0pKT8nICsgLy8gbWlsbGlzZWNvbmRzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICcoJyArIC8vIGNhcHR1cmUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAnWnwnICsgLy8gVVRDIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICAnKFstK10pJyArIC8vIHNpZ24gY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKFxcXFxkezJ9KScgKyAvLyBob3VycyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICcpJyArXG4gICAgICAgICAgICAnKT8pPyk/KT8nICtcbiAgICAgICAgJyQnKTtcblxuICAgICAgICB2YXIgbW9udGhzID0gW1xuICAgICAgICAgICAgMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NVxuICAgICAgICBdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIHQgPSBtb250aCA+IDEgPyAxIDogMDtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE5NjkgKyB0KSAvIDQpIC1cbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTkwMSArIHQpIC8gMTAwKSArXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE2MDEgKyB0KSAvIDQwMCkgK1xuICAgICAgICAgICAgICAgIDM2NSAqICh5ZWFyIC0gMTk3MClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b1VUQyh0KSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKG5ldyBOYXRpdmVEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIDAsIHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgYW55IGN1c3RvbSBtZXRob2RzIGEgM3JkIHBhcnR5IGxpYnJhcnkgbWF5IGhhdmUgYWRkZWRcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE5hdGl2ZURhdGUpIHtcbiAgICAgICAgICAgIERhdGVba2V5XSA9IE5hdGl2ZURhdGVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgXCJuYXRpdmVcIiBtZXRob2RzIGV4cGxpY2l0bHk7IHRoZXkgbWF5IGJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgIERhdGUubm93ID0gTmF0aXZlRGF0ZS5ub3c7XG4gICAgICAgIERhdGUuVVRDID0gTmF0aXZlRGF0ZS5VVEM7XG4gICAgICAgIERhdGUucHJvdG90eXBlID0gTmF0aXZlRGF0ZS5wcm90b3R5cGU7XG4gICAgICAgIERhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGF0ZTtcblxuICAgICAgICAvLyBVcGdyYWRlIERhdGUucGFyc2UgdG8gaGFuZGxlIHNpbXBsaWZpZWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgICAgICBEYXRlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpc29EYXRlRXhwcmVzc2lvbi5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB2YXIgeWVhciA9IE51bWJlcihtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gTnVtYmVyKG1hdGNoWzJdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gTnVtYmVyKG1hdGNoWzNdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9IE51bWJlcihtYXRjaFs0XSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlID0gTnVtYmVyKG1hdGNoWzVdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmQgPSBOdW1iZXIobWF0Y2hbNl0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gTWF0aC5mbG9vcihOdW1iZXIobWF0Y2hbN10gfHwgMCkgKiAxMDAwKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aW1lIHpvbmUgaXMgbWlzc2VkLCBsb2NhbCBvZmZzZXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gKEVTIDUuMSBidWcpXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3MuZWNtYXNjcmlwdC5vcmcvc2hvd19idWcuY2dpP2lkPTExMlxuICAgICAgICAgICAgICAgICAgICBpc0xvY2FsVGltZSA9IEJvb2xlYW4obWF0Y2hbNF0gJiYgIW1hdGNoWzhdKSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbk9mZnNldCA9IG1hdGNoWzldID09PSAnLScgPyAxIDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGhvdXJPZmZzZXQgPSBOdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPSBOdW1iZXIobWF0Y2hbMTFdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBob3VyIDwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlID4gMCB8fCBzZWNvbmQgPiAwIHx8IG1pbGxpc2Vjb25kID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAyNCA6IDI1XG4gICAgICAgICAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICAgICAgICAgbWludXRlIDwgNjAgJiYgc2Vjb25kIDwgNjAgJiYgbWlsbGlzZWNvbmQgPCAxMDAwICYmXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMiAmJiBob3VyT2Zmc2V0IDwgMjQgJiZcbiAgICAgICAgICAgICAgICAgICAgbWludXRlT2Zmc2V0IDwgNjAgJiYgLy8gZGV0ZWN0IGludmFsaWQgb2Zmc2V0c1xuICAgICAgICAgICAgICAgICAgICBkYXkgPiAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXkgPCAoXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlGcm9tTW9udGgoeWVhciwgbW9udGggKyAxKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkgKyBkYXkpICogMjQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyT2Zmc2V0ICogc2lnbk9mZnNldFxuICAgICAgICAgICAgICAgICAgICApICogNjA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQgKyBtaW51dGUgKyBtaW51dGVPZmZzZXQgKiBzaWduT2Zmc2V0KSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICApICogMTAwMCArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvVVRDKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKC04LjY0ZTE1IDw9IHJlc3VsdCAmJiByZXN1bHQgPD0gOC42NGUxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZURhdGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRGF0ZTtcbiAgICB9KERhdGUpKTtcbiAgICAvKmdsb2JhbCBEYXRlOiBmYWxzZSAqL1xufVxuXG4vLyBFUzUgMTUuOS40LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNC40XG5pZiAoIURhdGUubm93KSB7XG4gICAgRGF0ZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xufVxuXG5cbi8vXG4vLyBOdW1iZXJcbi8vID09PT09PVxuLy9cblxuLy8gRVM1LjEgMTUuNy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjcuNC41XG52YXIgaGFzVG9GaXhlZEJ1Z3MgPSBOdW1iZXJQcm90b3R5cGUudG9GaXhlZCAmJiAoXG4gICgwLjAwMDA4KS50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gICgwLjkpLnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAoMS4yNTUpLnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAoMTAwMDAwMDAwMDAwMDAwMDEyOCkudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pO1xuXG52YXIgdG9GaXhlZEhlbHBlcnMgPSB7XG4gIGJhc2U6IDFlNyxcbiAgc2l6ZTogNixcbiAgZGF0YTogWzAsIDAsIDAsIDAsIDAsIDBdLFxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkobiwgYykge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCB0b0ZpeGVkSGVscGVycy5zaXplKSB7XG4gICAgICAgICAgYyArPSBuICogdG9GaXhlZEhlbHBlcnMuZGF0YVtpXTtcbiAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kYXRhW2ldID0gYyAlIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgYyA9IE1hdGguZmxvb3IoYyAvIHRvRml4ZWRIZWxwZXJzLmJhc2UpO1xuICAgICAgfVxuICB9LFxuICBkaXZpZGU6IGZ1bmN0aW9uIGRpdmlkZShuKSB7XG4gICAgICB2YXIgaSA9IHRvRml4ZWRIZWxwZXJzLnNpemUsIGMgPSAwO1xuICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgYyArPSB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBNYXRoLmZsb29yKGMgLyBuKTtcbiAgICAgICAgICBjID0gKGMgJSBuKSAqIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICB9XG4gIH0sXG4gIG51bVRvU3RyaW5nOiBmdW5jdGlvbiBudW1Ub1N0cmluZygpIHtcbiAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZTtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCB0b0ZpeGVkSGVscGVycy5kYXRhW2ldICE9PSAwKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gU3RyaW5nKHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0pO1xuICAgICAgICAgICAgICBpZiAocyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHMgPSB0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcyArPSAnMDAwMDAwMCcuc2xpY2UoMCwgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgfSxcbiAgcG93OiBmdW5jdGlvbiBwb3coeCwgbiwgYWNjKSB7XG4gICAgICByZXR1cm4gKG4gPT09IDAgPyBhY2MgOiAobiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKSkpO1xuICB9LFxuICBsb2c6IGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB3aGlsZSAoeCA+PSA0MDk2KSB7XG4gICAgICAgICAgbiArPSAxMjtcbiAgICAgICAgICB4IC89IDQwOTY7XG4gICAgICB9XG4gICAgICB3aGlsZSAoeCA+PSAyKSB7XG4gICAgICAgICAgbiArPSAxO1xuICAgICAgICAgIHggLz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICB9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKE51bWJlclByb3RvdHlwZSwge1xuICAgIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgdmFyIGYsIHgsIHMsIG0sIGUsIHosIGosIGs7XG5cbiAgICAgICAgLy8gVGVzdCBmb3IgTmFOIGFuZCByb3VuZCBmcmFjdGlvbkRpZ2l0cyBkb3duXG4gICAgICAgIGYgPSBOdW1iZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgICAgICBmID0gZiAhPT0gZiA/IDAgOiBNYXRoLmZsb29yKGYpO1xuXG4gICAgICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIudG9GaXhlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBkZWNpbWFscycpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IE51bWJlcih0aGlzKTtcblxuICAgICAgICAvLyBUZXN0IGZvciBOYU5cbiAgICAgICAgaWYgKHggIT09IHgpIHtcbiAgICAgICAgICAgIHJldHVybiAnTmFOJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIHRvbyBiaWcgb3Igc21hbGwsIHJldHVybiB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBudW1iZXJcbiAgICAgICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcyA9ICcnO1xuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgcyA9ICctJztcbiAgICAgICAgICAgIHggPSAteDtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSAnMCc7XG5cbiAgICAgICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgICAgICAgLy8gMWUtMjEgPCB4IDwgMWUyMVxuICAgICAgICAgICAgLy8gLTcwIDwgbG9nMih4KSA8IDcwXG4gICAgICAgICAgICBlID0gdG9GaXhlZEhlbHBlcnMubG9nKHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgICAgICAgeiA9IChlIDwgMCA/IHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgLWUsIDEpIDogeCAvIHRvRml4ZWRIZWxwZXJzLnBvdygyLCBlLCAxKSk7XG4gICAgICAgICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7IC8vIE1hdGgucG93KDIsIDUyKTtcbiAgICAgICAgICAgIGUgPSA1MiAtIGU7XG5cbiAgICAgICAgICAgIC8vIC0xOCA8IGUgPCAxMjJcbiAgICAgICAgICAgIC8vIHggPSB6IC8gMiBeIGVcbiAgICAgICAgICAgIGlmIChlID4gMCkge1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDAsIHopO1xuICAgICAgICAgICAgICAgIGogPSBmO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgICAgICAgICAgICBqIC09IDc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkodG9GaXhlZEhlbHBlcnMucG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgICAgICAgICAgaiA9IGUgLSAxO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgICAgICAgICAgICBqIC09IDIzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgxIDw8IGopO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDEsIDEpO1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgyKTtcbiAgICAgICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSA8PCAoLWUpLCAwKTtcbiAgICAgICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKSArICcwLjAwMDAwMDAwMDAwMDAwMDAwMDAwJy5zbGljZSgyLCAyICsgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGsgPD0gZikge1xuICAgICAgICAgICAgICAgIG0gPSBzICsgJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcuc2xpY2UoMCwgZiAtIGsgKyAyKSArIG07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG0gPSBzICsgbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSBzICsgbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn0sIGhhc1RvRml4ZWRCdWdzKTtcblxuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gdHlwZW9mICgvKCk/Py8pLmV4ZWMoJycpWzFdID09PSAndW5kZWZpbmVkJzsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAodG9fc3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIHN0cmluZyArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgICAgICAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICBFUy5Ub1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlfcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KCcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxudmFyIHN0cl9yZXBsYWNlID0gU3RyaW5nUHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAneCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBncm91cCkge1xuICAgICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGdyb3Vwc1swXSA9PT0gJ3VuZGVmaW5lZCc7XG59KCkpO1xuXG5pZiAoIXJlcGxhY2VSZXBvcnRzR3JvdXBzQ29ycmVjdGx5KSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgdmFyIGlzRm4gPSBpc0Z1bmN0aW9uKHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIHZhciBoYXNDYXB0dXJpbmdHcm91cHMgPSBpc1JlZ2V4KHNlYXJjaFZhbHVlKSAmJiAoL1xcKVsqP10vKS50ZXN0KHNlYXJjaFZhbHVlLnNvdXJjZSk7XG4gICAgICAgIGlmICghaXNGbiB8fCAhaGFzQ2FwdHVyaW5nR3JvdXBzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkUmVwbGFjZVZhbHVlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsTGFzdEluZGV4ID0gc2VhcmNoVmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzZWFyY2hWYWx1ZS5leGVjKG1hdGNoKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZS5sYXN0SW5kZXggPSBvcmlnaW5hbExhc3RJbmRleDtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2xlbmd0aCAtIDJdLCBhcmd1bWVudHNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHdyYXBwZWRSZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbi8vIEVTNSAxNS41LjQuMjBcbi8vIHdoaXRlc3BhY2UgZnJvbTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS41LjQuMjBcbnZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAgICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcgK1xuICAgICdcXHUyMDI5XFx1RkVGRic7XG52YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xudmFyIHdzUmVnZXhDaGFycyA9ICdbJyArIHdzICsgJ10nO1xudmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgd3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyonKTtcbnZhciB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKiQnKTtcbnZhciBoYXNUcmltV2hpdGVzcGFjZUJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS50cmltICYmICh3cy50cmltKCkgfHwgIXplcm9XaWR0aC50cmltKCkpO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdFxuICAgIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL3doaXRlc3BhY2UtZGV2aWF0aW9ucy9cbiAgICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xuICAgIH1cbn0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcblxuLy8gRVMtNSAxNS4xLjIuMlxuaWYgKHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMikge1xuICAgIC8qZ2xvYmFsIHBhcnNlSW50OiB0cnVlICovXG4gICAgcGFyc2VJbnQgPSAoZnVuY3Rpb24gKG9yaWdQYXJzZUludCkge1xuICAgICAgICB2YXIgaGV4UmVnZXggPSAvXjBbeFhdLztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhcnNlSW50RVM1KHN0ciwgcmFkaXgpIHtcbiAgICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyKHJhZGl4KSkge1xuICAgICAgICAgICAgICAgIHJhZGl4ID0gaGV4UmVnZXgudGVzdChzdHIpID8gMTYgOiAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnUGFyc2VJbnQoc3RyLCByYWRpeCk7XG4gICAgICAgIH07XG4gICAgfShwYXJzZUludCkpO1xufVxuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYm93ZXJfY29tcG9uZW50cy9lczUtc2hpbS9lczUtc2hpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNCBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy9BZGQgc2VtaWNvbG9uIHRvIHByZXZlbnQgSUlGRSBmcm9tIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudCB0byBjb25jYXRlZCBjb2RlLlxuO1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKmdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbnZhciBwcm90b3R5cGVPZk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgb3ducyA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvcnMgY3JlYXRpbmcgc2hvcnRjdXRzLlxudmFyIGRlZmluZUdldHRlcjtcbnZhciBkZWZpbmVTZXR0ZXI7XG52YXIgbG9va3VwR2V0dGVyO1xudmFyIGxvb2t1cFNldHRlcjtcbnZhciBzdXBwb3J0c0FjY2Vzc29ycyA9IG93bnMocHJvdG90eXBlT2ZPYmplY3QsICdfX2RlZmluZUdldHRlcl9fJyk7XG5pZiAoc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICBkZWZpbmVHZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVHZXR0ZXJfXyk7XG4gICAgZGVmaW5lU2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18pO1xuICAgIGxvb2t1cEdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fKTtcbiAgICBsb29rdXBTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBTZXR0ZXJfXyk7XG59XG5cbi8vIEVTNSAxNS4yLjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjJcbmlmICghT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS8yXG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL29iamVjdGdldHByb3RvdHlwZW9mL1xuICAgIC8vIHJlY29tbWVuZGVkIGJ5IGZzY2hhZWZlciBvbiBnaXRodWJcbiAgICAvL1xuICAgIC8vIHN1cmUsIGFuZCB3ZWJyZWZsZWN0aW9uIHNheXMgXl9eXG4gICAgLy8gLi4uIHRoaXMgd2lsbCBuZXJldmVyIHBvc3NpYmx5IHJldHVybiBudWxsXG4gICAgLy8gLi4uIE9wZXJhIE1pbmkgYnJlYWtzIGhlcmUgd2l0aCBpbmZpbml0ZSBsb29wc1xuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKG9iamVjdCkge1xuICAgICAgICB2YXIgcHJvdG8gPSBvYmplY3QuX19wcm90b19fO1xuICAgICAgICBpZiAocHJvdG8gfHwgcHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy9FUzUgMTUuMi4zLjNcbi8vaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjNcblxuZnVuY3Rpb24gZG9lc0dldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmsob2JqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqZWN0LnNlbnRpbmVsID0gMDtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCAnc2VudGluZWwnKS52YWx1ZSA9PT0gMDtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgLy8gcmV0dXJucyBmYWxzeVxuICAgIH1cbn1cblxuLy9jaGVjayB3aGV0aGVyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB3b3JrcyBpZiBpdCdzIGdpdmVuLiBPdGhlcndpc2UsXG4vL3NoaW0gcGFydGlhbGx5LlxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uT2JqZWN0ID0gZG9lc0dldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmsoe30pO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgIGRvZXNHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBpZiAoIWdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25Eb20gfHwgIWdldE93blByb3BlcnR5RGVzY3JpcHRvcldvcmtzT25PYmplY3QpIHtcbiAgICAgICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgICB9XG59XG5cbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjaykge1xuICAgIHZhciBFUlJfTk9OX09CSkVDVCA9ICdPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbGxlZCBvbiBhIG5vbi1vYmplY3Q6ICc7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0ICE9PSAnZnVuY3Rpb24nKSB8fCBvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1QgKyBvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBhIHZhbGlhbnQgYXR0ZW1wdCB0byB1c2UgdGhlIHJlYWwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5RGVzY3JpcHRvckZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIHNoaW0gaWYgdGhlIHJlYWwgb25lIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgb2JqZWN0IGRvZXMgbm90IG93bnMgcHJvcGVydHkgcmV0dXJuIHVuZGVmaW5lZCBpbW1lZGlhdGVseS5cbiAgICAgICAgaWYgKCFvd25zKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBvYmplY3QgaGFzIGEgcHJvcGVydHkgdGhlbiBpdCdzIGZvciBzdXJlIGJvdGggYGVudW1lcmFibGVgIGFuZFxuICAgICAgICAvLyBgY29uZmlndXJhYmxlYC5cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xuXG4gICAgICAgIC8vIElmIEpTIGVuZ2luZSBzdXBwb3J0cyBhY2Nlc3NvciBwcm9wZXJ0aWVzIHRoZW4gcHJvcGVydHkgbWF5IGJlIGFcbiAgICAgICAgLy8gZ2V0dGVyIG9yIHNldHRlci5cbiAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBhIGdldHRlciBldmVuXG4gICAgICAgICAgICAvLyBpZiBvYmplY3QgaGFzIG93biBub24gZ2V0dGVyIHByb3BlcnR5IGFsb25nIHdpdGggYSBzYW1lIG5hbWVkXG4gICAgICAgICAgICAvLyBpbmhlcml0ZWQgZ2V0dGVyLiBUbyBhdm9pZCBtaXNiZWhhdmlvciB3ZSB0ZW1wb3JhcnkgcmVtb3ZlXG4gICAgICAgICAgICAvLyBgX19wcm90b19fYCBzbyB0aGF0IGBfX2xvb2t1cEdldHRlcl9fYCB3aWxsIHJldHVybiBnZXR0ZXIgb25seVxuICAgICAgICAgICAgLy8gaWYgaXQncyBvd25lZCBieSBhbiBvYmplY3QuXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0Ll9fcHJvdG9fXztcbiAgICAgICAgICAgIHZhciBub3RQcm90b3R5cGVPZk9iamVjdCA9IG9iamVjdCAhPT0gcHJvdG90eXBlT2ZPYmplY3Q7XG4gICAgICAgICAgICAvLyBhdm9pZCByZWN1cnNpb24gcHJvYmxlbSwgYnJlYWtpbmcgaW4gT3BlcmEgTWluaSB3aGVuXG4gICAgICAgICAgICAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycpXG4gICAgICAgICAgICAvLyBvciBhbnkgb3RoZXIgT2JqZWN0LnByb3RvdHlwZSBhY2Nlc3NvclxuICAgICAgICAgICAgaWYgKG5vdFByb3RvdHlwZU9mT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2V0dGVyID0gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgdmFyIHNldHRlciA9IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KTtcblxuICAgICAgICAgICAgaWYgKG5vdFByb3RvdHlwZU9mT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gT25jZSB3ZSBoYXZlIGdldHRlciBhbmQgc2V0dGVyIHdlIGNhbiBwdXQgdmFsdWVzIGJhY2suXG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdldHRlciB8fCBzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZ2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gc2V0dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCB3YXMgYWNjZXNzb3IgcHJvcGVydHkgd2UncmUgZG9uZSBhbmQgcmV0dXJuIGhlcmVcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhZGRpbmcgYHZhbHVlYCB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB3ZSBrbm93IHRoYXQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgdGhhdCBpc1xuICAgICAgICAvLyBub3QgYW4gYWNjZXNzb3Igc28gd2Ugc2V0IGl0IGFzIGEgdmFsdWUgYW5kIHJldHVybiBkZXNjcmlwdG9yLlxuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjRcbmlmICghT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjVcbmlmICghT2JqZWN0LmNyZWF0ZSkge1xuXG4gICAgLy8gQ29udHJpYnV0ZWQgYnkgQnJhbmRvbiBCZW52aWUsIE9jdG9iZXIsIDIwMTJcbiAgICB2YXIgY3JlYXRlRW1wdHk7XG4gICAgdmFyIHN1cHBvcnRzUHJvdG8gPSAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiBPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBwcm9kdWNlcyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIE9wZXJhIE1pbmkgPT4gbm90IGEgcmVsaWFibGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fID09PSBudWxsXG4gICAgLypnbG9iYWwgZG9jdW1lbnQgKi9cbiAgICBpZiAoc3VwcG9ydHNQcm90byB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgX19wcm90b19fOiBudWxsIH07XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW4gb2xkIElFIF9fcHJvdG9fXyBjYW4ndCBiZSB1c2VkIHRvIG1hbnVhbGx5IHNldCBgbnVsbGAsIG5vciBkb2VzXG4gICAgICAgIC8vIGFueSBvdGhlciBtZXRob2QgZXhpc3QgdG8gbWFrZSBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIG5vdGhpbmcsXG4gICAgICAgIC8vIGFzaWRlIGZyb20gT2JqZWN0LnByb3RvdHlwZSBpdHNlbGYuIEluc3RlYWQsIGNyZWF0ZSBhIG5ldyBnbG9iYWxcbiAgICAgICAgLy8gb2JqZWN0IGFuZCAqc3RlYWwqIGl0cyBPYmplY3QucHJvdG90eXBlIGFuZCBzdHJpcCBpdCBiYXJlLiBUaGlzIGlzXG4gICAgICAgIC8vIHVzZWQgYXMgdGhlIHByb3RvdHlwZSB0byBjcmVhdGUgbnVsbGFyeSBvYmplY3RzLlxuICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JztcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdC5wcm90b3R5cGU7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuaGFzT3duUHJvcGVydHk7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkucHJvcGVydHlJc0VudW1lcmFibGU7XG4gICAgICAgICAgICBkZWxldGUgZW1wdHkuaXNQcm90b3R5cGVPZjtcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b0xvY2FsZVN0cmluZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS50b1N0cmluZztcbiAgICAgICAgICAgIGRlbGV0ZSBlbXB0eS52YWx1ZU9mO1xuICAgICAgICAgICAgZW1wdHkuX19wcm90b19fID0gbnVsbDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRW1wdHkoKSB7fVxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gZW1wdHk7XG4gICAgICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IGZ1dHVyZSBjYWxsc1xuICAgICAgICAgICAgY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHkoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgIGZ1bmN0aW9uIFR5cGUoKSB7fSAgLy8gQW4gZW1wdHkgY29uc3RydWN0b3IuXG5cbiAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gY3JlYXRlRW1wdHkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvdG90eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBgcGFyZW50YCBjYW4gYmUgYG51bGxgXG4gICAgICAgICAgICAgICAgLy8gT1IgKmFueSogYGluc3RhbmNlb2YgT2JqZWN0YCAgKE9iamVjdHxGdW5jdGlvbnxBcnJheXxSZWdFeHB8ZXRjKVxuICAgICAgICAgICAgICAgIC8vIFVzZSBgdHlwZW9mYCB0aG8sIGIvYyBpbiBvbGQgSUUsIERPTSBlbGVtZW50cyBhcmUgbm90IGBpbnN0YW5jZW9mIE9iamVjdGBcbiAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZXkgYXJlIGluIG1vZGVybiBicm93c2Vycy4gVXNpbmcgYE9iamVjdC5jcmVhdGVgIG9uIERPTSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGlzLi4uZXJyLi4ucHJvYmFibHkgaW5hcHByb3ByaWF0ZSwgYnV0IHRoZSBuYXRpdmUgdmVyc2lvbiBhbGxvd3MgZm9yIGl0LlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBwcm90b3R5cGUgbWF5IG9ubHkgYmUgYW4gT2JqZWN0IG9yIG51bGwnKTsgLy8gc2FtZSBtc2cgYXMgQ2hyb21lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgICAgICAvLyBJRSBoYXMgbm8gYnVpbHQtaW4gaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5nZXRQcm90b3R5cGVPZmBcbiAgICAgICAgICAgIC8vIG5laXRoZXIgYF9fcHJvdG9fX2AsIGJ1dCB0aGlzIG1hbnVhbGx5IHNldHRpbmcgYF9fcHJvdG9fX2Agd2lsbFxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlIHRoYXQgYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgd2lsbCB3b3JrIGFzIGV4cGVjdGVkIHdpdGhcbiAgICAgICAgICAgIC8vIG9iamVjdHMgY3JlYXRlZCB1c2luZyBgT2JqZWN0LmNyZWF0ZWBcbiAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuMi4zLjZcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy42XG5cbi8vIFBhdGNoIGZvciBXZWJLaXQgYW5kIElFOCBzdGFuZGFyZCBtb2RlXG4vLyBEZXNpZ25lZCBieSBoYXggPGhheC5naXRodWIuY29tPlxuLy8gcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3VlcyNpc3N1ZS81XG4vLyBJRTggUmVmZXJlbmNlOlxuLy8gICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9kZDI4MjkwMC5hc3B4XG4vLyAgICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2RkMjI5OTE2LmFzcHhcbi8vIFdlYktpdCBCdWdzOlxuLy8gICAgIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjQyM1xuXG5mdW5jdGlvbiBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKG9iamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdzZW50aW5lbCcsIHt9KTtcbiAgICAgICAgcmV0dXJuICdzZW50aW5lbCcgaW4gb2JqZWN0O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAvLyByZXR1cm5zIGZhbHN5XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGRlZmluZVByb3BlcnR5IHdvcmtzIGlmIGl0J3MgZ2l2ZW4uIE90aGVyd2lzZSxcbi8vIHNoaW0gcGFydGlhbGx5LlxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgPSBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKHt9KTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICBpZiAoIWRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdCB8fCAhZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tKSB7XG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gICAgfVxufVxuXG5pZiAoIU9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKSB7XG4gICAgdmFyIEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1IgPSAnUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3Q6ICc7XG4gICAgdmFyIEVSUl9OT05fT0JKRUNUX1RBUkdFVCA9ICdPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3Q6ICc7XG4gICAgdmFyIEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCA9ICdnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgb24gdGhpcyBqYXZhc2NyaXB0IGVuZ2luZSc7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdCAhPT0gJ2Z1bmN0aW9uJykgfHwgb2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUX1RBUkdFVCArIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgZGVzY3JpcHRvciAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGRlc2NyaXB0b3IgIT09ICdmdW5jdGlvbicpIHx8IGRlc2NyaXB0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiArIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2UgYSB2YWxpYW50IGF0dGVtcHQgdG8gdXNlIHRoZSByZWFsIGRlZmluZVByb3BlcnR5XG4gICAgICAgIC8vIGZvciBJOCdzIERPTSBlbGVtZW50cy5cbiAgICAgICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5RmFsbGJhY2suY2FsbChPYmplY3QsIG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBzaGltIGlmIHRoZSByZWFsIG9uZSBkb2Vzbid0IHdvcmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3MgYSBkYXRhIHByb3BlcnR5LlxuICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCAndmFsdWUnKSkge1xuICAgICAgICAgICAgLy8gZmFpbCBzaWxlbnRseSBpZiAnd3JpdGFibGUnLCAnZW51bWVyYWJsZScsIG9yICdjb25maWd1cmFibGUnXG4gICAgICAgICAgICAvLyBhcmUgcmVxdWVzdGVkIGJ1dCBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgLy8gYWx0ZXJuYXRlIGFwcHJvYWNoOlxuICAgICAgICAgICAgaWYgKCAvLyBjYW4ndCBpbXBsZW1lbnQgdGhlc2UgZmVhdHVyZXM7IGFsbG93IGZhbHNlIGJ1dCBub3QgdHJ1ZVxuICAgICAgICAgICAgICAgICEob3ducyhkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSA/IGRlc2NyaXB0b3Iud3JpdGFibGUgOiB0cnVlKSB8fFxuICAgICAgICAgICAgICAgICEob3ducyhkZXNjcmlwdG9yLCAnZW51bWVyYWJsZScpID8gZGVzY3JpcHRvci5lbnVtZXJhYmxlIDogdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAhKG93bnMoZGVzY3JpcHRvciwgJ2NvbmZpZ3VyYWJsZScpID8gZGVzY3JpcHRvci5jb25maWd1cmFibGUgOiB0cnVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lcyBub3Qgc3VwcG9ydCBjb25maWd1cmFibGUsIGVudW1lcmFibGUsIG9yIHdyaXRhYmxlLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzICYmIChsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSkgfHwgbG9va3VwU2V0dGVyKG9iamVjdCwgcHJvcGVydHkpKSkge1xuICAgICAgICAgICAgICAgIC8vIEFzIGFjY2Vzc29ycyBhcmUgc3VwcG9ydGVkIG9ubHkgb24gZW5naW5lcyBpbXBsZW1lbnRpbmdcbiAgICAgICAgICAgICAgICAvLyBgX19wcm90b19fYCB3ZSBjYW4gc2FmZWx5IG92ZXJyaWRlIGBfX3Byb3RvX19gIHdoaWxlIGRlZmluaW5nXG4gICAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBoaXQgYW4gaW5oZXJpdGVkXG4gICAgICAgICAgICAgICAgLy8gYWNjZXNzb3IuXG4gICAgICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xuICAgICAgICAgICAgICAgIC8vIERlbGV0aW5nIGEgcHJvcGVydHkgYW55d2F5IHNpbmNlIGdldHRlciAvIHNldHRlciBtYXkgYmVcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmVkIG9uIG9iamVjdCBpdHNlbGYuXG4gICAgICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBvcmlnaW5hbCBgX19wcm90b19fYCBiYWNrIG5vdy5cbiAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydHNBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9BQ0NFU1NPUlNfTk9UX1NVUFBPUlRFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhhdCBmYXIgdGhlbiBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGNhbiBiZSBkZWZpbmVkICEhXG4gICAgICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCAnZ2V0JykpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5nZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG93bnMoZGVzY3JpcHRvciwgJ3NldCcpKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lU2V0dGVyKG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuN1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjdcbmlmICghT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgfHwgZGVmaW5lUHJvcGVydGllc0ZhbGxiYWNrKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgICAgICAvLyBtYWtlIGEgdmFsaWFudCBhdHRlbXB0IHRvIHVzZSB0aGUgcmVhbCBkZWZpbmVQcm9wZXJ0aWVzXG4gICAgICAgIGlmIChkZWZpbmVQcm9wZXJ0aWVzRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnRpZXNGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgc2hpbSBpZiB0aGUgcmVhbCBvbmUgZG9lc24ndCB3b3JrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAob3ducyhwcm9wZXJ0aWVzLCBwcm9wZXJ0eSkgJiYgcHJvcGVydHkgIT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHByb3BlcnRpZXNbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuOFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjhcbmlmICghT2JqZWN0LnNlYWwpIHtcbiAgICBPYmplY3Quc2VhbCA9IGZ1bmN0aW9uIHNlYWwob2JqZWN0KSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbWlzbGVhZGluZyBhbmQgYnJlYWtzIGZlYXR1cmUtZGV0ZWN0aW9uLCBidXRcbiAgICAgICAgLy8gYWxsb3dzIFwic2VjdXJhYmxlXCIgY29kZSB0byBcImdyYWNlZnVsbHlcIiBkZWdyYWRlIHRvIHdvcmtpbmdcbiAgICAgICAgLy8gYnV0IGluc2VjdXJlIGNvZGUuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjIuMy45XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4yLjMuOVxuaWYgKCFPYmplY3QuZnJlZXplKSB7XG4gICAgT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCBicmVha3MgZmVhdHVyZS1kZXRlY3Rpb24sIGJ1dFxuICAgICAgICAvLyBhbGxvd3MgXCJzZWN1cmFibGVcIiBjb2RlIHRvIFwiZ3JhY2VmdWxseVwiIGRlZ3JhZGUgdG8gd29ya2luZ1xuICAgICAgICAvLyBidXQgaW5zZWN1cmUgY29kZS5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG4vLyBkZXRlY3QgYSBSaGlubyBidWcgYW5kIHBhdGNoIGl0XG50cnkge1xuICAgIE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKCkge30pO1xufSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgT2JqZWN0LmZyZWV6ZSA9IChmdW5jdGlvbiBmcmVlemUoZnJlZXplT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmVlemVPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KE9iamVjdC5mcmVlemUpKTtcbn1cblxuLy8gRVM1IDE1LjIuMy4xMFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjEwXG5pZiAoIU9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKG9iamVjdCkge1xuICAgICAgICAvLyB0aGlzIGlzIG1pc2xlYWRpbmcgYW5kIGJyZWFrcyBmZWF0dXJlLWRldGVjdGlvbiwgYnV0XG4gICAgICAgIC8vIGFsbG93cyBcInNlY3VyYWJsZVwiIGNvZGUgdG8gXCJncmFjZWZ1bGx5XCIgZGVncmFkZSB0byB3b3JraW5nXG4gICAgICAgIC8vIGJ1dCBpbnNlY3VyZSBjb2RlLlxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTFcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMVxuaWYgKCFPYmplY3QuaXNTZWFsZWQpIHtcbiAgICBPYmplY3QuaXNTZWFsZWQgPSBmdW5jdGlvbiBpc1NlYWxlZChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xMlxuaWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcbiAgICBPYmplY3QuaXNGcm96ZW4gPSBmdW5jdGlvbiBpc0Zyb3plbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS4yLjMuMTNcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xM1xuaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKSB7XG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShvYmplY3QpIHtcbiAgICAgICAgLy8gMS4gSWYgVHlwZShPKSBpcyBub3QgT2JqZWN0IHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKE9iamVjdChvYmplY3QpICE9PSBvYmplY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gUmV0dXJuIHRoZSBCb29sZWFuIHZhbHVlIG9mIHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBPLlxuICAgICAgICB2YXIgbmFtZSA9ICcnO1xuICAgICAgICB3aGlsZSAob3ducyhvYmplY3QsIG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lICs9ICc/JztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSB0cnVlO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvd25zKG9iamVjdCwgbmFtZSk7XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmFtZV07XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9O1xufVxuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYm93ZXJfY29tcG9uZW50cy9lczUtc2hpbS9lczUtc2hhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJyZXF1aXJlKFwiISEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvYm93ZXJfY29tcG9uZW50cy9odG1sNXNoaXYvZGlzdC9odG1sNXNoaXYubWluLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL2h0bWw1c2hpdi9kaXN0L2h0bWw1c2hpdi5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcclxuXHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgPT09IFwiZnVuY3Rpb25cIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4qIEBwcmVzZXJ2ZSBIVE1MNSBTaGl2IDMuNy4yIHwgQGFmYXJrYXMgQGpkYWx0b24gQGpvbl9uZWFsIEByZW0gfCBNSVQvR1BMMiBMaWNlbnNlZFxcbiovXFxuIWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe3ZhciBjPWEuY3JlYXRlRWxlbWVudChcXFwicFxcXCIpLGQ9YS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiaGVhZFxcXCIpWzBdfHxhLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gYy5pbm5lckhUTUw9XFxcIng8c3R5bGU+XFxcIitiK1xcXCI8L3N0eWxlPlxcXCIsZC5pbnNlcnRCZWZvcmUoYy5sYXN0Q2hpbGQsZC5maXJzdENoaWxkKX1mdW5jdGlvbiBkKCl7dmFyIGE9dC5lbGVtZW50cztyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIGE/YS5zcGxpdChcXFwiIFxcXCIpOmF9ZnVuY3Rpb24gZShhLGIpe3ZhciBjPXQuZWxlbWVudHM7XFxcInN0cmluZ1xcXCIhPXR5cGVvZiBjJiYoYz1jLmpvaW4oXFxcIiBcXFwiKSksXFxcInN0cmluZ1xcXCIhPXR5cGVvZiBhJiYoYT1hLmpvaW4oXFxcIiBcXFwiKSksdC5lbGVtZW50cz1jK1xcXCIgXFxcIithLGooYil9ZnVuY3Rpb24gZihhKXt2YXIgYj1zW2FbcV1dO3JldHVybiBifHwoYj17fSxyKyssYVtxXT1yLHNbcl09YiksYn1mdW5jdGlvbiBnKGEsYyxkKXtpZihjfHwoYz1iKSxsKXJldHVybiBjLmNyZWF0ZUVsZW1lbnQoYSk7ZHx8KGQ9ZihjKSk7dmFyIGU7cmV0dXJuIGU9ZC5jYWNoZVthXT9kLmNhY2hlW2FdLmNsb25lTm9kZSgpOnAudGVzdChhKT8oZC5jYWNoZVthXT1kLmNyZWF0ZUVsZW0oYSkpLmNsb25lTm9kZSgpOmQuY3JlYXRlRWxlbShhKSwhZS5jYW5IYXZlQ2hpbGRyZW58fG8udGVzdChhKXx8ZS50YWdVcm4/ZTpkLmZyYWcuYXBwZW5kQ2hpbGQoZSl9ZnVuY3Rpb24gaChhLGMpe2lmKGF8fChhPWIpLGwpcmV0dXJuIGEuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2M9Y3x8ZihhKTtmb3IodmFyIGU9Yy5mcmFnLmNsb25lTm9kZSgpLGc9MCxoPWQoKSxpPWgubGVuZ3RoO2k+ZztnKyspZS5jcmVhdGVFbGVtZW50KGhbZ10pO3JldHVybiBlfWZ1bmN0aW9uIGkoYSxiKXtiLmNhY2hlfHwoYi5jYWNoZT17fSxiLmNyZWF0ZUVsZW09YS5jcmVhdGVFbGVtZW50LGIuY3JlYXRlRnJhZz1hLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsYi5mcmFnPWIuY3JlYXRlRnJhZygpKSxhLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24oYyl7cmV0dXJuIHQuc2hpdk1ldGhvZHM/ZyhjLGEsYik6Yi5jcmVhdGVFbGVtKGMpfSxhLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQ9RnVuY3Rpb24oXFxcImgsZlxcXCIsXFxcInJldHVybiBmdW5jdGlvbigpe3ZhciBuPWYuY2xvbmVOb2RlKCksYz1uLmNyZWF0ZUVsZW1lbnQ7aC5zaGl2TWV0aG9kcyYmKFxcXCIrZCgpLmpvaW4oKS5yZXBsYWNlKC9bXFxcXHdcXFxcLTpdKy9nLGZ1bmN0aW9uKGEpe3JldHVybiBiLmNyZWF0ZUVsZW0oYSksYi5mcmFnLmNyZWF0ZUVsZW1lbnQoYSksJ2MoXFxcIicrYSsnXFxcIiknfSkrXFxcIik7cmV0dXJuIG59XFxcIikodCxiLmZyYWcpfWZ1bmN0aW9uIGooYSl7YXx8KGE9Yik7dmFyIGQ9ZihhKTtyZXR1cm4hdC5zaGl2Q1NTfHxrfHxkLmhhc0NTU3x8KGQuaGFzQ1NTPSEhYyhhLFxcXCJhcnRpY2xlLGFzaWRlLGRpYWxvZyxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGhncm91cCxtYWluLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9bWFya3tiYWNrZ3JvdW5kOiNGRjA7Y29sb3I6IzAwMH10ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9XFxcIikpLGx8fGkoYSxkKSxhfXZhciBrLGwsbT1cXFwiMy43LjJcXFwiLG49YS5odG1sNXx8e30sbz0vXjx8Xig/OmJ1dHRvbnxtYXB8c2VsZWN0fHRleHRhcmVhfG9iamVjdHxpZnJhbWV8b3B0aW9ufG9wdGdyb3VwKSQvaSxwPS9eKD86YXxifGNvZGV8ZGl2fGZpZWxkc2V0fGgxfGgyfGgzfGg0fGg1fGg2fGl8bGFiZWx8bGl8b2x8cHxxfHNwYW58c3Ryb25nfHN0eWxlfHRhYmxlfHRib2R5fHRkfHRofHRyfHVsKSQvaSxxPVxcXCJfaHRtbDVzaGl2XFxcIixyPTAscz17fTshZnVuY3Rpb24oKXt0cnl7dmFyIGE9Yi5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIik7YS5pbm5lckhUTUw9XFxcIjx4eXo+PC94eXo+XFxcIixrPVxcXCJoaWRkZW5cXFwiaW4gYSxsPTE9PWEuY2hpbGROb2Rlcy5sZW5ndGh8fGZ1bmN0aW9uKCl7Yi5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIik7dmFyIGE9Yi5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhLmNsb25lTm9kZXx8XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhLmNyZWF0ZURvY3VtZW50RnJhZ21lbnR8fFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYS5jcmVhdGVFbGVtZW50fSgpfWNhdGNoKGMpe2s9ITAsbD0hMH19KCk7dmFyIHQ9e2VsZW1lbnRzOm4uZWxlbWVudHN8fFxcXCJhYmJyIGFydGljbGUgYXNpZGUgYXVkaW8gYmRpIGNhbnZhcyBkYXRhIGRhdGFsaXN0IGRldGFpbHMgZGlhbG9nIGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBoZWFkZXIgaGdyb3VwIG1haW4gbWFyayBtZXRlciBuYXYgb3V0cHV0IHBpY3R1cmUgcHJvZ3Jlc3Mgc2VjdGlvbiBzdW1tYXJ5IHRlbXBsYXRlIHRpbWUgdmlkZW9cXFwiLHZlcnNpb246bSxzaGl2Q1NTOm4uc2hpdkNTUyE9PSExLHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzOmwsc2hpdk1ldGhvZHM6bi5zaGl2TWV0aG9kcyE9PSExLHR5cGU6XFxcImRlZmF1bHRcXFwiLHNoaXZEb2N1bWVudDpqLGNyZWF0ZUVsZW1lbnQ6ZyxjcmVhdGVEb2N1bWVudEZyYWdtZW50OmgsYWRkRWxlbWVudHM6ZX07YS5odG1sNT10LGooYil9KHRoaXMsZG9jdW1lbnQpO1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL2Jvd2VyX2NvbXBvbmVudHMvaHRtbDVzaGl2L2Rpc3QvaHRtbDVzaGl2Lm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJyZXF1aXJlKFwiISEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvYm93ZXJfY29tcG9uZW50cy9qc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvci5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9qc29uZWRpdG9yL2Rpc3QvanNvbmVkaXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICoganNvbmVkaXRvci5qc1xcbiAqXFxuICogQGJyaWVmXFxuICogSlNPTkVkaXRvciBpcyBhIHdlYi1iYXNlZCB0b29sIHRvIHZpZXcsIGVkaXQsIGFuZCBmb3JtYXQgSlNPTi5cXG4gKiBJdCBzaG93cyBkYXRhIGEgY2xlYXIsIGVkaXRhYmxlIHRyZWV2aWV3LlxcbiAqXFxuICogU3VwcG9ydGVkIGJyb3dzZXJzOiBDaHJvbWUsIEZpcmVmb3gsIFNhZmFyaSwgT3BlcmEsIEludGVybmV0IEV4cGxvcmVyIDgrXFxuICpcXG4gKiBAbGljZW5zZVxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpOyB5b3UgbWF5IG5vdFxcbiAqIHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5XFxuICogb2YgdGhlIExpY2Vuc2UgYXRcXG4gKlxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcbiAqXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFxcXCJBUyBJU1xcXCIgQkFTSVMsIFdJVEhPVVRcXG4gKiBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlclxcbiAqIHRoZSBMaWNlbnNlLlxcbiAqXFxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTUgSm9zIGRlIEpvbmcsIGh0dHA6Ly9qc29uZWRpdG9yb25saW5lLm9yZ1xcbiAqXFxuICogQGF1dGhvciAgSm9zIGRlIEpvbmcsIDx3am9zZGVqb25nQGdtYWlsLmNvbT5cXG4gKiBAdmVyc2lvbiA0LjIuMVxcbiAqIEBkYXRlICAgIDIwMTUtMDYtMTNcXG4gKi9cXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xcblxcdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcXG5cXHRcXHRkZWZpbmUoZmFjdG9yeSk7XFxuXFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXFxuXFx0XFx0ZXhwb3J0c1tcXFwiSlNPTkVkaXRvclxcXCJdID0gZmFjdG9yeSgpO1xcblxcdGVsc2VcXG5cXHRcXHRyb290W1xcXCJKU09ORWRpdG9yXFxcIl0gPSBmYWN0b3J5KCk7XFxufSkodGhpcywgZnVuY3Rpb24oKSB7XFxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcXG4vKioqKioqLyBcXHQvLyBUaGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcXG5cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcXG4vKioqKioqLyBcXHRcXHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcXG4vKioqKioqLyBcXHRcXHRcXHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcXG4vKioqKioqLyBcXHRcXHRcXHRleHBvcnRzOiB7fSxcXG4vKioqKioqLyBcXHRcXHRcXHRpZDogbW9kdWxlSWQsXFxuLyoqKioqKi8gXFx0XFx0XFx0bG9hZGVkOiBmYWxzZVxcbi8qKioqKiovIFxcdFxcdH07XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG5cXG5cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XFxuXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcblxcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovIChbXFxuLyogMCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciB0cmVlbW9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuXFx0dmFyIHRleHRtb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG5cXHR2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGNvbnN0cnVjdG9yIEpTT05FZGl0b3JcXG5cXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgICBDb250YWluZXIgZWxlbWVudFxcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnNdICAgIE9iamVjdCB3aXRoIG9wdGlvbnMuIGF2YWlsYWJsZSBvcHRpb25zOlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG1vZGUgICAgICBFZGl0b3IgbW9kZS4gQXZhaWxhYmxlIHZhbHVlczpcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyZWUnIChkZWZhdWx0KSwgJ3ZpZXcnLFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9ybScsICd0ZXh0JywgYW5kICdjb2RlJy5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVuY3Rpb259IGNoYW5nZSAgQ2FsbGJhY2sgbWV0aG9kLCB0cmlnZ2VyZWRcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gY2hhbmdlIG9mIGNvbnRlbnRzXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Jvb2xlYW59IHNlYXJjaCAgIEVuYWJsZSBzZWFyY2ggYm94LlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlIGJ5IGRlZmF1bHRcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSBhcHBsaWNhYmxlIGZvciBtb2Rlc1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHJlZScsICd2aWV3JywgYW5kICdmb3JtJ1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBoaXN0b3J5ICBFbmFibGUgaGlzdG9yeSAodW5kby9yZWRvKS5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSBieSBkZWZhdWx0XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgYXBwbGljYWJsZSBmb3IgbW9kZXNcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyZWUnLCAndmlldycsIGFuZCAnZm9ybSdcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBuYW1lICAgICAgRmllbGQgbmFtZSBmb3IgdGhlIHJvb3Qgbm9kZS5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSBhcHBsaWNhYmxlIGZvciBtb2Rlc1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHJlZScsICd2aWV3JywgYW5kICdmb3JtJ1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IGluZGVudGF0aW9uICAgTnVtYmVyIG9mIGluZGVudGF0aW9uXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXMuIDQgYnkgZGVmYXVsdC5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgYXBwbGljYWJsZSBmb3JcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVzICd0ZXh0JyBhbmQgJ2NvZGUnXFxuXFx0ICogQHBhcmFtIHtPYmplY3QgfCB1bmRlZmluZWR9IGpzb24gSlNPTiBvYmplY3RcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBKU09ORWRpdG9yIChjb250YWluZXIsIG9wdGlvbnMsIGpzb24pIHtcXG5cXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKU09ORWRpdG9yKSkge1xcblxcdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT05FZGl0b3IgY29uc3RydWN0b3IgY2FsbGVkIHdpdGhvdXQgXFxcIm5ld1xcXCIuJyk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBjaGVjayBmb3IgdW5zdXBwb3J0ZWQgYnJvd3NlciAoSUU4IGFuZCBvbGRlcilcXG5cXHQgIHZhciBpZVZlcnNpb24gPSB1dGlsLmdldEludGVybmV0RXhwbG9yZXJWZXJzaW9uKCk7XFxuXFx0ICBpZiAoaWVWZXJzaW9uICE9IC0xICYmIGllVmVyc2lvbiA8IDkpIHtcXG5cXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBicm93c2VyLCBJRTkgb3IgbmV3ZXIgcmVxdWlyZWQuICcgK1xcblxcdCAgICAgICAgJ1BsZWFzZSBpbnN0YWxsIHRoZSBuZXdlc3QgdmVyc2lvbiBvZiB5b3VyIGJyb3dzZXIuJyk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xcblxcdCAgICB0aGlzLl9jcmVhdGUoY29udGFpbmVyLCBvcHRpb25zLCBqc29uKTtcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29uZmlndXJhdGlvbiBmb3IgYWxsIHJlZ2lzdGVyZWQgbW9kZXMuIEV4YW1wbGU6XFxuXFx0ICoge1xcblxcdCAqICAgICB0cmVlOiB7XFxuXFx0ICogICAgICAgICBtaXhpbjogVHJlZUVkaXRvcixcXG5cXHQgKiAgICAgICAgIGRhdGE6ICdqc29uJ1xcblxcdCAqICAgICB9LFxcblxcdCAqICAgICB0ZXh0OiB7XFxuXFx0ICogICAgICAgICBtaXhpbjogVGV4dEVkaXRvcixcXG5cXHQgKiAgICAgICAgIGRhdGE6ICd0ZXh0J1xcblxcdCAqICAgICB9XFxuXFx0ICogfVxcblxcdCAqXFxuXFx0ICogQHR5cGUgeyBPYmplY3QuPFN0cmluZywge21peGluOiBPYmplY3QsIGRhdGE6IFN0cmluZ30gPiB9XFxuXFx0ICovXFxuXFx0SlNPTkVkaXRvci5tb2RlcyA9IHt9O1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZSB0aGUgSlNPTkVkaXRvclxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyICAgIENvbnRhaW5lciBlbGVtZW50XFxuXFx0ICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9uc10gICAgU2VlIGRlc2NyaXB0aW9uIGluIGNvbnN0cnVjdG9yXFxuXFx0ICogQHBhcmFtIHtPYmplY3QgfCB1bmRlZmluZWR9IGpzb24gSlNPTiBvYmplY3RcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdEpTT05FZGl0b3IucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zLCBqc29uKSB7XFxuXFx0ICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcXG5cXHQgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFx0ICB0aGlzLmpzb24gPSBqc29uIHx8IHt9O1xcblxcblxcdCAgdmFyIG1vZGUgPSB0aGlzLm9wdGlvbnMubW9kZSB8fCAndHJlZSc7XFxuXFx0ICB0aGlzLnNldE1vZGUobW9kZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEZXRhY2ggdGhlIGVkaXRvciBmcm9tIHRoZSBET01cXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdEpTT05FZGl0b3IucHJvdG90eXBlLl9kZWxldGUgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgSlNPTiBvYmplY3QgaW4gZWRpdG9yXFxuXFx0ICogQHBhcmFtIHtPYmplY3QgfCB1bmRlZmluZWR9IGpzb24gICAgICBKU09OIGRhdGFcXG5cXHQgKi9cXG5cXHRKU09ORWRpdG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoanNvbikge1xcblxcdCAgdGhpcy5qc29uID0ganNvbjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCBKU09OIGZyb20gdGhlIGVkaXRvclxcblxcdCAqIEByZXR1cm5zIHtPYmplY3R9IGpzb25cXG5cXHQgKi9cXG5cXHRKU09ORWRpdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICByZXR1cm4gdGhpcy5qc29uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0IHN0cmluZyBjb250YWluaW5nIEpTT04gZm9yIHRoZSBlZGl0b3JcXG5cXHQgKiBAcGFyYW0ge1N0cmluZyB8IHVuZGVmaW5lZH0ganNvblRleHRcXG5cXHQgKi9cXG5cXHRKU09ORWRpdG9yLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKGpzb25UZXh0KSB7XFxuXFx0ICB0aGlzLmpzb24gPSB1dGlsLnBhcnNlKGpzb25UZXh0KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCBzdHJpbmdpZmllZCBKU09OIGNvbnRlbnRzIGZyb20gdGhlIGVkaXRvclxcblxcdCAqIEByZXR1cm5zIHtTdHJpbmd9IGpzb25UZXh0XFxuXFx0ICovXFxuXFx0SlNPTkVkaXRvci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmpzb24pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0IGEgZmllbGQgbmFtZSBmb3IgdGhlIHJvb3Qgbm9kZS5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZyB8IHVuZGVmaW5lZH0gbmFtZVxcblxcdCAqL1xcblxcdEpTT05FZGl0b3IucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xcblxcdCAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcXG5cXHQgICAgdGhpcy5vcHRpb25zID0ge307XFxuXFx0ICB9XFxuXFx0ICB0aGlzLm9wdGlvbnMubmFtZSA9IG5hbWU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgdGhlIGZpZWxkIG5hbWUgZm9yIHRoZSByb290IG5vZGUuXFxuXFx0ICogQHJldHVybiB7U3RyaW5nIHwgdW5kZWZpbmVkfSBuYW1lXFxuXFx0ICovXFxuXFx0SlNPTkVkaXRvci5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHJldHVybiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5hbWU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGFuZ2UgdGhlIG1vZGUgb2YgdGhlIGVkaXRvci5cXG5cXHQgKiBKU09ORWRpdG9yIHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBhbGwgbWV0aG9kcyBuZWVkZWQgZm9yIHRoZSBjaG9zZW4gbW9kZS5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSAgICAgQXZhaWxhYmxlIG1vZGVzOiAndHJlZScgKGRlZmF1bHQpLCAndmlldycsICdmb3JtJyxcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQnLCBhbmQgJ2NvZGUnLlxcblxcdCAqL1xcblxcdEpTT05FZGl0b3IucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xcblxcdCAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxcblxcdCAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKSxcXG5cXHQgICAgICBkYXRhLFxcblxcdCAgICAgIG5hbWU7XFxuXFxuXFx0ICBvcHRpb25zLm1vZGUgPSBtb2RlO1xcblxcdCAgdmFyIGNvbmZpZyA9IEpTT05FZGl0b3IubW9kZXNbbW9kZV07XFxuXFx0ICBpZiAoY29uZmlnKSB7XFxuXFx0ICAgIHRyeSB7XFxuXFx0ICAgICAgdmFyIGFzVGV4dCA9IChjb25maWcuZGF0YSA9PSAndGV4dCcpO1xcblxcdCAgICAgIG5hbWUgPSB0aGlzLmdldE5hbWUoKTtcXG5cXHQgICAgICBkYXRhID0gdGhpc1thc1RleHQgPyAnZ2V0VGV4dCcgOiAnZ2V0J10oKTsgLy8gZ2V0IHRleHQgb3IganNvblxcblxcblxcdCAgICAgIHRoaXMuX2RlbGV0ZSgpO1xcblxcdCAgICAgIHV0aWwuY2xlYXIodGhpcyk7XFxuXFx0ICAgICAgdXRpbC5leHRlbmQodGhpcywgY29uZmlnLm1peGluKTtcXG5cXHQgICAgICB0aGlzLmNyZWF0ZShjb250YWluZXIsIG9wdGlvbnMpO1xcblxcblxcdCAgICAgIHRoaXMuc2V0TmFtZShuYW1lKTtcXG5cXHQgICAgICB0aGlzW2FzVGV4dCA/ICdzZXRUZXh0JyA6ICdzZXQnXShkYXRhKTsgLy8gc2V0IHRleHQgb3IganNvblxcblxcblxcdCAgICAgIGlmICh0eXBlb2YgY29uZmlnLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcXG5cXHQgICAgICAgIHRyeSB7XFxuXFx0ICAgICAgICAgIGNvbmZpZy5sb2FkLmNhbGwodGhpcyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBjYXRjaCAoZXJyKSB7fVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBjYXRjaCAoZXJyKSB7XFxuXFx0ICAgICAgdGhpcy5fb25FcnJvcihlcnIpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgXFxcIicgKyBvcHRpb25zLm1vZGUgKyAnXFxcIicpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGhyb3cgYW4gZXJyb3IuIElmIGFuIGVycm9yIGNhbGxiYWNrIGlzIGNvbmZpZ3VyZWQgaW4gb3B0aW9ucy5lcnJvciwgdGhpc1xcblxcdCAqIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZC4gRWxzZSwgYSByZWd1bGFyIGVycm9yIGlzIHRocm93bi5cXG5cXHQgKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdEpTT05FZGl0b3IucHJvdG90eXBlLl9vbkVycm9yID0gZnVuY3Rpb24oZXJyKSB7XFxuXFx0ICAvLyBUT0RPOiBvbkVycm9yIGlzIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjIuMC4gY2xlYW51cCBzb21lIGRheVxcblxcdCAgaWYgKHR5cGVvZiB0aGlzLm9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcXG5cXHQgICAgdXRpbC5sb2coJ1dBUk5JTkc6IEpTT05FZGl0b3Iub25FcnJvciBpcyBkZXByZWNhdGVkLiAnICtcXG5cXHQgICAgICAgICdVc2Ugb3B0aW9ucy5lcnJvciBpbnN0ZWFkLicpO1xcblxcdCAgICB0aGlzLm9uRXJyb3IoZXJyKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLm9wdGlvbnMgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICB0aGlzLm9wdGlvbnMuZXJyb3IoZXJyKTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICB0aHJvdyBlcnI7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWdpc3RlciBhIHBsdWdpbiB3aXRoIG9uZSBvcmUgbXVsdGlwbGUgbW9kZXMgZm9yIHRoZSBKU09OIEVkaXRvci5cXG5cXHQgKlxcblxcdCAqIEEgbW9kZSBpcyBkZXNjcmliZWQgYXMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllczpcXG5cXHQgKlxcblxcdCAqIC0gYG1vZGU6IFN0cmluZ2AgICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtb2RlLlxcblxcdCAqIC0gYG1peGluOiBPYmplY3RgICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtaXhpbiBmdW5jdGlvbnMgd2hpY2hcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGFkZGVkIHRvIHRoZSBKU09ORWRpdG9yLiBNdXN0IGNvbnRhaW4gZnVuY3Rpb25zXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlLCBnZXQsIGdldFRleHQsIHNldCwgYW5kIHNldFRleHQuIE1heSBoYXZlXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbCBmdW5jdGlvbnMuXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB0aGUgSlNPTkVkaXRvciBzd2l0Y2hlcyB0byBhIG1peGluLCBhbGwgbWl4aW5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbnMgYXJlIGFkZGVkIHRvIHRoZSBKU09ORWRpdG9yLCBhbmQgdGhlblxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmdW5jdGlvbiBgY3JlYXRlKGNvbnRhaW5lciwgb3B0aW9ucylgIGlzIGV4ZWN1dGVkLlxcblxcdCAqIC0gYGRhdGE6ICd0ZXh0JyB8ICdqc29uJ2AgIFRoZSB0eXBlIG9mIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbG9hZCB0aGUgbWl4aW4uXFxuXFx0ICogLSBgW2xvYWQ6IGZ1bmN0aW9uXWAgICAgICAgQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIGFmdGVyIHRoZSBtaXhpblxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIGxvYWRlZC5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IG1vZGUgIEEgbW9kZSBvYmplY3Qgb3IgYW4gYXJyYXkgd2l0aCBtdWx0aXBsZSBtb2RlIG9iamVjdHMuXFxuXFx0ICovXFxuXFx0SlNPTkVkaXRvci5yZWdpc3Rlck1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xcblxcdCAgdmFyIGksIHByb3A7XFxuXFxuXFx0ICBpZiAodXRpbC5pc0FycmF5KG1vZGUpKSB7XFxuXFx0ICAgIC8vIG11bHRpcGxlIG1vZGVzXFxuXFx0ICAgIGZvciAoaSA9IDA7IGkgPCBtb2RlLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgSlNPTkVkaXRvci5yZWdpc3Rlck1vZGUobW9kZVtpXSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICAvLyB2YWxpZGF0ZSB0aGUgbmV3IG1vZGVcXG5cXHQgICAgaWYgKCEoJ21vZGUnIGluIG1vZGUpKSB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFxcXCJtb2RlXFxcIiBtaXNzaW5nJyk7XFxuXFx0ICAgIGlmICghKCdtaXhpbicgaW4gbW9kZSkpIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXFxcIm1peGluXFxcIiBtaXNzaW5nJyk7XFxuXFx0ICAgIGlmICghKCdkYXRhJyBpbiBtb2RlKSkgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBcXFwiZGF0YVxcXCIgbWlzc2luZycpO1xcblxcdCAgICB2YXIgbmFtZSA9IG1vZGUubW9kZTtcXG5cXHQgICAgaWYgKG5hbWUgaW4gSlNPTkVkaXRvci5tb2Rlcykge1xcblxcdCAgICAgIHRocm93IG5ldyBFcnJvcignTW9kZSBcXFwiJyArIG5hbWUgKyAnXFxcIiBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyB2YWxpZGF0ZSB0aGUgbWl4aW5cXG5cXHQgICAgaWYgKHR5cGVvZiBtb2RlLm1peGluLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgZnVuY3Rpb24gXFxcImNyZWF0ZVxcXCIgbWlzc2luZyBvbiBtaXhpbicpO1xcblxcdCAgICB9XFxuXFx0ICAgIHZhciByZXNlcnZlZCA9IFsnc2V0TW9kZScsICdyZWdpc3Rlck1vZGUnLCAnbW9kZXMnXTtcXG5cXHQgICAgZm9yIChpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgcHJvcCA9IHJlc2VydmVkW2ldO1xcblxcdCAgICAgIGlmIChwcm9wIGluIG1vZGUubWl4aW4pIHtcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzZXJ2ZWQgcHJvcGVydHkgXFxcIicgKyBwcm9wICsgJ1xcXCIgbm90IGFsbG93ZWQgaW4gbWl4aW4nKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgSlNPTkVkaXRvci5tb2Rlc1tuYW1lXSA9IG1vZGU7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvLyByZWdpc3RlciB0cmVlIGFuZCB0ZXh0IG1vZGVzXFxuXFx0SlNPTkVkaXRvci5yZWdpc3Rlck1vZGUodHJlZW1vZGUpO1xcblxcdEpTT05FZGl0b3IucmVnaXN0ZXJNb2RlKHRleHRtb2RlKTtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05FZGl0b3I7XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiAxICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIEhpZ2hsaWdodGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcXG5cXHR2YXIgSGlzdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuXFx0dmFyIFNlYXJjaEJveCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuXFx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xcblxcdHZhciBtb2Rlc3dpdGNoZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xcblxcdHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG5cXG5cXHQvLyBjcmVhdGUgYSBtaXhpbiB3aXRoIHRoZSBmdW5jdGlvbnMgZm9yIHRyZWUgbW9kZVxcblxcdHZhciB0cmVlbW9kZSA9IHt9O1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZSBhIHRyZWUgZWRpdG9yXFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICAgQ29udGFpbmVyIGVsZW1lbnRcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXSAgICBPYmplY3Qgd2l0aCBvcHRpb25zLiBhdmFpbGFibGUgb3B0aW9uczpcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBtb2RlICAgICAgRWRpdG9yIG1vZGUuIEF2YWlsYWJsZSB2YWx1ZXM6XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0cmVlJyAoZGVmYXVsdCksICd2aWV3JyxcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kICdmb3JtJy5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Qm9vbGVhbn0gc2VhcmNoICAgRW5hYmxlIHNlYXJjaCBib3guXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRydWUgYnkgZGVmYXVsdFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtCb29sZWFufSBoaXN0b3J5ICBFbmFibGUgaGlzdG9yeSAodW5kby9yZWRvKS5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSBieSBkZWZhdWx0XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBjaGFuZ2UgIENhbGxiYWNrIG1ldGhvZCwgdHJpZ2dlcmVkXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIGNoYW5nZSBvZiBjb250ZW50c1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG5hbWUgICAgICBGaWVsZCBuYW1lIGZvciB0aGUgcm9vdCBub2RlLlxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgb3B0aW9ucykge1xcblxcdCAgaWYgKCFjb250YWluZXIpIHtcXG5cXHQgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb250YWluZXIgZWxlbWVudCBwcm92aWRlZC4nKTtcXG5cXHQgIH1cXG5cXHQgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xcblxcdCAgdGhpcy5kb20gPSB7fTtcXG5cXHQgIHRoaXMuaGlnaGxpZ2h0ZXIgPSBuZXcgSGlnaGxpZ2h0ZXIoKTtcXG5cXHQgIHRoaXMuc2VsZWN0aW9uID0gdW5kZWZpbmVkOyAvLyB3aWxsIGhvbGQgdGhlIGxhc3QgaW5wdXQgc2VsZWN0aW9uXFxuXFxuXFx0ICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xcblxcblxcdCAgaWYgKHRoaXMub3B0aW9ucy5oaXN0b3J5ICYmIHRoaXMub3B0aW9ucy5tb2RlICE9PSAndmlldycpIHtcXG5cXHQgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcyk7XFxuXFx0ICB9XFxuXFxuXFx0ICB0aGlzLl9jcmVhdGVGcmFtZSgpO1xcblxcdCAgdGhpcy5fY3JlYXRlVGFibGUoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERldGFjaCB0aGUgZWRpdG9yIGZyb20gdGhlIERPTVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuX2RlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIGlmICh0aGlzLmZyYW1lICYmIHRoaXMuY29udGFpbmVyICYmIHRoaXMuZnJhbWUucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRhaW5lcikge1xcblxcdCAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEluaXRpYWxpemUgYW5kIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gIFtvcHRpb25zXSAgICBTZWUgZGVzY3JpcHRpb24gaW4gY29uc3RydWN0b3JcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdHRyZWVtb2RlLl9zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG5cXHQgIHRoaXMub3B0aW9ucyA9IHtcXG5cXHQgICAgc2VhcmNoOiB0cnVlLFxcblxcdCAgICBoaXN0b3J5OiB0cnVlLFxcblxcdCAgICBtb2RlOiAndHJlZScsXFxuXFx0ICAgIG5hbWU6IHVuZGVmaW5lZCAgIC8vIGZpZWxkIG5hbWUgb2Ygcm9vdCBub2RlXFxuXFx0ICB9O1xcblxcblxcdCAgLy8gY29weSBhbGwgb3B0aW9uc1xcblxcdCAgaWYgKG9wdGlvbnMpIHtcXG5cXHQgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XFxuXFx0ICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcXG5cXHQgICAgICAgIHRoaXMub3B0aW9uc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvLyBub2RlIGN1cnJlbnRseSBiZWluZyBlZGl0ZWRcXG5cXHR2YXIgZm9jdXNOb2RlID0gdW5kZWZpbmVkO1xcblxcblxcdC8vIGRvbSBoYXZpbmcgZm9jdXNcXG5cXHR2YXIgZG9tRm9jdXMgPSBudWxsO1xcblxcblxcdC8qKlxcblxcdCAqIFNldCBKU09OIG9iamVjdCBpbiBlZGl0b3JcXG5cXHQgKiBAcGFyYW0ge09iamVjdCB8IHVuZGVmaW5lZH0ganNvbiAgICAgIEpTT04gZGF0YVxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICBbbmFtZV0gICAgT3B0aW9uYWwgZmllbGQgbmFtZSBmb3IgdGhlIHJvb3Qgbm9kZS5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhbiBhbHNvIGJlIHNldCB1c2luZyBzZXROYW1lKG5hbWUpLlxcblxcdCAqL1xcblxcdHRyZWVtb2RlLnNldCA9IGZ1bmN0aW9uIChqc29uLCBuYW1lKSB7XFxuXFx0ICAvLyBhZGp1c3QgZmllbGQgbmFtZSBmb3Igcm9vdCBub2RlXFxuXFx0ICBpZiAobmFtZSkge1xcblxcdCAgICAvLyBUT0RPOiBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4yLjAuIENsZWFudXAgc29tZSBkYXkuXFxuXFx0ICAgIHV0aWwubG9nKCdXYXJuaW5nOiBzZWNvbmQgcGFyYW1ldGVyIFxcXCJuYW1lXFxcIiBpcyBkZXByZWNhdGVkLiAnICtcXG5cXHQgICAgICAgICdVc2Ugc2V0TmFtZShuYW1lKSBpbnN0ZWFkLicpO1xcblxcdCAgICB0aGlzLm9wdGlvbnMubmFtZSA9IG5hbWU7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyB2ZXJpZnkgaWYganNvbiBpcyB2YWxpZCBKU09OLCBpZ25vcmUgd2hlbiBhIGZ1bmN0aW9uXFxuXFx0ICBpZiAoanNvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IChqc29uID09PSB1bmRlZmluZWQpKSB7XFxuXFx0ICAgIHRoaXMuY2xlYXIoKTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICB0aGlzLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy50YWJsZSk7ICAvLyBUYWtlIHRoZSB0YWJsZSBvZmZsaW5lXFxuXFxuXFx0ICAgIC8vIHJlcGxhY2UgdGhlIHJvb3Qgbm9kZVxcblxcdCAgICB2YXIgcGFyYW1zID0ge1xcblxcdCAgICAgICdmaWVsZCc6IHRoaXMub3B0aW9ucy5uYW1lLFxcblxcdCAgICAgICd2YWx1ZSc6IGpzb25cXG5cXHQgICAgfTtcXG5cXHQgICAgdmFyIG5vZGUgPSBuZXcgTm9kZSh0aGlzLCBwYXJhbXMpO1xcblxcdCAgICB0aGlzLl9zZXRSb290KG5vZGUpO1xcblxcblxcdCAgICAvLyBleHBhbmRcXG5cXHQgICAgdmFyIHJlY3Vyc2UgPSBmYWxzZTtcXG5cXHQgICAgdGhpcy5ub2RlLmV4cGFuZChyZWN1cnNlKTtcXG5cXG5cXHQgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMudGFibGUpOyAgLy8gUHV0IHRoZSB0YWJsZSBvbmxpbmUgYWdhaW5cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFRPRE86IG1haW50YWluIGhpc3RvcnksIHN0b3JlIGxhc3Qgc3RhdGUgYW5kIHByZXZpb3VzIGRvY3VtZW50XFxuXFx0ICBpZiAodGhpcy5oaXN0b3J5KSB7XFxuXFx0ICAgIHRoaXMuaGlzdG9yeS5jbGVhcigpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IEpTT04gb2JqZWN0IGZyb20gZWRpdG9yXFxuXFx0ICogQHJldHVybiB7T2JqZWN0IHwgdW5kZWZpbmVkfSBqc29uXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xcblxcdCAgLy8gcmVtb3ZlIGZvY3VzIGZyb20gY3VycmVudGx5IGVkaXRlZCBub2RlXFxuXFx0ICBpZiAoZm9jdXNOb2RlKSB7XFxuXFx0ICAgIGZvY3VzTm9kZS5ibHVyKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAodGhpcy5ub2RlKSB7XFxuXFx0ICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VmFsdWUoKTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICByZXR1cm4gdW5kZWZpbmVkO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBlZGl0b3JcXG5cXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb25UZXh0XFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0KCkpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0IHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBlZGl0b3JcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30ganNvblRleHRcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5zZXRUZXh0ID0gZnVuY3Rpb24oanNvblRleHQpIHtcXG5cXHQgIHRoaXMuc2V0KHV0aWwucGFyc2UoanNvblRleHQpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldCBhIGZpZWxkIG5hbWUgZm9yIHRoZSByb290IG5vZGUuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmcgfCB1bmRlZmluZWR9IG5hbWVcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5zZXROYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcXG5cXHQgIHRoaXMub3B0aW9ucy5uYW1lID0gbmFtZTtcXG5cXHQgIGlmICh0aGlzLm5vZGUpIHtcXG5cXHQgICAgdGhpcy5ub2RlLnVwZGF0ZUZpZWxkKHRoaXMub3B0aW9ucy5uYW1lKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgZmllbGQgbmFtZSBmb3IgdGhlIHJvb3Qgbm9kZS5cXG5cXHQgKiBAcmV0dXJuIHtTdHJpbmcgfCB1bmRlZmluZWR9IG5hbWVcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xcblxcdCAgcmV0dXJuIHRoaXMub3B0aW9ucy5uYW1lO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0IGZvY3VzIHRvIHRoZSBlZGl0b3IuIEZvY3VzIHdpbGwgYmUgc2V0IHRvOlxcblxcdCAqIC0gdGhlIGZpcnN0IGVkaXRhYmxlIGZpZWxkIG9yIHZhbHVlLCBvciBlbHNlXFxuXFx0ICogLSB0byB0aGUgZXhwYW5kIGJ1dHRvbiBvZiB0aGUgcm9vdCBub2RlLCBvciBlbHNlXFxuXFx0ICogLSB0byB0aGUgY29udGV4dCBtZW51IGJ1dHRvbiBvZiB0aGUgcm9vdCBub2RlLCBvciBlbHNlXFxuXFx0ICogLSB0byB0aGUgZmlyc3QgYnV0dG9uIGluIHRoZSB0b3AgbWVudVxcblxcdCAqL1xcblxcdHRyZWVtb2RlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdmFyIGlucHV0ID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ1tjb250ZW50ZWRpdGFibGU9dHJ1ZV0nKTtcXG5cXHQgIGlmIChpbnB1dCkge1xcblxcdCAgICBpbnB1dC5mb2N1cygpO1xcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAodGhpcy5ub2RlLmRvbS5leHBhbmQpIHtcXG5cXHQgICAgdGhpcy5ub2RlLmRvbS5leHBhbmQuZm9jdXMoKTtcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKHRoaXMubm9kZS5kb20ubWVudSkge1xcblxcdCAgICB0aGlzLm5vZGUuZG9tLm1lbnUuZm9jdXMoKTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICAvLyBmb2N1cyB0byB0aGUgZmlyc3QgYnV0dG9uIGluIHRoZSBtZW51XFxuXFx0ICAgIGlucHV0ID0gdGhpcy5mcmFtZS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcXG5cXHQgICAgaWYgKGlucHV0KSB7XFxuXFx0ICAgICAgaW5wdXQuZm9jdXMoKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVtb3ZlIHRoZSByb290IG5vZGUgZnJvbSB0aGUgZWRpdG9yXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy5ub2RlKSB7XFxuXFx0ICAgIHRoaXMubm9kZS5jb2xsYXBzZSgpO1xcblxcdCAgICB0aGlzLnRib2R5LnJlbW92ZUNoaWxkKHRoaXMubm9kZS5nZXREb20oKSk7XFxuXFx0ICAgIGRlbGV0ZSB0aGlzLm5vZGU7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgdGhlIHJvb3Qgbm9kZSBmb3IgdGhlIGpzb24gZWRpdG9yXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5fc2V0Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7XFxuXFx0ICB0aGlzLmNsZWFyKCk7XFxuXFxuXFx0ICB0aGlzLm5vZGUgPSBub2RlO1xcblxcblxcdCAgLy8gYXBwZW5kIHRvIHRoZSBkb21cXG5cXHQgIHRoaXMudGJvZHkuYXBwZW5kQ2hpbGQobm9kZS5nZXREb20oKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZWFyY2ggdGV4dCBpbiBhbGwgbm9kZXNcXG5cXHQgKiBUaGUgbm9kZXMgd2lsbCBiZSBleHBhbmRlZCB3aGVuIHRoZSB0ZXh0IGlzIGZvdW5kIG9uZSBvZiBpdHMgY2hpbGRzLFxcblxcdCAqIGVsc2UgaXQgd2lsbCBiZSBjb2xsYXBzZWQuIFNlYXJjaGVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XFxuXFx0ICogQHJldHVybiB7T2JqZWN0W119IHJlc3VsdHMgIEFycmF5IHdpdGggbm9kZXMgY29udGFpbmluZyB0aGUgc2VhcmNoIHJlc3VsdHNcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlc3VsdCBvYmplY3RzIGNvbnRhaW5zIGZpZWxkczpcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7Tm9kZX0gbm9kZSxcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBlbGVtICB0aGUgZG9tIGVsZW1lbnQgbmFtZSB3aGVyZVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgaXMgZm91bmQgKCdmaWVsZCcgb3JcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnKVxcblxcdCAqL1xcblxcdHRyZWVtb2RlLnNlYXJjaCA9IGZ1bmN0aW9uICh0ZXh0KSB7XFxuXFx0ICB2YXIgcmVzdWx0cztcXG5cXHQgIGlmICh0aGlzLm5vZGUpIHtcXG5cXHQgICAgdGhpcy5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMudGFibGUpOyAgLy8gVGFrZSB0aGUgdGFibGUgb2ZmbGluZVxcblxcdCAgICByZXN1bHRzID0gdGhpcy5ub2RlLnNlYXJjaCh0ZXh0KTtcXG5cXHQgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMudGFibGUpOyAgLy8gUHV0IHRoZSB0YWJsZSBvbmxpbmUgYWdhaW5cXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICByZXN1bHRzID0gW107XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcmVzdWx0cztcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEV4cGFuZCBhbGwgbm9kZXNcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5leHBhbmRBbGwgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy5ub2RlKSB7XFxuXFx0ICAgIHRoaXMuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLnRhYmxlKTsgIC8vIFRha2UgdGhlIHRhYmxlIG9mZmxpbmVcXG5cXHQgICAgdGhpcy5ub2RlLmV4cGFuZCgpO1xcblxcdCAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy50YWJsZSk7ICAvLyBQdXQgdGhlIHRhYmxlIG9ubGluZSBhZ2FpblxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29sbGFwc2UgYWxsIG5vZGVzXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuY29sbGFwc2VBbGwgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy5ub2RlKSB7XFxuXFx0ICAgIHRoaXMuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLnRhYmxlKTsgIC8vIFRha2UgdGhlIHRhYmxlIG9mZmxpbmVcXG5cXHQgICAgdGhpcy5ub2RlLmNvbGxhcHNlKCk7XFxuXFx0ICAgIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlKTsgIC8vIFB1dCB0aGUgdGFibGUgb25saW5lIGFnYWluXFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBUaGUgbWV0aG9kIG9uQ2hhbmdlIGlzIGNhbGxlZCB3aGVuZXZlciBhIGZpZWxkIG9yIHZhbHVlIGlzIGNoYW5nZWQsIGNyZWF0ZWQsXFxuXFx0ICogZGVsZXRlZCwgZHVwbGljYXRlZCwgZXRjLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb24gIENoYW5nZSBhY3Rpb24uIEF2YWlsYWJsZSB2YWx1ZXM6IFxcXCJlZGl0RmllbGRcXFwiLFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJlZGl0VmFsdWVcXFwiLCBcXFwiY2hhbmdlVHlwZVxcXCIsIFxcXCJhcHBlbmROb2RlXFxcIixcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBcXFwicmVtb3ZlTm9kZVxcXCIsIFxcXCJkdXBsaWNhdGVOb2RlXFxcIiwgXFxcIm1vdmVOb2RlXFxcIiwgXFxcImV4cGFuZFxcXCIsXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgXFxcImNvbGxhcHNlXFxcIi5cXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIGRlc2NyaWJpbmcgdGhlIGNoYW5nZS5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgcGFyYW1ldGVycyBpbiBwYXJhbXMgZGVwZW5kIG9uIHRoZSBhY3Rpb24gKGZvclxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZm9yIFxcXCJlZGl0VmFsdWVcXFwiIHRoZSBOb2RlLCBvbGQgdmFsdWUsIGFuZCBuZXdcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBhcmUgcHJvdmlkZWQpLiBwYXJhbXMgY29udGFpbnMgYWxsIGluZm9ybWF0aW9uXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgbmVlZGVkIHRvIHVuZG8gb3IgcmVkbyB0aGUgYWN0aW9uLlxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuX29uQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbiwgcGFyYW1zKSB7XFxuXFx0ICAvLyBhZGQgYW4gYWN0aW9uIHRvIHRoZSBoaXN0b3J5XFxuXFx0ICBpZiAodGhpcy5oaXN0b3J5KSB7XFxuXFx0ICAgIHRoaXMuaGlzdG9yeS5hZGQoYWN0aW9uLCBwYXJhbXMpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gdHJpZ2dlciB0aGUgb25DaGFuZ2UgY2FsbGJhY2tcXG5cXHQgIGlmICh0aGlzLm9wdGlvbnMuY2hhbmdlKSB7XFxuXFx0ICAgIHRyeSB7XFxuXFx0ICAgICAgdGhpcy5vcHRpb25zLmNoYW5nZSgpO1xcblxcdCAgICB9XFxuXFx0ICAgIGNhdGNoIChlcnIpIHtcXG5cXHQgICAgICB1dGlsLmxvZygnRXJyb3IgaW4gY2hhbmdlIGNhbGxiYWNrOiAnLCBlcnIpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdGFydCBhdXRvc2Nyb2xsaW5nIHdoZW4gZ2l2ZW4gbW91c2UgcG9zaXRpb24gaXMgYWJvdmUgdGhlIHRvcCBvZiB0aGVcXG5cXHQgKiBlZGl0b3IgY29udGVudHMsIG9yIGJlbG93IHRoZSBib3R0b20uXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IG1vdXNlWSAgQWJzb2x1dGUgbW91c2UgcG9zaXRpb24gaW4gcGl4ZWxzXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuc3RhcnRBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKG1vdXNlWSkge1xcblxcdCAgdmFyIG1lID0gdGhpcztcXG5cXHQgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50O1xcblxcdCAgdmFyIHRvcCA9IHV0aWwuZ2V0QWJzb2x1dGVUb3AoY29udGVudCk7XFxuXFx0ICB2YXIgaGVpZ2h0ID0gY29udGVudC5jbGllbnRIZWlnaHQ7XFxuXFx0ICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xcblxcdCAgdmFyIG1hcmdpbiA9IDI0O1xcblxcdCAgdmFyIGludGVydmFsID0gNTA7IC8vIG1zXFxuXFxuXFx0ICBpZiAoKG1vdXNlWSA8IHRvcCArIG1hcmdpbikgJiYgY29udGVudC5zY3JvbGxUb3AgPiAwKSB7XFxuXFx0ICAgIHRoaXMuYXV0b1Njcm9sbFN0ZXAgPSAoKHRvcCArIG1hcmdpbikgLSBtb3VzZVkpIC8gMztcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKG1vdXNlWSA+IGJvdHRvbSAtIG1hcmdpbiAmJlxcblxcdCAgICAgIGhlaWdodCArIGNvbnRlbnQuc2Nyb2xsVG9wIDwgY29udGVudC5zY3JvbGxIZWlnaHQpIHtcXG5cXHQgICAgdGhpcy5hdXRvU2Nyb2xsU3RlcCA9ICgoYm90dG9tIC0gbWFyZ2luKSAtIG1vdXNlWSkgLyAzO1xcblxcdCAgfVxcblxcdCAgZWxzZSB7XFxuXFx0ICAgIHRoaXMuYXV0b1Njcm9sbFN0ZXAgPSB1bmRlZmluZWQ7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAodGhpcy5hdXRvU2Nyb2xsU3RlcCkge1xcblxcdCAgICBpZiAoIXRoaXMuYXV0b1Njcm9sbFRpbWVyKSB7XFxuXFx0ICAgICAgdGhpcy5hdXRvU2Nyb2xsVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICBpZiAobWUuYXV0b1Njcm9sbFN0ZXApIHtcXG5cXHQgICAgICAgICAgY29udGVudC5zY3JvbGxUb3AgLT0gbWUuYXV0b1Njcm9sbFN0ZXA7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgbWUuc3RvcEF1dG9TY3JvbGwoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9LCBpbnRlcnZhbCk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICB0aGlzLnN0b3BBdXRvU2Nyb2xsKCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTdG9wIGF1dG8gc2Nyb2xsaW5nLiBPbmx5IGFwcGxpY2FibGUgd2hlbiBzY3JvbGxpbmdcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5zdG9wQXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIGlmICh0aGlzLmF1dG9TY3JvbGxUaW1lcikge1xcblxcdCAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvU2Nyb2xsVGltZXIpO1xcblxcdCAgICBkZWxldGUgdGhpcy5hdXRvU2Nyb2xsVGltZXI7XFxuXFx0ICB9XFxuXFx0ICBpZiAodGhpcy5hdXRvU2Nyb2xsU3RlcCkge1xcblxcdCAgICBkZWxldGUgdGhpcy5hdXRvU2Nyb2xsU3RlcDtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcblxcdC8qKlxcblxcdCAqIFNldCB0aGUgZm9jdXMgdG8gYW4gZWxlbWVudCBpbiB0aGUgZWRpdG9yLCBzZXQgdGV4dCBzZWxlY3Rpb24sIGFuZFxcblxcdCAqIHNldCBzY3JvbGwgcG9zaXRpb24uXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbiAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZmllbGRzOlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtFbGVtZW50IHwgdW5kZWZpbmVkfSBkb20gICAgIFRoZSBkb20gZWxlbWVudFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGhhcyBmb2N1c1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtSYW5nZSB8IFRleHRSYW5nZX0gcmFuZ2UgICAgIEEgdGV4dCBzZWxlY3Rpb25cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBzY3JvbGxUb3AgICAgICAgICAgICBTY3JvbGwgcG9zaXRpb25cXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XFxuXFx0ICBpZiAoIXNlbGVjdGlvbikge1xcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoJ3Njcm9sbFRvcCcgaW4gc2VsZWN0aW9uICYmIHRoaXMuY29udGVudCkge1xcblxcdCAgICAvLyBUT0RPOiBhbmltYXRlZCBzY3JvbGxcXG5cXHQgICAgdGhpcy5jb250ZW50LnNjcm9sbFRvcCA9IHNlbGVjdGlvbi5zY3JvbGxUb3A7XFxuXFx0ICB9XFxuXFx0ICBpZiAoc2VsZWN0aW9uLnJhbmdlKSB7XFxuXFx0ICAgIHV0aWwuc2V0U2VsZWN0aW9uT2Zmc2V0KHNlbGVjdGlvbi5yYW5nZSk7XFxuXFx0ICB9XFxuXFx0ICBpZiAoc2VsZWN0aW9uLmRvbSkge1xcblxcdCAgICBzZWxlY3Rpb24uZG9tLmZvY3VzKCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgdGhlIGN1cnJlbnQgZm9jdXNcXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IHNlbGVjdGlvbiBBbiBvYmplY3QgY29udGFpbmluZyBmaWVsZHM6XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAge0VsZW1lbnQgfCB1bmRlZmluZWR9IGRvbSAgICAgVGhlIGRvbSBlbGVtZW50XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggaGFzIGZvY3VzXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAge1JhbmdlIHwgVGV4dFJhbmdlfSByYW5nZSAgICAgQSB0ZXh0IHNlbGVjdGlvblxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IHNjcm9sbFRvcCAgICAgICAgICAgIFNjcm9sbCBwb3NpdGlvblxcblxcdCAqL1xcblxcdHRyZWVtb2RlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHJldHVybiB7XFxuXFx0ICAgIGRvbTogZG9tRm9jdXMsXFxuXFx0ICAgIHNjcm9sbFRvcDogdGhpcy5jb250ZW50ID8gdGhpcy5jb250ZW50LnNjcm9sbFRvcCA6IDAsXFxuXFx0ICAgIHJhbmdlOiB1dGlsLmdldFNlbGVjdGlvbk9mZnNldCgpXFxuXFx0ICB9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQWRqdXN0IHRoZSBzY3JvbGwgcG9zaXRpb24gc3VjaCB0aGF0IGdpdmVuIHRvcCBwb3NpdGlvbiBpcyBzaG93biBhdCAxLzRcXG5cXHQgKiBvZiB0aGUgd2luZG93IGhlaWdodC5cXG5cXHQgKiBAcGFyYW0ge051bWJlcn0gdG9wXFxuXFx0ICogQHBhcmFtIHtmdW5jdGlvbihib29sZWFuKX0gW2NhbGxiYWNrXSAgIENhbGxiYWNrLCBleGVjdXRlZCB3aGVuIGFuaW1hdGlvbiBpc1xcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZC4gVGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZCwgb3IgZmFsc2VcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBub3QuXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuc2Nyb2xsVG8gPSBmdW5jdGlvbiAodG9wLCBjYWxsYmFjaykge1xcblxcdCAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XFxuXFx0ICBpZiAoY29udGVudCkge1xcblxcdCAgICB2YXIgZWRpdG9yID0gdGhpcztcXG5cXHQgICAgLy8gY2FuY2VsIGFueSBydW5uaW5nIGFuaW1hdGlvblxcblxcdCAgICBpZiAoZWRpdG9yLmFuaW1hdGVUaW1lb3V0KSB7XFxuXFx0ICAgICAgY2xlYXJUaW1lb3V0KGVkaXRvci5hbmltYXRlVGltZW91dCk7XFxuXFx0ICAgICAgZGVsZXRlIGVkaXRvci5hbmltYXRlVGltZW91dDtcXG5cXHQgICAgfVxcblxcdCAgICBpZiAoZWRpdG9yLmFuaW1hdGVDYWxsYmFjaykge1xcblxcdCAgICAgIGVkaXRvci5hbmltYXRlQ2FsbGJhY2soZmFsc2UpO1xcblxcdCAgICAgIGRlbGV0ZSBlZGl0b3IuYW5pbWF0ZUNhbGxiYWNrO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCBzY3JvbGwgcG9zaXRpb25cXG5cXHQgICAgdmFyIGhlaWdodCA9IGNvbnRlbnQuY2xpZW50SGVpZ2h0O1xcblxcdCAgICB2YXIgYm90dG9tID0gY29udGVudC5zY3JvbGxIZWlnaHQgLSBoZWlnaHQ7XFxuXFx0ICAgIHZhciBmaW5hbFNjcm9sbFRvcCA9IE1hdGgubWluKE1hdGgubWF4KHRvcCAtIGhlaWdodCAvIDQsIDApLCBib3R0b20pO1xcblxcblxcdCAgICAvLyBhbmltYXRlIHRvd2FyZHMgdGhlIG5ldyBzY3JvbGwgcG9zaXRpb25cXG5cXHQgICAgdmFyIGFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgdmFyIHNjcm9sbFRvcCA9IGNvbnRlbnQuc2Nyb2xsVG9wO1xcblxcdCAgICAgIHZhciBkaWZmID0gKGZpbmFsU2Nyb2xsVG9wIC0gc2Nyb2xsVG9wKTtcXG5cXHQgICAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiAzKSB7XFxuXFx0ICAgICAgICBjb250ZW50LnNjcm9sbFRvcCArPSBkaWZmIC8gMztcXG5cXHQgICAgICAgIGVkaXRvci5hbmltYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcXG5cXHQgICAgICAgIGVkaXRvci5hbmltYXRlVGltZW91dCA9IHNldFRpbWVvdXQoYW5pbWF0ZSwgNTApO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIHtcXG5cXHQgICAgICAgIC8vIGZpbmlzaGVkXFxuXFx0ICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG5cXHQgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBjb250ZW50LnNjcm9sbFRvcCA9IGZpbmFsU2Nyb2xsVG9wO1xcblxcdCAgICAgICAgZGVsZXRlIGVkaXRvci5hbmltYXRlVGltZW91dDtcXG5cXHQgICAgICAgIGRlbGV0ZSBlZGl0b3IuYW5pbWF0ZUNhbGxiYWNrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgYW5pbWF0ZSgpO1xcblxcdCAgfVxcblxcdCAgZWxzZSB7XFxuXFx0ICAgIGlmIChjYWxsYmFjaykge1xcblxcdCAgICAgIGNhbGxiYWNrKGZhbHNlKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlIG1haW4gZnJhbWVcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdHRyZWVtb2RlLl9jcmVhdGVGcmFtZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIC8vIGNyZWF0ZSB0aGUgZnJhbWVcXG5cXHQgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG5cXHQgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gJ2pzb25lZGl0b3InO1xcblxcdCAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XFxuXFxuXFx0ICAvLyBjcmVhdGUgb25lIGdsb2JhbCBldmVudCBsaXN0ZW5lciB0byBoYW5kbGUgYWxsIGV2ZW50cyBmcm9tIGFsbCBub2Rlc1xcblxcdCAgdmFyIGVkaXRvciA9IHRoaXM7XFxuXFx0ICBmdW5jdGlvbiBvbkV2ZW50KGV2ZW50KSB7XFxuXFx0ICAgIGVkaXRvci5fb25FdmVudChldmVudCk7XFxuXFx0ICB9XFxuXFx0ICB0aGlzLmZyYW1lLm9uY2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDsvLyB8fCBldmVudC5zcmNFbGVtZW50O1xcblxcblxcdCAgICBvbkV2ZW50KGV2ZW50KTtcXG5cXG5cXHQgICAgLy8gcHJldmVudCBkZWZhdWx0IHN1Ym1pdCBhY3Rpb24gb2YgYnV0dG9ucyB3aGVuIGVkaXRvciBpcyBsb2NhdGVkXFxuXFx0ICAgIC8vIGluc2lkZSBhIGZvcm1cXG5cXHQgICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PSAnQlVUVE9OJykge1xcblxcdCAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgIH1cXG5cXHQgIH07XFxuXFx0ICB0aGlzLmZyYW1lLm9uaW5wdXQgPSBvbkV2ZW50O1xcblxcdCAgdGhpcy5mcmFtZS5vbmNoYW5nZSA9IG9uRXZlbnQ7XFxuXFx0ICB0aGlzLmZyYW1lLm9ua2V5ZG93biA9IG9uRXZlbnQ7XFxuXFx0ICB0aGlzLmZyYW1lLm9ua2V5dXAgPSBvbkV2ZW50O1xcblxcdCAgdGhpcy5mcmFtZS5vbmN1dCA9IG9uRXZlbnQ7XFxuXFx0ICB0aGlzLmZyYW1lLm9ucGFzdGUgPSBvbkV2ZW50O1xcblxcdCAgdGhpcy5mcmFtZS5vbm1vdXNlZG93biA9IG9uRXZlbnQ7XFxuXFx0ICB0aGlzLmZyYW1lLm9ubW91c2V1cCA9IG9uRXZlbnQ7XFxuXFx0ICB0aGlzLmZyYW1lLm9ubW91c2VvdmVyID0gb25FdmVudDtcXG5cXHQgIHRoaXMuZnJhbWUub25tb3VzZW91dCA9IG9uRXZlbnQ7XFxuXFx0ICAvLyBOb3RlOiBmb2N1cyBhbmQgYmx1ciBldmVudHMgZG8gbm90IHByb3BhZ2F0ZSwgdGhlcmVmb3JlIHRoZXkgZGVmaW5lZFxcblxcdCAgLy8gdXNpbmcgYW4gZXZlbnRMaXN0ZW5lciB3aXRoIHVzZUNhcHR1cmU9dHJ1ZVxcblxcdCAgLy8gc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcXG5cXHQgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLCAnZm9jdXMnLCBvbkV2ZW50LCB0cnVlKTtcXG5cXHQgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmZyYW1lLCAnYmx1cicsIG9uRXZlbnQsIHRydWUpO1xcblxcdCAgdGhpcy5mcmFtZS5vbmZvY3VzaW4gPSBvbkV2ZW50OyAgLy8gZm9yIElFXFxuXFx0ICB0aGlzLmZyYW1lLm9uZm9jdXNvdXQgPSBvbkV2ZW50OyAvLyBmb3IgSUVcXG5cXG5cXHQgIC8vIGNyZWF0ZSBtZW51XFxuXFx0ICB0aGlzLm1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG5cXHQgIHRoaXMubWVudS5jbGFzc05hbWUgPSAnbWVudSc7XFxuXFx0ICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMubWVudSk7XFxuXFxuXFx0ICAvLyBjcmVhdGUgZXhwYW5kIGFsbCBidXR0b25cXG5cXHQgIHZhciBleHBhbmRBbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgIGV4cGFuZEFsbC5jbGFzc05hbWUgPSAnZXhwYW5kLWFsbCc7XFxuXFx0ICBleHBhbmRBbGwudGl0bGUgPSAnRXhwYW5kIGFsbCBmaWVsZHMnO1xcblxcdCAgZXhwYW5kQWxsLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgIGVkaXRvci5leHBhbmRBbGwoKTtcXG5cXHQgIH07XFxuXFx0ICB0aGlzLm1lbnUuYXBwZW5kQ2hpbGQoZXhwYW5kQWxsKTtcXG5cXG5cXHQgIC8vIGNyZWF0ZSBleHBhbmQgYWxsIGJ1dHRvblxcblxcdCAgdmFyIGNvbGxhcHNlQWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxuXFx0ICBjb2xsYXBzZUFsbC50aXRsZSA9ICdDb2xsYXBzZSBhbGwgZmllbGRzJztcXG5cXHQgIGNvbGxhcHNlQWxsLmNsYXNzTmFtZSA9ICdjb2xsYXBzZS1hbGwnO1xcblxcdCAgY29sbGFwc2VBbGwub25jbGljayA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgZWRpdG9yLmNvbGxhcHNlQWxsKCk7XFxuXFx0ICB9O1xcblxcdCAgdGhpcy5tZW51LmFwcGVuZENoaWxkKGNvbGxhcHNlQWxsKTtcXG5cXG5cXHQgIC8vIGNyZWF0ZSB1bmRvL3JlZG8gYnV0dG9uc1xcblxcdCAgaWYgKHRoaXMuaGlzdG9yeSkge1xcblxcdCAgICAvLyBjcmVhdGUgdW5kbyBidXR0b25cXG5cXHQgICAgdmFyIHVuZG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgICAgdW5kby5jbGFzc05hbWUgPSAndW5kbyBzZXBhcmF0b3InO1xcblxcdCAgICB1bmRvLnRpdGxlID0gJ1VuZG8gbGFzdCBhY3Rpb24gKEN0cmwrWiknO1xcblxcdCAgICB1bmRvLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgZWRpdG9yLl9vblVuZG8oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tZW51LmFwcGVuZENoaWxkKHVuZG8pO1xcblxcdCAgICB0aGlzLmRvbS51bmRvID0gdW5kbztcXG5cXG5cXHQgICAgLy8gY3JlYXRlIHJlZG8gYnV0dG9uXFxuXFx0ICAgIHZhciByZWRvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxuXFx0ICAgIHJlZG8uY2xhc3NOYW1lID0gJ3JlZG8nO1xcblxcdCAgICByZWRvLnRpdGxlID0gJ1JlZG8gKEN0cmwrU2hpZnQrWiknO1xcblxcdCAgICByZWRvLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgZWRpdG9yLl9vblJlZG8oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tZW51LmFwcGVuZENoaWxkKHJlZG8pO1xcblxcdCAgICB0aGlzLmRvbS5yZWRvID0gcmVkbztcXG5cXG5cXHQgICAgLy8gcmVnaXN0ZXIgaGFuZGxlciBmb3Igb25jaGFuZ2Ugb2YgaGlzdG9yeVxcblxcdCAgICB0aGlzLmhpc3Rvcnkub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgdW5kby5kaXNhYmxlZCA9ICFlZGl0b3IuaGlzdG9yeS5jYW5VbmRvKCk7XFxuXFx0ICAgICAgcmVkby5kaXNhYmxlZCA9ICFlZGl0b3IuaGlzdG9yeS5jYW5SZWRvKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaGlzdG9yeS5vbkNoYW5nZSgpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gY3JlYXRlIG1vZGUgYm94XFxuXFx0ICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlcyAmJiB0aGlzLm9wdGlvbnMubW9kZXMubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBtb2RlQm94ID0gbW9kZXN3aXRjaGVyLmNyZWF0ZSh0aGlzLCB0aGlzLm9wdGlvbnMubW9kZXMsIHRoaXMub3B0aW9ucy5tb2RlKTtcXG5cXHQgICAgdGhpcy5tZW51LmFwcGVuZENoaWxkKG1vZGVCb3gpO1xcblxcdCAgICB0aGlzLmRvbS5tb2RlQm94ID0gbW9kZUJveDtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIGNyZWF0ZSBzZWFyY2ggYm94XFxuXFx0ICBpZiAodGhpcy5vcHRpb25zLnNlYXJjaCkge1xcblxcdCAgICB0aGlzLnNlYXJjaEJveCA9IG5ldyBTZWFyY2hCb3godGhpcywgdGhpcy5tZW51KTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFBlcmZvcm0gYW4gdW5kbyBhY3Rpb25cXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdHRyZWVtb2RlLl9vblVuZG8gPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy5oaXN0b3J5KSB7XFxuXFx0ICAgIC8vIHVuZG8gbGFzdCBhY3Rpb25cXG5cXHQgICAgdGhpcy5oaXN0b3J5LnVuZG8oKTtcXG5cXG5cXHQgICAgLy8gdHJpZ2dlciBjaGFuZ2UgY2FsbGJhY2tcXG5cXHQgICAgaWYgKHRoaXMub3B0aW9ucy5jaGFuZ2UpIHtcXG5cXHQgICAgICB0aGlzLm9wdGlvbnMuY2hhbmdlKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFBlcmZvcm0gYSByZWRvIGFjdGlvblxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuX29uUmVkbyA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIGlmICh0aGlzLmhpc3RvcnkpIHtcXG5cXHQgICAgLy8gcmVkbyBsYXN0IGFjdGlvblxcblxcdCAgICB0aGlzLmhpc3RvcnkucmVkbygpO1xcblxcblxcdCAgICAvLyB0cmlnZ2VyIGNoYW5nZSBjYWxsYmFja1xcblxcdCAgICBpZiAodGhpcy5vcHRpb25zLmNoYW5nZSkge1xcblxcdCAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2UoKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRXZlbnQgaGFuZGxlclxcblxcdCAqIEBwYXJhbSBldmVudFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XFxuXFxuXFx0ICBpZiAoZXZlbnQudHlwZSA9PSAna2V5ZG93bicpIHtcXG5cXHQgICAgdGhpcy5fb25LZXlEb3duKGV2ZW50KTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChldmVudC50eXBlID09ICdmb2N1cycpIHtcXG5cXHQgICAgZG9tRm9jdXMgPSB0YXJnZXQ7XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgbm9kZSA9IE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQodGFyZ2V0KTtcXG5cXHQgIGlmIChub2RlKSB7XFxuXFx0ICAgIG5vZGUub25FdmVudChldmVudCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFdmVudCBoYW5kbGVyIGZvciBrZXlkb3duLiBIYW5kbGVzIHNob3J0Y3V0IGtleXNcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dHJlZW1vZGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgdmFyIGtleW51bSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XFxuXFx0ICB2YXIgY3RybEtleSA9IGV2ZW50LmN0cmxLZXk7XFxuXFx0ICB2YXIgc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcXG5cXHQgIHZhciBoYW5kbGVkID0gZmFsc2U7XFxuXFxuXFx0ICBpZiAoa2V5bnVtID09IDkpIHsgLy8gVGFiIG9yIFNoaWZ0K1RhYlxcblxcdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAvLyBzZWxlY3QgYWxsIHRleHQgd2hlbiBtb3ZpbmcgZm9jdXMgdG8gYW4gZWRpdGFibGUgZGl2XFxuXFx0ICAgICAgdXRpbC5zZWxlY3RDb250ZW50RWRpdGFibGUoZG9tRm9jdXMpO1xcblxcdCAgICB9LCAwKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLnNlYXJjaEJveCkge1xcblxcdCAgICBpZiAoY3RybEtleSAmJiBrZXludW0gPT0gNzApIHsgLy8gQ3RybCtGXFxuXFx0ICAgICAgdGhpcy5zZWFyY2hCb3guZG9tLnNlYXJjaC5mb2N1cygpO1xcblxcdCAgICAgIHRoaXMuc2VhcmNoQm94LmRvbS5zZWFyY2guc2VsZWN0KCk7XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAoa2V5bnVtID09IDExNCB8fCAoY3RybEtleSAmJiBrZXludW0gPT0gNzEpKSB7IC8vIEYzIG9yIEN0cmwrR1xcblxcdCAgICAgIHZhciBmb2N1cyA9IHRydWU7XFxuXFx0ICAgICAgaWYgKCFzaGlmdEtleSkge1xcblxcdCAgICAgICAgLy8gc2VsZWN0IG5leHQgc2VhcmNoIHJlc3VsdCAoRjMgb3IgQ3RybCtHKVxcblxcdCAgICAgICAgdGhpcy5zZWFyY2hCb3gubmV4dChmb2N1cyk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgLy8gc2VsZWN0IHByZXZpb3VzIHNlYXJjaCByZXN1bHQgKFNoaWZ0K0YzIG9yIEN0cmwrU2hpZnQrRylcXG5cXHQgICAgICAgIHRoaXMuc2VhcmNoQm94LnByZXZpb3VzKGZvY3VzKTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLmhpc3RvcnkpIHtcXG5cXHQgICAgaWYgKGN0cmxLZXkgJiYgIXNoaWZ0S2V5ICYmIGtleW51bSA9PSA5MCkgeyAvLyBDdHJsK1pcXG5cXHQgICAgICAvLyB1bmRvXFxuXFx0ICAgICAgdGhpcy5fb25VbmRvKCk7XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAoY3RybEtleSAmJiBzaGlmdEtleSAmJiBrZXludW0gPT0gOTApIHsgLy8gQ3RybCtTaGlmdCtaXFxuXFx0ICAgICAgLy8gcmVkb1xcblxcdCAgICAgIHRoaXMuX29uUmVkbygpO1xcblxcdCAgICAgIGhhbmRsZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoaGFuZGxlZCkge1xcblxcdCAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZSBtYWluIHRhYmxlXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHR0cmVlbW9kZS5fY3JlYXRlVGFibGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB2YXIgY29udGVudE91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuXFx0ICBjb250ZW50T3V0ZXIuY2xhc3NOYW1lID0gJ291dGVyJztcXG5cXHQgIHRoaXMuY29udGVudE91dGVyID0gY29udGVudE91dGVyO1xcblxcblxcdCAgdGhpcy5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuXFx0ICB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gJ3RyZWUnO1xcblxcdCAgY29udGVudE91dGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XFxuXFxuXFx0ICB0aGlzLnRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcXG5cXHQgIHRoaXMudGFibGUuY2xhc3NOYW1lID0gJ3RyZWUnO1xcblxcdCAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMudGFibGUpO1xcblxcblxcdCAgLy8gY3JlYXRlIGNvbGdyb3VwIHdoZXJlIHRoZSBmaXJzdCB0d28gY29sdW1ucyBkb24ndCBoYXZlIGEgZml4ZWRcXG5cXHQgIC8vIHdpZHRoLCBhbmQgdGhlIGVkaXQgY29sdW1ucyBkbyBoYXZlIGEgZml4ZWQgd2lkdGhcXG5cXHQgIHZhciBjb2w7XFxuXFx0ICB0aGlzLmNvbGdyb3VwQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJyk7XFxuXFx0ICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09ICd0cmVlJykge1xcblxcdCAgICBjb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2wnKTtcXG5cXHQgICAgY29sLndpZHRoID0gXFxcIjI0cHhcXFwiO1xcblxcdCAgICB0aGlzLmNvbGdyb3VwQ29udGVudC5hcHBlbmRDaGlsZChjb2wpO1xcblxcdCAgfVxcblxcdCAgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XFxuXFx0ICBjb2wud2lkdGggPSBcXFwiMjRweFxcXCI7XFxuXFx0ICB0aGlzLmNvbGdyb3VwQ29udGVudC5hcHBlbmRDaGlsZChjb2wpO1xcblxcdCAgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XFxuXFx0ICB0aGlzLmNvbGdyb3VwQ29udGVudC5hcHBlbmRDaGlsZChjb2wpO1xcblxcdCAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aGlzLmNvbGdyb3VwQ29udGVudCk7XFxuXFxuXFx0ICB0aGlzLnRib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcXG5cXHQgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGhpcy50Ym9keSk7XFxuXFxuXFx0ICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKGNvbnRlbnRPdXRlcik7XFxuXFx0fTtcXG5cXG5cXHQvLyBkZWZpbmUgbW9kZXNcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IFtcXG5cXHQgIHtcXG5cXHQgICAgbW9kZTogJ3RyZWUnLFxcblxcdCAgICBtaXhpbjogdHJlZW1vZGUsXFxuXFx0ICAgIGRhdGE6ICdqc29uJ1xcblxcdCAgfSxcXG5cXHQgIHtcXG5cXHQgICAgbW9kZTogJ3ZpZXcnLFxcblxcdCAgICBtaXhpbjogdHJlZW1vZGUsXFxuXFx0ICAgIGRhdGE6ICdqc29uJ1xcblxcdCAgfSxcXG5cXHQgIHtcXG5cXHQgICAgbW9kZTogJ2Zvcm0nLFxcblxcdCAgICBtaXhpbjogdHJlZW1vZGUsXFxuXFx0ICAgIGRhdGE6ICdqc29uJ1xcblxcdCAgfVxcblxcdF07XFxuXFxuLyoqKi8gfSxcXG4vKiAyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIGFjZTtcXG5cXHR0cnkge1xcblxcdCAgYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcXG5cXHR9XFxuXFx0Y2F0Y2ggKGVycikge1xcblxcdCAgLy8gZmFpbGVkIHRvIGxvYWQgYWNlLCBubyBwcm9ibGVtLCB3ZSB3aWxsIGZhbGwgYmFjayB0byBwbGFpbiB0ZXh0XFxuXFx0fVxcblxcblxcdHZhciBtb2Rlc3dpdGNoZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xcblxcdHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG5cXG5cXHQvLyBjcmVhdGUgYSBtaXhpbiB3aXRoIHRoZSBmdW5jdGlvbnMgZm9yIHRleHQgbW9kZVxcblxcdHZhciB0ZXh0bW9kZSA9IHt9O1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZSBhIHRleHQgZWRpdG9yXFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICAgICAgICAgT2JqZWN0IHdpdGggb3B0aW9ucy4gYXZhaWxhYmxlIG9wdGlvbnM6XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtTdHJpbmd9IG1vZGUgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInRleHRcXFwiIChkZWZhdWx0KVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgXFxcImNvZGVcXFwiLlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSBpbmRlbnRhdGlvbiAgTnVtYmVyIG9mIGluZGVudGF0aW9uXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjZXMuIDIgYnkgZGVmYXVsdC5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBjaGFuZ2UgICAgIENhbGxiYWNrIG1ldGhvZFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkIG9uIGNoYW5nZVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBhY2UgICAgICAgICAgQSBjdXN0b20gaW5zdGFuY2Ugb2ZcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjZSBlZGl0b3IuXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHR0ZXh0bW9kZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBvcHRpb25zKSB7XFxuXFx0ICAvLyByZWFkIG9wdGlvbnNcXG5cXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdCAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXG5cXHQgIC8vIGluZGVudGF0aW9uXFxuXFx0ICBpZiAob3B0aW9ucy5pbmRlbnRhdGlvbikge1xcblxcdCAgICB0aGlzLmluZGVudGF0aW9uID0gTnVtYmVyKG9wdGlvbnMuaW5kZW50YXRpb24pO1xcblxcdCAgfVxcblxcdCAgZWxzZSB7XFxuXFx0ICAgIHRoaXMuaW5kZW50YXRpb24gPSAyOyAvLyBudW1iZXIgb2Ygc3BhY2VzXFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBncmFiIGFjZSBmcm9tIG9wdGlvbnMgaWYgcHJvdmlkZWRcXG5cXHQgIHZhciBfYWNlID0gb3B0aW9ucy5hY2UgPyBvcHRpb25zLmFjZSA6IGFjZTtcXG5cXG5cXHQgIC8vIGRldGVybWluZSBtb2RlXFxuXFx0ICB0aGlzLm1vZGUgPSAob3B0aW9ucy5tb2RlID09ICdjb2RlJykgPyAnY29kZScgOiAndGV4dCc7XFxuXFx0ICBpZiAodGhpcy5tb2RlID09ICdjb2RlJykge1xcblxcdCAgICAvLyB2ZXJpZnkgd2hldGhlciBBY2UgZWRpdG9yIGlzIGF2YWlsYWJsZSBhbmQgc3VwcG9ydGVkXFxuXFx0ICAgIGlmICh0eXBlb2YgX2FjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG5cXHQgICAgICB0aGlzLm1vZGUgPSAndGV4dCc7XFxuXFx0ICAgICAgdXRpbC5sb2coJ1dBUk5JTkc6IENhbm5vdCBsb2FkIGNvZGUgZWRpdG9yLCBBY2UgbGlicmFyeSBub3QgbG9hZGVkLiAnICtcXG5cXHQgICAgICAgICAgJ0ZhbGxpbmcgYmFjayB0byBwbGFpbiB0ZXh0IGVkaXRvcicpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBkZXRlcm1pbmUgdGhlbWVcXG5cXHQgIHRoaXMudGhlbWUgPSBvcHRpb25zLnRoZW1lIHx8ICdhY2UvdGhlbWUvanNvbmVkaXRvcic7XFxuXFxuXFx0ICB2YXIgbWUgPSB0aGlzO1xcblxcdCAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XFxuXFx0ICB0aGlzLmRvbSA9IHt9O1xcblxcdCAgdGhpcy5lZGl0b3IgPSB1bmRlZmluZWQ7ICAgIC8vIGFjZSBjb2RlIGVkaXRvclxcblxcdCAgdGhpcy50ZXh0YXJlYSA9IHVuZGVmaW5lZDsgIC8vIHBsYWluIHRleHQgZWRpdG9yIChmYWxsYmFjayB3aGVuIEFjZSBpcyBub3QgYXZhaWxhYmxlKVxcblxcblxcdCAgdGhpcy53aWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcXG5cXHQgIHRoaXMuaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcXG5cXG5cXHQgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG5cXHQgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gJ2pzb25lZGl0b3InO1xcblxcdCAgdGhpcy5mcmFtZS5vbmNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICAgIC8vIHByZXZlbnQgZGVmYXVsdCBzdWJtaXQgYWN0aW9uIHdoZW4gdGhlIGVkaXRvciBpcyBsb2NhdGVkIGluc2lkZSBhIGZvcm1cXG5cXHQgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgIH07XFxuXFx0ICB0aGlzLmZyYW1lLm9ua2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgICBtZS5fb25LZXlEb3duKGV2ZW50KTtcXG5cXHQgIH07XFxuXFxuXFx0ICAvLyBjcmVhdGUgbWVudVxcblxcdCAgdGhpcy5tZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuXFx0ICB0aGlzLm1lbnUuY2xhc3NOYW1lID0gJ21lbnUnO1xcblxcdCAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm1lbnUpO1xcblxcblxcdCAgLy8gY3JlYXRlIGZvcm1hdCBidXR0b25cXG5cXHQgIHZhciBidXR0b25Gb3JtYXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgIGJ1dHRvbkZvcm1hdC5jbGFzc05hbWUgPSAnZm9ybWF0JztcXG5cXHQgIGJ1dHRvbkZvcm1hdC50aXRsZSA9ICdGb3JtYXQgSlNPTiBkYXRhLCB3aXRoIHByb3BlciBpbmRlbnRhdGlvbiBhbmQgbGluZSBmZWVkcyAoQ3RybCtcXFxcXFxcXCknO1xcblxcdCAgdGhpcy5tZW51LmFwcGVuZENoaWxkKGJ1dHRvbkZvcm1hdCk7XFxuXFx0ICBidXR0b25Gb3JtYXQub25jbGljayA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgdHJ5IHtcXG5cXHQgICAgICBtZS5mb3JtYXQoKTtcXG5cXHQgICAgfVxcblxcdCAgICBjYXRjaCAoZXJyKSB7XFxuXFx0ICAgICAgbWUuX29uRXJyb3IoZXJyKTtcXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIC8vIGNyZWF0ZSBjb21wYWN0IGJ1dHRvblxcblxcdCAgdmFyIGJ1dHRvbkNvbXBhY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgIGJ1dHRvbkNvbXBhY3QuY2xhc3NOYW1lID0gJ2NvbXBhY3QnO1xcblxcdCAgYnV0dG9uQ29tcGFjdC50aXRsZSA9ICdDb21wYWN0IEpTT04gZGF0YSwgcmVtb3ZlIGFsbCB3aGl0ZXNwYWNlcyAoQ3RybCtTaGlmdCtcXFxcXFxcXCknO1xcblxcdCAgdGhpcy5tZW51LmFwcGVuZENoaWxkKGJ1dHRvbkNvbXBhY3QpO1xcblxcdCAgYnV0dG9uQ29tcGFjdC5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xcblxcdCAgICB0cnkge1xcblxcdCAgICAgIG1lLmNvbXBhY3QoKTtcXG5cXHQgICAgfVxcblxcdCAgICBjYXRjaCAoZXJyKSB7XFxuXFx0ICAgICAgbWUuX29uRXJyb3IoZXJyKTtcXG5cXHQgICAgfVxcblxcdCAgfTtcXG5cXG5cXHQgIC8vIGNyZWF0ZSBtb2RlIGJveFxcblxcdCAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZXMgJiYgdGhpcy5vcHRpb25zLm1vZGVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbW9kZUJveCA9IG1vZGVzd2l0Y2hlci5jcmVhdGUodGhpcywgdGhpcy5vcHRpb25zLm1vZGVzLCB0aGlzLm9wdGlvbnMubW9kZSk7XFxuXFx0ICAgIHRoaXMubWVudS5hcHBlbmRDaGlsZChtb2RlQm94KTtcXG5cXHQgICAgdGhpcy5kb20ubW9kZUJveCA9IG1vZGVCb3g7XFxuXFx0ICB9XFxuXFxuXFx0ICB0aGlzLmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG5cXHQgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSAnb3V0ZXInO1xcblxcdCAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xcblxcblxcdCAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XFxuXFxuXFx0ICBpZiAodGhpcy5tb2RlID09ICdjb2RlJykge1xcblxcdCAgICB0aGlzLmVkaXRvckRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgICB0aGlzLmVkaXRvckRvbS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7IC8vIFRPRE86IG1vdmUgdG8gY3NzXFxuXFx0ICAgIHRoaXMuZWRpdG9yRG9tLnN0eWxlLndpZHRoID0gJzEwMCUnOyAvLyBUT0RPOiBtb3ZlIHRvIGNzc1xcblxcdCAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3JEb20pO1xcblxcblxcdCAgICB2YXIgZWRpdG9yID0gX2FjZS5lZGl0KHRoaXMuZWRpdG9yRG9tKTtcXG5cXHQgICAgZWRpdG9yLnNldFRoZW1lKHRoaXMudGhlbWUpO1xcblxcdCAgICBlZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTtcXG5cXHQgICAgZWRpdG9yLnNldEZvbnRTaXplKDEzKTtcXG5cXHQgICAgZWRpdG9yLmdldFNlc3Npb24oKS5zZXRNb2RlKCdhY2UvbW9kZS9qc29uJyk7XFxuXFx0ICAgIGVkaXRvci5nZXRTZXNzaW9uKCkuc2V0VGFiU2l6ZSh0aGlzLmluZGVudGF0aW9uKTtcXG5cXHQgICAgZWRpdG9yLmdldFNlc3Npb24oKS5zZXRVc2VTb2Z0VGFicyh0cnVlKTtcXG5cXHQgICAgZWRpdG9yLmdldFNlc3Npb24oKS5zZXRVc2VXcmFwTW9kZSh0cnVlKTtcXG5cXHQgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XFxuXFxuXFx0ICAgIHZhciBwb3dlcmVkQnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XFxuXFx0ICAgIHBvd2VyZWRCeS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgncG93ZXJlZCBieSBhY2UnKSk7XFxuXFx0ICAgIHBvd2VyZWRCeS5ocmVmID0gJ2h0dHA6Ly9hY2UuYWpheC5vcmcnO1xcblxcdCAgICBwb3dlcmVkQnkudGFyZ2V0ID0gJ19ibGFuayc7XFxuXFx0ICAgIHBvd2VyZWRCeS5jbGFzc05hbWUgPSAncG93ZXJlZEJ5JztcXG5cXHQgICAgcG93ZXJlZEJ5Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgLy8gVE9ETzogdGhpcyBhbmNob3IgZmFsbHMgYmVsb3cgdGhlIG1hcmdpbiBvZiB0aGUgY29udGVudCxcXG5cXHQgICAgICAvLyB0aGVyZWZvcmUgdGhlIG5vcm1hbCBhLmhyZWYgZG9lcyBub3Qgd29yay4gV2UgdXNlIGEgY2xpY2sgZXZlbnRcXG5cXHQgICAgICAvLyBmb3Igbm93LCBidXQgdGhpcyBzaG91bGQgYmUgZml4ZWQuXFxuXFx0ICAgICAgd2luZG93Lm9wZW4ocG93ZXJlZEJ5LmhyZWYsIHBvd2VyZWRCeS50YXJnZXQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1lbnUuYXBwZW5kQ2hpbGQocG93ZXJlZEJ5KTtcXG5cXG5cXHQgICAgaWYgKG9wdGlvbnMuY2hhbmdlKSB7XFxuXFx0ICAgICAgLy8gcmVnaXN0ZXIgb25jaGFuZ2UgZXZlbnRcXG5cXHQgICAgICBlZGl0b3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIG9wdGlvbnMuY2hhbmdlKCk7XFxuXFx0ICAgICAgfSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICAvLyBsb2FkIGEgcGxhaW4gdGV4dCB0ZXh0YXJlYVxcblxcdCAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xcblxcdCAgICB0ZXh0YXJlYS5jbGFzc05hbWUgPSAndGV4dCc7XFxuXFx0ICAgIHRleHRhcmVhLnNwZWxsY2hlY2sgPSBmYWxzZTtcXG5cXHQgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKHRleHRhcmVhKTtcXG5cXHQgICAgdGhpcy50ZXh0YXJlYSA9IHRleHRhcmVhO1xcblxcblxcdCAgICBpZiAob3B0aW9ucy5jaGFuZ2UpIHtcXG5cXHQgICAgICAvLyByZWdpc3RlciBvbmNoYW5nZSBldmVudFxcblxcdCAgICAgIGlmICh0aGlzLnRleHRhcmVhLm9uaW5wdXQgPT09IG51bGwpIHtcXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgb3B0aW9ucy5jaGFuZ2UoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAvLyBvbmlucHV0IGlzIHVuZGVmaW5lZC4gRm9yIElFOC1cXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIG9wdGlvbnMuY2hhbmdlKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFdmVudCBoYW5kbGVyIGZvciBrZXlkb3duLiBIYW5kbGVzIHNob3J0Y3V0IGtleXNcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dGV4dG1vZGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgdmFyIGtleW51bSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XFxuXFx0ICB2YXIgaGFuZGxlZCA9IGZhbHNlO1xcblxcblxcdCAgaWYgKGtleW51bSA9PSAyMjAgJiYgZXZlbnQuY3RybEtleSkge1xcblxcdCAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHsgLy8gQ3RybCtTaGlmdCtcXFxcXFxuXFx0ICAgICAgdGhpcy5jb21wYWN0KCk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7IC8vIEN0cmwrXFxcXFxcblxcdCAgICAgIHRoaXMuZm9ybWF0KCk7XFxuXFx0ICAgIH1cXG5cXHQgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoaGFuZGxlZCkge1xcblxcdCAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERldGFjaCB0aGUgZWRpdG9yIGZyb20gdGhlIERPTVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0dGV4dG1vZGUuX2RlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIGlmICh0aGlzLmZyYW1lICYmIHRoaXMuY29udGFpbmVyICYmIHRoaXMuZnJhbWUucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRhaW5lcikge1xcblxcdCAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRocm93IGFuIGVycm9yLiBJZiBhbiBlcnJvciBjYWxsYmFjayBpcyBjb25maWd1cmVkIGluIG9wdGlvbnMuZXJyb3IsIHRoaXNcXG5cXHQgKiBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQuIEVsc2UsIGEgcmVndWxhciBlcnJvciBpcyB0aHJvd24uXFxuXFx0ICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHR0ZXh0bW9kZS5fb25FcnJvciA9IGZ1bmN0aW9uKGVycikge1xcblxcdCAgLy8gVE9ETzogb25FcnJvciBpcyBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4yLjAuIGNsZWFudXAgc29tZSBkYXlcXG5cXHQgIGlmICh0eXBlb2YgdGhpcy5vbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0ICAgIHV0aWwubG9nKCdXQVJOSU5HOiBKU09ORWRpdG9yLm9uRXJyb3IgaXMgZGVwcmVjYXRlZC4gJyArXFxuXFx0ICAgICAgICAnVXNlIG9wdGlvbnMuZXJyb3IgaW5zdGVhZC4nKTtcXG5cXHQgICAgdGhpcy5vbkVycm9yKGVycik7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAodGhpcy5vcHRpb25zICYmIHR5cGVvZiB0aGlzLm9wdGlvbnMuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcXG5cXHQgICAgdGhpcy5vcHRpb25zLmVycm9yKGVycik7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgdGhyb3cgZXJyO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ29tcGFjdCB0aGUgY29kZSBpbiB0aGUgZm9ybWF0dGVyXFxuXFx0ICovXFxuXFx0dGV4dG1vZGUuY29tcGFjdCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHZhciBqc29uID0gdGhpcy5nZXQoKTtcXG5cXHQgIHZhciB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoanNvbik7XFxuXFx0ICB0aGlzLnNldFRleHQodGV4dCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBGb3JtYXQgdGhlIGNvZGUgaW4gdGhlIGZvcm1hdHRlclxcblxcdCAqL1xcblxcdHRleHRtb2RlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHZhciBqc29uID0gdGhpcy5nZXQoKTtcXG5cXHQgIHZhciB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgdGhpcy5pbmRlbnRhdGlvbik7XFxuXFx0ICB0aGlzLnNldFRleHQodGV4dCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgZm9jdXMgdG8gdGhlIGZvcm1hdHRlclxcblxcdCAqL1xcblxcdHRleHRtb2RlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xcblxcdCAgaWYgKHRoaXMudGV4dGFyZWEpIHtcXG5cXHQgICAgdGhpcy50ZXh0YXJlYS5mb2N1cygpO1xcblxcdCAgfVxcblxcdCAgaWYgKHRoaXMuZWRpdG9yKSB7XFxuXFx0ICAgIHRoaXMuZWRpdG9yLmZvY3VzKCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZXNpemUgdGhlIGZvcm1hdHRlclxcblxcdCAqL1xcblxcdHRleHRtb2RlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIGlmICh0aGlzLmVkaXRvcikge1xcblxcdCAgICB2YXIgZm9yY2UgPSBmYWxzZTtcXG5cXHQgICAgdGhpcy5lZGl0b3IucmVzaXplKGZvcmNlKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldCBqc29uIGRhdGEgaW4gdGhlIGZvcm1hdHRlclxcblxcdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXFxuXFx0ICovXFxuXFx0dGV4dG1vZGUuc2V0ID0gZnVuY3Rpb24oanNvbikge1xcblxcdCAgdGhpcy5zZXRUZXh0KEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIHRoaXMuaW5kZW50YXRpb24pKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCBqc29uIGRhdGEgZnJvbSB0aGUgZm9ybWF0dGVyXFxuXFx0ICogQHJldHVybiB7T2JqZWN0fSBqc29uXFxuXFx0ICovXFxuXFx0dGV4dG1vZGUuZ2V0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xcblxcdCAgdmFyIGpzb247XFxuXFxuXFx0ICB0cnkge1xcblxcdCAgICBqc29uID0gdXRpbC5wYXJzZSh0ZXh0KTsgLy8gdGhpcyBjYW4gdGhyb3cgYW4gZXJyb3JcXG5cXHQgIH1cXG5cXHQgIGNhdGNoIChlcnIpIHtcXG5cXHQgICAgLy8gdHJ5IHRvIHNhbml0aXplIGpzb24sIHJlcGxhY2UgSmF2YVNjcmlwdCBub3RhdGlvbiB3aXRoIEpTT04gbm90YXRpb25cXG5cXHQgICAgdGV4dCA9IHV0aWwuc2FuaXRpemUodGV4dCk7XFxuXFxuXFx0ICAgIC8vIHRyeSB0byBwYXJzZSBhZ2FpblxcblxcdCAgICBqc29uID0gdXRpbC5wYXJzZSh0ZXh0KTsgLy8gdGhpcyBjYW4gdGhyb3cgYW4gZXJyb3JcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBqc29uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBlZGl0b3JcXG5cXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb25UZXh0XFxuXFx0ICovXFxuXFx0dGV4dG1vZGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgaWYgKHRoaXMudGV4dGFyZWEpIHtcXG5cXHQgICAgcmV0dXJuIHRoaXMudGV4dGFyZWEudmFsdWU7XFxuXFx0ICB9XFxuXFx0ICBpZiAodGhpcy5lZGl0b3IpIHtcXG5cXHQgICAgcmV0dXJuIHRoaXMuZWRpdG9yLmdldFZhbHVlKCk7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gJyc7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgdGhlIHRleHQgY29udGVudHMgb2YgdGhlIGVkaXRvclxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBqc29uVGV4dFxcblxcdCAqL1xcblxcdHRleHRtb2RlLnNldFRleHQgPSBmdW5jdGlvbihqc29uVGV4dCkge1xcblxcdCAgaWYgKHRoaXMudGV4dGFyZWEpIHtcXG5cXHQgICAgdGhpcy50ZXh0YXJlYS52YWx1ZSA9IGpzb25UZXh0O1xcblxcdCAgfVxcblxcdCAgaWYgKHRoaXMuZWRpdG9yKSB7XFxuXFx0ICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKGpzb25UZXh0LCAtMSk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvLyBkZWZpbmUgbW9kZXNcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IFtcXG5cXHQgIHtcXG5cXHQgICAgbW9kZTogJ3RleHQnLFxcblxcdCAgICBtaXhpbjogdGV4dG1vZGUsXFxuXFx0ICAgIGRhdGE6ICd0ZXh0JyxcXG5cXHQgICAgbG9hZDogdGV4dG1vZGUuZm9ybWF0XFxuXFx0ICB9LFxcblxcdCAge1xcblxcdCAgICBtb2RlOiAnY29kZScsXFxuXFx0ICAgIG1peGluOiB0ZXh0bW9kZSxcXG5cXHQgICAgZGF0YTogJ3RleHQnLFxcblxcdCAgICBsb2FkOiB0ZXh0bW9kZS5mb3JtYXRcXG5cXHQgIH1cXG5cXHRdO1xcblxcblxcbi8qKiovIH0sXFxuLyogMyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBqc29ubGludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xcblxcblxcdC8qKlxcblxcdCAqIFBhcnNlIEpTT04gdXNpbmcgdGhlIHBhcnNlciBidWlsdC1pbiBpbiB0aGUgYnJvd3Nlci5cXG5cXHQgKiBPbiBleGNlcHRpb24sIHRoZSBqc29uU3RyaW5nIGlzIHZhbGlkYXRlZCBhbmQgYSBkZXRhaWxlZCBlcnJvciBpcyB0aHJvd24uXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcXG5cXHQgKiBAcmV0dXJuIHtKU09OfSBqc29uXFxuXFx0ICovXFxuXFx0ZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGpzb25TdHJpbmcpIHtcXG5cXHQgIHRyeSB7XFxuXFx0ICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xcblxcdCAgfVxcblxcdCAgY2F0Y2ggKGVycikge1xcblxcdCAgICAvLyB0cnkgdG8gdGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yIG1lc3NhZ2UgdXNpbmcgdmFsaWRhdGVcXG5cXHQgICAgZXhwb3J0cy52YWxpZGF0ZShqc29uU3RyaW5nKTtcXG5cXG5cXHQgICAgLy8gcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3JcXG5cXHQgICAgdGhyb3cgZXJyO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2FuaXRpemUgYSBKU09OLWxpa2Ugc3RyaW5nIGNvbnRhaW5pbmcuIEZvciBleGFtcGxlIGNoYW5nZXMgSmF2YVNjcmlwdFxcblxcdCAqIG5vdGF0aW9uIGludG8gSlNPTiBub3RhdGlvbi5cXG5cXHQgKiBUaGlzIGZ1bmN0aW9uIGZvciBleGFtcGxlIGNoYW5nZXMgYSBzdHJpbmcgbGlrZSBcXFwie2E6IDIsICdiJzoge2M6ICdkJ31cXFwiXFxuXFx0ICogaW50byAne1xcXCJhXFxcIjogMiwgXFxcImJcXFwiOiB7XFxcImNcXFwiOiBcXFwiZFxcXCJ9J1xcblxcdCAqIEBwYXJhbSB7c3RyaW5nfSBqc1N0cmluZ1xcblxcdCAqIEByZXR1cm5zIHtzdHJpbmd9IGpzb25cXG5cXHQgKi9cXG5cXHRleHBvcnRzLnNhbml0aXplID0gZnVuY3Rpb24gKGpzU3RyaW5nKSB7XFxuXFx0ICAvLyBlc2NhcGUgYWxsIHNpbmdsZSBhbmQgZG91YmxlIHF1b3RlcyBpbnNpZGUgc3RyaW5nc1xcblxcdCAgdmFyIGNoYXJzID0gW107XFxuXFx0ICB2YXIgaSA9IDA7XFxuXFxuXFx0ICAvL0lmIEpTT04gc3RhcnRzIHdpdGggYSBmdW5jdGlvbiAoY2hhcmFjdGVycy9kaWdpdHMvXFxcIl8tXFxcIiksIHJlbW92ZSB0aGlzIGZ1bmN0aW9uLlxcblxcdCAgLy9UaGlzIGlzIHVzZWZ1bCBmb3IgXFxcInN0cmlwcGluZ1xcXCIgSlNPTlAgb2JqZWN0cyB0byBiZWNvbWUgSlNPTlxcblxcdCAgLy9Gb3IgZXhhbXBsZTogLyogc29tZSBjb21tZW50ICovIGZ1bmN0aW9uXzEyMzIxMzIxICggW3tcXFwiYVxcXCI6XFxcImJcXFwifV0gKTsgPT4gW3tcXFwiYVxcXCI6XFxcImJcXFwifV1cXG5cXHQgIHZhciBtYXRjaCA9IGpzU3RyaW5nLm1hdGNoKC9eXFxcXHMqKFxcXFwvXFxcXCooLnxbXFxcXHJcXFxcbl0pKj9cXFxcKlxcXFwvKT9cXFxccypbXFxcXGRhLXpBLVpfJF0rXFxcXHMqXFxcXCgoW1xcXFxzXFxcXFNdKilcXFxcKVxcXFxzKjs/XFxcXHMqJC8pO1xcblxcdCAgaWYgKG1hdGNoKSB7XFxuXFx0ICAgIGpzU3RyaW5nID0gbWF0Y2hbM107XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBoZWxwZXIgZnVuY3Rpb25zIHRvIGdldCB0aGUgY3VycmVudC9wcmV2L25leHQgY2hhcmFjdGVyXFxuXFx0ICBmdW5jdGlvbiBjdXJyICgpIHsgcmV0dXJuIGpzU3RyaW5nLmNoYXJBdChpKTsgICAgIH1cXG5cXHQgIGZ1bmN0aW9uIG5leHQoKSAgeyByZXR1cm4ganNTdHJpbmcuY2hhckF0KGkgKyAxKTsgfVxcblxcdCAgZnVuY3Rpb24gcHJldigpICB7IHJldHVybiBqc1N0cmluZy5jaGFyQXQoaSAtIDEpOyB9XFxuXFxuXFx0ICAvLyB0ZXN0IHdoZXRoZXIgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIHdhcyBhIGJyYWNlLW9wZW4gJ3snXFxuXFx0ICBmdW5jdGlvbiBwcmV2SXNCcmFjZSgpIHtcXG5cXHQgICAgdmFyIGlpID0gaSAtIDE7XFxuXFx0ICAgIHdoaWxlIChpaSA+PSAwKSB7XFxuXFx0ICAgICAgdmFyIGNjID0ganNTdHJpbmcuY2hhckF0KGlpKTtcXG5cXHQgICAgICBpZiAoY2MgPT09ICd7Jykge1xcblxcdCAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGVsc2UgaWYgKGNjID09PSAnICcgfHwgY2MgPT09ICdcXFxcbicgfHwgY2MgPT09ICdcXFxccicpIHsgLy8gd2hpdGVzcGFjZVxcblxcdCAgICAgICAgaWktLTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiBmYWxzZTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIHNraXAgYSBibG9jayBjb21tZW50ICcvKiAuLi4gKi8nXFxuXFx0ICBmdW5jdGlvbiBza2lwQ29tbWVudCAoKSB7XFxuXFx0ICAgIGkgKz0gMjtcXG5cXHQgICAgd2hpbGUgKGkgPCBqc1N0cmluZy5sZW5ndGggJiYgKGN1cnIoKSAhPT0gJyonIHx8IG5leHQoKSAhPT0gJy8nKSkge1xcblxcdCAgICAgIGkrKztcXG5cXHQgICAgfVxcblxcdCAgICBpICs9IDI7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBwYXJzZSBzaW5nbGUgb3IgZG91YmxlIHF1b3RlZCBzdHJpbmdcXG5cXHQgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHF1b3RlKSB7XFxuXFx0ICAgIGNoYXJzLnB1c2goJ1xcXCInKTtcXG5cXHQgICAgaSsrO1xcblxcdCAgICB2YXIgYyA9IGN1cnIoKTtcXG5cXHQgICAgd2hpbGUgKGkgPCBqc1N0cmluZy5sZW5ndGggJiYgYyAhPT0gcXVvdGUpIHtcXG5cXHQgICAgICBpZiAoYyA9PT0gJ1xcXCInICYmIHByZXYoKSAhPT0gJ1xcXFxcXFxcJykge1xcblxcdCAgICAgICAgLy8gdW5lc2NhcGVkIGRvdWJsZSBxdW90ZSwgZXNjYXBlIGl0XFxuXFx0ICAgICAgICBjaGFycy5wdXNoKCdcXFxcXFxcXCcpO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICAvLyBoYW5kbGUgZXNjYXBlIGNoYXJhY3RlclxcblxcdCAgICAgIGlmIChjID09PSAnXFxcXFxcXFwnKSB7XFxuXFx0ICAgICAgICBpKys7XFxuXFx0ICAgICAgICBjID0gY3VycigpO1xcblxcblxcdCAgICAgICAgLy8gcmVtb3ZlIHRoZSBlc2NhcGUgY2hhcmFjdGVyIHdoZW4gZm9sbG93ZWQgYnkgYSBzaW5nbGUgcXVvdGUgJywgbm90IG5lZWRlZFxcblxcdCAgICAgICAgaWYgKGMgIT09ICdcXFxcJycpIHtcXG5cXHQgICAgICAgICAgY2hhcnMucHVzaCgnXFxcXFxcXFwnKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgICAgY2hhcnMucHVzaChjKTtcXG5cXG5cXHQgICAgICBpKys7XFxuXFx0ICAgICAgYyA9IGN1cnIoKTtcXG5cXHQgICAgfVxcblxcdCAgICBpZiAoYyA9PT0gcXVvdGUpIHtcXG5cXHQgICAgICBjaGFycy5wdXNoKCdcXFwiJyk7XFxuXFx0ICAgICAgaSsrO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBwYXJzZSBhbiB1bnF1b3RlZCBrZXlcXG5cXHQgIGZ1bmN0aW9uIHBhcnNlS2V5KCkge1xcblxcdCAgICB2YXIgc3BlY2lhbFZhbHVlcyA9IFsnbnVsbCcsICd0cnVlJywgJ2ZhbHNlJ107XFxuXFx0ICAgIHZhciBrZXkgPSAnJztcXG5cXHQgICAgdmFyIGMgPSBjdXJyKCk7XFxuXFxuXFx0ICAgIHZhciByZWdleHAgPSAvW2EtekEtWl8kXFxcXGRdLzsgLy8gbGV0dGVyLCBudW1iZXIsIHVuZGVyc2NvcmUsIGRvbGxhciBjaGFyYWN0ZXJcXG5cXHQgICAgd2hpbGUgKHJlZ2V4cC50ZXN0KGMpKSB7XFxuXFx0ICAgICAga2V5ICs9IGM7XFxuXFx0ICAgICAgaSsrO1xcblxcdCAgICAgIGMgPSBjdXJyKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKHNwZWNpYWxWYWx1ZXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xcblxcdCAgICAgIGNoYXJzLnB1c2goJ1xcXCInICsga2V5ICsgJ1xcXCInKTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICBjaGFycy5wdXNoKGtleSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHdoaWxlKGkgPCBqc1N0cmluZy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIGMgPSBjdXJyKCk7XFxuXFxuXFx0ICAgIGlmIChjID09PSAnLycgJiYgbmV4dCgpID09PSAnKicpIHtcXG5cXHQgICAgICBza2lwQ29tbWVudCgpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKGMgPT09ICdcXFxcJycgfHwgYyA9PT0gJ1xcXCInKSB7XFxuXFx0ICAgICAgcGFyc2VTdHJpbmcoYyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAoL1thLXpBLVpfJF0vLnRlc3QoYykgJiYgcHJldklzQnJhY2UoKSkge1xcblxcdCAgICAgIC8vIGFuIHVucXVvdGVkIG9iamVjdCBrZXkgKGxpa2UgYSBpbiAne2E6Mn0nKVxcblxcdCAgICAgIHBhcnNlS2V5KCk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgY2hhcnMucHVzaChjKTtcXG5cXHQgICAgICBpKys7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBjaGFycy5qb2luKCcnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFZhbGlkYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBKU09OIG9iamVjdFxcblxcdCAqIFRoaXMgbWV0aG9kIHVzZXMgSlNPTkxpbnQgdG8gdmFsaWRhdGUgdGhlIFN0cmluZy4gSWYgSlNPTkxpbnQgaXMgbm90XFxuXFx0ICogYXZhaWxhYmxlLCB0aGUgYnVpbHQtaW4gSlNPTiBwYXJzZXIgb2YgdGhlIGJyb3dzZXIgaXMgdXNlZC5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZyAgIFN0cmluZyB3aXRoIGFuIChpbnZhbGlkKSBKU09OIG9iamVjdFxcblxcdCAqIEB0aHJvd3MgRXJyb3JcXG5cXHQgKi9cXG5cXHRleHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoanNvblN0cmluZykge1xcblxcdCAgaWYgKHR5cGVvZihqc29ubGludCkgIT0gJ3VuZGVmaW5lZCcpIHtcXG5cXHQgICAganNvbmxpbnQucGFyc2UoanNvblN0cmluZyk7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEV4dGVuZCBvYmplY3QgYSB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IGFcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gYlxcblxcdCAqIEByZXR1cm4ge09iamVjdH0gYVxcblxcdCAqL1xcblxcdGV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcXG5cXHQgIGZvciAodmFyIHByb3AgaW4gYikge1xcblxcdCAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xcblxcdCAgICAgIGFbcHJvcF0gPSBiW3Byb3BdO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gYTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlbW92ZSBhbGwgcHJvcGVydGllcyBmcm9tIG9iamVjdCBhXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IGFcXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IGFcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKGEpIHtcXG5cXHQgIGZvciAodmFyIHByb3AgaW4gYSkge1xcblxcdCAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xcblxcdCAgICAgIGRlbGV0ZSBhW3Byb3BdO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gYTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIE91dHB1dCB0ZXh0IHRvIHRoZSBjb25zb2xlLCBpZiBjb25zb2xlIGlzIGF2YWlsYWJsZVxcblxcdCAqIEBwYXJhbSB7Li4uKn0gYXJnc1xcblxcdCAqL1xcblxcdGV4cG9ydHMubG9nID0gZnVuY3Rpb24gbG9nIChhcmdzKSB7XFxuXFx0ICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdCAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSB0eXBlIG9mIGFuIG9iamVjdFxcblxcdCAqIEBwYXJhbSB7Kn0gb2JqZWN0XFxuXFx0ICogQHJldHVybiB7U3RyaW5nfSB0eXBlXFxuXFx0ICovXFxuXFx0ZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSAob2JqZWN0KSB7XFxuXFx0ICBpZiAob2JqZWN0ID09PSBudWxsKSB7XFxuXFx0ICAgIHJldHVybiAnbnVsbCc7XFxuXFx0ICB9XFxuXFx0ICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgcmV0dXJuICd1bmRlZmluZWQnO1xcblxcdCAgfVxcblxcdCAgaWYgKChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHx8ICh0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJykpIHtcXG5cXHQgICAgcmV0dXJuICdudW1iZXInO1xcblxcdCAgfVxcblxcdCAgaWYgKChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHx8ICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykpIHtcXG5cXHQgICAgcmV0dXJuICdzdHJpbmcnO1xcblxcdCAgfVxcblxcdCAgaWYgKChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB8fCAodHlwZW9mIG9iamVjdCA9PT0gJ2Jvb2xlYW4nKSkge1xcblxcdCAgICByZXR1cm4gJ2Jvb2xlYW4nO1xcblxcdCAgfVxcblxcdCAgaWYgKChvYmplY3QgaW5zdGFuY2VvZiBSZWdFeHApIHx8ICh0eXBlb2Ygb2JqZWN0ID09PSAncmVnZXhwJykpIHtcXG5cXHQgICAgcmV0dXJuICdyZWdleHAnO1xcblxcdCAgfVxcblxcdCAgaWYgKGV4cG9ydHMuaXNBcnJheShvYmplY3QpKSB7XFxuXFx0ICAgIHJldHVybiAnYXJyYXknO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuICdvYmplY3QnO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGVzdCB3aGV0aGVyIGEgdGV4dCBjb250YWlucyBhIHVybCAobWF0Y2hlcyB3aGVuIGEgc3RyaW5nIHN0YXJ0c1xcblxcdCAqIHdpdGggJ2h0dHA6Ly8qJyBvciAnaHR0cHM6Ly8qJyBhbmQgaGFzIG5vIHdoaXRlc3BhY2UgY2hhcmFjdGVycylcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxcblxcdCAqL1xcblxcdHZhciBpc1VybFJlZ2V4ID0gL15odHRwcz86XFxcXC9cXFxcL1xcXFxTKyQvO1xcblxcdGV4cG9ydHMuaXNVcmwgPSBmdW5jdGlvbiBpc1VybCAodGV4dCkge1xcblxcdCAgcmV0dXJuICh0eXBlb2YgdGV4dCA9PSAnc3RyaW5nJyB8fCB0ZXh0IGluc3RhbmNlb2YgU3RyaW5nKSAmJlxcblxcdCAgICAgIGlzVXJsUmVnZXgudGVzdCh0ZXh0KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRlcyB3aGV0aGVyIGdpdmVuIG9iamVjdCBpcyBhbiBBcnJheVxcblxcdCAqIEBwYXJhbSB7Kn0gb2JqXFxuXFx0ICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMgdHJ1ZSB3aGVuIG9iaiBpcyBhbiBhcnJheVxcblxcdCAqL1xcblxcdGV4cG9ydHMuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcXG5cXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSBsZWZ0IHZhbHVlIG9mIGEgRE9NIGVsZW1lbnRcXG5cXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcXG5cXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlZnQgICAgVGhlIGFic29sdXRlIGxlZnQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBicm93c2VyIHBhZ2UuXFxuXFx0ICovXFxuXFx0ZXhwb3J0cy5nZXRBYnNvbHV0ZUxlZnQgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZUxlZnQoZWxlbSkge1xcblxcdCAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdCAgcmV0dXJuIHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxMZWZ0IHx8IDA7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZXRyaWV2ZSB0aGUgYWJzb2x1dGUgdG9wIHZhbHVlIG9mIGEgRE9NIGVsZW1lbnRcXG5cXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gICAgQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXZcXG5cXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRvcCAgICAgVGhlIGFic29sdXRlIHRvcCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnRcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIGJyb3dzZXIgcGFnZS5cXG5cXHQgKi9cXG5cXHRleHBvcnRzLmdldEFic29sdXRlVG9wID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGVUb3AoZWxlbSkge1xcblxcdCAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdCAgcmV0dXJuIHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCB8fCAwO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogYWRkIGEgY2xhc3NOYW1lIHRvIHRoZSBnaXZlbiBlbGVtZW50cyBzdHlsZVxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbGVtLCBjbGFzc05hbWUpIHtcXG5cXHQgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoJyAnKTtcXG5cXHQgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xcblxcdCAgICBjbGFzc2VzLnB1c2goY2xhc3NOYW1lKTsgLy8gYWRkIHRoZSBjbGFzcyB0byB0aGUgYXJyYXlcXG5cXHQgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIGFkZCBhIGNsYXNzTmFtZSB0byB0aGUgZ2l2ZW4gZWxlbWVudHMgc3R5bGVcXG5cXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lXFxuXFx0ICovXFxuXFx0ZXhwb3J0cy5yZW1vdmVDbGFzc05hbWUgPSBmdW5jdGlvbiByZW1vdmVDbGFzc05hbWUoZWxlbSwgY2xhc3NOYW1lKSB7XFxuXFx0ICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KCcgJyk7XFxuXFx0ICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKTtcXG5cXHQgIGlmIChpbmRleCAhPSAtMSkge1xcblxcdCAgICBjbGFzc2VzLnNwbGljZShpbmRleCwgMSk7IC8vIHJlbW92ZSB0aGUgY2xhc3MgZnJvbSB0aGUgYXJyYXlcXG5cXHQgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN0cmlwIHRoZSBmb3JtYXR0aW5nIGZyb20gdGhlIGNvbnRlbnRzIG9mIGEgZGl2XFxuXFx0ICogdGhlIGZvcm1hdHRpbmcgZnJvbSB0aGUgZGl2IGl0c2VsZiBpcyBub3Qgc3RyaXBwZWQsIG9ubHkgZnJvbSBpdHMgY2hpbGRzLlxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gZGl2RWxlbWVudFxcblxcdCAqL1xcblxcdGV4cG9ydHMuc3RyaXBGb3JtYXR0aW5nID0gZnVuY3Rpb24gc3RyaXBGb3JtYXR0aW5nKGRpdkVsZW1lbnQpIHtcXG5cXHQgIHZhciBjaGlsZHMgPSBkaXZFbGVtZW50LmNoaWxkTm9kZXM7XFxuXFx0ICBmb3IgKHZhciBpID0gMCwgaU1heCA9IGNoaWxkcy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcXG5cXHQgICAgdmFyIGNoaWxkID0gY2hpbGRzW2ldO1xcblxcblxcdCAgICAvLyByZW1vdmUgdGhlIHN0eWxlXFxuXFx0ICAgIGlmIChjaGlsZC5zdHlsZSkge1xcblxcdCAgICAgIC8vIFRPRE86IHRlc3QgaWYgY2hpbGQuYXR0cmlidXRlcyBkb2VzIGNvbnRhaW4gc3R5bGVcXG5cXHQgICAgICBjaGlsZC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gcmVtb3ZlIGFsbCBhdHRyaWJ1dGVzXFxuXFx0ICAgIHZhciBhdHRyaWJ1dGVzID0gY2hpbGQuYXR0cmlidXRlcztcXG5cXHQgICAgaWYgKGF0dHJpYnV0ZXMpIHtcXG5cXHQgICAgICBmb3IgKHZhciBqID0gYXR0cmlidXRlcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xcblxcdCAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XFxuXFx0ICAgICAgICBpZiAoYXR0cmlidXRlLnNwZWNpZmllZCA9PT0gdHJ1ZSkge1xcblxcdCAgICAgICAgICBjaGlsZC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyByZWN1cnNpdmVseSBzdHJpcCBjaGlsZHNcXG5cXHQgICAgZXhwb3J0cy5zdHJpcEZvcm1hdHRpbmcoY2hpbGQpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0IGZvY3VzIHRvIHRoZSBlbmQgb2YgYW4gZWRpdGFibGUgZGl2XFxuXFx0ICogY29kZSBmcm9tIE5pY28gQnVybnNcXG5cXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vdXNlcnMvMTQwMjkzL25pY28tYnVybnNcXG5cXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExMjUyOTIvaG93LXRvLW1vdmUtY3Vyc29yLXRvLWVuZC1vZi1jb250ZW50ZWRpdGFibGUtZW50aXR5XFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBjb250ZW50RWRpdGFibGVFbGVtZW50ICAgQSBjb250ZW50IGVkaXRhYmxlIGRpdlxcblxcdCAqL1xcblxcdGV4cG9ydHMuc2V0RW5kT2ZDb250ZW50RWRpdGFibGUgPSBmdW5jdGlvbiBzZXRFbmRPZkNvbnRlbnRFZGl0YWJsZShjb250ZW50RWRpdGFibGVFbGVtZW50KSB7XFxuXFx0ICB2YXIgcmFuZ2UsIHNlbGVjdGlvbjtcXG5cXHQgIGlmKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7XFxuXFx0ICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTsvL0NyZWF0ZSBhIHJhbmdlIChhIHJhbmdlIGlzIGEgbGlrZSB0aGUgc2VsZWN0aW9uIGJ1dCBpbnZpc2libGUpXFxuXFx0ICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhjb250ZW50RWRpdGFibGVFbGVtZW50KTsvL1NlbGVjdCB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IHdpdGggdGhlIHJhbmdlXFxuXFx0ICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTsvL2NvbGxhcHNlIHRoZSByYW5nZSB0byB0aGUgZW5kIHBvaW50LiBmYWxzZSBtZWFucyBjb2xsYXBzZSB0byBlbmQgcmF0aGVyIHRoYW4gdGhlIHN0YXJ0XFxuXFx0ICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTsvL2dldCB0aGUgc2VsZWN0aW9uIG9iamVjdCAoYWxsb3dzIHlvdSB0byBjaGFuZ2Ugc2VsZWN0aW9uKVxcblxcdCAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7Ly9yZW1vdmUgYW55IHNlbGVjdGlvbnMgYWxyZWFkeSBtYWRlXFxuXFx0ICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7Ly9tYWtlIHRoZSByYW5nZSB5b3UgaGF2ZSBqdXN0IGNyZWF0ZWQgdGhlIHZpc2libGUgc2VsZWN0aW9uXFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZWxlY3QgYWxsIHRleHQgb2YgYSBjb250ZW50IGVkaXRhYmxlIGRpdi5cXG5cXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zODA2MDA0LzEyNjI3NTNcXG5cXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQgICBBIGNvbnRlbnQgZWRpdGFibGUgZGl2XFxuXFx0ICovXFxuXFx0ZXhwb3J0cy5zZWxlY3RDb250ZW50RWRpdGFibGUgPSBmdW5jdGlvbiBzZWxlY3RDb250ZW50RWRpdGFibGUoY29udGVudEVkaXRhYmxlRWxlbWVudCkge1xcblxcdCAgaWYgKCFjb250ZW50RWRpdGFibGVFbGVtZW50IHx8IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQubm9kZU5hbWUgIT0gJ0RJVicpIHtcXG5cXHQgICAgcmV0dXJuO1xcblxcdCAgfVxcblxcblxcdCAgdmFyIHNlbCwgcmFuZ2U7XFxuXFx0ICBpZiAod2luZG93LmdldFNlbGVjdGlvbiAmJiBkb2N1bWVudC5jcmVhdGVSYW5nZSkge1xcblxcdCAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XFxuXFx0ICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhjb250ZW50RWRpdGFibGVFbGVtZW50KTtcXG5cXHQgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xcblxcdCAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XFxuXFx0ICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgdGV4dCBzZWxlY3Rpb25cXG5cXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ2ODc4MDgvY29udGVudGVkaXRhYmxlLXNlbGVjdGVkLXRleHQtc2F2ZS1hbmQtcmVzdG9yZVxcblxcdCAqIEByZXR1cm4ge1JhbmdlIHwgVGV4dFJhbmdlIHwgbnVsbH0gcmFuZ2VcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcXG5cXHQgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XFxuXFx0ICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuXFx0ICAgIGlmIChzZWwuZ2V0UmFuZ2VBdCAmJiBzZWwucmFuZ2VDb3VudCkge1xcblxcdCAgICAgIHJldHVybiBzZWwuZ2V0UmFuZ2VBdCgwKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgcmV0dXJuIG51bGw7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgdGV4dCBzZWxlY3Rpb25cXG5cXHQgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ2ODc4MDgvY29udGVudGVkaXRhYmxlLXNlbGVjdGVkLXRleHQtc2F2ZS1hbmQtcmVzdG9yZVxcblxcdCAqIEBwYXJhbSB7UmFuZ2UgfCBUZXh0UmFuZ2UgfCBudWxsfSByYW5nZVxcblxcdCAqL1xcblxcdGV4cG9ydHMuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gc2V0U2VsZWN0aW9uKHJhbmdlKSB7XFxuXFx0ICBpZiAocmFuZ2UpIHtcXG5cXHQgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcXG5cXHQgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xcblxcdCAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcXG5cXHQgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgc2VsZWN0ZWQgdGV4dCByYW5nZVxcblxcdCAqIEByZXR1cm4ge09iamVjdH0gcGFyYW1zICBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzOlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gIHN0YXJ0T2Zmc2V0XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TnVtYmVyfSAgZW5kT2Zmc2V0XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7RWxlbWVudH0gY29udGFpbmVyICBIVE1MIGVsZW1lbnQgaG9sZGluZyB0aGVcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIHRleHQgZWxlbWVudFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIG51bGwgaWYgbm8gdGV4dCBzZWxlY3Rpb24gaXMgZm91bmRcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmdldFNlbGVjdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvbk9mZnNldCgpIHtcXG5cXHQgIHZhciByYW5nZSA9IGV4cG9ydHMuZ2V0U2VsZWN0aW9uKCk7XFxuXFxuXFx0ICBpZiAocmFuZ2UgJiYgJ3N0YXJ0T2Zmc2V0JyBpbiByYW5nZSAmJiAnZW5kT2Zmc2V0JyBpbiByYW5nZSAmJlxcblxcdCAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyICYmIChyYW5nZS5zdGFydENvbnRhaW5lciA9PSByYW5nZS5lbmRDb250YWluZXIpKSB7XFxuXFx0ICAgIHJldHVybiB7XFxuXFx0ICAgICAgc3RhcnRPZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0LFxcblxcdCAgICAgIGVuZE9mZnNldDogcmFuZ2UuZW5kT2Zmc2V0LFxcblxcdCAgICAgIGNvbnRhaW5lcjogcmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZVxcblxcdCAgICB9O1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIG51bGw7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgc2VsZWN0ZWQgdGV4dCByYW5nZSBpbiBnaXZlbiBlbGVtZW50XFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAgIEFuIG9iamVjdCBjb250YWluaW5nOlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0VsZW1lbnR9IGNvbnRhaW5lclxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge051bWJlcn0gc3RhcnRPZmZzZXRcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtOdW1iZXJ9IGVuZE9mZnNldFxcblxcdCAqL1xcblxcdGV4cG9ydHMuc2V0U2VsZWN0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gc2V0U2VsZWN0aW9uT2Zmc2V0KHBhcmFtcykge1xcblxcdCAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcXG5cXHQgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG5cXHQgICAgaWYoc2VsZWN0aW9uKSB7XFxuXFx0ICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcXG5cXHQgICAgICAvLyBUT0RPOiBkbyBub3Qgc3VwcG9zZSB0aGF0IHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgY29udGFpbmVyIGlzIGEgdGV4dG5vZGUsXFxuXFx0ICAgICAgLy8gICAgICAgYnV0IHJlY3Vyc2l2ZWx5IGZpbmQgdGhlIHRleHRub2Rlc1xcblxcdCAgICAgIHJhbmdlLnNldFN0YXJ0KHBhcmFtcy5jb250YWluZXIuZmlyc3RDaGlsZCwgcGFyYW1zLnN0YXJ0T2Zmc2V0KTtcXG5cXHQgICAgICByYW5nZS5zZXRFbmQocGFyYW1zLmNvbnRhaW5lci5maXJzdENoaWxkLCBwYXJhbXMuZW5kT2Zmc2V0KTtcXG5cXG5cXHQgICAgICBleHBvcnRzLnNldFNlbGVjdGlvbihyYW5nZSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgaW5uZXIgdGV4dCBvZiBhbiBIVE1MIGVsZW1lbnQgKGZvciBleGFtcGxlIGEgZGl2IGVsZW1lbnQpXFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IFtidWZmZXJdXFxuXFx0ICogQHJldHVybiB7U3RyaW5nfSBpbm5lclRleHRcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmdldElubmVyVGV4dCA9IGZ1bmN0aW9uIGdldElubmVyVGV4dChlbGVtZW50LCBidWZmZXIpIHtcXG5cXHQgIHZhciBmaXJzdCA9IChidWZmZXIgPT0gdW5kZWZpbmVkKTtcXG5cXHQgIGlmIChmaXJzdCkge1xcblxcdCAgICBidWZmZXIgPSB7XFxuXFx0ICAgICAgJ3RleHQnOiAnJyxcXG5cXHQgICAgICAnZmx1c2gnOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dDtcXG5cXHQgICAgICAgIHRoaXMudGV4dCA9ICcnO1xcblxcdCAgICAgICAgcmV0dXJuIHRleHQ7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICAnc2V0JzogZnVuY3Rpb24gKHRleHQpIHtcXG5cXHQgICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgfVxcblxcblxcdCAgLy8gdGV4dCBub2RlXFxuXFx0ICBpZiAoZWxlbWVudC5ub2RlVmFsdWUpIHtcXG5cXHQgICAgcmV0dXJuIGJ1ZmZlci5mbHVzaCgpICsgZWxlbWVudC5ub2RlVmFsdWU7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBkaXZzIG9yIG90aGVyIEhUTUwgZWxlbWVudHNcXG5cXHQgIGlmIChlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xcblxcdCAgICB2YXIgY2hpbGROb2RlcyA9IGVsZW1lbnQuY2hpbGROb2RlcztcXG5cXHQgICAgdmFyIGlubmVyVGV4dCA9ICcnO1xcblxcblxcdCAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XFxuXFx0ICAgICAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcXG5cXG5cXHQgICAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT0gJ0RJVicgfHwgY2hpbGQubm9kZU5hbWUgPT0gJ1AnKSB7XFxuXFx0ICAgICAgICB2YXIgcHJldkNoaWxkID0gY2hpbGROb2Rlc1tpIC0gMV07XFxuXFx0ICAgICAgICB2YXIgcHJldk5hbWUgPSBwcmV2Q2hpbGQgPyBwcmV2Q2hpbGQubm9kZU5hbWUgOiB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICBpZiAocHJldk5hbWUgJiYgcHJldk5hbWUgIT0gJ0RJVicgJiYgcHJldk5hbWUgIT0gJ1AnICYmIHByZXZOYW1lICE9ICdCUicpIHtcXG5cXHQgICAgICAgICAgaW5uZXJUZXh0ICs9ICdcXFxcbic7XFxuXFx0ICAgICAgICAgIGJ1ZmZlci5mbHVzaCgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaW5uZXJUZXh0ICs9IGV4cG9ydHMuZ2V0SW5uZXJUZXh0KGNoaWxkLCBidWZmZXIpO1xcblxcdCAgICAgICAgYnVmZmVyLnNldCgnXFxcXG4nKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZU5hbWUgPT0gJ0JSJykge1xcblxcdCAgICAgICAgaW5uZXJUZXh0ICs9IGJ1ZmZlci5mbHVzaCgpO1xcblxcdCAgICAgICAgYnVmZmVyLnNldCgnXFxcXG4nKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICBpbm5lclRleHQgKz0gZXhwb3J0cy5nZXRJbm5lclRleHQoY2hpbGQsIGJ1ZmZlcik7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldHVybiBpbm5lclRleHQ7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT0gJ1AnICYmIGV4cG9ydHMuZ2V0SW50ZXJuZXRFeHBsb3JlclZlcnNpb24oKSAhPSAtMSkge1xcblxcdCAgICAgIC8vIE9uIEludGVybmV0IEV4cGxvcmVyLCBhIDxwPiB3aXRoIGhhc0NoaWxkTm9kZXMoKT09ZmFsc2UgaXNcXG5cXHQgICAgICAvLyByZW5kZXJlZCB3aXRoIGEgbmV3IGxpbmUuIE5vdGUgdGhhdCBhIDxwPiB3aXRoXFxuXFx0ICAgICAgLy8gaGFzQ2hpbGROb2RlcygpPT10cnVlIGlzIHJlbmRlcmVkIHdpdGhvdXQgYSBuZXcgbGluZVxcblxcdCAgICAgIC8vIE90aGVyIGJyb3dzZXJzIGFsd2F5cyBlbnN1cmUgdGhlcmUgaXMgYSA8YnI+IGluc2lkZSB0aGUgPHA+LFxcblxcdCAgICAgIC8vIGFuZCBpZiBub3QsIHRoZSA8cD4gZG9lcyBub3QgcmVuZGVyIGEgbmV3IGxpbmVcXG5cXHQgICAgICByZXR1cm4gYnVmZmVyLmZsdXNoKCk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIGJyIG9yIHVua25vd25cXG5cXHQgIHJldHVybiAnJztcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgSW50ZXJuZXQgRXhwbG9yZXIgb3IgYSAtMVxcblxcdCAqIChpbmRpY2F0aW5nIHRoZSB1c2Ugb2YgYW5vdGhlciBicm93c2VyKS5cXG5cXHQgKiBTb3VyY2U6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwOSh2PXZzLjg1KS5hc3B4XFxuXFx0ICogQHJldHVybiB7TnVtYmVyfSBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9uLCBvciAtMSBpbiBjYXNlIG9mIGFuIG90aGVyIGJyb3dzZXJcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmdldEludGVybmV0RXhwbG9yZXJWZXJzaW9uID0gZnVuY3Rpb24gZ2V0SW50ZXJuZXRFeHBsb3JlclZlcnNpb24oKSB7XFxuXFx0ICBpZiAoX2llVmVyc2lvbiA9PSAtMSkge1xcblxcdCAgICB2YXIgcnYgPSAtMTsgLy8gUmV0dXJuIHZhbHVlIGFzc3VtZXMgZmFpbHVyZS5cXG5cXHQgICAgaWYgKG5hdmlnYXRvci5hcHBOYW1lID09ICdNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXInKVxcblxcdCAgICB7XFxuXFx0ICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcXG5cXHQgICAgICB2YXIgcmUgID0gbmV3IFJlZ0V4cChcXFwiTVNJRSAoWzAtOV17MSx9W1xcXFwuMC05XXswLH0pXFxcIik7XFxuXFx0ICAgICAgaWYgKHJlLmV4ZWModWEpICE9IG51bGwpIHtcXG5cXHQgICAgICAgIHJ2ID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIF9pZVZlcnNpb24gPSBydjtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBfaWVWZXJzaW9uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgRmlyZWZveFxcblxcdCAqIEByZXR1cm5zIHtib29sZWFufSBpc0ZpcmVmb3hcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmlzRmlyZWZveCA9IGZ1bmN0aW9uIGlzRmlyZWZveCAoKSB7XFxuXFx0ICByZXR1cm4gKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcXFwiRmlyZWZveFxcXCIpICE9IC0xKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIGNhY2hlZCBpbnRlcm5ldCBleHBsb3JlciB2ZXJzaW9uXFxuXFx0ICogQHR5cGUge051bWJlcn1cXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdHZhciBfaWVWZXJzaW9uID0gLTE7XFxuXFxuXFx0LyoqXFxuXFx0ICogQWRkIGFuZCBldmVudCBsaXN0ZW5lci4gV29ya3MgZm9yIGFsbCBicm93c2Vyc1xcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gICAgIGVsZW1lbnQgICAgQW4gaHRtbCBlbGVtZW50XFxuXFx0ICogQHBhcmFtIHtzdHJpbmd9ICAgICAgYWN0aW9uICAgICBUaGUgYWN0aW9uLCBmb3IgZXhhbXBsZSBcXFwiY2xpY2tcXFwiLFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB0aGUgcHJlZml4IFxcXCJvblxcXCJcXG5cXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgICBsaXN0ZW5lciAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIFt1c2VDYXB0dXJlXSBmYWxzZSBieSBkZWZhdWx0XFxuXFx0ICogQHJldHVybiB7ZnVuY3Rpb259ICAgdGhlIGNyZWF0ZWQgZXZlbnQgbGlzdGVuZXJcXG5cXHQgKi9cXG5cXHRleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcXG5cXHQgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcXG5cXHQgICAgaWYgKHVzZUNhcHR1cmUgPT09IHVuZGVmaW5lZClcXG5cXHQgICAgICB1c2VDYXB0dXJlID0gZmFsc2U7XFxuXFxuXFx0ICAgIGlmIChhY3Rpb24gPT09IFxcXCJtb3VzZXdoZWVsXFxcIiAmJiBleHBvcnRzLmlzRmlyZWZveCgpKSB7XFxuXFx0ICAgICAgYWN0aW9uID0gXFxcIkRPTU1vdXNlU2Nyb2xsXFxcIjsgIC8vIEZvciBGaXJlZm94XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGFjdGlvbiwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xcblxcdCAgICByZXR1cm4gbGlzdGVuZXI7XFxuXFx0ICB9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcXG5cXHQgICAgLy8gT2xkIElFIGJyb3dzZXJzXFxuXFx0ICAgIHZhciBmID0gZnVuY3Rpb24gKCkge1xcblxcdCAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKGVsZW1lbnQsIHdpbmRvdy5ldmVudCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXFxcIm9uXFxcIiArIGFjdGlvbiwgZik7XFxuXFx0ICAgIHJldHVybiBmO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gIGVsZW1lbnQgICBBbiBodG1sIGRvbSBlbGVtZW50XFxuXFx0ICogQHBhcmFtIHtzdHJpbmd9ICAgYWN0aW9uICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgZm9yIGV4YW1wbGUgXFxcIm1vdXNlZG93blxcXCJcXG5cXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uXFxuXFx0ICogQHBhcmFtIHtib29sZWFufSAgW3VzZUNhcHR1cmVdICAgZmFsc2UgYnkgZGVmYXVsdFxcblxcdCAqL1xcblxcdGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xcblxcdCAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcblxcdCAgICBpZiAodXNlQ2FwdHVyZSA9PT0gdW5kZWZpbmVkKVxcblxcdCAgICAgIHVzZUNhcHR1cmUgPSBmYWxzZTtcXG5cXG5cXHQgICAgaWYgKGFjdGlvbiA9PT0gXFxcIm1vdXNld2hlZWxcXFwiICYmIGV4cG9ydHMuaXNGaXJlZm94KCkpIHtcXG5cXHQgICAgICBhY3Rpb24gPSBcXFwiRE9NTW91c2VTY3JvbGxcXFwiOyAgLy8gRm9yIEZpcmVmb3hcXG5cXHQgICAgfVxcblxcblxcdCAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYWN0aW9uLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XFxuXFx0ICB9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcXG5cXHQgICAgLy8gT2xkIElFIGJyb3dzZXJzXFxuXFx0ICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXFxcIm9uXFxcIiArIGFjdGlvbiwgbGlzdGVuZXIpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA0ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogVGhlIGhpZ2hsaWdodGVyIGNhbiBoaWdobGlnaHQvdW5oaWdobGlnaHQgYSBub2RlLCBhbmRcXG5cXHQgKiBhbmltYXRlIHRoZSB2aXNpYmlsaXR5IG9mIGEgY29udGV4dCBtZW51LlxcblxcdCAqIEBjb25zdHJ1Y3RvciBIaWdobGlnaHRlclxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIEhpZ2hsaWdodGVyICgpIHtcXG5cXHQgIHRoaXMubG9ja2VkID0gZmFsc2U7XFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEhpZ2h0bGlnaHQgZ2l2ZW4gbm9kZSBhbmQgaXRzIGNoaWxkc1xcblxcdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxcblxcdCAqL1xcblxcdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5oaWdobGlnaHQgPSBmdW5jdGlvbiAobm9kZSkge1xcblxcdCAgaWYgKHRoaXMubG9ja2VkKSB7XFxuXFx0ICAgIHJldHVybjtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLm5vZGUgIT0gbm9kZSkge1xcblxcdCAgICAvLyB1bmhpZ2hsaWdodCBjdXJyZW50IG5vZGVcXG5cXHQgICAgaWYgKHRoaXMubm9kZSkge1xcblxcdCAgICAgIHRoaXMubm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGhpZ2hsaWdodCBuZXcgbm9kZVxcblxcdCAgICB0aGlzLm5vZGUgPSBub2RlO1xcblxcdCAgICB0aGlzLm5vZGUuc2V0SGlnaGxpZ2h0KHRydWUpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gY2FuY2VsIGFueSBjdXJyZW50IHRpbWVvdXRcXG5cXHQgIHRoaXMuX2NhbmNlbFVuaGlnaGxpZ2h0KCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVbmhpZ2hsaWdodCBjdXJyZW50bHkgaGlnaGxpZ2h0ZWQgbm9kZS5cXG5cXHQgKiBXaWxsIGJlIGRvbmUgYWZ0ZXIgYSBkZWxheVxcblxcdCAqL1xcblxcdEhpZ2hsaWdodGVyLnByb3RvdHlwZS51bmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIGlmICh0aGlzLmxvY2tlZCkge1xcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgbWUgPSB0aGlzO1xcblxcdCAgaWYgKHRoaXMubm9kZSkge1xcblxcdCAgICB0aGlzLl9jYW5jZWxVbmhpZ2hsaWdodCgpO1xcblxcblxcdCAgICAvLyBkbyB0aGUgdW5oaWdobGlnaHRpbmcgYWZ0ZXIgYSBzbWFsbCBkZWxheSwgdG8gcHJldmVudCByZS1oaWdobGlnaHRpbmdcXG5cXHQgICAgLy8gdGhlIHNhbWUgbm9kZSB3aGVuIG1vdmluZyBmcm9tIHRoZSBkcmFnLWljb24gdG8gdGhlIGNvbnRleHRtZW51LWljb25cXG5cXHQgICAgLy8gb3IgdmljZSB2ZXJzYS5cXG5cXHQgICAgdGhpcy51bmhpZ2hsaWdodFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgbWUubm9kZS5zZXRIaWdobGlnaHQoZmFsc2UpO1xcblxcdCAgICAgIG1lLm5vZGUgPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgbWUudW5oaWdobGlnaHRUaW1lciA9IHVuZGVmaW5lZDtcXG5cXHQgICAgfSwgMCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDYW5jZWwgYW4gdW5oaWdobGlnaHQgYWN0aW9uIChpZiBiZWZvcmUgdGhlIHRpbWVvdXQgb2YgdGhlIHVuaGlnaGxpZ2h0IGFjdGlvbilcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5fY2FuY2VsVW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy51bmhpZ2hsaWdodFRpbWVyKSB7XFxuXFx0ICAgIGNsZWFyVGltZW91dCh0aGlzLnVuaGlnaGxpZ2h0VGltZXIpO1xcblxcdCAgICB0aGlzLnVuaGlnaGxpZ2h0VGltZXIgPSB1bmRlZmluZWQ7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBMb2NrIGhpZ2hsaWdodGluZyBvciB1bmhpZ2hsaWdodGluZyBub2Rlcy5cXG5cXHQgKiBtZXRob2RzIGhpZ2hsaWdodCBhbmQgdW5oaWdobGlnaHQgZG8gbm90IHdvcmsgd2hpbGUgbG9ja2VkLlxcblxcdCAqL1xcblxcdEhpZ2hsaWdodGVyLnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdGhpcy5sb2NrZWQgPSB0cnVlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVW5sb2NrIGhpZ2hsaWdodGluZyBvciB1bmhpZ2hsaWdodGluZyBub2Rlc1xcblxcdCAqL1xcblxcdEhpZ2hsaWdodGVyLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xcblxcdH07XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBIaWdobGlnaHRlcjtcXG5cXG5cXG4vKioqLyB9LFxcbi8qIDUgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGNvbnN0cnVjdG9yIEhpc3RvcnlcXG5cXHQgKiBTdG9yZSBhY3Rpb24gaGlzdG9yeSwgZW5hYmxlcyB1bmRvIGFuZCByZWRvXFxuXFx0ICogQHBhcmFtIHtKU09ORWRpdG9yfSBlZGl0b3JcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBIaXN0b3J5IChlZGl0b3IpIHtcXG5cXHQgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xcblxcdCAgdGhpcy5jbGVhcigpO1xcblxcblxcdCAgLy8gbWFwIHdpdGggYWxsIHN1cHBvcnRlZCBhY3Rpb25zXFxuXFx0ICB0aGlzLmFjdGlvbnMgPSB7XFxuXFx0ICAgICdlZGl0RmllbGQnOiB7XFxuXFx0ICAgICAgJ3VuZG8nOiBmdW5jdGlvbiAocGFyYW1zKSB7XFxuXFx0ICAgICAgICBwYXJhbXMubm9kZS51cGRhdGVGaWVsZChwYXJhbXMub2xkVmFsdWUpO1xcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgJ3JlZG8nOiBmdW5jdGlvbiAocGFyYW1zKSB7XFxuXFx0ICAgICAgICBwYXJhbXMubm9kZS51cGRhdGVGaWVsZChwYXJhbXMubmV3VmFsdWUpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgJ2VkaXRWYWx1ZSc6IHtcXG5cXHQgICAgICAndW5kbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5ub2RlLnVwZGF0ZVZhbHVlKHBhcmFtcy5vbGRWYWx1ZSk7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICAncmVkbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5ub2RlLnVwZGF0ZVZhbHVlKHBhcmFtcy5uZXdWYWx1ZSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICAnYXBwZW5kTm9kZSc6IHtcXG5cXHQgICAgICAndW5kbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5wYXJlbnQucmVtb3ZlQ2hpbGQocGFyYW1zLm5vZGUpO1xcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgJ3JlZG8nOiBmdW5jdGlvbiAocGFyYW1zKSB7XFxuXFx0ICAgICAgICBwYXJhbXMucGFyZW50LmFwcGVuZENoaWxkKHBhcmFtcy5ub2RlKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgICdpbnNlcnRCZWZvcmVOb2RlJzoge1xcblxcdCAgICAgICd1bmRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgcGFyYW1zLnBhcmVudC5yZW1vdmVDaGlsZChwYXJhbXMubm9kZSk7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICAncmVkbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHBhcmFtcy5ub2RlLCBwYXJhbXMuYmVmb3JlTm9kZSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICAnaW5zZXJ0QWZ0ZXJOb2RlJzoge1xcblxcdCAgICAgICd1bmRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgcGFyYW1zLnBhcmVudC5yZW1vdmVDaGlsZChwYXJhbXMubm9kZSk7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICAncmVkbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5wYXJlbnQuaW5zZXJ0QWZ0ZXIocGFyYW1zLm5vZGUsIHBhcmFtcy5hZnRlck5vZGUpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgJ3JlbW92ZU5vZGUnOiB7XFxuXFx0ICAgICAgJ3VuZG8nOiBmdW5jdGlvbiAocGFyYW1zKSB7XFxuXFx0ICAgICAgICB2YXIgcGFyZW50ID0gcGFyYW1zLnBhcmVudDtcXG5cXHQgICAgICAgIHZhciBiZWZvcmVOb2RlID0gcGFyZW50LmNoaWxkc1twYXJhbXMuaW5kZXhdIHx8IHBhcmVudC5hcHBlbmQ7XFxuXFx0ICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHBhcmFtcy5ub2RlLCBiZWZvcmVOb2RlKTtcXG5cXHQgICAgICB9LFxcblxcdCAgICAgICdyZWRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgcGFyYW1zLnBhcmVudC5yZW1vdmVDaGlsZChwYXJhbXMubm9kZSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICAnZHVwbGljYXRlTm9kZSc6IHtcXG5cXHQgICAgICAndW5kbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5wYXJlbnQucmVtb3ZlQ2hpbGQocGFyYW1zLmNsb25lKTtcXG5cXHQgICAgICB9LFxcblxcdCAgICAgICdyZWRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgcGFyYW1zLnBhcmVudC5pbnNlcnRBZnRlcihwYXJhbXMuY2xvbmUsIHBhcmFtcy5ub2RlKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgICdjaGFuZ2VUeXBlJzoge1xcblxcdCAgICAgICd1bmRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgcGFyYW1zLm5vZGUuY2hhbmdlVHlwZShwYXJhbXMub2xkVHlwZSk7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICAncmVkbyc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG5cXHQgICAgICAgIHBhcmFtcy5ub2RlLmNoYW5nZVR5cGUocGFyYW1zLm5ld1R5cGUpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgJ21vdmVOb2RlJzoge1xcblxcdCAgICAgICd1bmRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgcGFyYW1zLnN0YXJ0UGFyZW50Lm1vdmVUbyhwYXJhbXMubm9kZSwgcGFyYW1zLnN0YXJ0SW5kZXgpO1xcblxcdCAgICAgIH0sXFxuXFx0ICAgICAgJ3JlZG8nOiBmdW5jdGlvbiAocGFyYW1zKSB7XFxuXFx0ICAgICAgICBwYXJhbXMuZW5kUGFyZW50Lm1vdmVUbyhwYXJhbXMubm9kZSwgcGFyYW1zLmVuZEluZGV4KTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgICdzb3J0Jzoge1xcblxcdCAgICAgICd1bmRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgdmFyIG5vZGUgPSBwYXJhbXMubm9kZTtcXG5cXHQgICAgICAgIG5vZGUuaGlkZUNoaWxkcygpO1xcblxcdCAgICAgICAgbm9kZS5zb3J0ID0gcGFyYW1zLm9sZFNvcnQ7XFxuXFx0ICAgICAgICBub2RlLmNoaWxkcyA9IHBhcmFtcy5vbGRDaGlsZHM7XFxuXFx0ICAgICAgICBub2RlLnNob3dDaGlsZHMoKTtcXG5cXHQgICAgICB9LFxcblxcdCAgICAgICdyZWRvJzogZnVuY3Rpb24gKHBhcmFtcykge1xcblxcdCAgICAgICAgdmFyIG5vZGUgPSBwYXJhbXMubm9kZTtcXG5cXHQgICAgICAgIG5vZGUuaGlkZUNoaWxkcygpO1xcblxcdCAgICAgICAgbm9kZS5zb3J0ID0gcGFyYW1zLm5ld1NvcnQ7XFxuXFx0ICAgICAgICBub2RlLmNoaWxkcyA9IHBhcmFtcy5uZXdDaGlsZHM7XFxuXFx0ICAgICAgICBub2RlLnNob3dDaGlsZHMoKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gVE9ETzogcmVzdG9yZSB0aGUgb3JpZ2luYWwgY2FyZXQgcG9zaXRpb24gYW5kIHNlbGVjdGlvbiB3aXRoIGVhY2ggdW5kb1xcblxcdCAgICAvLyBUT0RPOiBpbXBsZW1lbnQgaGlzdG9yeSBmb3IgYWN0aW9ucyBcXFwiZXhwYW5kXFxcIiwgXFxcImNvbGxhcHNlXFxcIiwgXFxcInNjcm9sbFxcXCIsIFxcXCJzZXREb2N1bWVudFxcXCJcXG5cXHQgIH07XFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIFRoZSBtZXRob2Qgb25DaGFuZ2UgaXMgZXhlY3V0ZWQgd2hlbiB0aGUgSGlzdG9yeSBpcyBjaGFuZ2VkLCBhbmQgY2FuXFxuXFx0ICogYmUgb3ZlcmxvYWRlZC5cXG5cXHQgKi9cXG5cXHRIaXN0b3J5LnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHt9O1xcblxcblxcdC8qKlxcblxcdCAqIEFkZCBhIG5ldyBhY3Rpb24gdG8gdGhlIGhpc3RvcnlcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uICBUaGUgZXhlY3V0ZWQgYWN0aW9uLiBBdmFpbGFibGUgYWN0aW9uczogXFxcImVkaXRGaWVsZFxcXCIsXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgXFxcImVkaXRWYWx1ZVxcXCIsIFxcXCJjaGFuZ2VUeXBlXFxcIiwgXFxcImFwcGVuZE5vZGVcXFwiLFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJyZW1vdmVOb2RlXFxcIiwgXFxcImR1cGxpY2F0ZU5vZGVcXFwiLCBcXFwibW92ZU5vZGVcXFwiXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAgT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBkZXNjcmliaW5nIHRoZSBjaGFuZ2UuXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHBhcmFtZXRlcnMgaW4gcGFyYW1zIGRlcGVuZCBvbiB0aGUgYWN0aW9uIChmb3JcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlIGZvciBcXFwiZWRpdFZhbHVlXFxcIiB0aGUgTm9kZSwgb2xkIHZhbHVlLCBhbmQgbmV3XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgYXJlIHByb3ZpZGVkKS4gcGFyYW1zIGNvbnRhaW5zIGFsbCBpbmZvcm1hdGlvblxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRlZCB0byB1bmRvIG9yIHJlZG8gdGhlIGFjdGlvbi5cXG5cXHQgKi9cXG5cXHRIaXN0b3J5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWN0aW9uLCBwYXJhbXMpIHtcXG5cXHQgIHRoaXMuaW5kZXgrKztcXG5cXHQgIHRoaXMuaGlzdG9yeVt0aGlzLmluZGV4XSA9IHtcXG5cXHQgICAgJ2FjdGlvbic6IGFjdGlvbixcXG5cXHQgICAgJ3BhcmFtcyc6IHBhcmFtcyxcXG5cXHQgICAgJ3RpbWVzdGFtcCc6IG5ldyBEYXRlKClcXG5cXHQgIH07XFxuXFxuXFx0ICAvLyByZW1vdmUgcmVkbyBhY3Rpb25zIHdoaWNoIGFyZSBpbnZhbGlkIG5vd1xcblxcdCAgaWYgKHRoaXMuaW5kZXggPCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSkge1xcblxcdCAgICB0aGlzLmhpc3Rvcnkuc3BsaWNlKHRoaXMuaW5kZXggKyAxLCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gdGhpcy5pbmRleCAtIDEpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gZmlyZSBvbmNoYW5nZSBldmVudFxcblxcdCAgdGhpcy5vbkNoYW5nZSgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2xlYXIgaGlzdG9yeVxcblxcdCAqL1xcblxcdEhpc3RvcnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdGhpcy5oaXN0b3J5ID0gW107XFxuXFx0ICB0aGlzLmluZGV4ID0gLTE7XFxuXFxuXFx0ICAvLyBmaXJlIG9uY2hhbmdlIGV2ZW50XFxuXFx0ICB0aGlzLm9uQ2hhbmdlKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGVjayBpZiB0aGVyZSBpcyBhbiBhY3Rpb24gYXZhaWxhYmxlIGZvciB1bmRvXFxuXFx0ICogQHJldHVybiB7Qm9vbGVhbn0gY2FuVW5kb1xcblxcdCAqL1xcblxcdEhpc3RvcnkucHJvdG90eXBlLmNhblVuZG8gPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICByZXR1cm4gKHRoaXMuaW5kZXggPj0gMCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGVjayBpZiB0aGVyZSBpcyBhbiBhY3Rpb24gYXZhaWxhYmxlIGZvciByZWRvXFxuXFx0ICogQHJldHVybiB7Qm9vbGVhbn0gY2FuUmVkb1xcblxcdCAqL1xcblxcdEhpc3RvcnkucHJvdG90eXBlLmNhblJlZG8gPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICByZXR1cm4gKHRoaXMuaW5kZXggPCB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVbmRvIHRoZSBsYXN0IGFjdGlvblxcblxcdCAqL1xcblxcdEhpc3RvcnkucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy5jYW5VbmRvKCkpIHtcXG5cXHQgICAgdmFyIG9iaiA9IHRoaXMuaGlzdG9yeVt0aGlzLmluZGV4XTtcXG5cXHQgICAgaWYgKG9iaikge1xcblxcdCAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbb2JqLmFjdGlvbl07XFxuXFx0ICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udW5kbykge1xcblxcdCAgICAgICAgYWN0aW9uLnVuZG8ob2JqLnBhcmFtcyk7XFxuXFx0ICAgICAgICBpZiAob2JqLnBhcmFtcy5vbGRTZWxlY3Rpb24pIHtcXG5cXHQgICAgICAgICAgdGhpcy5lZGl0b3Iuc2V0U2VsZWN0aW9uKG9iai5wYXJhbXMub2xkU2VsZWN0aW9uKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICB1dGlsLmxvZygnRXJyb3I6IHVua25vd24gYWN0aW9uIFxcXCInICsgb2JqLmFjdGlvbiArICdcXFwiJyk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHRoaXMuaW5kZXgtLTtcXG5cXG5cXHQgICAgLy8gZmlyZSBvbmNoYW5nZSBldmVudFxcblxcdCAgICB0aGlzLm9uQ2hhbmdlKCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWRvIHRoZSBsYXN0IGFjdGlvblxcblxcdCAqL1xcblxcdEhpc3RvcnkucHJvdG90eXBlLnJlZG8gPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICBpZiAodGhpcy5jYW5SZWRvKCkpIHtcXG5cXHQgICAgdGhpcy5pbmRleCsrO1xcblxcblxcdCAgICB2YXIgb2JqID0gdGhpcy5oaXN0b3J5W3RoaXMuaW5kZXhdO1xcblxcdCAgICBpZiAob2JqKSB7XFxuXFx0ICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uc1tvYmouYWN0aW9uXTtcXG5cXHQgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi5yZWRvKSB7XFxuXFx0ICAgICAgICBhY3Rpb24ucmVkbyhvYmoucGFyYW1zKTtcXG5cXHQgICAgICAgIGlmIChvYmoucGFyYW1zLm5ld1NlbGVjdGlvbikge1xcblxcdCAgICAgICAgICB0aGlzLmVkaXRvci5zZXRTZWxlY3Rpb24ob2JqLnBhcmFtcy5uZXdTZWxlY3Rpb24pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIHtcXG5cXHQgICAgICAgIHV0aWwubG9nKCdFcnJvcjogdW5rbm93biBhY3Rpb24gXFxcIicgKyBvYmouYWN0aW9uICsgJ1xcXCInKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gZmlyZSBvbmNoYW5nZSBldmVudFxcblxcdCAgICB0aGlzLm9uQ2hhbmdlKCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IEhpc3Rvcnk7XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA2ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGNvbnN0cnVjdG9yIFNlYXJjaEJveFxcblxcdCAqIENyZWF0ZSBhIHNlYXJjaCBib3ggaW4gZ2l2ZW4gSFRNTCBjb250YWluZXJcXG5cXHQgKiBAcGFyYW0ge0pTT05FZGl0b3J9IGVkaXRvciAgICBUaGUgSlNPTiBFZGl0b3IgdG8gYXR0YWNoIHRvXFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICAgICAgICAgICAgICBIVE1MIGNvbnRhaW5lciBlbGVtZW50IG9mIHdoZXJlIHRvXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGUgdGhlIHNlYXJjaCBib3hcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBTZWFyY2hCb3ggKGVkaXRvciwgY29udGFpbmVyKSB7XFxuXFx0ICB2YXIgc2VhcmNoQm94ID0gdGhpcztcXG5cXG5cXHQgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xcblxcdCAgdGhpcy50aW1lb3V0ID0gdW5kZWZpbmVkO1xcblxcdCAgdGhpcy5kZWxheSA9IDIwMDsgLy8gbXNcXG5cXHQgIHRoaXMubGFzdFRleHQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0ICB0aGlzLmRvbSA9IHt9O1xcblxcdCAgdGhpcy5kb20uY29udGFpbmVyID0gY29udGFpbmVyO1xcblxcblxcdCAgdmFyIHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcXG5cXHQgIHRoaXMuZG9tLnRhYmxlID0gdGFibGU7XFxuXFx0ICB0YWJsZS5jbGFzc05hbWUgPSAnc2VhcmNoJztcXG5cXHQgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0YWJsZSk7XFxuXFx0ICB2YXIgdGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xcblxcdCAgdGhpcy5kb20udGJvZHkgPSB0Ym9keTtcXG5cXHQgIHRhYmxlLmFwcGVuZENoaWxkKHRib2R5KTtcXG5cXHQgIHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XFxuXFx0ICB0Ym9keS5hcHBlbmRDaGlsZCh0cik7XFxuXFxuXFx0ICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xcblxcdCAgdHIuYXBwZW5kQ2hpbGQodGQpO1xcblxcdCAgdmFyIHJlc3VsdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG5cXHQgIHRoaXMuZG9tLnJlc3VsdHMgPSByZXN1bHRzO1xcblxcdCAgcmVzdWx0cy5jbGFzc05hbWUgPSAncmVzdWx0cyc7XFxuXFx0ICB0ZC5hcHBlbmRDaGlsZChyZXN1bHRzKTtcXG5cXG5cXHQgIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkKTtcXG5cXHQgIHZhciBkaXZJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgdGhpcy5kb20uaW5wdXQgPSBkaXZJbnB1dDtcXG5cXHQgIGRpdklucHV0LmNsYXNzTmFtZSA9ICdmcmFtZSc7XFxuXFx0ICBkaXZJbnB1dC50aXRsZSA9ICdTZWFyY2ggZmllbGRzIGFuZCB2YWx1ZXMnO1xcblxcdCAgdGQuYXBwZW5kQ2hpbGQoZGl2SW5wdXQpO1xcblxcblxcdCAgLy8gdGFibGUgdG8gY29udGFpbiB0aGUgdGV4dCBpbnB1dCBhbmQgc2VhcmNoIGJ1dHRvblxcblxcdCAgdmFyIHRhYmxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xcblxcdCAgZGl2SW5wdXQuYXBwZW5kQ2hpbGQodGFibGVJbnB1dCk7XFxuXFx0ICB2YXIgdGJvZHlTZWFyY2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xcblxcdCAgdGFibGVJbnB1dC5hcHBlbmRDaGlsZCh0Ym9keVNlYXJjaCk7XFxuXFx0ICB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XFxuXFx0ICB0Ym9keVNlYXJjaC5hcHBlbmRDaGlsZCh0cik7XFxuXFxuXFx0ICB2YXIgcmVmcmVzaFNlYXJjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xcblxcdCAgcmVmcmVzaFNlYXJjaC5jbGFzc05hbWUgPSAncmVmcmVzaCc7XFxuXFx0ICB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICB0ZC5hcHBlbmRDaGlsZChyZWZyZXNoU2VhcmNoKTtcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkKTtcXG5cXG5cXHQgIHZhciBzZWFyY2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xcblxcdCAgdGhpcy5kb20uc2VhcmNoID0gc2VhcmNoO1xcblxcdCAgc2VhcmNoLm9uaW5wdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgICAgc2VhcmNoQm94Ll9vbkRlbGF5ZWRTZWFyY2goZXZlbnQpO1xcblxcdCAgfTtcXG5cXHQgIHNlYXJjaC5vbmNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkgeyAvLyBGb3IgSUUgOVxcblxcdCAgICBzZWFyY2hCb3guX29uU2VhcmNoKGV2ZW50KTtcXG5cXHQgIH07XFxuXFx0ICBzZWFyY2gub25rZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICAgIHNlYXJjaEJveC5fb25LZXlEb3duKGV2ZW50KTtcXG5cXHQgIH07XFxuXFx0ICBzZWFyY2gub25rZXl1cCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgICBzZWFyY2hCb3guX29uS2V5VXAoZXZlbnQpO1xcblxcdCAgfTtcXG5cXHQgIHJlZnJlc2hTZWFyY2gub25jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgICBzZWFyY2guc2VsZWN0KCk7XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gVE9ETzogRVNDIGluIEZGIHJlc3RvcmVzIHRoZSBsYXN0IGlucHV0LCBpcyBhIEZGIGJ1ZywgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTk4ODE5XFxuXFx0ICB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICB0ZC5hcHBlbmRDaGlsZChzZWFyY2gpO1xcblxcdCAgdHIuYXBwZW5kQ2hpbGQodGQpO1xcblxcblxcdCAgdmFyIHNlYXJjaE5leHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgIHNlYXJjaE5leHQudGl0bGUgPSAnTmV4dCByZXN1bHQgKEVudGVyKSc7XFxuXFx0ICBzZWFyY2hOZXh0LmNsYXNzTmFtZSA9ICduZXh0JztcXG5cXHQgIHNlYXJjaE5leHQub25jbGljayA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgc2VhcmNoQm94Lm5leHQoKTtcXG5cXHQgIH07XFxuXFx0ICB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICB0ZC5hcHBlbmRDaGlsZChzZWFyY2hOZXh0KTtcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkKTtcXG5cXG5cXHQgIHZhciBzZWFyY2hQcmV2aW91cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xcblxcdCAgc2VhcmNoUHJldmlvdXMudGl0bGUgPSAnUHJldmlvdXMgcmVzdWx0IChTaGlmdCtFbnRlciknO1xcblxcdCAgc2VhcmNoUHJldmlvdXMuY2xhc3NOYW1lID0gJ3ByZXZpb3VzJztcXG5cXHQgIHNlYXJjaFByZXZpb3VzLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgIHNlYXJjaEJveC5wcmV2aW91cygpO1xcblxcdCAgfTtcXG5cXHQgIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcXG5cXHQgIHRkLmFwcGVuZENoaWxkKHNlYXJjaFByZXZpb3VzKTtcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkKTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogR28gdG8gdGhlIG5leHQgc2VhcmNoIHJlc3VsdFxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvY3VzXSAgIElmIHRydWUsIGZvY3VzIHdpbGwgYmUgc2V0IHRvIHRoZSBuZXh0IHJlc3VsdFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzIGlzIGZhbHNlIGJ5IGRlZmF1bHQuXFxuXFx0ICovXFxuXFx0U2VhcmNoQm94LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oZm9jdXMpIHtcXG5cXHQgIGlmICh0aGlzLnJlc3VsdHMgIT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgIHZhciBpbmRleCA9ICh0aGlzLnJlc3VsdEluZGV4ICE9IHVuZGVmaW5lZCkgPyB0aGlzLnJlc3VsdEluZGV4ICsgMSA6IDA7XFxuXFx0ICAgIGlmIChpbmRleCA+IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XFxuXFx0ICAgICAgaW5kZXggPSAwO1xcblxcdCAgICB9XFxuXFx0ICAgIHRoaXMuX3NldEFjdGl2ZVJlc3VsdChpbmRleCwgZm9jdXMpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR28gdG8gdGhlIHByZXZvdXMgc2VhcmNoIHJlc3VsdFxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvY3VzXSAgIElmIHRydWUsIGZvY3VzIHdpbGwgYmUgc2V0IHRvIHRoZSBuZXh0IHJlc3VsdFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzIGlzIGZhbHNlIGJ5IGRlZmF1bHQuXFxuXFx0ICovXFxuXFx0U2VhcmNoQm94LnByb3RvdHlwZS5wcmV2aW91cyA9IGZ1bmN0aW9uKGZvY3VzKSB7XFxuXFx0ICBpZiAodGhpcy5yZXN1bHRzICE9IHVuZGVmaW5lZCkge1xcblxcdCAgICB2YXIgbWF4ID0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDE7XFxuXFx0ICAgIHZhciBpbmRleCA9ICh0aGlzLnJlc3VsdEluZGV4ICE9IHVuZGVmaW5lZCkgPyB0aGlzLnJlc3VsdEluZGV4IC0gMSA6IG1heDtcXG5cXHQgICAgaWYgKGluZGV4IDwgMCkge1xcblxcdCAgICAgIGluZGV4ID0gbWF4O1xcblxcdCAgICB9XFxuXFx0ICAgIHRoaXMuX3NldEFjdGl2ZVJlc3VsdChpbmRleCwgZm9jdXMpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2V0IG5ldyB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgYWN0aXZlIHJlc3VsdFxcblxcdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvY3VzXSAgIElmIHRydWUsIGZvY3VzIHdpbGwgYmUgc2V0IHRvIHRoZSBuZXh0IHJlc3VsdC5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1cyBpcyBmYWxzZSBieSBkZWZhdWx0LlxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0U2VhcmNoQm94LnByb3RvdHlwZS5fc2V0QWN0aXZlUmVzdWx0ID0gZnVuY3Rpb24oaW5kZXgsIGZvY3VzKSB7XFxuXFx0ICAvLyBkZS1hY3RpdmF0ZSBjdXJyZW50IGFjdGl2ZSByZXN1bHRcXG5cXHQgIGlmICh0aGlzLmFjdGl2ZVJlc3VsdCkge1xcblxcdCAgICB2YXIgcHJldk5vZGUgPSB0aGlzLmFjdGl2ZVJlc3VsdC5ub2RlO1xcblxcdCAgICB2YXIgcHJldkVsZW0gPSB0aGlzLmFjdGl2ZVJlc3VsdC5lbGVtO1xcblxcdCAgICBpZiAocHJldkVsZW0gPT0gJ2ZpZWxkJykge1xcblxcdCAgICAgIGRlbGV0ZSBwcmV2Tm9kZS5zZWFyY2hGaWVsZEFjdGl2ZTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICBkZWxldGUgcHJldk5vZGUuc2VhcmNoVmFsdWVBY3RpdmU7XFxuXFx0ICAgIH1cXG5cXHQgICAgcHJldk5vZGUudXBkYXRlRG9tKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoIXRoaXMucmVzdWx0cyB8fCAhdGhpcy5yZXN1bHRzW2luZGV4XSkge1xcblxcdCAgICAvLyBvdXQgb2YgcmFuZ2UsIHNldCB0byB1bmRlZmluZWRcXG5cXHQgICAgdGhpcy5yZXN1bHRJbmRleCA9IHVuZGVmaW5lZDtcXG5cXHQgICAgdGhpcy5hY3RpdmVSZXN1bHQgPSB1bmRlZmluZWQ7XFxuXFx0ICAgIHJldHVybjtcXG5cXHQgIH1cXG5cXG5cXHQgIHRoaXMucmVzdWx0SW5kZXggPSBpbmRleDtcXG5cXG5cXHQgIC8vIHNldCBuZXcgbm9kZSBhY3RpdmVcXG5cXHQgIHZhciBub2RlID0gdGhpcy5yZXN1bHRzW3RoaXMucmVzdWx0SW5kZXhdLm5vZGU7XFxuXFx0ICB2YXIgZWxlbSA9IHRoaXMucmVzdWx0c1t0aGlzLnJlc3VsdEluZGV4XS5lbGVtO1xcblxcdCAgaWYgKGVsZW0gPT0gJ2ZpZWxkJykge1xcblxcdCAgICBub2RlLnNlYXJjaEZpZWxkQWN0aXZlID0gdHJ1ZTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICBub2RlLnNlYXJjaFZhbHVlQWN0aXZlID0gdHJ1ZTtcXG5cXHQgIH1cXG5cXHQgIHRoaXMuYWN0aXZlUmVzdWx0ID0gdGhpcy5yZXN1bHRzW3RoaXMucmVzdWx0SW5kZXhdO1xcblxcdCAgbm9kZS51cGRhdGVEb20oKTtcXG5cXG5cXHQgIC8vIFRPRE86IG5vdCBzbyBuaWNlIHRoYXQgdGhlIGZvY3VzIGlzIG9ubHkgc2V0IGFmdGVyIHRoZSBhbmltYXRpb24gaXMgZmluaXNoZWRcXG5cXHQgIG5vZGUuc2Nyb2xsVG8oZnVuY3Rpb24gKCkge1xcblxcdCAgICBpZiAoZm9jdXMpIHtcXG5cXHQgICAgICBub2RlLmZvY3VzKGVsZW0pO1xcblxcdCAgICB9XFxuXFx0ICB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENhbmNlbCBhbnkgcnVubmluZyBvbkRlbGF5ZWRTZWFyY2guXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHRTZWFyY2hCb3gucHJvdG90eXBlLl9jbGVhckRlbGF5ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICBpZiAodGhpcy50aW1lb3V0ICE9IHVuZGVmaW5lZCkge1xcblxcdCAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcXG5cXHQgICAgZGVsZXRlIHRoaXMudGltZW91dDtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFN0YXJ0IGEgdGltZXIgdG8gZXhlY3V0ZSBhIHNlYXJjaCBhZnRlciBhIHNob3J0IGRlbGF5LlxcblxcdCAqIFVzZWQgZm9yIHJlZHVjaW5nIHRoZSBudW1iZXIgb2Ygc2VhcmNoZXMgd2hpbGUgdHlwaW5nLlxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHRTZWFyY2hCb3gucHJvdG90eXBlLl9vbkRlbGF5ZWRTZWFyY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgIC8vIGV4ZWN1dGUgdGhlIHNlYXJjaCBhZnRlciBhIHNob3J0IGRlbGF5IChyZWR1Y2VzIHRoZSBudW1iZXIgb2ZcXG5cXHQgIC8vIHNlYXJjaCBhY3Rpb25zIHdoaWxlIHR5cGluZyBpbiB0aGUgc2VhcmNoIHRleHQgYm94KVxcblxcdCAgdGhpcy5fY2xlYXJEZWxheSgpO1xcblxcdCAgdmFyIHNlYXJjaEJveCA9IHRoaXM7XFxuXFx0ICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgICAgICAgc2VhcmNoQm94Ll9vblNlYXJjaChldmVudCk7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICB0aGlzLmRlbGF5KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZSBvblNlYXJjaCBldmVudFxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XFxuXFx0ICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VTZWFyY2hdICBJZiB0cnVlLCBzZWFyY2ggd2lsbCBiZSBleGVjdXRlZCBhZ2FpbiBldmVuXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSBzZWFyY2ggdGV4dCBpcyBub3QgY2hhbmdlZC5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQgaXMgZmFsc2UuXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHRTZWFyY2hCb3gucHJvdG90eXBlLl9vblNlYXJjaCA9IGZ1bmN0aW9uIChldmVudCwgZm9yY2VTZWFyY2gpIHtcXG5cXHQgIHRoaXMuX2NsZWFyRGVsYXkoKTtcXG5cXG5cXHQgIHZhciB2YWx1ZSA9IHRoaXMuZG9tLnNlYXJjaC52YWx1ZTtcXG5cXHQgIHZhciB0ZXh0ID0gKHZhbHVlLmxlbmd0aCA+IDApID8gdmFsdWUgOiB1bmRlZmluZWQ7XFxuXFx0ICBpZiAodGV4dCAhPSB0aGlzLmxhc3RUZXh0IHx8IGZvcmNlU2VhcmNoKSB7XFxuXFx0ICAgIC8vIG9ubHkgc2VhcmNoIGFnYWluIHdoZW4gY2hhbmdlZFxcblxcdCAgICB0aGlzLmxhc3RUZXh0ID0gdGV4dDtcXG5cXHQgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5lZGl0b3Iuc2VhcmNoKHRleHQpO1xcblxcdCAgICB0aGlzLl9zZXRBY3RpdmVSZXN1bHQodW5kZWZpbmVkKTtcXG5cXG5cXHQgICAgLy8gZGlzcGxheSBzZWFyY2ggcmVzdWx0c1xcblxcdCAgICBpZiAodGV4dCAhPSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICB2YXIgcmVzdWx0Q291bnQgPSB0aGlzLnJlc3VsdHMubGVuZ3RoO1xcblxcdCAgICAgIHN3aXRjaCAocmVzdWx0Q291bnQpIHtcXG5cXHQgICAgICAgIGNhc2UgMDogdGhpcy5kb20ucmVzdWx0cy5pbm5lckhUTUwgPSAnbm8mbmJzcDtyZXN1bHRzJzsgYnJlYWs7XFxuXFx0ICAgICAgICBjYXNlIDE6IHRoaXMuZG9tLnJlc3VsdHMuaW5uZXJIVE1MID0gJzEmbmJzcDtyZXN1bHQnOyBicmVhaztcXG5cXHQgICAgICAgIGRlZmF1bHQ6IHRoaXMuZG9tLnJlc3VsdHMuaW5uZXJIVE1MID0gcmVzdWx0Q291bnQgKyAnJm5ic3A7cmVzdWx0cyc7IGJyZWFrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICB0aGlzLmRvbS5yZXN1bHRzLmlubmVySFRNTCA9ICcnO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBIYW5kbGUgb25LZXlEb3duIGV2ZW50IGluIHRoZSBpbnB1dCBib3hcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0U2VhcmNoQm94LnByb3RvdHlwZS5fb25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICB2YXIga2V5bnVtID0gZXZlbnQud2hpY2g7XFxuXFx0ICBpZiAoa2V5bnVtID09IDI3KSB7IC8vIEVTQ1xcblxcdCAgICB0aGlzLmRvbS5zZWFyY2gudmFsdWUgPSAnJzsgIC8vIGNsZWFyIHNlYXJjaFxcblxcdCAgICB0aGlzLl9vblNlYXJjaChldmVudCk7XFxuXFx0ICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAoa2V5bnVtID09IDEzKSB7IC8vIEVudGVyXFxuXFx0ICAgIGlmIChldmVudC5jdHJsS2V5KSB7XFxuXFx0ICAgICAgLy8gZm9yY2UgdG8gc2VhcmNoIGFnYWluXFxuXFx0ICAgICAgdGhpcy5fb25TZWFyY2goZXZlbnQsIHRydWUpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XFxuXFx0ICAgICAgLy8gbW92ZSB0byB0aGUgcHJldmlvdXMgc2VhcmNoIHJlc3VsdFxcblxcdCAgICAgIHRoaXMucHJldmlvdXMoKTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IHNlYXJjaCByZXN1bHRcXG5cXHQgICAgICB0aGlzLm5leHQoKTtcXG5cXHQgICAgfVxcblxcdCAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZSBvbktleVVwIGV2ZW50IGluIHRoZSBpbnB1dCBib3hcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0U2VhcmNoQm94LnByb3RvdHlwZS5fb25LZXlVcCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgdmFyIGtleW51bSA9IGV2ZW50LmtleUNvZGU7XFxuXFx0ICBpZiAoa2V5bnVtICE9IDI3ICYmIGtleW51bSAhPSAxMykgeyAvLyAhc2hvdyBhbmQgIUVudGVyXFxuXFx0ICAgIHRoaXMuX29uRGVsYXllZFNlYXJjaChldmVudCk7ICAgLy8gRm9yIElFIDlcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdG1vZHVsZS5leHBvcnRzID0gU2VhcmNoQm94O1xcblxcblxcbi8qKiovIH0sXFxuLyogNyAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciBDb250ZXh0TWVudSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xcblxcdHZhciBhcHBlbmROb2RlRmFjdG9yeSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xcblxcdHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAY29uc3RydWN0b3IgTm9kZVxcblxcdCAqIENyZWF0ZSBhIG5ldyBOb2RlXFxuXFx0ICogQHBhcmFtIHtUcmVlRWRpdG9yfSBlZGl0b3JcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gQ2FuIGNvbnRhaW4gcGFyYW1ldGVyczpcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gIGZpZWxkXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHtib29sZWFufSBmaWVsZEVkaXRhYmxlXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHsqfSAgICAgICB2YWx1ZVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSAgdHlwZSAgQ2FuIGhhdmUgdmFsdWVzICdhdXRvJywgJ2FycmF5JyxcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLCBvciAnc3RyaW5nJy5cXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBOb2RlIChlZGl0b3IsIHBhcmFtcykge1xcblxcdCAgLyoqIEB0eXBlIHtUcmVlRWRpdG9yfSAqL1xcblxcdCAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XFxuXFx0ICB0aGlzLmRvbSA9IHt9O1xcblxcdCAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xcblxcblxcdCAgaWYocGFyYW1zICYmIChwYXJhbXMgaW5zdGFuY2VvZiBPYmplY3QpKSB7XFxuXFx0ICAgIHRoaXMuc2V0RmllbGQocGFyYW1zLmZpZWxkLCBwYXJhbXMuZmllbGRFZGl0YWJsZSk7XFxuXFx0ICAgIHRoaXMuc2V0VmFsdWUocGFyYW1zLnZhbHVlLCBwYXJhbXMudHlwZSk7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgdGhpcy5zZXRGaWVsZCgnJyk7XFxuXFx0ICAgIHRoaXMuc2V0VmFsdWUobnVsbCk7XFxuXFx0ICB9XFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIERldGVybWluZSB3aGV0aGVyIHRoZSBmaWVsZCBhbmQvb3IgdmFsdWUgb2YgdGhpcyBub2RlIGFyZSBlZGl0YWJsZVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX3VwZGF0ZUVkaXRhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdGhpcy5lZGl0YWJsZSA9IHtcXG5cXHQgICAgZmllbGQ6IHRydWUsXFxuXFx0ICAgIHZhbHVlOiB0cnVlXFxuXFx0ICB9O1xcblxcblxcdCAgaWYgKHRoaXMuZWRpdG9yKSB7XFxuXFx0ICAgIHRoaXMuZWRpdGFibGUuZmllbGQgPSB0aGlzLmVkaXRvci5vcHRpb25zLm1vZGUgPT09ICd0cmVlJztcXG5cXHQgICAgdGhpcy5lZGl0YWJsZS52YWx1ZSA9IHRoaXMuZWRpdG9yLm9wdGlvbnMubW9kZSAhPT0gJ3ZpZXcnO1xcblxcblxcdCAgICBpZiAodGhpcy5lZGl0b3Iub3B0aW9ucy5tb2RlID09PSAndHJlZScgJiYgKHR5cGVvZiB0aGlzLmVkaXRvci5vcHRpb25zLmVkaXRhYmxlID09PSAnZnVuY3Rpb24nKSkge1xcblxcdCAgICAgIHZhciBlZGl0YWJsZSA9IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGUoe1xcblxcdCAgICAgICAgZmllbGQ6IHRoaXMuZmllbGQsXFxuXFx0ICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcXG5cXHQgICAgICAgIHBhdGg6IHRoaXMucGF0aCgpXFxuXFx0ICAgICAgfSk7XFxuXFxuXFx0ICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRhYmxlLmZpZWxkID0gZWRpdGFibGU7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRhYmxlLnZhbHVlID0gZWRpdGFibGU7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZS5maWVsZCA9PT0gJ2Jvb2xlYW4nKSB0aGlzLmVkaXRhYmxlLmZpZWxkID0gZWRpdGFibGUuZmllbGQ7XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIGVkaXRhYmxlLnZhbHVlID09PSAnYm9vbGVhbicpIHRoaXMuZWRpdGFibGUudmFsdWUgPSBlZGl0YWJsZS52YWx1ZTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgcGF0aCBvZiB0aGlzIG5vZGVcXG5cXHQgKiBAcmV0dXJuIHtTdHJpbmdbXX0gQXJyYXkgY29udGFpbmluZyB0aGUgcGF0aCB0byB0aGlzIG5vZGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdmFyIG5vZGUgPSB0aGlzO1xcblxcdCAgdmFyIHBhdGggPSBbXTtcXG5cXHQgIHdoaWxlIChub2RlKSB7XFxuXFx0ICAgIHZhciBmaWVsZCA9IG5vZGUuZmllbGQgIT0gdW5kZWZpbmVkID8gbm9kZS5maWVsZCA6IG5vZGUuaW5kZXg7XFxuXFx0ICAgIGlmIChmaWVsZCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgcGF0aC51bnNoaWZ0KGZpZWxkKTtcXG5cXHQgICAgfVxcblxcdCAgICBub2RlID0gbm9kZS5wYXJlbnQ7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gcGF0aDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldCBwYXJlbnQgbm9kZVxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24ocGFyZW50KSB7XFxuXFx0ICB0aGlzLnBhcmVudCA9IHBhcmVudDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFNldCBmaWVsZFxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSAgZmllbGRcXG5cXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtmaWVsZEVkaXRhYmxlXVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLnNldEZpZWxkID0gZnVuY3Rpb24oZmllbGQsIGZpZWxkRWRpdGFibGUpIHtcXG5cXHQgIHRoaXMuZmllbGQgPSBmaWVsZDtcXG5cXHQgIHRoaXMuZmllbGRFZGl0YWJsZSA9IChmaWVsZEVkaXRhYmxlID09PSB0cnVlKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCBmaWVsZFxcblxcdCAqIEByZXR1cm4ge1N0cmluZ31cXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgaWYgKHRoaXMuZmllbGQgPT09IHVuZGVmaW5lZCkge1xcblxcdCAgICB0aGlzLl9nZXREb21GaWVsZCgpO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHRoaXMuZmllbGQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgdmFsdWUuIFZhbHVlIGlzIGEgSlNPTiBzdHJ1Y3R1cmUgb3IgYW4gZWxlbWVudCBTdHJpbmcsIEJvb2xlYW4sIGV0Yy5cXG5cXHQgKiBAcGFyYW0geyp9IHZhbHVlXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAgU3BlY2lmeSB0aGUgdHlwZSBvZiB0aGUgdmFsdWUuIENhbiBiZSAnYXV0bycsXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5JywgJ29iamVjdCcsIG9yICdzdHJpbmcnXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgdHlwZSkge1xcblxcdCAgdmFyIGNoaWxkVmFsdWUsIGNoaWxkO1xcblxcblxcdCAgLy8gZmlyc3QgY2xlYXIgYWxsIGN1cnJlbnQgY2hpbGRzIChpZiBhbnkpXFxuXFx0ICB2YXIgY2hpbGRzID0gdGhpcy5jaGlsZHM7XFxuXFx0ICBpZiAoY2hpbGRzKSB7XFxuXFx0ICAgIHdoaWxlIChjaGlsZHMubGVuZ3RoKSB7XFxuXFx0ICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZHNbMF0pO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBUT0RPOiByZW1vdmUgdGhlIERPTSBvZiB0aGlzIE5vZGVcXG5cXG5cXHQgIHRoaXMudHlwZSA9IHRoaXMuX2dldFR5cGUodmFsdWUpO1xcblxcblxcdCAgLy8gY2hlY2sgaWYgdHlwZSBjb3JyZXNwb25kcyB3aXRoIHRoZSBwcm92aWRlZCB0eXBlXFxuXFx0ICBpZiAodHlwZSAmJiB0eXBlICE9IHRoaXMudHlwZSkge1xcblxcdCAgICBpZiAodHlwZSA9PSAnc3RyaW5nJyAmJiB0aGlzLnR5cGUgPT0gJ2F1dG8nKSB7XFxuXFx0ICAgICAgdGhpcy50eXBlID0gdHlwZTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbWlzbWF0Y2g6ICcgK1xcblxcdCAgICAgICAgICAnY2Fubm90IGNhc3QgdmFsdWUgb2YgdHlwZSBcXFwiJyArIHRoaXMudHlwZSArXFxuXFx0ICAgICAgICAgICcgdG8gdGhlIHNwZWNpZmllZCB0eXBlIFxcXCInICsgdHlwZSArICdcXFwiJyk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLnR5cGUgPT0gJ2FycmF5Jykge1xcblxcdCAgICAvLyBhcnJheVxcblxcdCAgICB0aGlzLmNoaWxkcyA9IFtdO1xcblxcdCAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xcblxcdCAgICAgIGNoaWxkVmFsdWUgPSB2YWx1ZVtpXTtcXG5cXHQgICAgICBpZiAoY2hpbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICEoY2hpbGRWYWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xcblxcdCAgICAgICAgLy8gaWdub3JlIHVuZGVmaW5lZCBhbmQgZnVuY3Rpb25zXFxuXFx0ICAgICAgICBjaGlsZCA9IG5ldyBOb2RlKHRoaXMuZWRpdG9yLCB7XFxuXFx0ICAgICAgICAgIHZhbHVlOiBjaGlsZFZhbHVlXFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICB0aGlzLnZhbHVlID0gJyc7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gJ29iamVjdCcpIHtcXG5cXHQgICAgLy8gb2JqZWN0XFxuXFx0ICAgIHRoaXMuY2hpbGRzID0gW107XFxuXFx0ICAgIGZvciAodmFyIGNoaWxkRmllbGQgaW4gdmFsdWUpIHtcXG5cXHQgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoY2hpbGRGaWVsZCkpIHtcXG5cXHQgICAgICAgIGNoaWxkVmFsdWUgPSB2YWx1ZVtjaGlsZEZpZWxkXTtcXG5cXHQgICAgICAgIGlmIChjaGlsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShjaGlsZFZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XFxuXFx0ICAgICAgICAgIC8vIGlnbm9yZSB1bmRlZmluZWQgYW5kIGZ1bmN0aW9uc1xcblxcdCAgICAgICAgICBjaGlsZCA9IG5ldyBOb2RlKHRoaXMuZWRpdG9yLCB7XFxuXFx0ICAgICAgICAgICAgZmllbGQ6IGNoaWxkRmllbGQsXFxuXFx0ICAgICAgICAgICAgdmFsdWU6IGNoaWxkVmFsdWVcXG5cXHQgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICB0aGlzLnZhbHVlID0gJyc7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgLy8gdmFsdWVcXG5cXHQgICAgdGhpcy5jaGlsZHMgPSB1bmRlZmluZWQ7XFxuXFx0ICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcXG5cXHQgICAgLyogVE9ET1xcblxcdCAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT0gJ3N0cmluZycpIHtcXG5cXHQgICAgIHZhciBlc2NWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcXG5cXHQgICAgIHRoaXMudmFsdWUgPSBlc2NWYWx1ZS5zdWJzdHJpbmcoMSwgZXNjVmFsdWUubGVuZ3RoIC0gMSk7XFxuXFx0ICAgICB1dGlsLmxvZygnY2hlY2snLCB2YWx1ZSwgdGhpcy52YWx1ZSk7XFxuXFx0ICAgICB9XFxuXFx0ICAgICBlbHNlIHtcXG5cXHQgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcXG5cXHQgICAgIH1cXG5cXHQgICAgICovXFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgdmFsdWUuIFZhbHVlIGlzIGEgSlNPTiBzdHJ1Y3R1cmVcXG5cXHQgKiBAcmV0dXJuIHsqfSB2YWx1ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAvL3ZhciBjaGlsZHMsIGksIGlNYXg7XFxuXFxuXFx0ICBpZiAodGhpcy50eXBlID09ICdhcnJheScpIHtcXG5cXHQgICAgdmFyIGFyciA9IFtdO1xcblxcdCAgICB0aGlzLmNoaWxkcy5mb3JFYWNoIChmdW5jdGlvbiAoY2hpbGQpIHtcXG5cXHQgICAgICBhcnIucHVzaChjaGlsZC5nZXRWYWx1ZSgpKTtcXG5cXHQgICAgfSk7XFxuXFx0ICAgIHJldHVybiBhcnI7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gJ29iamVjdCcpIHtcXG5cXHQgICAgdmFyIG9iaiA9IHt9O1xcblxcdCAgICB0aGlzLmNoaWxkcy5mb3JFYWNoIChmdW5jdGlvbiAoY2hpbGQpIHtcXG5cXHQgICAgICBvYmpbY2hpbGQuZ2V0RmllbGQoKV0gPSBjaGlsZC5nZXRWYWx1ZSgpO1xcblxcdCAgICB9KTtcXG5cXHQgICAgcmV0dXJuIG9iajtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgdGhpcy5fZ2V0RG9tVmFsdWUoKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICByZXR1cm4gdGhpcy52YWx1ZTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgbmVzdGluZyBsZXZlbCBvZiB0aGlzIG5vZGVcXG5cXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGxldmVsXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbigpIHtcXG5cXHQgIHJldHVybiAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5nZXRMZXZlbCgpICsgMSA6IDApO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlIGEgY2xvbmUgb2YgYSBub2RlXFxuXFx0ICogVGhlIGNvbXBsZXRlIHN0YXRlIG9mIGEgY2xvbmUgaXMgY29waWVkLCBpbmNsdWRpbmcgd2hldGhlciBpdCBpcyBleHBhbmRlZCBvclxcblxcdCAqIG5vdC4gVGhlIERPTSBlbGVtZW50cyBhcmUgbm90IGNsb25lZC5cXG5cXHQgKiBAcmV0dXJuIHtOb2RlfSBjbG9uZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICB2YXIgY2xvbmUgPSBuZXcgTm9kZSh0aGlzLmVkaXRvcik7XFxuXFx0ICBjbG9uZS50eXBlID0gdGhpcy50eXBlO1xcblxcdCAgY2xvbmUuZmllbGQgPSB0aGlzLmZpZWxkO1xcblxcdCAgY2xvbmUuZmllbGRJbm5lclRleHQgPSB0aGlzLmZpZWxkSW5uZXJUZXh0O1xcblxcdCAgY2xvbmUuZmllbGRFZGl0YWJsZSA9IHRoaXMuZmllbGRFZGl0YWJsZTtcXG5cXHQgIGNsb25lLnZhbHVlID0gdGhpcy52YWx1ZTtcXG5cXHQgIGNsb25lLnZhbHVlSW5uZXJUZXh0ID0gdGhpcy52YWx1ZUlubmVyVGV4dDtcXG5cXHQgIGNsb25lLmV4cGFuZGVkID0gdGhpcy5leHBhbmRlZDtcXG5cXG5cXHQgIGlmICh0aGlzLmNoaWxkcykge1xcblxcdCAgICAvLyBhbiBvYmplY3Qgb3IgYXJyYXlcXG5cXHQgICAgdmFyIGNsb25lQ2hpbGRzID0gW107XFxuXFx0ICAgIHRoaXMuY2hpbGRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XFxuXFx0ICAgICAgdmFyIGNoaWxkQ2xvbmUgPSBjaGlsZC5jbG9uZSgpO1xcblxcdCAgICAgIGNoaWxkQ2xvbmUuc2V0UGFyZW50KGNsb25lKTtcXG5cXHQgICAgICBjbG9uZUNoaWxkcy5wdXNoKGNoaWxkQ2xvbmUpO1xcblxcdCAgICB9KTtcXG5cXHQgICAgY2xvbmUuY2hpbGRzID0gY2xvbmVDaGlsZHM7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgLy8gYSB2YWx1ZVxcblxcdCAgICBjbG9uZS5jaGlsZHMgPSB1bmRlZmluZWQ7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gY2xvbmU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFeHBhbmQgdGhpcyBub2RlIGFuZCBvcHRpb25hbGx5IGl0cyBjaGlsZHMuXFxuXFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVjdXJzZV0gT3B0aW9uYWwgcmVjdXJzaW9uLCB0cnVlIGJ5IGRlZmF1bHQuIFdoZW5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCBhbGwgY2hpbGRzIHdpbGwgYmUgZXhwYW5kZWQgcmVjdXJzaXZlbHlcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbihyZWN1cnNlKSB7XFxuXFx0ICBpZiAoIXRoaXMuY2hpbGRzKSB7XFxuXFx0ICAgIHJldHVybjtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIHNldCB0aGlzIG5vZGUgZXhwYW5kZWRcXG5cXHQgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xcblxcdCAgaWYgKHRoaXMuZG9tLmV4cGFuZCkge1xcblxcdCAgICB0aGlzLmRvbS5leHBhbmQuY2xhc3NOYW1lID0gJ2V4cGFuZGVkJztcXG5cXHQgIH1cXG5cXG5cXHQgIHRoaXMuc2hvd0NoaWxkcygpO1xcblxcblxcdCAgaWYgKHJlY3Vyc2UgIT09IGZhbHNlKSB7XFxuXFx0ICAgIHRoaXMuY2hpbGRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XFxuXFx0ICAgICAgY2hpbGQuZXhwYW5kKHJlY3Vyc2UpO1xcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENvbGxhcHNlIHRoaXMgbm9kZSBhbmQgb3B0aW9uYWxseSBpdHMgY2hpbGRzLlxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2VdIE9wdGlvbmFsIHJlY3Vyc2lvbiwgdHJ1ZSBieSBkZWZhdWx0LiBXaGVuXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSwgYWxsIGNoaWxkcyB3aWxsIGJlIGNvbGxhcHNlZCByZWN1cnNpdmVseVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24ocmVjdXJzZSkge1xcblxcdCAgaWYgKCF0aGlzLmNoaWxkcykge1xcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICB0aGlzLmhpZGVDaGlsZHMoKTtcXG5cXG5cXHQgIC8vIGNvbGxhcHNlIGNoaWxkcyBpbiBjYXNlIG9mIHJlY3Vyc2VcXG5cXHQgIGlmIChyZWN1cnNlICE9PSBmYWxzZSkge1xcblxcdCAgICB0aGlzLmNoaWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xcblxcdCAgICAgIGNoaWxkLmNvbGxhcHNlKHJlY3Vyc2UpO1xcblxcdCAgICB9KTtcXG5cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIG1ha2UgdGhpcyBub2RlIGNvbGxhcHNlZFxcblxcdCAgaWYgKHRoaXMuZG9tLmV4cGFuZCkge1xcblxcdCAgICB0aGlzLmRvbS5leHBhbmQuY2xhc3NOYW1lID0gJ2NvbGxhcHNlZCc7XFxuXFx0ICB9XFxuXFx0ICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZWN1cnNpdmVseSBzaG93IGFsbCBjaGlsZHMgd2hlbiB0aGV5IGFyZSBleHBhbmRlZFxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLnNob3dDaGlsZHMgPSBmdW5jdGlvbigpIHtcXG5cXHQgIHZhciBjaGlsZHMgPSB0aGlzLmNoaWxkcztcXG5cXHQgIGlmICghY2hpbGRzKSB7XFxuXFx0ICAgIHJldHVybjtcXG5cXHQgIH1cXG5cXHQgIGlmICghdGhpcy5leHBhbmRlZCkge1xcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgdHIgPSB0aGlzLmRvbS50cjtcXG5cXHQgIHZhciB0YWJsZSA9IHRyID8gdHIucGFyZW50Tm9kZSA6IHVuZGVmaW5lZDtcXG5cXHQgIGlmICh0YWJsZSkge1xcblxcdCAgICAvLyBzaG93IHJvdyB3aXRoIGFwcGVuZCBidXR0b25cXG5cXHQgICAgdmFyIGFwcGVuZCA9IHRoaXMuZ2V0QXBwZW5kKCk7XFxuXFx0ICAgIHZhciBuZXh0VHIgPSB0ci5uZXh0U2libGluZztcXG5cXHQgICAgaWYgKG5leHRUcikge1xcblxcdCAgICAgIHRhYmxlLmluc2VydEJlZm9yZShhcHBlbmQsIG5leHRUcik7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgdGFibGUuYXBwZW5kQ2hpbGQoYXBwZW5kKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBzaG93IGNoaWxkc1xcblxcdCAgICB0aGlzLmNoaWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xcblxcdCAgICAgIHRhYmxlLmluc2VydEJlZm9yZShjaGlsZC5nZXREb20oKSwgYXBwZW5kKTtcXG5cXHQgICAgICBjaGlsZC5zaG93Q2hpbGRzKCk7XFxuXFx0ICAgIH0pO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGlkZSB0aGUgbm9kZSB3aXRoIGFsbCBpdHMgY2hpbGRzXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgdmFyIHRyID0gdGhpcy5kb20udHI7XFxuXFx0ICB2YXIgdGFibGUgPSB0ciA/IHRyLnBhcmVudE5vZGUgOiB1bmRlZmluZWQ7XFxuXFx0ICBpZiAodGFibGUpIHtcXG5cXHQgICAgdGFibGUucmVtb3ZlQ2hpbGQodHIpO1xcblxcdCAgfVxcblxcdCAgdGhpcy5oaWRlQ2hpbGRzKCk7XFxuXFx0fTtcXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBSZWN1cnNpdmVseSBoaWRlIGFsbCBjaGlsZHNcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5oaWRlQ2hpbGRzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICB2YXIgY2hpbGRzID0gdGhpcy5jaGlsZHM7XFxuXFx0ICBpZiAoIWNoaWxkcykge1xcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFx0ICBpZiAoIXRoaXMuZXhwYW5kZWQpIHtcXG5cXHQgICAgcmV0dXJuO1xcblxcdCAgfVxcblxcblxcdCAgLy8gaGlkZSBhcHBlbmQgcm93XFxuXFx0ICB2YXIgYXBwZW5kID0gdGhpcy5nZXRBcHBlbmQoKTtcXG5cXHQgIGlmIChhcHBlbmQucGFyZW50Tm9kZSkge1xcblxcdCAgICBhcHBlbmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhcHBlbmQpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gaGlkZSBjaGlsZHNcXG5cXHQgIHRoaXMuY2hpbGRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XFxuXFx0ICAgIGNoaWxkLmhpZGUoKTtcXG5cXHQgIH0pO1xcblxcdH07XFxuXFxuXFxuXFx0LyoqXFxuXFx0ICogQWRkIGEgbmV3IGNoaWxkIHRvIHRoZSBub2RlLlxcblxcdCAqIE9ubHkgYXBwbGljYWJsZSB3aGVuIE5vZGUgdmFsdWUgaXMgb2YgdHlwZSBhcnJheSBvciBvYmplY3RcXG5cXHQgKiBAcGFyYW0ge05vZGV9IG5vZGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcXG5cXHQgIGlmICh0aGlzLl9oYXNDaGlsZHMoKSkge1xcblxcdCAgICAvLyBhZGp1c3QgdGhlIGxpbmsgdG8gdGhlIHBhcmVudFxcblxcdCAgICBub2RlLnNldFBhcmVudCh0aGlzKTtcXG5cXHQgICAgbm9kZS5maWVsZEVkaXRhYmxlID0gKHRoaXMudHlwZSA9PSAnb2JqZWN0Jyk7XFxuXFx0ICAgIGlmICh0aGlzLnR5cGUgPT0gJ2FycmF5Jykge1xcblxcdCAgICAgIG5vZGUuaW5kZXggPSB0aGlzLmNoaWxkcy5sZW5ndGg7XFxuXFx0ICAgIH1cXG5cXHQgICAgdGhpcy5jaGlsZHMucHVzaChub2RlKTtcXG5cXG5cXHQgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcXG5cXHQgICAgICAvLyBpbnNlcnQgaW50byB0aGUgRE9NLCBiZWZvcmUgdGhlIGFwcGVuZFJvd1xcblxcdCAgICAgIHZhciBuZXdUciA9IG5vZGUuZ2V0RG9tKCk7XFxuXFx0ICAgICAgdmFyIGFwcGVuZFRyID0gdGhpcy5nZXRBcHBlbmQoKTtcXG5cXHQgICAgICB2YXIgdGFibGUgPSBhcHBlbmRUciA/IGFwcGVuZFRyLnBhcmVudE5vZGUgOiB1bmRlZmluZWQ7XFxuXFx0ICAgICAgaWYgKGFwcGVuZFRyICYmIHRhYmxlKSB7XFxuXFx0ICAgICAgICB0YWJsZS5pbnNlcnRCZWZvcmUobmV3VHIsIGFwcGVuZFRyKTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgbm9kZS5zaG93Q2hpbGRzKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgdGhpcy51cGRhdGVEb20oeyd1cGRhdGVJbmRleGVzJzogdHJ1ZX0pO1xcblxcdCAgICBub2RlLnVwZGF0ZURvbSh7J3JlY3Vyc2UnOiB0cnVlfSk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBNb3ZlIGEgbm9kZSBmcm9tIGl0cyBjdXJyZW50IHBhcmVudCB0byB0aGlzIG5vZGVcXG5cXHQgKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBOb2RlIHZhbHVlIGlzIG9mIHR5cGUgYXJyYXkgb3Igb2JqZWN0XFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBiZWZvcmVOb2RlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUubW92ZUJlZm9yZSA9IGZ1bmN0aW9uKG5vZGUsIGJlZm9yZU5vZGUpIHtcXG5cXHQgIGlmICh0aGlzLl9oYXNDaGlsZHMoKSkge1xcblxcdCAgICAvLyBjcmVhdGUgYSB0ZW1wb3Jhcnkgcm93LCB0byBwcmV2ZW50IHRoZSBzY3JvbGwgcG9zaXRpb24gZnJvbSBqdW1waW5nXFxuXFx0ICAgIC8vIHdoZW4gcmVtb3ZpbmcgdGhlIG5vZGVcXG5cXHQgICAgdmFyIHRib2R5ID0gKHRoaXMuZG9tLnRyKSA/IHRoaXMuZG9tLnRyLnBhcmVudE5vZGUgOiB1bmRlZmluZWQ7XFxuXFx0ICAgIGlmICh0Ym9keSkge1xcblxcdCAgICAgIHZhciB0clRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xcblxcdCAgICAgIHRyVGVtcC5zdHlsZS5oZWlnaHQgPSB0Ym9keS5jbGllbnRIZWlnaHQgKyAncHgnO1xcblxcdCAgICAgIHRib2R5LmFwcGVuZENoaWxkKHRyVGVtcCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKG5vZGUucGFyZW50KSB7XFxuXFx0ICAgICAgbm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKGJlZm9yZU5vZGUgaW5zdGFuY2VvZiBBcHBlbmROb2RlKSB7XFxuXFx0ICAgICAgdGhpcy5hcHBlbmRDaGlsZChub2RlKTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICB0aGlzLmluc2VydEJlZm9yZShub2RlLCBiZWZvcmVOb2RlKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAodGJvZHkpIHtcXG5cXHQgICAgICB0Ym9keS5yZW1vdmVDaGlsZCh0clRlbXApO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBNb3ZlIGEgbm9kZSBmcm9tIGl0cyBjdXJyZW50IHBhcmVudCB0byB0aGlzIG5vZGVcXG5cXHQgKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBOb2RlIHZhbHVlIGlzIG9mIHR5cGUgYXJyYXkgb3Igb2JqZWN0LlxcblxcdCAqIElmIGluZGV4IGlzIG91dCBvZiByYW5nZSwgdGhlIG5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlXFxuXFx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKG5vZGUsIGluZGV4KSB7XFxuXFx0ICBpZiAobm9kZS5wYXJlbnQgPT0gdGhpcykge1xcblxcdCAgICAvLyBzYW1lIHBhcmVudFxcblxcdCAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5jaGlsZHMuaW5kZXhPZihub2RlKTtcXG5cXHQgICAgaWYgKGN1cnJlbnRJbmRleCA8IGluZGV4KSB7XFxuXFx0ICAgICAgLy8gY29tcGVuc2F0ZSB0aGUgaW5kZXggZm9yIHJlbW92YWwgb2YgdGhlIG5vZGUgaXRzZWxmXFxuXFx0ICAgICAgaW5kZXgrKztcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgdmFyIGJlZm9yZU5vZGUgPSB0aGlzLmNoaWxkc1tpbmRleF0gfHwgdGhpcy5hcHBlbmQ7XFxuXFx0ICB0aGlzLm1vdmVCZWZvcmUobm9kZSwgYmVmb3JlTm9kZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBJbnNlcnQgYSBuZXcgY2hpbGQgYmVmb3JlIGEgZ2l2ZW4gbm9kZVxcblxcdCAqIE9ubHkgYXBwbGljYWJsZSB3aGVuIE5vZGUgdmFsdWUgaXMgb2YgdHlwZSBhcnJheSBvciBvYmplY3RcXG5cXHQgKiBAcGFyYW0ge05vZGV9IG5vZGVcXG5cXHQgKiBAcGFyYW0ge05vZGV9IGJlZm9yZU5vZGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihub2RlLCBiZWZvcmVOb2RlKSB7XFxuXFx0ICBpZiAodGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgaWYgKGJlZm9yZU5vZGUgPT0gdGhpcy5hcHBlbmQpIHtcXG5cXHQgICAgICAvLyBhcHBlbmQgdG8gdGhlIGNoaWxkIG5vZGVzXFxuXFxuXFx0ICAgICAgLy8gYWRqdXN0IHRoZSBsaW5rIHRvIHRoZSBwYXJlbnRcXG5cXHQgICAgICBub2RlLnNldFBhcmVudCh0aGlzKTtcXG5cXHQgICAgICBub2RlLmZpZWxkRWRpdGFibGUgPSAodGhpcy50eXBlID09ICdvYmplY3QnKTtcXG5cXHQgICAgICB0aGlzLmNoaWxkcy5wdXNoKG5vZGUpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIC8vIGluc2VydCBiZWZvcmUgYSBjaGlsZCBub2RlXFxuXFx0ICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHMuaW5kZXhPZihiZWZvcmVOb2RlKTtcXG5cXHQgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBub3QgZm91bmQnKTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgLy8gYWRqdXN0IHRoZSBsaW5rIHRvIHRoZSBwYXJlbnRcXG5cXHQgICAgICBub2RlLnNldFBhcmVudCh0aGlzKTtcXG5cXHQgICAgICBub2RlLmZpZWxkRWRpdGFibGUgPSAodGhpcy50eXBlID09ICdvYmplY3QnKTtcXG5cXHQgICAgICB0aGlzLmNoaWxkcy5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XFxuXFx0ICAgICAgLy8gaW5zZXJ0IGludG8gdGhlIERPTVxcblxcdCAgICAgIHZhciBuZXdUciA9IG5vZGUuZ2V0RG9tKCk7XFxuXFx0ICAgICAgdmFyIG5leHRUciA9IGJlZm9yZU5vZGUuZ2V0RG9tKCk7XFxuXFx0ICAgICAgdmFyIHRhYmxlID0gbmV4dFRyID8gbmV4dFRyLnBhcmVudE5vZGUgOiB1bmRlZmluZWQ7XFxuXFx0ICAgICAgaWYgKG5leHRUciAmJiB0YWJsZSkge1xcblxcdCAgICAgICAgdGFibGUuaW5zZXJ0QmVmb3JlKG5ld1RyLCBuZXh0VHIpO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBub2RlLnNob3dDaGlsZHMoKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB0aGlzLnVwZGF0ZURvbSh7J3VwZGF0ZUluZGV4ZXMnOiB0cnVlfSk7XFxuXFx0ICAgIG5vZGUudXBkYXRlRG9tKHsncmVjdXJzZSc6IHRydWV9KTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEluc2VydCBhIG5ldyBjaGlsZCBiZWZvcmUgYSBnaXZlbiBub2RlXFxuXFx0ICogT25seSBhcHBsaWNhYmxlIHdoZW4gTm9kZSB2YWx1ZSBpcyBvZiB0eXBlIGFycmF5IG9yIG9iamVjdFxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gYWZ0ZXJOb2RlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbihub2RlLCBhZnRlck5vZGUpIHtcXG5cXHQgIGlmICh0aGlzLl9oYXNDaGlsZHMoKSkge1xcblxcdCAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcy5pbmRleE9mKGFmdGVyTm9kZSk7XFxuXFx0ICAgIHZhciBiZWZvcmVOb2RlID0gdGhpcy5jaGlsZHNbaW5kZXggKyAxXTtcXG5cXHQgICAgaWYgKGJlZm9yZU5vZGUpIHtcXG5cXHQgICAgICB0aGlzLmluc2VydEJlZm9yZShub2RlLCBiZWZvcmVOb2RlKTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICB0aGlzLmFwcGVuZENoaWxkKG5vZGUpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZWFyY2ggaW4gdGhpcyBub2RlXFxuXFx0ICogVGhlIG5vZGUgd2lsbCBiZSBleHBhbmRlZCB3aGVuIHRoZSB0ZXh0IGlzIGZvdW5kIG9uZSBvZiBpdHMgY2hpbGRzLCBlbHNlXFxuXFx0ICogaXQgd2lsbCBiZSBjb2xsYXBzZWQuIFNlYXJjaGVzIGFyZSBjYXNlIGluc2Vuc2l0aXZlLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XFxuXFx0ICogQHJldHVybiB7Tm9kZVtdfSByZXN1bHRzICBBcnJheSB3aXRoIG5vZGVzIGNvbnRhaW5pbmcgdGhlIHNlYXJjaCB0ZXh0XFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgdmFyIHJlc3VsdHMgPSBbXTtcXG5cXHQgIHZhciBpbmRleDtcXG5cXHQgIHZhciBzZWFyY2ggPSB0ZXh0ID8gdGV4dC50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xcblxcblxcdCAgLy8gZGVsZXRlIG9sZCBzZWFyY2ggZGF0YVxcblxcdCAgZGVsZXRlIHRoaXMuc2VhcmNoRmllbGQ7XFxuXFx0ICBkZWxldGUgdGhpcy5zZWFyY2hWYWx1ZTtcXG5cXG5cXHQgIC8vIHNlYXJjaCBpbiBmaWVsZFxcblxcdCAgaWYgKHRoaXMuZmllbGQgIT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgIHZhciBmaWVsZCA9IFN0cmluZyh0aGlzLmZpZWxkKS50b0xvd2VyQ2FzZSgpO1xcblxcdCAgICBpbmRleCA9IGZpZWxkLmluZGV4T2Yoc2VhcmNoKTtcXG5cXHQgICAgaWYgKGluZGV4ICE9IC0xKSB7XFxuXFx0ICAgICAgdGhpcy5zZWFyY2hGaWVsZCA9IHRydWU7XFxuXFx0ICAgICAgcmVzdWx0cy5wdXNoKHtcXG5cXHQgICAgICAgICdub2RlJzogdGhpcyxcXG5cXHQgICAgICAgICdlbGVtJzogJ2ZpZWxkJ1xcblxcdCAgICAgIH0pO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIHVwZGF0ZSBkb21cXG5cXHQgICAgdGhpcy5fdXBkYXRlRG9tRmllbGQoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIHNlYXJjaCBpbiB2YWx1ZVxcblxcdCAgaWYgKHRoaXMuX2hhc0NoaWxkcygpKSB7XFxuXFx0ICAgIC8vIGFycmF5LCBvYmplY3RcXG5cXG5cXHQgICAgLy8gc2VhcmNoIHRoZSBub2RlcyBjaGlsZHNcXG5cXHQgICAgaWYgKHRoaXMuY2hpbGRzKSB7XFxuXFx0ICAgICAgdmFyIGNoaWxkUmVzdWx0cyA9IFtdO1xcblxcdCAgICAgIHRoaXMuY2hpbGRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XFxuXFx0ICAgICAgICBjaGlsZFJlc3VsdHMgPSBjaGlsZFJlc3VsdHMuY29uY2F0KGNoaWxkLnNlYXJjaCh0ZXh0KSk7XFxuXFx0ICAgICAgfSk7XFxuXFx0ICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGNoaWxkUmVzdWx0cyk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gdXBkYXRlIGRvbVxcblxcdCAgICBpZiAoc2VhcmNoICE9IHVuZGVmaW5lZCkge1xcblxcdCAgICAgIHZhciByZWN1cnNlID0gZmFsc2U7XFxuXFx0ICAgICAgaWYgKGNoaWxkUmVzdWx0cy5sZW5ndGggPT0gMCkge1xcblxcdCAgICAgICAgdGhpcy5jb2xsYXBzZShyZWN1cnNlKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICB0aGlzLmV4cGFuZChyZWN1cnNlKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICAvLyBzdHJpbmcsIGF1dG9cXG5cXHQgICAgaWYgKHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkICkge1xcblxcdCAgICAgIHZhciB2YWx1ZSA9IFN0cmluZyh0aGlzLnZhbHVlKS50b0xvd2VyQ2FzZSgpO1xcblxcdCAgICAgIGluZGV4ID0gdmFsdWUuaW5kZXhPZihzZWFyY2gpO1xcblxcdCAgICAgIGlmIChpbmRleCAhPSAtMSkge1xcblxcdCAgICAgICAgdGhpcy5zZWFyY2hWYWx1ZSA9IHRydWU7XFxuXFx0ICAgICAgICByZXN1bHRzLnB1c2goe1xcblxcdCAgICAgICAgICAnbm9kZSc6IHRoaXMsXFxuXFx0ICAgICAgICAgICdlbGVtJzogJ3ZhbHVlJ1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIHVwZGF0ZSBkb21cXG5cXHQgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXN1bHRzO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogTW92ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHN1Y2ggdGhhdCB0aGlzIG5vZGUgaXMgaW4gdGhlIHZpc2libGUgYXJlYS5cXG5cXHQgKiBUaGUgbm9kZSB3aWxsIG5vdCBnZXQgdGhlIGZvY3VzXFxuXFx0ICogQHBhcmFtIHtmdW5jdGlvbihib29sZWFuKX0gW2NhbGxiYWNrXVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLnNjcm9sbFRvID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcXG5cXHQgIGlmICghdGhpcy5kb20udHIgfHwgIXRoaXMuZG9tLnRyLnBhcmVudE5vZGUpIHtcXG5cXHQgICAgLy8gaWYgdGhlIG5vZGUgaXMgbm90IHZpc2libGUsIGV4cGFuZCBpdHMgcGFyZW50c1xcblxcdCAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XFxuXFx0ICAgIHZhciByZWN1cnNlID0gZmFsc2U7XFxuXFx0ICAgIHdoaWxlIChwYXJlbnQpIHtcXG5cXHQgICAgICBwYXJlbnQuZXhwYW5kKHJlY3Vyc2UpO1xcblxcdCAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLmRvbS50ciAmJiB0aGlzLmRvbS50ci5wYXJlbnROb2RlKSB7XFxuXFx0ICAgIHRoaXMuZWRpdG9yLnNjcm9sbFRvKHRoaXMuZG9tLnRyLm9mZnNldFRvcCwgY2FsbGJhY2spO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFxuXFx0Ly8gc3RvcmVzIHRoZSBlbGVtZW50IG5hbWUgY3VycmVudGx5IGhhdmluZyB0aGUgZm9jdXNcXG5cXHROb2RlLmZvY3VzRWxlbWVudCA9IHVuZGVmaW5lZDtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgZm9jdXMgdG8gdGhpcyBub2RlXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFtlbGVtZW50TmFtZV0gIFRoZSBmaWVsZCBuYW1lIG9mIHRoZSBlbGVtZW50IHRvIGdldCB0aGVcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXMgYXZhaWxhYmxlIHZhbHVlczogJ2RyYWcnLCAnbWVudScsXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdleHBhbmQnLCAnZmllbGQnLCAndmFsdWUnIChkZWZhdWx0KVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oZWxlbWVudE5hbWUpIHtcXG5cXHQgIE5vZGUuZm9jdXNFbGVtZW50ID0gZWxlbWVudE5hbWU7XFxuXFxuXFx0ICBpZiAodGhpcy5kb20udHIgJiYgdGhpcy5kb20udHIucGFyZW50Tm9kZSkge1xcblxcdCAgICB2YXIgZG9tID0gdGhpcy5kb207XFxuXFxuXFx0ICAgIHN3aXRjaCAoZWxlbWVudE5hbWUpIHtcXG5cXHQgICAgICBjYXNlICdkcmFnJzpcXG5cXHQgICAgICAgIGlmIChkb20uZHJhZykge1xcblxcdCAgICAgICAgICBkb20uZHJhZy5mb2N1cygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgIGRvbS5tZW51LmZvY3VzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBicmVhaztcXG5cXG5cXHQgICAgICBjYXNlICdtZW51JzpcXG5cXHQgICAgICAgIGRvbS5tZW51LmZvY3VzKCk7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXG5cXHQgICAgICBjYXNlICdleHBhbmQnOlxcblxcdCAgICAgICAgaWYgKHRoaXMuX2hhc0NoaWxkcygpKSB7XFxuXFx0ICAgICAgICAgIGRvbS5leHBhbmQuZm9jdXMoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2UgaWYgKGRvbS5maWVsZCAmJiB0aGlzLmZpZWxkRWRpdGFibGUpIHtcXG5cXHQgICAgICAgICAgZG9tLmZpZWxkLmZvY3VzKCk7XFxuXFx0ICAgICAgICAgIHV0aWwuc2VsZWN0Q29udGVudEVkaXRhYmxlKGRvbS5maWVsZCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIGlmIChkb20udmFsdWUgJiYgIXRoaXMuX2hhc0NoaWxkcygpKSB7XFxuXFx0ICAgICAgICAgIGRvbS52YWx1ZS5mb2N1cygpO1xcblxcdCAgICAgICAgICB1dGlsLnNlbGVjdENvbnRlbnRFZGl0YWJsZShkb20udmFsdWUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgIGRvbS5tZW51LmZvY3VzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBicmVhaztcXG5cXG5cXHQgICAgICBjYXNlICdmaWVsZCc6XFxuXFx0ICAgICAgICBpZiAoZG9tLmZpZWxkICYmIHRoaXMuZmllbGRFZGl0YWJsZSkge1xcblxcdCAgICAgICAgICBkb20uZmllbGQuZm9jdXMoKTtcXG5cXHQgICAgICAgICAgdXRpbC5zZWxlY3RDb250ZW50RWRpdGFibGUoZG9tLmZpZWxkKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2UgaWYgKGRvbS52YWx1ZSAmJiAhdGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICAgICAgZG9tLnZhbHVlLmZvY3VzKCk7XFxuXFx0ICAgICAgICAgIHV0aWwuc2VsZWN0Q29udGVudEVkaXRhYmxlKGRvbS52YWx1ZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIGlmICh0aGlzLl9oYXNDaGlsZHMoKSkge1xcblxcdCAgICAgICAgICBkb20uZXhwYW5kLmZvY3VzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgZG9tLm1lbnUuZm9jdXMoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ3ZhbHVlJzpcXG5cXHQgICAgICBkZWZhdWx0OlxcblxcdCAgICAgICAgaWYgKGRvbS52YWx1ZSAmJiAhdGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICAgICAgZG9tLnZhbHVlLmZvY3VzKCk7XFxuXFx0ICAgICAgICAgIHV0aWwuc2VsZWN0Q29udGVudEVkaXRhYmxlKGRvbS52YWx1ZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIGlmIChkb20uZmllbGQgJiYgdGhpcy5maWVsZEVkaXRhYmxlKSB7XFxuXFx0ICAgICAgICAgIGRvbS5maWVsZC5mb2N1cygpO1xcblxcdCAgICAgICAgICB1dGlsLnNlbGVjdENvbnRlbnRFZGl0YWJsZShkb20uZmllbGQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSBpZiAodGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICAgICAgZG9tLmV4cGFuZC5mb2N1cygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgIGRvbS5tZW51LmZvY3VzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogU2VsZWN0IGFsbCB0ZXh0IGluIGFuIGVkaXRhYmxlIGRpdiBhZnRlciBhIGRlbGF5IG9mIDAgbXNcXG5cXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVkaXRhYmxlRGl2XFxuXFx0ICovXFxuXFx0Tm9kZS5zZWxlY3QgPSBmdW5jdGlvbihlZGl0YWJsZURpdikge1xcblxcdCAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgIHV0aWwuc2VsZWN0Q29udGVudEVkaXRhYmxlKGVkaXRhYmxlRGl2KTtcXG5cXHQgIH0sIDApO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlIHRoZSB2YWx1ZXMgZnJvbSB0aGUgRE9NIGZpZWxkIGFuZCB2YWx1ZSBvZiB0aGlzIG5vZGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAvLyByZXRyaWV2ZSB0aGUgYWN0dWFsIGZpZWxkIGFuZCB2YWx1ZSBmcm9tIHRoZSBET00uXFxuXFx0ICB0aGlzLl9nZXREb21WYWx1ZShmYWxzZSk7XFxuXFx0ICB0aGlzLl9nZXREb21GaWVsZChmYWxzZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBEdXBsaWNhdGUgZ2l2ZW4gY2hpbGQgbm9kZVxcblxcdCAqIG5ldyBzdHJ1Y3R1cmUgd2lsbCBiZSBhZGRlZCByaWdodCBiZWZvcmUgdGhlIGNsb25lZCBub2RlXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlICAgICAgICAgICB0aGUgY2hpbGROb2RlIHRvIGJlIGR1cGxpY2F0ZWRcXG5cXHQgKiBAcmV0dXJuIHtOb2RlfSBjbG9uZSAgICAgICAgIHRoZSBjbG9uZSBvZiB0aGUgbm9kZVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2R1cGxpY2F0ZSA9IGZ1bmN0aW9uKG5vZGUpIHtcXG5cXHQgIHZhciBjbG9uZSA9IG5vZGUuY2xvbmUoKTtcXG5cXG5cXHQgIC8qIFRPRE86IGFkanVzdCB0aGUgZmllbGQgbmFtZSAodG8gcHJldmVudCBlcXVhbCBmaWVsZCBuYW1lcylcXG5cXHQgICBpZiAodGhpcy50eXBlID09ICdvYmplY3QnKSB7XFxuXFx0ICAgfVxcblxcdCAgICovXFxuXFxuXFx0ICB0aGlzLmluc2VydEFmdGVyKGNsb25lLCBub2RlKTtcXG5cXG5cXHQgIHJldHVybiBjbG9uZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENoZWNrIGlmIGdpdmVuIG5vZGUgaXMgYSBjaGlsZC4gVGhlIG1ldGhvZCB3aWxsIGNoZWNrIHJlY3Vyc2l2ZWx5IHRvIGZpbmRcXG5cXHQgKiB0aGlzIG5vZGUuXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlXFxuXFx0ICogQHJldHVybiB7Ym9vbGVhbn0gY29udGFpbnNOb2RlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuY29udGFpbnNOb2RlID0gZnVuY3Rpb24obm9kZSkge1xcblxcdCAgaWYgKHRoaXMgPT0gbm9kZSkge1xcblxcdCAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBjaGlsZHMgPSB0aGlzLmNoaWxkcztcXG5cXHQgIGlmIChjaGlsZHMpIHtcXG5cXHQgICAgLy8gVE9ETzogdXNlIHRoZSBqczUgQXJyYXkuc29tZSgpIGhlcmU/XFxuXFx0ICAgIGZvciAodmFyIGkgPSAwLCBpTWF4ID0gY2hpbGRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xcblxcdCAgICAgIGlmIChjaGlsZHNbaV0uY29udGFpbnNOb2RlKG5vZGUpKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBmYWxzZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIE1vdmUgZ2l2ZW4gbm9kZSBpbnRvIHRoaXMgbm9kZVxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgICAgICAgICAgdGhlIGNoaWxkTm9kZSB0byBiZSBtb3ZlZFxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gYmVmb3JlTm9kZSAgICAgbm9kZSB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSBnaXZlblxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLiBJZiBubyBiZWZvcmVOb2RlIGlzIGdpdmVuLFxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgbm9kZSBpcyBhcHBlbmRlZCBhdCB0aGUgZW5kXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uKG5vZGUsIGJlZm9yZU5vZGUpIHtcXG5cXHQgIGlmIChub2RlID09IGJlZm9yZU5vZGUpIHtcXG5cXHQgICAgLy8gbm90aGluZyB0byBkby4uLlxcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBjaGVjayBpZiB0aGlzIG5vZGUgaXMgbm90IGEgY2hpbGQgb2YgdGhlIG5vZGUgdG8gYmUgbW92ZWQgaGVyZVxcblxcdCAgaWYgKG5vZGUuY29udGFpbnNOb2RlKHRoaXMpKSB7XFxuXFx0ICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1vdmUgYSBmaWVsZCBpbnRvIGEgY2hpbGQgb2YgaXRzZWxmJyk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIG5vZGVcXG5cXHQgIGlmIChub2RlLnBhcmVudCkge1xcblxcdCAgICBub2RlLnBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIGNyZWF0ZSBhIGNsb25lIG9mIHRoZSBub2RlXFxuXFx0ICB2YXIgY2xvbmUgPSBub2RlLmNsb25lKCk7XFxuXFx0ICBub2RlLmNsZWFyRG9tKCk7XFxuXFxuXFx0ICAvLyBpbnNlcnQgb3IgYXBwZW5kIHRoZSBub2RlXFxuXFx0ICBpZiAoYmVmb3JlTm9kZSkge1xcblxcdCAgICB0aGlzLmluc2VydEJlZm9yZShjbG9uZSwgYmVmb3JlTm9kZSk7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgdGhpcy5hcHBlbmRDaGlsZChjbG9uZSk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvKiBUT0RPOiBhZGp1c3QgdGhlIGZpZWxkIG5hbWUgKHRvIHByZXZlbnQgZXF1YWwgZmllbGQgbmFtZXMpXFxuXFx0ICAgaWYgKHRoaXMudHlwZSA9PSAnb2JqZWN0Jykge1xcblxcdCAgIH1cXG5cXHQgICAqL1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVtb3ZlIGEgY2hpbGQgZnJvbSB0aGUgbm9kZS5cXG5cXHQgKiBPbmx5IGFwcGxpY2FibGUgd2hlbiBOb2RlIHZhbHVlIGlzIG9mIHR5cGUgYXJyYXkgb3Igb2JqZWN0XFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlICAgVGhlIGNoaWxkIG5vZGUgdG8gYmUgcmVtb3ZlZDtcXG5cXHQgKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSBub2RlICBUaGUgcmVtb3ZlZCBub2RlIG9uIHN1Y2Nlc3MsXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHVuZGVmaW5lZFxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24obm9kZSkge1xcblxcdCAgaWYgKHRoaXMuY2hpbGRzKSB7XFxuXFx0ICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRzLmluZGV4T2Yobm9kZSk7XFxuXFxuXFx0ICAgIGlmIChpbmRleCAhPSAtMSkge1xcblxcdCAgICAgIG5vZGUuaGlkZSgpO1xcblxcblxcdCAgICAgIC8vIGRlbGV0ZSBvbGQgc2VhcmNoIHJlc3VsdHNcXG5cXHQgICAgICBkZWxldGUgbm9kZS5zZWFyY2hGaWVsZDtcXG5cXHQgICAgICBkZWxldGUgbm9kZS5zZWFyY2hWYWx1ZTtcXG5cXG5cXHQgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLmNoaWxkcy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xcblxcblxcdCAgICAgIHRoaXMudXBkYXRlRG9tKHsndXBkYXRlSW5kZXhlcyc6IHRydWV9KTtcXG5cXG5cXHQgICAgICByZXR1cm4gcmVtb3ZlZE5vZGU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB1bmRlZmluZWQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZW1vdmUgYSBjaGlsZCBub2RlIG5vZGUgZnJvbSB0aGlzIG5vZGVcXG5cXHQgKiBUaGlzIG1ldGhvZCBpcyBlcXVhbCB0byBOb2RlLnJlbW92ZUNoaWxkLCBleGNlcHQgdGhhdCBfcmVtb3ZlIGZpcmV4IGFuXFxuXFx0ICogb25DaGFuZ2UgZXZlbnQuXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcXG5cXHQgIHRoaXMucmVtb3ZlQ2hpbGQobm9kZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTm9kZVxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBuZXdUeXBlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuY2hhbmdlVHlwZSA9IGZ1bmN0aW9uIChuZXdUeXBlKSB7XFxuXFx0ICB2YXIgb2xkVHlwZSA9IHRoaXMudHlwZTtcXG5cXG5cXHQgIGlmIChvbGRUeXBlID09IG5ld1R5cGUpIHtcXG5cXHQgICAgLy8gdHlwZSBpcyBub3QgY2hhbmdlZFxcblxcdCAgICByZXR1cm47XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoKG5ld1R5cGUgPT0gJ3N0cmluZycgfHwgbmV3VHlwZSA9PSAnYXV0bycpICYmXFxuXFx0ICAgICAgKG9sZFR5cGUgPT0gJ3N0cmluZycgfHwgb2xkVHlwZSA9PSAnYXV0bycpKSB7XFxuXFx0ICAgIC8vIHRoaXMgaXMgYW4gZWFzeSBjaGFuZ2VcXG5cXHQgICAgdGhpcy50eXBlID0gbmV3VHlwZTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICAvLyBjaGFuZ2UgZnJvbSBhcnJheSB0byBvYmplY3QsIG9yIGZyb20gc3RyaW5nL2F1dG8gdG8gb2JqZWN0L2FycmF5XFxuXFx0ICAgIHZhciB0YWJsZSA9IHRoaXMuZG9tLnRyID8gdGhpcy5kb20udHIucGFyZW50Tm9kZSA6IHVuZGVmaW5lZDtcXG5cXHQgICAgdmFyIGxhc3RUcjtcXG5cXHQgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcXG5cXHQgICAgICBsYXN0VHIgPSB0aGlzLmdldEFwcGVuZCgpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIGxhc3RUciA9IHRoaXMuZ2V0RG9tKCk7XFxuXFx0ICAgIH1cXG5cXHQgICAgdmFyIG5leHRUciA9IChsYXN0VHIgJiYgbGFzdFRyLnBhcmVudE5vZGUpID8gbGFzdFRyLm5leHRTaWJsaW5nIDogdW5kZWZpbmVkO1xcblxcblxcdCAgICAvLyBoaWRlIGN1cnJlbnQgZmllbGQgYW5kIGFsbCBpdHMgY2hpbGRzXFxuXFx0ICAgIHRoaXMuaGlkZSgpO1xcblxcdCAgICB0aGlzLmNsZWFyRG9tKCk7XFxuXFxuXFx0ICAgIC8vIGFkanVzdCB0aGUgZmllbGQgYW5kIHRoZSB2YWx1ZVxcblxcdCAgICB0aGlzLnR5cGUgPSBuZXdUeXBlO1xcblxcblxcdCAgICAvLyBhZGp1c3QgY2hpbGRzXFxuXFx0ICAgIGlmIChuZXdUeXBlID09ICdvYmplY3QnKSB7XFxuXFx0ICAgICAgaWYgKCF0aGlzLmNoaWxkcykge1xcblxcdCAgICAgICAgdGhpcy5jaGlsZHMgPSBbXTtcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgdGhpcy5jaGlsZHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XFxuXFx0ICAgICAgICBjaGlsZC5jbGVhckRvbSgpO1xcblxcdCAgICAgICAgZGVsZXRlIGNoaWxkLmluZGV4O1xcblxcdCAgICAgICAgY2hpbGQuZmllbGRFZGl0YWJsZSA9IHRydWU7XFxuXFx0ICAgICAgICBpZiAoY2hpbGQuZmllbGQgPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICAgIGNoaWxkLmZpZWxkID0gJyc7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfSk7XFxuXFxuXFx0ICAgICAgaWYgKG9sZFR5cGUgPT0gJ3N0cmluZycgfHwgb2xkVHlwZSA9PSAnYXV0bycpIHtcXG5cXHQgICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmIChuZXdUeXBlID09ICdhcnJheScpIHtcXG5cXHQgICAgICBpZiAoIXRoaXMuY2hpbGRzKSB7XFxuXFx0ICAgICAgICB0aGlzLmNoaWxkcyA9IFtdO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICB0aGlzLmNoaWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcXG5cXHQgICAgICAgIGNoaWxkLmNsZWFyRG9tKCk7XFxuXFx0ICAgICAgICBjaGlsZC5maWVsZEVkaXRhYmxlID0gZmFsc2U7XFxuXFx0ICAgICAgICBjaGlsZC5pbmRleCA9IGluZGV4O1xcblxcdCAgICAgIH0pO1xcblxcblxcdCAgICAgIGlmIChvbGRUeXBlID09ICdzdHJpbmcnIHx8IG9sZFR5cGUgPT0gJ2F1dG8nKSB7XFxuXFx0ICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGNyZWF0ZSBuZXcgRE9NXFxuXFx0ICAgIGlmICh0YWJsZSkge1xcblxcdCAgICAgIGlmIChuZXh0VHIpIHtcXG5cXHQgICAgICAgIHRhYmxlLmluc2VydEJlZm9yZSh0aGlzLmdldERvbSgpLCBuZXh0VHIpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIHtcXG5cXHQgICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRoaXMuZ2V0RG9tKCkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICB0aGlzLnNob3dDaGlsZHMoKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChuZXdUeXBlID09ICdhdXRvJyB8fCBuZXdUeXBlID09ICdzdHJpbmcnKSB7XFxuXFx0ICAgIC8vIGNhc3QgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZVxcblxcdCAgICBpZiAobmV3VHlwZSA9PSAnc3RyaW5nJykge1xcblxcdCAgICAgIHRoaXMudmFsdWUgPSBTdHJpbmcodGhpcy52YWx1ZSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX3N0cmluZ0Nhc3QoU3RyaW5nKHRoaXMudmFsdWUpKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB0aGlzLmZvY3VzKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICB0aGlzLnVwZGF0ZURvbSh7J3VwZGF0ZUluZGV4ZXMnOiB0cnVlfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZXRyaWV2ZSB2YWx1ZSBmcm9tIERPTVxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudF0gIElmIHRydWUgKGRlZmF1bHQpLCBubyBlcnJvcnMgd2lsbCBiZSB0aHJvd24gaW5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mIGludmFsaWQgZGF0YVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2dldERvbVZhbHVlID0gZnVuY3Rpb24oc2lsZW50KSB7XFxuXFx0ICBpZiAodGhpcy5kb20udmFsdWUgJiYgdGhpcy50eXBlICE9ICdhcnJheScgJiYgdGhpcy50eXBlICE9ICdvYmplY3QnKSB7XFxuXFx0ICAgIHRoaXMudmFsdWVJbm5lclRleHQgPSB1dGlsLmdldElubmVyVGV4dCh0aGlzLmRvbS52YWx1ZSk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAodGhpcy52YWx1ZUlubmVyVGV4dCAhPSB1bmRlZmluZWQpIHtcXG5cXHQgICAgdHJ5IHtcXG5cXHQgICAgICAvLyByZXRyaWV2ZSB0aGUgdmFsdWVcXG5cXHQgICAgICB2YXIgdmFsdWU7XFxuXFx0ICAgICAgaWYgKHRoaXMudHlwZSA9PSAnc3RyaW5nJykge1xcblxcdCAgICAgICAgdmFsdWUgPSB0aGlzLl91bmVzY2FwZUhUTUwodGhpcy52YWx1ZUlubmVyVGV4dCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuX3VuZXNjYXBlSFRNTCh0aGlzLnZhbHVlSW5uZXJUZXh0KTtcXG5cXHQgICAgICAgIHZhbHVlID0gdGhpcy5fc3RyaW5nQ2FzdChzdHIpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcXG5cXHQgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XFxuXFx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci5fb25BY3Rpb24oJ2VkaXRWYWx1ZScsIHtcXG5cXHQgICAgICAgICAgJ25vZGUnOiB0aGlzLFxcblxcdCAgICAgICAgICAnb2xkVmFsdWUnOiBvbGRWYWx1ZSxcXG5cXHQgICAgICAgICAgJ25ld1ZhbHVlJzogdmFsdWUsXFxuXFx0ICAgICAgICAgICdvbGRTZWxlY3Rpb24nOiB0aGlzLmVkaXRvci5zZWxlY3Rpb24sXFxuXFx0ICAgICAgICAgICduZXdTZWxlY3Rpb24nOiB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKVxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIGNhdGNoIChlcnIpIHtcXG5cXHQgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xcblxcdCAgICAgIC8vIFRPRE86IHNlbnQgYW4gYWN0aW9uIHdpdGggdGhlIG5ldywgaW52YWxpZCB2YWx1ZT9cXG5cXHQgICAgICBpZiAoc2lsZW50ICE9PSB0cnVlKSB7XFxuXFx0ICAgICAgICB0aHJvdyBlcnI7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVcGRhdGUgZG9tIHZhbHVlOlxcblxcdCAqIC0gdGhlIHRleHQgY29sb3Igb2YgdGhlIHZhbHVlLCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdGhlIHZhbHVlXFxuXFx0ICogLSB0aGUgaGVpZ2h0IG9mIHRoZSBmaWVsZCwgZGVwZW5kaW5nIG9uIHRoZSB3aWR0aFxcblxcdCAqIC0gYmFja2dyb3VuZCBjb2xvciBpbiBjYXNlIGl0IGlzIGVtcHR5XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fdXBkYXRlRG9tVmFsdWUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB2YXIgZG9tVmFsdWUgPSB0aGlzLmRvbS52YWx1ZTtcXG5cXHQgIGlmIChkb21WYWx1ZSkge1xcblxcdCAgICAvLyBzZXQgdGV4dCBjb2xvciBkZXBlbmRpbmcgb24gdmFsdWUgdHlwZVxcblxcdCAgICAvLyBUT0RPOiBwdXQgY29sb3JzIGluIGNzc1xcblxcdCAgICB2YXIgdiA9IHRoaXMudmFsdWU7XFxuXFx0ICAgIHZhciB0ID0gKHRoaXMudHlwZSA9PSAnYXV0bycpID8gdXRpbC50eXBlKHYpIDogdGhpcy50eXBlO1xcblxcdCAgICB2YXIgaXNVcmwgPSAodCA9PSAnc3RyaW5nJyAmJiB1dGlsLmlzVXJsKHYpKTtcXG5cXHQgICAgdmFyIGNvbG9yID0gJyc7XFxuXFx0ICAgIGlmIChpc1VybCAmJiAhdGhpcy5lZGl0YWJsZS52YWx1ZSkgeyAvLyBUT0RPOiB3aGVuIHRvIGFwcGx5IHRoaXM/XFxuXFx0ICAgICAgY29sb3IgPSAnJztcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmICh0ID09ICdzdHJpbmcnKSB7XFxuXFx0ICAgICAgY29sb3IgPSAnZ3JlZW4nO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHQgPT0gJ251bWJlcicpIHtcXG5cXHQgICAgICBjb2xvciA9ICdyZWQnO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHQgPT0gJ2Jvb2xlYW4nKSB7XFxuXFx0ICAgICAgY29sb3IgPSAnZGFya29yYW5nZSc7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAodGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICBjb2xvciA9ICcnO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHYgPT09IG51bGwpIHtcXG5cXHQgICAgICBjb2xvciA9ICcjMDA0RUQwJzsgIC8vIGJsdWVcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICAvLyBpbnZhbGlkIHZhbHVlXFxuXFx0ICAgICAgY29sb3IgPSAnYmxhY2snO1xcblxcdCAgICB9XFxuXFx0ICAgIGRvbVZhbHVlLnN0eWxlLmNvbG9yID0gY29sb3I7XFxuXFxuXFx0ICAgIC8vIG1ha2UgYmFja2dyb3VuZCBjb2xvciBsaWdodC1ncmF5IHdoZW4gZW1wdHlcXG5cXHQgICAgdmFyIGlzRW1wdHkgPSAoU3RyaW5nKHRoaXMudmFsdWUpID09ICcnICYmIHRoaXMudHlwZSAhPSAnYXJyYXknICYmIHRoaXMudHlwZSAhPSAnb2JqZWN0Jyk7XFxuXFx0ICAgIGlmIChpc0VtcHR5KSB7XFxuXFx0ICAgICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tVmFsdWUsICdlbXB0eScpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbVZhbHVlLCAnZW1wdHknKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyB1bmRlcmxpbmUgdXJsXFxuXFx0ICAgIGlmIChpc1VybCkge1xcblxcdCAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbVZhbHVlLCAndXJsJyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tVmFsdWUsICd1cmwnKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyB1cGRhdGUgdGl0bGVcXG5cXHQgICAgaWYgKHQgPT0gJ2FycmF5JyB8fCB0ID09ICdvYmplY3QnKSB7XFxuXFx0ICAgICAgdmFyIGNvdW50ID0gdGhpcy5jaGlsZHMgPyB0aGlzLmNoaWxkcy5sZW5ndGggOiAwO1xcblxcdCAgICAgIGRvbVZhbHVlLnRpdGxlID0gdGhpcy50eXBlICsgJyBjb250YWluaW5nICcgKyBjb3VudCArICcgaXRlbXMnO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHQgPT0gJ3N0cmluZycgJiYgdXRpbC5pc1VybCh2KSkge1xcblxcdCAgICAgIGlmICh0aGlzLmVkaXRhYmxlLnZhbHVlKSB7XFxuXFx0ICAgICAgICBkb21WYWx1ZS50aXRsZSA9ICdDdHJsK0NsaWNrIG9yIEN0cmwrRW50ZXIgdG8gb3BlbiB1cmwgaW4gbmV3IHdpbmRvdyc7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIGRvbVZhbHVlLnRpdGxlID0gJyc7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gaGlnaGxpZ2h0IHdoZW4gdGhlcmUgaXMgYSBzZWFyY2ggcmVzdWx0XFxuXFx0ICAgIGlmICh0aGlzLnNlYXJjaFZhbHVlQWN0aXZlKSB7XFxuXFx0ICAgICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tVmFsdWUsICdoaWdobGlnaHQtYWN0aXZlJyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tVmFsdWUsICdoaWdobGlnaHQtYWN0aXZlJyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgaWYgKHRoaXMuc2VhcmNoVmFsdWUpIHtcXG5cXHQgICAgICB1dGlsLmFkZENsYXNzTmFtZShkb21WYWx1ZSwgJ2hpZ2hsaWdodCcpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbVZhbHVlLCAnaGlnaGxpZ2h0Jyk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gc3RyaXAgZm9ybWF0dGluZyBmcm9tIHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdGFibGUgZGl2XFxuXFx0ICAgIHV0aWwuc3RyaXBGb3JtYXR0aW5nKGRvbVZhbHVlKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZSBkb20gZmllbGQ6XFxuXFx0ICogLSB0aGUgdGV4dCBjb2xvciBvZiB0aGUgZmllbGQsIGRlcGVuZGluZyBvbiB0aGUgdGV4dFxcblxcdCAqIC0gdGhlIGhlaWdodCBvZiB0aGUgZmllbGQsIGRlcGVuZGluZyBvbiB0aGUgd2lkdGhcXG5cXHQgKiAtIGJhY2tncm91bmQgY29sb3IgaW4gY2FzZSBpdCBpcyBlbXB0eVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX3VwZGF0ZURvbUZpZWxkID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdmFyIGRvbUZpZWxkID0gdGhpcy5kb20uZmllbGQ7XFxuXFx0ICBpZiAoZG9tRmllbGQpIHtcXG5cXHQgICAgLy8gbWFrZSBiYWNrZ291bmQgY29sb3IgbGlnaHRncmF5IHdoZW4gZW1wdHlcXG5cXHQgICAgdmFyIGlzRW1wdHkgPSAoU3RyaW5nKHRoaXMuZmllbGQpID09ICcnICYmIHRoaXMucGFyZW50LnR5cGUgIT0gJ2FycmF5Jyk7XFxuXFx0ICAgIGlmIChpc0VtcHR5KSB7XFxuXFx0ICAgICAgdXRpbC5hZGRDbGFzc05hbWUoZG9tRmllbGQsICdlbXB0eScpO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbUZpZWxkLCAnZW1wdHknKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBoaWdobGlnaHQgd2hlbiB0aGVyZSBpcyBhIHNlYXJjaCByZXN1bHRcXG5cXHQgICAgaWYgKHRoaXMuc2VhcmNoRmllbGRBY3RpdmUpIHtcXG5cXHQgICAgICB1dGlsLmFkZENsYXNzTmFtZShkb21GaWVsZCwgJ2hpZ2hsaWdodC1hY3RpdmUnKTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb21GaWVsZCwgJ2hpZ2hsaWdodC1hY3RpdmUnKTtcXG5cXHQgICAgfVxcblxcdCAgICBpZiAodGhpcy5zZWFyY2hGaWVsZCkge1xcblxcdCAgICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbUZpZWxkLCAnaGlnaGxpZ2h0Jyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZG9tRmllbGQsICdoaWdobGlnaHQnKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBzdHJpcCBmb3JtYXR0aW5nIGZyb20gdGhlIGNvbnRlbnRzIG9mIHRoZSBlZGl0YWJsZSBkaXZcXG5cXHQgICAgdXRpbC5zdHJpcEZvcm1hdHRpbmcoZG9tRmllbGQpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmV0cmlldmUgZmllbGQgZnJvbSBET01cXG5cXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnRdICBJZiB0cnVlIChkZWZhdWx0KSwgbm8gZXJyb3JzIHdpbGwgYmUgdGhyb3duIGluXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBvZiBpbnZhbGlkIGRhdGFcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9nZXREb21GaWVsZCA9IGZ1bmN0aW9uKHNpbGVudCkge1xcblxcdCAgaWYgKHRoaXMuZG9tLmZpZWxkICYmIHRoaXMuZmllbGRFZGl0YWJsZSkge1xcblxcdCAgICB0aGlzLmZpZWxkSW5uZXJUZXh0ID0gdXRpbC5nZXRJbm5lclRleHQodGhpcy5kb20uZmllbGQpO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKHRoaXMuZmllbGRJbm5lclRleHQgIT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgIHRyeSB7XFxuXFx0ICAgICAgdmFyIGZpZWxkID0gdGhpcy5fdW5lc2NhcGVIVE1MKHRoaXMuZmllbGRJbm5lclRleHQpO1xcblxcblxcdCAgICAgIGlmIChmaWVsZCAhPT0gdGhpcy5maWVsZCkge1xcblxcdCAgICAgICAgdmFyIG9sZEZpZWxkID0gdGhpcy5maWVsZDtcXG5cXHQgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLl9vbkFjdGlvbignZWRpdEZpZWxkJywge1xcblxcdCAgICAgICAgICAnbm9kZSc6IHRoaXMsXFxuXFx0ICAgICAgICAgICdvbGRWYWx1ZSc6IG9sZEZpZWxkLFxcblxcdCAgICAgICAgICAnbmV3VmFsdWUnOiBmaWVsZCxcXG5cXHQgICAgICAgICAgJ29sZFNlbGVjdGlvbic6IHRoaXMuZWRpdG9yLnNlbGVjdGlvbixcXG5cXHQgICAgICAgICAgJ25ld1NlbGVjdGlvbic6IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpXFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgY2F0Y2ggKGVycikge1xcblxcdCAgICAgIHRoaXMuZmllbGQgPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgLy8gVE9ETzogc2VudCBhbiBhY3Rpb24gaGVyZSwgd2l0aCB0aGUgbmV3LCBpbnZhbGlkIHZhbHVlP1xcblxcdCAgICAgIGlmIChzaWxlbnQgIT09IHRydWUpIHtcXG5cXHQgICAgICAgIHRocm93IGVycjtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENsZWFyIHRoZSBkb20gb2YgdGhlIG5vZGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5jbGVhckRvbSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgLy8gVE9ETzogaGlkZSB0aGUgbm9kZSBmaXJzdD9cXG5cXHQgIC8vdGhpcy5oaWRlKCk7XFxuXFx0ICAvLyBUT0RPOiByZWN1cnNpdmVseSBjbGVhciBkb20/XFxuXFxuXFx0ICB0aGlzLmRvbSA9IHt9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSBIVE1MIERPTSBUUiBlbGVtZW50IG9mIHRoZSBub2RlLlxcblxcdCAqIFRoZSBkb20gd2lsbCBiZSBnZW5lcmF0ZWQgd2hlbiBub3QgeWV0IGNyZWF0ZWRcXG5cXHQgKiBAcmV0dXJuIHtFbGVtZW50fSB0ciAgICBIVE1MIERPTSBUUiBFbGVtZW50XFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuZ2V0RG9tID0gZnVuY3Rpb24oKSB7XFxuXFx0ICB2YXIgZG9tID0gdGhpcy5kb207XFxuXFx0ICBpZiAoZG9tLnRyKSB7XFxuXFx0ICAgIHJldHVybiBkb20udHI7XFxuXFx0ICB9XFxuXFxuXFx0ICB0aGlzLl91cGRhdGVFZGl0YWJpbGl0eSgpO1xcblxcblxcdCAgLy8gY3JlYXRlIHJvd1xcblxcdCAgZG9tLnRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcXG5cXHQgIGRvbS50ci5ub2RlID0gdGhpcztcXG5cXG5cXHQgIGlmICh0aGlzLmVkaXRvci5vcHRpb25zLm1vZGUgPT09ICd0cmVlJykgeyAvLyBub3RlOiB3ZSB0YWtlIGhlcmUgdGhlIGdsb2JhbCBzZXR0aW5nXFxuXFx0ICAgIHZhciB0ZERyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xcblxcdCAgICBpZiAodGhpcy5lZGl0YWJsZS5maWVsZCkge1xcblxcdCAgICAgIC8vIGNyZWF0ZSBkcmFnZ2FibGUgYXJlYVxcblxcdCAgICAgIGlmICh0aGlzLnBhcmVudCkge1xcblxcdCAgICAgICAgdmFyIGRvbURyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgICAgICAgIGRvbS5kcmFnID0gZG9tRHJhZztcXG5cXHQgICAgICAgIGRvbURyYWcuY2xhc3NOYW1lID0gJ2RyYWdhcmVhJztcXG5cXHQgICAgICAgIGRvbURyYWcudGl0bGUgPSAnRHJhZyB0byBtb3ZlIHRoaXMgZmllbGQgKEFsdCtTaGlmdCtBcnJvd3MpJztcXG5cXHQgICAgICAgIHRkRHJhZy5hcHBlbmRDaGlsZChkb21EcmFnKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgZG9tLnRyLmFwcGVuZENoaWxkKHRkRHJhZyk7XFxuXFxuXFx0ICAgIC8vIGNyZWF0ZSBjb250ZXh0IG1lbnVcXG5cXHQgICAgdmFyIHRkTWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICAgIHZhciBtZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxuXFx0ICAgIGRvbS5tZW51ID0gbWVudTtcXG5cXHQgICAgbWVudS5jbGFzc05hbWUgPSAnY29udGV4dG1lbnUnO1xcblxcdCAgICBtZW51LnRpdGxlID0gJ0NsaWNrIHRvIG9wZW4gdGhlIGFjdGlvbnMgbWVudSAoQ3RybCtNKSc7XFxuXFx0ICAgIHRkTWVudS5hcHBlbmRDaGlsZChkb20ubWVudSk7XFxuXFx0ICAgIGRvbS50ci5hcHBlbmRDaGlsZCh0ZE1lbnUpO1xcblxcdCAgfVxcblxcblxcdCAgLy8gY3JlYXRlIHRyZWUgYW5kIGZpZWxkXFxuXFx0ICB2YXIgdGRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICBkb20udHIuYXBwZW5kQ2hpbGQodGRGaWVsZCk7XFxuXFx0ICBkb20udHJlZSA9IHRoaXMuX2NyZWF0ZURvbVRyZWUoKTtcXG5cXHQgIHRkRmllbGQuYXBwZW5kQ2hpbGQoZG9tLnRyZWUpO1xcblxcblxcdCAgdGhpcy51cGRhdGVEb20oeyd1cGRhdGVJbmRleGVzJzogdHJ1ZX0pO1xcblxcblxcdCAgcmV0dXJuIGRvbS50cjtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERyYWdTdGFydCBldmVudCwgZmlyZWQgb24gbW91c2Vkb3duIG9uIHRoZSBkcmFnYXJlYSBhdCB0aGUgbGVmdCBzaWRlIG9mIGEgTm9kZVxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fb25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgIHZhciBub2RlID0gdGhpcztcXG5cXHQgIGlmICghdGhpcy5tb3VzZW1vdmUpIHtcXG5cXHQgICAgdGhpcy5tb3VzZW1vdmUgPSB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZW1vdmUnLFxcblxcdCAgICAgICAgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICAgICAgICAgIG5vZGUuX29uRHJhZyhldmVudCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICghdGhpcy5tb3VzZXVwKSB7XFxuXFx0ICAgIHRoaXMubW91c2V1cCA9IHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ21vdXNldXAnLFxcblxcdCAgICAgICAgZnVuY3Rpb24gKGV2ZW50ICkge1xcblxcdCAgICAgICAgICBub2RlLl9vbkRyYWdFbmQoZXZlbnQpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICB9XFxuXFxuXFx0ICB0aGlzLmVkaXRvci5oaWdobGlnaHRlci5sb2NrKCk7XFxuXFx0ICB0aGlzLmRyYWcgPSB7XFxuXFx0ICAgICdvbGRDdXJzb3InOiBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvcixcXG5cXHQgICAgJ3N0YXJ0UGFyZW50JzogdGhpcy5wYXJlbnQsXFxuXFx0ICAgICdzdGFydEluZGV4JzogdGhpcy5wYXJlbnQuY2hpbGRzLmluZGV4T2YodGhpcyksXFxuXFx0ICAgICdtb3VzZVgnOiBldmVudC5wYWdlWCxcXG5cXHQgICAgJ2xldmVsJzogdGhpcy5nZXRMZXZlbCgpXFxuXFx0ICB9O1xcblxcdCAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XFxuXFxuXFx0ICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRHJhZyBldmVudCwgZmlyZWQgd2hlbiBtb3ZpbmcgdGhlIG1vdXNlIHdoaWxlIGRyYWdnaW5nIGEgTm9kZVxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICAvLyBUT0RPOiB0aGlzIG1ldGhvZCBoYXMgZ3Jvd24gdG9vIGxhcmdlLiBTcGxpdCBpdCBpbiBhIG51bWJlciBvZiBtZXRob2RzXFxuXFx0ICB2YXIgbW91c2VZID0gZXZlbnQucGFnZVk7XFxuXFx0ICB2YXIgbW91c2VYID0gZXZlbnQucGFnZVg7XFxuXFxuXFx0ICB2YXIgdHJUaGlzLCB0clByZXYsIHRyTmV4dCwgdHJGaXJzdCwgdHJMYXN0LCB0clJvb3Q7XFxuXFx0ICB2YXIgbm9kZVByZXYsIG5vZGVOZXh0O1xcblxcdCAgdmFyIHRvcFRoaXMsIHRvcFByZXYsIHRvcEZpcnN0LCBoZWlnaHRUaGlzLCBib3R0b21OZXh0LCBoZWlnaHROZXh0O1xcblxcdCAgdmFyIG1vdmVkID0gZmFsc2U7XFxuXFxuXFx0ICAvLyBUT0RPOiBhZGQgYW4gRVNDIG9wdGlvbiwgd2hpY2ggcmVzZXRzIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxcblxcblxcdCAgLy8gbW92ZSB1cC9kb3duXFxuXFx0ICB0clRoaXMgPSB0aGlzLmRvbS50cjtcXG5cXHQgIHRvcFRoaXMgPSB1dGlsLmdldEFic29sdXRlVG9wKHRyVGhpcyk7XFxuXFx0ICBoZWlnaHRUaGlzID0gdHJUaGlzLm9mZnNldEhlaWdodDtcXG5cXHQgIGlmIChtb3VzZVkgPCB0b3BUaGlzKSB7XFxuXFx0ICAgIC8vIG1vdmUgdXBcXG5cXHQgICAgdHJQcmV2ID0gdHJUaGlzO1xcblxcdCAgICBkbyB7XFxuXFx0ICAgICAgdHJQcmV2ID0gdHJQcmV2LnByZXZpb3VzU2libGluZztcXG5cXHQgICAgICBub2RlUHJldiA9IE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQodHJQcmV2KTtcXG5cXHQgICAgICB0b3BQcmV2ID0gdHJQcmV2ID8gdXRpbC5nZXRBYnNvbHV0ZVRvcCh0clByZXYpIDogMDtcXG5cXHQgICAgfVxcblxcdCAgICB3aGlsZSAodHJQcmV2ICYmIG1vdXNlWSA8IHRvcFByZXYpO1xcblxcblxcdCAgICBpZiAobm9kZVByZXYgJiYgIW5vZGVQcmV2LnBhcmVudCkge1xcblxcdCAgICAgIG5vZGVQcmV2ID0gdW5kZWZpbmVkO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICghbm9kZVByZXYpIHtcXG5cXHQgICAgICAvLyBtb3ZlIHRvIHRoZSBmaXJzdCBub2RlXFxuXFx0ICAgICAgdHJSb290ID0gdHJUaGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZDtcXG5cXHQgICAgICB0clByZXYgPSB0clJvb3QgPyB0clJvb3QubmV4dFNpYmxpbmcgOiB1bmRlZmluZWQ7XFxuXFx0ICAgICAgbm9kZVByZXYgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KHRyUHJldik7XFxuXFx0ICAgICAgaWYgKG5vZGVQcmV2ID09IHRoaXMpIHtcXG5cXHQgICAgICAgIG5vZGVQcmV2ID0gdW5kZWZpbmVkO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAobm9kZVByZXYpIHtcXG5cXHQgICAgICAvLyBjaGVjayBpZiBtb3VzZVkgaXMgcmVhbGx5IGluc2lkZSB0aGUgZm91bmQgbm9kZVxcblxcdCAgICAgIHRyUHJldiA9IG5vZGVQcmV2LmRvbS50cjtcXG5cXHQgICAgICB0b3BQcmV2ID0gdHJQcmV2ID8gdXRpbC5nZXRBYnNvbHV0ZVRvcCh0clByZXYpIDogMDtcXG5cXHQgICAgICBpZiAobW91c2VZID4gdG9wUHJldiArIGhlaWdodFRoaXMpIHtcXG5cXHQgICAgICAgIG5vZGVQcmV2ID0gdW5kZWZpbmVkO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAobm9kZVByZXYpIHtcXG5cXHQgICAgICBub2RlUHJldi5wYXJlbnQubW92ZUJlZm9yZSh0aGlzLCBub2RlUHJldik7XFxuXFx0ICAgICAgbW92ZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgLy8gbW92ZSBkb3duXFxuXFx0ICAgIHRyTGFzdCA9ICh0aGlzLmV4cGFuZGVkICYmIHRoaXMuYXBwZW5kKSA/IHRoaXMuYXBwZW5kLmdldERvbSgpIDogdGhpcy5kb20udHI7XFxuXFx0ICAgIHRyRmlyc3QgPSB0ckxhc3QgPyB0ckxhc3QubmV4dFNpYmxpbmcgOiB1bmRlZmluZWQ7XFxuXFx0ICAgIGlmICh0ckZpcnN0KSB7XFxuXFx0ICAgICAgdG9wRmlyc3QgPSB1dGlsLmdldEFic29sdXRlVG9wKHRyRmlyc3QpO1xcblxcdCAgICAgIHRyTmV4dCA9IHRyRmlyc3Q7XFxuXFx0ICAgICAgZG8ge1xcblxcdCAgICAgICAgbm9kZU5leHQgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KHRyTmV4dCk7XFxuXFx0ICAgICAgICBpZiAodHJOZXh0KSB7XFxuXFx0ICAgICAgICAgIGJvdHRvbU5leHQgPSB0ck5leHQubmV4dFNpYmxpbmcgP1xcblxcdCAgICAgICAgICAgICAgdXRpbC5nZXRBYnNvbHV0ZVRvcCh0ck5leHQubmV4dFNpYmxpbmcpIDogMDtcXG5cXHQgICAgICAgICAgaGVpZ2h0TmV4dCA9IHRyTmV4dCA/IChib3R0b21OZXh0IC0gdG9wRmlyc3QpIDogMDtcXG5cXG5cXHQgICAgICAgICAgaWYgKG5vZGVOZXh0LnBhcmVudC5jaGlsZHMubGVuZ3RoID09IDEgJiYgbm9kZU5leHQucGFyZW50LmNoaWxkc1swXSA9PSB0aGlzKSB7XFxuXFx0ICAgICAgICAgICAgLy8gV2UgYXJlIGFib3V0IHRvIHJlbW92ZSB0aGUgbGFzdCBjaGlsZCBvZiB0aGlzIHBhcmVudCxcXG5cXHQgICAgICAgICAgICAvLyB3aGljaCB3aWxsIG1ha2UgdGhlIHBhcmVudHMgYXBwZW5kTm9kZSB2aXNpYmxlLlxcblxcdCAgICAgICAgICAgIHRvcFRoaXMgKz0gMjQgLSAxO1xcblxcdCAgICAgICAgICAgIC8vIFRPRE86IGRhbmdlcm91cyB0byBzdXBwb3NlIHRoZSBoZWlnaHQgb2YgdGhlIGFwcGVuZE5vZGUgYSBjb25zdGFudCBvZiAyNC0xIHB4LlxcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0ck5leHQgPSB0ck5leHQubmV4dFNpYmxpbmc7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIHdoaWxlICh0ck5leHQgJiYgbW91c2VZID4gdG9wVGhpcyArIGhlaWdodE5leHQpO1xcblxcblxcdCAgICAgIGlmIChub2RlTmV4dCAmJiBub2RlTmV4dC5wYXJlbnQpIHtcXG5cXHQgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVzaXJlZCBsZXZlbFxcblxcdCAgICAgICAgdmFyIGRpZmZYID0gKG1vdXNlWCAtIHRoaXMuZHJhZy5tb3VzZVgpO1xcblxcdCAgICAgICAgdmFyIGRpZmZMZXZlbCA9IE1hdGgucm91bmQoZGlmZlggLyAyNCAvIDIpO1xcblxcdCAgICAgICAgdmFyIGxldmVsID0gdGhpcy5kcmFnLmxldmVsICsgZGlmZkxldmVsOyAvLyBkZXNpcmVkIGxldmVsXFxuXFx0ICAgICAgICB2YXIgbGV2ZWxOZXh0ID0gbm9kZU5leHQuZ2V0TGV2ZWwoKTsgICAgIC8vIGxldmVsIHRvIGJlXFxuXFxuXFx0ICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IGZpdHRpbmcgbGV2ZWwgKG1vdmUgdXB3YXJkcyBvdmVyIHRoZSBhcHBlbmQgbm9kZXMpXFxuXFx0ICAgICAgICB0clByZXYgPSBub2RlTmV4dC5kb20udHIucHJldmlvdXNTaWJsaW5nO1xcblxcdCAgICAgICAgd2hpbGUgKGxldmVsTmV4dCA8IGxldmVsICYmIHRyUHJldikge1xcblxcdCAgICAgICAgICBub2RlUHJldiA9IE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQodHJQcmV2KTtcXG5cXHQgICAgICAgICAgaWYgKG5vZGVQcmV2ID09IHRoaXMgfHwgbm9kZVByZXYuX2lzQ2hpbGRPZih0aGlzKSkge1xcblxcdCAgICAgICAgICAgIC8vIG5lZ2xlY3QgaXRzZWxmIGFuZCBpdHMgY2hpbGRzXFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgZWxzZSBpZiAobm9kZVByZXYgaW5zdGFuY2VvZiBBcHBlbmROb2RlKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGNoaWxkcyA9IG5vZGVQcmV2LnBhcmVudC5jaGlsZHM7XFxuXFx0ICAgICAgICAgICAgaWYgKGNoaWxkcy5sZW5ndGggPiAxIHx8XFxuXFx0ICAgICAgICAgICAgICAgIChjaGlsZHMubGVuZ3RoID09IDEgJiYgY2hpbGRzWzBdICE9IHRoaXMpKSB7XFxuXFx0ICAgICAgICAgICAgICAvLyBub24tdmlzaWJsZSBhcHBlbmQgbm9kZSBvZiBhIGxpc3Qgb2YgY2hpbGRzXFxuXFx0ICAgICAgICAgICAgICAvLyBjb25zaXN0aW5nIG9mIG5vdCBvbmx5IHRoaXMgbm9kZSAoZWxzZSB0aGVcXG5cXHQgICAgICAgICAgICAgIC8vIGFwcGVuZCBub2RlIHdpbGwgY2hhbmdlIGludG8gYSB2aXNpYmxlIFxcXCJlbXB0eVxcXCJcXG5cXHQgICAgICAgICAgICAgIC8vIHRleHQgd2hlbiByZW1vdmluZyB0aGlzIG5vZGUpLlxcblxcdCAgICAgICAgICAgICAgbm9kZU5leHQgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KHRyUHJldik7XFxuXFx0ICAgICAgICAgICAgICBsZXZlbE5leHQgPSBub2RlTmV4dC5nZXRMZXZlbCgpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICB0clByZXYgPSB0clByZXYucHJldmlvdXNTaWJsaW5nO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgLy8gbW92ZSB0aGUgbm9kZSB3aGVuIGl0cyBwb3NpdGlvbiBpcyBjaGFuZ2VkXFxuXFx0ICAgICAgICBpZiAodHJMYXN0Lm5leHRTaWJsaW5nICE9IG5vZGVOZXh0LmRvbS50cikge1xcblxcdCAgICAgICAgICBub2RlTmV4dC5wYXJlbnQubW92ZUJlZm9yZSh0aGlzLCBub2RlTmV4dCk7XFxuXFx0ICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChtb3ZlZCkge1xcblxcdCAgICAvLyB1cGRhdGUgdGhlIGRyYWdnaW5nIHBhcmFtZXRlcnMgd2hlbiBtb3ZlZFxcblxcdCAgICB0aGlzLmRyYWcubW91c2VYID0gbW91c2VYO1xcblxcdCAgICB0aGlzLmRyYWcubGV2ZWwgPSB0aGlzLmdldExldmVsKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBhdXRvIHNjcm9sbCB3aGVuIGhvdmVyaW5nIGFyb3VuZCB0aGUgdG9wIG9mIHRoZSBlZGl0b3JcXG5cXHQgIHRoaXMuZWRpdG9yLnN0YXJ0QXV0b1Njcm9sbChtb3VzZVkpO1xcblxcblxcdCAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIERyYWcgZXZlbnQsIGZpcmVkIG9uIG1vdXNldXAgYWZ0ZXIgaGF2aW5nIGRyYWdnZWQgYSBub2RlXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9vbkRyYWdFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgIHZhciBwYXJhbXMgPSB7XFxuXFx0ICAgICdub2RlJzogdGhpcyxcXG5cXHQgICAgJ3N0YXJ0UGFyZW50JzogdGhpcy5kcmFnLnN0YXJ0UGFyZW50LFxcblxcdCAgICAnc3RhcnRJbmRleCc6IHRoaXMuZHJhZy5zdGFydEluZGV4LFxcblxcdCAgICAnZW5kUGFyZW50JzogdGhpcy5wYXJlbnQsXFxuXFx0ICAgICdlbmRJbmRleCc6IHRoaXMucGFyZW50LmNoaWxkcy5pbmRleE9mKHRoaXMpXFxuXFx0ICB9O1xcblxcdCAgaWYgKChwYXJhbXMuc3RhcnRQYXJlbnQgIT0gcGFyYW1zLmVuZFBhcmVudCkgfHxcXG5cXHQgICAgICAocGFyYW1zLnN0YXJ0SW5kZXggIT0gcGFyYW1zLmVuZEluZGV4KSkge1xcblxcdCAgICAvLyBvbmx5IHJlZ2lzdGVyIHRoaXMgYWN0aW9uIGlmIHRoZSBub2RlIGlzIGFjdHVhbGx5IG1vdmVkIHRvIGFub3RoZXIgcGxhY2VcXG5cXHQgICAgdGhpcy5lZGl0b3IuX29uQWN0aW9uKCdtb3ZlTm9kZScsIHBhcmFtcyk7XFxuXFx0ICB9XFxuXFxuXFx0ICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9IHRoaXMuZHJhZy5vbGRDdXJzb3I7XFxuXFx0ICB0aGlzLmVkaXRvci5oaWdobGlnaHRlci51bmxvY2soKTtcXG5cXHQgIGRlbGV0ZSB0aGlzLmRyYWc7XFxuXFxuXFx0ICBpZiAodGhpcy5tb3VzZW1vdmUpIHtcXG5cXHQgICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5tb3VzZW1vdmUpO1xcblxcdCAgICBkZWxldGUgdGhpcy5tb3VzZW1vdmU7fVxcblxcdCAgaWYgKHRoaXMubW91c2V1cCkge1xcblxcdCAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5tb3VzZXVwKTtcXG5cXHQgICAgZGVsZXRlIHRoaXMubW91c2V1cDtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIFN0b3AgYW55IHJ1bm5pbmcgYXV0byBzY3JvbGxcXG5cXHQgIHRoaXMuZWRpdG9yLnN0b3BBdXRvU2Nyb2xsKCk7XFxuXFxuXFx0ICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGVzdCBpZiB0aGlzIG5vZGUgaXMgYSBjaGlsZCBvZiBhbiBvdGhlciBub2RlXFxuXFx0ICogQHBhcmFtIHtOb2RlfSBub2RlXFxuXFx0ICogQHJldHVybiB7Ym9vbGVhbn0gaXNDaGlsZFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2lzQ2hpbGRPZiA9IGZ1bmN0aW9uIChub2RlKSB7XFxuXFx0ICB2YXIgbiA9IHRoaXMucGFyZW50O1xcblxcdCAgd2hpbGUgKG4pIHtcXG5cXHQgICAgaWYgKG4gPT0gbm9kZSkge1xcblxcdCAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICAgIG4gPSBuLnBhcmVudDtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBmYWxzZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIENyZWF0ZSBhbiBlZGl0YWJsZSBmaWVsZFxcblxcdCAqIEByZXR1cm4ge0VsZW1lbnR9IGRvbUZpZWxkXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fY3JlYXRlRG9tRmllbGQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXQgaGlnaGxpZ2h0aW5nIGZvciB0aGlzIG5vZGUgYW5kIGFsbCBpdHMgY2hpbGRzLlxcblxcdCAqIE9ubHkgYXBwbGllZCB0byB0aGUgY3VycmVudGx5IHZpc2libGUgKGV4cGFuZGVkIGNoaWxkcylcXG5cXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGhpZ2hsaWdodFxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLnNldEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChoaWdobGlnaHQpIHtcXG5cXHQgIGlmICh0aGlzLmRvbS50cikge1xcblxcdCAgICB0aGlzLmRvbS50ci5jbGFzc05hbWUgPSAoaGlnaGxpZ2h0ID8gJ2hpZ2hsaWdodCcgOiAnJyk7XFxuXFxuXFx0ICAgIGlmICh0aGlzLmFwcGVuZCkge1xcblxcdCAgICAgIHRoaXMuYXBwZW5kLnNldEhpZ2hsaWdodChoaWdobGlnaHQpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICh0aGlzLmNoaWxkcykge1xcblxcdCAgICAgIHRoaXMuY2hpbGRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XFxuXFx0ICAgICAgICBjaGlsZC5zZXRIaWdobGlnaHQoaGlnaGxpZ2h0KTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZS4gT25seSBwcmltaXRpdmUgdHlwZXMgYXJlIGFsbG93ZWQsIG5vIE9iamVjdFxcblxcdCAqIG9yIEFycmF5IGlzIGFsbG93ZWQuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBCb29sZWFuIHwgbnVsbH0gdmFsdWVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS51cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgdGhpcy52YWx1ZSA9IHZhbHVlO1xcblxcdCAgdGhpcy51cGRhdGVEb20oKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZSB0aGUgZmllbGQgb2YgdGhlIG5vZGUuXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUudXBkYXRlRmllbGQgPSBmdW5jdGlvbiAoZmllbGQpIHtcXG5cXHQgIHRoaXMuZmllbGQgPSBmaWVsZDtcXG5cXHQgIHRoaXMudXBkYXRlRG9tKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVcGRhdGUgdGhlIEhUTUwgRE9NLCBvcHRpb25hbGx5IHJlY3Vyc2luZyB0aHJvdWdoIHRoZSBjaGlsZHNcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gW3JlY3Vyc2VdICAgICAgICAgSWYgdHJ1ZSwgdGhlXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIERPTSBvZiB0aGUgY2hpbGRzIHdpbGwgYmUgdXBkYXRlZCByZWN1cnNpdmVseS5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgRmFsc2UgYnkgZGVmYXVsdC5cXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAge2Jvb2xlYW59IFt1cGRhdGVJbmRleGVzXSAgIElmIHRydWUsIHRoZSBjaGlsZHNcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlcyBvZiB0aGUgbm9kZSB3aWxsIGJlIHVwZGF0ZWQgdG9vLiBGYWxzZSBieVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0LlxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLnVwZGF0ZURvbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuXFx0ICAvLyB1cGRhdGUgbGV2ZWwgaW5kZW50YXRpb25cXG5cXHQgIHZhciBkb21UcmVlID0gdGhpcy5kb20udHJlZTtcXG5cXHQgIGlmIChkb21UcmVlKSB7XFxuXFx0ICAgIGRvbVRyZWUuc3R5bGUubWFyZ2luTGVmdCA9IHRoaXMuZ2V0TGV2ZWwoKSAqIDI0ICsgJ3B4JztcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIHVwZGF0ZSBmaWVsZFxcblxcdCAgdmFyIGRvbUZpZWxkID0gdGhpcy5kb20uZmllbGQ7XFxuXFx0ICBpZiAoZG9tRmllbGQpIHtcXG5cXHQgICAgaWYgKHRoaXMuZmllbGRFZGl0YWJsZSkge1xcblxcdCAgICAgIC8vIHBhcmVudCBpcyBhbiBvYmplY3RcXG5cXHQgICAgICBkb21GaWVsZC5jb250ZW50RWRpdGFibGUgPSB0aGlzLmVkaXRhYmxlLmZpZWxkO1xcblxcdCAgICAgIGRvbUZpZWxkLnNwZWxsY2hlY2sgPSBmYWxzZTtcXG5cXHQgICAgICBkb21GaWVsZC5jbGFzc05hbWUgPSAnZmllbGQnO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgIC8vIHBhcmVudCBpcyBhbiBhcnJheSB0aGlzIGlzIHRoZSByb290IG5vZGVcXG5cXHQgICAgICBkb21GaWVsZC5jbGFzc05hbWUgPSAncmVhZG9ubHknO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHZhciBmaWVsZDtcXG5cXHQgICAgaWYgKHRoaXMuaW5kZXggIT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgZmllbGQgPSB0aGlzLmluZGV4O1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHRoaXMuZmllbGQgIT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgZmllbGQgPSB0aGlzLmZpZWxkO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHRoaXMuX2hhc0NoaWxkcygpKSB7XFxuXFx0ICAgICAgZmllbGQgPSB0aGlzLnR5cGU7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgZmllbGQgPSAnJztcXG5cXHQgICAgfVxcblxcdCAgICBkb21GaWVsZC5pbm5lckhUTUwgPSB0aGlzLl9lc2NhcGVIVE1MKGZpZWxkKTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIHVwZGF0ZSB2YWx1ZVxcblxcdCAgdmFyIGRvbVZhbHVlID0gdGhpcy5kb20udmFsdWU7XFxuXFx0ICBpZiAoZG9tVmFsdWUpIHtcXG5cXHQgICAgdmFyIGNvdW50ID0gdGhpcy5jaGlsZHMgPyB0aGlzLmNoaWxkcy5sZW5ndGggOiAwO1xcblxcdCAgICBpZiAodGhpcy50eXBlID09ICdhcnJheScpIHtcXG5cXHQgICAgICBkb21WYWx1ZS5pbm5lckhUTUwgPSAnWycgKyBjb3VudCArICddJztcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gJ29iamVjdCcpIHtcXG5cXHQgICAgICBkb21WYWx1ZS5pbm5lckhUTUwgPSAneycgKyBjb3VudCArICd9JztcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICBkb21WYWx1ZS5pbm5lckhUTUwgPSB0aGlzLl9lc2NhcGVIVE1MKHRoaXMudmFsdWUpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyB1cGRhdGUgZmllbGQgYW5kIHZhbHVlXFxuXFx0ICB0aGlzLl91cGRhdGVEb21GaWVsZCgpO1xcblxcdCAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcXG5cXG5cXHQgIC8vIHVwZGF0ZSBjaGlsZHMgaW5kZXhlc1xcblxcdCAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51cGRhdGVJbmRleGVzID09PSB0cnVlKSB7XFxuXFx0ICAgIC8vIHVwZGF0ZUluZGV4ZXMgaXMgdHJ1ZSBvciB1bmRlZmluZWRcXG5cXHQgICAgdGhpcy5fdXBkYXRlRG9tSW5kZXhlcygpO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWN1cnNlID09PSB0cnVlKSB7XFxuXFx0ICAgIC8vIHJlY3Vyc2UgaXMgdHJ1ZSBvciB1bmRlZmluZWQuIHVwZGF0ZSBjaGlsZHMgcmVjdXJzaXZlbHlcXG5cXHQgICAgaWYgKHRoaXMuY2hpbGRzKSB7XFxuXFx0ICAgICAgdGhpcy5jaGlsZHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcXG5cXHQgICAgICAgIGNoaWxkLnVwZGF0ZURvbShvcHRpb25zKTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gdXBkYXRlIHJvdyB3aXRoIGFwcGVuZCBidXR0b25cXG5cXHQgIGlmICh0aGlzLmFwcGVuZCkge1xcblxcdCAgICB0aGlzLmFwcGVuZC51cGRhdGVEb20oKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVwZGF0ZSB0aGUgRE9NIG9mIHRoZSBjaGlsZHMgb2YgYSBub2RlOiB1cGRhdGUgaW5kZXhlcyBhbmQgdW5kZWZpbmVkIGZpZWxkXFxuXFx0ICogbmFtZXMuXFxuXFx0ICogT25seSBhcHBsaWNhYmxlIHdoZW4gc3RydWN0dXJlIGlzIGFuIGFycmF5IG9yIG9iamVjdFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX3VwZGF0ZURvbUluZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB2YXIgZG9tVmFsdWUgPSB0aGlzLmRvbS52YWx1ZTtcXG5cXHQgIHZhciBjaGlsZHMgPSB0aGlzLmNoaWxkcztcXG5cXHQgIGlmIChkb21WYWx1ZSAmJiBjaGlsZHMpIHtcXG5cXHQgICAgaWYgKHRoaXMudHlwZSA9PSAnYXJyYXknKSB7XFxuXFx0ICAgICAgY2hpbGRzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xcblxcdCAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcXG5cXHQgICAgICAgIHZhciBjaGlsZEZpZWxkID0gY2hpbGQuZG9tLmZpZWxkO1xcblxcdCAgICAgICAgaWYgKGNoaWxkRmllbGQpIHtcXG5cXHQgICAgICAgICAgY2hpbGRGaWVsZC5pbm5lckhUTUwgPSBpbmRleDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT0gJ29iamVjdCcpIHtcXG5cXHQgICAgICBjaGlsZHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcXG5cXHQgICAgICAgIGlmIChjaGlsZC5pbmRleCAhPSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICAgICAgZGVsZXRlIGNoaWxkLmluZGV4O1xcblxcblxcdCAgICAgICAgICBpZiAoY2hpbGQuZmllbGQgPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICAgICAgY2hpbGQuZmllbGQgPSAnJztcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH0pO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGUgYW4gZWRpdGFibGUgdmFsdWVcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9jcmVhdGVEb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHZhciBkb21WYWx1ZTtcXG5cXG5cXHQgIGlmICh0aGlzLnR5cGUgPT0gJ2FycmF5Jykge1xcblxcdCAgICBkb21WYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgICBkb21WYWx1ZS5jbGFzc05hbWUgPSAncmVhZG9ubHknO1xcblxcdCAgICBkb21WYWx1ZS5pbm5lckhUTUwgPSAnWy4uLl0nO1xcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAodGhpcy50eXBlID09ICdvYmplY3QnKSB7XFxuXFx0ICAgIGRvbVZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuXFx0ICAgIGRvbVZhbHVlLmNsYXNzTmFtZSA9ICdyZWFkb25seSc7XFxuXFx0ICAgIGRvbVZhbHVlLmlubmVySFRNTCA9ICd7Li4ufSc7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgaWYgKCF0aGlzLmVkaXRhYmxlLnZhbHVlICYmIHV0aWwuaXNVcmwodGhpcy52YWx1ZSkpIHtcXG5cXHQgICAgICAvLyBjcmVhdGUgYSBsaW5rIGluIGNhc2Ugb2YgcmVhZC1vbmx5IGVkaXRvciBhbmQgdmFsdWUgY29udGFpbmluZyBhbiB1cmxcXG5cXHQgICAgICBkb21WYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcXG5cXHQgICAgICBkb21WYWx1ZS5jbGFzc05hbWUgPSAndmFsdWUnO1xcblxcdCAgICAgIGRvbVZhbHVlLmhyZWYgPSB0aGlzLnZhbHVlO1xcblxcdCAgICAgIGRvbVZhbHVlLnRhcmdldCA9ICdfYmxhbmsnO1xcblxcdCAgICAgIGRvbVZhbHVlLmlubmVySFRNTCA9IHRoaXMuX2VzY2FwZUhUTUwodGhpcy52YWx1ZSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgLy8gY3JlYXRlIGFuIGVkaXRhYmxlIG9yIHJlYWQtb25seSBkaXZcXG5cXHQgICAgICBkb21WYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgICAgIGRvbVZhbHVlLmNvbnRlbnRFZGl0YWJsZSA9IHRoaXMuZWRpdGFibGUudmFsdWU7XFxuXFx0ICAgICAgZG9tVmFsdWUuc3BlbGxjaGVjayA9IGZhbHNlO1xcblxcdCAgICAgIGRvbVZhbHVlLmNsYXNzTmFtZSA9ICd2YWx1ZSc7XFxuXFx0ICAgICAgZG9tVmFsdWUuaW5uZXJIVE1MID0gdGhpcy5fZXNjYXBlSFRNTCh0aGlzLnZhbHVlKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIGRvbVZhbHVlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlIGFuIGV4cGFuZC9jb2xsYXBzZSBidXR0b25cXG5cXHQgKiBAcmV0dXJuIHtFbGVtZW50fSBleHBhbmRcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9jcmVhdGVEb21FeHBhbmRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAvLyBjcmVhdGUgZXhwYW5kIGJ1dHRvblxcblxcdCAgdmFyIGV4cGFuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xcblxcdCAgaWYgKHRoaXMuX2hhc0NoaWxkcygpKSB7XFxuXFx0ICAgIGV4cGFuZC5jbGFzc05hbWUgPSB0aGlzLmV4cGFuZGVkID8gJ2V4cGFuZGVkJyA6ICdjb2xsYXBzZWQnO1xcblxcdCAgICBleHBhbmQudGl0bGUgPVxcblxcdCAgICAgICAgJ0NsaWNrIHRvIGV4cGFuZC9jb2xsYXBzZSB0aGlzIGZpZWxkIChDdHJsK0UpLiBcXFxcbicgK1xcblxcdCAgICAgICAgJ0N0cmwrQ2xpY2sgdG8gZXhwYW5kL2NvbGxhcHNlIGluY2x1ZGluZyBhbGwgY2hpbGRzLic7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgZXhwYW5kLmNsYXNzTmFtZSA9ICdpbnZpc2libGUnO1xcblxcdCAgICBleHBhbmQudGl0bGUgPSAnJztcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBleHBhbmQ7XFxuXFx0fTtcXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGUgYSBET00gdHJlZSBlbGVtZW50LCBjb250YWluaW5nIHRoZSBleHBhbmQvY29sbGFwc2UgYnV0dG9uXFxuXFx0ICogQHJldHVybiB7RWxlbWVudH0gZG9tVHJlZVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2NyZWF0ZURvbVRyZWUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB2YXIgZG9tID0gdGhpcy5kb207XFxuXFx0ICB2YXIgZG9tVHJlZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XFxuXFx0ICB2YXIgdGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xcblxcdCAgZG9tVHJlZS5zdHlsZS5ib3JkZXJDb2xsYXBzZSA9ICdjb2xsYXBzZSc7IC8vIFRPRE86IHB1dCBpbiBjc3NcXG5cXHQgIGRvbVRyZWUuY2xhc3NOYW1lID0gJ3ZhbHVlcyc7XFxuXFx0ICBkb21UcmVlLmFwcGVuZENoaWxkKHRib2R5KTtcXG5cXHQgIHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XFxuXFx0ICB0Ym9keS5hcHBlbmRDaGlsZCh0cik7XFxuXFxuXFx0ICAvLyBjcmVhdGUgZXhwYW5kIGJ1dHRvblxcblxcdCAgdmFyIHRkRXhwYW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcXG5cXHQgIHRkRXhwYW5kLmNsYXNzTmFtZSA9ICd0cmVlJztcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkRXhwYW5kKTtcXG5cXHQgIGRvbS5leHBhbmQgPSB0aGlzLl9jcmVhdGVEb21FeHBhbmRCdXR0b24oKTtcXG5cXHQgIHRkRXhwYW5kLmFwcGVuZENoaWxkKGRvbS5leHBhbmQpO1xcblxcdCAgZG9tLnRkRXhwYW5kID0gdGRFeHBhbmQ7XFxuXFxuXFx0ICAvLyBjcmVhdGUgdGhlIGZpZWxkXFxuXFx0ICB2YXIgdGRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICB0ZEZpZWxkLmNsYXNzTmFtZSA9ICd0cmVlJztcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkRmllbGQpO1xcblxcdCAgZG9tLmZpZWxkID0gdGhpcy5fY3JlYXRlRG9tRmllbGQoKTtcXG5cXHQgIHRkRmllbGQuYXBwZW5kQ2hpbGQoZG9tLmZpZWxkKTtcXG5cXHQgIGRvbS50ZEZpZWxkID0gdGRGaWVsZDtcXG5cXG5cXHQgIC8vIGNyZWF0ZSBhIHNlcGFyYXRvclxcblxcdCAgdmFyIHRkU2VwYXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcXG5cXHQgIHRkU2VwYXJhdG9yLmNsYXNzTmFtZSA9ICd0cmVlJztcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkU2VwYXJhdG9yKTtcXG5cXHQgIGlmICh0aGlzLnR5cGUgIT0gJ29iamVjdCcgJiYgdGhpcy50eXBlICE9ICdhcnJheScpIHtcXG5cXHQgICAgdGRTZXBhcmF0b3IuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJzonKSk7XFxuXFx0ICAgIHRkU2VwYXJhdG9yLmNsYXNzTmFtZSA9ICdzZXBhcmF0b3InO1xcblxcdCAgfVxcblxcdCAgZG9tLnRkU2VwYXJhdG9yID0gdGRTZXBhcmF0b3I7XFxuXFxuXFx0ICAvLyBjcmVhdGUgdGhlIHZhbHVlXFxuXFx0ICB2YXIgdGRWYWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICB0ZFZhbHVlLmNsYXNzTmFtZSA9ICd0cmVlJztcXG5cXHQgIHRyLmFwcGVuZENoaWxkKHRkVmFsdWUpO1xcblxcdCAgZG9tLnZhbHVlID0gdGhpcy5fY3JlYXRlRG9tVmFsdWUoKTtcXG5cXHQgIHRkVmFsdWUuYXBwZW5kQ2hpbGQoZG9tLnZhbHVlKTtcXG5cXHQgIGRvbS50ZFZhbHVlID0gdGRWYWx1ZTtcXG5cXG5cXHQgIHJldHVybiBkb21UcmVlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGFuZGxlIGFuIGV2ZW50LiBUaGUgZXZlbnQgaXMgY2F0Y2hlZCBjZW50cmFsbHkgYnkgdGhlIGVkaXRvclxcblxcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdCAgdmFyIHR5cGUgPSBldmVudC50eXBlLFxcblxcdCAgICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50LFxcblxcdCAgICAgIGRvbSA9IHRoaXMuZG9tLFxcblxcdCAgICAgIG5vZGUgPSB0aGlzLFxcblxcdCAgICAgIGZvY3VzTm9kZSxcXG5cXHQgICAgICBleHBhbmRhYmxlID0gdGhpcy5faGFzQ2hpbGRzKCk7XFxuXFxuXFx0ICAvLyBjaGVjayBpZiBtb3VzZSBpcyBvbiBtZW51IG9yIG9uIGRyYWdhcmVhLlxcblxcdCAgLy8gSWYgc28sIGhpZ2hsaWdodCBjdXJyZW50IHJvdyBhbmQgaXRzIGNoaWxkc1xcblxcdCAgaWYgKHRhcmdldCA9PSBkb20uZHJhZyB8fCB0YXJnZXQgPT0gZG9tLm1lbnUpIHtcXG5cXHQgICAgaWYgKHR5cGUgPT0gJ21vdXNlb3ZlcicpIHtcXG5cXHQgICAgICB0aGlzLmVkaXRvci5oaWdobGlnaHRlci5oaWdobGlnaHQodGhpcyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAodHlwZSA9PSAnbW91c2VvdXQnKSB7XFxuXFx0ICAgICAgdGhpcy5lZGl0b3IuaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gZHJhZyBldmVudHNcXG5cXHQgIGlmICh0eXBlID09ICdtb3VzZWRvd24nICYmIHRhcmdldCA9PSBkb20uZHJhZykge1xcblxcdCAgICB0aGlzLl9vbkRyYWdTdGFydChldmVudCk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBjb250ZXh0IG1lbnUgZXZlbnRzXFxuXFx0ICBpZiAodHlwZSA9PSAnY2xpY2snICYmIHRhcmdldCA9PSBkb20ubWVudSkge1xcblxcdCAgICB2YXIgaGlnaGxpZ2h0ZXIgPSBub2RlLmVkaXRvci5oaWdobGlnaHRlcjtcXG5cXHQgICAgaGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0KG5vZGUpO1xcblxcdCAgICBoaWdobGlnaHRlci5sb2NrKCk7XFxuXFx0ICAgIHV0aWwuYWRkQ2xhc3NOYW1lKGRvbS5tZW51LCAnc2VsZWN0ZWQnKTtcXG5cXHQgICAgdGhpcy5zaG93Q29udGV4dE1lbnUoZG9tLm1lbnUsIGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICB1dGlsLnJlbW92ZUNsYXNzTmFtZShkb20ubWVudSwgJ3NlbGVjdGVkJyk7XFxuXFx0ICAgICAgaGlnaGxpZ2h0ZXIudW5sb2NrKCk7XFxuXFx0ICAgICAgaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoKTtcXG5cXHQgICAgfSk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBleHBhbmQgZXZlbnRzXFxuXFx0ICBpZiAodHlwZSA9PSAnY2xpY2snICYmIHRhcmdldCA9PSBkb20uZXhwYW5kKSB7XFxuXFx0ICAgIGlmIChleHBhbmRhYmxlKSB7XFxuXFx0ICAgICAgdmFyIHJlY3Vyc2UgPSBldmVudC5jdHJsS2V5OyAvLyB3aXRoIGN0cmwta2V5LCBleHBhbmQvY29sbGFwc2UgYWxsXFxuXFx0ICAgICAgdGhpcy5fb25FeHBhbmQocmVjdXJzZSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIHZhbHVlIGV2ZW50c1xcblxcdCAgdmFyIGRvbVZhbHVlID0gZG9tLnZhbHVlO1xcblxcdCAgaWYgKHRhcmdldCA9PSBkb21WYWx1ZSkge1xcblxcdCAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcXG5cXHQgICAgc3dpdGNoICh0eXBlKSB7XFxuXFx0ICAgICAgY2FzZSAnZm9jdXMnOlxcblxcdCAgICAgICAgZm9jdXNOb2RlID0gdGhpcztcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2JsdXInOlxcblxcdCAgICAgIGNhc2UgJ2NoYW5nZSc6XFxuXFx0ICAgICAgICB0aGlzLl9nZXREb21WYWx1ZSh0cnVlKTtcXG5cXHQgICAgICAgIHRoaXMuX3VwZGF0ZURvbVZhbHVlKCk7XFxuXFx0ICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xcblxcdCAgICAgICAgICBkb21WYWx1ZS5pbm5lckhUTUwgPSB0aGlzLl9lc2NhcGVIVE1MKHRoaXMudmFsdWUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgYnJlYWs7XFxuXFxuXFx0ICAgICAgY2FzZSAnaW5wdXQnOlxcblxcdCAgICAgICAgdGhpcy5fZ2V0RG9tVmFsdWUodHJ1ZSk7XFxuXFx0ICAgICAgICB0aGlzLl91cGRhdGVEb21WYWx1ZSgpO1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFxuXFx0ICAgICAgY2FzZSAna2V5ZG93bic6XFxuXFx0ICAgICAgY2FzZSAnbW91c2Vkb3duJzpcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLnNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFxuXFx0ICAgICAgY2FzZSAnY2xpY2snOlxcblxcdCAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgIXRoaXMuZWRpdGFibGUudmFsdWUpIHtcXG5cXHQgICAgICAgICAgaWYgKHV0aWwuaXNVcmwodGhpcy52YWx1ZSkpIHtcXG5cXHQgICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLnZhbHVlLCAnX2JsYW5rJyk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2tleXVwJzpcXG5cXHQgICAgICAgIHRoaXMuX2dldERvbVZhbHVlKHRydWUpO1xcblxcdCAgICAgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2N1dCc6XFxuXFx0ICAgICAgY2FzZSAncGFzdGUnOlxcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIG5vZGUuX2dldERvbVZhbHVlKHRydWUpO1xcblxcdCAgICAgICAgICBub2RlLl91cGRhdGVEb21WYWx1ZSgpO1xcblxcdCAgICAgICAgfSwgMSk7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gZmllbGQgZXZlbnRzXFxuXFx0ICB2YXIgZG9tRmllbGQgPSBkb20uZmllbGQ7XFxuXFx0ICBpZiAodGFyZ2V0ID09IGRvbUZpZWxkKSB7XFxuXFx0ICAgIHN3aXRjaCAodHlwZSkge1xcblxcdCAgICAgIGNhc2UgJ2ZvY3VzJzpcXG5cXHQgICAgICAgIGZvY3VzTm9kZSA9IHRoaXM7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXG5cXHQgICAgICBjYXNlICdibHVyJzpcXG5cXHQgICAgICBjYXNlICdjaGFuZ2UnOlxcblxcdCAgICAgICAgdGhpcy5fZ2V0RG9tRmllbGQodHJ1ZSk7XFxuXFx0ICAgICAgICB0aGlzLl91cGRhdGVEb21GaWVsZCgpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuZmllbGQpIHtcXG5cXHQgICAgICAgICAgZG9tRmllbGQuaW5uZXJIVE1MID0gdGhpcy5fZXNjYXBlSFRNTCh0aGlzLmZpZWxkKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2lucHV0JzpcXG5cXHQgICAgICAgIHRoaXMuX2dldERvbUZpZWxkKHRydWUpO1xcblxcdCAgICAgICAgdGhpcy5fdXBkYXRlRG9tRmllbGQoKTtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2tleWRvd24nOlxcblxcdCAgICAgIGNhc2UgJ21vdXNlZG93bic6XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci5zZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2tleXVwJzpcXG5cXHQgICAgICAgIHRoaXMuX2dldERvbUZpZWxkKHRydWUpO1xcblxcdCAgICAgICAgdGhpcy5fdXBkYXRlRG9tRmllbGQoKTtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgIGNhc2UgJ2N1dCc6XFxuXFx0ICAgICAgY2FzZSAncGFzdGUnOlxcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIG5vZGUuX2dldERvbUZpZWxkKHRydWUpO1xcblxcdCAgICAgICAgICBub2RlLl91cGRhdGVEb21GaWVsZCgpO1xcblxcdCAgICAgICAgfSwgMSk7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gZm9jdXNcXG5cXHQgIC8vIHdoZW4gY2xpY2tlZCBpbiB3aGl0ZXNwYWNlIGxlZnQgb3IgcmlnaHQgZnJvbSB0aGUgZmllbGQgb3IgdmFsdWUsIHNldCBmb2N1c1xcblxcdCAgdmFyIGRvbVRyZWUgPSBkb20udHJlZTtcXG5cXHQgIGlmICh0YXJnZXQgPT0gZG9tVHJlZS5wYXJlbnROb2RlKSB7XFxuXFx0ICAgIHN3aXRjaCAodHlwZSkge1xcblxcdCAgICAgIGNhc2UgJ2NsaWNrJzpcXG5cXHQgICAgICAgIHZhciBsZWZ0ID0gKGV2ZW50Lm9mZnNldFggIT0gdW5kZWZpbmVkKSA/XFxuXFx0ICAgICAgICAgICAgKGV2ZW50Lm9mZnNldFggPCAodGhpcy5nZXRMZXZlbCgpICsgMSkgKiAyNCkgOlxcblxcdCAgICAgICAgICAgIChldmVudC5wYWdlWCA8IHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KGRvbS50ZFNlcGFyYXRvcikpOy8vIGZvciBGRlxcblxcdCAgICAgICAgaWYgKGxlZnQgfHwgZXhwYW5kYWJsZSkge1xcblxcdCAgICAgICAgICAvLyBub2RlIGlzIGV4cGFuZGFibGUgd2hlbiBpdCBpcyBhbiBvYmplY3Qgb3IgYXJyYXlcXG5cXHQgICAgICAgICAgaWYgKGRvbUZpZWxkKSB7XFxuXFx0ICAgICAgICAgICAgdXRpbC5zZXRFbmRPZkNvbnRlbnRFZGl0YWJsZShkb21GaWVsZCk7XFxuXFx0ICAgICAgICAgICAgZG9tRmllbGQuZm9jdXMoKTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgIGlmIChkb21WYWx1ZSkge1xcblxcdCAgICAgICAgICAgIHV0aWwuc2V0RW5kT2ZDb250ZW50RWRpdGFibGUoZG9tVmFsdWUpO1xcblxcdCAgICAgICAgICAgIGRvbVZhbHVlLmZvY3VzKCk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICBpZiAoKHRhcmdldCA9PSBkb20udGRFeHBhbmQgJiYgIWV4cGFuZGFibGUpIHx8IHRhcmdldCA9PSBkb20udGRGaWVsZCB8fFxcblxcdCAgICAgIHRhcmdldCA9PSBkb20udGRTZXBhcmF0b3IpIHtcXG5cXHQgICAgc3dpdGNoICh0eXBlKSB7XFxuXFx0ICAgICAgY2FzZSAnY2xpY2snOlxcblxcdCAgICAgICAgaWYgKGRvbUZpZWxkKSB7XFxuXFx0ICAgICAgICAgIHV0aWwuc2V0RW5kT2ZDb250ZW50RWRpdGFibGUoZG9tRmllbGQpO1xcblxcdCAgICAgICAgICBkb21GaWVsZC5mb2N1cygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0eXBlID09ICdrZXlkb3duJykge1xcblxcdCAgICB0aGlzLm9uS2V5RG93bihldmVudCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBLZXkgZG93biBldmVudCBoYW5kbGVyXFxuXFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgIHZhciBrZXludW0gPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xcblxcdCAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xcblxcdCAgdmFyIGN0cmxLZXkgPSBldmVudC5jdHJsS2V5O1xcblxcdCAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XFxuXFx0ICB2YXIgYWx0S2V5ID0gZXZlbnQuYWx0S2V5O1xcblxcdCAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcXG5cXHQgIHZhciBwcmV2Tm9kZSwgbmV4dE5vZGUsIG5leHREb20sIG5leHREb20yO1xcblxcdCAgdmFyIGVkaXRhYmxlID0gdGhpcy5lZGl0b3Iub3B0aW9ucy5tb2RlID09PSAndHJlZSc7XFxuXFxuXFx0ICAvLyB1dGlsLmxvZyhjdHJsS2V5LCBrZXludW0sIGV2ZW50LmNoYXJDb2RlKTsgLy8gVE9ETzogY2xlYW51cFxcblxcdCAgaWYgKGtleW51bSA9PSAxMykgeyAvLyBFbnRlclxcblxcdCAgICBpZiAodGFyZ2V0ID09IHRoaXMuZG9tLnZhbHVlKSB7XFxuXFx0ICAgICAgaWYgKCF0aGlzLmVkaXRhYmxlLnZhbHVlIHx8IGV2ZW50LmN0cmxLZXkpIHtcXG5cXHQgICAgICAgIGlmICh1dGlsLmlzVXJsKHRoaXMudmFsdWUpKSB7XFxuXFx0ICAgICAgICAgIHdpbmRvdy5vcGVuKHRoaXMudmFsdWUsICdfYmxhbmsnKTtcXG5cXHQgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKHRhcmdldCA9PSB0aGlzLmRvbS5leHBhbmQpIHtcXG5cXHQgICAgICB2YXIgZXhwYW5kYWJsZSA9IHRoaXMuX2hhc0NoaWxkcygpO1xcblxcdCAgICAgIGlmIChleHBhbmRhYmxlKSB7XFxuXFx0ICAgICAgICB2YXIgcmVjdXJzZSA9IGV2ZW50LmN0cmxLZXk7IC8vIHdpdGggY3RybC1rZXksIGV4cGFuZC9jb2xsYXBzZSBhbGxcXG5cXHQgICAgICAgIHRoaXMuX29uRXhwYW5kKHJlY3Vyc2UpO1xcblxcdCAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XFxuXFx0ICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSA2OCkgeyAgLy8gRFxcblxcdCAgICBpZiAoY3RybEtleSAmJiBlZGl0YWJsZSkgeyAgIC8vIEN0cmwrRFxcblxcdCAgICAgIHRoaXMuX29uRHVwbGljYXRlKCk7XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSA2OSkgeyAvLyBFXFxuXFx0ICAgIGlmIChjdHJsS2V5KSB7ICAgICAgIC8vIEN0cmwrRSBhbmQgQ3RybCtTaGlmdCtFXFxuXFx0ICAgICAgdGhpcy5fb25FeHBhbmQoc2hpZnRLZXkpOyAgLy8gcmVjdXJzZSA9IHNoaWZ0S2V5XFxuXFx0ICAgICAgdGFyZ2V0LmZvY3VzKCk7IC8vIFRPRE86IHNob3VsZCByZXN0b3JlIGZvY3VzIGluIGNhc2Ugb2YgcmVjdXJzaW5nIGV4cGFuZCAod2hpY2ggdGFrZXMgRE9NIG9mZmxpbmUpXFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSA3NyAmJiBlZGl0YWJsZSkgeyAvLyBNXFxuXFx0ICAgIGlmIChjdHJsS2V5KSB7IC8vIEN0cmwrTVxcblxcdCAgICAgIHRoaXMuc2hvd0NvbnRleHRNZW51KHRhcmdldCk7XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSA0NiAmJiBlZGl0YWJsZSkgeyAvLyBEZWxcXG5cXHQgICAgaWYgKGN0cmxLZXkpIHsgICAgICAgLy8gQ3RybCtEZWxcXG5cXHQgICAgICB0aGlzLl9vblJlbW92ZSgpO1xcblxcdCAgICAgIGhhbmRsZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICBlbHNlIGlmIChrZXludW0gPT0gNDUgJiYgZWRpdGFibGUpIHsgLy8gSW5zXFxuXFx0ICAgIGlmIChjdHJsS2V5ICYmICFzaGlmdEtleSkgeyAgICAgICAvLyBDdHJsK0luc1xcblxcdCAgICAgIHRoaXMuX29uSW5zZXJ0QmVmb3JlKCk7XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAoY3RybEtleSAmJiBzaGlmdEtleSkgeyAgIC8vIEN0cmwrU2hpZnQrSW5zXFxuXFx0ICAgICAgdGhpcy5fb25JbnNlcnRBZnRlcigpO1xcblxcdCAgICAgIGhhbmRsZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICBlbHNlIGlmIChrZXludW0gPT0gMzUpIHsgLy8gRW5kXFxuXFx0ICAgIGlmIChhbHRLZXkpIHsgLy8gQWx0K0VuZFxcblxcdCAgICAgIC8vIGZpbmQgdGhlIGxhc3Qgbm9kZVxcblxcdCAgICAgIHZhciBsYXN0Tm9kZSA9IHRoaXMuX2xhc3ROb2RlKCk7XFxuXFx0ICAgICAgaWYgKGxhc3ROb2RlKSB7XFxuXFx0ICAgICAgICBsYXN0Tm9kZS5mb2N1cyhOb2RlLmZvY3VzRWxlbWVudCB8fCB0aGlzLl9nZXRFbGVtZW50TmFtZSh0YXJnZXQpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSAzNikgeyAvLyBIb21lXFxuXFx0ICAgIGlmIChhbHRLZXkpIHsgLy8gQWx0K0hvbWVcXG5cXHQgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBub2RlXFxuXFx0ICAgICAgdmFyIGZpcnN0Tm9kZSA9IHRoaXMuX2ZpcnN0Tm9kZSgpO1xcblxcdCAgICAgIGlmIChmaXJzdE5vZGUpIHtcXG5cXHQgICAgICAgIGZpcnN0Tm9kZS5mb2N1cyhOb2RlLmZvY3VzRWxlbWVudCB8fCB0aGlzLl9nZXRFbGVtZW50TmFtZSh0YXJnZXQpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSAzNykgeyAgICAgICAgLy8gQXJyb3cgTGVmdFxcblxcdCAgICBpZiAoYWx0S2V5ICYmICFzaGlmdEtleSkgeyAgLy8gQWx0ICsgQXJyb3cgTGVmdFxcblxcdCAgICAgIC8vIG1vdmUgdG8gbGVmdCBlbGVtZW50XFxuXFx0ICAgICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fcHJldmlvdXNFbGVtZW50KHRhcmdldCk7XFxuXFx0ICAgICAgaWYgKHByZXZFbGVtZW50KSB7XFxuXFx0ICAgICAgICB0aGlzLmZvY3VzKHRoaXMuX2dldEVsZW1lbnROYW1lKHByZXZFbGVtZW50KSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGhhbmRsZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKGFsdEtleSAmJiBzaGlmdEtleSAmJiBlZGl0YWJsZSkgeyAvLyBBbHQgKyBTaGlmdCBBcnJvdyBsZWZ0XFxuXFx0ICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcXG5cXHQgICAgICAgIHZhciBhcHBlbmREb20gPSB0aGlzLmdldEFwcGVuZCgpO1xcblxcdCAgICAgICAgbmV4dERvbSA9IGFwcGVuZERvbSA/IGFwcGVuZERvbS5uZXh0U2libGluZyA6IHVuZGVmaW5lZDtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICB2YXIgZG9tID0gdGhpcy5nZXREb20oKTtcXG5cXHQgICAgICAgIG5leHREb20gPSBkb20ubmV4dFNpYmxpbmc7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGlmIChuZXh0RG9tKSB7XFxuXFx0ICAgICAgICBuZXh0Tm9kZSA9IE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQobmV4dERvbSk7XFxuXFx0ICAgICAgICBuZXh0RG9tMiA9IG5leHREb20ubmV4dFNpYmxpbmc7XFxuXFx0ICAgICAgICBuZXh0Tm9kZTIgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KG5leHREb20yKTtcXG5cXHQgICAgICAgIGlmIChuZXh0Tm9kZSAmJiBuZXh0Tm9kZSBpbnN0YW5jZW9mIEFwcGVuZE5vZGUgJiZcXG5cXHQgICAgICAgICAgICAhKHRoaXMucGFyZW50LmNoaWxkcy5sZW5ndGggPT0gMSkgJiZcXG5cXHQgICAgICAgICAgICBuZXh0Tm9kZTIgJiYgbmV4dE5vZGUyLnBhcmVudCkge1xcblxcdCAgICAgICAgICBuZXh0Tm9kZTIucGFyZW50Lm1vdmVCZWZvcmUodGhpcywgbmV4dE5vZGUyKTtcXG5cXHQgICAgICAgICAgdGhpcy5mb2N1cyhOb2RlLmZvY3VzRWxlbWVudCB8fCB0aGlzLl9nZXRFbGVtZW50TmFtZSh0YXJnZXQpKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSAzOCkgeyAgICAgICAgLy8gQXJyb3cgVXBcXG5cXHQgICAgaWYgKGFsdEtleSAmJiAhc2hpZnRLZXkpIHsgIC8vIEFsdCArIEFycm93IFVwXFxuXFx0ICAgICAgLy8gZmluZCB0aGUgcHJldmlvdXMgbm9kZVxcblxcdCAgICAgIHByZXZOb2RlID0gdGhpcy5fcHJldmlvdXNOb2RlKCk7XFxuXFx0ICAgICAgaWYgKHByZXZOb2RlKSB7XFxuXFx0ICAgICAgICBwcmV2Tm9kZS5mb2N1cyhOb2RlLmZvY3VzRWxlbWVudCB8fCB0aGlzLl9nZXRFbGVtZW50TmFtZSh0YXJnZXQpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSBpZiAoYWx0S2V5ICYmIHNoaWZ0S2V5KSB7IC8vIEFsdCArIFNoaWZ0ICsgQXJyb3cgVXBcXG5cXHQgICAgICAvLyBmaW5kIHRoZSBwcmV2aW91cyBub2RlXFxuXFx0ICAgICAgcHJldk5vZGUgPSB0aGlzLl9wcmV2aW91c05vZGUoKTtcXG5cXHQgICAgICBpZiAocHJldk5vZGUgJiYgcHJldk5vZGUucGFyZW50KSB7XFxuXFx0ICAgICAgICBwcmV2Tm9kZS5wYXJlbnQubW92ZUJlZm9yZSh0aGlzLCBwcmV2Tm9kZSk7XFxuXFx0ICAgICAgICB0aGlzLmZvY3VzKE5vZGUuZm9jdXNFbGVtZW50IHx8IHRoaXMuX2dldEVsZW1lbnROYW1lKHRhcmdldCkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAoa2V5bnVtID09IDM5KSB7ICAgICAgICAvLyBBcnJvdyBSaWdodFxcblxcdCAgICBpZiAoYWx0S2V5ICYmICFzaGlmdEtleSkgeyAgLy8gQWx0ICsgQXJyb3cgUmlnaHRcXG5cXHQgICAgICAvLyBtb3ZlIHRvIHJpZ2h0IGVsZW1lbnRcXG5cXHQgICAgICB2YXIgbmV4dEVsZW1lbnQgPSB0aGlzLl9uZXh0RWxlbWVudCh0YXJnZXQpO1xcblxcdCAgICAgIGlmIChuZXh0RWxlbWVudCkge1xcblxcdCAgICAgICAgdGhpcy5mb2N1cyh0aGlzLl9nZXRFbGVtZW50TmFtZShuZXh0RWxlbWVudCkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmIChhbHRLZXkgJiYgc2hpZnRLZXkpIHsgLy8gQWx0ICsgU2hpZnQgQXJyb3cgUmlnaHRcXG5cXHQgICAgICBkb20gPSB0aGlzLmdldERvbSgpO1xcblxcdCAgICAgIHZhciBwcmV2RG9tID0gZG9tLnByZXZpb3VzU2libGluZztcXG5cXHQgICAgICBpZiAocHJldkRvbSkge1xcblxcdCAgICAgICAgcHJldk5vZGUgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KHByZXZEb20pO1xcblxcdCAgICAgICAgaWYgKHByZXZOb2RlICYmIHByZXZOb2RlLnBhcmVudCAmJlxcblxcdCAgICAgICAgICAgIChwcmV2Tm9kZSBpbnN0YW5jZW9mIEFwcGVuZE5vZGUpXFxuXFx0ICAgICAgICAgICAgJiYgIXByZXZOb2RlLmlzVmlzaWJsZSgpKSB7XFxuXFx0ICAgICAgICAgIHByZXZOb2RlLnBhcmVudC5tb3ZlQmVmb3JlKHRoaXMsIHByZXZOb2RlKTtcXG5cXHQgICAgICAgICAgdGhpcy5mb2N1cyhOb2RlLmZvY3VzRWxlbWVudCB8fCB0aGlzLl9nZXRFbGVtZW50TmFtZSh0YXJnZXQpKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSA0MCkgeyAgICAgICAgLy8gQXJyb3cgRG93blxcblxcdCAgICBpZiAoYWx0S2V5ICYmICFzaGlmdEtleSkgeyAgLy8gQWx0ICsgQXJyb3cgRG93blxcblxcdCAgICAgIC8vIGZpbmQgdGhlIG5leHQgbm9kZVxcblxcdCAgICAgIG5leHROb2RlID0gdGhpcy5fbmV4dE5vZGUoKTtcXG5cXHQgICAgICBpZiAobmV4dE5vZGUpIHtcXG5cXHQgICAgICAgIG5leHROb2RlLmZvY3VzKE5vZGUuZm9jdXNFbGVtZW50IHx8IHRoaXMuX2dldEVsZW1lbnROYW1lKHRhcmdldCkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmIChhbHRLZXkgJiYgc2hpZnRLZXkgJiYgZWRpdGFibGUpIHsgLy8gQWx0ICsgU2hpZnQgKyBBcnJvdyBEb3duXFxuXFx0ICAgICAgLy8gZmluZCB0aGUgMm5kIG5leHQgbm9kZSBhbmQgbW92ZSBiZWZvcmUgdGhhdCBvbmVcXG5cXHQgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xcblxcdCAgICAgICAgbmV4dE5vZGUgPSB0aGlzLmFwcGVuZCA/IHRoaXMuYXBwZW5kLl9uZXh0Tm9kZSgpIDogdW5kZWZpbmVkO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIHtcXG5cXHQgICAgICAgIG5leHROb2RlID0gdGhpcy5fbmV4dE5vZGUoKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgbmV4dERvbSA9IG5leHROb2RlID8gbmV4dE5vZGUuZ2V0RG9tKCkgOiB1bmRlZmluZWQ7XFxuXFx0ICAgICAgaWYgKHRoaXMucGFyZW50LmNoaWxkcy5sZW5ndGggPT0gMSkge1xcblxcdCAgICAgICAgbmV4dERvbTIgPSBuZXh0RG9tO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIHtcXG5cXHQgICAgICAgIG5leHREb20yID0gbmV4dERvbSA/IG5leHREb20ubmV4dFNpYmxpbmcgOiB1bmRlZmluZWQ7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIHZhciBuZXh0Tm9kZTIgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KG5leHREb20yKTtcXG5cXHQgICAgICBpZiAobmV4dE5vZGUyICYmIG5leHROb2RlMi5wYXJlbnQpIHtcXG5cXHQgICAgICAgIG5leHROb2RlMi5wYXJlbnQubW92ZUJlZm9yZSh0aGlzLCBuZXh0Tm9kZTIpO1xcblxcdCAgICAgICAgdGhpcy5mb2N1cyhOb2RlLmZvY3VzRWxlbWVudCB8fCB0aGlzLl9nZXRFbGVtZW50TmFtZSh0YXJnZXQpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChoYW5kbGVkKSB7XFxuXFx0ICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGFuZGxlIHRoZSBleHBhbmQgZXZlbnQsIHdoZW4gY2xpY2tlZCBvbiB0aGUgZXhwYW5kIGJ1dHRvblxcblxcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzZSAgIElmIHRydWUsIGNoaWxkIG5vZGVzIHdpbGwgYmUgZXhwYW5kZWQgdG9vXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fb25FeHBhbmQgPSBmdW5jdGlvbiAocmVjdXJzZSkge1xcblxcdCAgaWYgKHJlY3Vyc2UpIHtcXG5cXHQgICAgLy8gVGFrZSB0aGUgdGFibGUgb2ZmbGluZVxcblxcdCAgICB2YXIgdGFibGUgPSB0aGlzLmRvbS50ci5wYXJlbnROb2RlOyAvLyBUT0RPOiBub3QgbmljZSB0byBhY2Nlc3MgdGhlIG1haW4gdGFibGUgbGlrZSB0aGlzXFxuXFx0ICAgIHZhciBmcmFtZSA9IHRhYmxlLnBhcmVudE5vZGU7XFxuXFx0ICAgIHZhciBzY3JvbGxUb3AgPSBmcmFtZS5zY3JvbGxUb3A7XFxuXFx0ICAgIGZyYW1lLnJlbW92ZUNoaWxkKHRhYmxlKTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLmV4cGFuZGVkKSB7XFxuXFx0ICAgIHRoaXMuY29sbGFwc2UocmVjdXJzZSk7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIHtcXG5cXHQgICAgdGhpcy5leHBhbmQocmVjdXJzZSk7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAocmVjdXJzZSkge1xcblxcdCAgICAvLyBQdXQgdGhlIHRhYmxlIG9ubGluZSBhZ2FpblxcblxcdCAgICBmcmFtZS5hcHBlbmRDaGlsZCh0YWJsZSk7XFxuXFx0ICAgIGZyYW1lLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFJlbW92ZSB0aGlzIG5vZGVcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgdGhpcy5lZGl0b3IuaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoKTtcXG5cXHQgIHZhciBjaGlsZHMgPSB0aGlzLnBhcmVudC5jaGlsZHM7XFxuXFx0ICB2YXIgaW5kZXggPSBjaGlsZHMuaW5kZXhPZih0aGlzKTtcXG5cXG5cXHQgIC8vIGFkanVzdCB0aGUgZm9jdXNcXG5cXHQgIHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcXG5cXHQgIGlmIChjaGlsZHNbaW5kZXggKyAxXSkge1xcblxcdCAgICBjaGlsZHNbaW5kZXggKyAxXS5mb2N1cygpO1xcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAoY2hpbGRzW2luZGV4IC0gMV0pIHtcXG5cXHQgICAgY2hpbGRzW2luZGV4IC0gMV0uZm9jdXMoKTtcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICB0aGlzLnBhcmVudC5mb2N1cygpO1xcblxcdCAgfVxcblxcdCAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xcblxcblxcdCAgLy8gcmVtb3ZlIHRoZSBub2RlXFxuXFx0ICB0aGlzLnBhcmVudC5fcmVtb3ZlKHRoaXMpO1xcblxcblxcdCAgLy8gc3RvcmUgaGlzdG9yeSBhY3Rpb25cXG5cXHQgIHRoaXMuZWRpdG9yLl9vbkFjdGlvbigncmVtb3ZlTm9kZScsIHtcXG5cXHQgICAgbm9kZTogdGhpcyxcXG5cXHQgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcXG5cXHQgICAgaW5kZXg6IGluZGV4LFxcblxcdCAgICBvbGRTZWxlY3Rpb246IG9sZFNlbGVjdGlvbixcXG5cXHQgICAgbmV3U2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cXG5cXHQgIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRHVwbGljYXRlIHRoaXMgbm9kZVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX29uRHVwbGljYXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XFxuXFx0ICB2YXIgY2xvbmUgPSB0aGlzLnBhcmVudC5fZHVwbGljYXRlKHRoaXMpO1xcblxcdCAgY2xvbmUuZm9jdXMoKTtcXG5cXHQgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcXG5cXG5cXHQgIHRoaXMuZWRpdG9yLl9vbkFjdGlvbignZHVwbGljYXRlTm9kZScsIHtcXG5cXHQgICAgbm9kZTogdGhpcyxcXG5cXHQgICAgY2xvbmU6IGNsb25lLFxcblxcdCAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxcblxcdCAgICBvbGRTZWxlY3Rpb246IG9sZFNlbGVjdGlvbixcXG5cXHQgICAgbmV3U2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cXG5cXHQgIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGFuZGxlIGluc2VydCBiZWZvcmUgZXZlbnRcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gW2ZpZWxkXVxcblxcdCAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gICBDYW4gYmUgJ2F1dG8nLCAnYXJyYXknLCAnb2JqZWN0Jywgb3IgJ3N0cmluZydcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9vbkluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIHR5cGUpIHtcXG5cXHQgIHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcXG5cXG5cXHQgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUodGhpcy5lZGl0b3IsIHtcXG5cXHQgICAgZmllbGQ6IChmaWVsZCAhPSB1bmRlZmluZWQpID8gZmllbGQgOiAnJyxcXG5cXHQgICAgdmFsdWU6ICh2YWx1ZSAhPSB1bmRlZmluZWQpID8gdmFsdWUgOiAnJyxcXG5cXHQgICAgdHlwZTogdHlwZVxcblxcdCAgfSk7XFxuXFx0ICBuZXdOb2RlLmV4cGFuZCh0cnVlKTtcXG5cXHQgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZShuZXdOb2RlLCB0aGlzKTtcXG5cXHQgIHRoaXMuZWRpdG9yLmhpZ2hsaWdodGVyLnVuaGlnaGxpZ2h0KCk7XFxuXFx0ICBuZXdOb2RlLmZvY3VzKCdmaWVsZCcpO1xcblxcdCAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xcblxcblxcdCAgdGhpcy5lZGl0b3IuX29uQWN0aW9uKCdpbnNlcnRCZWZvcmVOb2RlJywge1xcblxcdCAgICBub2RlOiBuZXdOb2RlLFxcblxcdCAgICBiZWZvcmVOb2RlOiB0aGlzLFxcblxcdCAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxcblxcdCAgICBvbGRTZWxlY3Rpb246IG9sZFNlbGVjdGlvbixcXG5cXHQgICAgbmV3U2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cXG5cXHQgIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogSGFuZGxlIGluc2VydCBhZnRlciBldmVudFxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbZmllbGRdXFxuXFx0ICogQHBhcmFtIHsqfSBbdmFsdWVdXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSAgIENhbiBiZSAnYXV0bycsICdhcnJheScsICdvYmplY3QnLCBvciAnc3RyaW5nJ1xcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX29uSW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZmllbGQsIHZhbHVlLCB0eXBlKSB7XFxuXFx0ICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XFxuXFxuXFx0ICB2YXIgbmV3Tm9kZSA9IG5ldyBOb2RlKHRoaXMuZWRpdG9yLCB7XFxuXFx0ICAgIGZpZWxkOiAoZmllbGQgIT0gdW5kZWZpbmVkKSA/IGZpZWxkIDogJycsXFxuXFx0ICAgIHZhbHVlOiAodmFsdWUgIT0gdW5kZWZpbmVkKSA/IHZhbHVlIDogJycsXFxuXFx0ICAgIHR5cGU6IHR5cGVcXG5cXHQgIH0pO1xcblxcdCAgbmV3Tm9kZS5leHBhbmQodHJ1ZSk7XFxuXFx0ICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcihuZXdOb2RlLCB0aGlzKTtcXG5cXHQgIHRoaXMuZWRpdG9yLmhpZ2hsaWdodGVyLnVuaGlnaGxpZ2h0KCk7XFxuXFx0ICBuZXdOb2RlLmZvY3VzKCdmaWVsZCcpO1xcblxcdCAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xcblxcblxcdCAgdGhpcy5lZGl0b3IuX29uQWN0aW9uKCdpbnNlcnRBZnRlck5vZGUnLCB7XFxuXFx0ICAgIG5vZGU6IG5ld05vZGUsXFxuXFx0ICAgIGFmdGVyTm9kZTogdGhpcyxcXG5cXHQgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcXG5cXHQgICAgb2xkU2VsZWN0aW9uOiBvbGRTZWxlY3Rpb24sXFxuXFx0ICAgIG5ld1NlbGVjdGlvbjogbmV3U2VsZWN0aW9uXFxuXFx0ICB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZSBhcHBlbmQgZXZlbnRcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gW2ZpZWxkXVxcblxcdCAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gICBDYW4gYmUgJ2F1dG8nLCAnYXJyYXknLCAnb2JqZWN0Jywgb3IgJ3N0cmluZydcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9vbkFwcGVuZCA9IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIHR5cGUpIHtcXG5cXHQgIHZhciBvbGRTZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcXG5cXG5cXHQgIHZhciBuZXdOb2RlID0gbmV3IE5vZGUodGhpcy5lZGl0b3IsIHtcXG5cXHQgICAgZmllbGQ6IChmaWVsZCAhPSB1bmRlZmluZWQpID8gZmllbGQgOiAnJyxcXG5cXHQgICAgdmFsdWU6ICh2YWx1ZSAhPSB1bmRlZmluZWQpID8gdmFsdWUgOiAnJyxcXG5cXHQgICAgdHlwZTogdHlwZVxcblxcdCAgfSk7XFxuXFx0ICBuZXdOb2RlLmV4cGFuZCh0cnVlKTtcXG5cXHQgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKG5ld05vZGUpO1xcblxcdCAgdGhpcy5lZGl0b3IuaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoKTtcXG5cXHQgIG5ld05vZGUuZm9jdXMoJ2ZpZWxkJyk7XFxuXFx0ICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XFxuXFxuXFx0ICB0aGlzLmVkaXRvci5fb25BY3Rpb24oJ2FwcGVuZE5vZGUnLCB7XFxuXFx0ICAgIG5vZGU6IG5ld05vZGUsXFxuXFx0ICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXFxuXFx0ICAgIG9sZFNlbGVjdGlvbjogb2xkU2VsZWN0aW9uLFxcblxcdCAgICBuZXdTZWxlY3Rpb246IG5ld1NlbGVjdGlvblxcblxcdCAgfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIG5vZGUncyB2YWx1ZVxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBuZXdUeXBlXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fb25DaGFuZ2VUeXBlID0gZnVuY3Rpb24gKG5ld1R5cGUpIHtcXG5cXHQgIHZhciBvbGRUeXBlID0gdGhpcy50eXBlO1xcblxcdCAgaWYgKG5ld1R5cGUgIT0gb2xkVHlwZSkge1xcblxcdCAgICB2YXIgb2xkU2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XFxuXFx0ICAgIHRoaXMuY2hhbmdlVHlwZShuZXdUeXBlKTtcXG5cXHQgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xcblxcblxcdCAgICB0aGlzLmVkaXRvci5fb25BY3Rpb24oJ2NoYW5nZVR5cGUnLCB7XFxuXFx0ICAgICAgbm9kZTogdGhpcyxcXG5cXHQgICAgICBvbGRUeXBlOiBvbGRUeXBlLFxcblxcdCAgICAgIG5ld1R5cGU6IG5ld1R5cGUsXFxuXFx0ICAgICAgb2xkU2VsZWN0aW9uOiBvbGRTZWxlY3Rpb24sXFxuXFx0ICAgICAgbmV3U2VsZWN0aW9uOiBuZXdTZWxlY3Rpb25cXG5cXHQgICAgfSk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTb3J0IHRoZSBjaGlsZHMgb2YgdGhlIG5vZGUuIE9ubHkgYXBwbGljYWJsZSB3aGVuIHRoZSBub2RlIGhhcyB0eXBlICdvYmplY3QnXFxuXFx0ICogb3IgJ2FycmF5Jy5cXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICAgU29ydGluZyBkaXJlY3Rpb24uIEF2YWlsYWJsZSB2YWx1ZXM6IFxcXCJhc2NcXFwiLCBcXFwiZGVzY1xcXCJcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9vblNvcnQgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XFxuXFx0ICBpZiAodGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgdmFyIG9yZGVyID0gKGRpcmVjdGlvbiA9PSAnZGVzYycpID8gLTEgOiAxO1xcblxcdCAgICB2YXIgcHJvcCA9ICh0aGlzLnR5cGUgPT0gJ2FycmF5JykgPyAndmFsdWUnOiAnZmllbGQnO1xcblxcdCAgICB0aGlzLmhpZGVDaGlsZHMoKTtcXG5cXG5cXHQgICAgdmFyIG9sZENoaWxkcyA9IHRoaXMuY2hpbGRzO1xcblxcdCAgICB2YXIgb2xkU29ydCA9IHRoaXMuc29ydDtcXG5cXG5cXHQgICAgLy8gY29weSB0aGUgYXJyYXkgKHRoZSBvbGQgb25lIHdpbGwgYmUga2VwdCBmb3IgYW4gdW5kbyBhY3Rpb25cXG5cXHQgICAgdGhpcy5jaGlsZHMgPSB0aGlzLmNoaWxkcy5jb25jYXQoKTtcXG5cXG5cXHQgICAgLy8gc29ydCB0aGUgYXJyYXlzXFxuXFx0ICAgIHRoaXMuY2hpbGRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG5cXHQgICAgICBpZiAoYVtwcm9wXSA+IGJbcHJvcF0pIHJldHVybiBvcmRlcjtcXG5cXHQgICAgICBpZiAoYVtwcm9wXSA8IGJbcHJvcF0pIHJldHVybiAtb3JkZXI7XFxuXFx0ICAgICAgcmV0dXJuIDA7XFxuXFx0ICAgIH0pO1xcblxcdCAgICB0aGlzLnNvcnQgPSAob3JkZXIgPT0gMSkgPyAnYXNjJyA6ICdkZXNjJztcXG5cXG5cXHQgICAgdGhpcy5lZGl0b3IuX29uQWN0aW9uKCdzb3J0Jywge1xcblxcdCAgICAgIG5vZGU6IHRoaXMsXFxuXFx0ICAgICAgb2xkQ2hpbGRzOiBvbGRDaGlsZHMsXFxuXFx0ICAgICAgb2xkU29ydDogb2xkU29ydCxcXG5cXHQgICAgICBuZXdDaGlsZHM6IHRoaXMuY2hpbGRzLFxcblxcdCAgICAgIG5ld1NvcnQ6IHRoaXMuc29ydFxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy5zaG93Q2hpbGRzKCk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDcmVhdGUgYSB0YWJsZSByb3cgd2l0aCBhbiBhcHBlbmQgYnV0dG9uLlxcblxcdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfSBidXR0b25BcHBlbmQgb3IgdW5kZWZpbmVkIHdoZW4gaW5hcHBsaWNhYmxlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuZ2V0QXBwZW5kID0gZnVuY3Rpb24gKCkge1xcblxcdCAgaWYgKCF0aGlzLmFwcGVuZCkge1xcblxcdCAgICB0aGlzLmFwcGVuZCA9IG5ldyBBcHBlbmROb2RlKHRoaXMuZWRpdG9yKTtcXG5cXHQgICAgdGhpcy5hcHBlbmQuc2V0UGFyZW50KHRoaXMpO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIHRoaXMuYXBwZW5kLmdldERvbSgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRmluZCB0aGUgbm9kZSBmcm9tIGFuIGV2ZW50IHRhcmdldFxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XFxuXFx0ICogQHJldHVybiB7Tm9kZSB8IHVuZGVmaW5lZH0gbm9kZSAgb3IgdW5kZWZpbmVkIHdoZW4gbm90IGZvdW5kXFxuXFx0ICogQHN0YXRpY1xcblxcdCAqL1xcblxcdE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XFxuXFx0ICB3aGlsZSAodGFyZ2V0KSB7XFxuXFx0ICAgIGlmICh0YXJnZXQubm9kZSkge1xcblxcdCAgICAgIHJldHVybiB0YXJnZXQubm9kZTtcXG5cXHQgICAgfVxcblxcdCAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB1bmRlZmluZWQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgdGhlIHByZXZpb3VzbHkgcmVuZGVyZWQgbm9kZVxcblxcdCAqIEByZXR1cm4ge05vZGUgfCBudWxsfSBwcmV2aW91c05vZGVcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9wcmV2aW91c05vZGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB2YXIgcHJldk5vZGUgPSBudWxsO1xcblxcdCAgdmFyIGRvbSA9IHRoaXMuZ2V0RG9tKCk7XFxuXFx0ICBpZiAoZG9tICYmIGRvbS5wYXJlbnROb2RlKSB7XFxuXFx0ICAgIC8vIGZpbmQgdGhlIHByZXZpb3VzIGZpZWxkXFxuXFx0ICAgIHZhciBwcmV2RG9tID0gZG9tO1xcblxcdCAgICBkbyB7XFxuXFx0ICAgICAgcHJldkRvbSA9IHByZXZEb20ucHJldmlvdXNTaWJsaW5nO1xcblxcdCAgICAgIHByZXZOb2RlID0gTm9kZS5nZXROb2RlRnJvbVRhcmdldChwcmV2RG9tKTtcXG5cXHQgICAgfVxcblxcdCAgICB3aGlsZSAocHJldkRvbSAmJiAocHJldk5vZGUgaW5zdGFuY2VvZiBBcHBlbmROb2RlICYmICFwcmV2Tm9kZS5pc1Zpc2libGUoKSkpO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIHByZXZOb2RlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSBuZXh0IHJlbmRlcmVkIG5vZGVcXG5cXHQgKiBAcmV0dXJuIHtOb2RlIHwgbnVsbH0gbmV4dE5vZGVcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9uZXh0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHZhciBuZXh0Tm9kZSA9IG51bGw7XFxuXFx0ICB2YXIgZG9tID0gdGhpcy5nZXREb20oKTtcXG5cXHQgIGlmIChkb20gJiYgZG9tLnBhcmVudE5vZGUpIHtcXG5cXHQgICAgLy8gZmluZCB0aGUgcHJldmlvdXMgZmllbGRcXG5cXHQgICAgdmFyIG5leHREb20gPSBkb207XFxuXFx0ICAgIGRvIHtcXG5cXHQgICAgICBuZXh0RG9tID0gbmV4dERvbS5uZXh0U2libGluZztcXG5cXHQgICAgICBuZXh0Tm9kZSA9IE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQobmV4dERvbSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgd2hpbGUgKG5leHREb20gJiYgKG5leHROb2RlIGluc3RhbmNlb2YgQXBwZW5kTm9kZSAmJiAhbmV4dE5vZGUuaXNWaXNpYmxlKCkpKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBuZXh0Tm9kZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgZmlyc3QgcmVuZGVyZWQgbm9kZVxcblxcdCAqIEByZXR1cm4ge05vZGUgfCBudWxsfSBmaXJzdE5vZGVcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9maXJzdE5vZGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICB2YXIgZmlyc3ROb2RlID0gbnVsbDtcXG5cXHQgIHZhciBkb20gPSB0aGlzLmdldERvbSgpO1xcblxcdCAgaWYgKGRvbSAmJiBkb20ucGFyZW50Tm9kZSkge1xcblxcdCAgICB2YXIgZmlyc3REb20gPSBkb20ucGFyZW50Tm9kZS5maXJzdENoaWxkO1xcblxcdCAgICBmaXJzdE5vZGUgPSBOb2RlLmdldE5vZGVGcm9tVGFyZ2V0KGZpcnN0RG9tKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiBmaXJzdE5vZGU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBHZXQgdGhlIGxhc3QgcmVuZGVyZWQgbm9kZVxcblxcdCAqIEByZXR1cm4ge05vZGUgfCBudWxsfSBsYXN0Tm9kZVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2xhc3ROb2RlID0gZnVuY3Rpb24gKCkge1xcblxcdCAgdmFyIGxhc3ROb2RlID0gbnVsbDtcXG5cXHQgIHZhciBkb20gPSB0aGlzLmdldERvbSgpO1xcblxcdCAgaWYgKGRvbSAmJiBkb20ucGFyZW50Tm9kZSkge1xcblxcdCAgICB2YXIgbGFzdERvbSA9IGRvbS5wYXJlbnROb2RlLmxhc3RDaGlsZDtcXG5cXHQgICAgbGFzdE5vZGUgPSAgTm9kZS5nZXROb2RlRnJvbVRhcmdldChsYXN0RG9tKTtcXG5cXHQgICAgd2hpbGUgKGxhc3REb20gJiYgKGxhc3ROb2RlIGluc3RhbmNlb2YgQXBwZW5kTm9kZSAmJiAhbGFzdE5vZGUuaXNWaXNpYmxlKCkpKSB7XFxuXFx0ICAgICAgbGFzdERvbSA9IGxhc3REb20ucHJldmlvdXNTaWJsaW5nO1xcblxcdCAgICAgIGxhc3ROb2RlID0gIE5vZGUuZ2V0Tm9kZUZyb21UYXJnZXQobGFzdERvbSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIHJldHVybiBsYXN0Tm9kZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgbmV4dCBlbGVtZW50IHdoaWNoIGNhbiBoYXZlIGZvY3VzLlxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxcblxcdCAqIEByZXR1cm4ge0VsZW1lbnQgfCBudWxsfSBuZXh0RWxlbVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX3ByZXZpb3VzRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0ICB2YXIgZG9tID0gdGhpcy5kb207XFxuXFx0ICAvLyBub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXFxuXFx0ICBzd2l0Y2ggKGVsZW0pIHtcXG5cXHQgICAgY2FzZSBkb20udmFsdWU6XFxuXFx0ICAgICAgaWYgKHRoaXMuZmllbGRFZGl0YWJsZSkge1xcblxcdCAgICAgICAgcmV0dXJuIGRvbS5maWVsZDtcXG5cXHQgICAgICB9XFxuXFx0ICAgIC8vIGludGVudGlvbmFsIGZhbGwgdGhyb3VnaFxcblxcdCAgICBjYXNlIGRvbS5maWVsZDpcXG5cXHQgICAgICBpZiAodGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICAgIHJldHVybiBkb20uZXhwYW5kO1xcblxcdCAgICAgIH1cXG5cXHQgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXFxuXFx0ICAgIGNhc2UgZG9tLmV4cGFuZDpcXG5cXHQgICAgICByZXR1cm4gZG9tLm1lbnU7XFxuXFx0ICAgIGNhc2UgZG9tLm1lbnU6XFxuXFx0ICAgICAgaWYgKGRvbS5kcmFnKSB7XFxuXFx0ICAgICAgICByZXR1cm4gZG9tLmRyYWc7XFxuXFx0ICAgICAgfVxcblxcdCAgICAvLyBpbnRlbnRpb25hbCBmYWxsIHRocm91Z2hcXG5cXHQgICAgZGVmYXVsdDpcXG5cXHQgICAgICByZXR1cm4gbnVsbDtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCB0aGUgbmV4dCBlbGVtZW50IHdoaWNoIGNhbiBoYXZlIGZvY3VzLlxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxcblxcdCAqIEByZXR1cm4ge0VsZW1lbnQgfCBudWxsfSBuZXh0RWxlbVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX25leHRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHQgIHZhciBkb20gPSB0aGlzLmRvbTtcXG5cXHQgIC8vIG5vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcXG5cXHQgIHN3aXRjaCAoZWxlbSkge1xcblxcdCAgICBjYXNlIGRvbS5kcmFnOlxcblxcdCAgICAgIHJldHVybiBkb20ubWVudTtcXG5cXHQgICAgY2FzZSBkb20ubWVudTpcXG5cXHQgICAgICBpZiAodGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICAgIHJldHVybiBkb20uZXhwYW5kO1xcblxcdCAgICAgIH1cXG5cXHQgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXFxuXFx0ICAgIGNhc2UgZG9tLmV4cGFuZDpcXG5cXHQgICAgICBpZiAodGhpcy5maWVsZEVkaXRhYmxlKSB7XFxuXFx0ICAgICAgICByZXR1cm4gZG9tLmZpZWxkO1xcblxcdCAgICAgIH1cXG5cXHQgICAgLy8gaW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoXFxuXFx0ICAgIGNhc2UgZG9tLmZpZWxkOlxcblxcdCAgICAgIGlmICghdGhpcy5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgICAgIHJldHVybiBkb20udmFsdWU7XFxuXFx0ICAgICAgfVxcblxcdCAgICBkZWZhdWx0OlxcblxcdCAgICAgIHJldHVybiBudWxsO1xcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSBkb20gbmFtZSBvZiBnaXZlbiBlbGVtZW50LiByZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kLlxcblxcdCAqIEZvciBleGFtcGxlIHdoZW4gZWxlbWVudCA9PSBkb20uZmllbGQsIFxcXCJmaWVsZFxcXCIgaXMgcmV0dXJuZWQuXFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XFxuXFx0ICogQHJldHVybiB7U3RyaW5nIHwgbnVsbH0gZWxlbWVudE5hbWUgIEF2YWlsYWJsZSBlbGVtZW50cyB3aXRoIG5hbWU6ICdkcmFnJyxcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21lbnUnLCAnZXhwYW5kJywgJ2ZpZWxkJywgJ3ZhbHVlJ1xcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2dldEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG5cXHQgIHZhciBkb20gPSB0aGlzLmRvbTtcXG5cXHQgIGZvciAodmFyIG5hbWUgaW4gZG9tKSB7XFxuXFx0ICAgIGlmIChkb20uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXG5cXHQgICAgICBpZiAoZG9tW25hbWVdID09IGVsZW1lbnQpIHtcXG5cXHQgICAgICAgIHJldHVybiBuYW1lO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgcmV0dXJuIG51bGw7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBUZXN0IGlmIHRoaXMgbm9kZSBoYXMgY2hpbGRzLiBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlIG5vZGUgaXMgYW4gb2JqZWN0XFxuXFx0ICogb3IgYXJyYXkuXFxuXFx0ICogQHJldHVybiB7Ym9vbGVhbn0gaGFzQ2hpbGRzXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5faGFzQ2hpbGRzID0gZnVuY3Rpb24gKCkge1xcblxcdCAgcmV0dXJuIHRoaXMudHlwZSA9PSAnYXJyYXknIHx8IHRoaXMudHlwZSA9PSAnb2JqZWN0JztcXG5cXHR9O1xcblxcblxcdC8vIHRpdGxlcyB3aXRoIGV4cGxhbmF0aW9uIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzXFxuXFx0Tm9kZS5UWVBFX1RJVExFUyA9IHtcXG5cXHQgICdhdXRvJzogJ0ZpZWxkIHR5cGUgXFxcImF1dG9cXFwiLiAnICtcXG5cXHQgICAgICAnVGhlIGZpZWxkIHR5cGUgaXMgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkIGZyb20gdGhlIHZhbHVlICcgK1xcblxcdCAgICAgICdhbmQgY2FuIGJlIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9yIG51bGwuJyxcXG5cXHQgICdvYmplY3QnOiAnRmllbGQgdHlwZSBcXFwib2JqZWN0XFxcIi4gJyArXFxuXFx0ICAgICAgJ0FuIG9iamVjdCBjb250YWlucyBhbiB1bm9yZGVyZWQgc2V0IG9mIGtleS92YWx1ZSBwYWlycy4nLFxcblxcdCAgJ2FycmF5JzogJ0ZpZWxkIHR5cGUgXFxcImFycmF5XFxcIi4gJyArXFxuXFx0ICAgICAgJ0FuIGFycmF5IGNvbnRhaW5zIGFuIG9yZGVyZWQgY29sbGVjdGlvbiBvZiB2YWx1ZXMuJyxcXG5cXHQgICdzdHJpbmcnOiAnRmllbGQgdHlwZSBcXFwic3RyaW5nXFxcIi4gJyArXFxuXFx0ICAgICAgJ0ZpZWxkIHR5cGUgaXMgbm90IGRldGVybWluZWQgZnJvbSB0aGUgdmFsdWUsICcgK1xcblxcdCAgICAgICdidXQgYWx3YXlzIHJldHVybmVkIGFzIHN0cmluZy4nXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTaG93IGEgY29udGV4dG1lbnUgZm9yIHRoaXMgbm9kZVxcblxcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFuY2hvciAgIEFuY2hvciBlbGVtZW50IHRvIGF0dGFjaGUgdGhlIGNvbnRleHQgbWVudSB0by5cXG5cXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb25DbG9zZV0gICBDYWxsYmFjayBtZXRob2QgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudVxcblxcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGJlaW5nIGNsb3NlZC5cXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5zaG93Q29udGV4dE1lbnUgPSBmdW5jdGlvbiAoYW5jaG9yLCBvbkNsb3NlKSB7XFxuXFx0ICB2YXIgbm9kZSA9IHRoaXM7XFxuXFx0ICB2YXIgdGl0bGVzID0gTm9kZS5UWVBFX1RJVExFUztcXG5cXHQgIHZhciBpdGVtcyA9IFtdO1xcblxcblxcdCAgaWYgKHRoaXMuZWRpdGFibGUudmFsdWUpIHtcXG5cXHQgICAgaXRlbXMucHVzaCh7XFxuXFx0ICAgICAgdGV4dDogJ1R5cGUnLFxcblxcdCAgICAgIHRpdGxlOiAnQ2hhbmdlIHRoZSB0eXBlIG9mIHRoaXMgZmllbGQnLFxcblxcdCAgICAgIGNsYXNzTmFtZTogJ3R5cGUtJyArIHRoaXMudHlwZSxcXG5cXHQgICAgICBzdWJtZW51OiBbXFxuXFx0ICAgICAgICB7XFxuXFx0ICAgICAgICAgIHRleHQ6ICdBdXRvJyxcXG5cXHQgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZS1hdXRvJyArXFxuXFx0ICAgICAgICAgICAgICAodGhpcy50eXBlID09ICdhdXRvJyA/ICcgc2VsZWN0ZWQnIDogJycpLFxcblxcdCAgICAgICAgICB0aXRsZTogdGl0bGVzLmF1dG8sXFxuXFx0ICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgbm9kZS5fb25DaGFuZ2VUeXBlKCdhdXRvJyk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICB7XFxuXFx0ICAgICAgICAgIHRleHQ6ICdBcnJheScsXFxuXFx0ICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUtYXJyYXknICtcXG5cXHQgICAgICAgICAgICAgICh0aGlzLnR5cGUgPT0gJ2FycmF5JyA/ICcgc2VsZWN0ZWQnIDogJycpLFxcblxcdCAgICAgICAgICB0aXRsZTogdGl0bGVzLmFycmF5LFxcblxcdCAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgIG5vZGUuX29uQ2hhbmdlVHlwZSgnYXJyYXknKTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIHtcXG5cXHQgICAgICAgICAgdGV4dDogJ09iamVjdCcsXFxuXFx0ICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUtb2JqZWN0JyArXFxuXFx0ICAgICAgICAgICAgICAodGhpcy50eXBlID09ICdvYmplY3QnID8gJyBzZWxlY3RlZCcgOiAnJyksXFxuXFx0ICAgICAgICAgIHRpdGxlOiB0aXRsZXMub2JqZWN0LFxcblxcdCAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgIG5vZGUuX29uQ2hhbmdlVHlwZSgnb2JqZWN0Jyk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICB7XFxuXFx0ICAgICAgICAgIHRleHQ6ICdTdHJpbmcnLFxcblxcdCAgICAgICAgICBjbGFzc05hbWU6ICd0eXBlLXN0cmluZycgK1xcblxcdCAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PSAnc3RyaW5nJyA/ICcgc2VsZWN0ZWQnIDogJycpLFxcblxcdCAgICAgICAgICB0aXRsZTogdGl0bGVzLnN0cmluZyxcXG5cXHQgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICBub2RlLl9vbkNoYW5nZVR5cGUoJ3N0cmluZycpO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgXVxcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLl9oYXNDaGlsZHMoKSkge1xcblxcdCAgICB2YXIgZGlyZWN0aW9uID0gKCh0aGlzLnNvcnQgPT0gJ2FzYycpID8gJ2Rlc2MnOiAnYXNjJyk7XFxuXFx0ICAgIGl0ZW1zLnB1c2goe1xcblxcdCAgICAgIHRleHQ6ICdTb3J0JyxcXG5cXHQgICAgICB0aXRsZTogJ1NvcnQgdGhlIGNoaWxkcyBvZiB0aGlzICcgKyB0aGlzLnR5cGUsXFxuXFx0ICAgICAgY2xhc3NOYW1lOiAnc29ydC0nICsgZGlyZWN0aW9uLFxcblxcdCAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICBub2RlLl9vblNvcnQoZGlyZWN0aW9uKTtcXG5cXHQgICAgICB9LFxcblxcdCAgICAgIHN1Ym1lbnU6IFtcXG5cXHQgICAgICAgIHtcXG5cXHQgICAgICAgICAgdGV4dDogJ0FzY2VuZGluZycsXFxuXFx0ICAgICAgICAgIGNsYXNzTmFtZTogJ3NvcnQtYXNjJyxcXG5cXHQgICAgICAgICAgdGl0bGU6ICdTb3J0IHRoZSBjaGlsZHMgb2YgdGhpcyAnICsgdGhpcy50eXBlICsgJyBpbiBhc2NlbmRpbmcgb3JkZXInLFxcblxcdCAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgIG5vZGUuX29uU29ydCgnYXNjJyk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICB7XFxuXFx0ICAgICAgICAgIHRleHQ6ICdEZXNjZW5kaW5nJyxcXG5cXHQgICAgICAgICAgY2xhc3NOYW1lOiAnc29ydC1kZXNjJyxcXG5cXHQgICAgICAgICAgdGl0bGU6ICdTb3J0IHRoZSBjaGlsZHMgb2YgdGhpcyAnICsgdGhpcy50eXBlICsnIGluIGRlc2NlbmRpbmcgb3JkZXInLFxcblxcdCAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgIG5vZGUuX29uU29ydCgnZGVzYycpO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgXVxcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5faGFzQ2hpbGRzKCkpIHtcXG5cXHQgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xcblxcdCAgICAgIC8vIGNyZWF0ZSBhIHNlcGFyYXRvclxcblxcdCAgICAgIGl0ZW1zLnB1c2goe1xcblxcdCAgICAgICAgJ3R5cGUnOiAnc2VwYXJhdG9yJ1xcblxcdCAgICAgIH0pO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGNyZWF0ZSBhcHBlbmQgYnV0dG9uIChmb3IgbGFzdCBjaGlsZCBub2RlIG9ubHkpXFxuXFx0ICAgIHZhciBjaGlsZHMgPSBub2RlLnBhcmVudC5jaGlsZHM7XFxuXFx0ICAgIGlmIChub2RlID09IGNoaWxkc1tjaGlsZHMubGVuZ3RoIC0gMV0pIHtcXG5cXHQgICAgICBpdGVtcy5wdXNoKHtcXG5cXHQgICAgICAgIHRleHQ6ICdBcHBlbmQnLFxcblxcdCAgICAgICAgdGl0bGU6ICdBcHBlbmQgYSBuZXcgZmllbGQgd2l0aCB0eXBlIFxcXFwnYXV0b1xcXFwnIGFmdGVyIHRoaXMgZmllbGQgKEN0cmwrU2hpZnQrSW5zKScsXFxuXFx0ICAgICAgICBzdWJtZW51VGl0bGU6ICdTZWxlY3QgdGhlIHR5cGUgb2YgdGhlIGZpZWxkIHRvIGJlIGFwcGVuZGVkJyxcXG5cXHQgICAgICAgIGNsYXNzTmFtZTogJ2FwcGVuZCcsXFxuXFx0ICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICBub2RlLl9vbkFwcGVuZCgnJywgJycsICdhdXRvJyk7XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgc3VibWVudTogW1xcblxcdCAgICAgICAgICB7XFxuXFx0ICAgICAgICAgICAgdGV4dDogJ0F1dG8nLFxcblxcdCAgICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUtYXV0bycsXFxuXFx0ICAgICAgICAgICAgdGl0bGU6IHRpdGxlcy5hdXRvLFxcblxcdCAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgICBub2RlLl9vbkFwcGVuZCgnJywgJycsICdhdXRvJyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICB9LFxcblxcdCAgICAgICAgICB7XFxuXFx0ICAgICAgICAgICAgdGV4dDogJ0FycmF5JyxcXG5cXHQgICAgICAgICAgICBjbGFzc05hbWU6ICd0eXBlLWFycmF5JyxcXG5cXHQgICAgICAgICAgICB0aXRsZTogdGl0bGVzLmFycmF5LFxcblxcdCAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgICBub2RlLl9vbkFwcGVuZCgnJywgW10pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgfSxcXG5cXHQgICAgICAgICAge1xcblxcdCAgICAgICAgICAgIHRleHQ6ICdPYmplY3QnLFxcblxcdCAgICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUtb2JqZWN0JyxcXG5cXHQgICAgICAgICAgICB0aXRsZTogdGl0bGVzLm9iamVjdCxcXG5cXHQgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgICAgbm9kZS5fb25BcHBlbmQoJycsIHt9KTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgIH0sXFxuXFx0ICAgICAgICAgIHtcXG5cXHQgICAgICAgICAgICB0ZXh0OiAnU3RyaW5nJyxcXG5cXHQgICAgICAgICAgICBjbGFzc05hbWU6ICd0eXBlLXN0cmluZycsXFxuXFx0ICAgICAgICAgICAgdGl0bGU6IHRpdGxlcy5zdHJpbmcsXFxuXFx0ICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICAgIG5vZGUuX29uQXBwZW5kKCcnLCAnJywgJ3N0cmluZycpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgXVxcblxcdCAgICAgIH0pO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGNyZWF0ZSBpbnNlcnQgYnV0dG9uXFxuXFx0ICAgIGl0ZW1zLnB1c2goe1xcblxcdCAgICAgIHRleHQ6ICdJbnNlcnQnLFxcblxcdCAgICAgIHRpdGxlOiAnSW5zZXJ0IGEgbmV3IGZpZWxkIHdpdGggdHlwZSBcXFxcJ2F1dG9cXFxcJyBiZWZvcmUgdGhpcyBmaWVsZCAoQ3RybCtJbnMpJyxcXG5cXHQgICAgICBzdWJtZW51VGl0bGU6ICdTZWxlY3QgdGhlIHR5cGUgb2YgdGhlIGZpZWxkIHRvIGJlIGluc2VydGVkJyxcXG5cXHQgICAgICBjbGFzc05hbWU6ICdpbnNlcnQnLFxcblxcdCAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICBub2RlLl9vbkluc2VydEJlZm9yZSgnJywgJycsICdhdXRvJyk7XFxuXFx0ICAgICAgfSxcXG5cXHQgICAgICBzdWJtZW51OiBbXFxuXFx0ICAgICAgICB7XFxuXFx0ICAgICAgICAgIHRleHQ6ICdBdXRvJyxcXG5cXHQgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZS1hdXRvJyxcXG5cXHQgICAgICAgICAgdGl0bGU6IHRpdGxlcy5hdXRvLFxcblxcdCAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgIG5vZGUuX29uSW5zZXJ0QmVmb3JlKCcnLCAnJywgJ2F1dG8nKTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIHtcXG5cXHQgICAgICAgICAgdGV4dDogJ0FycmF5JyxcXG5cXHQgICAgICAgICAgY2xhc3NOYW1lOiAndHlwZS1hcnJheScsXFxuXFx0ICAgICAgICAgIHRpdGxlOiB0aXRsZXMuYXJyYXksXFxuXFx0ICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgbm9kZS5fb25JbnNlcnRCZWZvcmUoJycsIFtdKTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIHtcXG5cXHQgICAgICAgICAgdGV4dDogJ09iamVjdCcsXFxuXFx0ICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUtb2JqZWN0JyxcXG5cXHQgICAgICAgICAgdGl0bGU6IHRpdGxlcy5vYmplY3QsXFxuXFx0ICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgbm9kZS5fb25JbnNlcnRCZWZvcmUoJycsIHt9KTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIHtcXG5cXHQgICAgICAgICAgdGV4dDogJ1N0cmluZycsXFxuXFx0ICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUtc3RyaW5nJyxcXG5cXHQgICAgICAgICAgdGl0bGU6IHRpdGxlcy5zdHJpbmcsXFxuXFx0ICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgbm9kZS5fb25JbnNlcnRCZWZvcmUoJycsICcnLCAnc3RyaW5nJyk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICBdXFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICBpZiAodGhpcy5lZGl0YWJsZS5maWVsZCkge1xcblxcdCAgICAgIC8vIGNyZWF0ZSBkdXBsaWNhdGUgYnV0dG9uXFxuXFx0ICAgICAgaXRlbXMucHVzaCh7XFxuXFx0ICAgICAgICB0ZXh0OiAnRHVwbGljYXRlJyxcXG5cXHQgICAgICAgIHRpdGxlOiAnRHVwbGljYXRlIHRoaXMgZmllbGQgKEN0cmwrRCknLFxcblxcdCAgICAgICAgY2xhc3NOYW1lOiAnZHVwbGljYXRlJyxcXG5cXHQgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIG5vZGUuX29uRHVwbGljYXRlKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfSk7XFxuXFxuXFx0ICAgICAgLy8gY3JlYXRlIHJlbW92ZSBidXR0b25cXG5cXHQgICAgICBpdGVtcy5wdXNoKHtcXG5cXHQgICAgICAgIHRleHQ6ICdSZW1vdmUnLFxcblxcdCAgICAgICAgdGl0bGU6ICdSZW1vdmUgdGhpcyBmaWVsZCAoQ3RybCtEZWwpJyxcXG5cXHQgICAgICAgIGNsYXNzTmFtZTogJ3JlbW92ZScsXFxuXFx0ICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICBub2RlLl9vblJlbW92ZSgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH0pO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgbWVudSA9IG5ldyBDb250ZXh0TWVudShpdGVtcywge2Nsb3NlOiBvbkNsb3NlfSk7XFxuXFx0ICBtZW51LnNob3coYW5jaG9yKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIGdldCB0aGUgdHlwZSBvZiBhIHZhbHVlXFxuXFx0ICogQHBhcmFtIHsqfSB2YWx1ZVxcblxcdCAqIEByZXR1cm4ge1N0cmluZ30gdHlwZSAgIENhbiBiZSAnb2JqZWN0JywgJ2FycmF5JywgJ3N0cmluZycsICdhdXRvJ1xcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX2dldFR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xcblxcdCAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcXG5cXHQgICAgcmV0dXJuICdhcnJheSc7XFxuXFx0ICB9XFxuXFx0ICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcXG5cXHQgICAgcmV0dXJuICdvYmplY3QnO1xcblxcdCAgfVxcblxcdCAgaWYgKHR5cGVvZih2YWx1ZSkgPT0gJ3N0cmluZycgJiYgdHlwZW9mKHRoaXMuX3N0cmluZ0Nhc3QodmFsdWUpKSAhPSAnc3RyaW5nJykge1xcblxcdCAgICByZXR1cm4gJ3N0cmluZyc7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gJ2F1dG8nO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogY2FzdCBjb250ZW50cyBvZiBhIHN0cmluZyB0byB0aGUgY29ycmVjdCB0eXBlLiBUaGlzIGNhbiBiZSBhIHN0cmluZyxcXG5cXHQgKiBhIG51bWJlciwgYSBib29sZWFuLCBldGNcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXFxuXFx0ICogQHJldHVybiB7Kn0gY2FzdGVkU3RyXFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fc3RyaW5nQ2FzdCA9IGZ1bmN0aW9uKHN0cikge1xcblxcdCAgdmFyIGxvd2VyID0gc3RyLnRvTG93ZXJDYXNlKCksXFxuXFx0ICAgICAgbnVtID0gTnVtYmVyKHN0ciksICAgICAgICAgIC8vIHdpbGwgbmljZWx5IGZhaWwgd2l0aCAnMTIzYWInXFxuXFx0ICAgICAgbnVtRmxvYXQgPSBwYXJzZUZsb2F0KHN0cik7IC8vIHdpbGwgbmljZWx5IGZhaWwgd2l0aCAnICAnXFxuXFxuXFx0ICBpZiAoc3RyID09ICcnKSB7XFxuXFx0ICAgIHJldHVybiAnJztcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGxvd2VyID09ICdudWxsJykge1xcblxcdCAgICByZXR1cm4gbnVsbDtcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGxvd2VyID09ICd0cnVlJykge1xcblxcdCAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGxvd2VyID09ICdmYWxzZScpIHtcXG5cXHQgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAoIWlzTmFOKG51bSkgJiYgIWlzTmFOKG51bUZsb2F0KSkge1xcblxcdCAgICByZXR1cm4gbnVtO1xcblxcdCAgfVxcblxcdCAgZWxzZSB7XFxuXFx0ICAgIHJldHVybiBzdHI7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBlc2NhcGUgYSB0ZXh0LCBzdWNoIHRoYXQgaXQgY2FuIGJlIGRpc3BsYXllZCBzYWZlbHkgaW4gYW4gSFRNTCBlbGVtZW50XFxuXFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcXG5cXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGVzY2FwZWRUZXh0XFxuXFx0ICogQHByaXZhdGVcXG5cXHQgKi9cXG5cXHROb2RlLnByb3RvdHlwZS5fZXNjYXBlSFRNTCA9IGZ1bmN0aW9uICh0ZXh0KSB7XFxuXFx0ICB2YXIgaHRtbEVzY2FwZWQgPSBTdHJpbmcodGV4dClcXG5cXHQgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXFxuXFx0ICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxcblxcdCAgICAgIC5yZXBsYWNlKC8gIC9nLCAnICZuYnNwOycpIC8vIHJlcGxhY2UgZG91YmxlIHNwYWNlIHdpdGggYW4gbmJzcCBhbmQgc3BhY2VcXG5cXHQgICAgICAucmVwbGFjZSgvXiAvLCAnJm5ic3A7JykgICAvLyBzcGFjZSBhdCBzdGFydFxcblxcdCAgICAgIC5yZXBsYWNlKC8gJC8sICcmbmJzcDsnKTsgIC8vIHNwYWNlIGF0IGVuZFxcblxcblxcdCAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShodG1sRXNjYXBlZCk7XFxuXFx0ICByZXR1cm4ganNvbi5zdWJzdHJpbmcoMSwganNvbi5sZW5ndGggLSAxKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIHVuZXNjYXBlIGEgc3RyaW5nLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBlc2NhcGVkVGV4dFxcblxcdCAqIEByZXR1cm4ge1N0cmluZ30gdGV4dFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Tm9kZS5wcm90b3R5cGUuX3VuZXNjYXBlSFRNTCA9IGZ1bmN0aW9uIChlc2NhcGVkVGV4dCkge1xcblxcdCAgdmFyIGpzb24gPSAnXFxcIicgKyB0aGlzLl9lc2NhcGVKU09OKGVzY2FwZWRUZXh0KSArICdcXFwiJztcXG5cXHQgIHZhciBodG1sRXNjYXBlZCA9IHV0aWwucGFyc2UoanNvbik7XFxuXFx0ICByZXR1cm4gaHRtbEVzY2FwZWRcXG5cXHQgICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXFxuXFx0ICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxcblxcdCAgICAgIC5yZXBsYWNlKC8mbmJzcDt8XFxcXHUwMEEwL2csICcgJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBlc2NhcGUgYSB0ZXh0IHRvIG1ha2UgaXQgYSB2YWxpZCBKU09OIHN0cmluZy4gVGhlIG1ldGhvZCB3aWxsOlxcblxcdCAqICAgLSByZXBsYWNlIHVuZXNjYXBlZCBkb3VibGUgcXVvdGVzIHdpdGggJ1xcXFxcXFwiJ1xcblxcdCAqICAgLSByZXBsYWNlIHVuZXNjYXBlZCBiYWNrc2xhc2ggd2l0aCAnXFxcXFxcXFwnXFxuXFx0ICogICAtIHJlcGxhY2UgcmV0dXJucyB3aXRoICdcXFxcbidcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxcblxcdCAqIEByZXR1cm4ge1N0cmluZ30gZXNjYXBlZFRleHRcXG5cXHQgKiBAcHJpdmF0ZVxcblxcdCAqL1xcblxcdE5vZGUucHJvdG90eXBlLl9lc2NhcGVKU09OID0gZnVuY3Rpb24gKHRleHQpIHtcXG5cXHQgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBzb21lIHNtYXJ0IHJlZ2V4IChvbmx5IHdoZW4gYSBuZXcgc29sdXRpb24gaXMgZmFzdGVyISlcXG5cXHQgIHZhciBlc2NhcGVkID0gJyc7XFxuXFx0ICB2YXIgaSA9IDAsIGlNYXggPSB0ZXh0Lmxlbmd0aDtcXG5cXHQgIHdoaWxlIChpIDwgaU1heCkge1xcblxcdCAgICB2YXIgYyA9IHRleHQuY2hhckF0KGkpO1xcblxcdCAgICBpZiAoYyA9PSAnXFxcXG4nKSB7XFxuXFx0ICAgICAgZXNjYXBlZCArPSAnXFxcXFxcXFxuJztcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmIChjID09ICdcXFxcXFxcXCcpIHtcXG5cXHQgICAgICBlc2NhcGVkICs9IGM7XFxuXFx0ICAgICAgaSsrO1xcblxcblxcdCAgICAgIGMgPSB0ZXh0LmNoYXJBdChpKTtcXG5cXHQgICAgICBpZiAoJ1xcXCJcXFxcXFxcXC9iZm5ydHUnLmluZGV4T2YoYykgPT0gLTEpIHtcXG5cXHQgICAgICAgIGVzY2FwZWQgKz0gJ1xcXFxcXFxcJzsgIC8vIG5vIHZhbGlkIGVzY2FwZSBjaGFyYWN0ZXJcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgZXNjYXBlZCArPSBjO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2UgaWYgKGMgPT0gJ1xcXCInKSB7XFxuXFx0ICAgICAgZXNjYXBlZCArPSAnXFxcXFxcXFxcXFwiJztcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICBlc2NhcGVkICs9IGM7XFxuXFx0ICAgIH1cXG5cXHQgICAgaSsrO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIGVzY2FwZWQ7XFxuXFx0fTtcXG5cXG5cXHQvLyBUT0RPOiBmaW5kIGEgbmljZXIgc29sdXRpb24gdG8gcmVzb2x2ZSB0aGlzIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBOb2RlIGFuZCBBcHBlbmROb2RlXFxuXFx0dmFyIEFwcGVuZE5vZGUgPSBhcHBlbmROb2RlRmFjdG9yeShOb2RlKTtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IE5vZGU7XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0dmFyIENvbnRleHRNZW51ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQ3JlYXRlIGEgc2VsZWN0IGJveCB0byBiZSB1c2VkIGluIHRoZSBlZGl0b3IgbWVudSdzLCB3aGljaCBhbGxvd3MgdG8gc3dpdGNoIG1vZGVcXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yXFxuXFx0ICogQHBhcmFtIHtTdHJpbmdbXX0gbW9kZXMgIEF2YWlsYWJsZSBtb2RlczogJ2NvZGUnLCAnZm9ybScsICd0ZXh0JywgJ3RyZWUnLCAndmlldydcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudCAgQXZhaWxhYmxlIG1vZGVzOiAnY29kZScsICdmb3JtJywgJ3RleHQnLCAndHJlZScsICd2aWV3J1xcblxcdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gYm94XFxuXFx0ICovXFxuXFx0ZnVuY3Rpb24gY3JlYXRlTW9kZVN3aXRjaGVyKGVkaXRvciwgbW9kZXMsIGN1cnJlbnQpIHtcXG5cXHQgIC8vIFRPRE86IGRlY291cGxlIG1vZGUgc3dpdGNoZXIgZnJvbSBlZGl0b3JcXG5cXG5cXHQgIC8qKlxcblxcdCAgICogU3dpdGNoIHRoZSBtb2RlIG9mIHRoZSBlZGl0b3JcXG5cXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlXFxuXFx0ICAgKi9cXG5cXHQgIGZ1bmN0aW9uIHN3aXRjaE1vZGUobW9kZSkge1xcblxcdCAgICAvLyBzd2l0Y2ggbW9kZVxcblxcdCAgICBlZGl0b3Iuc2V0TW9kZShtb2RlKTtcXG5cXG5cXHQgICAgLy8gcmVzdG9yZSBmb2N1cyBvbiBtb2RlIGJveFxcblxcdCAgICB2YXIgbW9kZUJveCA9IGVkaXRvci5kb20gJiYgZWRpdG9yLmRvbS5tb2RlQm94O1xcblxcdCAgICBpZiAobW9kZUJveCkge1xcblxcdCAgICAgIG1vZGVCb3guZm9jdXMoKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gYXZhaWxhYmxlIG1vZGVzXFxuXFx0ICB2YXIgYXZhaWxhYmxlTW9kZXMgPSB7XFxuXFx0ICAgIGNvZGU6IHtcXG5cXHQgICAgICAndGV4dCc6ICdDb2RlJyxcXG5cXHQgICAgICAndGl0bGUnOiAnU3dpdGNoIHRvIGNvZGUgaGlnaGxpZ2h0ZXInLFxcblxcdCAgICAgICdjbGljayc6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHN3aXRjaE1vZGUoJ2NvZGUnKVxcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgZm9ybToge1xcblxcdCAgICAgICd0ZXh0JzogJ0Zvcm0nLFxcblxcdCAgICAgICd0aXRsZSc6ICdTd2l0Y2ggdG8gZm9ybSBlZGl0b3InLFxcblxcdCAgICAgICdjbGljayc6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHN3aXRjaE1vZGUoJ2Zvcm0nKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHRleHQ6IHtcXG5cXHQgICAgICAndGV4dCc6ICdUZXh0JyxcXG5cXHQgICAgICAndGl0bGUnOiAnU3dpdGNoIHRvIHBsYWluIHRleHQgZWRpdG9yJyxcXG5cXHQgICAgICAnY2xpY2snOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICBzd2l0Y2hNb2RlKCd0ZXh0Jyk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICB0cmVlOiB7XFxuXFx0ICAgICAgJ3RleHQnOiAnVHJlZScsXFxuXFx0ICAgICAgJ3RpdGxlJzogJ1N3aXRjaCB0byB0cmVlIGVkaXRvcicsXFxuXFx0ICAgICAgJ2NsaWNrJzogZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgc3dpdGNoTW9kZSgndHJlZScpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgdmlldzoge1xcblxcdCAgICAgICd0ZXh0JzogJ1ZpZXcnLFxcblxcdCAgICAgICd0aXRsZSc6ICdTd2l0Y2ggdG8gdHJlZSB2aWV3JyxcXG5cXHQgICAgICAnY2xpY2snOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICBzd2l0Y2hNb2RlKCd2aWV3Jyk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9O1xcblxcblxcdCAgLy8gbGlzdCB0aGUgc2VsZWN0ZWQgbW9kZXNcXG5cXHQgIHZhciBpdGVtcyA9IFtdO1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2Rlcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICB2YXIgbW9kZSA9IG1vZGVzW2ldO1xcblxcdCAgICB2YXIgaXRlbSA9IGF2YWlsYWJsZU1vZGVzW21vZGVdO1xcblxcdCAgICBpZiAoIWl0ZW0pIHtcXG5cXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSBcXFwiJyArIG1vZGUgKyAnXFxcIicpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGl0ZW0uY2xhc3NOYW1lID0gJ3R5cGUtbW9kZXMnICsgKChjdXJyZW50ID09IG1vZGUpID8gJyBzZWxlY3RlZCcgOiAnJyk7XFxuXFx0ICAgIGl0ZW1zLnB1c2goaXRlbSk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyByZXRyaWV2ZSB0aGUgdGl0bGUgb2YgY3VycmVudCBtb2RlXFxuXFx0ICB2YXIgY3VycmVudE1vZGUgPSBhdmFpbGFibGVNb2Rlc1tjdXJyZW50XTtcXG5cXHQgIGlmICghY3VycmVudE1vZGUpIHtcXG5cXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgXFxcIicgKyBjdXJyZW50ICsgJ1xcXCInKTtcXG5cXHQgIH1cXG5cXHQgIHZhciBjdXJyZW50VGl0bGUgPSBjdXJyZW50TW9kZS50ZXh0O1xcblxcblxcdCAgLy8gY3JlYXRlIHRoZSBodG1sIGVsZW1lbnRcXG5cXHQgIHZhciBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgIGJveC5jbGFzc05hbWUgPSAnbW9kZXMgc2VwYXJhdG9yJztcXG5cXHQgIGJveC5pbm5lckhUTUwgPSBjdXJyZW50VGl0bGUgKyAnICYjeDI1QkU7JztcXG5cXHQgIGJveC50aXRsZSA9ICdTd2l0Y2ggZWRpdG9yIG1vZGUnO1xcblxcdCAgYm94Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgIHZhciBtZW51ID0gbmV3IENvbnRleHRNZW51KGl0ZW1zKTtcXG5cXHQgICAgbWVudS5zaG93KGJveCk7XFxuXFx0ICB9O1xcblxcblxcdCAgcmV0dXJuIGJveDtcXG5cXHR9XFxuXFxuXFx0ZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGVNb2RlU3dpdGNoZXI7XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiA5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Ly8gbG9hZCBicmFjZVxcblxcdHZhciBhY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcXG5cXG5cXHQvLyBsb2FkIHJlcXVpcmVkIGFjZSBtb2R1bGVzXFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxNik7XFxuXFx0X193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBhY2U7XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiAxMCAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdHZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBIGNvbnRleHQgbWVudVxcblxcdCAqIEBwYXJhbSB7T2JqZWN0W119IGl0ZW1zICAgIEFycmF5IGNvbnRhaW5pbmcgdGhlIG1lbnUgc3RydWN0dXJlXFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgVE9ETzogZGVzY3JpYmUgc3RydWN0dXJlXFxuXFx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgT2JqZWN0IHdpdGggb3B0aW9ucy4gQXZhaWxhYmxlIG9wdGlvbnM6XFxuXFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAge2Z1bmN0aW9ufSBjbG9zZSAgICBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGVcXG5cXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgbWVudSBpcyBiZWluZyBjbG9zZWQuXFxuXFx0ICogQGNvbnN0cnVjdG9yXFxuXFx0ICovXFxuXFx0ZnVuY3Rpb24gQ29udGV4dE1lbnUgKGl0ZW1zLCBvcHRpb25zKSB7XFxuXFx0ICB0aGlzLmRvbSA9IHt9O1xcblxcblxcdCAgdmFyIG1lID0gdGhpcztcXG5cXHQgIHZhciBkb20gPSB0aGlzLmRvbTtcXG5cXHQgIHRoaXMuYW5jaG9yID0gdW5kZWZpbmVkO1xcblxcdCAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xcblxcdCAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xcblxcdCAgdGhpcy5zZWxlY3Rpb24gPSB1bmRlZmluZWQ7IC8vIGhvbGRzIHRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoZSBtZW51IHdhcyBvcGVuZWRcXG5cXHQgIHRoaXMudmlzaWJsZVN1Ym1lbnUgPSB1bmRlZmluZWQ7XFxuXFx0ICB0aGlzLm9uQ2xvc2UgPSBvcHRpb25zID8gb3B0aW9ucy5jbG9zZSA6IHVuZGVmaW5lZDtcXG5cXG5cXHQgIC8vIGNyZWF0ZSBhIGNvbnRhaW5lciBlbGVtZW50XFxuXFx0ICB2YXIgbWVudSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgbWVudS5jbGFzc05hbWUgPSAnanNvbmVkaXRvci1jb250ZXh0bWVudSc7XFxuXFx0ICBkb20ubWVudSA9IG1lbnU7XFxuXFxuXFx0ICAvLyBjcmVhdGUgYSBsaXN0IHRvIGhvbGQgdGhlIG1lbnUgaXRlbXNcXG5cXHQgIHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcXG5cXHQgIGxpc3QuY2xhc3NOYW1lID0gJ21lbnUnO1xcblxcdCAgbWVudS5hcHBlbmRDaGlsZChsaXN0KTtcXG5cXHQgIGRvbS5saXN0ID0gbGlzdDtcXG5cXHQgIGRvbS5pdGVtcyA9IFtdOyAvLyBsaXN0IHdpdGggYWxsIGJ1dHRvbnNcXG5cXG5cXHQgIC8vIGNyZWF0ZSBhIChub24tdmlzaWJsZSkgYnV0dG9uIHRvIHNldCB0aGUgZm9jdXMgdG8gdGhlIG1lbnVcXG5cXHQgIHZhciBmb2N1c0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xcblxcdCAgZG9tLmZvY3VzQnV0dG9uID0gZm9jdXNCdXR0b247XFxuXFx0ICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xcblxcdCAgbGkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcXG5cXHQgIGxpLnN0eWxlLmhlaWdodCA9ICcwJztcXG5cXHQgIGxpLmFwcGVuZENoaWxkKGZvY3VzQnV0dG9uKTtcXG5cXHQgIGxpc3QuYXBwZW5kQ2hpbGQobGkpO1xcblxcblxcdCAgZnVuY3Rpb24gY3JlYXRlTWVudUl0ZW1zIChsaXN0LCBkb21JdGVtcywgaXRlbXMpIHtcXG5cXHQgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xcblxcdCAgICAgIGlmIChpdGVtLnR5cGUgPT0gJ3NlcGFyYXRvcicpIHtcXG5cXHQgICAgICAgIC8vIGNyZWF0ZSBhIHNlcGFyYXRvclxcblxcdCAgICAgICAgdmFyIHNlcGFyYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgICAgICAgc2VwYXJhdG9yLmNsYXNzTmFtZSA9ICdzZXBhcmF0b3InO1xcblxcdCAgICAgICAgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xcblxcdCAgICAgICAgbGkuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yKTtcXG5cXHQgICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQobGkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIHtcXG5cXHQgICAgICAgIHZhciBkb21JdGVtID0ge307XFxuXFxuXFx0ICAgICAgICAvLyBjcmVhdGUgYSBtZW51IGl0ZW1cXG5cXHQgICAgICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XFxuXFx0ICAgICAgICBsaXN0LmFwcGVuZENoaWxkKGxpKTtcXG5cXG5cXHQgICAgICAgIC8vIGNyZWF0ZSBhIGJ1dHRvbiBpbiB0aGUgbWVudSBpdGVtXFxuXFx0ICAgICAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxuXFx0ICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gaXRlbS5jbGFzc05hbWU7XFxuXFx0ICAgICAgICBkb21JdGVtLmJ1dHRvbiA9IGJ1dHRvbjtcXG5cXHQgICAgICAgIGlmIChpdGVtLnRpdGxlKSB7XFxuXFx0ICAgICAgICAgIGJ1dHRvbi50aXRsZSA9IGl0ZW0udGl0bGU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoaXRlbS5jbGljaykge1xcblxcdCAgICAgICAgICBidXR0b24ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICBtZS5oaWRlKCk7XFxuXFx0ICAgICAgICAgICAgaXRlbS5jbGljaygpO1xcblxcdCAgICAgICAgICB9O1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcXG5cXG5cXHQgICAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIGJ1dHRvblxcblxcdCAgICAgICAgaWYgKGl0ZW0uc3VibWVudSkge1xcblxcdCAgICAgICAgICAvLyBhZGQgdGhlIGljb24gdG8gdGhlIGJ1dHRvblxcblxcdCAgICAgICAgICB2YXIgZGl2SWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgICAgICAgICBkaXZJY29uLmNsYXNzTmFtZSA9ICdpY29uJztcXG5cXHQgICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGRpdkljb24pO1xcblxcdCAgICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaXRlbS50ZXh0KSk7XFxuXFxuXFx0ICAgICAgICAgIHZhciBidXR0b25TdWJtZW51O1xcblxcdCAgICAgICAgICBpZiAoaXRlbS5jbGljaykge1xcblxcdCAgICAgICAgICAgIC8vIHN1Ym1lbnUgYW5kIGEgYnV0dG9uIHdpdGggYSBjbGljayBoYW5kbGVyXFxuXFx0ICAgICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSArPSAnIGRlZmF1bHQnO1xcblxcblxcdCAgICAgICAgICAgIHZhciBidXR0b25FeHBhbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcXG5cXHQgICAgICAgICAgICBkb21JdGVtLmJ1dHRvbkV4cGFuZCA9IGJ1dHRvbkV4cGFuZDtcXG5cXHQgICAgICAgICAgICBidXR0b25FeHBhbmQuY2xhc3NOYW1lID0gJ2V4cGFuZCc7XFxuXFx0ICAgICAgICAgICAgYnV0dG9uRXhwYW5kLmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVxcXCJleHBhbmRcXFwiPjwvZGl2Pic7XFxuXFx0ICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYnV0dG9uRXhwYW5kKTtcXG5cXHQgICAgICAgICAgICBpZiAoaXRlbS5zdWJtZW51VGl0bGUpIHtcXG5cXHQgICAgICAgICAgICAgIGJ1dHRvbkV4cGFuZC50aXRsZSA9IGl0ZW0uc3VibWVudVRpdGxlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBidXR0b25TdWJtZW51ID0gYnV0dG9uRXhwYW5kO1xcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgIC8vIHN1Ym1lbnUgYW5kIGEgYnV0dG9uIHdpdGhvdXQgYSBjbGljayBoYW5kbGVyXFxuXFx0ICAgICAgICAgICAgdmFyIGRpdkV4cGFuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcblxcdCAgICAgICAgICAgIGRpdkV4cGFuZC5jbGFzc05hbWUgPSAnZXhwYW5kJztcXG5cXHQgICAgICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQoZGl2RXhwYW5kKTtcXG5cXG5cXHQgICAgICAgICAgICBidXR0b25TdWJtZW51ID0gYnV0dG9uO1xcblxcdCAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgIC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gZXhwYW5kL2NvbGxhcHNlIHRoZSBzdWJtZW51XFxuXFx0ICAgICAgICAgIGJ1dHRvblN1Ym1lbnUub25jbGljayA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICBtZS5fb25FeHBhbmRJdGVtKGRvbUl0ZW0pO1xcblxcdCAgICAgICAgICAgIGJ1dHRvblN1Ym1lbnUuZm9jdXMoKTtcXG5cXHQgICAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgICAgLy8gY3JlYXRlIHRoZSBzdWJtZW51XFxuXFx0ICAgICAgICAgIHZhciBkb21TdWJJdGVtcyA9IFtdO1xcblxcdCAgICAgICAgICBkb21JdGVtLnN1Ykl0ZW1zID0gZG9tU3ViSXRlbXM7XFxuXFx0ICAgICAgICAgIHZhciB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XFxuXFx0ICAgICAgICAgIGRvbUl0ZW0udWwgPSB1bDtcXG5cXHQgICAgICAgICAgdWwuY2xhc3NOYW1lID0gJ21lbnUnO1xcblxcdCAgICAgICAgICB1bC5zdHlsZS5oZWlnaHQgPSAnMCc7XFxuXFx0ICAgICAgICAgIGxpLmFwcGVuZENoaWxkKHVsKTtcXG5cXHQgICAgICAgICAgY3JlYXRlTWVudUl0ZW1zKHVsLCBkb21TdWJJdGVtcywgaXRlbS5zdWJtZW51KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAvLyBubyBzdWJtZW51LCBqdXN0IGEgYnV0dG9uIHdpdGggY2xpY2toYW5kbGVyXFxuXFx0ICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cXFwiaWNvblxcXCI+PC9kaXY+JyArIGl0ZW0udGV4dDtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGRvbUl0ZW1zLnB1c2goZG9tSXRlbSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXHQgIGNyZWF0ZU1lbnVJdGVtcyhsaXN0LCB0aGlzLmRvbS5pdGVtcywgaXRlbXMpO1xcblxcblxcdCAgLy8gVE9ETzogd2hlbiB0aGUgZWRpdG9yIGlzIHNtYWxsLCBzaG93IHRoZSBzdWJtZW51IG9uIHRoZSByaWdodCBpbnN0ZWFkIG9mIGlubGluZT9cXG5cXG5cXHQgIC8vIGNhbGN1bGF0ZSB0aGUgbWF4IGhlaWdodCBvZiB0aGUgbWVudSB3aXRoIG9uZSBzdWJtZW51IGV4cGFuZGVkXFxuXFx0ICB0aGlzLm1heEhlaWdodCA9IDA7IC8vIGhlaWdodCBpbiBwaXhlbHNcXG5cXHQgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcXG5cXHQgICAgdmFyIGhlaWdodCA9IChpdGVtcy5sZW5ndGggKyAoaXRlbS5zdWJtZW51ID8gaXRlbS5zdWJtZW51Lmxlbmd0aCA6IDApKSAqIDI0O1xcblxcdCAgICBtZS5tYXhIZWlnaHQgPSBNYXRoLm1heChtZS5tYXhIZWlnaHQsIGhlaWdodCk7XFxuXFx0ICB9KTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogR2V0IHRoZSBjdXJyZW50bHkgdmlzaWJsZSBidXR0b25zXFxuXFx0ICogQHJldHVybiB7QXJyYXkuPEhUTUxFbGVtZW50Pn0gYnV0dG9uc1xcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Q29udGV4dE1lbnUucHJvdG90eXBlLl9nZXRWaXNpYmxlQnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgIHZhciBidXR0b25zID0gW107XFxuXFx0ICB2YXIgbWUgPSB0aGlzO1xcblxcdCAgdGhpcy5kb20uaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xcblxcdCAgICBidXR0b25zLnB1c2goaXRlbS5idXR0b24pO1xcblxcdCAgICBpZiAoaXRlbS5idXR0b25FeHBhbmQpIHtcXG5cXHQgICAgICBidXR0b25zLnB1c2goaXRlbS5idXR0b25FeHBhbmQpO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmIChpdGVtLnN1Ykl0ZW1zICYmIGl0ZW0gPT0gbWUuZXhwYW5kZWRJdGVtKSB7XFxuXFx0ICAgICAgaXRlbS5zdWJJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJJdGVtKSB7XFxuXFx0ICAgICAgICBidXR0b25zLnB1c2goc3ViSXRlbS5idXR0b24pO1xcblxcdCAgICAgICAgaWYgKHN1Ykl0ZW0uYnV0dG9uRXhwYW5kKSB7XFxuXFx0ICAgICAgICAgIGJ1dHRvbnMucHVzaChzdWJJdGVtLmJ1dHRvbkV4cGFuZCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgdG8gZnVsbHkgcmVjdXJzaXZlIG1ldGhvZFxcblxcdCAgICAgIH0pO1xcblxcdCAgICB9XFxuXFx0ICB9KTtcXG5cXG5cXHQgIHJldHVybiBidXR0b25zO1xcblxcdH07XFxuXFxuXFx0Ly8gY3VycmVudGx5IGRpc3BsYXllZCBjb250ZXh0IG1lbnUsIGEgc2luZ2xldG9uLiBXZSBtYXkgb25seSBoYXZlIG9uZSB2aXNpYmxlIGNvbnRleHQgbWVudVxcblxcdENvbnRleHRNZW51LnZpc2libGVNZW51ID0gdW5kZWZpbmVkO1xcblxcblxcdC8qKlxcblxcdCAqIEF0dGFjaCB0aGUgbWVudSB0byBhbiBhbmNob3JcXG5cXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhbmNob3JcXG5cXHQgKi9cXG5cXHRDb250ZXh0TWVudS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChhbmNob3IpIHtcXG5cXHQgIHRoaXMuaGlkZSgpO1xcblxcblxcdCAgLy8gY2FsY3VsYXRlIHdoZXRoZXIgdGhlIG1lbnUgZml0cyBiZWxvdyB0aGUgYW5jaG9yXFxuXFx0ICB2YXIgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0LFxcblxcdCAgICAgIHdpbmRvd1Njcm9sbCA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsVG9wIHx8IDApLFxcblxcdCAgICAgIHdpbmRvd0JvdHRvbSA9IHdpbmRvd0hlaWdodCArIHdpbmRvd1Njcm9sbCxcXG5cXHQgICAgICBhbmNob3JIZWlnaHQgPSBhbmNob3Iub2Zmc2V0SGVpZ2h0LFxcblxcdCAgICAgIG1lbnVIZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcXG5cXG5cXHQgIC8vIHBvc2l0aW9uIHRoZSBtZW51XFxuXFx0ICB2YXIgbGVmdCA9IHV0aWwuZ2V0QWJzb2x1dGVMZWZ0KGFuY2hvcik7XFxuXFx0ICB2YXIgdG9wID0gdXRpbC5nZXRBYnNvbHV0ZVRvcChhbmNob3IpO1xcblxcdCAgaWYgKHRvcCArIGFuY2hvckhlaWdodCArIG1lbnVIZWlnaHQgPCB3aW5kb3dCb3R0b20pIHtcXG5cXHQgICAgLy8gZGlzcGxheSB0aGUgbWVudSBiZWxvdyB0aGUgYW5jaG9yXFxuXFx0ICAgIHRoaXMuZG9tLm1lbnUuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xcblxcdCAgICB0aGlzLmRvbS5tZW51LnN0eWxlLnRvcCA9ICh0b3AgKyBhbmNob3JIZWlnaHQpICsgJ3B4JztcXG5cXHQgICAgdGhpcy5kb20ubWVudS5zdHlsZS5ib3R0b20gPSAnJztcXG5cXHQgIH1cXG5cXHQgIGVsc2Uge1xcblxcdCAgICAvLyBkaXNwbGF5IHRoZSBtZW51IGFib3ZlIHRoZSBhbmNob3JcXG5cXHQgICAgdGhpcy5kb20ubWVudS5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XFxuXFx0ICAgIHRoaXMuZG9tLm1lbnUuc3R5bGUudG9wID0gJyc7XFxuXFx0ICAgIHRoaXMuZG9tLm1lbnUuc3R5bGUuYm90dG9tID0gKHdpbmRvd0hlaWdodCAtIHRvcCkgKyAncHgnO1xcblxcdCAgfVxcblxcblxcdCAgLy8gYXR0YWNoIHRoZSBtZW51IHRvIHRoZSBkb2N1bWVudFxcblxcdCAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRvbS5tZW51KTtcXG5cXG5cXHQgIC8vIGNyZWF0ZSBhbmQgYXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xcblxcdCAgdmFyIG1lID0gdGhpcztcXG5cXHQgIHZhciBsaXN0ID0gdGhpcy5kb20ubGlzdDtcXG5cXHQgIHRoaXMuZXZlbnRMaXN0ZW5lcnMubW91c2Vkb3duID0gdXRpbC5hZGRFdmVudExpc3RlbmVyKFxcblxcdCAgICAgIGRvY3VtZW50LCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICAgICAgICAvLyBoaWRlIG1lbnUgb24gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudVxcblxcdCAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcXG5cXHQgICAgICAgIGlmICgodGFyZ2V0ICE9IGxpc3QpICYmICFtZS5faXNDaGlsZE9mKHRhcmdldCwgbGlzdCkpIHtcXG5cXHQgICAgICAgICAgbWUuaGlkZSgpO1xcblxcdCAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9KTtcXG5cXHQgIHRoaXMuZXZlbnRMaXN0ZW5lcnMubW91c2V3aGVlbCA9IHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihcXG5cXHQgICAgICBkb2N1bWVudCwgJ21vdXNld2hlZWwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgICAgICAgIC8vIGJsb2NrIHNjcm9sbGluZyB3aGVuIGNvbnRleHQgbWVudSBpcyB2aXNpYmxlXFxuXFx0ICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgICAgfSk7XFxuXFx0ICB0aGlzLmV2ZW50TGlzdGVuZXJzLmtleWRvd24gPSB1dGlsLmFkZEV2ZW50TGlzdGVuZXIoXFxuXFx0ICAgICAgZG9jdW1lbnQsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0ICAgICAgICBtZS5fb25LZXlEb3duKGV2ZW50KTtcXG5cXHQgICAgICB9KTtcXG5cXG5cXHQgIC8vIG1vdmUgZm9jdXMgdG8gdGhlIGZpcnN0IGJ1dHRvbiBpbiB0aGUgY29udGV4dCBtZW51XFxuXFx0ICB0aGlzLnNlbGVjdGlvbiA9IHV0aWwuZ2V0U2VsZWN0aW9uKCk7XFxuXFx0ICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcXG5cXHQgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdCAgICBtZS5kb20uZm9jdXNCdXR0b24uZm9jdXMoKTtcXG5cXHQgIH0sIDApO1xcblxcblxcdCAgaWYgKENvbnRleHRNZW51LnZpc2libGVNZW51KSB7XFxuXFx0ICAgIENvbnRleHRNZW51LnZpc2libGVNZW51LmhpZGUoKTtcXG5cXHQgIH1cXG5cXHQgIENvbnRleHRNZW51LnZpc2libGVNZW51ID0gdGhpcztcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhpZGUgdGhlIGNvbnRleHQgbWVudSBpZiB2aXNpYmxlXFxuXFx0ICovXFxuXFx0Q29udGV4dE1lbnUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAvLyByZW1vdmUgdGhlIG1lbnUgZnJvbSB0aGUgRE9NXFxuXFx0ICBpZiAodGhpcy5kb20ubWVudS5wYXJlbnROb2RlKSB7XFxuXFx0ICAgIHRoaXMuZG9tLm1lbnUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbS5tZW51KTtcXG5cXHQgICAgaWYgKHRoaXMub25DbG9zZSkge1xcblxcdCAgICAgIHRoaXMub25DbG9zZSgpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVyc1xcblxcdCAgLy8gYWxsIGV2ZW50IGxpc3RlbmVycyBhcmUgc3VwcG9zZWQgdG8gYmUgYXR0YWNoZWQgdG8gZG9jdW1lbnQuXFxuXFx0ICBmb3IgKHZhciBuYW1lIGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcXG5cXHQgICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXG5cXHQgICAgICB2YXIgZm4gPSB0aGlzLmV2ZW50TGlzdGVuZXJzW25hbWVdO1xcblxcdCAgICAgIGlmIChmbikge1xcblxcdCAgICAgICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKGRvY3VtZW50LCBuYW1lLCBmbik7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50TGlzdGVuZXJzW25hbWVdO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoQ29udGV4dE1lbnUudmlzaWJsZU1lbnUgPT0gdGhpcykge1xcblxcdCAgICBDb250ZXh0TWVudS52aXNpYmxlTWVudSA9IHVuZGVmaW5lZDtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEV4cGFuZCBhIHN1Ym1lbnVcXG5cXHQgKiBBbnkgY3VycmVudGx5IGV4cGFuZGVkIHN1Ym1lbnUgd2lsbCBiZSBoaWRlZC5cXG5cXHQgKiBAcGFyYW0ge09iamVjdH0gZG9tSXRlbVxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Q29udGV4dE1lbnUucHJvdG90eXBlLl9vbkV4cGFuZEl0ZW0gPSBmdW5jdGlvbiAoZG9tSXRlbSkge1xcblxcdCAgdmFyIG1lID0gdGhpcztcXG5cXHQgIHZhciBhbHJlYWR5VmlzaWJsZSA9IChkb21JdGVtID09IHRoaXMuZXhwYW5kZWRJdGVtKTtcXG5cXG5cXHQgIC8vIGhpZGUgdGhlIGN1cnJlbnRseSB2aXNpYmxlIHN1Ym1lbnVcXG5cXHQgIHZhciBleHBhbmRlZEl0ZW0gPSB0aGlzLmV4cGFuZGVkSXRlbTtcXG5cXHQgIGlmIChleHBhbmRlZEl0ZW0pIHtcXG5cXHQgICAgLy92YXIgdWwgPSBleHBhbmRlZEl0ZW0udWw7XFxuXFx0ICAgIGV4cGFuZGVkSXRlbS51bC5zdHlsZS5oZWlnaHQgPSAnMCc7XFxuXFx0ICAgIGV4cGFuZGVkSXRlbS51bC5zdHlsZS5wYWRkaW5nID0gJyc7XFxuXFx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdCAgICAgIGlmIChtZS5leHBhbmRlZEl0ZW0gIT0gZXhwYW5kZWRJdGVtKSB7XFxuXFx0ICAgICAgICBleHBhbmRlZEl0ZW0udWwuc3R5bGUuZGlzcGxheSA9ICcnO1xcblxcdCAgICAgICAgdXRpbC5yZW1vdmVDbGFzc05hbWUoZXhwYW5kZWRJdGVtLnVsLnBhcmVudE5vZGUsICdzZWxlY3RlZCcpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSwgMzAwKTsgLy8gdGltZW91dCBkdXJhdGlvbiBtdXN0IG1hdGNoIHRoZSBjc3MgdHJhbnNpdGlvbiBkdXJhdGlvblxcblxcdCAgICB0aGlzLmV4cGFuZGVkSXRlbSA9IHVuZGVmaW5lZDtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmICghYWxyZWFkeVZpc2libGUpIHtcXG5cXHQgICAgdmFyIHVsID0gZG9tSXRlbS51bDtcXG5cXHQgICAgdWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XFxuXFx0ICAgIHZhciBoZWlnaHQgPSB1bC5jbGllbnRIZWlnaHQ7IC8vIGZvcmNlIGEgcmVmbG93IGluIEZpcmVmb3hcXG5cXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgaWYgKG1lLmV4cGFuZGVkSXRlbSA9PSBkb21JdGVtKSB7XFxuXFx0ICAgICAgICB1bC5zdHlsZS5oZWlnaHQgPSAodWwuY2hpbGROb2Rlcy5sZW5ndGggKiAyNCkgKyAncHgnO1xcblxcdCAgICAgICAgdWwuc3R5bGUucGFkZGluZyA9ICc1cHggMTBweCc7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9LCAwKTtcXG5cXHQgICAgdXRpbC5hZGRDbGFzc05hbWUodWwucGFyZW50Tm9kZSwgJ3NlbGVjdGVkJyk7XFxuXFx0ICAgIHRoaXMuZXhwYW5kZWRJdGVtID0gZG9tSXRlbTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEhhbmRsZSBvbmtleWRvd24gZXZlbnRcXG5cXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxcblxcdCAqIEBwcml2YXRlXFxuXFx0ICovXFxuXFx0Q29udGV4dE1lbnUucHJvdG90eXBlLl9vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XFxuXFx0ICB2YXIga2V5bnVtID0gZXZlbnQud2hpY2g7XFxuXFx0ICB2YXIgaGFuZGxlZCA9IGZhbHNlO1xcblxcdCAgdmFyIGJ1dHRvbnMsIHRhcmdldEluZGV4LCBwcmV2QnV0dG9uLCBuZXh0QnV0dG9uO1xcblxcblxcdCAgaWYgKGtleW51bSA9PSAyNykgeyAvLyBFU0NcXG5cXHQgICAgLy8gaGlkZSB0aGUgbWVudSBvbiBFU0Mga2V5XFxuXFxuXFx0ICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc2VsZWN0aW9uIGFuZCBmb2N1c1xcblxcdCAgICBpZiAodGhpcy5zZWxlY3Rpb24pIHtcXG5cXHQgICAgICB1dGlsLnNldFNlbGVjdGlvbih0aGlzLnNlbGVjdGlvbik7XFxuXFx0ICAgIH1cXG5cXHQgICAgaWYgKHRoaXMuYW5jaG9yKSB7XFxuXFx0ICAgICAgdGhpcy5hbmNob3IuZm9jdXMoKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB0aGlzLmhpZGUoKTtcXG5cXG5cXHQgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICB9XFxuXFx0ICBlbHNlIGlmIChrZXludW0gPT0gOSkgeyAvLyBUYWJcXG5cXHQgICAgaWYgKCFldmVudC5zaGlmdEtleSkgeyAvLyBUYWJcXG5cXHQgICAgICBidXR0b25zID0gdGhpcy5fZ2V0VmlzaWJsZUJ1dHRvbnMoKTtcXG5cXHQgICAgICB0YXJnZXRJbmRleCA9IGJ1dHRvbnMuaW5kZXhPZih0YXJnZXQpO1xcblxcdCAgICAgIGlmICh0YXJnZXRJbmRleCA9PSBidXR0b25zLmxlbmd0aCAtIDEpIHtcXG5cXHQgICAgICAgIC8vIG1vdmUgdG8gZmlyc3QgYnV0dG9uXFxuXFx0ICAgICAgICBidXR0b25zWzBdLmZvY3VzKCk7XFxuXFx0ICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7IC8vIFNoaWZ0K1RhYlxcblxcdCAgICAgIGJ1dHRvbnMgPSB0aGlzLl9nZXRWaXNpYmxlQnV0dG9ucygpO1xcblxcdCAgICAgIHRhcmdldEluZGV4ID0gYnV0dG9ucy5pbmRleE9mKHRhcmdldCk7XFxuXFx0ICAgICAgaWYgKHRhcmdldEluZGV4ID09IDApIHtcXG5cXHQgICAgICAgIC8vIG1vdmUgdG8gbGFzdCBidXR0b25cXG5cXHQgICAgICAgIGJ1dHRvbnNbYnV0dG9ucy5sZW5ndGggLSAxXS5mb2N1cygpO1xcblxcdCAgICAgICAgaGFuZGxlZCA9IHRydWU7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFx0ICBlbHNlIGlmIChrZXludW0gPT0gMzcpIHsgLy8gQXJyb3cgTGVmdFxcblxcdCAgICBpZiAodGFyZ2V0LmNsYXNzTmFtZSA9PSAnZXhwYW5kJykge1xcblxcdCAgICAgIGJ1dHRvbnMgPSB0aGlzLl9nZXRWaXNpYmxlQnV0dG9ucygpO1xcblxcdCAgICAgIHRhcmdldEluZGV4ID0gYnV0dG9ucy5pbmRleE9mKHRhcmdldCk7XFxuXFx0ICAgICAgcHJldkJ1dHRvbiA9IGJ1dHRvbnNbdGFyZ2V0SW5kZXggLSAxXTtcXG5cXHQgICAgICBpZiAocHJldkJ1dHRvbikge1xcblxcdCAgICAgICAgcHJldkJ1dHRvbi5mb2N1cygpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSAzOCkgeyAvLyBBcnJvdyBVcFxcblxcdCAgICBidXR0b25zID0gdGhpcy5fZ2V0VmlzaWJsZUJ1dHRvbnMoKTtcXG5cXHQgICAgdGFyZ2V0SW5kZXggPSBidXR0b25zLmluZGV4T2YodGFyZ2V0KTtcXG5cXHQgICAgcHJldkJ1dHRvbiA9IGJ1dHRvbnNbdGFyZ2V0SW5kZXggLSAxXTtcXG5cXHQgICAgaWYgKHByZXZCdXR0b24gJiYgcHJldkJ1dHRvbi5jbGFzc05hbWUgPT0gJ2V4cGFuZCcpIHtcXG5cXHQgICAgICAvLyBza2lwIGV4cGFuZCBidXR0b25cXG5cXHQgICAgICBwcmV2QnV0dG9uID0gYnV0dG9uc1t0YXJnZXRJbmRleCAtIDJdO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmICghcHJldkJ1dHRvbikge1xcblxcdCAgICAgIC8vIG1vdmUgdG8gbGFzdCBidXR0b25cXG5cXHQgICAgICBwcmV2QnV0dG9uID0gYnV0dG9uc1tidXR0b25zLmxlbmd0aCAtIDFdO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmIChwcmV2QnV0dG9uKSB7XFxuXFx0ICAgICAgcHJldkJ1dHRvbi5mb2N1cygpO1xcblxcdCAgICB9XFxuXFx0ICAgIGhhbmRsZWQgPSB0cnVlO1xcblxcdCAgfVxcblxcdCAgZWxzZSBpZiAoa2V5bnVtID09IDM5KSB7IC8vIEFycm93IFJpZ2h0XFxuXFx0ICAgIGJ1dHRvbnMgPSB0aGlzLl9nZXRWaXNpYmxlQnV0dG9ucygpO1xcblxcdCAgICB0YXJnZXRJbmRleCA9IGJ1dHRvbnMuaW5kZXhPZih0YXJnZXQpO1xcblxcdCAgICBuZXh0QnV0dG9uID0gYnV0dG9uc1t0YXJnZXRJbmRleCArIDFdO1xcblxcdCAgICBpZiAobmV4dEJ1dHRvbiAmJiBuZXh0QnV0dG9uLmNsYXNzTmFtZSA9PSAnZXhwYW5kJykge1xcblxcdCAgICAgIG5leHRCdXR0b24uZm9jdXMoKTtcXG5cXHQgICAgfVxcblxcdCAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgIH1cXG5cXHQgIGVsc2UgaWYgKGtleW51bSA9PSA0MCkgeyAvLyBBcnJvdyBEb3duXFxuXFx0ICAgIGJ1dHRvbnMgPSB0aGlzLl9nZXRWaXNpYmxlQnV0dG9ucygpO1xcblxcdCAgICB0YXJnZXRJbmRleCA9IGJ1dHRvbnMuaW5kZXhPZih0YXJnZXQpO1xcblxcdCAgICBuZXh0QnV0dG9uID0gYnV0dG9uc1t0YXJnZXRJbmRleCArIDFdO1xcblxcdCAgICBpZiAobmV4dEJ1dHRvbiAmJiBuZXh0QnV0dG9uLmNsYXNzTmFtZSA9PSAnZXhwYW5kJykge1xcblxcdCAgICAgIC8vIHNraXAgZXhwYW5kIGJ1dHRvblxcblxcdCAgICAgIG5leHRCdXR0b24gPSBidXR0b25zW3RhcmdldEluZGV4ICsgMl07XFxuXFx0ICAgIH1cXG5cXHQgICAgaWYgKCFuZXh0QnV0dG9uKSB7XFxuXFx0ICAgICAgLy8gbW92ZSB0byBmaXJzdCBidXR0b25cXG5cXHQgICAgICBuZXh0QnV0dG9uID0gYnV0dG9uc1swXTtcXG5cXHQgICAgfVxcblxcdCAgICBpZiAobmV4dEJ1dHRvbikge1xcblxcdCAgICAgIG5leHRCdXR0b24uZm9jdXMoKTtcXG5cXHQgICAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcdCAgICBoYW5kbGVkID0gdHJ1ZTtcXG5cXHQgIH1cXG5cXHQgIC8vIFRPRE86IGFycm93IGxlZnQgYW5kIHJpZ2h0XFxuXFxuXFx0ICBpZiAoaGFuZGxlZCkge1xcblxcdCAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHQgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHQgIH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFRlc3QgaWYgYW4gZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgcGFyZW50IGVsZW1lbnQuXFxuXFx0ICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZFxcblxcdCAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XFxuXFx0ICogQHJldHVybiB7Ym9vbGVhbn0gaXNDaGlsZFxcblxcdCAqL1xcblxcdENvbnRleHRNZW51LnByb3RvdHlwZS5faXNDaGlsZE9mID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcXG5cXHQgIHZhciBlID0gY2hpbGQucGFyZW50Tm9kZTtcXG5cXHQgIHdoaWxlIChlKSB7XFxuXFx0ICAgIGlmIChlID09IHBhcmVudCkge1xcblxcdCAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICAgIGUgPSBlLnBhcmVudE5vZGU7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gZmFsc2U7XFxuXFx0fTtcXG5cXG5cXHRtb2R1bGUuZXhwb3J0cyA9IENvbnRleHRNZW51O1xcblxcblxcbi8qKiovIH0sXFxuLyogMTEgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHR2YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XFxuXFx0dmFyIENvbnRleHRNZW51ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBBcHBlbmROb2RlLCB3aGljaCBkZXBlbmRzIG9uIGEgTm9kZVxcblxcdCAqIEBwYXJhbSB7Tm9kZX0gTm9kZVxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIGFwcGVuZE5vZGVGYWN0b3J5KE5vZGUpIHtcXG5cXHQgIC8qKlxcblxcdCAgICogQGNvbnN0cnVjdG9yIEFwcGVuZE5vZGVcXG5cXHQgICAqIEBleHRlbmRzIE5vZGVcXG5cXHQgICAqIEBwYXJhbSB7VHJlZUVkaXRvcn0gZWRpdG9yXFxuXFx0ICAgKiBDcmVhdGUgYSBuZXcgQXBwZW5kTm9kZS4gVGhpcyBpcyBhIHNwZWNpYWwgbm9kZSB3aGljaCBpcyBjcmVhdGVkIGF0IHRoZVxcblxcdCAgICogZW5kIG9mIHRoZSBsaXN0IHdpdGggY2hpbGRzIGZvciBhbiBvYmplY3Qgb3IgYXJyYXlcXG5cXHQgICAqL1xcblxcdCAgZnVuY3Rpb24gQXBwZW5kTm9kZSAoZWRpdG9yKSB7XFxuXFx0ICAgIC8qKiBAdHlwZSB7VHJlZUVkaXRvcn0gKi9cXG5cXHQgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XFxuXFx0ICAgIHRoaXMuZG9tID0ge307XFxuXFx0ICB9XFxuXFxuXFx0ICBBcHBlbmROb2RlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCk7XFxuXFxuXFx0ICAvKipcXG5cXHQgICAqIFJldHVybiBhIHRhYmxlIHJvdyB3aXRoIGFuIGFwcGVuZCBidXR0b24uXFxuXFx0ICAgKiBAcmV0dXJuIHtFbGVtZW50fSBkb20gICBUUiBlbGVtZW50XFxuXFx0ICAgKi9cXG5cXHQgIEFwcGVuZE5vZGUucHJvdG90eXBlLmdldERvbSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgLy8gVE9ETzogaW1wbGVtZW50IGEgbmV3IHNvbHV0aW9uIGZvciB0aGUgYXBwZW5kIG5vZGVcXG5cXHQgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xcblxcblxcdCAgICBpZiAoZG9tLnRyKSB7XFxuXFx0ICAgICAgcmV0dXJuIGRvbS50cjtcXG5cXHQgICAgfVxcblxcblxcdCAgICB0aGlzLl91cGRhdGVFZGl0YWJpbGl0eSgpO1xcblxcblxcdCAgICAvLyBhIHJvdyBmb3IgdGhlIGFwcGVuZCBidXR0b25cXG5cXHQgICAgdmFyIHRyQXBwZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcXG5cXHQgICAgdHJBcHBlbmQubm9kZSA9IHRoaXM7XFxuXFx0ICAgIGRvbS50ciA9IHRyQXBwZW5kO1xcblxcblxcdCAgICAvLyBUT0RPOiBjb25zaXN0ZW50IG5hbWluZ1xcblxcblxcdCAgICBpZiAodGhpcy5lZGl0YWJsZS5maWVsZCkge1xcblxcdCAgICAgIC8vIGEgY2VsbCBmb3IgdGhlIGRyYWdhcmVhIGNvbHVtblxcblxcdCAgICAgIGRvbS50ZERyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xcblxcblxcdCAgICAgIC8vIGNyZWF0ZSBjb250ZXh0IG1lbnVcXG5cXHQgICAgICB2YXIgdGRNZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcXG5cXHQgICAgICBkb20udGRNZW51ID0gdGRNZW51O1xcblxcdCAgICAgIHZhciBtZW51ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XFxuXFx0ICAgICAgbWVudS5jbGFzc05hbWUgPSAnY29udGV4dG1lbnUnO1xcblxcdCAgICAgIG1lbnUudGl0bGUgPSAnQ2xpY2sgdG8gb3BlbiB0aGUgYWN0aW9ucyBtZW51IChDdHJsK00pJztcXG5cXHQgICAgICBkb20ubWVudSA9IG1lbnU7XFxuXFx0ICAgICAgdGRNZW51LmFwcGVuZENoaWxkKGRvbS5tZW51KTtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBhIGNlbGwgZm9yIHRoZSBjb250ZW50cyAoc2hvd2luZyB0ZXh0ICdlbXB0eScpXFxuXFx0ICAgIHZhciB0ZEFwcGVuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XFxuXFx0ICAgIHZhciBkb21UZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuXFx0ICAgIGRvbVRleHQuaW5uZXJIVE1MID0gJyhlbXB0eSknO1xcblxcdCAgICBkb21UZXh0LmNsYXNzTmFtZSA9ICdyZWFkb25seSc7XFxuXFx0ICAgIHRkQXBwZW5kLmFwcGVuZENoaWxkKGRvbVRleHQpO1xcblxcdCAgICBkb20udGQgPSB0ZEFwcGVuZDtcXG5cXHQgICAgZG9tLnRleHQgPSBkb21UZXh0O1xcblxcblxcdCAgICB0aGlzLnVwZGF0ZURvbSgpO1xcblxcblxcdCAgICByZXR1cm4gdHJBcHBlbmQ7XFxuXFx0ICB9O1xcblxcblxcdCAgLyoqXFxuXFx0ICAgKiBVcGRhdGUgdGhlIEhUTUwgZG9tIG9mIHRoZSBOb2RlXFxuXFx0ICAgKi9cXG5cXHQgIEFwcGVuZE5vZGUucHJvdG90eXBlLnVwZGF0ZURvbSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xcblxcdCAgICB2YXIgdGRBcHBlbmQgPSBkb20udGQ7XFxuXFx0ICAgIGlmICh0ZEFwcGVuZCkge1xcblxcdCAgICAgIHRkQXBwZW5kLnN0eWxlLnBhZGRpbmdMZWZ0ID0gKHRoaXMuZ2V0TGV2ZWwoKSAqIDI0ICsgMjYpICsgJ3B4JztcXG5cXHQgICAgICAvLyBUT0RPOiBub3Qgc28gbmljZSBoYXJkIGNvZGVkIG9mZnNldFxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHZhciBkb21UZXh0ID0gZG9tLnRleHQ7XFxuXFx0ICAgIGlmIChkb21UZXh0KSB7XFxuXFx0ICAgICAgZG9tVGV4dC5pbm5lckhUTUwgPSAnKGVtcHR5ICcgKyB0aGlzLnBhcmVudC50eXBlICsgJyknO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGF0dGFjaCBvciBkZXRhY2ggdGhlIGNvbnRlbnRzIG9mIHRoZSBhcHBlbmQgbm9kZTpcXG5cXHQgICAgLy8gaGlkZSB3aGVuIHRoZSBwYXJlbnQgaGFzIGNoaWxkcywgc2hvdyB3aGVuIHRoZSBwYXJlbnQgaGFzIG5vIGNoaWxkc1xcblxcdCAgICB2YXIgdHJBcHBlbmQgPSBkb20udHI7XFxuXFx0ICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xcblxcdCAgICAgIGlmIChkb20udHIuZmlyc3RDaGlsZCkge1xcblxcdCAgICAgICAgaWYgKGRvbS50ZERyYWcpIHtcXG5cXHQgICAgICAgICAgdHJBcHBlbmQucmVtb3ZlQ2hpbGQoZG9tLnRkRHJhZyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoZG9tLnRkTWVudSkge1xcblxcdCAgICAgICAgICB0ckFwcGVuZC5yZW1vdmVDaGlsZChkb20udGRNZW51KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRyQXBwZW5kLnJlbW92ZUNoaWxkKHRkQXBwZW5kKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgZWxzZSB7XFxuXFx0ICAgICAgaWYgKCFkb20udHIuZmlyc3RDaGlsZCkge1xcblxcdCAgICAgICAgaWYgKGRvbS50ZERyYWcpIHtcXG5cXHQgICAgICAgICAgdHJBcHBlbmQuYXBwZW5kQ2hpbGQoZG9tLnRkRHJhZyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoZG9tLnRkTWVudSkge1xcblxcdCAgICAgICAgICB0ckFwcGVuZC5hcHBlbmRDaGlsZChkb20udGRNZW51KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRyQXBwZW5kLmFwcGVuZENoaWxkKHRkQXBwZW5kKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH07XFxuXFxuXFx0ICAvKipcXG5cXHQgICAqIENoZWNrIHdoZXRoZXIgdGhlIEFwcGVuZE5vZGUgaXMgY3VycmVudGx5IHZpc2libGUuXFxuXFx0ICAgKiB0aGUgQXBwZW5kTm9kZSBpcyB2aXNpYmxlIHdoZW4gaXRzIHBhcmVudCBoYXMgbm8gY2hpbGRzIChpLmUuIGlzIGVtcHR5KS5cXG5cXHQgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzVmlzaWJsZVxcblxcdCAgICovXFxuXFx0ICBBcHBlbmROb2RlLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgIHJldHVybiAodGhpcy5wYXJlbnQuY2hpbGRzLmxlbmd0aCA9PSAwKTtcXG5cXHQgIH07XFxuXFxuXFx0ICAvKipcXG5cXHQgICAqIFNob3cgYSBjb250ZXh0bWVudSBmb3IgdGhpcyBub2RlXFxuXFx0ICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhbmNob3IgICBUaGUgZWxlbWVudCB0byBhdHRhY2ggdGhlIG1lbnUgdG8uXFxuXFx0ICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb25DbG9zZV0gICBDYWxsYmFjayBtZXRob2QgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudVxcblxcdCAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYmVpbmcgY2xvc2VkLlxcblxcdCAgICovXFxuXFx0ICBBcHBlbmROb2RlLnByb3RvdHlwZS5zaG93Q29udGV4dE1lbnUgPSBmdW5jdGlvbiAoYW5jaG9yLCBvbkNsb3NlKSB7XFxuXFx0ICAgIHZhciBub2RlID0gdGhpcztcXG5cXHQgICAgdmFyIHRpdGxlcyA9IE5vZGUuVFlQRV9USVRMRVM7XFxuXFx0ICAgIHZhciBpdGVtcyA9IFtcXG5cXHQgICAgICAvLyBjcmVhdGUgYXBwZW5kIGJ1dHRvblxcblxcdCAgICAgIHtcXG5cXHQgICAgICAgICd0ZXh0JzogJ0FwcGVuZCcsXFxuXFx0ICAgICAgICAndGl0bGUnOiAnQXBwZW5kIGEgbmV3IGZpZWxkIHdpdGggdHlwZSBcXFxcJ2F1dG9cXFxcJyAoQ3RybCtTaGlmdCtJbnMpJyxcXG5cXHQgICAgICAgICdzdWJtZW51VGl0bGUnOiAnU2VsZWN0IHRoZSB0eXBlIG9mIHRoZSBmaWVsZCB0byBiZSBhcHBlbmRlZCcsXFxuXFx0ICAgICAgICAnY2xhc3NOYW1lJzogJ2luc2VydCcsXFxuXFx0ICAgICAgICAnY2xpY2snOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIG5vZGUuX29uQXBwZW5kKCcnLCAnJywgJ2F1dG8nKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICAnc3VibWVudSc6IFtcXG5cXHQgICAgICAgICAge1xcblxcdCAgICAgICAgICAgICd0ZXh0JzogJ0F1dG8nLFxcblxcdCAgICAgICAgICAgICdjbGFzc05hbWUnOiAndHlwZS1hdXRvJyxcXG5cXHQgICAgICAgICAgICAndGl0bGUnOiB0aXRsZXMuYXV0byxcXG5cXHQgICAgICAgICAgICAnY2xpY2snOiBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgICBub2RlLl9vbkFwcGVuZCgnJywgJycsICdhdXRvJyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICB9LFxcblxcdCAgICAgICAgICB7XFxuXFx0ICAgICAgICAgICAgJ3RleHQnOiAnQXJyYXknLFxcblxcdCAgICAgICAgICAgICdjbGFzc05hbWUnOiAndHlwZS1hcnJheScsXFxuXFx0ICAgICAgICAgICAgJ3RpdGxlJzogdGl0bGVzLmFycmF5LFxcblxcdCAgICAgICAgICAgICdjbGljayc6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICAgIG5vZGUuX29uQXBwZW5kKCcnLCBbXSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICB9LFxcblxcdCAgICAgICAgICB7XFxuXFx0ICAgICAgICAgICAgJ3RleHQnOiAnT2JqZWN0JyxcXG5cXHQgICAgICAgICAgICAnY2xhc3NOYW1lJzogJ3R5cGUtb2JqZWN0JyxcXG5cXHQgICAgICAgICAgICAndGl0bGUnOiB0aXRsZXMub2JqZWN0LFxcblxcdCAgICAgICAgICAgICdjbGljayc6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICAgIG5vZGUuX29uQXBwZW5kKCcnLCB7fSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICB9LFxcblxcdCAgICAgICAgICB7XFxuXFx0ICAgICAgICAgICAgJ3RleHQnOiAnU3RyaW5nJyxcXG5cXHQgICAgICAgICAgICAnY2xhc3NOYW1lJzogJ3R5cGUtc3RyaW5nJyxcXG5cXHQgICAgICAgICAgICAndGl0bGUnOiB0aXRsZXMuc3RyaW5nLFxcblxcdCAgICAgICAgICAgICdjbGljayc6IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICAgIG5vZGUuX29uQXBwZW5kKCcnLCAnJywgJ3N0cmluZycpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgXVxcblxcdCAgICAgIH1cXG5cXHQgICAgXTtcXG5cXG5cXHQgICAgdmFyIG1lbnUgPSBuZXcgQ29udGV4dE1lbnUoaXRlbXMsIHtjbG9zZTogb25DbG9zZX0pO1xcblxcdCAgICBtZW51LnNob3coYW5jaG9yKTtcXG5cXHQgIH07XFxuXFxuXFx0ICAvKipcXG5cXHQgICAqIEhhbmRsZSBhbiBldmVudC4gVGhlIGV2ZW50IGlzIGNhdGNoZWQgY2VudHJhbGx5IGJ5IHRoZSBlZGl0b3JcXG5cXHQgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XFxuXFx0ICAgKi9cXG5cXHQgIEFwcGVuZE5vZGUucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHQgICAgdmFyIHR5cGUgPSBldmVudC50eXBlO1xcblxcdCAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XFxuXFx0ICAgIHZhciBkb20gPSB0aGlzLmRvbTtcXG5cXG5cXHQgICAgLy8gaGlnaGxpZ2h0IHRoZSBhcHBlbmQgbm9kZXMgcGFyZW50XFxuXFx0ICAgIHZhciBtZW51ID0gZG9tLm1lbnU7XFxuXFx0ICAgIGlmICh0YXJnZXQgPT0gbWVudSkge1xcblxcdCAgICAgIGlmICh0eXBlID09ICdtb3VzZW92ZXInKSB7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci5oaWdobGlnaHRlci5oaWdobGlnaHQodGhpcy5wYXJlbnQpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBlbHNlIGlmICh0eXBlID09ICdtb3VzZW91dCcpIHtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLmhpZ2hsaWdodGVyLnVuaGlnaGxpZ2h0KCk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIGNvbnRleHQgbWVudSBldmVudHNcXG5cXHQgICAgaWYgKHR5cGUgPT0gJ2NsaWNrJyAmJiB0YXJnZXQgPT0gZG9tLm1lbnUpIHtcXG5cXHQgICAgICB2YXIgaGlnaGxpZ2h0ZXIgPSB0aGlzLmVkaXRvci5oaWdobGlnaHRlcjtcXG5cXHQgICAgICBoaWdobGlnaHRlci5oaWdobGlnaHQodGhpcy5wYXJlbnQpO1xcblxcdCAgICAgIGhpZ2hsaWdodGVyLmxvY2soKTtcXG5cXHQgICAgICB1dGlsLmFkZENsYXNzTmFtZShkb20ubWVudSwgJ3NlbGVjdGVkJyk7XFxuXFx0ICAgICAgdGhpcy5zaG93Q29udGV4dE1lbnUoZG9tLm1lbnUsIGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHV0aWwucmVtb3ZlQ2xhc3NOYW1lKGRvbS5tZW51LCAnc2VsZWN0ZWQnKTtcXG5cXHQgICAgICAgIGhpZ2hsaWdodGVyLnVubG9jaygpO1xcblxcdCAgICAgICAgaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoKTtcXG5cXHQgICAgICB9KTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAodHlwZSA9PSAna2V5ZG93bicpIHtcXG5cXHQgICAgICB0aGlzLm9uS2V5RG93bihldmVudCk7XFxuXFx0ICAgIH1cXG5cXHQgIH07XFxuXFxuXFx0ICByZXR1cm4gQXBwZW5kTm9kZTtcXG5cXHR9XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBhcHBlbmROb2RlRmFjdG9yeTtcXG5cXG5cXG4vKioqLyB9LFxcbi8qIDEyICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0LyogSmlzb24gZ2VuZXJhdGVkIHBhcnNlciAqL1xcblxcdHZhciBqc29ubGludCA9IChmdW5jdGlvbigpe1xcblxcdHZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LFxcblxcdHl5OiB7fSxcXG5cXHRzeW1ib2xzXzoge1xcXCJlcnJvclxcXCI6MixcXFwiSlNPTlN0cmluZ1xcXCI6MyxcXFwiU1RSSU5HXFxcIjo0LFxcXCJKU09OTnVtYmVyXFxcIjo1LFxcXCJOVU1CRVJcXFwiOjYsXFxcIkpTT05OdWxsTGl0ZXJhbFxcXCI6NyxcXFwiTlVMTFxcXCI6OCxcXFwiSlNPTkJvb2xlYW5MaXRlcmFsXFxcIjo5LFxcXCJUUlVFXFxcIjoxMCxcXFwiRkFMU0VcXFwiOjExLFxcXCJKU09OVGV4dFxcXCI6MTIsXFxcIkpTT05WYWx1ZVxcXCI6MTMsXFxcIkVPRlxcXCI6MTQsXFxcIkpTT05PYmplY3RcXFwiOjE1LFxcXCJKU09OQXJyYXlcXFwiOjE2LFxcXCJ7XFxcIjoxNyxcXFwifVxcXCI6MTgsXFxcIkpTT05NZW1iZXJMaXN0XFxcIjoxOSxcXFwiSlNPTk1lbWJlclxcXCI6MjAsXFxcIjpcXFwiOjIxLFxcXCIsXFxcIjoyMixcXFwiW1xcXCI6MjMsXFxcIl1cXFwiOjI0LFxcXCJKU09ORWxlbWVudExpc3RcXFwiOjI1LFxcXCIkYWNjZXB0XFxcIjowLFxcXCIkZW5kXFxcIjoxfSxcXG5cXHR0ZXJtaW5hbHNfOiB7MjpcXFwiZXJyb3JcXFwiLDQ6XFxcIlNUUklOR1xcXCIsNjpcXFwiTlVNQkVSXFxcIiw4OlxcXCJOVUxMXFxcIiwxMDpcXFwiVFJVRVxcXCIsMTE6XFxcIkZBTFNFXFxcIiwxNDpcXFwiRU9GXFxcIiwxNzpcXFwie1xcXCIsMTg6XFxcIn1cXFwiLDIxOlxcXCI6XFxcIiwyMjpcXFwiLFxcXCIsMjM6XFxcIltcXFwiLDI0OlxcXCJdXFxcIn0sXFxuXFx0cHJvZHVjdGlvbnNfOiBbMCxbMywxXSxbNSwxXSxbNywxXSxbOSwxXSxbOSwxXSxbMTIsMl0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxMywxXSxbMTMsMV0sWzE1LDJdLFsxNSwzXSxbMjAsM10sWzE5LDFdLFsxOSwzXSxbMTYsMl0sWzE2LDNdLFsyNSwxXSxbMjUsM11dLFxcblxcdHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQseXlsZW5nLHl5bGluZW5vLHl5LHl5c3RhdGUsJCQsXyQpIHtcXG5cXG5cXHR2YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xcblxcdHN3aXRjaCAoeXlzdGF0ZSkge1xcblxcdGNhc2UgMTogLy8gcmVwbGFjZSBlc2NhcGVkIGNoYXJhY3RlcnMgd2l0aCBhY3R1YWwgY2hhcmFjdGVyXFxuXFx0ICAgICAgICAgIHRoaXMuJCA9IHl5dGV4dC5yZXBsYWNlKC9cXFxcXFxcXChcXFxcXFxcXHxcXFwiKS9nLCBcXFwiJFxcXCIrXFxcIjFcXFwiKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXG4vZywnXFxcXG4nKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXHIvZywnXFxcXHInKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXHQvZywnXFxcXHQnKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXHYvZywnXFxcXHYnKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXGYvZywnXFxcXGYnKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXGIvZywnXFxcXGInKTtcXG5cXHQgICAgICAgIFxcblxcdGJyZWFrO1xcblxcdGNhc2UgMjp0aGlzLiQgPSBOdW1iZXIoeXl0ZXh0KTtcXG5cXHRicmVhaztcXG5cXHRjYXNlIDM6dGhpcy4kID0gbnVsbDtcXG5cXHRicmVhaztcXG5cXHRjYXNlIDQ6dGhpcy4kID0gdHJ1ZTtcXG5cXHRicmVhaztcXG5cXHRjYXNlIDU6dGhpcy4kID0gZmFsc2U7XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSA2OnJldHVybiB0aGlzLiQgPSAkJFskMC0xXTtcXG5cXHRicmVhaztcXG5cXHRjYXNlIDEzOnRoaXMuJCA9IHt9O1xcblxcdGJyZWFrO1xcblxcdGNhc2UgMTQ6dGhpcy4kID0gJCRbJDAtMV07XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAxNTp0aGlzLiQgPSBbJCRbJDAtMl0sICQkWyQwXV07XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAxNjp0aGlzLiQgPSB7fTsgdGhpcy4kWyQkWyQwXVswXV0gPSAkJFskMF1bMV07XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAxNzp0aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl1bJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcXG5cXHRicmVhaztcXG5cXHRjYXNlIDE4OnRoaXMuJCA9IFtdO1xcblxcdGJyZWFrO1xcblxcdGNhc2UgMTk6dGhpcy4kID0gJCRbJDAtMV07XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAyMDp0aGlzLiQgPSBbJCRbJDBdXTtcXG5cXHRicmVhaztcXG5cXHRjYXNlIDIxOnRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwXSk7XFxuXFx0YnJlYWs7XFxuXFx0fVxcblxcdH0sXFxuXFx0dGFibGU6IFt7Mzo1LDQ6WzEsMTJdLDU6Niw2OlsxLDEzXSw3OjMsODpbMSw5XSw5OjQsMTA6WzEsMTBdLDExOlsxLDExXSwxMjoxLDEzOjIsMTU6NywxNjo4LDE3OlsxLDE0XSwyMzpbMSwxNV19LHsxOlszXX0sezE0OlsxLDE2XX0sezE0OlsyLDddLDE4OlsyLDddLDIyOlsyLDddLDI0OlsyLDddfSx7MTQ6WzIsOF0sMTg6WzIsOF0sMjI6WzIsOF0sMjQ6WzIsOF19LHsxNDpbMiw5XSwxODpbMiw5XSwyMjpbMiw5XSwyNDpbMiw5XX0sezE0OlsyLDEwXSwxODpbMiwxMF0sMjI6WzIsMTBdLDI0OlsyLDEwXX0sezE0OlsyLDExXSwxODpbMiwxMV0sMjI6WzIsMTFdLDI0OlsyLDExXX0sezE0OlsyLDEyXSwxODpbMiwxMl0sMjI6WzIsMTJdLDI0OlsyLDEyXX0sezE0OlsyLDNdLDE4OlsyLDNdLDIyOlsyLDNdLDI0OlsyLDNdfSx7MTQ6WzIsNF0sMTg6WzIsNF0sMjI6WzIsNF0sMjQ6WzIsNF19LHsxNDpbMiw1XSwxODpbMiw1XSwyMjpbMiw1XSwyNDpbMiw1XX0sezE0OlsyLDFdLDE4OlsyLDFdLDIxOlsyLDFdLDIyOlsyLDFdLDI0OlsyLDFdfSx7MTQ6WzIsMl0sMTg6WzIsMl0sMjI6WzIsMl0sMjQ6WzIsMl19LHszOjIwLDQ6WzEsMTJdLDE4OlsxLDE3XSwxOToxOCwyMDoxOX0sezM6NSw0OlsxLDEyXSw1OjYsNjpbMSwxM10sNzozLDg6WzEsOV0sOTo0LDEwOlsxLDEwXSwxMTpbMSwxMV0sMTM6MjMsMTU6NywxNjo4LDE3OlsxLDE0XSwyMzpbMSwxNV0sMjQ6WzEsMjFdLDI1OjIyfSx7MTpbMiw2XX0sezE0OlsyLDEzXSwxODpbMiwxM10sMjI6WzIsMTNdLDI0OlsyLDEzXX0sezE4OlsxLDI0XSwyMjpbMSwyNV19LHsxODpbMiwxNl0sMjI6WzIsMTZdfSx7MjE6WzEsMjZdfSx7MTQ6WzIsMThdLDE4OlsyLDE4XSwyMjpbMiwxOF0sMjQ6WzIsMThdfSx7MjI6WzEsMjhdLDI0OlsxLDI3XX0sezIyOlsyLDIwXSwyNDpbMiwyMF19LHsxNDpbMiwxNF0sMTg6WzIsMTRdLDIyOlsyLDE0XSwyNDpbMiwxNF19LHszOjIwLDQ6WzEsMTJdLDIwOjI5fSx7Mzo1LDQ6WzEsMTJdLDU6Niw2OlsxLDEzXSw3OjMsODpbMSw5XSw5OjQsMTA6WzEsMTBdLDExOlsxLDExXSwxMzozMCwxNTo3LDE2OjgsMTc6WzEsMTRdLDIzOlsxLDE1XX0sezE0OlsyLDE5XSwxODpbMiwxOV0sMjI6WzIsMTldLDI0OlsyLDE5XX0sezM6NSw0OlsxLDEyXSw1OjYsNjpbMSwxM10sNzozLDg6WzEsOV0sOTo0LDEwOlsxLDEwXSwxMTpbMSwxMV0sMTM6MzEsMTU6NywxNjo4LDE3OlsxLDE0XSwyMzpbMSwxNV19LHsxODpbMiwxN10sMjI6WzIsMTddfSx7MTg6WzIsMTVdLDIyOlsyLDE1XX0sezIyOlsyLDIxXSwyNDpbMiwyMV19XSxcXG5cXHRkZWZhdWx0QWN0aW9uczogezE2OlsyLDZdfSxcXG5cXHRwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xcblxcdCAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcXG5cXHR9LFxcblxcdHBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xcblxcdCAgICB2YXIgc2VsZiA9IHRoaXMsXFxuXFx0ICAgICAgICBzdGFjayA9IFswXSxcXG5cXHQgICAgICAgIHZzdGFjayA9IFtudWxsXSwgLy8gc2VtYW50aWMgdmFsdWUgc3RhY2tcXG5cXHQgICAgICAgIGxzdGFjayA9IFtdLCAvLyBsb2NhdGlvbiBzdGFja1xcblxcdCAgICAgICAgdGFibGUgPSB0aGlzLnRhYmxlLFxcblxcdCAgICAgICAgeXl0ZXh0ID0gJycsXFxuXFx0ICAgICAgICB5eWxpbmVubyA9IDAsXFxuXFx0ICAgICAgICB5eWxlbmcgPSAwLFxcblxcdCAgICAgICAgcmVjb3ZlcmluZyA9IDAsXFxuXFx0ICAgICAgICBURVJST1IgPSAyLFxcblxcdCAgICAgICAgRU9GID0gMTtcXG5cXG5cXHQgICAgLy90aGlzLnJlZHVjdGlvbkNvdW50ID0gdGhpcy5zaGlmdENvdW50ID0gMDtcXG5cXG5cXHQgICAgdGhpcy5sZXhlci5zZXRJbnB1dChpbnB1dCk7XFxuXFx0ICAgIHRoaXMubGV4ZXIueXkgPSB0aGlzLnl5O1xcblxcdCAgICB0aGlzLnl5LmxleGVyID0gdGhpcy5sZXhlcjtcXG5cXHQgICAgaWYgKHR5cGVvZiB0aGlzLmxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJylcXG5cXHQgICAgICAgIHRoaXMubGV4ZXIueXlsbG9jID0ge307XFxuXFx0ICAgIHZhciB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xcblxcdCAgICBsc3RhY2sucHVzaCh5eWxvYyk7XFxuXFxuXFx0ICAgIGlmICh0eXBlb2YgdGhpcy55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKVxcblxcdCAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy55eS5wYXJzZUVycm9yO1xcblxcblxcdCAgICBmdW5jdGlvbiBwb3BTdGFjayAobikge1xcblxcdCAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMipuO1xcblxcdCAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xcblxcdCAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGZ1bmN0aW9uIGxleCgpIHtcXG5cXHQgICAgICAgIHZhciB0b2tlbjtcXG5cXHQgICAgICAgIHRva2VuID0gc2VsZi5sZXhlci5sZXgoKSB8fCAxOyAvLyAkZW5kID0gMVxcblxcdCAgICAgICAgLy8gaWYgdG9rZW4gaXNuJ3QgaXRzIG51bWVyaWMgdmFsdWUsIGNvbnZlcnRcXG5cXHQgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XFxuXFx0ICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiB0b2tlbjtcXG5cXHQgICAgfVxcblxcblxcdCAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWw9e30scCxsZW4sbmV3U3RhdGUsIGV4cGVjdGVkO1xcblxcdCAgICB3aGlsZSAodHJ1ZSkge1xcblxcdCAgICAgICAgLy8gcmV0cmVpdmUgc3RhdGUgbnVtYmVyIGZyb20gdG9wIG9mIHN0YWNrXFxuXFx0ICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcXG5cXG5cXHQgICAgICAgIC8vIHVzZSBkZWZhdWx0IGFjdGlvbnMgaWYgYXZhaWxhYmxlXFxuXFx0ICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcXG5cXHQgICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHN5bWJvbCA9PSBudWxsKVxcblxcdCAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcXG5cXHQgICAgICAgICAgICAvLyByZWFkIGFjdGlvbiBmb3IgY3VycmVudCBzdGF0ZSBhbmQgZmlyc3QgaW5wdXRcXG5cXHQgICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAvLyBoYW5kbGUgcGFyc2UgZXJyb3JcXG5cXHQgICAgICAgIF9oYW5kbGVfZXJyb3I6XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xcblxcblxcdCAgICAgICAgICAgIGlmICghcmVjb3ZlcmluZykge1xcblxcdCAgICAgICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JcXG5cXHQgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcXG5cXHQgICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gMikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaChcXFwiJ1xcXCIrdGhpcy50ZXJtaW5hbHNfW3BdK1xcXCInXFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xcblxcdCAgICAgICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zaG93UG9zaXRpb24pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcrKHl5bGluZW5vKzEpK1xcXCI6XFxcXG5cXFwiK3RoaXMubGV4ZXIuc2hvd1Bvc2l0aW9uKCkrXFxcIlxcXFxuRXhwZWN0aW5nIFxcXCIrZXhwZWN0ZWQuam9pbignLCAnKSArIFxcXCIsIGdvdCAnXFxcIiArIHRoaXMudGVybWluYWxzX1tzeW1ib2xdKyBcXFwiJ1xcXCI7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnKyh5eWxpbmVubysxKStcXFwiOiBVbmV4cGVjdGVkIFxcXCIgK1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ltYm9sID09IDEgLypFT0YqLyA/IFxcXCJlbmQgb2YgaW5wdXRcXFwiIDpcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxcXCInXFxcIisodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKStcXFwiJ1xcXCIpKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLFxcblxcdCAgICAgICAgICAgICAgICAgICAge3RleHQ6IHRoaXMubGV4ZXIubWF0Y2gsIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsIGxpbmU6IHRoaXMubGV4ZXIueXlsaW5lbm8sIGxvYzogeXlsb2MsIGV4cGVjdGVkOiBleHBlY3RlZH0pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAvLyBqdXN0IHJlY292ZXJlZCBmcm9tIGFub3RoZXIgZXJyb3JcXG5cXHQgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA9PSAzKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT0gRU9GKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZC4nKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIGN1cnJlbnQgbG9va2FoZWFkIGFuZCBncmFiIGFub3RoZXJcXG5cXHQgICAgICAgICAgICAgICAgeXlsZW5nID0gdGhpcy5sZXhlci55eWxlbmc7XFxuXFx0ICAgICAgICAgICAgICAgIHl5dGV4dCA9IHRoaXMubGV4ZXIueXl0ZXh0O1xcblxcdCAgICAgICAgICAgICAgICB5eWxpbmVubyA9IHRoaXMubGV4ZXIueXlsaW5lbm87XFxuXFx0ICAgICAgICAgICAgICAgIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XFxuXFx0ICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAvLyB0cnkgdG8gcmVjb3ZlciBmcm9tIGVycm9yXFxuXFx0ICAgICAgICAgICAgd2hpbGUgKDEpIHtcXG5cXHQgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yIHJlY292ZXJ5IHJ1bGUgaW4gdGhpcyBzdGF0ZVxcblxcdCAgICAgICAgICAgICAgICBpZiAoKFRFUlJPUi50b1N0cmluZygpKSBpbiB0YWJsZVtzdGF0ZV0pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyU3RyIHx8ICdQYXJzaW5nIGhhbHRlZC4nKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBwb3BTdGFjaygxKTtcXG5cXHQgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGgtMV07XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gc3ltYm9sOyAvLyBzYXZlIHRoZSBsb29rYWhlYWQgdG9rZW5cXG5cXHQgICAgICAgICAgICBzeW1ib2wgPSBURVJST1I7ICAgICAgICAgLy8gaW5zZXJ0IGdlbmVyaWMgZXJyb3Igc3ltYm9sIGFzIG5ldyBsb29rYWhlYWRcXG5cXHQgICAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXTtcXG5cXHQgICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW1RFUlJPUl07XFxuXFx0ICAgICAgICAgICAgcmVjb3ZlcmluZyA9IDM7IC8vIGFsbG93IDMgcmVhbCBzeW1ib2xzIHRvIGJlIHNoaWZ0ZWQgYmVmb3JlIHJlcG9ydGluZyBhIG5ldyBlcnJvclxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCB1bmxlc3MgcmVzb2x2ZSBkZWZhdWx0cyBhcmUgb2ZmXFxuXFx0ICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnK3N0YXRlKycsIHRva2VuOiAnK3N5bWJvbCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xcblxcblxcdCAgICAgICAgICAgIGNhc2UgMTogLy8gc2hpZnRcXG5cXHQgICAgICAgICAgICAgICAgLy90aGlzLnNoaWZ0Q291bnQrKztcXG5cXG5cXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xcblxcdCAgICAgICAgICAgICAgICB2c3RhY2sucHVzaCh0aGlzLmxleGVyLnl5dGV4dCk7XFxuXFx0ICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHRoaXMubGV4ZXIueXlsbG9jKTtcXG5cXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pOyAvLyBwdXNoIHN0YXRlXFxuXFx0ICAgICAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHsgLy8gbm9ybWFsIGV4ZWN1dGlvbi9ubyBlcnJvclxcblxcdCAgICAgICAgICAgICAgICAgICAgeXlsZW5nID0gdGhpcy5sZXhlci55eWxlbmc7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB5eXRleHQgPSB0aGlzLmxleGVyLnl5dGV4dDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcXG5cXHQgICAgICAgICAgICAgICAgICAgIHl5bG9jID0gdGhpcy5sZXhlci55eWxsb2M7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBlcnJvciBqdXN0IG9jY3VycmVkLCByZXN1bWUgb2xkIGxvb2thaGVhZCBmLyBiZWZvcmUgZXJyb3JcXG5cXHQgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgICAgICAgIGNhc2UgMjogLy8gcmVkdWNlXFxuXFx0ICAgICAgICAgICAgICAgIC8vdGhpcy5yZWR1Y3Rpb25Db3VudCsrO1xcblxcblxcdCAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xcblxcblxcdCAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHNlbWFudGljIGFjdGlvblxcblxcdCAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGgtbGVuXTsgLy8gZGVmYXVsdCB0byAkJCA9ICQxXFxuXFx0ICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgbG9jYXRpb24sIHVzZXMgZmlyc3QgdG9rZW4gZm9yIGZpcnN0cywgbGFzdCBmb3IgbGFzdHNcXG5cXHQgICAgICAgICAgICAgICAgeXl2YWwuXyQgPSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0obGVufHwxKV0uZmlyc3RfbGluZSxcXG5cXHQgICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGgtMV0ubGFzdF9saW5lLFxcblxcdCAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aC0obGVufHwxKV0uZmlyc3RfY29sdW1uLFxcblxcdCAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoLTFdLmxhc3RfY29sdW1uXFxuXFx0ICAgICAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB0aGlzLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrKTtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAgICAgLy8gcG9wIG9mZiBzdGFja1xcblxcdCAgICAgICAgICAgICAgICBpZiAobGVuKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsLTEqbGVuKjIpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xKmxlbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEqbGVuKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pOyAgICAvLyBwdXNoIG5vbnRlcm1pbmFsIChyZWR1Y2UpXFxuXFx0ICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xcblxcdCAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XFxuXFx0ICAgICAgICAgICAgICAgIC8vIGdvdG8gbmV3IHN0YXRlID0gdGFibGVbU1RBVEVdW05PTlRFUk1JTkFMXVxcblxcdCAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aC0yXV1bc3RhY2tbc3RhY2subGVuZ3RoLTFdXTtcXG5cXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgICAgICAgIGNhc2UgMzogLy8gYWNjZXB0XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldHVybiB0cnVlO1xcblxcdH19O1xcblxcdC8qIEppc29uIGdlbmVyYXRlZCBsZXhlciAqL1xcblxcdHZhciBsZXhlciA9IChmdW5jdGlvbigpe1xcblxcdHZhciBsZXhlciA9ICh7RU9GOjEsXFxuXFx0cGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMueXkucGFyc2VFcnJvcikge1xcblxcdCAgICAgICAgICAgIHRoaXMueXkucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHRzZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQpIHtcXG5cXHQgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XFxuXFx0ICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fbGVzcyA9IHRoaXMuZG9uZSA9IGZhbHNlO1xcblxcdCAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcXG5cXHQgICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xcblxcdCAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xcblxcdCAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZToxLGZpcnN0X2NvbHVtbjowLGxhc3RfbGluZToxLGxhc3RfY29sdW1uOjB9O1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXM7XFxuXFx0ICAgIH0sXFxuXFx0aW5wdXQ6ZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XFxuXFx0ICAgICAgICB0aGlzLnl5dGV4dCs9Y2g7XFxuXFx0ICAgICAgICB0aGlzLnl5bGVuZysrO1xcblxcdCAgICAgICAgdGhpcy5tYXRjaCs9Y2g7XFxuXFx0ICAgICAgICB0aGlzLm1hdGNoZWQrPWNoO1xcblxcdCAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goL1xcXFxuLyk7XFxuXFx0ICAgICAgICBpZiAobGluZXMpIHRoaXMueXlsaW5lbm8rKztcXG5cXHQgICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XFxuXFx0ICAgICAgICByZXR1cm4gY2g7XFxuXFx0ICAgIH0sXFxuXFx0dW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XFxuXFx0ICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcztcXG5cXHQgICAgfSxcXG5cXHRtb3JlOmZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXM7XFxuXFx0ICAgIH0sXFxuXFx0bGVzczpmdW5jdGlvbiAobikge1xcblxcdCAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLm1hdGNoLnNsaWNlKG4pICsgdGhpcy5faW5wdXQ7XFxuXFx0ICAgIH0sXFxuXFx0cGFzdElucHV0OmZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xcblxcdCAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXFxcbi9nLCBcXFwiXFxcIik7XFxuXFx0ICAgIH0sXFxuXFx0dXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XFxuXFx0ICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xcblxcdCAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkrKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJzonJykpLnJlcGxhY2UoL1xcXFxuL2csIFxcXCJcXFwiKTtcXG5cXHQgICAgfSxcXG5cXHRzaG93UG9zaXRpb246ZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XFxuXFx0ICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcXFwiLVxcXCIpO1xcblxcdCAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXFxcIlxcXFxuXFxcIiArIGMrXFxcIl5cXFwiO1xcblxcdCAgICB9LFxcblxcdG5leHQ6ZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICghdGhpcy5faW5wdXQpIHRoaXMuZG9uZSA9IHRydWU7XFxuXFxuXFx0ICAgICAgICB2YXIgdG9rZW4sXFxuXFx0ICAgICAgICAgICAgbWF0Y2gsXFxuXFx0ICAgICAgICAgICAgdGVtcE1hdGNoLFxcblxcdCAgICAgICAgICAgIGluZGV4LFxcblxcdCAgICAgICAgICAgIGNvbCxcXG5cXHQgICAgICAgICAgICBsaW5lcztcXG5cXHQgICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XFxuXFx0ICAgICAgICBmb3IgKHZhciBpPTA7aSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xcblxcdCAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xcblxcdCAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcXG5cXHQgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSBicmVhaztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAobWF0Y2gpIHtcXG5cXHQgICAgICAgICAgICBsaW5lcyA9IG1hdGNoWzBdLm1hdGNoKC9cXFxcbi4qL2cpO1xcblxcdCAgICAgICAgICAgIGlmIChsaW5lcykgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubysxLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gbGluZXNbbGluZXMubGVuZ3RoLTFdLmxlbmd0aC0xIDogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGh9XFxuXFx0ICAgICAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XFxuXFx0ICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcXG5cXHQgICAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcXG5cXHQgICAgICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xcblxcdCAgICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcXG5cXHQgICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIHJ1bGVzW2luZGV4XSx0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoLTFdKTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB0aGlzLmRvbmUgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICBpZiAodG9rZW4pIHJldHVybiB0b2tlbjtcXG5cXHQgICAgICAgICAgICBlbHNlIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXFxcIlxcXCIpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcrKHRoaXMueXlsaW5lbm8rMSkrJy4gVW5yZWNvZ25pemVkIHRleHQuXFxcXG4nK3RoaXMuc2hvd1Bvc2l0aW9uKCksIFxcblxcdCAgICAgICAgICAgICAgICAgICAge3RleHQ6IFxcXCJcXFwiLCB0b2tlbjogbnVsbCwgbGluZTogdGhpcy55eWxpbmVub30pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9LFxcblxcdGxleDpmdW5jdGlvbiBsZXgoKSB7XFxuXFx0ICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xcblxcdCAgICAgICAgICAgIHJldHVybiByO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHRiZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcXG5cXHQgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xcblxcdCAgICB9LFxcblxcdHBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XFxuXFx0ICAgIH0sXFxuXFx0X2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoLTFdXS5ydWxlcztcXG5cXHQgICAgfSxcXG5cXHR0b3BTdGF0ZTpmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aC0yXTtcXG5cXHQgICAgfSxcXG5cXHRwdXNoU3RhdGU6ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XFxuXFx0ICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XFxuXFx0ICAgIH19KTtcXG5cXHRsZXhlci5vcHRpb25zID0ge307XFxuXFx0bGV4ZXIucGVyZm9ybUFjdGlvbiA9IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xcblxcblxcdHZhciBZWVNUQVRFPVlZX1NUQVJUXFxuXFx0c3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcXG5cXHRjYXNlIDA6Lyogc2tpcCB3aGl0ZXNwYWNlICovXFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAxOnJldHVybiA2XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAyOnl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigxLHl5Xy55eWxlbmctMik7IHJldHVybiA0XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAzOnJldHVybiAxN1xcblxcdGJyZWFrO1xcblxcdGNhc2UgNDpyZXR1cm4gMThcXG5cXHRicmVhaztcXG5cXHRjYXNlIDU6cmV0dXJuIDIzXFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSA2OnJldHVybiAyNFxcblxcdGJyZWFrO1xcblxcdGNhc2UgNzpyZXR1cm4gMjJcXG5cXHRicmVhaztcXG5cXHRjYXNlIDg6cmV0dXJuIDIxXFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSA5OnJldHVybiAxMFxcblxcdGJyZWFrO1xcblxcdGNhc2UgMTA6cmV0dXJuIDExXFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAxMTpyZXR1cm4gOFxcblxcdGJyZWFrO1xcblxcdGNhc2UgMTI6cmV0dXJuIDE0XFxuXFx0YnJlYWs7XFxuXFx0Y2FzZSAxMzpyZXR1cm4gJ0lOVkFMSUQnXFxuXFx0YnJlYWs7XFxuXFx0fVxcblxcdH07XFxuXFx0bGV4ZXIucnVsZXMgPSBbL14oPzpcXFxccyspLywvXig/OigtPyhbMC05XXxbMS05XVswLTldKykpKFxcXFwuWzAtOV0rKT8oW2VFXVstK10/WzAtOV0rKT9cXFxcYikvLC9eKD86XFxcIig/OlxcXFxcXFxcW1xcXFxcXFxcXFxcImJmbnJ0L118XFxcXFxcXFx1W2EtZkEtRjAtOV17NH18W15cXFxcXFxcXFxcXFwwLVxcXFx4MDlcXFxceDBhLVxcXFx4MWZcXFwiXSkqXFxcIikvLC9eKD86XFxcXHspLywvXig/OlxcXFx9KS8sL14oPzpcXFxcWykvLC9eKD86XFxcXF0pLywvXig/OiwpLywvXig/OjopLywvXig/OnRydWVcXFxcYikvLC9eKD86ZmFsc2VcXFxcYikvLC9eKD86bnVsbFxcXFxiKS8sL14oPzokKS8sL14oPzouKS9dO1xcblxcdGxleGVyLmNvbmRpdGlvbnMgPSB7XFxcIklOSVRJQUxcXFwiOntcXFwicnVsZXNcXFwiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzXSxcXFwiaW5jbHVzaXZlXFxcIjp0cnVlfX07XFxuXFxuXFxuXFx0O1xcblxcdHJldHVybiBsZXhlcjt9KSgpXFxuXFx0cGFyc2VyLmxleGVyID0gbGV4ZXI7XFxuXFx0cmV0dXJuIHBhcnNlcjtcXG5cXHR9KSgpO1xcblxcdGlmICh0cnVlKSB7XFxuXFx0ICBleHBvcnRzLnBhcnNlciA9IGpzb25saW50O1xcblxcdCAgZXhwb3J0cy5wYXJzZSA9IGpzb25saW50LnBhcnNlLmJpbmQoanNvbmxpbnQpO1xcblxcdH1cXG5cXG4vKioqLyB9LFxcbi8qIDEzICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0LyogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxcblxcdCAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcXG5cXHQgKlxcblxcdCAqIENvcHlyaWdodCAoYykgMjAxMCwgQWpheC5vcmcgQi5WLlxcblxcdCAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFx0ICogXFxuXFx0ICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxuXFx0ICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxuXFx0ICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcXG5cXHQgKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXFx0ICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcXG5cXHQgKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXFxuXFx0ICogICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXHQgKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEFqYXgub3JnIEIuVi4gbm9yIHRoZVxcblxcdCAqICAgICAgIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXFxuXFx0ICogICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFx0ICogXFxuXFx0ICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcXFwiQVMgSVNcXFwiIEFORFxcblxcdCAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXFxuXFx0ICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxcblxcdCAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFKQVguT1JHIEIuVi4gQkUgTElBQkxFIEZPUiBBTllcXG5cXHQgKiBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xcblxcdCAqIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcXG5cXHQgKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcXG5cXHQgKiBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxcblxcdCAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXFxuXFx0ICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuXFx0ICpcXG5cXHQgKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKiAqL1xcblxcblxcdGFjZS5kZWZpbmUoJ2FjZS90aGVtZS9qc29uZWRpdG9yJywgWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJywgJ2FjZS9saWIvZG9tJ10sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXG5cXHRleHBvcnRzLmlzRGFyayA9IGZhbHNlO1xcblxcdGV4cG9ydHMuY3NzQ2xhc3MgPSBcXFwiYWNlLWpzb25lZGl0b3JcXFwiO1xcblxcdGV4cG9ydHMuY3NzVGV4dCA9IFxcXCIuYWNlLWpzb25lZGl0b3IgLmFjZV9ndXR0ZXIge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiAjZWJlYmViO1xcXFxcXG5cXHRjb2xvcjogIzMzM1xcXFxcXG5cXHR9XFxcXFxcblxcdFxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IuYWNlX2VkaXRvciB7XFxcXFxcblxcdGZvbnQtZmFtaWx5OiBkcm9pZCBzYW5zIG1vbm8sIGNvbnNvbGFzLCBtb25vc3BhY2UsIGNvdXJpZXIgbmV3LCBjb3VyaWVyLCBzYW5zLXNlcmlmO1xcXFxcXG5cXHRsaW5lLWhlaWdodDogMS4zO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX3ByaW50LW1hcmdpbiB7XFxcXFxcblxcdHdpZHRoOiAxcHg7XFxcXFxcblxcdGJhY2tncm91bmQ6ICNlOGU4ZThcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9zY3JvbGxlciB7XFxcXFxcblxcdGJhY2tncm91bmQtY29sb3I6ICNGRkZGRkZcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV90ZXh0LWxheWVyIHtcXFxcXFxuXFx0Y29sb3I6IGdyYXlcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV92YXJpYWJsZSB7XFxcXFxcblxcdGNvbG9yOiAjMWExYTFhXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2VfY3Vyc29yIHtcXFxcXFxuXFx0Ym9yZGVyLWxlZnQ6IDJweCBzb2xpZCAjMDAwMDAwXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2Vfb3ZlcndyaXRlLWN1cnNvcnMgLmFjZV9jdXJzb3Ige1xcXFxcXG5cXHRib3JkZXItbGVmdDogMHB4O1xcXFxcXG5cXHRib3JkZXItYm90dG9tOiAxcHggc29saWQgIzAwMDAwMFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX21hcmtlci1sYXllciAuYWNlX3NlbGVjdGlvbiB7XFxcXFxcblxcdGJhY2tncm91bmQ6ICNENURERjZcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IuYWNlX211bHRpc2VsZWN0IC5hY2Vfc2VsZWN0aW9uLmFjZV9zdGFydCB7XFxcXFxcblxcdGJveC1zaGFkb3c6IDAgMCAzcHggMHB4ICNGRkZGRkY7XFxcXFxcblxcdGJvcmRlci1yYWRpdXM6IDJweFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX21hcmtlci1sYXllciAuYWNlX3N0ZXAge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiByZ2IoMjU1LCAyNTUsIDApXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2VfbWFya2VyLWxheWVyIC5hY2VfYnJhY2tldCB7XFxcXFxcblxcdG1hcmdpbjogLTFweCAwIDAgLTFweDtcXFxcXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI0JGQkZCRlxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXFxcXFxuXFx0YmFja2dyb3VuZDogI0ZGRkJEMVxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX2d1dHRlci1hY3RpdmUtbGluZSB7XFxcXFxcblxcdGJhY2tncm91bmQtY29sb3IgOiAjZGNkY2RjXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0ZWQtd29yZCB7XFxcXFxcblxcdGJvcmRlcjogMXB4IHNvbGlkICNENURERjZcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9pbnZpc2libGUge1xcXFxcXG5cXHRjb2xvcjogI0JGQkZCRlxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX2tleXdvcmQsXFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX21ldGEsXFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX3N1cHBvcnQuYWNlX2NvbnN0YW50LmFjZV9wcm9wZXJ0eS12YWx1ZSB7XFxcXFxcblxcdGNvbG9yOiAjQUY5NTZGXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2Vfa2V5d29yZC5hY2Vfb3BlcmF0b3Ige1xcXFxcXG5cXHRjb2xvcjogIzQ4NDg0OFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX2tleXdvcmQuYWNlX290aGVyLmFjZV91bml0IHtcXFxcXFxuXFx0Y29sb3I6ICM5NkRDNUZcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9jb25zdGFudC5hY2VfbGFuZ3VhZ2Uge1xcXFxcXG5cXHRjb2xvcjogZGFya29yYW5nZVxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX2NvbnN0YW50LmFjZV9udW1lcmljIHtcXFxcXFxuXFx0Y29sb3I6IHJlZFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX2NvbnN0YW50LmFjZV9jaGFyYWN0ZXIuYWNlX2VudGl0eSB7XFxcXFxcblxcdGNvbG9yOiAjQkY3OENDXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2VfaW52YWxpZCB7XFxcXFxcblxcdGNvbG9yOiAjRkZGRkZGO1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRkYwMDJBO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX2ZvbGQge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjQUY5NTZGO1xcXFxcXG5cXHRib3JkZXItY29sb3I6ICMwMDAwMDBcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9zdG9yYWdlLFxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9zdXBwb3J0LmFjZV9jbGFzcyxcXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2Vfc3VwcG9ydC5hY2VfZnVuY3Rpb24sXFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX3N1cHBvcnQuYWNlX290aGVyLFxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9zdXBwb3J0LmFjZV90eXBlIHtcXFxcXFxuXFx0Y29sb3I6ICNDNTI3MjdcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9zdHJpbmcge1xcXFxcXG5cXHRjb2xvcjogZ3JlZW5cXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9jb21tZW50IHtcXFxcXFxuXFx0Y29sb3I6ICNCQ0M4QkFcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9lbnRpdHkuYWNlX25hbWUuYWNlX3RhZyxcXFxcXFxuXFx0LmFjZS1qc29uZWRpdG9yIC5hY2VfZW50aXR5LmFjZV9vdGhlci5hY2VfYXR0cmlidXRlLW5hbWUge1xcXFxcXG5cXHRjb2xvcjogIzYwNjA2MFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtanNvbmVkaXRvciAuYWNlX21hcmt1cC5hY2VfdW5kZXJsaW5lIHtcXFxcXFxuXFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmVcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLWpzb25lZGl0b3IgLmFjZV9pbmRlbnQtZ3VpZGUge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiB1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUNDQVlBQUFDWmdiWW5BQUFBRTBsRVFWUUltV1A0Ly8vL2Y0YkxseS8vQndBbVZnZDEvdzExL2dBQUFBQkpSVTVFcmtKZ2dnPT1cXFxcXFxcIikgcmlnaHQgcmVwZWF0LXlcXFxcXFxuXFx0fVxcXCI7XFxuXFxuXFx0dmFyIGRvbSA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZG9tXFxcIik7XFxuXFx0ZG9tLmltcG9ydENzc1N0cmluZyhleHBvcnRzLmNzc1RleHQsIGV4cG9ydHMuY3NzQ2xhc3MpO1xcblxcdH0pO1xcblxcblxcbi8qKiovIH0sXFxuLyogMTQgKi9cXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXFxuXFx0ICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxcblxcdCAqXFxuXFx0ICogQ29weXJpZ2h0IChjKSAyMDEwLCBBamF4Lm9yZyBCLlYuXFxuXFx0ICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG5cXHQgKlxcblxcdCAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxcblxcdCAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcblxcdCAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XFxuXFx0ICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcdCAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XFxuXFx0ICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxcblxcdCAqICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXFxuXFx0ICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiBBamF4Lm9yZyBCLlYuIG5vciB0aGVcXG5cXHQgKiAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xcblxcdCAqICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcdCAqXFxuXFx0ICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcXFwiQVMgSVNcXFwiIEFORFxcblxcdCAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXFxuXFx0ICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxcblxcdCAqIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEFKQVguT1JHIEIuVi4gQkUgTElBQkxFIEZPUiBBTllcXG5cXHQgKiBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xcblxcdCAqIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcXG5cXHQgKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcXG5cXHQgKiBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxcblxcdCAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXFxuXFx0ICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuXFx0ICpcXG5cXHQgKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKiAqL1xcblxcblxcdC8qKlxcblxcdCAqIERlZmluZSBhIG1vZHVsZSBhbG9uZyB3aXRoIGEgcGF5bG9hZFxcblxcdCAqIEBwYXJhbSBtb2R1bGUgYSBuYW1lIGZvciB0aGUgcGF5bG9hZFxcblxcdCAqIEBwYXJhbSBwYXlsb2FkIGEgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIChhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSBwYXJhbXNcXG5cXHQgKi9cXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0dmFyIEFDRV9OQU1FU1BBQ0UgPSBcXFwiYWNlXFxcIjtcXG5cXG5cXHR2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkge1xcblxcdCAgICByZXR1cm4gdGhpcztcXG5cXHR9KSgpO1xcblxcblxcblxcdGlmICghQUNFX05BTUVTUEFDRSAmJiB0eXBlb2YgYWNlcXVpcmVqcyAhPT0gXFxcInVuZGVmaW5lZFxcXCIpXFxuXFx0ICAgIHJldHVybjtcXG5cXG5cXG5cXHR2YXIgX2RlZmluZSA9IGZ1bmN0aW9uKG1vZHVsZSwgZGVwcywgcGF5bG9hZCkge1xcblxcdCAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3N0cmluZycpIHtcXG5cXHQgICAgICAgIGlmIChfZGVmaW5lLm9yaWdpbmFsKVxcblxcdCAgICAgICAgICAgIF9kZWZpbmUub3JpZ2luYWwuYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgICAgY29uc29sZS5lcnJvcignZHJvcHBpbmcgbW9kdWxlIGJlY2F1c2UgZGVmaW5lIHdhc25cXFxcJ3QgYSBzdHJpbmcuJyk7XFxuXFx0ICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpXFxuXFx0ICAgICAgICBwYXlsb2FkID0gZGVwcztcXG5cXG5cXHQgICAgaWYgKCFfZGVmaW5lLm1vZHVsZXMpIHtcXG5cXHQgICAgICAgIF9kZWZpbmUubW9kdWxlcyA9IHt9O1xcblxcdCAgICAgICAgX2RlZmluZS5wYXlsb2FkcyA9IHt9O1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIF9kZWZpbmUucGF5bG9hZHNbbW9kdWxlXSA9IHBheWxvYWQ7XFxuXFx0ICAgIF9kZWZpbmUubW9kdWxlc1ttb2R1bGVdID0gbnVsbDtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEdldCBhdCBmdW5jdGlvbmFsaXR5IGFjZS5kZWZpbmUoKWVkIHVzaW5nIHRoZSBmdW5jdGlvbiBhYm92ZVxcblxcdCAqL1xcblxcdHZhciBfYWNlcXVpcmUgPSBmdW5jdGlvbihwYXJlbnRJZCwgbW9kdWxlLCBjYWxsYmFjaykge1xcblxcdCAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1vZHVsZSkgPT09IFxcXCJbb2JqZWN0IEFycmF5XVxcXCIpIHtcXG5cXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbW9kdWxlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xcblxcdCAgICAgICAgICAgIHZhciBkZXAgPSBsb29rdXAocGFyZW50SWQsIG1vZHVsZVtpXSk7XFxuXFx0ICAgICAgICAgICAgaWYgKCFkZXAgJiYgX2FjZXF1aXJlLm9yaWdpbmFsKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gX2FjZXF1aXJlLm9yaWdpbmFsLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcXG5cXHQgICAgICAgICAgICBwYXJhbXMucHVzaChkZXApO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgcGFyYW1zKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnc3RyaW5nJykge1xcblxcdCAgICAgICAgdmFyIHBheWxvYWQgPSBsb29rdXAocGFyZW50SWQsIG1vZHVsZSk7XFxuXFx0ICAgICAgICBpZiAoIXBheWxvYWQgJiYgX2FjZXF1aXJlLm9yaWdpbmFsKVxcblxcdCAgICAgICAgICAgIHJldHVybiBfYWNlcXVpcmUub3JpZ2luYWwuYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xcblxcblxcdCAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgY2FsbGJhY2soKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBwYXlsb2FkO1xcblxcdCAgICB9XFxuXFx0ICAgIGVsc2Uge1xcblxcdCAgICAgICAgaWYgKF9hY2VxdWlyZS5vcmlnaW5hbClcXG5cXHQgICAgICAgICAgICByZXR1cm4gX2FjZXF1aXJlLm9yaWdpbmFsLmFwcGx5KHdpbmRvdywgYXJndW1lbnRzKTtcXG5cXHQgICAgfVxcblxcdH07XFxuXFxuXFx0dmFyIG5vcm1hbGl6ZU1vZHVsZSA9IGZ1bmN0aW9uKHBhcmVudElkLCBtb2R1bGVOYW1lKSB7XFxuXFx0ICAgIC8vIG5vcm1hbGl6ZSBwbHVnaW4gYWNlcXVpcmVzXFxuXFx0ICAgIGlmIChtb2R1bGVOYW1lLmluZGV4T2YoXFxcIiFcXFwiKSAhPT0gLTEpIHtcXG5cXHQgICAgICAgIHZhciBjaHVua3MgPSBtb2R1bGVOYW1lLnNwbGl0KFxcXCIhXFxcIik7XFxuXFx0ICAgICAgICByZXR1cm4gbm9ybWFsaXplTW9kdWxlKHBhcmVudElkLCBjaHVua3NbMF0pICsgXFxcIiFcXFwiICsgbm9ybWFsaXplTW9kdWxlKHBhcmVudElkLCBjaHVua3NbMV0pO1xcblxcdCAgICB9XFxuXFx0ICAgIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBhY2VxdWlyZXNcXG5cXHQgICAgaWYgKG1vZHVsZU5hbWUuY2hhckF0KDApID09IFxcXCIuXFxcIikge1xcblxcdCAgICAgICAgdmFyIGJhc2UgPSBwYXJlbnRJZC5zcGxpdChcXFwiL1xcXCIpLnNsaWNlKDAsIC0xKS5qb2luKFxcXCIvXFxcIik7XFxuXFx0ICAgICAgICBtb2R1bGVOYW1lID0gYmFzZSArIFxcXCIvXFxcIiArIG1vZHVsZU5hbWU7XFxuXFxuXFx0ICAgICAgICB3aGlsZShtb2R1bGVOYW1lLmluZGV4T2YoXFxcIi5cXFwiKSAhPT0gLTEgJiYgcHJldmlvdXMgIT0gbW9kdWxlTmFtZSkge1xcblxcdCAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IG1vZHVsZU5hbWU7XFxuXFx0ICAgICAgICAgICAgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUucmVwbGFjZSgvXFxcXC9cXFxcLlxcXFwvLywgXFxcIi9cXFwiKS5yZXBsYWNlKC9bXlxcXFwvXStcXFxcL1xcXFwuXFxcXC5cXFxcLy8sIFxcXCJcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICByZXR1cm4gbW9kdWxlTmFtZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGxvb2t1cCBtb2R1bGVOYW1lcyBhbmQgcmVzb2x2ZSB0aGVtIGJ5IGNhbGxpbmcgdGhlXFxuXFx0ICogZGVmaW5pdGlvbiBmdW5jdGlvbiBpZiBuZWVkZWQuXFxuXFx0ICovXFxuXFx0dmFyIGxvb2t1cCA9IGZ1bmN0aW9uKHBhcmVudElkLCBtb2R1bGVOYW1lKSB7XFxuXFxuXFx0ICAgIG1vZHVsZU5hbWUgPSBub3JtYWxpemVNb2R1bGUocGFyZW50SWQsIG1vZHVsZU5hbWUpO1xcblxcblxcdCAgICB2YXIgbW9kdWxlID0gX2RlZmluZS5tb2R1bGVzW21vZHVsZU5hbWVdO1xcblxcdCAgICBpZiAoIW1vZHVsZSkge1xcblxcdCAgICAgICAgbW9kdWxlID0gX2RlZmluZS5wYXlsb2Fkc1ttb2R1bGVOYW1lXTtcXG5cXHQgICAgICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGV4cG9ydHMgPSB7fTtcXG5cXHQgICAgICAgICAgICB2YXIgbW9kID0ge1xcblxcdCAgICAgICAgICAgICAgICBpZDogbW9kdWxlTmFtZSxcXG5cXHQgICAgICAgICAgICAgICAgdXJpOiAnJyxcXG5cXHQgICAgICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0cyxcXG5cXHQgICAgICAgICAgICAgICAgcGFja2FnZWQ6IHRydWVcXG5cXHQgICAgICAgICAgICB9O1xcblxcblxcdCAgICAgICAgICAgIHZhciByZXEgPSBmdW5jdGlvbihtb2R1bGUsIGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBfYWNlcXVpcmUobW9kdWxlTmFtZSwgbW9kdWxlLCBjYWxsYmFjayk7XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBtb2R1bGUocmVxLCBleHBvcnRzLCBtb2QpO1xcblxcdCAgICAgICAgICAgIGV4cG9ydHMgPSByZXR1cm5WYWx1ZSB8fCBtb2QuZXhwb3J0cztcXG5cXHQgICAgICAgICAgICBfZGVmaW5lLm1vZHVsZXNbbW9kdWxlTmFtZV0gPSBleHBvcnRzO1xcblxcdCAgICAgICAgICAgIGRlbGV0ZSBfZGVmaW5lLnBheWxvYWRzW21vZHVsZU5hbWVdO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgbW9kdWxlID0gX2RlZmluZS5tb2R1bGVzW21vZHVsZU5hbWVdID0gZXhwb3J0cyB8fCBtb2R1bGU7XFxuXFx0ICAgIH1cXG5cXHQgICAgcmV0dXJuIG1vZHVsZTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGV4cG9ydEFjZShucykge1xcblxcdCAgICB2YXIgYWNlcXVpcmUgPSBmdW5jdGlvbihtb2R1bGUsIGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICByZXR1cm4gX2FjZXF1aXJlKFxcXCJcXFwiLCBtb2R1bGUsIGNhbGxiYWNrKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdmFyIHJvb3QgPSBnbG9iYWw7XFxuXFx0ICAgIGlmIChucykge1xcblxcdCAgICAgICAgaWYgKCFnbG9iYWxbbnNdKVxcblxcdCAgICAgICAgICAgIGdsb2JhbFtuc10gPSB7fTtcXG5cXHQgICAgICAgIHJvb3QgPSBnbG9iYWxbbnNdO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICghcm9vdC5kZWZpbmUgfHwgIXJvb3QuZGVmaW5lLnBhY2thZ2VkKSB7XFxuXFx0ICAgICAgICBfZGVmaW5lLm9yaWdpbmFsID0gcm9vdC5kZWZpbmU7XFxuXFx0ICAgICAgICByb290LmRlZmluZSA9IF9kZWZpbmU7XFxuXFx0ICAgICAgICByb290LmRlZmluZS5wYWNrYWdlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKCFyb290LmFjZXF1aXJlIHx8ICFyb290LmFjZXF1aXJlLnBhY2thZ2VkKSB7XFxuXFx0ICAgICAgICBfYWNlcXVpcmUub3JpZ2luYWwgPSByb290LmFjZXF1aXJlO1xcblxcdCAgICAgICAgcm9vdC5hY2VxdWlyZSA9IGFjZXF1aXJlO1xcblxcdCAgICAgICAgcm9vdC5hY2VxdWlyZS5wYWNrYWdlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXHR9XFxuXFxuXFx0ZXhwb3J0QWNlKEFDRV9OQU1FU1BBQ0UpO1xcblxcblxcdH0pKCk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2xpYi9yZWdleHBcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHQgICAgdmFyIHJlYWwgPSB7XFxuXFx0ICAgICAgICAgICAgZXhlYzogUmVnRXhwLnByb3RvdHlwZS5leGVjLFxcblxcdCAgICAgICAgICAgIHRlc3Q6IFJlZ0V4cC5wcm90b3R5cGUudGVzdCxcXG5cXHQgICAgICAgICAgICBtYXRjaDogU3RyaW5nLnByb3RvdHlwZS5tYXRjaCxcXG5cXHQgICAgICAgICAgICByZXBsYWNlOiBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UsXFxuXFx0ICAgICAgICAgICAgc3BsaXQ6IFN0cmluZy5wcm90b3R5cGUuc3BsaXRcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBjb21wbGlhbnRFeGVjTnBjZyA9IHJlYWwuZXhlYy5jYWxsKC8oKT8/LywgXFxcIlxcXCIpWzFdID09PSB1bmRlZmluZWQsIC8vIGNoZWNrIGBleGVjYCBoYW5kbGluZyBvZiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcXG5cXHQgICAgICAgIGNvbXBsaWFudExhc3RJbmRleEluY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICB2YXIgeCA9IC9eL2c7XFxuXFx0ICAgICAgICAgICAgcmVhbC50ZXN0LmNhbGwoeCwgXFxcIlxcXCIpO1xcblxcdCAgICAgICAgICAgIHJldHVybiAheC5sYXN0SW5kZXg7XFxuXFx0ICAgICAgICB9KCk7XFxuXFxuXFx0ICAgIGlmIChjb21wbGlhbnRMYXN0SW5kZXhJbmNyZW1lbnQgJiYgY29tcGxpYW50RXhlY05wY2cpXFxuXFx0ICAgICAgICByZXR1cm47XFxuXFx0ICAgIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChzdHIpIHtcXG5cXHQgICAgICAgIHZhciBtYXRjaCA9IHJlYWwuZXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxcblxcdCAgICAgICAgICAgIG5hbWUsIHIyO1xcblxcdCAgICAgICAgaWYgKCB0eXBlb2Yoc3RyKSA9PSAnc3RyaW5nJyAmJiBtYXRjaCkge1xcblxcdCAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBpbmRleE9mKG1hdGNoLCBcXFwiXFxcIikgPiAtMSkge1xcblxcdCAgICAgICAgICAgICAgICByMiA9IFJlZ0V4cCh0aGlzLnNvdXJjZSwgcmVhbC5yZXBsYWNlLmNhbGwoZ2V0TmF0aXZlRmxhZ3ModGhpcyksIFxcXCJnXFxcIiwgXFxcIlxcXCIpKTtcXG5cXHQgICAgICAgICAgICAgICAgcmVhbC5yZXBsYWNlLmNhbGwoc3RyLnNsaWNlKG1hdGNoLmluZGV4KSwgcjIsIGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZClcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5feHJlZ2V4cCAmJiB0aGlzLl94cmVnZXhwLmNhcHR1cmVOYW1lcykge1xcblxcdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5feHJlZ2V4cC5jYXB0dXJlTmFtZXNbaSAtIDFdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtuYW1lXSA9IG1hdGNoW2ldO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmICghY29tcGxpYW50TGFzdEluZGV4SW5jcmVtZW50ICYmIHRoaXMuZ2xvYmFsICYmICFtYXRjaFswXS5sZW5ndGggJiYgKHRoaXMubGFzdEluZGV4ID4gbWF0Y2guaW5kZXgpKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleC0tO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIG1hdGNoO1xcblxcdCAgICB9O1xcblxcdCAgICBpZiAoIWNvbXBsaWFudExhc3RJbmRleEluY3JlbWVudCkge1xcblxcdCAgICAgICAgUmVnRXhwLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHN0cikge1xcblxcdCAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlYWwuZXhlYy5jYWxsKHRoaXMsIHN0cik7XFxuXFx0ICAgICAgICAgICAgaWYgKG1hdGNoICYmIHRoaXMuZ2xvYmFsICYmICFtYXRjaFswXS5sZW5ndGggJiYgKHRoaXMubGFzdEluZGV4ID4gbWF0Y2guaW5kZXgpKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleC0tO1xcblxcdCAgICAgICAgICAgIHJldHVybiAhIW1hdGNoO1xcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBmdW5jdGlvbiBnZXROYXRpdmVGbGFncyAocmVnZXgpIHtcXG5cXHQgICAgICAgIHJldHVybiAocmVnZXguZ2xvYmFsICAgICA/IFxcXCJnXFxcIiA6IFxcXCJcXFwiKSArXFxuXFx0ICAgICAgICAgICAgICAgKHJlZ2V4Lmlnbm9yZUNhc2UgPyBcXFwiaVxcXCIgOiBcXFwiXFxcIikgK1xcblxcdCAgICAgICAgICAgICAgIChyZWdleC5tdWx0aWxpbmUgID8gXFxcIm1cXFwiIDogXFxcIlxcXCIpICtcXG5cXHQgICAgICAgICAgICAgICAocmVnZXguZXh0ZW5kZWQgICA/IFxcXCJ4XFxcIiA6IFxcXCJcXFwiKSArIC8vIFByb3Bvc2VkIGZvciBFUzQ7IGluY2x1ZGVkIGluIEFTM1xcblxcdCAgICAgICAgICAgICAgIChyZWdleC5zdGlja3kgICAgID8gXFxcInlcXFwiIDogXFxcIlxcXCIpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGZ1bmN0aW9uIGluZGV4T2YgKGFycmF5LCBpdGVtLCBmcm9tKSB7XFxuXFx0ICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIC8vIFVzZSB0aGUgbmF0aXZlIGFycmF5IG1ldGhvZCBpZiBhdmFpbGFibGVcXG5cXHQgICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBmcm9tKTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSBmcm9tIHx8IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSlcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gLTE7XFxuXFx0ICAgIH1cXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGliL2VzNS1zaGltXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXG5cXHRmdW5jdGlvbiBFbXB0eSgpIHt9XFxuXFxuXFx0aWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xcblxcdCAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcXG5cXHQgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgXFxcIiArIHRhcmdldCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXFxuXFx0ICAgICAgICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xcblxcblxcdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcyxcXG5cXHQgICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcXG5cXHQgICAgICAgICAgICAgICAgKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XFxuXFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoYXQsXFxuXFx0ICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXFxuXFx0ICAgICAgICAgICAgICAgICk7XFxuXFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIGlmKHRhcmdldC5wcm90b3R5cGUpIHtcXG5cXHQgICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xcblxcdCAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xcblxcdCAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gYm91bmQ7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdHZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XFxuXFx0dmFyIHByb3RvdHlwZU9mQXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XFxuXFx0dmFyIHByb3RvdHlwZU9mT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXHR2YXIgc2xpY2UgPSBwcm90b3R5cGVPZkFycmF5LnNsaWNlO1xcblxcdHZhciBfdG9TdHJpbmcgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QudG9TdHJpbmcpO1xcblxcdHZhciBvd25zID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtcXG5cXHR2YXIgZGVmaW5lR2V0dGVyO1xcblxcdHZhciBkZWZpbmVTZXR0ZXI7XFxuXFx0dmFyIGxvb2t1cEdldHRlcjtcXG5cXHR2YXIgbG9va3VwU2V0dGVyO1xcblxcdHZhciBzdXBwb3J0c0FjY2Vzc29ycztcXG5cXHRpZiAoKHN1cHBvcnRzQWNjZXNzb3JzID0gb3ducyhwcm90b3R5cGVPZk9iamVjdCwgXFxcIl9fZGVmaW5lR2V0dGVyX19cXFwiKSkpIHtcXG5cXHQgICAgZGVmaW5lR2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lR2V0dGVyX18pO1xcblxcdCAgICBkZWZpbmVTZXR0ZXIgPSBjYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVTZXR0ZXJfXyk7XFxuXFx0ICAgIGxvb2t1cEdldHRlciA9IGNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cEdldHRlcl9fKTtcXG5cXHQgICAgbG9va3VwU2V0dGVyID0gY2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwU2V0dGVyX18pO1xcblxcdH1cXG5cXHRpZiAoWzEsMl0uc3BsaWNlKDApLmxlbmd0aCAhPSAyKSB7XFxuXFx0ICAgIGlmKGZ1bmN0aW9uKCkgeyAvLyB0ZXN0IElFIDwgOSB0byBzcGxpY2UgYnVnIC0gc2VlIGlzc3VlICMxMzhcXG5cXHQgICAgICAgIGZ1bmN0aW9uIG1ha2VBcnJheShsKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkobCsyKTtcXG5cXHQgICAgICAgICAgICBhWzBdID0gYVsxXSA9IDA7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGE7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB2YXIgYXJyYXkgPSBbXSwgbGVuZ3RoQmVmb3JlO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBhcnJheS5zcGxpY2UuYXBwbHkoYXJyYXksIG1ha2VBcnJheSgyMCkpO1xcblxcdCAgICAgICAgYXJyYXkuc3BsaWNlLmFwcGx5KGFycmF5LCBtYWtlQXJyYXkoMjYpKTtcXG5cXG5cXHQgICAgICAgIGxlbmd0aEJlZm9yZSA9IGFycmF5Lmxlbmd0aDsgLy80NlxcblxcdCAgICAgICAgYXJyYXkuc3BsaWNlKDUsIDAsIFxcXCJYWFhcXFwiKTsgLy8gYWRkIG9uZSBlbGVtZW50XFxuXFxuXFx0ICAgICAgICBsZW5ndGhCZWZvcmUgKyAxID09IGFycmF5Lmxlbmd0aFxcblxcblxcdCAgICAgICAgaWYgKGxlbmd0aEJlZm9yZSArIDEgPT0gYXJyYXkubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7Ly8gaGFzIHJpZ2h0IHNwbGljZSBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IGJ1Z3NcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSgpKSB7Ly9JRSA2LzdcXG5cXHQgICAgICAgIHZhciBhcnJheV9zcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xcblxcdCAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBkZWxldGVDb3VudCkge1xcblxcdCAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gW107XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBbXFxuXFx0ICAgICAgICAgICAgICAgICAgICBzdGFydCA9PT0gdm9pZCAwID8gMCA6IHN0YXJ0LFxcblxcdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlQ291bnQgPT09IHZvaWQgMCA/ICh0aGlzLmxlbmd0aCAtIHN0YXJ0KSA6IGRlbGV0ZUNvdW50XFxuXFx0ICAgICAgICAgICAgICAgIF0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSkpXFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfSBlbHNlIHsvL0lFOFxcblxcdCAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKHBvcywgcmVtb3ZlQ291bnQpe1xcblxcdCAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcXG5cXHQgICAgICAgICAgICBpZiAocG9zID4gMCkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAocG9zID4gbGVuZ3RoKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcG9zID0gbGVuZ3RoO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zID09IHZvaWQgMCkge1xcblxcdCAgICAgICAgICAgICAgICBwb3MgPSAwO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zIDwgMCkge1xcblxcdCAgICAgICAgICAgICAgICBwb3MgPSBNYXRoLm1heChsZW5ndGggKyBwb3MsIDApO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBpZiAoIShwb3MrcmVtb3ZlQ291bnQgPCBsZW5ndGgpKVxcblxcdCAgICAgICAgICAgICAgICByZW1vdmVDb3VudCA9IGxlbmd0aCAtIHBvcztcXG5cXG5cXHQgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuc2xpY2UocG9zLCBwb3MrcmVtb3ZlQ291bnQpO1xcblxcdCAgICAgICAgICAgIHZhciBpbnNlcnQgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XFxuXFx0ICAgICAgICAgICAgdmFyIGFkZCA9IGluc2VydC5sZW5ndGg7ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgaWYgKHBvcyA9PT0gbGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaC5hcHBseSh0aGlzLCBpbnNlcnQpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJlbW92ZSA9IE1hdGgubWluKHJlbW92ZUNvdW50LCBsZW5ndGggLSBwb3MpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdGFpbE9sZFBvcyA9IHBvcyArIHJlbW92ZTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRhaWxOZXdQb3MgPSB0YWlsT2xkUG9zICsgYWRkIC0gcmVtb3ZlO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdGFpbENvdW50ID0gbGVuZ3RoIC0gdGFpbE9sZFBvcztcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGxlbmd0aEFmdGVyUmVtb3ZlID0gbGVuZ3RoIC0gcmVtb3ZlO1xcblxcblxcdCAgICAgICAgICAgICAgICBpZiAodGFpbE5ld1BvcyA8IHRhaWxPbGRQb3MpIHsgLy8gY2FzZSBBXFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhaWxDb3VudDsgKytpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1t0YWlsTmV3UG9zK2ldID0gdGhpc1t0YWlsT2xkUG9zK2ldO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhaWxOZXdQb3MgPiB0YWlsT2xkUG9zKSB7IC8vIGNhc2UgQlxcblxcdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gdGFpbENvdW50OyBpLS07ICkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbdGFpbE5ld1BvcytpXSA9IHRoaXNbdGFpbE9sZFBvcytpXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfSAvLyBlbHNlLCBhZGQgPT0gcmVtb3ZlIChub3RoaW5nIHRvIGRvKVxcblxcblxcdCAgICAgICAgICAgICAgICBpZiAoYWRkICYmIHBvcyA9PT0gbGVuZ3RoQWZ0ZXJSZW1vdmUpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoQWZ0ZXJSZW1vdmU7IC8vIHRydW5jYXRlIGFycmF5XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2guYXBwbHkodGhpcywgaW5zZXJ0KTtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoQWZ0ZXJSZW1vdmUgKyBhZGQ7IC8vIHJlc2VydmVzIHNwYWNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWRkOyArK2kpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3BvcytpXSA9IGluc2VydFtpXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcXG5cXHQgICAgICAgIH07XFxuXFx0ICAgIH1cXG5cXHR9XFxuXFx0aWYgKCFBcnJheS5pc0FycmF5KSB7XFxuXFx0ICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xcblxcdCAgICAgICAgcmV0dXJuIF90b1N0cmluZyhvYmopID09IFxcXCJbb2JqZWN0IEFycmF5XVxcXCI7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdHZhciBib3hlZFN0cmluZyA9IE9iamVjdChcXFwiYVxcXCIpLFxcblxcdCAgICBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9IFxcXCJhXFxcIiB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xcblxcblxcdGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcXG5cXHQgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xcblxcdCAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxcblxcdCAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXFxcIltvYmplY3QgU3RyaW5nXVxcXCIgP1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFxcXCJcXFwiKSA6XFxuXFx0ICAgICAgICAgICAgICAgIG9iamVjdCxcXG5cXHQgICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXSxcXG5cXHQgICAgICAgICAgICBpID0gLTEsXFxuXFx0ICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XFxuXFx0ICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIikge1xcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xcblxcdCAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdGlmICghQXJyYXkucHJvdG90eXBlLm1hcCkge1xcblxcdCAgICBBcnJheS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwKGZ1biAvKiwgdGhpc3AqLykge1xcblxcdCAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxcblxcdCAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXFxcIltvYmplY3QgU3RyaW5nXVxcXCIgP1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFxcXCJcXFwiKSA6XFxuXFx0ICAgICAgICAgICAgICAgIG9iamVjdCxcXG5cXHQgICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMCxcXG5cXHQgICAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxcblxcdCAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xcblxcdCAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXCIpIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFxcXCIgaXMgbm90IGEgZnVuY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKVxcblxcdCAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiByZXN1bHQ7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdGlmICghQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xcblxcdCAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGZ1biAvKiwgdGhpc3AgKi8pIHtcXG5cXHQgICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcXG5cXHQgICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFxcXCJbb2JqZWN0IFN0cmluZ11cXFwiID9cXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcXFwiXFxcIikgOlxcblxcdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0LFxcblxcdCAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxcblxcdCAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxcblxcdCAgICAgICAgICAgIHZhbHVlLFxcblxcdCAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xcblxcdCAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXCIpIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFxcXCIgaXMgbm90IGEgZnVuY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhbHVlID0gc2VsZltpXTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNwLCB2YWx1ZSwgaSwgb2JqZWN0KSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFBcnJheS5wcm90b3R5cGUuZXZlcnkpIHtcXG5cXHQgICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoZnVuIC8qLCB0aGlzcCAqLykge1xcblxcdCAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxcblxcdCAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXFxcIltvYmplY3QgU3RyaW5nXVxcXCIgP1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFxcXCJcXFwiKSA6XFxuXFx0ICAgICAgICAgICAgICAgIG9iamVjdCxcXG5cXHQgICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMCxcXG5cXHQgICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXTtcXG5cXHQgICAgICAgIGlmIChfdG9TdHJpbmcoZnVuKSAhPSBcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiKSB7XFxuXFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4gKyBcXFwiIGlzIG5vdCBhIGZ1bmN0aW9uXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAhZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICB9O1xcblxcdH1cXG5cXHRpZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKSB7XFxuXFx0ICAgIEFycmF5LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gc29tZShmdW4gLyosIHRoaXNwICovKSB7XFxuXFx0ICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXFxuXFx0ICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIF90b1N0cmluZyh0aGlzKSA9PSBcXFwiW29iamVjdCBTdHJpbmddXFxcIiA/XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc3BsaXQoXFxcIlxcXCIpIDpcXG5cXHQgICAgICAgICAgICAgICAgb2JqZWN0LFxcblxcdCAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwLFxcblxcdCAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdO1xcblxcdCAgICAgICAgaWYgKF90b1N0cmluZyhmdW4pICE9IFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXCIpIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZ1biArIFxcXCIgaXMgbm90IGEgZnVuY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XFxuXFx0ICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoZnVuIC8qLCBpbml0aWFsKi8pIHtcXG5cXHQgICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcXG5cXHQgICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFxcXCJbb2JqZWN0IFN0cmluZ11cXFwiID9cXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcXFwiXFxcIikgOlxcblxcdCAgICAgICAgICAgICAgICBvYmplY3QsXFxuXFx0ICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XFxuXFx0ICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIikge1xcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZnVuICsgXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXCIpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKCFsZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XFxuXFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwicmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXCIpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGkgPSAwO1xcblxcdCAgICAgICAgdmFyIHJlc3VsdDtcXG5cXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcXG5cXHQgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpKytdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgaWYgKCsraSA+PSBsZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcInJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcXFwiKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuLmNhbGwodm9pZCAwLCByZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcXG5cXHQgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gcmVkdWNlUmlnaHQoZnVuIC8qLCBpbml0aWFsKi8pIHtcXG5cXHQgICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcXG5cXHQgICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFxcXCJbb2JqZWN0IFN0cmluZ11cXFwiID9cXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcXFwiXFxcIikgOlxcblxcdCAgICAgICAgICAgICAgICBvYmplY3QsXFxuXFx0ICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XFxuXFx0ICAgICAgICBpZiAoX3RvU3RyaW5nKGZ1bikgIT0gXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIikge1xcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZnVuICsgXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXCIpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKCFsZW5ndGggJiYgYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XFxuXFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwicmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgcmVzdWx0LCBpID0gbGVuZ3RoIC0gMTtcXG5cXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcXG5cXHQgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcInJlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXCIpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBkbyB7XFxuXFx0ICAgICAgICAgICAgaWYgKGkgaW4gdGhpcykge1xcblxcdCAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW4uY2FsbCh2b2lkIDAsIHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IHdoaWxlIChpLS0pO1xcblxcblxcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCAoWzAsIDFdLmluZGV4T2YoMSwgMikgIT0gLTEpKSB7XFxuXFx0ICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcXG5cXHQgICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgX3RvU3RyaW5nKHRoaXMpID09IFxcXCJbb2JqZWN0IFN0cmluZ11cXFwiID9cXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zcGxpdChcXFwiXFxcIikgOlxcblxcdCAgICAgICAgICAgICAgICB0b09iamVjdCh0aGlzKSxcXG5cXHQgICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcXG5cXG5cXHQgICAgICAgIGlmICghbGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGkgPSAwO1xcblxcdCAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuXFx0ICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcXG5cXHQgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gaTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gLTE7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdGlmICghQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mIHx8IChbMCwgMV0ubGFzdEluZGV4T2YoMCwgLTMpICE9IC0xKSkge1xcblxcdCAgICBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLykge1xcblxcdCAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBfdG9TdHJpbmcodGhpcykgPT0gXFxcIltvYmplY3QgU3RyaW5nXVxcXCIgP1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNwbGl0KFxcXCJcXFwiKSA6XFxuXFx0ICAgICAgICAgICAgICAgIHRvT2JqZWN0KHRoaXMpLFxcblxcdCAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xcblxcblxcdCAgICAgICAgaWYgKCFsZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gLTE7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB2YXIgaSA9IGxlbmd0aCAtIDE7XFxuXFx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG5cXHQgICAgICAgICAgICBpID0gTWF0aC5taW4oaSwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBsZW5ndGggLSBNYXRoLmFicyhpKTtcXG5cXHQgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xcblxcdCAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc291Z2h0ID09PSBzZWxmW2ldKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiAtMTtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcXG5cXHQgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gb2JqZWN0Ll9fcHJvdG9fXyB8fCAoXFxuXFx0ICAgICAgICAgICAgb2JqZWN0LmNvbnN0cnVjdG9yID9cXG5cXHQgICAgICAgICAgICBvYmplY3QuY29uc3RydWN0b3IucHJvdG90eXBlIDpcXG5cXHQgICAgICAgICAgICBwcm90b3R5cGVPZk9iamVjdFxcblxcdCAgICAgICAgKTtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKSB7XFxuXFx0ICAgIHZhciBFUlJfTk9OX09CSkVDVCA9IFxcXCJPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbGxlZCBvbiBhIFxcXCIgK1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICBcXFwibm9uLW9iamVjdDogXFxcIjtcXG5cXHQgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KSB7XFxuXFx0ICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgIT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG9iamVjdCAhPSBcXFwiZnVuY3Rpb25cXFwiKSB8fCBvYmplY3QgPT09IG51bGwpXFxuXFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVCArIG9iamVjdCk7XFxuXFx0ICAgICAgICBpZiAoIW93bnMob2JqZWN0LCBwcm9wZXJ0eSkpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdmFyIGRlc2NyaXB0b3IsIGdldHRlciwgc2V0dGVyO1xcblxcdCAgICAgICAgZGVzY3JpcHRvciA9ICB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9O1xcblxcdCAgICAgICAgaWYgKHN1cHBvcnRzQWNjZXNzb3JzKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IG9iamVjdC5fX3Byb3RvX187XFxuXFx0ICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZU9mT2JqZWN0O1xcblxcblxcdCAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSk7XFxuXFx0ICAgICAgICAgICAgdmFyIHNldHRlciA9IGxvb2t1cFNldHRlcihvYmplY3QsIHByb3BlcnR5KTtcXG5cXHQgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xcblxcblxcdCAgICAgICAgICAgIGlmIChnZXR0ZXIgfHwgc2V0dGVyKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChnZXR0ZXIpIGRlc2NyaXB0b3IuZ2V0ID0gZ2V0dGVyO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoc2V0dGVyKSBkZXNjcmlwdG9yLnNldCA9IHNldHRlcjtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XFxuXFx0ICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xcblxcdCAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QuY3JlYXRlKSB7XFxuXFx0ICAgIHZhciBjcmVhdGVFbXB0eTtcXG5cXHQgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuX19wcm90b19fID09PSBudWxsKSB7XFxuXFx0ICAgICAgICBjcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4geyBcXFwiX19wcm90b19fXFxcIjogbnVsbCB9O1xcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIGNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAgIHZhciBlbXB0eSA9IHt9O1xcblxcdCAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZW1wdHkpXFxuXFx0ICAgICAgICAgICAgICAgIGVtcHR5W2ldID0gbnVsbDtcXG5cXHQgICAgICAgICAgICBlbXB0eS5jb25zdHJ1Y3RvciA9XFxuXFx0ICAgICAgICAgICAgZW1wdHkuaGFzT3duUHJvcGVydHkgPVxcblxcdCAgICAgICAgICAgIGVtcHR5LnByb3BlcnR5SXNFbnVtZXJhYmxlID1cXG5cXHQgICAgICAgICAgICBlbXB0eS5pc1Byb3RvdHlwZU9mID1cXG5cXHQgICAgICAgICAgICBlbXB0eS50b0xvY2FsZVN0cmluZyA9XFxuXFx0ICAgICAgICAgICAgZW1wdHkudG9TdHJpbmcgPVxcblxcdCAgICAgICAgICAgIGVtcHR5LnZhbHVlT2YgPVxcblxcdCAgICAgICAgICAgIGVtcHR5Ll9fcHJvdG9fXyA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XFxuXFx0ICAgICAgICB2YXIgb2JqZWN0O1xcblxcdCAgICAgICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgIG9iamVjdCA9IGNyZWF0ZUVtcHR5KCk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9IFxcXCJvYmplY3RcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJ0eXBlb2YgcHJvdG90eXBlW1xcXCIrKHR5cGVvZiBwcm90b3R5cGUpK1xcXCJdICE9ICdvYmplY3QnXFxcIik7XFxuXFx0ICAgICAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXHQgICAgICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcXG5cXHQgICAgICAgICAgICBvYmplY3QgPSBuZXcgVHlwZSgpO1xcblxcdCAgICAgICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAocHJvcGVydGllcyAhPT0gdm9pZCAwKVxcblxcdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcyk7XFxuXFx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xcblxcdCAgICB9O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKG9iamVjdCkge1xcblxcdCAgICB0cnkge1xcblxcdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXFxcInNlbnRpbmVsXFxcIiwge30pO1xcblxcdCAgICAgICAgcmV0dXJuIFxcXCJzZW50aW5lbFxcXCIgaW4gb2JqZWN0O1xcblxcdCAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcXG5cXHQgICAgfVxcblxcdH1cXG5cXHRpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XFxuXFx0ICAgIHZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3QgPSBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKHt9KTtcXG5cXHQgICAgdmFyIGRlZmluZVByb3BlcnR5V29ya3NPbkRvbSA9IHR5cGVvZiBkb2N1bWVudCA9PSBcXFwidW5kZWZpbmVkXFxcIiB8fFxcblxcdCAgICAgICAgZG9lc0RlZmluZVByb3BlcnR5V29yayhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7XFxuXFx0ICAgIGlmICghZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0IHx8ICFkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20pIHtcXG5cXHQgICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xcblxcdCAgICB9XFxuXFx0fVxcblxcblxcdGlmICghT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcXG5cXHQgICAgdmFyIEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1IgPSBcXFwiUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBhbiBvYmplY3Q6IFxcXCI7XFxuXFx0ICAgIHZhciBFUlJfTk9OX09CSkVDVF9UQVJHRVQgPSBcXFwiT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0OiBcXFwiXFxuXFx0ICAgIHZhciBFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQgPSBcXFwiZ2V0dGVycyAmIHNldHRlcnMgY2FuIG5vdCBiZSBkZWZpbmVkIFxcXCIgK1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIm9uIHRoaXMgamF2YXNjcmlwdCBlbmdpbmVcXFwiO1xcblxcblxcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XFxuXFx0ICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgIT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG9iamVjdCAhPSBcXFwiZnVuY3Rpb25cXFwiKSB8fCBvYmplY3QgPT09IG51bGwpXFxuXFx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9UQVJHRVQgKyBvYmplY3QpO1xcblxcdCAgICAgICAgaWYgKCh0eXBlb2YgZGVzY3JpcHRvciAhPSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgZGVzY3JpcHRvciAhPSBcXFwiZnVuY3Rpb25cXFwiKSB8fCBkZXNjcmlwdG9yID09PSBudWxsKVxcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUiArIGRlc2NyaXB0b3IpO1xcblxcdCAgICAgICAgaWYgKGRlZmluZVByb3BlcnR5RmFsbGJhY2spIHtcXG5cXHQgICAgICAgICAgICB0cnkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHlGYWxsYmFjay5jYWxsKE9iamVjdCwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XFxuXFx0ICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKG93bnMoZGVzY3JpcHRvciwgXFxcInZhbHVlXFxcIikpIHtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoc3VwcG9ydHNBY2Nlc3NvcnMgJiYgKGxvb2t1cEdldHRlcihvYmplY3QsIHByb3BlcnR5KSB8fFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9va3VwU2V0dGVyKG9iamVjdCwgcHJvcGVydHkpKSlcXG5cXHQgICAgICAgICAgICB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fO1xcblxcdCAgICAgICAgICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlT2ZPYmplY3Q7XFxuXFx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcGVydHldO1xcblxcdCAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcXG5cXHQgICAgICAgICAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gZGVzY3JpcHRvci52YWx1ZTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGlmICghc3VwcG9ydHNBY2Nlc3NvcnMpXFxuXFx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSX0FDQ0VTU09SU19OT1RfU1VQUE9SVEVEKTtcXG5cXHQgICAgICAgICAgICBpZiAob3ducyhkZXNjcmlwdG9yLCBcXFwiZ2V0XFxcIikpXFxuXFx0ICAgICAgICAgICAgICAgIGRlZmluZUdldHRlcihvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yLmdldCk7XFxuXFx0ICAgICAgICAgICAgaWYgKG93bnMoZGVzY3JpcHRvciwgXFxcInNldFxcXCIpKVxcblxcdCAgICAgICAgICAgICAgICBkZWZpbmVTZXR0ZXIob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvci5zZXQpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIG9iamVjdDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QuZGVmaW5lUHJvcGVydGllcykge1xcblxcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XFxuXFx0ICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKG93bnMocHJvcGVydGllcywgcHJvcGVydHkpKVxcblxcdCAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgcHJvcGVydGllc1twcm9wZXJ0eV0pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIG9iamVjdDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3Quc2VhbCkge1xcblxcdCAgICBPYmplY3Quc2VhbCA9IGZ1bmN0aW9uIHNlYWwob2JqZWN0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xcblxcdCAgICB9O1xcblxcdH1cXG5cXHRpZiAoIU9iamVjdC5mcmVlemUpIHtcXG5cXHQgICAgT2JqZWN0LmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZShvYmplY3QpIHtcXG5cXHQgICAgICAgIHJldHVybiBvYmplY3Q7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdHRyeSB7XFxuXFx0ICAgIE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKCkge30pO1xcblxcdH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xcblxcdCAgICBPYmplY3QuZnJlZXplID0gKGZ1bmN0aW9uIGZyZWV6ZShmcmVlemVPYmplY3QpIHtcXG5cXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiBmcmVlemUob2JqZWN0KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBmcmVlemVPYmplY3Qob2JqZWN0KTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9KShPYmplY3QuZnJlZXplKTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QucHJldmVudEV4dGVuc2lvbnMpIHtcXG5cXHQgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID0gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMob2JqZWN0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xcblxcdCAgICB9O1xcblxcdH1cXG5cXHRpZiAoIU9iamVjdC5pc1NlYWxlZCkge1xcblxcdCAgICBPYmplY3QuaXNTZWFsZWQgPSBmdW5jdGlvbiBpc1NlYWxlZChvYmplY3QpIHtcXG5cXHQgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0aWYgKCFPYmplY3QuaXNGcm96ZW4pIHtcXG5cXHQgICAgT2JqZWN0LmlzRnJvemVuID0gZnVuY3Rpb24gaXNGcm96ZW4ob2JqZWN0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZSkge1xcblxcdCAgICBPYmplY3QuaXNFeHRlbnNpYmxlID0gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKG9iamVjdCkge1xcblxcdCAgICAgICAgaWYgKE9iamVjdChvYmplY3QpID09PSBvYmplY3QpIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIG5hbWUgPSAnJztcXG5cXHQgICAgICAgIHdoaWxlIChvd25zKG9iamVjdCwgbmFtZSkpIHtcXG5cXHQgICAgICAgICAgICBuYW1lICs9ICc/JztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIG9iamVjdFtuYW1lXSA9IHRydWU7XFxuXFx0ICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBvd25zKG9iamVjdCwgbmFtZSk7XFxuXFx0ICAgICAgICBkZWxldGUgb2JqZWN0W25hbWVdO1xcblxcdCAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xcblxcdCAgICB9O1xcblxcdH1cXG5cXHRpZiAoIU9iamVjdC5rZXlzKSB7XFxuXFx0ICAgIHZhciBoYXNEb250RW51bUJ1ZyA9IHRydWUsXFxuXFx0ICAgICAgICBkb250RW51bXMgPSBbXFxuXFx0ICAgICAgICAgICAgXFxcInRvU3RyaW5nXFxcIixcXG5cXHQgICAgICAgICAgICBcXFwidG9Mb2NhbGVTdHJpbmdcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJ2YWx1ZU9mXFxcIixcXG5cXHQgICAgICAgICAgICBcXFwiaGFzT3duUHJvcGVydHlcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJpc1Byb3RvdHlwZU9mXFxcIixcXG5cXHQgICAgICAgICAgICBcXFwicHJvcGVydHlJc0VudW1lcmFibGVcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJjb25zdHJ1Y3RvclxcXCJcXG5cXHQgICAgICAgIF0sXFxuXFx0ICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xcblxcblxcdCAgICBmb3IgKHZhciBrZXkgaW4ge1xcXCJ0b1N0cmluZ1xcXCI6IG51bGx9KSB7XFxuXFx0ICAgICAgICBoYXNEb250RW51bUJ1ZyA9IGZhbHNlO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcXG5cXG5cXHQgICAgICAgIGlmIChcXG5cXHQgICAgICAgICAgICAodHlwZW9mIG9iamVjdCAhPSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2Ygb2JqZWN0ICE9IFxcXCJmdW5jdGlvblxcXCIpIHx8XFxuXFx0ICAgICAgICAgICAgb2JqZWN0ID09PSBudWxsXFxuXFx0ICAgICAgICApIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0XFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIga2V5cyA9IFtdO1xcblxcdCAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcXG5cXHQgICAgICAgICAgICBpZiAob3ducyhvYmplY3QsIG5hbWUpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGtleXMucHVzaChuYW1lKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBkb250RW51bXNMZW5ndGg7IGkgPCBpaTsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tpXTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKG93bnMob2JqZWN0LCBkb250RW51bSkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChkb250RW51bSk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4ga2V5cztcXG5cXHQgICAgfTtcXG5cXG5cXHR9XFxuXFx0aWYgKCFEYXRlLm5vdykge1xcblxcdCAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcXG5cXHQgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0dmFyIHdzID0gXFxcIlxcXFx4MDlcXFxceDBBXFxcXHgwQlxcXFx4MENcXFxceDBEXFxcXHgyMFxcXFx4QTBcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFwiICtcXG5cXHQgICAgXFxcIlxcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMFxcXFx1MjAyOFxcXCIgK1xcblxcdCAgICBcXFwiXFxcXHUyMDI5XFxcXHVGRUZGXFxcIjtcXG5cXHRpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSB8fCB3cy50cmltKCkpIHtcXG5cXHQgICAgd3MgPSBcXFwiW1xcXCIgKyB3cyArIFxcXCJdXFxcIjtcXG5cXHQgICAgdmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgd3MgKyB3cyArIFxcXCIqXFxcIiksXFxuXFx0ICAgICAgICB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3cyArIHdzICsgXFxcIiokXFxcIik7XFxuXFx0ICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uIHRyaW0oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMpLnJlcGxhY2UodHJpbUJlZ2luUmVnZXhwLCBcXFwiXFxcIikucmVwbGFjZSh0cmltRW5kUmVnZXhwLCBcXFwiXFxcIik7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHRvSW50ZWdlcihuKSB7XFxuXFx0ICAgIG4gPSArbjtcXG5cXHQgICAgaWYgKG4gIT09IG4pIHsgLy8gaXNOYU5cXG5cXHQgICAgICAgIG4gPSAwO1xcblxcdCAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEvMCkgJiYgbiAhPT0gLSgxLzApKSB7XFxuXFx0ICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiBuO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBpc1ByaW1pdGl2ZShpbnB1dCkge1xcblxcdCAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbnB1dDtcXG5cXHQgICAgcmV0dXJuIChcXG5cXHQgICAgICAgIGlucHV0ID09PSBudWxsIHx8XFxuXFx0ICAgICAgICB0eXBlID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fFxcblxcdCAgICAgICAgdHlwZSA9PT0gXFxcImJvb2xlYW5cXFwiIHx8XFxuXFx0ICAgICAgICB0eXBlID09PSBcXFwibnVtYmVyXFxcIiB8fFxcblxcdCAgICAgICAgdHlwZSA9PT0gXFxcInN0cmluZ1xcXCJcXG5cXHQgICAgKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gdG9QcmltaXRpdmUoaW5wdXQpIHtcXG5cXHQgICAgdmFyIHZhbCwgdmFsdWVPZiwgdG9TdHJpbmc7XFxuXFx0ICAgIGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcXG5cXHQgICAgICAgIHJldHVybiBpbnB1dDtcXG5cXHQgICAgfVxcblxcdCAgICB2YWx1ZU9mID0gaW5wdXQudmFsdWVPZjtcXG5cXHQgICAgaWYgKHR5cGVvZiB2YWx1ZU9mID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuXFx0ICAgICAgICB2YWwgPSB2YWx1ZU9mLmNhbGwoaW5wdXQpO1xcblxcdCAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHRvU3RyaW5nID0gaW5wdXQudG9TdHJpbmc7XFxuXFx0ICAgIGlmICh0eXBlb2YgdG9TdHJpbmcgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHQgICAgICAgIHZhbCA9IHRvU3RyaW5nLmNhbGwoaW5wdXQpO1xcblxcdCAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcXG5cXHR9XFxuXFx0dmFyIHRvT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcXG5cXHQgICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcXG5cXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcImNhbid0IGNvbnZlcnQgXFxcIitvK1xcXCIgdG8gb2JqZWN0XFxcIik7XFxuXFx0ICAgIH1cXG5cXHQgICAgcmV0dXJuIE9iamVjdChvKTtcXG5cXHR9O1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9saWIvZml4b2xkYnJvd3NlcnNcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL3JlZ2V4cFxcXCIsXFxcImFjZS9saWIvZXM1LXNoaW1cXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRhY2VxdWlyZShcXFwiLi9yZWdleHBcXFwiKTtcXG5cXHRhY2VxdWlyZShcXFwiLi9lczUtc2hpbVxcXCIpO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9saWIvZG9tXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKHR5cGVvZiBkb2N1bWVudCA9PSBcXFwidW5kZWZpbmVkXFxcIilcXG5cXHQgICAgcmV0dXJuO1xcblxcblxcdHZhciBYSFRNTF9OUyA9IFxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXFxcIjtcXG5cXG5cXHRleHBvcnRzLmdldERvY3VtZW50SGVhZCA9IGZ1bmN0aW9uKGRvYykge1xcblxcdCAgICBpZiAoIWRvYylcXG5cXHQgICAgICAgIGRvYyA9IGRvY3VtZW50O1xcblxcdCAgICByZXR1cm4gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJoZWFkXFxcIilbMF0gfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcXG5cXHR9XFxuXFxuXFx0ZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24odGFnLCBucykge1xcblxcdCAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TID9cXG5cXHQgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucyB8fCBYSFRNTF9OUywgdGFnKSA6XFxuXFx0ICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmhhc0Nzc0NsYXNzID0gZnVuY3Rpb24oZWwsIG5hbWUpIHtcXG5cXHQgICAgdmFyIGNsYXNzZXMgPSAoZWwuY2xhc3NOYW1lIHx8IFxcXCJcXFwiKS5zcGxpdCgvXFxcXHMrL2cpO1xcblxcdCAgICByZXR1cm4gY2xhc3Nlcy5pbmRleE9mKG5hbWUpICE9PSAtMTtcXG5cXHR9O1xcblxcdGV4cG9ydHMuYWRkQ3NzQ2xhc3MgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xcblxcdCAgICBpZiAoIWV4cG9ydHMuaGFzQ3NzQ2xhc3MoZWwsIG5hbWUpKSB7XFxuXFx0ICAgICAgICBlbC5jbGFzc05hbWUgKz0gXFxcIiBcXFwiICsgbmFtZTtcXG5cXHQgICAgfVxcblxcdH07XFxuXFx0ZXhwb3J0cy5yZW1vdmVDc3NDbGFzcyA9IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XFxuXFx0ICAgIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KC9cXFxccysvZyk7XFxuXFx0ICAgIHdoaWxlICh0cnVlKSB7XFxuXFx0ICAgICAgICB2YXIgaW5kZXggPSBjbGFzc2VzLmluZGV4T2YobmFtZSk7XFxuXFx0ICAgICAgICBpZiAoaW5kZXggPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcXG5cXHQgICAgfVxcblxcdCAgICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXFxcIiBcXFwiKTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMudG9nZ2xlQ3NzQ2xhc3MgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xcblxcdCAgICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgvXFxcXHMrL2cpLCBhZGQgPSB0cnVlO1xcblxcdCAgICB3aGlsZSAodHJ1ZSkge1xcblxcdCAgICAgICAgdmFyIGluZGV4ID0gY2xhc3Nlcy5pbmRleE9mKG5hbWUpO1xcblxcdCAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XFxuXFx0ICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBhZGQgPSBmYWxzZTtcXG5cXHQgICAgICAgIGNsYXNzZXMuc3BsaWNlKGluZGV4LCAxKTtcXG5cXHQgICAgfVxcblxcdCAgICBpZihhZGQpXFxuXFx0ICAgICAgICBjbGFzc2VzLnB1c2gobmFtZSk7XFxuXFxuXFx0ICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbihcXFwiIFxcXCIpO1xcblxcdCAgICByZXR1cm4gYWRkO1xcblxcdH07XFxuXFx0ZXhwb3J0cy5zZXRDc3NDbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNsYXNzTmFtZSwgaW5jbHVkZSkge1xcblxcdCAgICBpZiAoaW5jbHVkZSkge1xcblxcdCAgICAgICAgZXhwb3J0cy5hZGRDc3NDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgZXhwb3J0cy5yZW1vdmVDc3NDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmhhc0Nzc1N0cmluZyA9IGZ1bmN0aW9uKGlkLCBkb2MpIHtcXG5cXHQgICAgdmFyIGluZGV4ID0gMCwgc2hlZXRzO1xcblxcdCAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XFxuXFxuXFx0ICAgIGlmIChkb2MuY3JlYXRlU3R5bGVTaGVldCAmJiAoc2hlZXRzID0gZG9jLnN0eWxlU2hlZXRzKSkge1xcblxcdCAgICAgICAgd2hpbGUgKGluZGV4IDwgc2hlZXRzLmxlbmd0aClcXG5cXHQgICAgICAgICAgICBpZiAoc2hlZXRzW2luZGV4KytdLm93bmluZ0VsZW1lbnQuaWQgPT09IGlkKSByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgfSBlbHNlIGlmICgoc2hlZXRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJzdHlsZVxcXCIpKSkge1xcblxcdCAgICAgICAgd2hpbGUgKGluZGV4IDwgc2hlZXRzLmxlbmd0aClcXG5cXHQgICAgICAgICAgICBpZiAoc2hlZXRzW2luZGV4KytdLmlkID09PSBpZCkgcmV0dXJuIHRydWU7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgcmV0dXJuIGZhbHNlO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5pbXBvcnRDc3NTdHJpbmcgPSBmdW5jdGlvbiBpbXBvcnRDc3NTdHJpbmcoY3NzVGV4dCwgaWQsIGRvYykge1xcblxcdCAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XFxuXFx0ICAgIGlmIChpZCAmJiBleHBvcnRzLmhhc0Nzc1N0cmluZyhpZCwgZG9jKSlcXG5cXHQgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICBcXG5cXHQgICAgdmFyIHN0eWxlO1xcblxcdCAgICBcXG5cXHQgICAgaWYgKGRvYy5jcmVhdGVTdHlsZVNoZWV0KSB7XFxuXFx0ICAgICAgICBzdHlsZSA9IGRvYy5jcmVhdGVTdHlsZVNoZWV0KCk7XFxuXFx0ICAgICAgICBzdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcXG5cXHQgICAgICAgIGlmIChpZClcXG5cXHQgICAgICAgICAgICBzdHlsZS5vd25pbmdFbGVtZW50LmlkID0gaWQ7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50TlNcXG5cXHQgICAgICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50TlMoWEhUTUxfTlMsIFxcXCJzdHlsZVxcXCIpXFxuXFx0ICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKTtcXG5cXG5cXHQgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0KSk7XFxuXFx0ICAgICAgICBpZiAoaWQpXFxuXFx0ICAgICAgICAgICAgc3R5bGUuaWQgPSBpZDtcXG5cXG5cXHQgICAgICAgIGV4cG9ydHMuZ2V0RG9jdW1lbnRIZWFkKGRvYykuYXBwZW5kQ2hpbGQoc3R5bGUpO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmltcG9ydENzc1N0eWxzaGVldCA9IGZ1bmN0aW9uKHVyaSwgZG9jKSB7XFxuXFx0ICAgIGlmIChkb2MuY3JlYXRlU3R5bGVTaGVldCkge1xcblxcdCAgICAgICAgZG9jLmNyZWF0ZVN0eWxlU2hlZXQodXJpKTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHZhciBsaW5rID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XFxuXFx0ICAgICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcXG5cXHQgICAgICAgIGxpbmsuaHJlZiA9IHVyaTtcXG5cXG5cXHQgICAgICAgIGV4cG9ydHMuZ2V0RG9jdW1lbnRIZWFkKGRvYykuYXBwZW5kQ2hpbGQobGluayk7XFxuXFx0ICAgIH1cXG5cXHR9O1xcblxcblxcdGV4cG9ydHMuZ2V0SW5uZXJXaWR0aCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcXG5cXHQgICAgcmV0dXJuIChcXG5cXHQgICAgICAgIHBhcnNlSW50KGV4cG9ydHMuY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcXFwicGFkZGluZ0xlZnRcXFwiKSwgMTApICtcXG5cXHQgICAgICAgIHBhcnNlSW50KGV4cG9ydHMuY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcXFwicGFkZGluZ1JpZ2h0XFxcIiksIDEwKSArIFxcblxcdCAgICAgICAgZWxlbWVudC5jbGllbnRXaWR0aFxcblxcdCAgICApO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5nZXRJbm5lckhlaWdodCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcXG5cXHQgICAgcmV0dXJuIChcXG5cXHQgICAgICAgIHBhcnNlSW50KGV4cG9ydHMuY29tcHV0ZWRTdHlsZShlbGVtZW50LCBcXFwicGFkZGluZ1RvcFxcXCIpLCAxMCkgK1xcblxcdCAgICAgICAgcGFyc2VJbnQoZXhwb3J0cy5jb21wdXRlZFN0eWxlKGVsZW1lbnQsIFxcXCJwYWRkaW5nQm90dG9tXFxcIiksIDEwKSArXFxuXFx0ICAgICAgICBlbGVtZW50LmNsaWVudEhlaWdodFxcblxcdCAgICApO1xcblxcdH07XFxuXFxuXFx0aWYgKHdpbmRvdy5wYWdlWU9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgIGV4cG9ydHMuZ2V0UGFnZVNjcm9sbFRvcCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgZXhwb3J0cy5nZXRQYWdlU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0ZWxzZSB7XFxuXFx0ICAgIGV4cG9ydHMuZ2V0UGFnZVNjcm9sbFRvcCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xcblxcdCAgICB9O1xcblxcblxcdCAgICBleHBvcnRzLmdldFBhZ2VTY3JvbGxMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xcblxcdCAgICB9O1xcblxcdH1cXG5cXG5cXHRpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpXFxuXFx0ICAgIGV4cG9ydHMuY29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlKSB7XFxuXFx0ICAgICAgICBpZiAoc3R5bGUpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBcXFwiXFxcIikgfHwge30pW3N0eWxlXSB8fCBcXFwiXFxcIjtcXG5cXHQgICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBcXFwiXFxcIikgfHwge307XFxuXFx0ICAgIH07XFxuXFx0ZWxzZVxcblxcdCAgICBleHBvcnRzLmNvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZSkge1xcblxcdCAgICAgICAgaWYgKHN0eWxlKVxcblxcdCAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZVtzdHlsZV07XFxuXFx0ICAgICAgICByZXR1cm4gZWxlbWVudC5jdXJyZW50U3R5bGU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ZXhwb3J0cy5zY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XFxuXFx0ICAgIHZhciBpbm5lciA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudChcXFwiYWNlX2lubmVyXFxcIik7XFxuXFx0ICAgIGlubmVyLnN0eWxlLndpZHRoID0gXFxcIjEwMCVcXFwiO1xcblxcdCAgICBpbm5lci5zdHlsZS5taW5XaWR0aCA9IFxcXCIwcHhcXFwiO1xcblxcdCAgICBpbm5lci5zdHlsZS5oZWlnaHQgPSBcXFwiMjAwcHhcXFwiO1xcblxcdCAgICBpbm5lci5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIjtcXG5cXG5cXHQgICAgdmFyIG91dGVyID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50KFxcXCJhY2Vfb3V0ZXJcXFwiKTtcXG5cXHQgICAgdmFyIHN0eWxlID0gb3V0ZXIuc3R5bGU7XFxuXFxuXFx0ICAgIHN0eWxlLnBvc2l0aW9uID0gXFxcImFic29sdXRlXFxcIjtcXG5cXHQgICAgc3R5bGUubGVmdCA9IFxcXCItMTAwMDBweFxcXCI7XFxuXFx0ICAgIHN0eWxlLm92ZXJmbG93ID0gXFxcImhpZGRlblxcXCI7XFxuXFx0ICAgIHN0eWxlLndpZHRoID0gXFxcIjIwMHB4XFxcIjtcXG5cXHQgICAgc3R5bGUubWluV2lkdGggPSBcXFwiMHB4XFxcIjtcXG5cXHQgICAgc3R5bGUuaGVpZ2h0ID0gXFxcIjE1MHB4XFxcIjtcXG5cXHQgICAgc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuXFxuXFx0ICAgIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcXG5cXG5cXHQgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFx0ICAgIGJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xcblxcblxcdCAgICB2YXIgbm9TY3JvbGxiYXIgPSBpbm5lci5vZmZzZXRXaWR0aDtcXG5cXG5cXHQgICAgc3R5bGUub3ZlcmZsb3cgPSBcXFwic2Nyb2xsXFxcIjtcXG5cXHQgICAgdmFyIHdpdGhTY3JvbGxiYXIgPSBpbm5lci5vZmZzZXRXaWR0aDtcXG5cXG5cXHQgICAgaWYgKG5vU2Nyb2xsYmFyID09IHdpdGhTY3JvbGxiYXIpIHtcXG5cXHQgICAgICAgIHdpdGhTY3JvbGxiYXIgPSBvdXRlci5jbGllbnRXaWR0aDtcXG5cXHQgICAgfVxcblxcblxcdCAgICBib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcXG5cXG5cXHQgICAgcmV0dXJuIG5vU2Nyb2xsYmFyLXdpdGhTY3JvbGxiYXI7XFxuXFx0fTtcXG5cXHRleHBvcnRzLnNldElubmVySHRtbCA9IGZ1bmN0aW9uKGVsLCBpbm5lckh0bWwpIHtcXG5cXHQgICAgdmFyIGVsZW1lbnQgPSBlbC5jbG9uZU5vZGUoZmFsc2UpOy8vZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaW5uZXJIdG1sO1xcblxcdCAgICBlbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbGVtZW50LCBlbCk7XFxuXFx0ICAgIHJldHVybiBlbGVtZW50O1xcblxcdH07XFxuXFxuXFx0aWYgKFxcXCJ0ZXh0Q29udGVudFxcXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuXFx0ICAgIGV4cG9ydHMuc2V0SW5uZXJUZXh0ID0gZnVuY3Rpb24oZWwsIGlubmVyVGV4dCkge1xcblxcdCAgICAgICAgZWwudGV4dENvbnRlbnQgPSBpbm5lclRleHQ7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIGV4cG9ydHMuZ2V0SW5uZXJUZXh0ID0gZnVuY3Rpb24oZWwpIHtcXG5cXHQgICAgICAgIHJldHVybiBlbC50ZXh0Q29udGVudDtcXG5cXHQgICAgfTtcXG5cXHR9XFxuXFx0ZWxzZSB7XFxuXFx0ICAgIGV4cG9ydHMuc2V0SW5uZXJUZXh0ID0gZnVuY3Rpb24oZWwsIGlubmVyVGV4dCkge1xcblxcdCAgICAgICAgZWwuaW5uZXJUZXh0ID0gaW5uZXJUZXh0O1xcblxcdCAgICB9O1xcblxcblxcdCAgICBleHBvcnRzLmdldElubmVyVGV4dCA9IGZ1bmN0aW9uKGVsKSB7XFxuXFx0ICAgICAgICByZXR1cm4gZWwuaW5uZXJUZXh0O1xcblxcdCAgICB9O1xcblxcdH1cXG5cXG5cXHRleHBvcnRzLmdldFBhcmVudFdpbmRvdyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XFxuXFx0ICAgIHJldHVybiBkb2N1bWVudC5kZWZhdWx0VmlldyB8fCBkb2N1bWVudC5wYXJlbnRXaW5kb3c7XFxuXFx0fTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGliL29vcFxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcXG5cXHQgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XFxuXFx0ICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XFxuXFx0ICAgICAgICBjb25zdHJ1Y3Rvcjoge1xcblxcdCAgICAgICAgICAgIHZhbHVlOiBjdG9yLFxcblxcdCAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxcblxcdCAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcblxcdCAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMubWl4aW4gPSBmdW5jdGlvbihvYmosIG1peGluKSB7XFxuXFx0ICAgIGZvciAodmFyIGtleSBpbiBtaXhpbikge1xcblxcdCAgICAgICAgb2JqW2tleV0gPSBtaXhpbltrZXldO1xcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiBvYmo7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmltcGxlbWVudCA9IGZ1bmN0aW9uKHByb3RvLCBtaXhpbikge1xcblxcdCAgICBleHBvcnRzLm1peGluKHByb3RvLCBtaXhpbik7XFxuXFx0fTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGliL2tleXNcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2ZpeG9sZGJyb3dzZXJzXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRhY2VxdWlyZShcXFwiLi9maXhvbGRicm93c2Vyc1xcXCIpO1xcblxcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi9vb3BcXFwiKTtcXG5cXHR2YXIgS2V5cyA9IChmdW5jdGlvbigpIHtcXG5cXHQgICAgdmFyIHJldCA9IHtcXG5cXHQgICAgICAgIE1PRElGSUVSX0tFWVM6IHtcXG5cXHQgICAgICAgICAgICAxNjogJ1NoaWZ0JywgMTc6ICdDdHJsJywgMTg6ICdBbHQnLCAyMjQ6ICdNZXRhJ1xcblxcdCAgICAgICAgfSxcXG5cXG5cXHQgICAgICAgIEtFWV9NT0RTOiB7XFxuXFx0ICAgICAgICAgICAgXFxcImN0cmxcXFwiOiAxLCBcXFwiYWx0XFxcIjogMiwgXFxcIm9wdGlvblxcXCIgOiAyLCBcXFwic2hpZnRcXFwiOiA0LFxcblxcdCAgICAgICAgICAgIFxcXCJzdXBlclxcXCI6IDgsIFxcXCJtZXRhXFxcIjogOCwgXFxcImNvbW1hbmRcXFwiOiA4LCBcXFwiY21kXFxcIjogOFxcblxcdCAgICAgICAgfSxcXG5cXG5cXHQgICAgICAgIEZVTkNUSU9OX0tFWVMgOiB7XFxuXFx0ICAgICAgICAgICAgOCAgOiBcXFwiQmFja3NwYWNlXFxcIixcXG5cXHQgICAgICAgICAgICA5ICA6IFxcXCJUYWJcXFwiLFxcblxcdCAgICAgICAgICAgIDEzIDogXFxcIlJldHVyblxcXCIsXFxuXFx0ICAgICAgICAgICAgMTkgOiBcXFwiUGF1c2VcXFwiLFxcblxcdCAgICAgICAgICAgIDI3IDogXFxcIkVzY1xcXCIsXFxuXFx0ICAgICAgICAgICAgMzIgOiBcXFwiU3BhY2VcXFwiLFxcblxcdCAgICAgICAgICAgIDMzIDogXFxcIlBhZ2VVcFxcXCIsXFxuXFx0ICAgICAgICAgICAgMzQgOiBcXFwiUGFnZURvd25cXFwiLFxcblxcdCAgICAgICAgICAgIDM1IDogXFxcIkVuZFxcXCIsXFxuXFx0ICAgICAgICAgICAgMzYgOiBcXFwiSG9tZVxcXCIsXFxuXFx0ICAgICAgICAgICAgMzcgOiBcXFwiTGVmdFxcXCIsXFxuXFx0ICAgICAgICAgICAgMzggOiBcXFwiVXBcXFwiLFxcblxcdCAgICAgICAgICAgIDM5IDogXFxcIlJpZ2h0XFxcIixcXG5cXHQgICAgICAgICAgICA0MCA6IFxcXCJEb3duXFxcIixcXG5cXHQgICAgICAgICAgICA0NCA6IFxcXCJQcmludFxcXCIsXFxuXFx0ICAgICAgICAgICAgNDUgOiBcXFwiSW5zZXJ0XFxcIixcXG5cXHQgICAgICAgICAgICA0NiA6IFxcXCJEZWxldGVcXFwiLFxcblxcdCAgICAgICAgICAgIDk2IDogXFxcIk51bXBhZDBcXFwiLFxcblxcdCAgICAgICAgICAgIDk3IDogXFxcIk51bXBhZDFcXFwiLFxcblxcdCAgICAgICAgICAgIDk4IDogXFxcIk51bXBhZDJcXFwiLFxcblxcdCAgICAgICAgICAgIDk5IDogXFxcIk51bXBhZDNcXFwiLFxcblxcdCAgICAgICAgICAgIDEwMDogXFxcIk51bXBhZDRcXFwiLFxcblxcdCAgICAgICAgICAgIDEwMTogXFxcIk51bXBhZDVcXFwiLFxcblxcdCAgICAgICAgICAgIDEwMjogXFxcIk51bXBhZDZcXFwiLFxcblxcdCAgICAgICAgICAgIDEwMzogXFxcIk51bXBhZDdcXFwiLFxcblxcdCAgICAgICAgICAgIDEwNDogXFxcIk51bXBhZDhcXFwiLFxcblxcdCAgICAgICAgICAgIDEwNTogXFxcIk51bXBhZDlcXFwiLFxcblxcdCAgICAgICAgICAgICctMTMnOiBcXFwiTnVtcGFkRW50ZXJcXFwiLFxcblxcdCAgICAgICAgICAgIDExMjogXFxcIkYxXFxcIixcXG5cXHQgICAgICAgICAgICAxMTM6IFxcXCJGMlxcXCIsXFxuXFx0ICAgICAgICAgICAgMTE0OiBcXFwiRjNcXFwiLFxcblxcdCAgICAgICAgICAgIDExNTogXFxcIkY0XFxcIixcXG5cXHQgICAgICAgICAgICAxMTY6IFxcXCJGNVxcXCIsXFxuXFx0ICAgICAgICAgICAgMTE3OiBcXFwiRjZcXFwiLFxcblxcdCAgICAgICAgICAgIDExODogXFxcIkY3XFxcIixcXG5cXHQgICAgICAgICAgICAxMTk6IFxcXCJGOFxcXCIsXFxuXFx0ICAgICAgICAgICAgMTIwOiBcXFwiRjlcXFwiLFxcblxcdCAgICAgICAgICAgIDEyMTogXFxcIkYxMFxcXCIsXFxuXFx0ICAgICAgICAgICAgMTIyOiBcXFwiRjExXFxcIixcXG5cXHQgICAgICAgICAgICAxMjM6IFxcXCJGMTJcXFwiLFxcblxcdCAgICAgICAgICAgIDE0NDogXFxcIk51bWxvY2tcXFwiLFxcblxcdCAgICAgICAgICAgIDE0NTogXFxcIlNjcm9sbGxvY2tcXFwiXFxuXFx0ICAgICAgICB9LFxcblxcblxcdCAgICAgICAgUFJJTlRBQkxFX0tFWVM6IHtcXG5cXHQgICAgICAgICAgIDMyOiAnICcsICA0ODogJzAnLCAgNDk6ICcxJywgIDUwOiAnMicsICA1MTogJzMnLCAgNTI6ICc0JywgNTM6ICAnNScsXFxuXFx0ICAgICAgICAgICA1NDogJzYnLCAgNTU6ICc3JywgIDU2OiAnOCcsICA1NzogJzknLCAgNTk6ICc7JywgIDYxOiAnPScsIDY1OiAgJ2EnLFxcblxcdCAgICAgICAgICAgNjY6ICdiJywgIDY3OiAnYycsICA2ODogJ2QnLCAgNjk6ICdlJywgIDcwOiAnZicsICA3MTogJ2cnLCA3MjogICdoJyxcXG5cXHQgICAgICAgICAgIDczOiAnaScsICA3NDogJ2onLCAgNzU6ICdrJywgIDc2OiAnbCcsICA3NzogJ20nLCAgNzg6ICduJywgNzk6ICAnbycsXFxuXFx0ICAgICAgICAgICA4MDogJ3AnLCAgODE6ICdxJywgIDgyOiAncicsICA4MzogJ3MnLCAgODQ6ICd0JywgIDg1OiAndScsIDg2OiAgJ3YnLFxcblxcdCAgICAgICAgICAgODc6ICd3JywgIDg4OiAneCcsICA4OTogJ3knLCAgOTA6ICd6JywgMTA3OiAnKycsIDEwOTogJy0nLCAxMTA6ICcuJyxcXG5cXHQgICAgICAgICAgMTg3OiAnPScsIDE4ODogJywnLCAxODk6ICctJywgMTkwOiAnLicsIDE5MTogJy8nLCAxOTI6ICdgJywgMjE5OiAnWycsXFxuXFx0ICAgICAgICAgIDIyMDogJ1xcXFxcXFxcJywyMjE6ICddJywgMjIyOiAnXFxcXCcnXFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHZhciBuYW1lLCBpO1xcblxcdCAgICBmb3IgKGkgaW4gcmV0LkZVTkNUSU9OX0tFWVMpIHtcXG5cXHQgICAgICAgIG5hbWUgPSByZXQuRlVOQ1RJT05fS0VZU1tpXS50b0xvd2VyQ2FzZSgpO1xcblxcdCAgICAgICAgcmV0W25hbWVdID0gcGFyc2VJbnQoaSwgMTApO1xcblxcdCAgICB9XFxuXFx0ICAgIGZvciAoaSBpbiByZXQuUFJJTlRBQkxFX0tFWVMpIHtcXG5cXHQgICAgICAgIG5hbWUgPSByZXQuUFJJTlRBQkxFX0tFWVNbaV0udG9Mb3dlckNhc2UoKTtcXG5cXHQgICAgICAgIHJldFtuYW1lXSA9IHBhcnNlSW50KGksIDEwKTtcXG5cXHQgICAgfVxcblxcdCAgICBvb3AubWl4aW4ocmV0LCByZXQuTU9ESUZJRVJfS0VZUyk7XFxuXFx0ICAgIG9vcC5taXhpbihyZXQsIHJldC5QUklOVEFCTEVfS0VZUyk7XFxuXFx0ICAgIG9vcC5taXhpbihyZXQsIHJldC5GVU5DVElPTl9LRVlTKTtcXG5cXHQgICAgcmV0LmVudGVyID0gcmV0W1xcXCJyZXR1cm5cXFwiXTtcXG5cXHQgICAgcmV0LmVzY2FwZSA9IHJldC5lc2M7XFxuXFx0ICAgIHJldC5kZWwgPSByZXRbXFxcImRlbGV0ZVxcXCJdO1xcblxcdCAgICByZXRbMTczXSA9ICctJztcXG5cXHQgICAgXFxuXFx0ICAgIChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBtb2RzID0gW1xcXCJjbWRcXFwiLCBcXFwiY3RybFxcXCIsIFxcXCJhbHRcXFwiLCBcXFwic2hpZnRcXFwiXTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSBNYXRoLnBvdygyLCBtb2RzLmxlbmd0aCk7IGktLTspIHsgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICByZXQuS0VZX01PRFNbaV0gPSBtb2RzLmZpbHRlcihmdW5jdGlvbih4KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBpICYgcmV0LktFWV9NT0RTW3hdO1xcblxcdCAgICAgICAgICAgIH0pLmpvaW4oXFxcIi1cXFwiKSArIFxcXCItXFxcIjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSkoKTtcXG5cXG5cXHQgICAgcmV0LktFWV9NT0RTWzBdID0gXFxcIlxcXCI7XFxuXFx0ICAgIHJldC5LRVlfTU9EU1stMV0gPSBcXFwiaW5wdXRcXFwiO1xcblxcblxcdCAgICByZXR1cm4gcmV0O1xcblxcdH0pKCk7XFxuXFx0b29wLm1peGluKGV4cG9ydHMsIEtleXMpO1xcblxcblxcdGV4cG9ydHMua2V5Q29kZVRvU3RyaW5nID0gZnVuY3Rpb24oa2V5Q29kZSkge1xcblxcdCAgICB2YXIga2V5U3RyaW5nID0gS2V5c1trZXlDb2RlXTtcXG5cXHQgICAgaWYgKHR5cGVvZiBrZXlTdHJpbmcgIT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0ICAgICAgICBrZXlTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpO1xcblxcdCAgICByZXR1cm4ga2V5U3RyaW5nLnRvTG93ZXJDYXNlKCk7XFxuXFx0fTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGliL3VzZXJhZ2VudFxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcdGV4cG9ydHMuT1MgPSB7XFxuXFx0ICAgIExJTlVYOiBcXFwiTElOVVhcXFwiLFxcblxcdCAgICBNQUM6IFxcXCJNQUNcXFwiLFxcblxcdCAgICBXSU5ET1dTOiBcXFwiV0lORE9XU1xcXCJcXG5cXHR9O1xcblxcdGV4cG9ydHMuZ2V0T1MgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgaWYgKGV4cG9ydHMuaXNNYWMpIHtcXG5cXHQgICAgICAgIHJldHVybiBleHBvcnRzLk9TLk1BQztcXG5cXHQgICAgfSBlbHNlIGlmIChleHBvcnRzLmlzTGludXgpIHtcXG5cXHQgICAgICAgIHJldHVybiBleHBvcnRzLk9TLkxJTlVYO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuIGV4cG9ydHMuT1MuV0lORE9XUztcXG5cXHQgICAgfVxcblxcdH07XFxuXFx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT0gXFxcIm9iamVjdFxcXCIpXFxuXFx0ICAgIHJldHVybjtcXG5cXG5cXHR2YXIgb3MgPSAobmF2aWdhdG9yLnBsYXRmb3JtLm1hdGNoKC9tYWN8d2lufGxpbnV4L2kpIHx8IFtcXFwib3RoZXJcXFwiXSlbMF0udG9Mb3dlckNhc2UoKTtcXG5cXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xcblxcdGV4cG9ydHMuaXNXaW4gPSAob3MgPT0gXFxcIndpblxcXCIpO1xcblxcdGV4cG9ydHMuaXNNYWMgPSAob3MgPT0gXFxcIm1hY1xcXCIpO1xcblxcdGV4cG9ydHMuaXNMaW51eCA9IChvcyA9PSBcXFwibGludXhcXFwiKTtcXG5cXHRleHBvcnRzLmlzSUUgPSBcXG5cXHQgICAgKG5hdmlnYXRvci5hcHBOYW1lID09IFxcXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcXFwiIHx8IG5hdmlnYXRvci5hcHBOYW1lLmluZGV4T2YoXFxcIk1TQXBwSG9zdFxcXCIpID49IDApXFxuXFx0ICAgID8gcGFyc2VGbG9hdCgodWEubWF0Y2goLyg/Ok1TSUUgfFRyaWRlbnRcXFxcL1swLTldK1tcXFxcLjAtOV0rOy4qcnY6KShbMC05XStbXFxcXC4wLTldKykvKXx8W10pWzFdKVxcblxcdCAgICA6IHBhcnNlRmxvYXQoKHVhLm1hdGNoKC8oPzpUcmlkZW50XFxcXC9bMC05XStbXFxcXC4wLTldKzsuKnJ2OikoWzAtOV0rW1xcXFwuMC05XSspLyl8fFtdKVsxXSk7IC8vIGZvciBpZVxcblxcdCAgICBcXG5cXHRleHBvcnRzLmlzT2xkSUUgPSBleHBvcnRzLmlzSUUgJiYgZXhwb3J0cy5pc0lFIDwgOTtcXG5cXHRleHBvcnRzLmlzR2Vja28gPSBleHBvcnRzLmlzTW96aWxsYSA9ICh3aW5kb3cuQ29udHJvbGxlcnMgfHwgd2luZG93LmNvbnRyb2xsZXJzKSAmJiB3aW5kb3cubmF2aWdhdG9yLnByb2R1Y3QgPT09IFxcXCJHZWNrb1xcXCI7XFxuXFx0ZXhwb3J0cy5pc09sZEdlY2tvID0gZXhwb3J0cy5pc0dlY2tvICYmIHBhcnNlSW50KCh1YS5tYXRjaCgvcnZcXFxcOihcXFxcZCspLyl8fFtdKVsxXSwgMTApIDwgNDtcXG5cXHRleHBvcnRzLmlzT3BlcmEgPSB3aW5kb3cub3BlcmEgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5vcGVyYSkgPT0gXFxcIltvYmplY3QgT3BlcmFdXFxcIjtcXG5cXHRleHBvcnRzLmlzV2ViS2l0ID0gcGFyc2VGbG9hdCh1YS5zcGxpdChcXFwiV2ViS2l0L1xcXCIpWzFdKSB8fCB1bmRlZmluZWQ7XFxuXFxuXFx0ZXhwb3J0cy5pc0Nocm9tZSA9IHBhcnNlRmxvYXQodWEuc3BsaXQoXFxcIiBDaHJvbWUvXFxcIilbMV0pIHx8IHVuZGVmaW5lZDtcXG5cXG5cXHRleHBvcnRzLmlzQUlSID0gdWEuaW5kZXhPZihcXFwiQWRvYmVBSVJcXFwiKSA+PSAwO1xcblxcblxcdGV4cG9ydHMuaXNJUGFkID0gdWEuaW5kZXhPZihcXFwiaVBhZFxcXCIpID49IDA7XFxuXFxuXFx0ZXhwb3J0cy5pc1RvdWNoUGFkID0gdWEuaW5kZXhPZihcXFwiVG91Y2hQYWRcXFwiKSA+PSAwO1xcblxcblxcdGV4cG9ydHMuaXNDaHJvbWVPUyA9IHVhLmluZGV4T2YoXFxcIiBDck9TIFxcXCIpID49IDA7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2xpYi9ldmVudFxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIva2V5c1xcXCIsXFxcImFjZS9saWIvdXNlcmFnZW50XFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIGtleXMgPSBhY2VxdWlyZShcXFwiLi9rZXlzXFxcIik7XFxuXFx0dmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFxcXCIuL3VzZXJhZ2VudFxcXCIpO1xcblxcblxcdGV4cG9ydHMuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtLCB0eXBlLCBjYWxsYmFjaykge1xcblxcdCAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XFxuXFx0ICAgICAgICByZXR1cm4gZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcXG5cXHQgICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbGVtLCB3aW5kb3cuZXZlbnQpO1xcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIGNhbGxiYWNrLl93cmFwcGVyID0gd3JhcHBlcjtcXG5cXHQgICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoXFxcIm9uXFxcIiArIHR5cGUsIHdyYXBwZXIpO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgY2FsbGJhY2spIHtcXG5cXHQgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcblxcdCAgICAgICAgcmV0dXJuIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgZmFsc2UpO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XFxuXFx0ICAgICAgICBlbGVtLmRldGFjaEV2ZW50KFxcXCJvblxcXCIgKyB0eXBlLCBjYWxsYmFjay5fd3JhcHBlciB8fCBjYWxsYmFjayk7XFxuXFx0ICAgIH1cXG5cXHR9O1xcblxcdGV4cG9ydHMuc3RvcEV2ZW50ID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICBleHBvcnRzLnN0b3BQcm9wYWdhdGlvbihlKTtcXG5cXHQgICAgZXhwb3J0cy5wcmV2ZW50RGVmYXVsdChlKTtcXG5cXHQgICAgcmV0dXJuIGZhbHNlO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbilcXG5cXHQgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0ICAgIGVsc2VcXG5cXHQgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxcblxcdCAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICBlbHNlXFxuXFx0ICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XFxuXFx0fTtcXG5cXHRleHBvcnRzLmdldEJ1dHRvbiA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgaWYgKGUudHlwZSA9PSBcXFwiZGJsY2xpY2tcXFwiKVxcblxcdCAgICAgICAgcmV0dXJuIDA7XFxuXFx0ICAgIGlmIChlLnR5cGUgPT0gXFxcImNvbnRleHRtZW51XFxcIiB8fCAodXNlcmFnZW50LmlzTWFjICYmIChlLmN0cmxLZXkgJiYgIWUuYWx0S2V5ICYmICFlLnNoaWZ0S2V5KSkpXFxuXFx0ICAgICAgICByZXR1cm4gMjtcXG5cXHQgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcXG5cXHQgICAgICAgIHJldHVybiBlLmJ1dHRvbjtcXG5cXHQgICAgfVxcblxcdCAgICBlbHNlIHtcXG5cXHQgICAgICAgIHJldHVybiB7MTowLCAyOjIsIDQ6MX1bZS5idXR0b25dO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmNhcHR1cmUgPSBmdW5jdGlvbihlbCwgZXZlbnRIYW5kbGVyLCByZWxlYXNlQ2FwdHVyZUhhbmRsZXIpIHtcXG5cXHQgICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcXG5cXHQgICAgICAgIGV2ZW50SGFuZGxlciAmJiBldmVudEhhbmRsZXIoZSk7XFxuXFx0ICAgICAgICByZWxlYXNlQ2FwdHVyZUhhbmRsZXIgJiYgcmVsZWFzZUNhcHR1cmVIYW5kbGVyKGUpO1xcblxcblxcdCAgICAgICAgZXhwb3J0cy5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIGV2ZW50SGFuZGxlciwgdHJ1ZSk7XFxuXFx0ICAgICAgICBleHBvcnRzLnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIG9uTW91c2VVcCwgdHJ1ZSk7XFxuXFx0ICAgICAgICBleHBvcnRzLnJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBcXFwiZHJhZ3N0YXJ0XFxcIiwgb25Nb3VzZVVwLCB0cnVlKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBleHBvcnRzLmFkZExpc3RlbmVyKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgZXZlbnRIYW5kbGVyLCB0cnVlKTtcXG5cXHQgICAgZXhwb3J0cy5hZGRMaXN0ZW5lcihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBvbk1vdXNlVXAsIHRydWUpO1xcblxcdCAgICBleHBvcnRzLmFkZExpc3RlbmVyKGRvY3VtZW50LCBcXFwiZHJhZ3N0YXJ0XFxcIiwgb25Nb3VzZVVwLCB0cnVlKTtcXG5cXHQgICAgXFxuXFx0ICAgIHJldHVybiBvbk1vdXNlVXA7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmFkZE1vdXNlV2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCBjYWxsYmFjaykge1xcblxcdCAgICBpZiAoXFxcIm9ubW91c2V3aGVlbFxcXCIgaW4gZWwpIHtcXG5cXHQgICAgICAgIGV4cG9ydHMuYWRkTGlzdGVuZXIoZWwsIFxcXCJtb3VzZXdoZWVsXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIHZhciBmYWN0b3IgPSA4O1xcblxcdCAgICAgICAgICAgIGlmIChlLndoZWVsRGVsdGFYICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICAgICAgICAgICAgZS53aGVlbFggPSAtZS53aGVlbERlbHRhWCAvIGZhY3RvcjtcXG5cXHQgICAgICAgICAgICAgICAgZS53aGVlbFkgPSAtZS53aGVlbERlbHRhWSAvIGZhY3RvcjtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBlLndoZWVsWCA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIGUud2hlZWxZID0gLWUud2hlZWxEZWx0YSAvIGZhY3RvcjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgY2FsbGJhY2soZSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfSBlbHNlIGlmIChcXFwib253aGVlbFxcXCIgaW4gZWwpIHtcXG5cXHQgICAgICAgIGV4cG9ydHMuYWRkTGlzdGVuZXIoZWwsIFxcXCJ3aGVlbFxcXCIsICBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZhY3RvciA9IDAuMzU7XFxuXFx0ICAgICAgICAgICAgc3dpdGNoIChlLmRlbHRhTW9kZSkge1xcblxcdCAgICAgICAgICAgICAgICBjYXNlIGUuRE9NX0RFTFRBX1BJWEVMOlxcblxcdCAgICAgICAgICAgICAgICAgICAgZS53aGVlbFggPSBlLmRlbHRhWCAqIGZhY3RvciB8fCAwO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZS53aGVlbFkgPSBlLmRlbHRhWSAqIGZhY3RvciB8fCAwO1xcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIGNhc2UgZS5ET01fREVMVEFfTElORTpcXG5cXHQgICAgICAgICAgICAgICAgY2FzZSBlLkRPTV9ERUxUQV9QQUdFOlxcblxcdCAgICAgICAgICAgICAgICAgICAgZS53aGVlbFggPSAoZS5kZWx0YVggfHwgMCkgKiA1O1xcblxcdCAgICAgICAgICAgICAgICAgICAgZS53aGVlbFkgPSAoZS5kZWx0YVkgfHwgMCkgKiA1O1xcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBleHBvcnRzLmFkZExpc3RlbmVyKGVsLCBcXFwiRE9NTW91c2VTY3JvbGxcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGUuYXhpcyAmJiBlLmF4aXMgPT0gZS5IT1JJWk9OVEFMX0FYSVMpIHtcXG5cXHQgICAgICAgICAgICAgICAgZS53aGVlbFggPSAoZS5kZXRhaWwgfHwgMCkgKiA1O1xcblxcdCAgICAgICAgICAgICAgICBlLndoZWVsWSA9IDA7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgZS53aGVlbFggPSAwO1xcblxcdCAgICAgICAgICAgICAgICBlLndoZWVsWSA9IChlLmRldGFpbCB8fCAwKSAqIDU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH1cXG5cXHR9O1xcblxcblxcdGV4cG9ydHMuYWRkTXVsdGlNb3VzZURvd25MaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCB0aW1lb3V0cywgZXZlbnRIYW5kbGVyLCBjYWxsYmFja05hbWUpIHtcXG5cXHQgICAgdmFyIGNsaWNrcyA9IDA7XFxuXFx0ICAgIHZhciBzdGFydFgsIHN0YXJ0WSwgdGltZXI7IFxcblxcdCAgICB2YXIgZXZlbnROYW1lcyA9IHtcXG5cXHQgICAgICAgIDI6IFxcXCJkYmxjbGlja1xcXCIsXFxuXFx0ICAgICAgICAzOiBcXFwidHJpcGxlY2xpY2tcXFwiLFxcblxcdCAgICAgICAgNDogXFxcInF1YWRjbGlja1xcXCJcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgZXhwb3J0cy5hZGRMaXN0ZW5lcihlbCwgXFxcIm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmIChleHBvcnRzLmdldEJ1dHRvbihlKSAhPT0gMCkge1xcblxcdCAgICAgICAgICAgIGNsaWNrcyA9IDA7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGUuZGV0YWlsID4gMSkge1xcblxcdCAgICAgICAgICAgIGNsaWNrcysrO1xcblxcdCAgICAgICAgICAgIGlmIChjbGlja3MgPiA0KVxcblxcdCAgICAgICAgICAgICAgICBjbGlja3MgPSAxO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBjbGlja3MgPSAxO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKHVzZXJhZ2VudC5pc0lFKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGlzTmV3Q2xpY2sgPSBNYXRoLmFicyhlLmNsaWVudFggLSBzdGFydFgpID4gNSB8fCBNYXRoLmFicyhlLmNsaWVudFkgLSBzdGFydFkpID4gNTtcXG5cXHQgICAgICAgICAgICBpZiAoIXRpbWVyIHx8IGlzTmV3Q2xpY2spXFxuXFx0ICAgICAgICAgICAgICAgIGNsaWNrcyA9IDE7XFxuXFx0ICAgICAgICAgICAgaWYgKHRpbWVyKVxcblxcdCAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcblxcdCAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHt0aW1lciA9IG51bGx9LCB0aW1lb3V0c1tjbGlja3MgLSAxXSB8fCA2MDApO1xcblxcblxcdCAgICAgICAgICAgIGlmIChjbGlja3MgPT0gMSkge1xcblxcdCAgICAgICAgICAgICAgICBzdGFydFggPSBlLmNsaWVudFg7XFxuXFx0ICAgICAgICAgICAgICAgIHN0YXJ0WSA9IGUuY2xpZW50WTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGUuX2NsaWNrcyA9IGNsaWNrcztcXG5cXG5cXHQgICAgICAgIGV2ZW50SGFuZGxlcltjYWxsYmFja05hbWVdKFxcXCJtb3VzZWRvd25cXFwiLCBlKTtcXG5cXG5cXHQgICAgICAgIGlmIChjbGlja3MgPiA0KVxcblxcdCAgICAgICAgICAgIGNsaWNrcyA9IDA7XFxuXFx0ICAgICAgICBlbHNlIGlmIChjbGlja3MgPiAxKVxcblxcdCAgICAgICAgICAgIHJldHVybiBldmVudEhhbmRsZXJbY2FsbGJhY2tOYW1lXShldmVudE5hbWVzW2NsaWNrc10sIGUpO1xcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgaWYgKHVzZXJhZ2VudC5pc09sZElFKSB7XFxuXFx0ICAgICAgICBleHBvcnRzLmFkZExpc3RlbmVyKGVsLCBcXFwiZGJsY2xpY2tcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgY2xpY2tzID0gMjtcXG5cXHQgICAgICAgICAgICBpZiAodGltZXIpXFxuXFx0ICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuXFx0ICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge3RpbWVyID0gbnVsbH0sIHRpbWVvdXRzW2NsaWNrcyAtIDFdIHx8IDYwMCk7XFxuXFx0ICAgICAgICAgICAgZXZlbnRIYW5kbGVyW2NhbGxiYWNrTmFtZV0oXFxcIm1vdXNlZG93blxcXCIsIGUpO1xcblxcdCAgICAgICAgICAgIGV2ZW50SGFuZGxlcltjYWxsYmFja05hbWVdKGV2ZW50TmFtZXNbY2xpY2tzXSwgZSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdH07XFxuXFxuXFx0dmFyIGdldE1vZGlmaWVySGFzaCA9IHVzZXJhZ2VudC5pc01hYyAmJiB1c2VyYWdlbnQuaXNPcGVyYSAmJiAhKFxcXCJLZXlib2FyZEV2ZW50XFxcIiBpbiB3aW5kb3cpXFxuXFx0ICAgID8gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgcmV0dXJuIDAgfCAoZS5tZXRhS2V5ID8gMSA6IDApIHwgKGUuYWx0S2V5ID8gMiA6IDApIHwgKGUuc2hpZnRLZXkgPyA0IDogMCkgfCAoZS5jdHJsS2V5ID8gOCA6IDApO1xcblxcdCAgICB9XFxuXFx0ICAgIDogZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgcmV0dXJuIDAgfCAoZS5jdHJsS2V5ID8gMSA6IDApIHwgKGUuYWx0S2V5ID8gMiA6IDApIHwgKGUuc2hpZnRLZXkgPyA0IDogMCkgfCAoZS5tZXRhS2V5ID8gOCA6IDApO1xcblxcdCAgICB9O1xcblxcblxcdGV4cG9ydHMuZ2V0TW9kaWZpZXJTdHJpbmcgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgIHJldHVybiBrZXlzLktFWV9NT0RTW2dldE1vZGlmaWVySGFzaChlKV07XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBub3JtYWxpemVDb21tYW5kS2V5cyhjYWxsYmFjaywgZSwga2V5Q29kZSkge1xcblxcdCAgICB2YXIgaGFzaElkID0gZ2V0TW9kaWZpZXJIYXNoKGUpO1xcblxcblxcdCAgICBpZiAoIXVzZXJhZ2VudC5pc01hYyAmJiBwcmVzc2VkS2V5cykge1xcblxcdCAgICAgICAgaWYgKHByZXNzZWRLZXlzWzkxXSB8fCBwcmVzc2VkS2V5c1s5Ml0pXFxuXFx0ICAgICAgICAgICAgaGFzaElkIHw9IDg7XFxuXFx0ICAgICAgICBpZiAocHJlc3NlZEtleXMuYWx0R3IpIHtcXG5cXHQgICAgICAgICAgICBpZiAoKDMgJiBoYXNoSWQpICE9IDMpXFxuXFx0ICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmFsdEdyID0gMDtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChrZXlDb2RlID09PSAxOCB8fCBrZXlDb2RlID09PSAxNykge1xcblxcdCAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IFxcXCJsb2NhdGlvblxcXCIgaW4gZSA/IGUubG9jYXRpb24gOiBlLmtleUxvY2F0aW9uO1xcblxcdCAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSAxNyAmJiBsb2NhdGlvbiA9PT0gMSkge1xcblxcdCAgICAgICAgICAgICAgICB0cyA9IGUudGltZVN0YW1wO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gMTggJiYgaGFzaElkID09PSAzICYmIGxvY2F0aW9uID09PSAyKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBkdCA9IC10cztcXG5cXHQgICAgICAgICAgICAgICAgdHMgPSBlLnRpbWVTdGFtcDtcXG5cXHQgICAgICAgICAgICAgICAgZHQgKz0gdHM7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChkdCA8IDMpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5hbHRHciA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoa2V5Q29kZSBpbiBrZXlzLk1PRElGSUVSX0tFWVMpIHtcXG5cXHQgICAgICAgIHN3aXRjaCAoa2V5cy5NT0RJRklFUl9LRVlTW2tleUNvZGVdKSB7XFxuXFx0ICAgICAgICAgICAgY2FzZSBcXFwiQWx0XFxcIjpcXG5cXHQgICAgICAgICAgICAgICAgaGFzaElkID0gMjtcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgY2FzZSBcXFwiU2hpZnRcXFwiOlxcblxcdCAgICAgICAgICAgICAgICBoYXNoSWQgPSA0O1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICBjYXNlIFxcXCJDdHJsXFxcIjpcXG5cXHQgICAgICAgICAgICAgICAgaGFzaElkID0gMTtcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgZGVmYXVsdDpcXG5cXHQgICAgICAgICAgICAgICAgaGFzaElkID0gODtcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBrZXlDb2RlID0gLTE7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKGhhc2hJZCAmIDggJiYgKGtleUNvZGUgPT09IDkxIHx8IGtleUNvZGUgPT09IDkzKSkge1xcblxcdCAgICAgICAga2V5Q29kZSA9IC0xO1xcblxcdCAgICB9XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoIWhhc2hJZCAmJiBrZXlDb2RlID09PSAxMykge1xcblxcdCAgICAgICAgdmFyIGxvY2F0aW9uID0gXFxcImxvY2F0aW9uXFxcIiBpbiBlID8gZS5sb2NhdGlvbiA6IGUua2V5TG9jYXRpb247XFxuXFx0ICAgICAgICBpZiAobG9jYXRpb24gPT09IDMpIHtcXG5cXHQgICAgICAgICAgICBjYWxsYmFjayhlLCBoYXNoSWQsIC1rZXlDb2RlKTtcXG5cXHQgICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgXFxuXFx0ICAgIGlmICh1c2VyYWdlbnQuaXNDaHJvbWVPUyAmJiBoYXNoSWQgJiA4KSB7XFxuXFx0ICAgICAgICBjYWxsYmFjayhlLCBoYXNoSWQsIGtleUNvZGUpO1xcblxcdCAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZClcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgaGFzaElkICY9IH44O1xcblxcdCAgICB9XFxuXFx0ICAgIGlmICghaGFzaElkICYmICEoa2V5Q29kZSBpbiBrZXlzLkZVTkNUSU9OX0tFWVMpICYmICEoa2V5Q29kZSBpbiBrZXlzLlBSSU5UQUJMRV9LRVlTKSkge1xcblxcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICB9XFxuXFx0ICAgIFxcblxcdCAgICByZXR1cm4gY2FsbGJhY2soZSwgaGFzaElkLCBrZXlDb2RlKTtcXG5cXHR9XFxuXFxuXFx0dmFyIHByZXNzZWRLZXlzID0gbnVsbDtcXG5cXHR2YXIgdHMgPSAwO1xcblxcdGV4cG9ydHMuYWRkQ29tbWFuZEtleUxpc3RlbmVyID0gZnVuY3Rpb24oZWwsIGNhbGxiYWNrKSB7XFxuXFx0ICAgIHZhciBhZGRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkTGlzdGVuZXI7XFxuXFx0ICAgIGlmICh1c2VyYWdlbnQuaXNPbGRHZWNrbyB8fCAodXNlcmFnZW50LmlzT3BlcmEgJiYgIShcXFwiS2V5Ym9hcmRFdmVudFxcXCIgaW4gd2luZG93KSkpIHtcXG5cXHQgICAgICAgIHZhciBsYXN0S2V5RG93bktleUNvZGUgPSBudWxsO1xcblxcdCAgICAgICAgYWRkTGlzdGVuZXIoZWwsIFxcXCJrZXlkb3duXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIGxhc3RLZXlEb3duS2V5Q29kZSA9IGUua2V5Q29kZTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgYWRkTGlzdGVuZXIoZWwsIFxcXCJrZXlwcmVzc1xcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplQ29tbWFuZEtleXMoY2FsbGJhY2ssIGUsIGxhc3RLZXlEb3duS2V5Q29kZSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHZhciBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IG51bGw7XFxuXFxuXFx0ICAgICAgICBhZGRMaXN0ZW5lcihlbCwgXFxcImtleWRvd25cXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgcHJlc3NlZEtleXNbZS5rZXlDb2RlXSA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5vcm1hbGl6ZUNvbW1hbmRLZXlzKGNhbGxiYWNrLCBlLCBlLmtleUNvZGUpO1xcblxcdCAgICAgICAgICAgIGxhc3REZWZhdWx0UHJldmVudGVkID0gZS5kZWZhdWx0UHJldmVudGVkO1xcblxcdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIGFkZExpc3RlbmVyKGVsLCBcXFwia2V5cHJlc3NcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGxhc3REZWZhdWx0UHJldmVudGVkICYmIChlLmN0cmxLZXkgfHwgZS5hbHRLZXkgfHwgZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGV4cG9ydHMuc3RvcEV2ZW50KGUpO1xcblxcdCAgICAgICAgICAgICAgICBsYXN0RGVmYXVsdFByZXZlbnRlZCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICBhZGRMaXN0ZW5lcihlbCwgXFxcImtleXVwXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIHByZXNzZWRLZXlzW2Uua2V5Q29kZV0gPSBudWxsO1xcblxcdCAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICBpZiAoIXByZXNzZWRLZXlzKSB7XFxuXFx0ICAgICAgICAgICAgcHJlc3NlZEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcblxcdCAgICAgICAgICAgIGFkZExpc3RlbmVyKHdpbmRvdywgXFxcImZvY3VzXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXHR9O1xcblxcblxcdGlmICh3aW5kb3cucG9zdE1lc3NhZ2UgJiYgIXVzZXJhZ2VudC5pc09sZElFKSB7XFxuXFx0ICAgIHZhciBwb3N0TWVzc2FnZUlkID0gMTtcXG5cXHQgICAgZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB3aW4pIHtcXG5cXHQgICAgICAgIHdpbiA9IHdpbiB8fCB3aW5kb3c7XFxuXFx0ICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBcXFwiemVyby10aW1lb3V0LW1lc3NhZ2UtXFxcIiArIHBvc3RNZXNzYWdlSWQ7XFxuXFx0ICAgICAgICBleHBvcnRzLmFkZExpc3RlbmVyKHdpbiwgXFxcIm1lc3NhZ2VcXFwiLCBmdW5jdGlvbiBsaXN0ZW5lcihlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGUuZGF0YSA9PSBtZXNzYWdlTmFtZSkge1xcblxcdCAgICAgICAgICAgICAgICBleHBvcnRzLnN0b3BQcm9wYWdhdGlvbihlKTtcXG5cXHQgICAgICAgICAgICAgICAgZXhwb3J0cy5yZW1vdmVMaXN0ZW5lcih3aW4sIFxcXCJtZXNzYWdlXFxcIiwgbGlzdGVuZXIpO1xcblxcdCAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgd2luLnBvc3RNZXNzYWdlKG1lc3NhZ2VOYW1lLCBcXFwiKlxcXCIpO1xcblxcdCAgICB9O1xcblxcdH1cXG5cXG5cXG5cXHRleHBvcnRzLm5leHRGcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcXG5cXHQgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxcblxcdCAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XFxuXFx0ICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxcblxcdCAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZTtcXG5cXG5cXHRpZiAoZXhwb3J0cy5uZXh0RnJhbWUpXFxuXFx0ICAgIGV4cG9ydHMubmV4dEZyYW1lID0gZXhwb3J0cy5uZXh0RnJhbWUuYmluZCh3aW5kb3cpO1xcblxcdGVsc2VcXG5cXHQgICAgZXhwb3J0cy5uZXh0RnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xcblxcdCAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTcpO1xcblxcdCAgICB9O1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9saWIvbGFuZ1xcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGEpIHtcXG5cXHQgICAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMuc3RyaW5nUmV2ZXJzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xcblxcdCAgICByZXR1cm4gc3RyaW5nLnNwbGl0KFxcXCJcXFwiKS5yZXZlcnNlKCkuam9pbihcXFwiXFxcIik7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLnN0cmluZ1JlcGVhdCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNvdW50KSB7XFxuXFx0ICAgIHZhciByZXN1bHQgPSAnJztcXG5cXHQgICAgd2hpbGUgKGNvdW50ID4gMCkge1xcblxcdCAgICAgICAgaWYgKGNvdW50ICYgMSlcXG5cXHQgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xcblxcblxcdCAgICAgICAgaWYgKGNvdW50ID4+PSAxKVxcblxcdCAgICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XFxuXFx0ICAgIH1cXG5cXHQgICAgcmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcblxcdHZhciB0cmltQmVnaW5SZWdleHAgPSAvXlxcXFxzXFxcXHMqLztcXG5cXHR2YXIgdHJpbUVuZFJlZ2V4cCA9IC9cXFxcc1xcXFxzKiQvO1xcblxcblxcdGV4cG9ydHMuc3RyaW5nVHJpbUxlZnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XFxuXFx0ICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMuc3RyaW5nVHJpbVJpZ2h0ID0gZnVuY3Rpb24gKHN0cmluZykge1xcblxcdCAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5jb3B5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XFxuXFx0ICAgIHZhciBjb3B5ID0ge307XFxuXFx0ICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG5cXHQgICAgICAgIGNvcHlba2V5XSA9IG9ialtrZXldO1xcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiBjb3B5O1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5jb3B5QXJyYXkgPSBmdW5jdGlvbihhcnJheSl7XFxuXFx0ICAgIHZhciBjb3B5ID0gW107XFxuXFx0ICAgIGZvciAodmFyIGk9MCwgbD1hcnJheS5sZW5ndGg7IGk8bDsgaSsrKSB7XFxuXFx0ICAgICAgICBpZiAoYXJyYXlbaV0gJiYgdHlwZW9mIGFycmF5W2ldID09IFxcXCJvYmplY3RcXFwiKVxcblxcdCAgICAgICAgICAgIGNvcHlbaV0gPSB0aGlzLmNvcHlPYmplY3QoIGFycmF5W2ldICk7XFxuXFx0ICAgICAgICBlbHNlIFxcblxcdCAgICAgICAgICAgIGNvcHlbaV0gPSBhcnJheVtpXTtcXG5cXHQgICAgfVxcblxcdCAgICByZXR1cm4gY29weTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMuZGVlcENvcHkgPSBmdW5jdGlvbiAob2JqKSB7XFxuXFx0ICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcXFwib2JqZWN0XFxcIiB8fCAhb2JqKVxcblxcdCAgICAgICAgcmV0dXJuIG9iajtcXG5cXHQgICAgdmFyIGNvbnMgPSBvYmouY29uc3RydWN0b3I7XFxuXFx0ICAgIGlmIChjb25zID09PSBSZWdFeHApXFxuXFx0ICAgICAgICByZXR1cm4gb2JqO1xcblxcdCAgICBcXG5cXHQgICAgdmFyIGNvcHkgPSBjb25zKCk7XFxuXFx0ICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG5cXHQgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgY29weVtrZXldID0gZXhwb3J0cy5kZWVwQ29weShvYmpba2V5XSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGNvcHlba2V5XSA9IG9ialtrZXldO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiBjb3B5O1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5hcnJheVRvTWFwID0gZnVuY3Rpb24oYXJyKSB7XFxuXFx0ICAgIHZhciBtYXAgPSB7fTtcXG5cXHQgICAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgbWFwW2FycltpXV0gPSAxO1xcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiBtYXA7XFxuXFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmNyZWF0ZU1hcCA9IGZ1bmN0aW9uKHByb3BzKSB7XFxuXFx0ICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcblxcdCAgICBmb3IgKHZhciBpIGluIHByb3BzKSB7XFxuXFx0ICAgICAgICBtYXBbaV0gPSBwcm9wc1tpXTtcXG5cXHQgICAgfVxcblxcdCAgICByZXR1cm4gbWFwO1xcblxcdH07XFxuXFx0ZXhwb3J0cy5hcnJheVJlbW92ZSA9IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPD0gYXJyYXkubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgaWYgKHZhbHVlID09PSBhcnJheVtpXSkge1xcblxcdCAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5lc2NhcGVSZWdFeHAgPSBmdW5jdGlvbihzdHIpIHtcXG5cXHQgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4qKz9eJHt9KCl8W1xcXFxdXFxcXC9cXFxcXFxcXF0pL2csICdcXFxcXFxcXCQxJyk7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmVzY2FwZUhUTUwgPSBmdW5jdGlvbihzdHIpIHtcXG5cXHQgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mL2csIFxcXCImIzM4O1xcXCIpLnJlcGxhY2UoL1xcXCIvZywgXFxcIiYjMzQ7XFxcIikucmVwbGFjZSgvJy9nLCBcXFwiJiMzOTtcXFwiKS5yZXBsYWNlKC88L2csIFxcXCImIzYwO1xcXCIpO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5nZXRNYXRjaE9mZnNldHMgPSBmdW5jdGlvbihzdHJpbmcsIHJlZ0V4cCkge1xcblxcdCAgICB2YXIgbWF0Y2hlcyA9IFtdO1xcblxcblxcdCAgICBzdHJpbmcucmVwbGFjZShyZWdFeHAsIGZ1bmN0aW9uKHN0cikge1xcblxcdCAgICAgICAgbWF0Y2hlcy5wdXNoKHtcXG5cXHQgICAgICAgICAgICBvZmZzZXQ6IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTJdLFxcblxcdCAgICAgICAgICAgIGxlbmd0aDogc3RyLmxlbmd0aFxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICByZXR1cm4gbWF0Y2hlcztcXG5cXHR9O1xcblxcdGV4cG9ydHMuZGVmZXJyZWRDYWxsID0gZnVuY3Rpb24oZmNuKSB7XFxuXFx0ICAgIHZhciB0aW1lciA9IG51bGw7XFxuXFx0ICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGltZXIgPSBudWxsO1xcblxcdCAgICAgICAgZmNuKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHZhciBkZWZlcnJlZCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcXG5cXHQgICAgICAgIGRlZmVycmVkLmNhbmNlbCgpO1xcblxcdCAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0IHx8IDApO1xcblxcdCAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcblxcdCAgICB9O1xcblxcblxcdCAgICBkZWZlcnJlZC5zY2hlZHVsZSA9IGRlZmVycmVkO1xcblxcblxcdCAgICBkZWZlcnJlZC5jYWxsID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLmNhbmNlbCgpO1xcblxcdCAgICAgICAgZmNuKCk7XFxuXFx0ICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIGRlZmVycmVkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG5cXHQgICAgICAgIHRpbWVyID0gbnVsbDtcXG5cXHQgICAgICAgIHJldHVybiBkZWZlcnJlZDtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIGRlZmVycmVkLmlzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRpbWVyO1xcblxcdCAgICB9O1xcblxcblxcdCAgICByZXR1cm4gZGVmZXJyZWQ7XFxuXFx0fTtcXG5cXG5cXG5cXHRleHBvcnRzLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZmNuLCBkZWZhdWx0VGltZW91dCkge1xcblxcdCAgICB2YXIgdGltZXIgPSBudWxsO1xcblxcdCAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRpbWVyID0gbnVsbDtcXG5cXHQgICAgICAgIGZjbigpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB2YXIgX3NlbGYgPSBmdW5jdGlvbih0aW1lb3V0KSB7XFxuXFx0ICAgICAgICBpZiAodGltZXIgPT0gbnVsbClcXG5cXHQgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgZGVmYXVsdFRpbWVvdXQpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICBfc2VsZi5kZWxheSA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcXG5cXHQgICAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XFxuXFx0ICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQgfHwgZGVmYXVsdFRpbWVvdXQpO1xcblxcdCAgICB9O1xcblxcdCAgICBfc2VsZi5zY2hlZHVsZSA9IF9zZWxmO1xcblxcblxcdCAgICBfc2VsZi5jYWxsID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLmNhbmNlbCgpO1xcblxcdCAgICAgICAgZmNuKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIF9zZWxmLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG5cXHQgICAgICAgIHRpbWVyID0gbnVsbDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgX3NlbGYuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGltZXI7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHJldHVybiBfc2VsZjtcXG5cXHR9O1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2V2ZW50XFxcIixcXFwiYWNlL2xpYi91c2VyYWdlbnRcXFwiLFxcXCJhY2UvbGliL2RvbVxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRcXFwiKTtcXG5cXHR2YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi91c2VyYWdlbnRcXFwiKTtcXG5cXHR2YXIgZG9tID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9kb21cXFwiKTtcXG5cXHR2YXIgbGFuZyA9IGFjZXF1aXJlKFxcXCIuLi9saWIvbGFuZ1xcXCIpO1xcblxcdHZhciBCUk9LRU5fU0VUREFUQSA9IHVzZXJhZ2VudC5pc0Nocm9tZSA8IDE4O1xcblxcdHZhciBVU0VfSUVfTUlNRV9UWVBFID0gIHVzZXJhZ2VudC5pc0lFO1xcblxcblxcdHZhciBUZXh0SW5wdXQgPSBmdW5jdGlvbihwYXJlbnROb2RlLCBob3N0KSB7XFxuXFx0ICAgIHZhciB0ZXh0ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcInRleHRhcmVhXFxcIik7XFxuXFx0ICAgIHRleHQuY2xhc3NOYW1lID0gXFxcImFjZV90ZXh0LWlucHV0XFxcIjtcXG5cXG5cXHQgICAgaWYgKHVzZXJhZ2VudC5pc1RvdWNoUGFkKVxcblxcdCAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoXFxcIngtcGFsbS1kaXNhYmxlLWF1dG8tY2FwXFxcIiwgdHJ1ZSk7XFxuXFxuXFx0ICAgIHRleHQud3JhcCA9IFxcXCJvZmZcXFwiO1xcblxcdCAgICB0ZXh0LmF1dG9jb3JyZWN0ID0gXFxcIm9mZlxcXCI7XFxuXFx0ICAgIHRleHQuYXV0b2NhcGl0YWxpemUgPSBcXFwib2ZmXFxcIjtcXG5cXHQgICAgdGV4dC5zcGVsbGNoZWNrID0gZmFsc2U7XFxuXFxuXFx0ICAgIHRleHQuc3R5bGUub3BhY2l0eSA9IFxcXCIwXFxcIjtcXG5cXHQgICAgaWYgKHVzZXJhZ2VudC5pc09sZElFKSB0ZXh0LnN0eWxlLnRvcCA9IFxcXCItMTAwcHhcXFwiO1xcblxcdCAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0LCBwYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xcblxcblxcdCAgICB2YXIgUExBQ0VIT0xERVIgPSBcXFwiXFxcXHgwMVxcXFx4MDFcXFwiO1xcblxcblxcdCAgICB2YXIgY29waWVkID0gZmFsc2U7XFxuXFx0ICAgIHZhciBwYXN0ZWQgPSBmYWxzZTtcXG5cXHQgICAgdmFyIGluQ29tcG9zaXRpb24gPSBmYWxzZTtcXG5cXHQgICAgdmFyIHRlbXBTdHlsZSA9ICcnO1xcblxcdCAgICB2YXIgaXNTZWxlY3Rpb25FbXB0eSA9IHRydWU7XFxuXFx0ICAgIHRyeSB7IHZhciBpc0ZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0ZXh0OyB9IGNhdGNoKGUpIHt9XFxuXFx0ICAgIFxcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcXFwiYmx1clxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGhvc3Qub25CbHVyKGUpO1xcblxcdCAgICAgICAgaXNGb2N1c2VkID0gZmFsc2U7XFxuXFx0ICAgIH0pO1xcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcXFwiZm9jdXNcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpc0ZvY3VzZWQgPSB0cnVlO1xcblxcdCAgICAgICAgaG9zdC5vbkZvY3VzKGUpO1xcblxcdCAgICAgICAgcmVzZXRTZWxlY3Rpb24oKTtcXG5cXHQgICAgfSk7XFxuXFx0ICAgIHRoaXMuZm9jdXMgPSBmdW5jdGlvbigpIHsgdGV4dC5mb2N1cygpOyB9O1xcblxcdCAgICB0aGlzLmJsdXIgPSBmdW5jdGlvbigpIHsgdGV4dC5ibHVyKCk7IH07XFxuXFx0ICAgIHRoaXMuaXNGb2N1c2VkID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gaXNGb2N1c2VkO1xcblxcdCAgICB9O1xcblxcdCAgICB2YXIgc3luY1NlbGVjdGlvbiA9IGxhbmcuZGVsYXllZENhbGwoZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpc0ZvY3VzZWQgJiYgcmVzZXRTZWxlY3Rpb24oaXNTZWxlY3Rpb25FbXB0eSk7XFxuXFx0ICAgIH0pO1xcblxcdCAgICB2YXIgc3luY1ZhbHVlID0gbGFuZy5kZWxheWVkQ2FsbChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICBpZiAoIWluQ29tcG9zaXRpb24pIHtcXG5cXHQgICAgICAgICAgICB0ZXh0LnZhbHVlID0gUExBQ0VIT0xERVI7XFxuXFx0ICAgICAgICAgICAgaXNGb2N1c2VkICYmIHJlc2V0U2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgZnVuY3Rpb24gcmVzZXRTZWxlY3Rpb24oaXNFbXB0eSkge1xcblxcdCAgICAgICAgaWYgKGluQ29tcG9zaXRpb24pXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgaWYgKGlucHV0SGFuZGxlcikge1xcblxcdCAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gMDtcXG5cXHQgICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBpc0VtcHR5ID8gMCA6IHRleHQudmFsdWUubGVuZ3RoIC0gMTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gaXNFbXB0eSA/IDIgOiAxO1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSAyO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdHJ5IHtcXG5cXHQgICAgICAgICAgICB0ZXh0LnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xcblxcdCAgICAgICAgfSBjYXRjaChlKXt9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gcmVzZXRWYWx1ZSgpIHtcXG5cXHQgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHRleHQudmFsdWUgPSBQTEFDRUhPTERFUjtcXG5cXHQgICAgICAgIGlmICh1c2VyYWdlbnQuaXNXZWJLaXQpXFxuXFx0ICAgICAgICAgICAgc3luY1ZhbHVlLnNjaGVkdWxlKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgdXNlcmFnZW50LmlzV2ViS2l0IHx8IGhvc3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlU2VsZWN0aW9uJywgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoaG9zdC5zZWxlY3Rpb24uaXNFbXB0eSgpICE9IGlzU2VsZWN0aW9uRW1wdHkpIHtcXG5cXHQgICAgICAgICAgICBpc1NlbGVjdGlvbkVtcHR5ID0gIWlzU2VsZWN0aW9uRW1wdHk7XFxuXFx0ICAgICAgICAgICAgc3luY1NlbGVjdGlvbi5zY2hlZHVsZSgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgcmVzZXRWYWx1ZSgpO1xcblxcdCAgICBpZiAoaXNGb2N1c2VkKVxcblxcdCAgICAgICAgaG9zdC5vbkZvY3VzKCk7XFxuXFxuXFxuXFx0ICAgIHZhciBpc0FsbFNlbGVjdGVkID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRleHQuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGV4dC5zZWxlY3Rpb25FbmQgPT09IHRleHQudmFsdWUubGVuZ3RoO1xcblxcdCAgICB9O1xcblxcdCAgICBpZiAoIXRleHQuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgdGV4dC5jcmVhdGVUZXh0UmFuZ2UpIHtcXG5cXHQgICAgICAgIHRleHQuc2V0U2VsZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5jcmVhdGVUZXh0UmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcXG5cXHQgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHNlbGVjdGlvblN0YXJ0KTtcXG5cXHQgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBzZWxlY3Rpb25FbmQpO1xcblxcdCAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIGlzQWxsU2VsZWN0ZWQgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICAgICAgdHJ5IHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGV4dC5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIH1jYXRjaChlKSB7fVxcblxcdCAgICAgICAgICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRleHQpIHJldHVybiBmYWxzZTtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnRleHQgPT0gdGV4dC52YWx1ZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBpZiAodXNlcmFnZW50LmlzT2xkSUUpIHtcXG5cXHQgICAgICAgIHZhciBpblByb3BlcnR5Q2hhbmdlID0gZmFsc2U7XFxuXFx0ICAgICAgICB2YXIgb25Qcm9wZXJ0eUNoYW5nZSA9IGZ1bmN0aW9uKGUpe1xcblxcdCAgICAgICAgICAgIGlmIChpblByb3BlcnR5Q2hhbmdlKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0ZXh0LnZhbHVlO1xcblxcdCAgICAgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uIHx8ICFkYXRhIHx8IGRhdGEgPT0gUExBQ0VIT0xERVIpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICBpZiAoZSAmJiBkYXRhID09IFBMQUNFSE9MREVSWzBdKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gc3luY1Byb3BlcnR5LnNjaGVkdWxlKCk7XFxuXFxuXFx0ICAgICAgICAgICAgc2VuZFRleHQoZGF0YSk7XFxuXFx0ICAgICAgICAgICAgaW5Qcm9wZXJ0eUNoYW5nZSA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgcmVzZXRWYWx1ZSgpO1xcblxcdCAgICAgICAgICAgIGluUHJvcGVydHlDaGFuZ2UgPSBmYWxzZTtcXG5cXHQgICAgICAgIH07XFxuXFx0ICAgICAgICB2YXIgc3luY1Byb3BlcnR5ID0gbGFuZy5kZWxheWVkQ2FsbChvblByb3BlcnR5Q2hhbmdlKTtcXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFxcXCJwcm9wZXJ0eWNoYW5nZVxcXCIsIG9uUHJvcGVydHlDaGFuZ2UpO1xcblxcblxcdCAgICAgICAgdmFyIGtleXRhYmxlID0geyAxMzoxLCAyNzoxIH07XFxuXFx0ICAgICAgICBldmVudC5hZGRMaXN0ZW5lcih0ZXh0LCBcXFwia2V5dXBcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdCAgICAgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uICYmICghdGV4dC52YWx1ZSB8fCBrZXl0YWJsZVtlLmtleUNvZGVdKSlcXG5cXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChvbkNvbXBvc2l0aW9uRW5kLCAwKTtcXG5cXHQgICAgICAgICAgICBpZiAoKHRleHQudmFsdWUuY2hhckNvZGVBdCgwKXx8MCkgPCAxMjkpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQcm9wZXJ0eS5jYWxsKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGluQ29tcG9zaXRpb24gPyBvbkNvbXBvc2l0aW9uVXBkYXRlKCkgOiBvbkNvbXBvc2l0aW9uU3RhcnQoKTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcImtleWRvd25cXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdCAgICAgICAgICAgIHN5bmNQcm9wZXJ0eS5zY2hlZHVsZSg1MCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB2YXIgb25TZWxlY3QgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAoY29waWVkKSB7XFxuXFx0ICAgICAgICAgICAgY29waWVkID0gZmFsc2U7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGlzQWxsU2VsZWN0ZWQodGV4dCkpIHtcXG5cXHQgICAgICAgICAgICBob3N0LnNlbGVjdEFsbCgpO1xcblxcdCAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGlucHV0SGFuZGxlcikge1xcblxcdCAgICAgICAgICAgIHJlc2V0U2VsZWN0aW9uKGhvc3Quc2VsZWN0aW9uLmlzRW1wdHkoKSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHZhciBpbnB1dEhhbmRsZXIgPSBudWxsO1xcblxcdCAgICB0aGlzLnNldElucHV0SGFuZGxlciA9IGZ1bmN0aW9uKGNiKSB7aW5wdXRIYW5kbGVyID0gY2J9O1xcblxcdCAgICB0aGlzLmdldElucHV0SGFuZGxlciA9IGZ1bmN0aW9uKCkge3JldHVybiBpbnB1dEhhbmRsZXJ9O1xcblxcdCAgICB2YXIgYWZ0ZXJDb250ZXh0TWVudSA9IGZhbHNlO1xcblxcdCAgICBcXG5cXHQgICAgdmFyIHNlbmRUZXh0ID0gZnVuY3Rpb24oZGF0YSkge1xcblxcdCAgICAgICAgaWYgKGlucHV0SGFuZGxlcikge1xcblxcdCAgICAgICAgICAgIGRhdGEgPSBpbnB1dEhhbmRsZXIoZGF0YSk7XFxuXFx0ICAgICAgICAgICAgaW5wdXRIYW5kbGVyID0gbnVsbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChwYXN0ZWQpIHtcXG5cXHQgICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgICAgIGlmIChkYXRhKVxcblxcdCAgICAgICAgICAgICAgICBob3N0Lm9uUGFzdGUoZGF0YSk7XFxuXFx0ICAgICAgICAgICAgcGFzdGVkID0gZmFsc2U7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gUExBQ0VIT0xERVIuY2hhckF0KDApKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGFmdGVyQ29udGV4dE1lbnUpXFxuXFx0ICAgICAgICAgICAgICAgIGhvc3QuZXhlY0NvbW1hbmQoXFxcImRlbFxcXCIsIHtzb3VyY2U6IFxcXCJhY2VcXFwifSk7XFxuXFx0ICAgICAgICAgICAgZWxzZSAvLyBzb21lIHZlcnNpb25zIG9mIGFuZHJvaWQgZG8gbm90IGZpcmUga2V5ZG93biB3aGVuIHByZXNzaW5nIGJhY2tzcGFjZVxcblxcdCAgICAgICAgICAgICAgICBob3N0LmV4ZWNDb21tYW5kKFxcXCJiYWNrc3BhY2VcXFwiLCB7c291cmNlOiBcXFwiYWNlXFxcIn0pO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBpZiAoZGF0YS5zdWJzdHJpbmcoMCwgMikgPT0gUExBQ0VIT0xERVIpXFxuXFx0ICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnN1YnN0cigyKTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChkYXRhLmNoYXJBdCgwKSA9PSBQTEFDRUhPTERFUi5jaGFyQXQoMCkpXFxuXFx0ICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnN1YnN0cigxKTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09IFBMQUNFSE9MREVSLmNoYXJBdCgwKSlcXG5cXHQgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpO1xcblxcdCAgICAgICAgICAgIGlmIChkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09IFBMQUNFSE9MREVSLmNoYXJBdCgwKSlcXG5cXHQgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgLTEpO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGlmIChkYXRhKVxcblxcdCAgICAgICAgICAgICAgICBob3N0Lm9uVGV4dElucHV0KGRhdGEpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKGFmdGVyQ29udGV4dE1lbnUpXFxuXFx0ICAgICAgICAgICAgYWZ0ZXJDb250ZXh0TWVudSA9IGZhbHNlO1xcblxcdCAgICB9O1xcblxcdCAgICB2YXIgb25JbnB1dCA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBkYXRhID0gdGV4dC52YWx1ZTtcXG5cXHQgICAgICAgIHNlbmRUZXh0KGRhdGEpO1xcblxcdCAgICAgICAgcmVzZXRWYWx1ZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdmFyIGhhbmRsZUNsaXBib2FyZERhdGEgPSBmdW5jdGlvbihlLCBkYXRhKSB7XFxuXFx0ICAgICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcXG5cXHQgICAgICAgIGlmICghY2xpcGJvYXJkRGF0YSB8fCBCUk9LRU5fU0VUREFUQSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgbWltZSA9IFVTRV9JRV9NSU1FX1RZUEUgPyBcXFwiVGV4dFxcXCIgOiBcXFwidGV4dC9wbGFpblxcXCI7XFxuXFx0ICAgICAgICBpZiAoZGF0YSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBjbGlwYm9hcmREYXRhLnNldERhdGEobWltZSwgZGF0YSkgIT09IGZhbHNlO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gY2xpcGJvYXJkRGF0YS5nZXREYXRhKG1pbWUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB2YXIgZG9Db3B5ID0gZnVuY3Rpb24oZSwgaXNDdXQpIHtcXG5cXHQgICAgICAgIHZhciBkYXRhID0gaG9zdC5nZXRDb3B5VGV4dCgpO1xcblxcdCAgICAgICAgaWYgKCFkYXRhKVxcblxcdCAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcXG5cXG5cXHQgICAgICAgIGlmIChoYW5kbGVDbGlwYm9hcmREYXRhKGUsIGRhdGEpKSB7XFxuXFx0ICAgICAgICAgICAgaXNDdXQgPyBob3N0Lm9uQ3V0KCkgOiBob3N0Lm9uQ29weSgpO1xcblxcdCAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBjb3BpZWQgPSB0cnVlO1xcblxcdCAgICAgICAgICAgIHRleHQudmFsdWUgPSBkYXRhO1xcblxcdCAgICAgICAgICAgIHRleHQuc2VsZWN0KCk7XFxuXFx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xcblxcdCAgICAgICAgICAgICAgICBjb3BpZWQgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICAgICAgcmVzZXRWYWx1ZSgpO1xcblxcdCAgICAgICAgICAgICAgICByZXNldFNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgICAgICAgICBpc0N1dCA/IGhvc3Qub25DdXQoKSA6IGhvc3Qub25Db3B5KCk7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB2YXIgb25DdXQgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBkb0NvcHkoZSwgdHJ1ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB2YXIgb25Db3B5ID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgZG9Db3B5KGUsIGZhbHNlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHZhciBvblBhc3RlID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGRhdGEgPSBoYW5kbGVDbGlwYm9hcmREYXRhKGUpO1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGRhdGEpXFxuXFx0ICAgICAgICAgICAgICAgIGhvc3Qub25QYXN0ZShkYXRhKTtcXG5cXHQgICAgICAgICAgICBpZiAodXNlcmFnZW50LmlzSUUpXFxuXFx0ICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzZXRTZWxlY3Rpb24pO1xcblxcdCAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdGV4dC52YWx1ZSA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgICAgIHBhc3RlZCA9IHRydWU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIGV2ZW50LmFkZENvbW1hbmRLZXlMaXN0ZW5lcih0ZXh0LCBob3N0Lm9uQ29tbWFuZEtleS5iaW5kKGhvc3QpKTtcXG5cXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcInNlbGVjdFxcXCIsIG9uU2VsZWN0KTtcXG5cXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcImlucHV0XFxcIiwgb25JbnB1dCk7XFxuXFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFxcXCJjdXRcXFwiLCBvbkN1dCk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFxcXCJjb3B5XFxcIiwgb25Db3B5KTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcInBhc3RlXFxcIiwgb25QYXN0ZSk7XFxuXFx0ICAgIGlmICghKCdvbmN1dCcgaW4gdGV4dCkgfHwgISgnb25jb3B5JyBpbiB0ZXh0KSB8fCAhKCdvbnBhc3RlJyBpbiB0ZXh0KSl7XFxuXFx0ICAgICAgICBldmVudC5hZGRMaXN0ZW5lcihwYXJlbnROb2RlLCBcXFwia2V5ZG93blxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgICAgICBpZiAoKHVzZXJhZ2VudC5pc01hYyAmJiAhZS5tZXRhS2V5KSB8fCAhZS5jdHJsS2V5KVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgY2FzZSA2NzpcXG5cXHQgICAgICAgICAgICAgICAgICAgIG9uQ29weShlKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICBjYXNlIDg2OlxcblxcdCAgICAgICAgICAgICAgICAgICAgb25QYXN0ZShlKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICBjYXNlIDg4OlxcblxcdCAgICAgICAgICAgICAgICAgICAgb25DdXQoZSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfVxcblxcdCAgICB2YXIgb25Db21wb3NpdGlvblN0YXJ0ID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgaWYgKGluQ29tcG9zaXRpb24gfHwgIWhvc3Qub25Db21wb3NpdGlvblN0YXJ0IHx8IGhvc3QuJHJlYWRPbmx5KSBcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBpbkNvbXBvc2l0aW9uID0ge307XFxuXFx0ICAgICAgICBob3N0Lm9uQ29tcG9zaXRpb25TdGFydCgpO1xcblxcdCAgICAgICAgc2V0VGltZW91dChvbkNvbXBvc2l0aW9uVXBkYXRlLCAwKTtcXG5cXHQgICAgICAgIGhvc3Qub24oXFxcIm1vdXNlZG93blxcXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xcblxcdCAgICAgICAgaWYgKCFob3N0LnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcXG5cXHQgICAgICAgICAgICBob3N0Lmluc2VydChcXFwiXFxcIik7XFxuXFx0ICAgICAgICAgICAgaG9zdC5zZXNzaW9uLm1hcmtVbmRvR3JvdXAoKTtcXG5cXHQgICAgICAgICAgICBob3N0LnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaG9zdC5zZXNzaW9uLm1hcmtVbmRvR3JvdXAoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdmFyIG9uQ29tcG9zaXRpb25VcGRhdGUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICghaW5Db21wb3NpdGlvbiB8fCAhaG9zdC5vbkNvbXBvc2l0aW9uVXBkYXRlIHx8IGhvc3QuJHJlYWRPbmx5KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciB2YWwgPSB0ZXh0LnZhbHVlLnJlcGxhY2UoL1xcXFx4MDEvZywgXFxcIlxcXCIpO1xcblxcdCAgICAgICAgaWYgKGluQ29tcG9zaXRpb24ubGFzdFZhbHVlID09PSB2YWwpIHJldHVybjtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaG9zdC5vbkNvbXBvc2l0aW9uVXBkYXRlKHZhbCk7XFxuXFx0ICAgICAgICBpZiAoaW5Db21wb3NpdGlvbi5sYXN0VmFsdWUpXFxuXFx0ICAgICAgICAgICAgaG9zdC51bmRvKCk7XFxuXFx0ICAgICAgICBpbkNvbXBvc2l0aW9uLmxhc3RWYWx1ZSA9IHZhbDtcXG5cXHQgICAgICAgIGlmIChpbkNvbXBvc2l0aW9uLmxhc3RWYWx1ZSkge1xcblxcdCAgICAgICAgICAgIHZhciByID0gaG9zdC5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICBob3N0Lmluc2VydChpbkNvbXBvc2l0aW9uLmxhc3RWYWx1ZSk7XFxuXFx0ICAgICAgICAgICAgaG9zdC5zZXNzaW9uLm1hcmtVbmRvR3JvdXAoKTtcXG5cXHQgICAgICAgICAgICBpbkNvbXBvc2l0aW9uLnJhbmdlID0gaG9zdC5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICBob3N0LnNlbGVjdGlvbi5zZXRSYW5nZShyKTtcXG5cXHQgICAgICAgICAgICBob3N0LnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB2YXIgb25Db21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmICghaG9zdC5vbkNvbXBvc2l0aW9uRW5kIHx8IGhvc3QuJHJlYWRPbmx5KSByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgYyA9IGluQ29tcG9zaXRpb247XFxuXFx0ICAgICAgICBpbkNvbXBvc2l0aW9uID0gZmFsc2U7XFxuXFx0ICAgICAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcXG5cXHQgICAgICAgICAgICB2YXIgc3RyID0gdGV4dC52YWx1ZS5yZXBsYWNlKC9cXFxceDAxL2csIFxcXCJcXFwiKTtcXG5cXHQgICAgICAgICAgICBpZiAoaW5Db21wb3NpdGlvbilcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKHN0ciA9PSBjLmxhc3RWYWx1ZSlcXG5cXHQgICAgICAgICAgICAgICAgcmVzZXRWYWx1ZSgpO1xcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKCFjLmxhc3RWYWx1ZSAmJiBzdHIpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmVzZXRWYWx1ZSgpO1xcblxcdCAgICAgICAgICAgICAgICBzZW5kVGV4dChzdHIpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gY29tcG9zaXRpb25JbnB1dEhhbmRsZXIoc3RyKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRpbWVyKVxcblxcdCAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcblxcdCAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXFxceDAxL2csIFxcXCJcXFwiKTtcXG5cXHQgICAgICAgICAgICBpZiAoc3RyID09IGMubGFzdFZhbHVlKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlxcXCI7XFxuXFx0ICAgICAgICAgICAgaWYgKGMubGFzdFZhbHVlICYmIHRpbWVyKVxcblxcdCAgICAgICAgICAgICAgICBob3N0LnVuZG8oKTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gc3RyO1xcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIGhvc3Qub25Db21wb3NpdGlvbkVuZCgpO1xcblxcdCAgICAgICAgaG9zdC5yZW1vdmVMaXN0ZW5lcihcXFwibW91c2Vkb3duXFxcIiwgb25Db21wb3NpdGlvbkVuZCk7XFxuXFx0ICAgICAgICBpZiAoZS50eXBlID09IFxcXCJjb21wb3NpdGlvbmVuZFxcXCIgJiYgYy5yYW5nZSkge1xcblxcdCAgICAgICAgICAgIGhvc3Quc2VsZWN0aW9uLnNldFJhbmdlKGMucmFuZ2UpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgXFxuXFxuXFx0ICAgIHZhciBzeW5jQ29tcG9zaXRpb24gPSBsYW5nLmRlbGF5ZWRDYWxsKG9uQ29tcG9zaXRpb25VcGRhdGUsIDUwKTtcXG5cXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcImNvbXBvc2l0aW9uc3RhcnRcXFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xcblxcdCAgICBpZiAodXNlcmFnZW50LmlzR2Vja28pIHtcXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFxcXCJ0ZXh0XFxcIiwgZnVuY3Rpb24oKXtzeW5jQ29tcG9zaXRpb24uc2NoZWR1bGUoKX0pO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcImtleXVwXFxcIiwgZnVuY3Rpb24oKXtzeW5jQ29tcG9zaXRpb24uc2NoZWR1bGUoKX0pO1xcblxcdCAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcImtleWRvd25cXFwiLCBmdW5jdGlvbigpe3N5bmNDb21wb3NpdGlvbi5zY2hlZHVsZSgpfSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIodGV4dCwgXFxcImNvbXBvc2l0aW9uZW5kXFxcIiwgb25Db21wb3NpdGlvbkVuZCk7XFxuXFxuXFx0ICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRleHQ7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0UmVhZE9ubHkgPSBmdW5jdGlvbihyZWFkT25seSkge1xcblxcdCAgICAgICB0ZXh0LnJlYWRPbmx5ID0gcmVhZE9ubHk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGFmdGVyQ29udGV4dE1lbnUgPSB0cnVlO1xcblxcdCAgICAgICAgcmVzZXRTZWxlY3Rpb24oaG9zdC5zZWxlY3Rpb24uaXNFbXB0eSgpKTtcXG5cXHQgICAgICAgIGhvc3QuX2VtaXQoXFxcIm5hdGl2ZWNvbnRleHRtZW51XFxcIiwge3RhcmdldDogaG9zdCwgZG9tRXZlbnQ6IGV9KTtcXG5cXHQgICAgICAgIHRoaXMubW92ZVRvTW91c2UoZSwgdHJ1ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLm1vdmVUb01vdXNlID0gZnVuY3Rpb24oZSwgYnJpbmdUb0Zyb250KSB7XFxuXFx0ICAgICAgICBpZiAoIWJyaW5nVG9Gcm9udCAmJiB1c2VyYWdlbnQuaXNPbGRJRSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBpZiAoIXRlbXBTdHlsZSlcXG5cXHQgICAgICAgICAgICB0ZW1wU3R5bGUgPSB0ZXh0LnN0eWxlLmNzc1RleHQ7XFxuXFx0ICAgICAgICB0ZXh0LnN0eWxlLmNzc1RleHQgPSAoYnJpbmdUb0Zyb250ID8gXFxcInotaW5kZXg6MTAwMDAwO1xcXCIgOiBcXFwiXFxcIilcXG5cXHQgICAgICAgICAgICArIFxcXCJoZWlnaHQ6XFxcIiArIHRleHQuc3R5bGUuaGVpZ2h0ICsgXFxcIjtcXFwiXFxuXFx0ICAgICAgICAgICAgKyAodXNlcmFnZW50LmlzSUUgPyBcXFwib3BhY2l0eTowLjE7XFxcIiA6IFxcXCJcXFwiKTtcXG5cXG5cXHQgICAgICAgIHZhciByZWN0ID0gaG9zdC5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0ICAgICAgICB2YXIgc3R5bGUgPSBkb20uY29tcHV0ZWRTdHlsZShob3N0LmNvbnRhaW5lcik7XFxuXFx0ICAgICAgICB2YXIgdG9wID0gcmVjdC50b3AgKyAocGFyc2VJbnQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDApO1xcblxcdCAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyAocGFyc2VJbnQocmVjdC5ib3JkZXJMZWZ0V2lkdGgpIHx8IDApO1xcblxcdCAgICAgICAgdmFyIG1heFRvcCA9IHJlY3QuYm90dG9tIC0gdG9wIC0gdGV4dC5jbGllbnRIZWlnaHQgLTI7XFxuXFx0ICAgICAgICB2YXIgbW92ZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgICAgICB0ZXh0LnN0eWxlLmxlZnQgPSBlLmNsaWVudFggLSBsZWZ0IC0gMiArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgdGV4dC5zdHlsZS50b3AgPSBNYXRoLm1pbihlLmNsaWVudFkgLSB0b3AgLSAyLCBtYXhUb3ApICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgIH07IFxcblxcdCAgICAgICAgbW92ZShlKTtcXG5cXG5cXHQgICAgICAgIGlmIChlLnR5cGUgIT0gXFxcIm1vdXNlZG93blxcXCIpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgaWYgKGhvc3QucmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yKVxcblxcdCAgICAgICAgICAgIGhvc3QucmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID0gbnVsbDtcXG5cXHQgICAgICAgIGlmICh1c2VyYWdlbnQuaXNXaW4gJiYgIXVzZXJhZ2VudC5pc09sZElFKVxcblxcdCAgICAgICAgICAgIGV2ZW50LmNhcHR1cmUoaG9zdC5jb250YWluZXIsIG1vdmUsIG9uQ29udGV4dE1lbnVDbG9zZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Db250ZXh0TWVudUNsb3NlID0gb25Db250ZXh0TWVudUNsb3NlO1xcblxcdCAgICB2YXIgY2xvc2VUaW1lb3V0O1xcblxcdCAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51Q2xvc2UoKSB7XFxuXFx0ICAgICAgICBjbGVhclRpbWVvdXQoY2xvc2VUaW1lb3V0KVxcblxcdCAgICAgICAgY2xvc2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRlbXBTdHlsZSkge1xcblxcdCAgICAgICAgICAgICAgICB0ZXh0LnN0eWxlLmNzc1RleHQgPSB0ZW1wU3R5bGU7XFxuXFx0ICAgICAgICAgICAgICAgIHRlbXBTdHlsZSA9ICcnO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpZiAoaG9zdC5yZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgICAgICBob3N0LnJlbmRlcmVyLiRrZWVwVGV4dEFyZWFBdEN1cnNvciA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgICAgIGhvc3QucmVuZGVyZXIuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSwgdXNlcmFnZW50LmlzT2xkSUUgPyAyMDAgOiAwKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB2YXIgb25Db250ZXh0TWVudSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGhvc3QudGV4dElucHV0Lm9uQ29udGV4dE1lbnUoZSk7XFxuXFx0ICAgICAgICBvbkNvbnRleHRNZW51Q2xvc2UoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIoaG9zdC5yZW5kZXJlci5zY3JvbGxlciwgXFxcImNvbnRleHRtZW51XFxcIiwgb25Db250ZXh0TWVudSk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKHRleHQsIFxcXCJjb250ZXh0bWVudVxcXCIsIG9uQ29udGV4dE1lbnUpO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5UZXh0SW5wdXQgPSBUZXh0SW5wdXQ7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL21vdXNlL2RlZmF1bHRfaGFuZGxlcnNcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2RvbVxcXCIsXFxcImFjZS9saWIvZXZlbnRcXFwiLFxcXCJhY2UvbGliL3VzZXJhZ2VudFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRcXFwiKTtcXG5cXHR2YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi91c2VyYWdlbnRcXFwiKTtcXG5cXG5cXHR2YXIgRFJBR19PRkZTRVQgPSAwOyAvLyBwaXhlbHNcXG5cXG5cXHRmdW5jdGlvbiBEZWZhdWx0SGFuZGxlcnMobW91c2VIYW5kbGVyKSB7XFxuXFx0ICAgIG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gPSBudWxsO1xcblxcblxcdCAgICB2YXIgZWRpdG9yID0gbW91c2VIYW5kbGVyLmVkaXRvcjtcXG5cXHQgICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFxcXCJtb3VzZWRvd25cXFwiLCB0aGlzLm9uTW91c2VEb3duLmJpbmQobW91c2VIYW5kbGVyKSk7XFxuXFx0ICAgIGVkaXRvci5zZXREZWZhdWx0SGFuZGxlcihcXFwiZGJsY2xpY2tcXFwiLCB0aGlzLm9uRG91YmxlQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXHQgICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFxcXCJ0cmlwbGVjbGlja1xcXCIsIHRoaXMub25UcmlwbGVDbGljay5iaW5kKG1vdXNlSGFuZGxlcikpO1xcblxcdCAgICBlZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXFxcInF1YWRjbGlja1xcXCIsIHRoaXMub25RdWFkQ2xpY2suYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXHQgICAgZWRpdG9yLnNldERlZmF1bHRIYW5kbGVyKFxcXCJtb3VzZXdoZWVsXFxcIiwgdGhpcy5vbk1vdXNlV2hlZWwuYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXG5cXHQgICAgdmFyIGV4cG9ydHMgPSBbXFxcInNlbGVjdFxcXCIsIFxcXCJzdGFydFNlbGVjdFxcXCIsIFxcXCJzZWxlY3RFbmRcXFwiLCBcXFwic2VsZWN0QWxsRW5kXFxcIiwgXFxcInNlbGVjdEJ5V29yZHNFbmRcXFwiLFxcblxcdCAgICAgICAgXFxcInNlbGVjdEJ5TGluZXNFbmRcXFwiLCBcXFwiZHJhZ1dhaXRcXFwiLCBcXFwiZHJhZ1dhaXRFbmRcXFwiLCBcXFwiZm9jdXNXYWl0XFxcIl07XFxuXFxuXFx0ICAgIGV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbih4KSB7XFxuXFx0ICAgICAgICBtb3VzZUhhbmRsZXJbeF0gPSB0aGlzW3hdO1xcblxcdCAgICB9LCB0aGlzKTtcXG5cXG5cXHQgICAgbW91c2VIYW5kbGVyLnNlbGVjdEJ5TGluZXMgPSB0aGlzLmV4dGVuZFNlbGVjdGlvbkJ5LmJpbmQobW91c2VIYW5kbGVyLCBcXFwiZ2V0TGluZVJhbmdlXFxcIik7XFxuXFx0ICAgIG1vdXNlSGFuZGxlci5zZWxlY3RCeVdvcmRzID0gdGhpcy5leHRlbmRTZWxlY3Rpb25CeS5iaW5kKG1vdXNlSGFuZGxlciwgXFxcImdldFdvcmRSYW5nZVxcXCIpO1xcblxcdH1cXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIHRoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbihldikge1xcblxcdCAgICAgICAgdmFyIGluU2VsZWN0aW9uID0gZXYuaW5TZWxlY3Rpb24oKTtcXG5cXHQgICAgICAgIHZhciBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XFxuXFx0ICAgICAgICB0aGlzLm1vdXNlZG93bkV2ZW50ID0gZXY7XFxuXFx0ICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XFxuXFxuXFx0ICAgICAgICB2YXIgYnV0dG9uID0gZXYuZ2V0QnV0dG9uKCk7XFxuXFx0ICAgICAgICBpZiAoYnV0dG9uICE9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkVtcHR5ID0gc2VsZWN0aW9uUmFuZ2UuaXNFbXB0eSgpO1xcblxcblxcdCAgICAgICAgICAgIGlmIChzZWxlY3Rpb25FbXB0eSlcXG5cXHQgICAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xcblxcdCAgICAgICAgICAgIGVkaXRvci50ZXh0SW5wdXQub25Db250ZXh0TWVudShldi5kb21FdmVudCk7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuOyAvLyBzdG9wcGluZyBldmVudCBoZXJlIGJyZWFrcyBjb250ZXh0bWVudSBvbiBmZiBtYWNcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA9IERhdGUubm93KCk7XFxuXFx0ICAgICAgICBpZiAoaW5TZWxlY3Rpb24gJiYgIWVkaXRvci5pc0ZvY3VzZWQoKSkge1xcblxcdCAgICAgICAgICAgIGVkaXRvci5mb2N1cygpO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiRmb2N1c1RpbW91dCAmJiAhdGhpcy4kY2xpY2tTZWxlY3Rpb24gJiYgIWVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKFxcXCJmb2N1c1dhaXRcXFwiKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZXYpO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZXYpO1xcblxcdCAgICAgICAgdGhpcy5zdGFydFNlbGVjdChwb3MsIGV2LmRvbUV2ZW50Ll9jbGlja3MgPiAxKTtcXG5cXHQgICAgICAgIHJldHVybiBldi5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnN0YXJ0U2VsZWN0ID0gZnVuY3Rpb24ocG9zLCB3YWl0Rm9yQ2xpY2tTZWxlY3Rpb24pIHtcXG5cXHQgICAgICAgIHBvcyA9IHBvcyB8fCB0aGlzLmVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyh0aGlzLngsIHRoaXMueSk7XFxuXFx0ICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmICh0aGlzLm1vdXNlZG93bkV2ZW50LmdldFNoaWZ0S2V5KCkpXFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RUb1Bvc2l0aW9uKHBvcyk7XFxuXFx0ICAgICAgICBlbHNlIGlmICghd2FpdEZvckNsaWNrU2VsZWN0aW9uKVxcblxcdCAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcXG5cXHQgICAgICAgIGlmICghd2FpdEZvckNsaWNrU2VsZWN0aW9uKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XFxuXFx0ICAgICAgICBpZiAoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLnNldENhcHR1cmUpIHtcXG5cXHQgICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsZXIuc2V0Q2FwdHVyZSgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWRpdG9yLnNldFN0eWxlKFxcXCJhY2Vfc2VsZWN0aW5nXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLnNldFN0YXRlKFxcXCJzZWxlY3RcXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zZWxlY3QgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBhbmNob3IsIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xcblxcdCAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyh0aGlzLngsIHRoaXMueSk7XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy4kY2xpY2tTZWxlY3Rpb24pIHtcXG5cXHQgICAgICAgICAgICB2YXIgY21wID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uY29tcGFyZVBvaW50KGN1cnNvcik7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5lbmQ7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT0gMSkge1xcblxcdCAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5zdGFydDtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWRSYW5nZSA9IGNhbGNSYW5nZU9yaWVudGF0aW9uKHRoaXMuJGNsaWNrU2VsZWN0aW9uLCBjdXJzb3IpO1xcblxcdCAgICAgICAgICAgICAgICBjdXJzb3IgPSBvcmllbnRlZFJhbmdlLmN1cnNvcjtcXG5cXHQgICAgICAgICAgICAgICAgYW5jaG9yID0gb3JpZW50ZWRSYW5nZS5hbmNob3I7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uQW5jaG9yKGFuY2hvci5yb3csIGFuY2hvci5jb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RUb1Bvc2l0aW9uKGN1cnNvcik7XFxuXFxuXFx0ICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5leHRlbmRTZWxlY3Rpb25CeSA9IGZ1bmN0aW9uKHVuaXROYW1lKSB7XFxuXFx0ICAgICAgICB2YXIgYW5jaG9yLCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcXG5cXHQgICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXModGhpcy54LCB0aGlzLnkpO1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvblt1bml0TmFtZV0oY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy4kY2xpY2tTZWxlY3Rpb24pIHtcXG5cXHQgICAgICAgICAgICB2YXIgY21wU3RhcnQgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5jb21wYXJlUG9pbnQocmFuZ2Uuc3RhcnQpO1xcblxcdCAgICAgICAgICAgIHZhciBjbXBFbmQgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5jb21wYXJlUG9pbnQocmFuZ2UuZW5kKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoY21wU3RhcnQgPT0gLTEgJiYgY21wRW5kIDw9IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgYW5jaG9yID0gdGhpcy4kY2xpY2tTZWxlY3Rpb24uZW5kO1xcblxcdCAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kLnJvdyAhPSBjdXJzb3Iucm93IHx8IHJhbmdlLmVuZC5jb2x1bW4gIT0gY3Vyc29yLmNvbHVtbilcXG5cXHQgICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IHJhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wRW5kID09IDEgJiYgY21wU3RhcnQgPj0gMCkge1xcblxcdCAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLiRjbGlja1NlbGVjdGlvbi5zdGFydDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyAhPSBjdXJzb3Iucm93IHx8IHJhbmdlLnN0YXJ0LmNvbHVtbiAhPSBjdXJzb3IuY29sdW1uKVxcblxcdCAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gcmFuZ2UuZW5kO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wU3RhcnQgPT0gLTEgJiYgY21wRW5kID09IDEpIHtcXG5cXHQgICAgICAgICAgICAgICAgY3Vyc29yID0gcmFuZ2UuZW5kO1xcblxcdCAgICAgICAgICAgICAgICBhbmNob3IgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWRSYW5nZSA9IGNhbGNSYW5nZU9yaWVudGF0aW9uKHRoaXMuJGNsaWNrU2VsZWN0aW9uLCBjdXJzb3IpO1xcblxcdCAgICAgICAgICAgICAgICBjdXJzb3IgPSBvcmllbnRlZFJhbmdlLmN1cnNvcjtcXG5cXHQgICAgICAgICAgICAgICAgYW5jaG9yID0gb3JpZW50ZWRSYW5nZS5hbmNob3I7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uQW5jaG9yKGFuY2hvci5yb3csIGFuY2hvci5jb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RUb1Bvc2l0aW9uKGN1cnNvcik7XFxuXFxuXFx0ICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zZWxlY3RFbmQgPVxcblxcdCAgICB0aGlzLnNlbGVjdEFsbEVuZCA9XFxuXFx0ICAgIHRoaXMuc2VsZWN0QnlXb3Jkc0VuZCA9XFxuXFx0ICAgIHRoaXMuc2VsZWN0QnlMaW5lc0VuZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBudWxsO1xcblxcdCAgICAgICAgdGhpcy5lZGl0b3IudW5zZXRTdHlsZShcXFwiYWNlX3NlbGVjdGluZ1xcXCIpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLnJlbGVhc2VDYXB0dXJlKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVuZGVyZXIuc2Nyb2xsZXIucmVsZWFzZUNhcHR1cmUoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5mb2N1c1dhaXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZSh0aGlzLm1vdXNlZG93bkV2ZW50LngsIHRoaXMubW91c2Vkb3duRXZlbnQueSwgdGhpcy54LCB0aGlzLnkpO1xcblxcdCAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xcblxcblxcdCAgICAgICAgaWYgKGRpc3RhbmNlID4gRFJBR19PRkZTRVQgfHwgdGltZSAtIHRoaXMubW91c2Vkb3duRXZlbnQudGltZSA+IHRoaXMuJGZvY3VzVGltb3V0KVxcblxcdCAgICAgICAgICAgIHRoaXMuc3RhcnRTZWxlY3QodGhpcy5tb3VzZWRvd25FdmVudC5nZXREb2N1bWVudFBvc2l0aW9uKCkpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihldikge1xcblxcdCAgICAgICAgdmFyIHBvcyA9IGV2LmdldERvY3VtZW50UG9zaXRpb24oKTtcXG5cXHQgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gZWRpdG9yLnNlc3Npb247XFxuXFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBzZXNzaW9uLmdldEJyYWNrZXRSYW5nZShwb3MpO1xcblxcdCAgICAgICAgaWYgKHJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4tLTtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbisrO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB0aGlzLnNldFN0YXRlKFxcXCJzZWxlY3RcXFwiKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFdvcmRSYW5nZShwb3Mucm93LCBwb3MuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNldFN0YXRlKFxcXCJzZWxlY3RCeVdvcmRzXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLiRjbGlja1NlbGVjdGlvbiA9IHJhbmdlO1xcblxcdCAgICAgICAgdGhpcy5zZWxlY3QoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vblRyaXBsZUNsaWNrID0gZnVuY3Rpb24oZXYpIHtcXG5cXHQgICAgICAgIHZhciBwb3MgPSBldi5nZXREb2N1bWVudFBvc2l0aW9uKCk7XFxuXFx0ICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNldFN0YXRlKFxcXCJzZWxlY3RCeUxpbmVzXFxcIik7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIGlmIChyYW5nZS5pc011bHRpTGluZSgpICYmIHJhbmdlLmNvbnRhaW5zKHBvcy5yb3csIHBvcy5jb2x1bW4pKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShyYW5nZS5zdGFydC5yb3cpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJGNsaWNrU2VsZWN0aW9uLmVuZCA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0TGluZVJhbmdlKHJhbmdlLmVuZC5yb3cpLmVuZDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShwb3Mucm93KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0KCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25RdWFkQ2xpY2sgPSBmdW5jdGlvbihldikge1xcblxcdCAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xcblxcblxcdCAgICAgICAgZWRpdG9yLnNlbGVjdEFsbCgpO1xcblxcdCAgICAgICAgdGhpcy4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIHRoaXMuc2V0U3RhdGUoXFxcInNlbGVjdEFsbFxcXCIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uTW91c2VXaGVlbCA9IGZ1bmN0aW9uKGV2KSB7XFxuXFx0ICAgICAgICBpZiAoZXYuZ2V0QWNjZWxLZXkoKSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBpZiAoZXYuZ2V0U2hpZnRLZXkoKSAmJiBldi53aGVlbFkgJiYgIWV2LndoZWVsWCkge1xcblxcdCAgICAgICAgICAgIGV2LndoZWVsWCA9IGV2LndoZWVsWTtcXG5cXHQgICAgICAgICAgICBldi53aGVlbFkgPSAwO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIHQgPSBldi5kb21FdmVudC50aW1lU3RhbXA7XFxuXFx0ICAgICAgICB2YXIgZHQgPSB0IC0gKHRoaXMuJGxhc3RTY3JvbGxUaW1lfHwwKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xcblxcdCAgICAgICAgdmFyIGlzU2Nyb2xhYmxlID0gZWRpdG9yLnJlbmRlcmVyLmlzU2Nyb2xsYWJsZUJ5KGV2LndoZWVsWCAqIGV2LnNwZWVkLCBldi53aGVlbFkgKiBldi5zcGVlZCk7XFxuXFx0ICAgICAgICBpZiAoaXNTY3JvbGFibGUgfHwgZHQgPCAyMDApIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRsYXN0U2Nyb2xsVGltZSA9IHQ7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJ5KGV2LndoZWVsWCAqIGV2LnNwZWVkLCBldi53aGVlbFkgKiBldi5zcGVlZCk7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGV2LnN0b3AoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKERlZmF1bHRIYW5kbGVycy5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuRGVmYXVsdEhhbmRsZXJzID0gRGVmYXVsdEhhbmRsZXJzO1xcblxcblxcdGZ1bmN0aW9uIGNhbGNEaXN0YW5jZShheCwgYXksIGJ4LCBieSkge1xcblxcdCAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGJ4IC0gYXgsIDIpICsgTWF0aC5wb3coYnkgLSBheSwgMikpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjYWxjUmFuZ2VPcmllbnRhdGlvbihyYW5nZSwgY3Vyc29yKSB7XFxuXFx0ICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdylcXG5cXHQgICAgICAgIHZhciBjbXAgPSAyICogY3Vyc29yLmNvbHVtbiAtIHJhbmdlLnN0YXJ0LmNvbHVtbiAtIHJhbmdlLmVuZC5jb2x1bW47XFxuXFx0ICAgIGVsc2UgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PSByYW5nZS5lbmQucm93IC0gMSAmJiAhcmFuZ2Uuc3RhcnQuY29sdW1uICYmICFyYW5nZS5lbmQuY29sdW1uKVxcblxcdCAgICAgICAgdmFyIGNtcCA9IGN1cnNvci5jb2x1bW4gLSA0O1xcblxcdCAgICBlbHNlXFxuXFx0ICAgICAgICB2YXIgY21wID0gMiAqIGN1cnNvci5yb3cgLSByYW5nZS5zdGFydC5yb3cgLSByYW5nZS5lbmQucm93O1xcblxcblxcdCAgICBpZiAoY21wIDwgMClcXG5cXHQgICAgICAgIHJldHVybiB7Y3Vyc29yOiByYW5nZS5zdGFydCwgYW5jaG9yOiByYW5nZS5lbmR9O1xcblxcdCAgICBlbHNlXFxuXFx0ICAgICAgICByZXR1cm4ge2N1cnNvcjogcmFuZ2UuZW5kLCBhbmNob3I6IHJhbmdlLnN0YXJ0fTtcXG5cXHR9XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL3Rvb2x0aXBcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvZG9tXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgZG9tID0gYWNlcXVpcmUoXFxcIi4vbGliL2RvbVxcXCIpO1xcblxcdGZ1bmN0aW9uIFRvb2x0aXAgKHBhcmVudE5vZGUpIHtcXG5cXHQgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcXG5cXHQgICAgdGhpcy4kZWxlbWVudCA9IG51bGw7XFxuXFx0ICAgIHRoaXMuJHBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xcblxcdH1cXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuJGluaXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJGVsZW1lbnQgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgICAgICB0aGlzLiRlbGVtZW50LmNsYXNzTmFtZSA9IFxcXCJhY2VfdG9vbHRpcFxcXCI7XFxuXFx0ICAgICAgICB0aGlzLiRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCI7XFxuXFx0ICAgICAgICB0aGlzLiRwYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuJGVsZW1lbnQpO1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQgfHwgdGhpcy4kaW5pdCgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICBkb20uc2V0SW5uZXJUZXh0KHRoaXMuZ2V0RWxlbWVudCgpLCB0ZXh0KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRIdG1sID0gZnVuY3Rpb24oaHRtbCkge1xcblxcdCAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuaW5uZXJIVE1MID0gaHRtbDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcXG5cXHQgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmxlZnQgPSB4ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLnRvcCA9IHkgKyBcXFwicHhcXFwiO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldENsYXNzTmFtZSA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xcblxcdCAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMuZ2V0RWxlbWVudCgpLCBjbGFzc05hbWUpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNob3cgPSBmdW5jdGlvbih0ZXh0LCB4LCB5KSB7XFxuXFx0ICAgICAgICBpZiAodGV4dCAhPSBudWxsKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2V0VGV4dCh0ZXh0KTtcXG5cXHQgICAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oeCwgeSk7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuXFx0ICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmhpZGUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xcblxcdCAgICAgICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCI7XFxuXFx0ICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoKS5vZmZzZXRIZWlnaHQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoKS5vZmZzZXRXaWR0aDtcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKFRvb2x0aXAucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb3VzZS9kZWZhdWx0X2d1dHRlcl9oYW5kbGVyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvZXZlbnRcXFwiLFxcXCJhY2UvdG9vbHRpcFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRcXFwiKTtcXG5cXHR2YXIgVG9vbHRpcCA9IGFjZXF1aXJlKFxcXCIuLi90b29sdGlwXFxcIikuVG9vbHRpcDtcXG5cXG5cXHRmdW5jdGlvbiBHdXR0ZXJIYW5kbGVyKG1vdXNlSGFuZGxlcikge1xcblxcdCAgICB2YXIgZWRpdG9yID0gbW91c2VIYW5kbGVyLmVkaXRvcjtcXG5cXHQgICAgdmFyIGd1dHRlciA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXI7XFxuXFx0ICAgIHZhciB0b29sdGlwID0gbmV3IEd1dHRlclRvb2x0aXAoZWRpdG9yLmNvbnRhaW5lcik7XFxuXFxuXFx0ICAgIG1vdXNlSGFuZGxlci5lZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXFxcImd1dHRlcm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmICghZWRpdG9yLmlzRm9jdXNlZCgpIHx8IGUuZ2V0QnV0dG9uKCkgIT0gMClcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgZ3V0dGVyUmVnaW9uID0gZ3V0dGVyLmdldFJlZ2lvbihlKTtcXG5cXG5cXHQgICAgICAgIGlmIChndXR0ZXJSZWdpb24gPT0gXFxcImZvbGRXaWRnZXRzXFxcIilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB2YXIgcm93ID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCkucm93O1xcblxcdCAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZXNzaW9uLnNlbGVjdGlvbjtcXG5cXG5cXHQgICAgICAgIGlmIChlLmdldFNoaWZ0S2V5KCkpXFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdFRvKHJvdywgMCk7XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICBpZiAoZS5kb21FdmVudC5kZXRhaWwgPT0gMikge1xcblxcdCAgICAgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0QWxsKCk7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uLmdldExpbmVSYW5nZShyb3cpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgbW91c2VIYW5kbGVyLnNldFN0YXRlKFxcXCJzZWxlY3RCeUxpbmVzXFxcIik7XFxuXFx0ICAgICAgICBtb3VzZUhhbmRsZXIuY2FwdHVyZU1vdXNlKGUpO1xcblxcdCAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcXG5cXHQgICAgfSk7XFxuXFxuXFxuXFx0ICAgIHZhciB0b29sdGlwVGltZW91dCwgbW91c2VFdmVudCwgdG9vbHRpcEFubm90YXRpb247XFxuXFxuXFx0ICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xcblxcdCAgICAgICAgdmFyIHJvdyA9IG1vdXNlRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcXG5cXHQgICAgICAgIHZhciBhbm5vdGF0aW9uID0gZ3V0dGVyLiRhbm5vdGF0aW9uc1tyb3ddO1xcblxcdCAgICAgICAgaWYgKCFhbm5vdGF0aW9uKVxcblxcdCAgICAgICAgICAgIHJldHVybiBoaWRlVG9vbHRpcCgpO1xcblxcblxcdCAgICAgICAgdmFyIG1heFJvdyA9IGVkaXRvci5zZXNzaW9uLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgaWYgKHJvdyA9PSBtYXhSb3cpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc2NyZWVuUm93ID0gZWRpdG9yLnJlbmRlcmVyLnBpeGVsVG9TY3JlZW5Db29yZGluYXRlcygwLCBtb3VzZUV2ZW50LnkpLnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgcG9zID0gbW91c2VFdmVudC4kcG9zO1xcblxcdCAgICAgICAgICAgIGlmIChzY3JlZW5Sb3cgPiBlZGl0b3Iuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KHBvcy5yb3csIHBvcy5jb2x1bW4pKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gaGlkZVRvb2x0aXAoKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmICh0b29sdGlwQW5ub3RhdGlvbiA9PSBhbm5vdGF0aW9uKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHRvb2x0aXBBbm5vdGF0aW9uID0gYW5ub3RhdGlvbi50ZXh0LmpvaW4oXFxcIjxici8+XFxcIik7XFxuXFxuXFx0ICAgICAgICB0b29sdGlwLnNldEh0bWwodG9vbHRpcEFubm90YXRpb24pO1xcblxcdCAgICAgICAgdG9vbHRpcC5zaG93KCk7XFxuXFx0ICAgICAgICBlZGl0b3Iub24oXFxcIm1vdXNld2hlZWxcXFwiLCBoaWRlVG9vbHRpcCk7XFxuXFxuXFx0ICAgICAgICBpZiAobW91c2VIYW5kbGVyLiR0b29sdGlwRm9sbG93c01vdXNlKSB7XFxuXFx0ICAgICAgICAgICAgbW92ZVRvb2x0aXAobW91c2VFdmVudCk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBndXR0ZXJFbGVtZW50ID0gZ3V0dGVyLiRjZWxsc1tlZGl0b3Iuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUm93KHJvdywgMCldLmVsZW1lbnQ7XFxuXFx0ICAgICAgICAgICAgdmFyIHJlY3QgPSBndXR0ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdCAgICAgICAgICAgIHZhciBzdHlsZSA9IHRvb2x0aXAuZ2V0RWxlbWVudCgpLnN0eWxlO1xcblxcdCAgICAgICAgICAgIHN0eWxlLmxlZnQgPSByZWN0LnJpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICBzdHlsZS50b3AgPSByZWN0LmJvdHRvbSArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gaGlkZVRvb2x0aXAoKSB7XFxuXFx0ICAgICAgICBpZiAodG9vbHRpcFRpbWVvdXQpXFxuXFx0ICAgICAgICAgICAgdG9vbHRpcFRpbWVvdXQgPSBjbGVhclRpbWVvdXQodG9vbHRpcFRpbWVvdXQpO1xcblxcdCAgICAgICAgaWYgKHRvb2x0aXBBbm5vdGF0aW9uKSB7XFxuXFx0ICAgICAgICAgICAgdG9vbHRpcC5oaWRlKCk7XFxuXFx0ICAgICAgICAgICAgdG9vbHRpcEFubm90YXRpb24gPSBudWxsO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJtb3VzZXdoZWVsXFxcIiwgaGlkZVRvb2x0aXApO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIGZ1bmN0aW9uIG1vdmVUb29sdGlwKGUpIHtcXG5cXHQgICAgICAgIHRvb2x0aXAuc2V0UG9zaXRpb24oZS54LCBlLnkpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIG1vdXNlSGFuZGxlci5lZGl0b3Iuc2V0RGVmYXVsdEhhbmRsZXIoXFxcImd1dHRlcm1vdXNlbW92ZVxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHZhciB0YXJnZXQgPSBlLmRvbUV2ZW50LnRhcmdldCB8fCBlLmRvbUV2ZW50LnNyY0VsZW1lbnQ7XFxuXFx0ICAgICAgICBpZiAoZG9tLmhhc0Nzc0NsYXNzKHRhcmdldCwgXFxcImFjZV9mb2xkLXdpZGdldFxcXCIpKVxcblxcdCAgICAgICAgICAgIHJldHVybiBoaWRlVG9vbHRpcCgpO1xcblxcblxcdCAgICAgICAgaWYgKHRvb2x0aXBBbm5vdGF0aW9uICYmIG1vdXNlSGFuZGxlci4kdG9vbHRpcEZvbGxvd3NNb3VzZSlcXG5cXHQgICAgICAgICAgICBtb3ZlVG9vbHRpcChlKTtcXG5cXG5cXHQgICAgICAgIG1vdXNlRXZlbnQgPSBlO1xcblxcdCAgICAgICAgaWYgKHRvb2x0aXBUaW1lb3V0KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICB0b29sdGlwVGltZW91dCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgaWYgKG1vdXNlRXZlbnQgJiYgIW1vdXNlSGFuZGxlci5pc01vdXNlUHJlc3NlZClcXG5cXHQgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XFxuXFx0ICAgICAgICB9LCA1MCk7XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcihlZGl0b3IucmVuZGVyZXIuJGd1dHRlciwgXFxcIm1vdXNlb3V0XFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgbW91c2VFdmVudCA9IG51bGw7XFxuXFx0ICAgICAgICBpZiAoIXRvb2x0aXBBbm5vdGF0aW9uIHx8IHRvb2x0aXBUaW1lb3V0KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICB0b29sdGlwVGltZW91dCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgaGlkZVRvb2x0aXAoKTtcXG5cXHQgICAgICAgIH0sIDUwKTtcXG5cXHQgICAgfSk7XFxuXFx0ICAgIFxcblxcdCAgICBlZGl0b3Iub24oXFxcImNoYW5nZVNlc3Npb25cXFwiLCBoaWRlVG9vbHRpcCk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEd1dHRlclRvb2x0aXAocGFyZW50Tm9kZSkge1xcblxcdCAgICBUb29sdGlwLmNhbGwodGhpcywgcGFyZW50Tm9kZSk7XFxuXFx0fVxcblxcblxcdG9vcC5pbmhlcml0cyhHdXR0ZXJUb29sdGlwLCBUb29sdGlwKTtcXG5cXG5cXHQoZnVuY3Rpb24oKXtcXG5cXHQgICAgdGhpcy5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHkpIHtcXG5cXHQgICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcXG5cXHQgICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcXG5cXHQgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcXG5cXHQgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xcblxcdCAgICAgICAgeCArPSAxNTtcXG5cXHQgICAgICAgIHkgKz0gMTU7XFxuXFx0ICAgICAgICBpZiAoeCArIHdpZHRoID4gd2luZG93V2lkdGgpIHtcXG5cXHQgICAgICAgICAgICB4IC09ICh4ICsgd2lkdGgpIC0gd2luZG93V2lkdGg7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoeSArIGhlaWdodCA+IHdpbmRvd0hlaWdodCkge1xcblxcdCAgICAgICAgICAgIHkgLT0gMjAgKyBoZWlnaHQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBUb29sdGlwLnByb3RvdHlwZS5zZXRQb3NpdGlvbi5jYWxsKHRoaXMsIHgsIHkpO1xcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoR3V0dGVyVG9vbHRpcC5wcm90b3R5cGUpO1xcblxcblxcblxcblxcdGV4cG9ydHMuR3V0dGVySGFuZGxlciA9IEd1dHRlckhhbmRsZXI7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL21vdXNlL21vdXNlX2V2ZW50XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCIsXFxcImFjZS9saWIvdXNlcmFnZW50XFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIGV2ZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9ldmVudFxcXCIpO1xcblxcdHZhciB1c2VyYWdlbnQgPSBhY2VxdWlyZShcXFwiLi4vbGliL3VzZXJhZ2VudFxcXCIpO1xcblxcdHZhciBNb3VzZUV2ZW50ID0gZXhwb3J0cy5Nb3VzZUV2ZW50ID0gZnVuY3Rpb24oZG9tRXZlbnQsIGVkaXRvcikge1xcblxcdCAgICB0aGlzLmRvbUV2ZW50ID0gZG9tRXZlbnQ7XFxuXFx0ICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy54ID0gdGhpcy5jbGllbnRYID0gZG9tRXZlbnQuY2xpZW50WDtcXG5cXHQgICAgdGhpcy55ID0gdGhpcy5jbGllbnRZID0gZG9tRXZlbnQuY2xpZW50WTtcXG5cXG5cXHQgICAgdGhpcy4kcG9zID0gbnVsbDtcXG5cXHQgICAgdGhpcy4kaW5TZWxlY3Rpb24gPSBudWxsO1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcXG5cXHQgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7ICBcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24odGhpcy5kb21FdmVudCk7XFxuXFx0ICAgICAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCh0aGlzLmRvbUV2ZW50KTtcXG5cXHQgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0ICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0RG9jdW1lbnRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHBvcylcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy4kcG9zO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLiRwb3MgPSB0aGlzLmVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyh0aGlzLmNsaWVudFgsIHRoaXMuY2xpZW50WSk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kcG9zO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmluU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kaW5TZWxlY3Rpb24gIT09IG51bGwpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGluU2VsZWN0aW9uO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xcblxcdCAgICAgICAgXFxuXFxuXFx0ICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIGlmIChzZWxlY3Rpb25SYW5nZS5pc0VtcHR5KCkpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kaW5TZWxlY3Rpb24gPSBmYWxzZTtcXG5cXHQgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldERvY3VtZW50UG9zaXRpb24oKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRpblNlbGVjdGlvbiA9IHNlbGVjdGlvblJhbmdlLmNvbnRhaW5zKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGluU2VsZWN0aW9uO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEJ1dHRvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIGV2ZW50LmdldEJ1dHRvbih0aGlzLmRvbUV2ZW50KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTaGlmdEtleSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZG9tRXZlbnQuc2hpZnRLZXk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmdldEFjY2VsS2V5ID0gdXNlcmFnZW50LmlzTWFjXFxuXFx0ICAgICAgICA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FdmVudC5tZXRhS2V5OyB9XFxuXFx0ICAgICAgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21FdmVudC5jdHJsS2V5OyB9O1xcblxcdCAgICBcXG5cXHR9KS5jYWxsKE1vdXNlRXZlbnQucHJvdG90eXBlKTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbW91c2UvZHJhZ2Ryb3BfaGFuZGxlclxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvZG9tXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCIsXFxcImFjZS9saWIvdXNlcmFnZW50XFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIGRvbSA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZG9tXFxcIik7XFxuXFx0dmFyIGV2ZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9ldmVudFxcXCIpO1xcblxcdHZhciB1c2VyYWdlbnQgPSBhY2VxdWlyZShcXFwiLi4vbGliL3VzZXJhZ2VudFxcXCIpO1xcblxcblxcdHZhciBBVVRPU0NST0xMX0RFTEFZID0gMjAwO1xcblxcdHZhciBTQ1JPTExfQ1VSU09SX0RFTEFZID0gMjAwO1xcblxcdHZhciBTQ1JPTExfQ1VSU09SX0hZU1RFUkVTSVMgPSA1O1xcblxcblxcdGZ1bmN0aW9uIERyYWdkcm9wSGFuZGxlcihtb3VzZUhhbmRsZXIpIHtcXG5cXG5cXHQgICAgdmFyIGVkaXRvciA9IG1vdXNlSGFuZGxlci5lZGl0b3I7XFxuXFxuXFx0ICAgIHZhciBibGFua0ltYWdlID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImltZ1xcXCIpO1xcblxcdCAgICBibGFua0ltYWdlLnNyYyA9IFxcXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVxcXCI7XFxuXFx0ICAgIGlmICh1c2VyYWdlbnQuaXNPcGVyYSlcXG5cXHQgICAgICAgIGJsYW5rSW1hZ2Uuc3R5bGUuY3NzVGV4dCA9IFxcXCJ3aWR0aDoxcHg7aGVpZ2h0OjFweDtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7ei1pbmRleDoyMTQ3NDgzNjQ3O29wYWNpdHk6MDtcXFwiO1xcblxcblxcdCAgICB2YXIgZXhwb3J0cyA9IFtcXFwiZHJhZ1dhaXRcXFwiLCBcXFwiZHJhZ1dhaXRFbmRcXFwiLCBcXFwic3RhcnREcmFnXFxcIiwgXFxcImRyYWdSZWFkeUVuZFxcXCIsIFxcXCJvbk1vdXNlRHJhZ1xcXCJdO1xcblxcblxcdCAgICAgZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcXG5cXHQgICAgICAgICBtb3VzZUhhbmRsZXJbeF0gPSB0aGlzW3hdO1xcblxcdCAgICB9LCB0aGlzKTtcXG5cXHQgICAgZWRpdG9yLmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1vdXNlZG93blxcXCIsIHRoaXMub25Nb3VzZURvd24uYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXG5cXG5cXHQgICAgdmFyIG1vdXNlVGFyZ2V0ID0gZWRpdG9yLmNvbnRhaW5lcjtcXG5cXHQgICAgdmFyIGRyYWdTZWxlY3Rpb25NYXJrZXIsIHgsIHk7XFxuXFx0ICAgIHZhciB0aW1lcklkLCByYW5nZTtcXG5cXHQgICAgdmFyIGRyYWdDdXJzb3IsIGNvdW50ZXIgPSAwO1xcblxcdCAgICB2YXIgZHJhZ09wZXJhdGlvbjtcXG5cXHQgICAgdmFyIGlzSW50ZXJuYWw7XFxuXFx0ICAgIHZhciBhdXRvU2Nyb2xsU3RhcnRUaW1lO1xcblxcdCAgICB2YXIgY3Vyc29yTW92ZWRUaW1lO1xcblxcdCAgICB2YXIgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQ7XFxuXFxuXFx0ICAgIHRoaXMub25EcmFnU3RhcnQgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5jYW5jZWxEcmFnIHx8ICFtb3VzZVRhcmdldC5kcmFnZ2FibGUpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xcblxcdCAgICAgICAgICAgICAgICBzZWxmLnN0YXJ0U2VsZWN0KCk7XFxuXFx0ICAgICAgICAgICAgICAgIHNlbGYuY2FwdHVyZU1vdXNlKGUpO1xcblxcdCAgICAgICAgICAgIH0sIDApO1xcblxcdCAgICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcblxcdCAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xcblxcdCAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBlZGl0b3IuZ2V0UmVhZE9ubHkoKSA/IFxcXCJjb3B5XFxcIiA6IFxcXCJjb3B5TW92ZVxcXCI7XFxuXFx0ICAgICAgICBpZiAodXNlcmFnZW50LmlzT3BlcmEpIHtcXG5cXHQgICAgICAgICAgICBlZGl0b3IuY29udGFpbmVyLmFwcGVuZENoaWxkKGJsYW5rSW1hZ2UpO1xcblxcdCAgICAgICAgICAgIGJsYW5rSW1hZ2Uuc2Nyb2xsVG9wID0gMDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShibGFua0ltYWdlLCAwLCAwKTtcXG5cXHQgICAgICAgIGlmICh1c2VyYWdlbnQuaXNPcGVyYSkge1xcblxcdCAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIucmVtb3ZlQ2hpbGQoYmxhbmtJbWFnZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBkYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XFxuXFx0ICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YShcXFwiVGV4dFxcXCIsIGVkaXRvci5zZXNzaW9uLmdldFRleHRSYW5nZSgpKTtcXG5cXG5cXHQgICAgICAgIGlzSW50ZXJuYWwgPSB0cnVlO1xcblxcdCAgICAgICAgdGhpcy5zZXRTdGF0ZShcXFwiZHJhZ1xcXCIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIG1vdXNlVGFyZ2V0LmRyYWdnYWJsZSA9IGZhbHNlO1xcblxcdCAgICAgICAgaXNJbnRlcm5hbCA9IGZhbHNlO1xcblxcdCAgICAgICAgdGhpcy5zZXRTdGF0ZShudWxsKTtcXG5cXHQgICAgICAgIGlmICghZWRpdG9yLmdldFJlYWRPbmx5KCkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgZHJvcEVmZmVjdCA9IGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3Q7XFxuXFx0ICAgICAgICAgICAgaWYgKCFkcmFnT3BlcmF0aW9uICYmIGRyb3BFZmZlY3QgPT0gXFxcIm1vdmVcXFwiKVxcblxcdCAgICAgICAgICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5yZW1vdmUoZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkpO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXIuc2V0QmxpbmtpbmcodHJ1ZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci51bnNldFN0eWxlKFxcXCJhY2VfZHJhZ2dpbmdcXFwiKTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNldEN1cnNvclN0eWxlKFxcXCJcXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vbkRyYWdFbnRlciA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmIChlZGl0b3IuZ2V0UmVhZE9ubHkoKSB8fCAhY2FuQWNjZXB0KGUuZGF0YVRyYW5zZmVyKSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB4ID0gZS5jbGllbnRYO1xcblxcdCAgICAgICAgeSA9IGUuY2xpZW50WTtcXG5cXHQgICAgICAgIGlmICghZHJhZ1NlbGVjdGlvbk1hcmtlcilcXG5cXHQgICAgICAgICAgICBhZGREcmFnTWFya2VyKCk7XFxuXFx0ICAgICAgICBjb3VudGVyKys7XFxuXFx0ICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gZHJhZ09wZXJhdGlvbiA9IGdldERyb3BFZmZlY3QoZSk7XFxuXFx0ICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25EcmFnT3ZlciA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmIChlZGl0b3IuZ2V0UmVhZE9ubHkoKSB8fCAhY2FuQWNjZXB0KGUuZGF0YVRyYW5zZmVyKSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB4ID0gZS5jbGllbnRYO1xcblxcdCAgICAgICAgeSA9IGUuY2xpZW50WTtcXG5cXHQgICAgICAgIGlmICghZHJhZ1NlbGVjdGlvbk1hcmtlcikge1xcblxcdCAgICAgICAgICAgIGFkZERyYWdNYXJrZXIoKTtcXG5cXHQgICAgICAgICAgICBjb3VudGVyKys7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciAhPT0gbnVsbClcXG5cXHQgICAgICAgICAgICBvbk1vdXNlTW92ZVRpbWVyID0gbnVsbDtcXG5cXG5cXHQgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBkcmFnT3BlcmF0aW9uID0gZ2V0RHJvcEVmZmVjdChlKTtcXG5cXHQgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vbkRyYWdMZWF2ZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGNvdW50ZXItLTtcXG5cXHQgICAgICAgIGlmIChjb3VudGVyIDw9IDAgJiYgZHJhZ1NlbGVjdGlvbk1hcmtlcikge1xcblxcdCAgICAgICAgICAgIGNsZWFyRHJhZ01hcmtlcigpO1xcblxcdCAgICAgICAgICAgIGRyYWdPcGVyYXRpb24gPSBudWxsO1xcblxcdCAgICAgICAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdChlKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vbkRyb3AgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAoIWRyYWdDdXJzb3IpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xcblxcdCAgICAgICAgaWYgKGlzSW50ZXJuYWwpIHtcXG5cXHQgICAgICAgICAgICBzd2l0Y2ggKGRyYWdPcGVyYXRpb24pIHtcXG5cXHQgICAgICAgICAgICAgICAgY2FzZSBcXFwibW92ZVxcXCI6XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29udGFpbnMoZHJhZ0N1cnNvci5yb3csIGRyYWdDdXJzb3IuY29sdW1uKSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZHJhZ0N1cnNvcixcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBkcmFnQ3Vyc29yXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBlZGl0b3IubW92ZVRleHQocmFuZ2UsIGRyYWdDdXJzb3IpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIGNhc2UgXFxcImNvcHlcXFwiOlxcblxcdCAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBlZGl0b3IubW92ZVRleHQocmFuZ2UsIGRyYWdDdXJzb3IsIHRydWUpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgZHJvcERhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnVGV4dCcpO1xcblxcdCAgICAgICAgICAgIHJhbmdlID0ge1xcblxcdCAgICAgICAgICAgICAgICBzdGFydDogZHJhZ0N1cnNvcixcXG5cXHQgICAgICAgICAgICAgICAgZW5kOiBlZGl0b3Iuc2Vzc2lvbi5pbnNlcnQoZHJhZ0N1cnNvciwgZHJvcERhdGEpXFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcXG5cXHQgICAgICAgICAgICBkcmFnT3BlcmF0aW9uID0gbnVsbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGNsZWFyRHJhZ01hcmtlcigpO1xcblxcdCAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcihtb3VzZVRhcmdldCwgXFxcImRyYWdzdGFydFxcXCIsIHRoaXMub25EcmFnU3RhcnQuYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFxcXCJkcmFnZW5kXFxcIiwgdGhpcy5vbkRyYWdFbmQuYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFxcXCJkcmFnZW50ZXJcXFwiLCB0aGlzLm9uRHJhZ0VudGVyLmJpbmQobW91c2VIYW5kbGVyKSk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcXFwiZHJhZ292ZXJcXFwiLCB0aGlzLm9uRHJhZ092ZXIuYmluZChtb3VzZUhhbmRsZXIpKTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFxcXCJkcmFnbGVhdmVcXFwiLCB0aGlzLm9uRHJhZ0xlYXZlLmJpbmQobW91c2VIYW5kbGVyKSk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcXFwiZHJvcFxcXCIsIHRoaXMub25Ecm9wLmJpbmQobW91c2VIYW5kbGVyKSk7XFxuXFxuXFx0ICAgIGZ1bmN0aW9uIHNjcm9sbEN1cnNvckludG9WaWV3KGN1cnNvciwgcHJldkN1cnNvcikge1xcblxcdCAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XFxuXFx0ICAgICAgICB2YXIgdk1vdmVtZW50ID0gIXByZXZDdXJzb3IgfHwgY3Vyc29yLnJvdyAhPSBwcmV2Q3Vyc29yLnJvdztcXG5cXHQgICAgICAgIHZhciBoTW92ZW1lbnQgPSAhcHJldkN1cnNvciB8fCBjdXJzb3IuY29sdW1uICE9IHByZXZDdXJzb3IuY29sdW1uO1xcblxcdCAgICAgICAgaWYgKCFjdXJzb3JNb3ZlZFRpbWUgfHwgdk1vdmVtZW50IHx8IGhNb3ZlbWVudCkge1xcblxcdCAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IubW92ZUN1cnNvclRvUG9zaXRpb24oY3Vyc29yKTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XFxuXFx0ICAgICAgICAgICAgY3Vyc29yTW92ZWRUaW1lID0gbm93O1xcblxcdCAgICAgICAgICAgIGN1cnNvclBvaW50T25DYXJldE1vdmVkID0ge3g6IHgsIHk6IHl9O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQueCwgY3Vyc29yUG9pbnRPbkNhcmV0TW92ZWQueSwgeCwgeSk7XFxuXFx0ICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gU0NST0xMX0NVUlNPUl9IWVNURVJFU0lTKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChub3cgLSBjdXJzb3JNb3ZlZFRpbWUgPj0gU0NST0xMX0NVUlNPUl9ERUxBWSkge1xcblxcdCAgICAgICAgICAgICAgICBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcXG5cXHQgICAgICAgICAgICAgICAgY3Vyc29yTW92ZWRUaW1lID0gbnVsbDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gYXV0b1Njcm9sbChjdXJzb3IsIHByZXZDdXJzb3IpIHtcXG5cXHQgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xcblxcdCAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBlZGl0b3IucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodDtcXG5cXHQgICAgICAgIHZhciBjaGFyYWN0ZXJXaWR0aCA9IGVkaXRvci5yZW5kZXJlci5sYXllckNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcXG5cXHQgICAgICAgIHZhciBlZGl0b3JSZWN0ID0gZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdCAgICAgICAgdmFyIG9mZnNldHMgPSB7XFxuXFx0ICAgICAgICAgICB4OiB7XFxuXFx0ICAgICAgICAgICAgICAgbGVmdDogeCAtIGVkaXRvclJlY3QubGVmdCxcXG5cXHQgICAgICAgICAgICAgICByaWdodDogZWRpdG9yUmVjdC5yaWdodCAtIHhcXG5cXHQgICAgICAgICAgIH0sXFxuXFx0ICAgICAgICAgICB5OiB7XFxuXFx0ICAgICAgICAgICAgICAgdG9wOiB5IC0gZWRpdG9yUmVjdC50b3AsXFxuXFx0ICAgICAgICAgICAgICAgYm90dG9tOiBlZGl0b3JSZWN0LmJvdHRvbSAtIHlcXG5cXHQgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH07XFxuXFx0ICAgICAgICB2YXIgbmVhcmVzdFhPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXRzLngubGVmdCwgb2Zmc2V0cy54LnJpZ2h0KTtcXG5cXHQgICAgICAgIHZhciBuZWFyZXN0WU9mZnNldCA9IE1hdGgubWluKG9mZnNldHMueS50b3AsIG9mZnNldHMueS5ib3R0b20pO1xcblxcdCAgICAgICAgdmFyIHNjcm9sbEN1cnNvciA9IHtyb3c6IGN1cnNvci5yb3csIGNvbHVtbjogY3Vyc29yLmNvbHVtbn07XFxuXFx0ICAgICAgICBpZiAobmVhcmVzdFhPZmZzZXQgLyBjaGFyYWN0ZXJXaWR0aCA8PSAyKSB7XFxuXFx0ICAgICAgICAgICAgc2Nyb2xsQ3Vyc29yLmNvbHVtbiArPSAob2Zmc2V0cy54LmxlZnQgPCBvZmZzZXRzLngucmlnaHQgPyAtMyA6ICsyKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChuZWFyZXN0WU9mZnNldCAvIGxpbmVIZWlnaHQgPD0gMSkge1xcblxcdCAgICAgICAgICAgIHNjcm9sbEN1cnNvci5yb3cgKz0gKG9mZnNldHMueS50b3AgPCBvZmZzZXRzLnkuYm90dG9tID8gLTEgOiArMSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB2YXIgdlNjcm9sbCA9IGN1cnNvci5yb3cgIT0gc2Nyb2xsQ3Vyc29yLnJvdztcXG5cXHQgICAgICAgIHZhciBoU2Nyb2xsID0gY3Vyc29yLmNvbHVtbiAhPSBzY3JvbGxDdXJzb3IuY29sdW1uO1xcblxcdCAgICAgICAgdmFyIHZNb3ZlbWVudCA9ICFwcmV2Q3Vyc29yIHx8IGN1cnNvci5yb3cgIT0gcHJldkN1cnNvci5yb3c7XFxuXFx0ICAgICAgICBpZiAodlNjcm9sbCB8fCAoaFNjcm9sbCAmJiAhdk1vdmVtZW50KSkge1xcblxcdCAgICAgICAgICAgIGlmICghYXV0b1Njcm9sbFN0YXJ0VGltZSlcXG5cXHQgICAgICAgICAgICAgICAgYXV0b1Njcm9sbFN0YXJ0VGltZSA9IG5vdztcXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChub3cgLSBhdXRvU2Nyb2xsU3RhcnRUaW1lID49IEFVVE9TQ1JPTExfREVMQVkpXFxuXFx0ICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhzY3JvbGxDdXJzb3IpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBhdXRvU2Nyb2xsU3RhcnRUaW1lID0gbnVsbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICBmdW5jdGlvbiBvbkRyYWdJbnRlcnZhbCgpIHtcXG5cXHQgICAgICAgIHZhciBwcmV2Q3Vyc29yID0gZHJhZ0N1cnNvcjtcXG5cXHQgICAgICAgIGRyYWdDdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXMoeCwgeSk7XFxuXFx0ICAgICAgICBzY3JvbGxDdXJzb3JJbnRvVmlldyhkcmFnQ3Vyc29yLCBwcmV2Q3Vyc29yKTtcXG5cXHQgICAgICAgIGF1dG9TY3JvbGwoZHJhZ0N1cnNvciwgcHJldkN1cnNvcik7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gYWRkRHJhZ01hcmtlcigpIHtcXG5cXHQgICAgICAgIHJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcXG5cXHQgICAgICAgIGRyYWdTZWxlY3Rpb25NYXJrZXIgPSBlZGl0b3Iuc2Vzc2lvbi5hZGRNYXJrZXIocmFuZ2UsIFxcXCJhY2Vfc2VsZWN0aW9uXFxcIiwgZWRpdG9yLmdldFNlbGVjdGlvblN0eWxlKCkpO1xcblxcdCAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICBpZiAoZWRpdG9yLmlzRm9jdXNlZCgpKVxcblxcdCAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXIuc2V0QmxpbmtpbmcoZmFsc2UpO1xcblxcdCAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcXG5cXHQgICAgICAgIG9uRHJhZ0ludGVydmFsKCk7XFxuXFx0ICAgICAgICB0aW1lcklkID0gc2V0SW50ZXJ2YWwob25EcmFnSW50ZXJ2YWwsIDIwKTtcXG5cXHQgICAgICAgIGNvdW50ZXIgPSAwO1xcblxcdCAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZG9jdW1lbnQsIFxcXCJtb3VzZW1vdmVcXFwiLCBvbk1vdXNlTW92ZSk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gY2xlYXJEcmFnTWFya2VyKCkge1xcblxcdCAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcXG5cXHQgICAgICAgIGVkaXRvci5zZXNzaW9uLnJlbW92ZU1hcmtlcihkcmFnU2VsZWN0aW9uTWFya2VyKTtcXG5cXHQgICAgICAgIGRyYWdTZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xcblxcdCAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZyArPSAxO1xcblxcdCAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5mcm9tT3JpZW50ZWRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICBlZGl0b3IuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XFxuXFx0ICAgICAgICBpZiAoZWRpdG9yLmlzRm9jdXNlZCgpICYmICFpc0ludGVybmFsKVxcblxcdCAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci4kY3Vyc29yTGF5ZXIuc2V0QmxpbmtpbmcoIWVkaXRvci5nZXRSZWFkT25seSgpKTtcXG5cXHQgICAgICAgIHJhbmdlID0gbnVsbDtcXG5cXHQgICAgICAgIGRyYWdDdXJzb3IgPSBudWxsO1xcblxcdCAgICAgICAgY291bnRlciA9IDA7XFxuXFx0ICAgICAgICBhdXRvU2Nyb2xsU3RhcnRUaW1lID0gbnVsbDtcXG5cXHQgICAgICAgIGN1cnNvck1vdmVkVGltZSA9IG51bGw7XFxuXFx0ICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lcihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIG9uTW91c2VNb3ZlKTtcXG5cXHQgICAgfVxcblxcdCAgICB2YXIgb25Nb3VzZU1vdmVUaW1lciA9IG51bGw7XFxuXFx0ICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge1xcblxcdCAgICAgICAgaWYgKG9uTW91c2VNb3ZlVGltZXIgPT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgIG9uTW91c2VNb3ZlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAob25Nb3VzZU1vdmVUaW1lciAhPSBudWxsICYmIGRyYWdTZWxlY3Rpb25NYXJrZXIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjbGVhckRyYWdNYXJrZXIoKTtcXG5cXHQgICAgICAgICAgICB9LCAyMCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gY2FuQWNjZXB0KGRhdGFUcmFuc2Zlcikge1xcblxcdCAgICAgICAgdmFyIHR5cGVzID0gZGF0YVRyYW5zZmVyLnR5cGVzO1xcblxcdCAgICAgICAgcmV0dXJuICF0eXBlcyB8fCBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT0gJ3RleHQvcGxhaW4nIHx8IHR5cGUgPT0gJ1RleHQnO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZnVuY3Rpb24gZ2V0RHJvcEVmZmVjdChlKSB7XFxuXFx0ICAgICAgICB2YXIgY29weUFsbG93ZWQgPSBbJ2NvcHknLCAnY29weW1vdmUnLCAnYWxsJywgJ3VuaW5pdGlhbGl6ZWQnXTtcXG5cXHQgICAgICAgIHZhciBtb3ZlQWxsb3dlZCA9IFsnbW92ZScsICdjb3B5bW92ZScsICdsaW5rbW92ZScsICdhbGwnLCAndW5pbml0aWFsaXplZCddO1xcblxcblxcdCAgICAgICAgdmFyIGNvcHlNb2RpZmllclN0YXRlID0gdXNlcmFnZW50LmlzTWFjID8gZS5hbHRLZXkgOiBlLmN0cmxLZXk7XFxuXFx0ICAgICAgICB2YXIgZWZmZWN0QWxsb3dlZCA9IFxcXCJ1bmluaXRpYWxpemVkXFxcIjtcXG5cXHQgICAgICAgIHRyeSB7XFxuXFx0ICAgICAgICAgICAgZWZmZWN0QWxsb3dlZCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQudG9Mb3dlckNhc2UoKTtcXG5cXHQgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuXFx0ICAgICAgICB2YXIgZHJvcEVmZmVjdCA9IFxcXCJub25lXFxcIjtcXG5cXG5cXHQgICAgICAgIGlmIChjb3B5TW9kaWZpZXJTdGF0ZSAmJiBjb3B5QWxsb3dlZC5pbmRleE9mKGVmZmVjdEFsbG93ZWQpID49IDApXFxuXFx0ICAgICAgICAgICAgZHJvcEVmZmVjdCA9IFxcXCJjb3B5XFxcIjtcXG5cXHQgICAgICAgIGVsc2UgaWYgKG1vdmVBbGxvd2VkLmluZGV4T2YoZWZmZWN0QWxsb3dlZCkgPj0gMClcXG5cXHQgICAgICAgICAgICBkcm9wRWZmZWN0ID0gXFxcIm1vdmVcXFwiO1xcblxcdCAgICAgICAgZWxzZSBpZiAoY29weUFsbG93ZWQuaW5kZXhPZihlZmZlY3RBbGxvd2VkKSA+PSAwKVxcblxcdCAgICAgICAgICAgIGRyb3BFZmZlY3QgPSBcXFwiY29weVxcXCI7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gZHJvcEVmZmVjdDtcXG5cXHQgICAgfVxcblxcdH1cXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIHRoaXMuZHJhZ1dhaXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBpbnRlcnZhbCA9IERhdGUubm93KCkgLSB0aGlzLm1vdXNlZG93bkV2ZW50LnRpbWU7XFxuXFx0ICAgICAgICBpZiAoaW50ZXJ2YWwgPiB0aGlzLmVkaXRvci5nZXREcmFnRGVsYXkoKSlcXG5cXHQgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmRyYWdXYWl0RW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5lZGl0b3IuY29udGFpbmVyO1xcblxcdCAgICAgICAgdGFyZ2V0LmRyYWdnYWJsZSA9IGZhbHNlO1xcblxcdCAgICAgICAgdGhpcy5zdGFydFNlbGVjdCh0aGlzLm1vdXNlZG93bkV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKSk7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdEVuZCgpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmRyYWdSZWFkeUVuZCA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5zZXRCbGlua2luZyghdGhpcy5lZGl0b3IuZ2V0UmVhZE9ubHkoKSk7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci51bnNldFN0eWxlKFxcXCJhY2VfZHJhZ2dpbmdcXFwiKTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnNldEN1cnNvclN0eWxlKFxcXCJcXFwiKTtcXG5cXHQgICAgICAgIHRoaXMuZHJhZ1dhaXRFbmQoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zdGFydERyYWcgPSBmdW5jdGlvbigpe1xcblxcdCAgICAgICAgdGhpcy5jYW5jZWxEcmFnID0gZmFsc2U7XFxuXFx0ICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XFxuXFx0ICAgICAgICB2YXIgdGFyZ2V0ID0gZWRpdG9yLmNvbnRhaW5lcjtcXG5cXHQgICAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xcblxcdCAgICAgICAgZWRpdG9yLnJlbmRlcmVyLiRjdXJzb3JMYXllci5zZXRCbGlua2luZyhmYWxzZSk7XFxuXFx0ICAgICAgICBlZGl0b3Iuc2V0U3R5bGUoXFxcImFjZV9kcmFnZ2luZ1xcXCIpO1xcblxcdCAgICAgICAgdmFyIGN1cnNvclN0eWxlID0gdXNlcmFnZW50LmlzV2luID8gXFxcImRlZmF1bHRcXFwiIDogXFxcIm1vdmVcXFwiO1xcblxcdCAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNldEN1cnNvclN0eWxlKGN1cnNvclN0eWxlKTtcXG5cXHQgICAgICAgIHRoaXMuc2V0U3RhdGUoXFxcImRyYWdSZWFkeVxcXCIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uTW91c2VEcmFnID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZWRpdG9yLmNvbnRhaW5lcjtcXG5cXHQgICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSAmJiB0aGlzLnN0YXRlID09IFxcXCJkcmFnUmVhZHlcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKHRoaXMubW91c2Vkb3duRXZlbnQueCwgdGhpcy5tb3VzZWRvd25FdmVudC55LCB0aGlzLngsIHRoaXMueSk7XFxuXFx0ICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMylcXG5cXHQgICAgICAgICAgICAgICAgdGFyZ2V0LmRyYWdEcm9wKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXFxcImRyYWdXYWl0XFxcIikge1xcblxcdCAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNhbGNEaXN0YW5jZSh0aGlzLm1vdXNlZG93bkV2ZW50LngsIHRoaXMubW91c2Vkb3duRXZlbnQueSwgdGhpcy54LCB0aGlzLnkpO1xcblxcdCAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgdGFyZ2V0LmRyYWdnYWJsZSA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0KHRoaXMubW91c2Vkb3duRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Nb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGRyYWdFbmFibGVkKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHRoaXMubW91c2Vkb3duRXZlbnQgPSBlO1xcblxcdCAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xcblxcblxcdCAgICAgICAgdmFyIGluU2VsZWN0aW9uID0gZS5pblNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgdmFyIGJ1dHRvbiA9IGUuZ2V0QnV0dG9uKCk7XFxuXFx0ICAgICAgICB2YXIgY2xpY2tDb3VudCA9IGUuZG9tRXZlbnQuZGV0YWlsIHx8IDE7XFxuXFx0ICAgICAgICBpZiAoY2xpY2tDb3VudCA9PT0gMSAmJiBidXR0b24gPT09IDAgJiYgaW5TZWxlY3Rpb24pIHtcXG5cXHQgICAgICAgICAgICBpZiAoZS5lZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGUgJiYgKGUuZ2V0QWNjZWxLZXkoKSB8fCBlLmdldFNoaWZ0S2V5KCkpKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3VzZWRvd25FdmVudC50aW1lID0gRGF0ZS5ub3coKTtcXG5cXHQgICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBlLmRvbUV2ZW50LnRhcmdldCB8fCBlLmRvbUV2ZW50LnNyY0VsZW1lbnQ7XFxuXFx0ICAgICAgICAgICAgaWYgKFxcXCJ1bnNlbGVjdGFibGVcXFwiIGluIGV2ZW50VGFyZ2V0KVxcblxcdCAgICAgICAgICAgICAgICBldmVudFRhcmdldC51bnNlbGVjdGFibGUgPSBcXFwib25cXFwiO1xcblxcdCAgICAgICAgICAgIGlmIChlZGl0b3IuZ2V0RHJhZ0RlbGF5KCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHVzZXJhZ2VudC5pc1dlYktpdCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxEcmFnID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZVRhcmdldCA9IGVkaXRvci5jb250YWluZXI7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBtb3VzZVRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoXFxcImRyYWdXYWl0XFxcIik7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy5jYXB0dXJlTW91c2UoZSwgdGhpcy5vbk1vdXNlRHJhZy5iaW5kKHRoaXMpKTtcXG5cXHQgICAgICAgICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoRHJhZ2Ryb3BIYW5kbGVyLnByb3RvdHlwZSk7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKGF4LCBheSwgYngsIGJ5KSB7XFxuXFx0ICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYnggLSBheCwgMikgKyBNYXRoLnBvdyhieSAtIGF5LCAyKSk7XFxuXFx0fVxcblxcblxcdGV4cG9ydHMuRHJhZ2Ryb3BIYW5kbGVyID0gRHJhZ2Ryb3BIYW5kbGVyO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9saWIvbmV0XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHR2YXIgZG9tID0gYWNlcXVpcmUoXFxcIi4vZG9tXFxcIik7XFxuXFxuXFx0ZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xcblxcdCAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxuXFx0ICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xcblxcdCAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XFxuXFx0ICAgICAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHhoci5zZW5kKG51bGwpO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5sb2FkU2NyaXB0ID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcXG5cXHQgICAgdmFyIGhlYWQgPSBkb20uZ2V0RG9jdW1lbnRIZWFkKCk7XFxuXFx0ICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XFxuXFxuXFx0ICAgIHMuc3JjID0gcGF0aDtcXG5cXHQgICAgaGVhZC5hcHBlbmRDaGlsZChzKTtcXG5cXG5cXHQgICAgcy5vbmxvYWQgPSBzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKF8sIGlzQWJvcnQpIHtcXG5cXHQgICAgICAgIGlmIChpc0Fib3J0IHx8ICFzLnJlYWR5U3RhdGUgfHwgcy5yZWFkeVN0YXRlID09IFxcXCJsb2FkZWRcXFwiIHx8IHMucmVhZHlTdGF0ZSA9PSBcXFwiY29tcGxldGVcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgcyA9IHMub25sb2FkID0gcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xcblxcdCAgICAgICAgICAgIGlmICghaXNBYm9ydClcXG5cXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHR9O1xcblxcdGV4cG9ydHMucXVhbGlmeVVSTCA9IGZ1bmN0aW9uKHVybCkge1xcblxcdCAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcXG5cXHQgICAgYS5ocmVmID0gdXJsO1xcblxcdCAgICByZXR1cm4gYS5ocmVmO1xcblxcdH1cXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgRXZlbnRFbWl0dGVyID0ge307XFxuXFx0dmFyIHN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkgeyB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7IH07XFxuXFx0dmFyIHByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH07XFxuXFxuXFx0RXZlbnRFbWl0dGVyLl9lbWl0ID1cXG5cXHRFdmVudEVtaXR0ZXIuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE5hbWUsIGUpIHtcXG5cXHQgICAgdGhpcy5fZXZlbnRSZWdpc3RyeSB8fCAodGhpcy5fZXZlbnRSZWdpc3RyeSA9IHt9KTtcXG5cXHQgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJzIHx8ICh0aGlzLl9kZWZhdWx0SGFuZGxlcnMgPSB7fSk7XFxuXFxuXFx0ICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gfHwgW107XFxuXFx0ICAgIHZhciBkZWZhdWx0SGFuZGxlciA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyc1tldmVudE5hbWVdO1xcblxcdCAgICBpZiAoIWxpc3RlbmVycy5sZW5ndGggJiYgIWRlZmF1bHRIYW5kbGVyKVxcblxcdCAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICBpZiAodHlwZW9mIGUgIT0gXFxcIm9iamVjdFxcXCIgfHwgIWUpXFxuXFx0ICAgICAgICBlID0ge307XFxuXFxuXFx0ICAgIGlmICghZS50eXBlKVxcblxcdCAgICAgICAgZS50eXBlID0gZXZlbnROYW1lO1xcblxcdCAgICBpZiAoIWUuc3RvcFByb3BhZ2F0aW9uKVxcblxcdCAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XFxuXFx0ICAgIGlmICghZS5wcmV2ZW50RGVmYXVsdClcXG5cXHQgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcXG5cXG5cXHQgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XFxuXFx0ICAgIGZvciAodmFyIGk9MDsgaTxsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgIGxpc3RlbmVyc1tpXShlLCB0aGlzKTtcXG5cXHQgICAgICAgIGlmIChlLnByb3BhZ2F0aW9uU3RvcHBlZClcXG5cXHQgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgfVxcblxcdCAgICBcXG5cXHQgICAgaWYgKGRlZmF1bHRIYW5kbGVyICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpXFxuXFx0ICAgICAgICByZXR1cm4gZGVmYXVsdEhhbmRsZXIoZSwgdGhpcyk7XFxuXFx0fTtcXG5cXG5cXG5cXHRFdmVudEVtaXR0ZXIuX3NpZ25hbCA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZSkge1xcblxcdCAgICB2YXIgbGlzdGVuZXJzID0gKHRoaXMuX2V2ZW50UmVnaXN0cnkgfHwge30pW2V2ZW50TmFtZV07XFxuXFx0ICAgIGlmICghbGlzdGVuZXJzKVxcblxcdCAgICAgICAgcmV0dXJuO1xcblxcdCAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcXG5cXHQgICAgZm9yICh2YXIgaT0wOyBpPGxpc3RlbmVycy5sZW5ndGg7IGkrKylcXG5cXHQgICAgICAgIGxpc3RlbmVyc1tpXShlLCB0aGlzKTtcXG5cXHR9O1xcblxcblxcdEV2ZW50RW1pdHRlci5vbmNlID0gZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xcblxcdCAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcdCAgICBjYWxsYmFjayAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiBuZXdDYWxsYmFjaygpIHtcXG5cXHQgICAgICAgIF9zZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBuZXdDYWxsYmFjayk7XFxuXFx0ICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcblxcdCAgICB9KTtcXG5cXHR9O1xcblxcblxcblxcdEV2ZW50RW1pdHRlci5zZXREZWZhdWx0SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcXG5cXHQgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fZGVmYXVsdEhhbmRsZXJzXFxuXFx0ICAgIGlmICghaGFuZGxlcnMpXFxuXFx0ICAgICAgICBoYW5kbGVycyA9IHRoaXMuX2RlZmF1bHRIYW5kbGVycyA9IHtfZGlzYWJsZWRfOiB7fX07XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoaGFuZGxlcnNbZXZlbnROYW1lXSkge1xcblxcdCAgICAgICAgdmFyIG9sZCA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XFxuXFx0ICAgICAgICB2YXIgZGlzYWJsZWQgPSBoYW5kbGVycy5fZGlzYWJsZWRfW2V2ZW50TmFtZV07XFxuXFx0ICAgICAgICBpZiAoIWRpc2FibGVkKVxcblxcdCAgICAgICAgICAgIGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXSA9IGRpc2FibGVkID0gW107XFxuXFx0ICAgICAgICBkaXNhYmxlZC5wdXNoKG9sZCk7XFxuXFx0ICAgICAgICB2YXIgaSA9IGRpc2FibGVkLmluZGV4T2YoY2FsbGJhY2spO1xcblxcdCAgICAgICAgaWYgKGkgIT0gLTEpIFxcblxcdCAgICAgICAgICAgIGRpc2FibGVkLnNwbGljZShpLCAxKTtcXG5cXHQgICAgfVxcblxcdCAgICBoYW5kbGVyc1tldmVudE5hbWVdID0gY2FsbGJhY2s7XFxuXFx0fTtcXG5cXHRFdmVudEVtaXR0ZXIucmVtb3ZlRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XFxuXFx0ICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyc1xcblxcdCAgICBpZiAoIWhhbmRsZXJzKVxcblxcdCAgICAgICAgcmV0dXJuO1xcblxcdCAgICB2YXIgZGlzYWJsZWQgPSBoYW5kbGVycy5fZGlzYWJsZWRfW2V2ZW50TmFtZV07XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoaGFuZGxlcnNbZXZlbnROYW1lXSA9PSBjYWxsYmFjaykge1xcblxcdCAgICAgICAgdmFyIG9sZCA9IGhhbmRsZXJzW2V2ZW50TmFtZV07XFxuXFx0ICAgICAgICBpZiAoZGlzYWJsZWQpXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0SGFuZGxlcihldmVudE5hbWUsIGRpc2FibGVkLnBvcCgpKTtcXG5cXHQgICAgfSBlbHNlIGlmIChkaXNhYmxlZCkge1xcblxcdCAgICAgICAgdmFyIGkgPSBkaXNhYmxlZC5pbmRleE9mKGNhbGxiYWNrKTtcXG5cXHQgICAgICAgIGlmIChpICE9IC0xKVxcblxcdCAgICAgICAgICAgIGRpc2FibGVkLnNwbGljZShpLCAxKTtcXG5cXHQgICAgfVxcblxcdH07XFxuXFxuXFx0RXZlbnRFbWl0dGVyLm9uID1cXG5cXHRFdmVudEVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGNhcHR1cmluZykge1xcblxcdCAgICB0aGlzLl9ldmVudFJlZ2lzdHJ5ID0gdGhpcy5fZXZlbnRSZWdpc3RyeSB8fCB7fTtcXG5cXG5cXHQgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtcXG5cXHQgICAgaWYgKCFsaXN0ZW5lcnMpXFxuXFx0ICAgICAgICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV0gPSBbXTtcXG5cXG5cXHQgICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSA9PSAtMSlcXG5cXHQgICAgICAgIGxpc3RlbmVyc1tjYXB0dXJpbmcgPyBcXFwidW5zaGlmdFxcXCIgOiBcXFwicHVzaFxcXCJdKGNhbGxiYWNrKTtcXG5cXHQgICAgcmV0dXJuIGNhbGxiYWNrO1xcblxcdH07XFxuXFxuXFx0RXZlbnRFbWl0dGVyLm9mZiA9XFxuXFx0RXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyID1cXG5cXHRFdmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcXG5cXHQgICAgdGhpcy5fZXZlbnRSZWdpc3RyeSA9IHRoaXMuX2V2ZW50UmVnaXN0cnkgfHwge307XFxuXFxuXFx0ICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV07XFxuXFx0ICAgIGlmICghbGlzdGVuZXJzKVxcblxcdCAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayk7XFxuXFx0ICAgIGlmIChpbmRleCAhPT0gLTEpXFxuXFx0ICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcXG5cXHR9O1xcblxcblxcdEV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcXG5cXHQgICAgaWYgKHRoaXMuX2V2ZW50UmVnaXN0cnkpIHRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXSA9IFtdO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2NvbmZpZ1xcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL2xpYi9uZXRcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJubyB1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgbGFuZyA9IGFjZXF1aXJlKFxcXCIuL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgbmV0ID0gYWNlcXVpcmUoXFxcIi4vbGliL25ldFxcXCIpO1xcblxcdHZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXG5cXHR2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkge1xcblxcdCAgICByZXR1cm4gdGhpcztcXG5cXHR9KSgpO1xcblxcblxcdHZhciBvcHRpb25zID0ge1xcblxcdCAgICBwYWNrYWdlZDogZmFsc2UsXFxuXFx0ICAgIHdvcmtlclBhdGg6IG51bGwsXFxuXFx0ICAgIG1vZGVQYXRoOiBudWxsLFxcblxcdCAgICB0aGVtZVBhdGg6IG51bGwsXFxuXFx0ICAgIGJhc2VQYXRoOiBcXFwiXFxcIixcXG5cXHQgICAgc3VmZml4OiBcXFwiLmpzXFxcIixcXG5cXHQgICAgJG1vZHVsZVVybHM6IHt9XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmdldCA9IGZ1bmN0aW9uKGtleSkge1xcblxcdCAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVW5rbm93biBjb25maWcga2V5OiBcXFwiICsga2V5KTtcXG5cXG5cXHQgICAgcmV0dXJuIG9wdGlvbnNba2V5XTtcXG5cXHR9O1xcblxcblxcdGV4cG9ydHMuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcblxcdCAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVW5rbm93biBjb25maWcga2V5OiBcXFwiICsga2V5KTtcXG5cXG5cXHQgICAgb3B0aW9uc1trZXldID0gdmFsdWU7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLmFsbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICByZXR1cm4gbGFuZy5jb3B5T2JqZWN0KG9wdGlvbnMpO1xcblxcdH07XFxuXFx0b29wLmltcGxlbWVudChleHBvcnRzLCBFdmVudEVtaXR0ZXIpO1xcblxcblxcdGV4cG9ydHMubW9kdWxlVXJsID0gZnVuY3Rpb24obmFtZSwgY29tcG9uZW50KSB7XFxuXFx0ICAgIGlmIChvcHRpb25zLiRtb2R1bGVVcmxzW25hbWVdKVxcblxcdCAgICAgICAgcmV0dXJuIG9wdGlvbnMuJG1vZHVsZVVybHNbbmFtZV07XFxuXFxuXFx0ICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoXFxcIi9cXFwiKTtcXG5cXHQgICAgY29tcG9uZW50ID0gY29tcG9uZW50IHx8IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdIHx8IFxcXCJcXFwiO1xcblxcdCAgICB2YXIgc2VwID0gY29tcG9uZW50ID09IFxcXCJzbmlwcGV0c1xcXCIgPyBcXFwiL1xcXCIgOiBcXFwiLVxcXCI7XFxuXFx0ICAgIHZhciBiYXNlID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XFxuXFx0ICAgIGlmIChjb21wb25lbnQgPT0gXFxcIndvcmtlclxcXCIgJiYgc2VwID09IFxcXCItXFxcIikge1xcblxcdCAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBjb21wb25lbnQgKyBcXFwiW1xcXFxcXFxcLV9dfFtcXFxcXFxcXC1fXVxcXCIgKyBjb21wb25lbnQgKyBcXFwiJFxcXCIsIFxcXCJnXFxcIik7XFxuXFx0ICAgICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKHJlLCBcXFwiXFxcIik7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKCghYmFzZSB8fCBiYXNlID09IGNvbXBvbmVudCkgJiYgcGFydHMubGVuZ3RoID4gMSlcXG5cXHQgICAgICAgIGJhc2UgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXTtcXG5cXHQgICAgdmFyIHBhdGggPSBvcHRpb25zW2NvbXBvbmVudCArIFxcXCJQYXRoXFxcIl07XFxuXFx0ICAgIGlmIChwYXRoID09IG51bGwpIHtcXG5cXHQgICAgICAgIHBhdGggPSBvcHRpb25zLmJhc2VQYXRoO1xcblxcdCAgICB9IGVsc2UgaWYgKHNlcCA9PSBcXFwiL1xcXCIpIHtcXG5cXHQgICAgICAgIGNvbXBvbmVudCA9IHNlcCA9IFxcXCJcXFwiO1xcblxcdCAgICB9XFxuXFx0ICAgIGlmIChwYXRoICYmIHBhdGguc2xpY2UoLTEpICE9IFxcXCIvXFxcIilcXG5cXHQgICAgICAgIHBhdGggKz0gXFxcIi9cXFwiO1xcblxcdCAgICByZXR1cm4gcGF0aCArIGNvbXBvbmVudCArIHNlcCArIGJhc2UgKyB0aGlzLmdldChcXFwic3VmZml4XFxcIik7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLnNldE1vZHVsZVVybCA9IGZ1bmN0aW9uKG5hbWUsIHN1YnN0KSB7XFxuXFx0ICAgIHJldHVybiBvcHRpb25zLiRtb2R1bGVVcmxzW25hbWVdID0gc3Vic3Q7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLiRsb2FkaW5nID0ge307XFxuXFx0ZXhwb3J0cy5sb2FkTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlTmFtZSwgb25Mb2FkKSB7XFxuXFx0ICAgIHZhciBtb2R1bGUsIG1vZHVsZVR5cGU7XFxuXFx0ICAgIGlmIChBcnJheS5pc0FycmF5KG1vZHVsZU5hbWUpKSB7XFxuXFx0ICAgICAgICBtb2R1bGVUeXBlID0gbW9kdWxlTmFtZVswXTtcXG5cXHQgICAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lWzFdO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHRyeSB7XFxuXFx0ICAgICAgICBtb2R1bGUgPSBhY2VxdWlyZShtb2R1bGVOYW1lKTtcXG5cXHQgICAgfSBjYXRjaCAoZSkge31cXG5cXHQgICAgaWYgKG1vZHVsZSAmJiAhZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSlcXG5cXHQgICAgICAgIHJldHVybiBvbkxvYWQgJiYgb25Mb2FkKG1vZHVsZSk7XFxuXFxuXFx0ICAgIGlmICghZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXSlcXG5cXHQgICAgICAgIGV4cG9ydHMuJGxvYWRpbmdbbW9kdWxlTmFtZV0gPSBbXTtcXG5cXG5cXHQgICAgZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXS5wdXNoKG9uTG9hZCk7XFxuXFxuXFx0ICAgIGlmIChleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdLmxlbmd0aCA+IDEpXFxuXFx0ICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgIHZhciBhZnRlckxvYWQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGFjZXF1aXJlKFttb2R1bGVOYW1lXSwgZnVuY3Rpb24obW9kdWxlKSB7XFxuXFx0ICAgICAgICAgICAgZXhwb3J0cy5fZW1pdChcXFwibG9hZC5tb2R1bGVcXFwiLCB7bmFtZTogbW9kdWxlTmFtZSwgbW9kdWxlOiBtb2R1bGV9KTtcXG5cXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gZXhwb3J0cy4kbG9hZGluZ1ttb2R1bGVOYW1lXTtcXG5cXHQgICAgICAgICAgICBleHBvcnRzLiRsb2FkaW5nW21vZHVsZU5hbWVdID0gbnVsbDtcXG5cXHQgICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihvbkxvYWQpIHtcXG5cXHQgICAgICAgICAgICAgICAgb25Mb2FkICYmIG9uTG9hZChtb2R1bGUpO1xcblxcdCAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIGlmICghZXhwb3J0cy5nZXQoXFxcInBhY2thZ2VkXFxcIikpXFxuXFx0ICAgICAgICByZXR1cm4gYWZ0ZXJMb2FkKCk7XFxuXFx0ICAgIG5ldC5sb2FkU2NyaXB0KGV4cG9ydHMubW9kdWxlVXJsKG1vZHVsZU5hbWUsIG1vZHVsZVR5cGUpLCBhZnRlckxvYWQpO1xcblxcdH07XFxuXFx0aW5pdCh0cnVlKTtmdW5jdGlvbiBpbml0KHBhY2thZ2VkKSB7XFxuXFxuXFx0ICAgIG9wdGlvbnMucGFja2FnZWQgPSBwYWNrYWdlZCB8fCBhY2VxdWlyZS5wYWNrYWdlZCB8fCBtb2R1bGUucGFja2FnZWQgfHwgKGdsb2JhbC5kZWZpbmUgJiYgX193ZWJwYWNrX3JlcXVpcmVfXygxOCkucGFja2FnZWQpO1xcblxcblxcdCAgICBpZiAoIWdsb2JhbC5kb2N1bWVudClcXG5cXHQgICAgICAgIHJldHVybiBcXFwiXFxcIjtcXG5cXG5cXHQgICAgdmFyIHNjcmlwdE9wdGlvbnMgPSB7fTtcXG5cXHQgICAgdmFyIHNjcmlwdFVybCA9IFxcXCJcXFwiO1xcblxcdCAgICB2YXIgY3VycmVudFNjcmlwdCA9IChkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IGRvY3VtZW50Ll9jdXJyZW50U2NyaXB0ICk7IC8vIG5hdGl2ZSBvciBwb2x5ZmlsbFxcblxcdCAgICB2YXIgY3VycmVudERvY3VtZW50ID0gY3VycmVudFNjcmlwdCAmJiBjdXJyZW50U2NyaXB0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XFxuXFx0ICAgIFxcblxcdCAgICB2YXIgc2NyaXB0cyA9IGN1cnJlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwic2NyaXB0XFxcIik7XFxuXFx0ICAgIGZvciAodmFyIGk9MDsgaTxzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0c1tpXTtcXG5cXG5cXHQgICAgICAgIHZhciBzcmMgPSBzY3JpcHQuc3JjIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXFxcInNyY1xcXCIpO1xcblxcdCAgICAgICAgaWYgKCFzcmMpXFxuXFx0ICAgICAgICAgICAgY29udGludWU7XFxuXFxuXFx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHNjcmlwdC5hdHRyaWJ1dGVzO1xcblxcdCAgICAgICAgZm9yICh2YXIgaj0wLCBsPWF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2pdO1xcblxcdCAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuaW5kZXhPZihcXFwiZGF0YS1hY2UtXFxcIikgPT09IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgc2NyaXB0T3B0aW9uc1tkZUh5cGhlbmF0ZShhdHRyLm5hbWUucmVwbGFjZSgvXmRhdGEtYWNlLS8sIFxcXCJcXFwiKSldID0gYXR0ci52YWx1ZTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgbSA9IHNyYy5tYXRjaCgvXiguKilcXFxcL2FjZShcXFxcLVxcXFx3Kyk/XFxcXC5qcyhcXFxcP3wkKS8pO1xcblxcdCAgICAgICAgaWYgKG0pXFxuXFx0ICAgICAgICAgICAgc2NyaXB0VXJsID0gbVsxXTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAoc2NyaXB0VXJsKSB7XFxuXFx0ICAgICAgICBzY3JpcHRPcHRpb25zLmJhc2UgPSBzY3JpcHRPcHRpb25zLmJhc2UgfHwgc2NyaXB0VXJsO1xcblxcdCAgICAgICAgc2NyaXB0T3B0aW9ucy5wYWNrYWdlZCA9IHRydWU7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgc2NyaXB0T3B0aW9ucy5iYXNlUGF0aCA9IHNjcmlwdE9wdGlvbnMuYmFzZTtcXG5cXHQgICAgc2NyaXB0T3B0aW9ucy53b3JrZXJQYXRoID0gc2NyaXB0T3B0aW9ucy53b3JrZXJQYXRoIHx8IHNjcmlwdE9wdGlvbnMuYmFzZTtcXG5cXHQgICAgc2NyaXB0T3B0aW9ucy5tb2RlUGF0aCA9IHNjcmlwdE9wdGlvbnMubW9kZVBhdGggfHwgc2NyaXB0T3B0aW9ucy5iYXNlO1xcblxcdCAgICBzY3JpcHRPcHRpb25zLnRoZW1lUGF0aCA9IHNjcmlwdE9wdGlvbnMudGhlbWVQYXRoIHx8IHNjcmlwdE9wdGlvbnMuYmFzZTtcXG5cXHQgICAgZGVsZXRlIHNjcmlwdE9wdGlvbnMuYmFzZTtcXG5cXG5cXHQgICAgZm9yICh2YXIga2V5IGluIHNjcmlwdE9wdGlvbnMpXFxuXFx0ICAgICAgICBpZiAodHlwZW9mIHNjcmlwdE9wdGlvbnNba2V5XSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpXFxuXFx0ICAgICAgICAgICAgZXhwb3J0cy5zZXQoa2V5LCBzY3JpcHRPcHRpb25zW2tleV0pO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5pbml0ID0gaW5pdDtcXG5cXG5cXHRmdW5jdGlvbiBkZUh5cGhlbmF0ZShzdHIpIHtcXG5cXHQgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKG0sIG0xKSB7IHJldHVybiBtMS50b1VwcGVyQ2FzZSgpOyB9KTtcXG5cXHR9XFxuXFxuXFx0dmFyIG9wdGlvbnNQcm92aWRlciA9IHtcXG5cXHQgICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0TGlzdCkge1xcblxcdCAgICAgICAgT2JqZWN0LmtleXMob3B0TGlzdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNldE9wdGlvbihrZXksIG9wdExpc3Rba2V5XSk7XFxuXFx0ICAgICAgICB9LCB0aGlzKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgZ2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9uTmFtZXMpIHtcXG5cXHQgICAgICAgIHZhciByZXN1bHQgPSB7fTtcXG5cXHQgICAgICAgIGlmICghb3B0aW9uTmFtZXMpIHtcXG5cXHQgICAgICAgICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuJG9wdGlvbnMpO1xcblxcdCAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25OYW1lcykpIHtcXG5cXHQgICAgICAgICAgICByZXN1bHQgPSBvcHRpb25OYW1lcztcXG5cXHQgICAgICAgICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKHJlc3VsdCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBvcHRpb25OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcblxcdCAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5nZXRPcHRpb24oa2V5KTtcXG5cXHQgICAgICAgIH0sIHRoaXMpO1xcblxcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG5cXHQgICAgfSxcXG5cXHQgICAgc2V0T3B0aW9uOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xcblxcdCAgICAgICAgaWYgKHRoaXNbXFxcIiRcXFwiICsgbmFtZV0gPT09IHZhbHVlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBvcHQgPSB0aGlzLiRvcHRpb25zW25hbWVdO1xcblxcdCAgICAgICAgaWYgKCFvcHQpIHtcXG5cXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgY29uc29sZS53YXJuKVxcblxcdCAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ21pc3NwZWxsZWQgb3B0aW9uIFxcXCInICsgbmFtZSArICdcXFwiJyk7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChvcHQuZm9yd2FyZFRvKVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzW29wdC5mb3J3YXJkVG9dICYmIHRoaXNbb3B0LmZvcndhcmRUb10uc2V0T3B0aW9uKG5hbWUsIHZhbHVlKTtcXG5cXG5cXHQgICAgICAgIGlmICghb3B0LmhhbmRsZXNTZXQpXFxuXFx0ICAgICAgICAgICAgdGhpc1tcXFwiJFxcXCIgKyBuYW1lXSA9IHZhbHVlO1xcblxcdCAgICAgICAgaWYgKG9wdCAmJiBvcHQuc2V0KVxcblxcdCAgICAgICAgICAgIG9wdC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIGdldE9wdGlvbjogZnVuY3Rpb24obmFtZSkge1xcblxcdCAgICAgICAgdmFyIG9wdCA9IHRoaXMuJG9wdGlvbnNbbmFtZV07XFxuXFx0ICAgICAgICBpZiAoIW9wdCkge1xcblxcdCAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjb25zb2xlLndhcm4pXFxuXFx0ICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignbWlzc3BlbGxlZCBvcHRpb24gXFxcIicgKyBuYW1lICsgJ1xcXCInKTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKG9wdC5mb3J3YXJkVG8pXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXNbb3B0LmZvcndhcmRUb10gJiYgdGhpc1tvcHQuZm9yd2FyZFRvXS5nZXRPcHRpb24obmFtZSk7XFxuXFx0ICAgICAgICByZXR1cm4gb3B0ICYmIG9wdC5nZXQgPyBvcHQuZ2V0LmNhbGwodGhpcykgOiB0aGlzW1xcXCIkXFxcIiArIG5hbWVdO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcXG5cXHRleHBvcnRzLmRlZmluZU9wdGlvbnMgPSBmdW5jdGlvbihvYmosIHBhdGgsIG9wdGlvbnMpIHtcXG5cXHQgICAgaWYgKCFvYmouJG9wdGlvbnMpXFxuXFx0ICAgICAgICBkZWZhdWx0T3B0aW9uc1twYXRoXSA9IG9iai4kb3B0aW9ucyA9IHt9O1xcblxcblxcdCAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcblxcdCAgICAgICAgdmFyIG9wdCA9IG9wdGlvbnNba2V5XTtcXG5cXHQgICAgICAgIGlmICh0eXBlb2Ygb3B0ID09IFxcXCJzdHJpbmdcXFwiKVxcblxcdCAgICAgICAgICAgIG9wdCA9IHtmb3J3YXJkVG86IG9wdH07XFxuXFxuXFx0ICAgICAgICBvcHQubmFtZSB8fCAob3B0Lm5hbWUgPSBrZXkpO1xcblxcdCAgICAgICAgb2JqLiRvcHRpb25zW29wdC5uYW1lXSA9IG9wdDtcXG5cXHQgICAgICAgIGlmIChcXFwiaW5pdGlhbFZhbHVlXFxcIiBpbiBvcHQpXFxuXFx0ICAgICAgICAgICAgb2JqW1xcXCIkXFxcIiArIG9wdC5uYW1lXSA9IG9wdC5pbml0aWFsVmFsdWU7XFxuXFx0ICAgIH0pO1xcblxcdCAgICBvb3AuaW1wbGVtZW50KG9iaiwgb3B0aW9uc1Byb3ZpZGVyKTtcXG5cXG5cXHQgICAgcmV0dXJuIHRoaXM7XFxuXFx0fTtcXG5cXG5cXHRleHBvcnRzLnJlc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9iaikge1xcblxcdCAgICBPYmplY3Qua2V5cyhvYmouJG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XFxuXFx0ICAgICAgICB2YXIgb3B0ID0gb2JqLiRvcHRpb25zW2tleV07XFxuXFx0ICAgICAgICBpZiAoXFxcInZhbHVlXFxcIiBpbiBvcHQpXFxuXFx0ICAgICAgICAgICAgb2JqLnNldE9wdGlvbihrZXksIG9wdC52YWx1ZSk7XFxuXFx0ICAgIH0pO1xcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5zZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbihwYXRoLCBuYW1lLCB2YWx1ZSkge1xcblxcdCAgICB2YXIgb3B0cyA9IGRlZmF1bHRPcHRpb25zW3BhdGhdIHx8IChkZWZhdWx0T3B0aW9uc1twYXRoXSA9IHt9KTtcXG5cXHQgICAgaWYgKG9wdHNbbmFtZV0pIHtcXG5cXHQgICAgICAgIGlmIChvcHRzLmZvcndhcmRUbylcXG5cXHQgICAgICAgICAgICBleHBvcnRzLnNldERlZmF1bHRWYWx1ZShvcHRzLmZvcndhcmRUbywgbmFtZSwgdmFsdWUpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIG9wdHNbbmFtZV0udmFsdWUgPSB2YWx1ZTtcXG5cXHQgICAgfVxcblxcdH07XFxuXFxuXFx0ZXhwb3J0cy5zZXREZWZhdWx0VmFsdWVzID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9uSGFzaCkge1xcblxcdCAgICBPYmplY3Qua2V5cyhvcHRpb25IYXNoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcblxcdCAgICAgICAgZXhwb3J0cy5zZXREZWZhdWx0VmFsdWUocGF0aCwga2V5LCBvcHRpb25IYXNoW2tleV0pO1xcblxcdCAgICB9KTtcXG5cXHR9O1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb3VzZS9tb3VzZV9oYW5kbGVyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCIsXFxcImFjZS9saWIvdXNlcmFnZW50XFxcIixcXFwiYWNlL21vdXNlL2RlZmF1bHRfaGFuZGxlcnNcXFwiLFxcXCJhY2UvbW91c2UvZGVmYXVsdF9ndXR0ZXJfaGFuZGxlclxcXCIsXFxcImFjZS9tb3VzZS9tb3VzZV9ldmVudFxcXCIsXFxcImFjZS9tb3VzZS9kcmFnZHJvcF9oYW5kbGVyXFxcIixcXFwiYWNlL2NvbmZpZ1xcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRcXFwiKTtcXG5cXHR2YXIgdXNlcmFnZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi91c2VyYWdlbnRcXFwiKTtcXG5cXHR2YXIgRGVmYXVsdEhhbmRsZXJzID0gYWNlcXVpcmUoXFxcIi4vZGVmYXVsdF9oYW5kbGVyc1xcXCIpLkRlZmF1bHRIYW5kbGVycztcXG5cXHR2YXIgRGVmYXVsdEd1dHRlckhhbmRsZXIgPSBhY2VxdWlyZShcXFwiLi9kZWZhdWx0X2d1dHRlcl9oYW5kbGVyXFxcIikuR3V0dGVySGFuZGxlcjtcXG5cXHR2YXIgTW91c2VFdmVudCA9IGFjZXF1aXJlKFxcXCIuL21vdXNlX2V2ZW50XFxcIikuTW91c2VFdmVudDtcXG5cXHR2YXIgRHJhZ2Ryb3BIYW5kbGVyID0gYWNlcXVpcmUoXFxcIi4vZHJhZ2Ryb3BfaGFuZGxlclxcXCIpLkRyYWdkcm9wSGFuZGxlcjtcXG5cXHR2YXIgY29uZmlnID0gYWNlcXVpcmUoXFxcIi4uL2NvbmZpZ1xcXCIpO1xcblxcblxcdHZhciBNb3VzZUhhbmRsZXIgPSBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgdmFyIF9zZWxmID0gdGhpcztcXG5cXHQgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XFxuXFxuXFx0ICAgIG5ldyBEZWZhdWx0SGFuZGxlcnModGhpcyk7XFxuXFx0ICAgIG5ldyBEZWZhdWx0R3V0dGVySGFuZGxlcih0aGlzKTtcXG5cXHQgICAgbmV3IERyYWdkcm9wSGFuZGxlcih0aGlzKTtcXG5cXHQgICAgXFxuXFx0ICAgIHZhciBmb2N1c0VkaXRvciA9IGZ1bmN0aW9uKGUpIHsgXFxuXFx0ICAgICAgICBpZiAoIWVkaXRvci5pc0ZvY3VzZWQoKSAmJiBlZGl0b3IudGV4dElucHV0KVxcblxcdCAgICAgICAgICAgIGVkaXRvci50ZXh0SW5wdXQubW92ZVRvTW91c2UoZSk7XFxuXFx0ICAgICAgICBlZGl0b3IuZm9jdXMoKSBcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHZhciBtb3VzZVRhcmdldCA9IGVkaXRvci5yZW5kZXJlci5nZXRNb3VzZUV2ZW50VGFyZ2V0KCk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcXFwiY2xpY2tcXFwiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFxcXCJjbGlja1xcXCIpKTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIobW91c2VUYXJnZXQsIFxcXCJtb3VzZW1vdmVcXFwiLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcywgXFxcIm1vdXNlbW92ZVxcXCIpKTtcXG5cXHQgICAgZXZlbnQuYWRkTXVsdGlNb3VzZURvd25MaXN0ZW5lcihtb3VzZVRhcmdldCwgWzQwMCwgMzAwLCAyNTBdLCB0aGlzLCBcXFwib25Nb3VzZUV2ZW50XFxcIik7XFxuXFx0ICAgIGlmIChlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFyVikge1xcblxcdCAgICAgICAgZXZlbnQuYWRkTXVsdGlNb3VzZURvd25MaXN0ZW5lcihlZGl0b3IucmVuZGVyZXIuc2Nyb2xsQmFyVi5pbm5lciwgWzQwMCwgMzAwLCAyNTBdLCB0aGlzLCBcXFwib25Nb3VzZUV2ZW50XFxcIik7XFxuXFx0ICAgICAgICBldmVudC5hZGRNdWx0aU1vdXNlRG93bkxpc3RlbmVyKGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJILmlubmVyLCBbNDAwLCAzMDAsIDI1MF0sIHRoaXMsIFxcXCJvbk1vdXNlRXZlbnRcXFwiKTtcXG5cXHQgICAgICAgIGlmICh1c2VyYWdlbnQuaXNJRSkge1xcblxcdCAgICAgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKGVkaXRvci5yZW5kZXJlci5zY3JvbGxCYXJWLmVsZW1lbnQsIFxcXCJtb3VzZWRvd25cXFwiLCBmb2N1c0VkaXRvcik7XFxuXFx0ICAgICAgICAgICAgZXZlbnQuYWRkTGlzdGVuZXIoZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEJhckguZWxlbWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIGZvY3VzRWRpdG9yKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBldmVudC5hZGRNb3VzZVdoZWVsTGlzdGVuZXIoZWRpdG9yLmNvbnRhaW5lciwgdGhpcy5vbk1vdXNlV2hlZWwuYmluZCh0aGlzLCBcXFwibW91c2V3aGVlbFxcXCIpKTtcXG5cXG5cXHQgICAgdmFyIGd1dHRlckVsID0gZWRpdG9yLnJlbmRlcmVyLiRndXR0ZXI7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKGd1dHRlckVsLCBcXFwibW91c2Vkb3duXFxcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcXFwiZ3V0dGVybW91c2Vkb3duXFxcIikpO1xcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXFxcImNsaWNrXFxcIiwgdGhpcy5vbk1vdXNlRXZlbnQuYmluZCh0aGlzLCBcXFwiZ3V0dGVyY2xpY2tcXFwiKSk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKGd1dHRlckVsLCBcXFwiZGJsY2xpY2tcXFwiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFxcXCJndXR0ZXJkYmxjbGlja1xcXCIpKTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIoZ3V0dGVyRWwsIFxcXCJtb3VzZW1vdmVcXFwiLCB0aGlzLm9uTW91c2VFdmVudC5iaW5kKHRoaXMsIFxcXCJndXR0ZXJtb3VzZW1vdmVcXFwiKSk7XFxuXFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKG1vdXNlVGFyZ2V0LCBcXFwibW91c2Vkb3duXFxcIiwgZm9jdXNFZGl0b3IpO1xcblxcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcihndXR0ZXJFbCwgXFxcIm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGVkaXRvci5mb2N1cygpO1xcblxcdCAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgZWRpdG9yLm9uKFxcXCJtb3VzZW1vdmVcXFwiLCBmdW5jdGlvbihlKXtcXG5cXHQgICAgICAgIGlmIChfc2VsZi5zdGF0ZSB8fCBfc2VsZi4kZHJhZ0RlbGF5IHx8ICFfc2VsZi4kZHJhZ0VuYWJsZWQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgY2hhciA9IGVkaXRvci5yZW5kZXJlci5zY3JlZW5Ub1RleHRDb29yZGluYXRlcyhlLngsIGUueSk7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3Iuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcXG5cXHQgICAgICAgIHZhciByZW5kZXJlciA9IGVkaXRvci5yZW5kZXJlcjtcXG5cXG5cXHQgICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpICYmIHJhbmdlLmluc2lkZVN0YXJ0KGNoYXIucm93LCBjaGFyLmNvbHVtbikpIHtcXG5cXHQgICAgICAgICAgICByZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcXFwiZGVmYXVsdFxcXCIpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZW5kZXJlci5zZXRDdXJzb3JTdHlsZShcXFwiXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH0pO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLm9uTW91c2VFdmVudCA9IGZ1bmN0aW9uKG5hbWUsIGUpIHtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLl9lbWl0KG5hbWUsIG5ldyBNb3VzZUV2ZW50KGUsIHRoaXMuZWRpdG9yKSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihuYW1lLCBlKSB7XFxuXFx0ICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5lZGl0b3IuX2V2ZW50UmVnaXN0cnkgJiYgdGhpcy5lZGl0b3IuX2V2ZW50UmVnaXN0cnkubW91c2Vtb3ZlO1xcblxcdCAgICAgICAgaWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdGhpcy5lZGl0b3IuX2VtaXQobmFtZSwgbmV3IE1vdXNlRXZlbnQoZSwgdGhpcy5lZGl0b3IpKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vbk1vdXNlV2hlZWwgPSBmdW5jdGlvbihuYW1lLCBlKSB7XFxuXFx0ICAgICAgICB2YXIgbW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KGUsIHRoaXMuZWRpdG9yKTtcXG5cXHQgICAgICAgIG1vdXNlRXZlbnQuc3BlZWQgPSB0aGlzLiRzY3JvbGxTcGVlZCAqIDI7XFxuXFx0ICAgICAgICBtb3VzZUV2ZW50LndoZWVsWCA9IGUud2hlZWxYO1xcblxcdCAgICAgICAgbW91c2VFdmVudC53aGVlbFkgPSBlLndoZWVsWTtcXG5cXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLl9lbWl0KG5hbWUsIG1vdXNlRXZlbnQpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcXG5cXHQgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jYXB0dXJlTW91c2UgPSBmdW5jdGlvbihldiwgbW91c2VNb3ZlSGFuZGxlcikge1xcblxcdCAgICAgICAgdGhpcy54ID0gZXYueDtcXG5cXHQgICAgICAgIHRoaXMueSA9IGV2Lnk7XFxuXFxuXFx0ICAgICAgICB0aGlzLmlzTW91c2VQcmVzc2VkID0gdHJ1ZTtcXG5cXHQgICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZWRpdG9yLnJlbmRlcmVyO1xcblxcdCAgICAgICAgaWYgKHJlbmRlcmVyLiRrZWVwVGV4dEFyZWFBdEN1cnNvcilcXG5cXHQgICAgICAgICAgICByZW5kZXJlci4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSBudWxsO1xcblxcblxcdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcdCAgICAgICAgdmFyIG9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIGlmICghZSkgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIGlmICh1c2VyYWdlbnQuaXNXZWJLaXQgJiYgIWUud2hpY2ggJiYgc2VsZi5yZWxlYXNlTW91c2UpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJlbGVhc2VNb3VzZSgpO1xcblxcblxcdCAgICAgICAgICAgIHNlbGYueCA9IGUuY2xpZW50WDtcXG5cXHQgICAgICAgICAgICBzZWxmLnkgPSBlLmNsaWVudFk7XFxuXFx0ICAgICAgICAgICAgbW91c2VNb3ZlSGFuZGxlciAmJiBtb3VzZU1vdmVIYW5kbGVyKGUpO1xcblxcdCAgICAgICAgICAgIHNlbGYubW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KGUsIHNlbGYuZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICBzZWxmLiRtb3VzZU1vdmVkID0gdHJ1ZTtcXG5cXHQgICAgICAgIH07XFxuXFxuXFx0ICAgICAgICB2YXIgb25DYXB0dXJlRW5kID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XFxuXFx0ICAgICAgICAgICAgb25DYXB0dXJlSW50ZXJ2YWwoKTtcXG5cXHQgICAgICAgICAgICBzZWxmW3NlbGYuc3RhdGUgKyBcXFwiRW5kXFxcIl0gJiYgc2VsZltzZWxmLnN0YXRlICsgXFxcIkVuZFxcXCJdKGUpO1xcblxcdCAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcXFwiXFxcIjtcXG5cXHQgICAgICAgICAgICBpZiAocmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID09IG51bGwpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmVuZGVyZXIuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICAgICAgcmVuZGVyZXIuJG1vdmVUZXh0QXJlYVRvQ3Vyc29yKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHNlbGYuaXNNb3VzZVByZXNzZWQgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICBzZWxmLiRvbkNhcHR1cmVNb3VzZU1vdmUgPSBzZWxmLnJlbGVhc2VNb3VzZSA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgZSAmJiBzZWxmLm9uTW91c2VFdmVudChcXFwibW91c2V1cFxcXCIsIGUpO1xcblxcdCAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgIHZhciBvbkNhcHR1cmVJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIHNlbGZbc2VsZi5zdGF0ZV0gJiYgc2VsZltzZWxmLnN0YXRlXSgpO1xcblxcdCAgICAgICAgICAgIHNlbGYuJG1vdXNlTW92ZWQgPSBmYWxzZTtcXG5cXHQgICAgICAgIH07XFxuXFxuXFx0ICAgICAgICBpZiAodXNlcmFnZW50LmlzT2xkSUUgJiYgZXYuZG9tRXZlbnQudHlwZSA9PSBcXFwiZGJsY2xpY2tcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7b25DYXB0dXJlRW5kKGV2KTt9KTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHNlbGYuJG9uQ2FwdHVyZU1vdXNlTW92ZSA9IG9uTW91c2VNb3ZlO1xcblxcdCAgICAgICAgc2VsZi5yZWxlYXNlTW91c2UgPSBldmVudC5jYXB0dXJlKHRoaXMuZWRpdG9yLmNvbnRhaW5lciwgb25Nb3VzZU1vdmUsIG9uQ2FwdHVyZUVuZCk7XFxuXFx0ICAgICAgICB2YXIgdGltZXJJZCA9IHNldEludGVydmFsKG9uQ2FwdHVyZUludGVydmFsLCAyMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVsZWFzZU1vdXNlID0gbnVsbDtcXG5cXHQgICAgdGhpcy5jYW5jZWxDb250ZXh0TWVudSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGUgJiYgZS5kb21FdmVudCAmJiBlLmRvbUV2ZW50LnR5cGUgIT0gXFxcImNvbnRleHRtZW51XFxcIilcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9mZihcXFwibmF0aXZlY29udGV4dG1lbnVcXFwiLCBzdG9wKTtcXG5cXHQgICAgICAgICAgICBpZiAoZSAmJiBlLmRvbUV2ZW50KVxcblxcdCAgICAgICAgICAgICAgICBldmVudC5zdG9wRXZlbnQoZS5kb21FdmVudCk7XFxuXFx0ICAgICAgICB9LmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICBzZXRUaW1lb3V0KHN0b3AsIDEwKTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLm9uKFxcXCJuYXRpdmVjb250ZXh0bWVudVxcXCIsIHN0b3ApO1xcblxcdCAgICB9O1xcblxcdH0pLmNhbGwoTW91c2VIYW5kbGVyLnByb3RvdHlwZSk7XFxuXFxuXFx0Y29uZmlnLmRlZmluZU9wdGlvbnMoTW91c2VIYW5kbGVyLnByb3RvdHlwZSwgXFxcIm1vdXNlSGFuZGxlclxcXCIsIHtcXG5cXHQgICAgc2Nyb2xsU3BlZWQ6IHtpbml0aWFsVmFsdWU6IDJ9LFxcblxcdCAgICBkcmFnRGVsYXk6IHtpbml0aWFsVmFsdWU6ICh1c2VyYWdlbnQuaXNNYWMgPyAxNTAgOiAwKX0sXFxuXFx0ICAgIGRyYWdFbmFibGVkOiB7aW5pdGlhbFZhbHVlOiB0cnVlfSxcXG5cXHQgICAgZm9jdXNUaW1vdXQ6IHtpbml0aWFsVmFsdWU6IDB9LFxcblxcdCAgICB0b29sdGlwRm9sbG93c01vdXNlOiB7aW5pdGlhbFZhbHVlOiB0cnVlfVxcblxcdH0pO1xcblxcblxcblxcdGV4cG9ydHMuTW91c2VIYW5kbGVyID0gTW91c2VIYW5kbGVyO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb3VzZS9mb2xkX2hhbmRsZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRmdW5jdGlvbiBGb2xkSGFuZGxlcihlZGl0b3IpIHtcXG5cXG5cXHQgICAgZWRpdG9yLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHZhciBwb3NpdGlvbiA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpO1xcblxcdCAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcXG5cXHQgICAgICAgIHZhciBmb2xkID0gc2Vzc2lvbi5nZXRGb2xkQXQocG9zaXRpb24ucm93LCBwb3NpdGlvbi5jb2x1bW4sIDEpO1xcblxcdCAgICAgICAgaWYgKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICBpZiAoZS5nZXRBY2NlbEtleSgpKVxcblxcdCAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUZvbGQoZm9sZCk7XFxuXFx0ICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICBzZXNzaW9uLmV4cGFuZEZvbGQoZm9sZCk7XFxuXFxuXFx0ICAgICAgICAgICAgZS5zdG9wKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICBlZGl0b3Iub24oXFxcImd1dHRlcmNsaWNrXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGd1dHRlclJlZ2lvbiA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuZ2V0UmVnaW9uKGUpO1xcblxcblxcdCAgICAgICAgaWYgKGd1dHRlclJlZ2lvbiA9PSBcXFwiZm9sZFdpZGdldHNcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvdyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xcblxcdCAgICAgICAgICAgIGlmIChzZXNzaW9uLmZvbGRXaWRnZXRzICYmIHNlc3Npb24uZm9sZFdpZGdldHNbcm93XSlcXG5cXHQgICAgICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ub25Gb2xkV2lkZ2V0Q2xpY2socm93LCBlKTtcXG5cXHQgICAgICAgICAgICBpZiAoIWVkaXRvci5pc0ZvY3VzZWQoKSlcXG5cXHQgICAgICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XFxuXFx0ICAgICAgICAgICAgZS5zdG9wKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICBlZGl0b3Iub24oXFxcImd1dHRlcmRibGNsaWNrXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGd1dHRlclJlZ2lvbiA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuZ2V0UmVnaW9uKGUpO1xcblxcblxcdCAgICAgICAgaWYgKGd1dHRlclJlZ2lvbiA9PSBcXFwiZm9sZFdpZGdldHNcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvdyA9IGUuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xcblxcdCAgICAgICAgICAgIHZhciBkYXRhID0gc2Vzc2lvbi5nZXRQYXJlbnRGb2xkUmFuZ2VEYXRhKHJvdywgdHJ1ZSk7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gZGF0YS5yYW5nZSB8fCBkYXRhLmZpcnN0UmFuZ2U7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGZvbGQgPSBzZXNzaW9uLmdldEZvbGRBdChyb3csIHNlc3Npb24uZ2V0TGluZShyb3cpLmxlbmd0aCwgMSk7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChmb2xkKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUZvbGQoZm9sZCk7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmFkZEZvbGQoXFxcIi4uLlxcXCIsIHJhbmdlKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyh7cm93OiByYW5nZS5zdGFydC5yb3csIGNvbHVtbjogMH0pO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGUuc3RvcCgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXHR9XFxuXFxuXFx0ZXhwb3J0cy5Gb2xkSGFuZGxlciA9IEZvbGRIYW5kbGVyO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9rZXlib2FyZC9rZXliaW5kaW5nXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9rZXlzXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBrZXlVdGlsICA9IGFjZXF1aXJlKFxcXCIuLi9saWIva2V5c1xcXCIpO1xcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRcXFwiKTtcXG5cXG5cXHR2YXIgS2V5QmluZGluZyA9IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICB0aGlzLiRlZGl0b3IgPSBlZGl0b3I7XFxuXFx0ICAgIHRoaXMuJGRhdGEgPSB7ZWRpdG9yOiBlZGl0b3J9O1xcblxcdCAgICB0aGlzLiRoYW5kbGVycyA9IFtdO1xcblxcdCAgICB0aGlzLnNldERlZmF1bHRIYW5kbGVyKGVkaXRvci5jb21tYW5kcyk7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuc2V0RGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbihrYikge1xcblxcdCAgICAgICAgdGhpcy5yZW1vdmVLZXlib2FyZEhhbmRsZXIodGhpcy4kZGVmYXVsdEhhbmRsZXIpO1xcblxcdCAgICAgICAgdGhpcy4kZGVmYXVsdEhhbmRsZXIgPSBrYjtcXG5cXHQgICAgICAgIHRoaXMuYWRkS2V5Ym9hcmRIYW5kbGVyKGtiLCAwKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbihrYikge1xcblxcdCAgICAgICAgdmFyIGggPSB0aGlzLiRoYW5kbGVycztcXG5cXHQgICAgICAgIGlmIChoW2gubGVuZ3RoIC0gMV0gPT0ga2IpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgd2hpbGUgKGhbaC5sZW5ndGggLSAxXSAmJiBoW2gubGVuZ3RoIC0gMV0gIT0gdGhpcy4kZGVmYXVsdEhhbmRsZXIpXFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW1vdmVLZXlib2FyZEhhbmRsZXIoaFtoLmxlbmd0aCAtIDFdKTtcXG5cXG5cXHQgICAgICAgIHRoaXMuYWRkS2V5Ym9hcmRIYW5kbGVyKGtiLCAxKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hZGRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbihrYiwgcG9zKSB7XFxuXFx0ICAgICAgICBpZiAoIWtiKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIGlmICh0eXBlb2Yga2IgPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiAha2IuaGFuZGxlS2V5Ym9hcmQpXFxuXFx0ICAgICAgICAgICAga2IuaGFuZGxlS2V5Ym9hcmQgPSBrYjtcXG5cXHQgICAgICAgIHZhciBpID0gdGhpcy4kaGFuZGxlcnMuaW5kZXhPZihrYik7XFxuXFx0ICAgICAgICBpZiAoaSAhPSAtMSlcXG5cXHQgICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UoaSwgMSk7XFxuXFxuXFx0ICAgICAgICBpZiAocG9zID09IHVuZGVmaW5lZClcXG5cXHQgICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5wdXNoKGtiKTtcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UocG9zLCAwLCBrYik7XFxuXFxuXFx0ICAgICAgICBpZiAoaSA9PSAtMSAmJiBrYi5hdHRhY2gpXFxuXFx0ICAgICAgICAgICAga2IuYXR0YWNoKHRoaXMuJGVkaXRvcik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24oa2IpIHtcXG5cXHQgICAgICAgIHZhciBpID0gdGhpcy4kaGFuZGxlcnMuaW5kZXhPZihrYik7XFxuXFx0ICAgICAgICBpZiAoaSA9PSAtMSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgICAgICB0aGlzLiRoYW5kbGVycy5zcGxpY2UoaSwgMSk7XFxuXFx0ICAgICAgICBrYi5kZXRhY2ggJiYga2IuZGV0YWNoKHRoaXMuJGVkaXRvcik7XFxuXFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRLZXlib2FyZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRoYW5kbGVyc1t0aGlzLiRoYW5kbGVycy5sZW5ndGggLSAxXTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRTdGF0dXNUZXh0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgZGF0YSA9IHRoaXMuJGRhdGE7XFxuXFx0ICAgICAgICB2YXIgZWRpdG9yID0gZGF0YS5lZGl0b3I7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kaGFuZGxlcnMubWFwKGZ1bmN0aW9uKGgpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gaC5nZXRTdGF0dXNUZXh0ICYmIGguZ2V0U3RhdHVzVGV4dChlZGl0b3IsIGRhdGEpIHx8IFxcXCJcXFwiO1xcblxcdCAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXFxcIiBcXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kY2FsbEtleWJvYXJkSGFuZGxlcnMgPSBmdW5jdGlvbihoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSwgZSkge1xcblxcdCAgICAgICAgdmFyIHRvRXhlY3V0ZTtcXG5cXHQgICAgICAgIHZhciBzdWNjZXNzID0gZmFsc2U7XFxuXFx0ICAgICAgICB2YXIgY29tbWFuZHMgPSB0aGlzLiRlZGl0b3IuY29tbWFuZHM7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy4kaGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XFxuXFx0ICAgICAgICAgICAgdG9FeGVjdXRlID0gdGhpcy4kaGFuZGxlcnNbaV0uaGFuZGxlS2V5Ym9hcmQoXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGRhdGEsIGhhc2hJZCwga2V5U3RyaW5nLCBrZXlDb2RlLCBlXFxuXFx0ICAgICAgICAgICAgKTtcXG5cXHQgICAgICAgICAgICBpZiAoIXRvRXhlY3V0ZSB8fCAhdG9FeGVjdXRlLmNvbW1hbmQpXFxuXFx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcblxcdCAgICAgICAgICAgIGlmICh0b0V4ZWN1dGUuY29tbWFuZCA9PSBcXFwibnVsbFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGNvbW1hbmRzLmV4ZWModG9FeGVjdXRlLmNvbW1hbmQsIHRoaXMuJGVkaXRvciwgdG9FeGVjdXRlLmFyZ3MsIGUpOyAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgJiYgZSAmJiBoYXNoSWQgIT0gLTEgJiYgXFxuXFx0ICAgICAgICAgICAgICAgIHRvRXhlY3V0ZS5wYXNzRXZlbnQgIT0gdHJ1ZSAmJiB0b0V4ZWN1dGUuY29tbWFuZC5wYXNzRXZlbnQgIT0gdHJ1ZVxcblxcdCAgICAgICAgICAgICkge1xcblxcdCAgICAgICAgICAgICAgICBldmVudC5zdG9wRXZlbnQoZSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmIChzdWNjZXNzKVxcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBzdWNjZXNzO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uQ29tbWFuZEtleSA9IGZ1bmN0aW9uKGUsIGhhc2hJZCwga2V5Q29kZSkge1xcblxcdCAgICAgICAgdmFyIGtleVN0cmluZyA9IGtleVV0aWwua2V5Q29kZVRvU3RyaW5nKGtleUNvZGUpO1xcblxcdCAgICAgICAgdGhpcy4kY2FsbEtleWJvYXJkSGFuZGxlcnMoaGFzaElkLCBrZXlTdHJpbmcsIGtleUNvZGUsIGUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uVGV4dElucHV0ID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgdmFyIHN1Y2Nlc3MgPSB0aGlzLiRjYWxsS2V5Ym9hcmRIYW5kbGVycygtMSwgdGV4dCk7XFxuXFx0ICAgICAgICBpZiAoIXN1Y2Nlc3MpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kZWRpdG9yLmNvbW1hbmRzLmV4ZWMoXFxcImluc2VydHN0cmluZ1xcXCIsIHRoaXMuJGVkaXRvciwgdGV4dCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChLZXlCaW5kaW5nLnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5LZXlCaW5kaW5nID0gS2V5QmluZGluZztcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvcmFuZ2VcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHR2YXIgY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xcblxcdCAgICByZXR1cm4gcDEucm93IC0gcDIucm93IHx8IHAxLmNvbHVtbiAtIHAyLmNvbHVtbjtcXG5cXHR9O1xcblxcdHZhciBSYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgZW5kUm93LCBlbmRDb2x1bW4pIHtcXG5cXHQgICAgdGhpcy5zdGFydCA9IHtcXG5cXHQgICAgICAgIHJvdzogc3RhcnRSb3csXFxuXFx0ICAgICAgICBjb2x1bW46IHN0YXJ0Q29sdW1uXFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZW5kID0ge1xcblxcdCAgICAgICAgcm93OiBlbmRSb3csXFxuXFx0ICAgICAgICBjb2x1bW46IGVuZENvbHVtblxcblxcdCAgICB9O1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLmlzRXF1YWwgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQucm93ID09PSByYW5nZS5zdGFydC5yb3cgJiZcXG5cXHQgICAgICAgICAgICB0aGlzLmVuZC5yb3cgPT09IHJhbmdlLmVuZC5yb3cgJiZcXG5cXHQgICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9PT0gcmFuZ2Uuc3RhcnQuY29sdW1uICYmXFxuXFx0ICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID09PSByYW5nZS5lbmQuY29sdW1uO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gKFxcXCJSYW5nZTogW1xcXCIgKyB0aGlzLnN0YXJ0LnJvdyArIFxcXCIvXFxcIiArIHRoaXMuc3RhcnQuY29sdW1uICtcXG5cXHQgICAgICAgICAgICBcXFwiXSAtPiBbXFxcIiArIHRoaXMuZW5kLnJvdyArIFxcXCIvXFxcIiArIHRoaXMuZW5kLmNvbHVtbiArIFxcXCJdXFxcIik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuY29udGFpbnMgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5jb21wYXJlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgdmFyIGNtcCxcXG5cXHQgICAgICAgICAgICBlbmQgPSByYW5nZS5lbmQsXFxuXFx0ICAgICAgICAgICAgc3RhcnQgPSByYW5nZS5zdGFydDtcXG5cXG5cXHQgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShlbmQucm93LCBlbmQuY29sdW1uKTtcXG5cXHQgICAgICAgIGlmIChjbXAgPT0gMSkge1xcblxcdCAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiAyO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSBlbHNlIGlmIChjbXAgPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gLTI7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyZShzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT0gMSkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gNDI7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNvbXBhcmVQb2ludCA9IGZ1bmN0aW9uKHApIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocC5yb3csIHAuY29sdW1uKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5jb250YWluc1JhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQb2ludChyYW5nZS5zdGFydCkgPT0gMCAmJiB0aGlzLmNvbXBhcmVQb2ludChyYW5nZS5lbmQpID09IDA7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJhbmdlKSB7XFxuXFx0ICAgICAgICB2YXIgY21wID0gdGhpcy5jb21wYXJlUmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgcmV0dXJuIChjbXAgPT0gLTEgfHwgY21wID09IDAgfHwgY21wID09IDEpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmlzRW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmVuZC5yb3cgPT0gcm93ICYmIHRoaXMuZW5kLmNvbHVtbiA9PSBjb2x1bW47XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaXNTdGFydCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5yb3cgPT0gcm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09IGNvbHVtbjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTdGFydCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIHJvdyA9PSBcXFwib2JqZWN0XFxcIikge1xcblxcdCAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gcm93LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICB0aGlzLnN0YXJ0LnJvdyA9IHJvdy5yb3c7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuc3RhcnQucm93ID0gcm93O1xcblxcdCAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uID0gY29sdW1uO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldEVuZCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIHJvdyA9PSBcXFwib2JqZWN0XFxcIikge1xcblxcdCAgICAgICAgICAgIHRoaXMuZW5kLmNvbHVtbiA9IHJvdy5jb2x1bW47XFxuXFx0ICAgICAgICAgICAgdGhpcy5lbmQucm93ID0gcm93LnJvdztcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5lbmQucm93ID0gcm93O1xcblxcdCAgICAgICAgICAgIHRoaXMuZW5kLmNvbHVtbiA9IGNvbHVtbjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pbnNpZGUgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKHJvdywgY29sdW1uKSB8fCB0aGlzLmlzU3RhcnQocm93LCBjb2x1bW4pKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaW5zaWRlU3RhcnQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuY29tcGFyZShyb3csIGNvbHVtbikgPT0gMCkge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKHJvdywgY29sdW1uKSkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmluc2lkZUVuZCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5jb21wYXJlKHJvdywgY29sdW1uKSA9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFydChyb3csIGNvbHVtbikpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSgpKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA9PT0gdGhpcy5zdGFydC5yb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA8IHRoaXMuc3RhcnQuY29sdW1uID8gLTEgOiAoY29sdW1uID4gdGhpcy5lbmQuY29sdW1uID8gMSA6IDApO1xcblxcdCAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAocm93IDwgdGhpcy5zdGFydC5yb3cpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xcblxcblxcdCAgICAgICAgaWYgKHJvdyA+IHRoaXMuZW5kLnJvdylcXG5cXHQgICAgICAgICAgICByZXR1cm4gMTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnN0YXJ0LnJvdyA9PT0gcm93KVxcblxcdCAgICAgICAgICAgIHJldHVybiBjb2x1bW4gPj0gdGhpcy5zdGFydC5jb2x1bW4gPyAwIDogLTE7XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy5lbmQucm93ID09PSByb3cpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA8PSB0aGlzLmVuZC5jb2x1bW4gPyAwIDogMTtcXG5cXG5cXHQgICAgICAgIHJldHVybiAwO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNvbXBhcmVTdGFydCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zdGFydC5yb3cgPT0gcm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09IGNvbHVtbikge1xcblxcdCAgICAgICAgICAgIHJldHVybiAtMTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZShyb3csIGNvbHVtbik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY29tcGFyZUVuZCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5lbmQucm93ID09IHJvdyAmJiB0aGlzLmVuZC5jb2x1bW4gPT0gY29sdW1uKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIDE7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNvbXBhcmVJbnNpZGUgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuZW5kLnJvdyA9PSByb3cgJiYgdGhpcy5lbmQuY29sdW1uID09IGNvbHVtbikge1xcblxcdCAgICAgICAgICAgIHJldHVybiAxO1xcblxcdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXJ0LnJvdyA9PSByb3cgJiYgdGhpcy5zdGFydC5jb2x1bW4gPT0gY29sdW1uKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHJvdywgY29sdW1uKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5jbGlwUm93cyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5lbmQucm93ID4gbGFzdFJvdylcXG5cXHQgICAgICAgICAgICB2YXIgZW5kID0ge3JvdzogbGFzdFJvdyArIDEsIGNvbHVtbjogMH07XFxuXFx0ICAgICAgICBlbHNlIGlmICh0aGlzLmVuZC5yb3cgPCBmaXJzdFJvdylcXG5cXHQgICAgICAgICAgICB2YXIgZW5kID0ge3JvdzogZmlyc3RSb3csIGNvbHVtbjogMH07XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy5zdGFydC5yb3cgPiBsYXN0Um93KVxcblxcdCAgICAgICAgICAgIHZhciBzdGFydCA9IHtyb3c6IGxhc3RSb3cgKyAxLCBjb2x1bW46IDB9O1xcblxcdCAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFydC5yb3cgPCBmaXJzdFJvdylcXG5cXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiBmaXJzdFJvdywgY29sdW1uOiAwfTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0IHx8IHRoaXMuc3RhcnQsIGVuZCB8fCB0aGlzLmVuZCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZXh0ZW5kID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHZhciBjbXAgPSB0aGlzLmNvbXBhcmUocm93LCBjb2x1bW4pO1xcblxcblxcdCAgICAgICAgaWYgKGNtcCA9PSAwKVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xcblxcdCAgICAgICAgZWxzZSBpZiAoY21wID09IC0xKVxcblxcdCAgICAgICAgICAgIHZhciBzdGFydCA9IHtyb3c6IHJvdywgY29sdW1uOiBjb2x1bW59O1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHZhciBlbmQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0IHx8IHRoaXMuc3RhcnQsIGVuZCB8fCB0aGlzLmVuZCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0LnJvdyA9PT0gdGhpcy5lbmQucm93ICYmIHRoaXMuc3RhcnQuY29sdW1uID09PSB0aGlzLmVuZC5jb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmlzTXVsdGlMaW5lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnQucm93ICE9PSB0aGlzLmVuZC5yb3cpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY29sbGFwc2VSb3dzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5lbmQuY29sdW1uID09IDApXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0LnJvdywgMCwgTWF0aC5tYXgodGhpcy5zdGFydC5yb3csIHRoaXMuZW5kLnJvdy0xKSwgMClcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQucm93LCAwLCB0aGlzLmVuZC5yb3csIDApXFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudG9TY3JlZW5SYW5nZSA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcXG5cXHQgICAgICAgIHZhciBzY3JlZW5Qb3NTdGFydCA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuc3RhcnQpO1xcblxcdCAgICAgICAgdmFyIHNjcmVlblBvc0VuZCA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuZW5kKTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBuZXcgUmFuZ2UoXFxuXFx0ICAgICAgICAgICAgc2NyZWVuUG9zU3RhcnQucm93LCBzY3JlZW5Qb3NTdGFydC5jb2x1bW4sXFxuXFx0ICAgICAgICAgICAgc2NyZWVuUG9zRW5kLnJvdywgc2NyZWVuUG9zRW5kLmNvbHVtblxcblxcdCAgICAgICAgKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tb3ZlQnkgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgdGhpcy5zdGFydC5yb3cgKz0gcm93O1xcblxcdCAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gKz0gY29sdW1uO1xcblxcdCAgICAgICAgdGhpcy5lbmQucm93ICs9IHJvdztcXG5cXHQgICAgICAgIHRoaXMuZW5kLmNvbHVtbiArPSBjb2x1bW47XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChSYW5nZS5wcm90b3R5cGUpO1xcblxcdFJhbmdlLmZyb21Qb2ludHMgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XFxuXFx0ICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQucm93LCBzdGFydC5jb2x1bW4sIGVuZC5yb3csIGVuZC5jb2x1bW4pO1xcblxcdH07XFxuXFx0UmFuZ2UuY29tcGFyZVBvaW50cyA9IGNvbXBhcmVQb2ludHM7XFxuXFxuXFx0UmFuZ2UuY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xcblxcdCAgICByZXR1cm4gcDEucm93IC0gcDIucm93IHx8IHAxLmNvbHVtbiAtIHAyLmNvbHVtbjtcXG5cXHR9O1xcblxcblxcblxcdGV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2Uvc2VsZWN0aW9uXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiLFxcXCJhY2UvbGliL2xhbmdcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiLFxcXCJhY2UvcmFuZ2VcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4vbGliL2xhbmdcXFwiKTtcXG5cXHR2YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXFxcIi4vbGliL2V2ZW50X2VtaXR0ZXJcXFwiKS5FdmVudEVtaXR0ZXI7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXHR2YXIgU2VsZWN0aW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xcblxcdCAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xcblxcdCAgICB0aGlzLmRvYyA9IHNlc3Npb24uZ2V0RG9jdW1lbnQoKTtcXG5cXG5cXHQgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICB0aGlzLmxlYWQgPSB0aGlzLnNlbGVjdGlvbkxlYWQgPSB0aGlzLmRvYy5jcmVhdGVBbmNob3IoMCwgMCk7XFxuXFx0ICAgIHRoaXMuYW5jaG9yID0gdGhpcy5zZWxlY3Rpb25BbmNob3IgPSB0aGlzLmRvYy5jcmVhdGVBbmNob3IoMCwgMCk7XFxuXFxuXFx0ICAgIHZhciBzZWxmID0gdGhpcztcXG5cXHQgICAgdGhpcy5sZWFkLm9uKFxcXCJjaGFuZ2VcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBzZWxmLl9lbWl0KFxcXCJjaGFuZ2VDdXJzb3JcXFwiKTtcXG5cXHQgICAgICAgIGlmICghc2VsZi4kaXNFbXB0eSlcXG5cXHQgICAgICAgICAgICBzZWxmLl9lbWl0KFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgIGlmICghc2VsZi4ka2VlcERlc2lyZWRDb2x1bW5PbkNoYW5nZSAmJiBlLm9sZC5jb2x1bW4gIT0gZS52YWx1ZS5jb2x1bW4pXFxuXFx0ICAgICAgICAgICAgc2VsZi4kZGVzaXJlZENvbHVtbiA9IG51bGw7XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICB0aGlzLnNlbGVjdGlvbkFuY2hvci5vbihcXFwiY2hhbmdlXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoIXNlbGYuJGlzRW1wdHkpXFxuXFx0ICAgICAgICAgICAgc2VsZi5fZW1pdChcXFwiY2hhbmdlU2VsZWN0aW9uXFxcIik7XFxuXFx0ICAgIH0pO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XFxuXFx0ICAgIHRoaXMuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuICh0aGlzLiRpc0VtcHR5IHx8IChcXG5cXHQgICAgICAgICAgICB0aGlzLmFuY2hvci5yb3cgPT0gdGhpcy5sZWFkLnJvdyAmJlxcblxcdCAgICAgICAgICAgIHRoaXMuYW5jaG9yLmNvbHVtbiA9PSB0aGlzLmxlYWQuY29sdW1uXFxuXFx0ICAgICAgICApKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pc011bHRpTGluZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2UoKS5pc011bHRpTGluZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEN1cnNvciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMubGVhZC5nZXRQb3NpdGlvbigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNlbGVjdGlvbkFuY2hvciA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICB0aGlzLmFuY2hvci5zZXRQb3NpdGlvbihyb3csIGNvbHVtbik7XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy4kaXNFbXB0eSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGlzRW1wdHkgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9lbWl0KFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTZWxlY3Rpb25BbmNob3IgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRpc0VtcHR5KVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbkxlYWQoKTtcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IuZ2V0UG9zaXRpb24oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTZWxlY3Rpb25MZWFkID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5sZWFkLmdldFBvc2l0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2hpZnRTZWxlY3Rpb24gPSBmdW5jdGlvbihjb2x1bW5zKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kaXNFbXB0eSkge1xcblxcdCAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHRoaXMubGVhZC5yb3csIHRoaXMubGVhZC5jb2x1bW4gKyBjb2x1bW5zKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5nZXRTZWxlY3Rpb25BbmNob3IoKTtcXG5cXHQgICAgICAgIHZhciBsZWFkID0gdGhpcy5nZXRTZWxlY3Rpb25MZWFkKCk7XFxuXFxuXFx0ICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSB0aGlzLmlzQmFja3dhcmRzKCk7XFxuXFxuXFx0ICAgICAgICBpZiAoIWlzQmFja3dhcmRzIHx8IGFuY2hvci5jb2x1bW4gIT09IDApXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25BbmNob3IoYW5jaG9yLnJvdywgYW5jaG9yLmNvbHVtbiArIGNvbHVtbnMpO1xcblxcblxcdCAgICAgICAgaWYgKGlzQmFja3dhcmRzIHx8IGxlYWQuY29sdW1uICE9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbihmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8obGVhZC5yb3csIGxlYWQuY29sdW1uICsgY29sdW1ucyk7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaXNCYWNrd2FyZHMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvcjtcXG5cXHQgICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xcblxcdCAgICAgICAgcmV0dXJuIChhbmNob3Iucm93ID4gbGVhZC5yb3cgfHwgKGFuY2hvci5yb3cgPT0gbGVhZC5yb3cgJiYgYW5jaG9yLmNvbHVtbiA+IGxlYWQuY29sdW1uKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0UmFuZ2UgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmFuY2hvcjtcXG5cXHQgICAgICAgIHZhciBsZWFkID0gdGhpcy5sZWFkO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKGxlYWQsIGxlYWQpO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMuaXNCYWNrd2FyZHMoKSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBSYW5nZS5mcm9tUG9pbnRzKGxlYWQsIGFuY2hvcik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhhbmNob3IsIGxlYWQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGlzRW1wdHkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRpc0VtcHR5ID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9lbWl0KFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZWxlY3RBbGwgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBsYXN0Um93ID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xcblxcdCAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25BbmNob3IoMCwgMCk7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhsYXN0Um93LCB0aGlzLmRvYy5nZXRMaW5lKGxhc3RSb3cpLmxlbmd0aCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0UmFuZ2UgPVxcblxcdCAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsIHJldmVyc2UpIHtcXG5cXHQgICAgICAgIGlmIChyZXZlcnNlKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25BbmNob3IocmFuZ2UuZW5kLnJvdywgcmFuZ2UuZW5kLmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZWxlY3RUbyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLnN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uQW5jaG9yKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdFRvKHJhbmdlLmVuZC5yb3csIHJhbmdlLmVuZC5jb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKHRoaXMuZ2V0UmFuZ2UoKS5pc0VtcHR5KCkpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kaXNFbXB0eSA9IHRydWU7XFxuXFx0ICAgICAgICB0aGlzLiRkZXNpcmVkQ29sdW1uID0gbnVsbDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kbW92ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKG1vdmVyKSB7XFxuXFx0ICAgICAgICB2YXIgbGVhZCA9IHRoaXMubGVhZDtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRpc0VtcHR5KVxcblxcdCAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uQW5jaG9yKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICBtb3Zlci5jYWxsKHRoaXMpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdFRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24oZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbihmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHBvcyk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tb3ZlVG8gPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVUb1Bvc2l0aW9uID0gZnVuY3Rpb24ocG9zKSB7XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHBvcyk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0VXAgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yVXApO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdERvd24gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yRG93bik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0UmlnaHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yUmlnaHQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdExlZnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVTZWxlY3Rpb24odGhpcy5tb3ZlQ3Vyc29yTGVmdCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0TGluZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckxpbmVTdGFydCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0TGluZUVuZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JMaW5lRW5kKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZWxlY3RGaWxlRW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvckZpbGVFbmQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdEZpbGVTdGFydCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JGaWxlU3RhcnQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdFdvcmRSaWdodCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZVNlbGVjdGlvbih0aGlzLm1vdmVDdXJzb3JXb3JkUmlnaHQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdFdvcmRMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlU2VsZWN0aW9uKHRoaXMubW92ZUN1cnNvcldvcmRMZWZ0KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRXb3JkUmFuZ2UgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgY3Vyc29yID0gcm93IHx8IHRoaXMubGVhZDtcXG5cXHQgICAgICAgICAgICByb3cgPSBjdXJzb3Iucm93O1xcblxcdCAgICAgICAgICAgIGNvbHVtbiA9IGN1cnNvci5jb2x1bW47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFdvcmRSYW5nZShyb3csIGNvbHVtbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0V29yZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmdldFdvcmRSYW5nZSgpKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZWxlY3RBV29yZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yKCk7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlc3Npb24uZ2V0QVdvcmRSYW5nZShjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcXG5cXHQgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldExpbmVSYW5nZSA9IGZ1bmN0aW9uKHJvdywgZXhjbHVkZUxhc3RDaGFyKSB7XFxuXFx0ICAgICAgICB2YXIgcm93U3RhcnQgPSB0eXBlb2Ygcm93ID09IFxcXCJudW1iZXJcXFwiID8gcm93IDogdGhpcy5sZWFkLnJvdztcXG5cXHQgICAgICAgIHZhciByb3dFbmQ7XFxuXFxuXFx0ICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZExpbmUocm93U3RhcnQpO1xcblxcdCAgICAgICAgaWYgKGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgcm93U3RhcnQgPSBmb2xkTGluZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICAgICAgcm93RW5kID0gZm9sZExpbmUuZW5kLnJvdztcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcm93RW5kID0gcm93U3RhcnQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoZXhjbHVkZUxhc3RDaGFyID09PSB0cnVlKVxcblxcdCAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uocm93U3RhcnQsIDAsIHJvd0VuZCwgdGhpcy5zZXNzaW9uLmdldExpbmUocm93RW5kKS5sZW5ndGgpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uocm93U3RhcnQsIDAsIHJvd0VuZCArIDEsIDApO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdExpbmUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5nZXRMaW5lUmFuZ2UoKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvclVwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JCeSgtMSwgMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvckRvd24gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDEsIDApO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5sZWFkLmdldFBvc2l0aW9uKCksXFxuXFx0ICAgICAgICAgICAgZm9sZDtcXG5cXG5cXHQgICAgICAgIGlmIChmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uLCAtMSkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChjdXJzb3IuY29sdW1uID09PSAwKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGN1cnNvci5yb3cgPiAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKGN1cnNvci5yb3cgLSAxLCB0aGlzLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cgLSAxKS5sZW5ndGgpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciB0YWJTaXplID0gdGhpcy5zZXNzaW9uLmdldFRhYlNpemUoKTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmlzVGFiU3RvcChjdXJzb3IpICYmIHRoaXMuZG9jLmdldExpbmUoY3Vyc29yLnJvdykuc2xpY2UoY3Vyc29yLmNvbHVtbi10YWJTaXplLCBjdXJzb3IuY29sdW1uKS5zcGxpdChcXFwiIFxcXCIpLmxlbmd0aC0xID09IHRhYlNpemUpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIC10YWJTaXplKTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIC0xKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tb3ZlQ3Vyc29yUmlnaHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmxlYWQuZ2V0UG9zaXRpb24oKSxcXG5cXHQgICAgICAgICAgICBmb2xkO1xcblxcdCAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4sIDEpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSBpZiAodGhpcy5sZWFkLmNvbHVtbiA9PSB0aGlzLmRvYy5nZXRMaW5lKHRoaXMubGVhZC5yb3cpLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLmxlYWQucm93IDwgdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvKHRoaXMubGVhZC5yb3cgKyAxLCAwKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgdGFiU2l6ZSA9IHRoaXMuc2Vzc2lvbi5nZXRUYWJTaXplKCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMubGVhZDtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmlzVGFiU3RvcChjdXJzb3IpICYmIHRoaXMuZG9jLmdldExpbmUoY3Vyc29yLnJvdykuc2xpY2UoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbit0YWJTaXplKS5zcGxpdChcXFwiIFxcXCIpLmxlbmd0aC0xID09IHRhYlNpemUpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KDAsIHRhYlNpemUpO1xcblxcdCAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yQnkoMCwgMSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvckxpbmVTdGFydCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJvdyA9IHRoaXMubGVhZC5yb3c7XFxuXFx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcXG5cXHQgICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhyb3csIGNvbHVtbik7XFxuXFx0ICAgICAgICB2YXIgZmlyc3RDb2x1bW5Qb3NpdGlvbiA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCAwKTtcXG5cXHQgICAgICAgIHZhciBiZWZvcmVDdXJzb3IgPSB0aGlzLnNlc3Npb24uZ2V0RGlzcGxheUxpbmUoXFxuXFx0ICAgICAgICAgICAgcm93LCBudWxsLCBmaXJzdENvbHVtblBvc2l0aW9uLnJvdyxcXG5cXHQgICAgICAgICAgICBmaXJzdENvbHVtblBvc2l0aW9uLmNvbHVtblxcblxcdCAgICAgICAgKTtcXG5cXG5cXHQgICAgICAgIHZhciBsZWFkaW5nU3BhY2UgPSBiZWZvcmVDdXJzb3IubWF0Y2goL15cXFxccyovKTtcXG5cXHQgICAgICAgIGlmIChsZWFkaW5nU3BhY2VbMF0ubGVuZ3RoICE9IGNvbHVtbiAmJiAhdGhpcy5zZXNzaW9uLiR1c2VFbWFjc1N0eWxlTGluZVN0YXJ0KVxcblxcdCAgICAgICAgICAgIGZpcnN0Q29sdW1uUG9zaXRpb24uY29sdW1uICs9IGxlYWRpbmdTcGFjZVswXS5sZW5ndGg7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKGZpcnN0Q29sdW1uUG9zaXRpb24pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JMaW5lRW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgbGVhZCA9IHRoaXMubGVhZDtcXG5cXHQgICAgICAgIHZhciBsaW5lRW5kID0gdGhpcy5zZXNzaW9uLmdldERvY3VtZW50TGFzdFJvd0NvbHVtblBvc2l0aW9uKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XFxuXFx0ICAgICAgICBpZiAodGhpcy5sZWFkLmNvbHVtbiA9PSBsaW5lRW5kLmNvbHVtbikge1xcblxcdCAgICAgICAgICAgIHZhciBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUobGluZUVuZC5yb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChsaW5lRW5kLmNvbHVtbiA9PSBsaW5lLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdGV4dEVuZCA9IGxpbmUuc2VhcmNoKC9cXFxccyskLyk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kID4gMClcXG5cXHQgICAgICAgICAgICAgICAgICAgIGxpbmVFbmQuY29sdW1uID0gdGV4dEVuZDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhsaW5lRW5kLnJvdywgbGluZUVuZC5jb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JGaWxlRW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgcm93ID0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxO1xcblxcdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZG9jLmdldExpbmUocm93KS5sZW5ndGg7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvckZpbGVTdGFydCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oMCwgMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvckxvbmdXb3JkUmlnaHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xcblxcdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcXG5cXHQgICAgICAgIHZhciByaWdodE9mQ3Vyc29yID0gbGluZS5zdWJzdHJpbmcoY29sdW1uKTtcXG5cXG5cXHQgICAgICAgIHZhciBtYXRjaDtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xcblxcdCAgICAgICAgdmFyIGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAxKTtcXG5cXHQgICAgICAgIGlmIChmb2xkKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5lbmQucm93LCBmb2xkLmVuZC5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChtYXRjaCA9IHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmV4ZWMocmlnaHRPZkN1cnNvcikpIHtcXG5cXHQgICAgICAgICAgICBjb2x1bW4gKz0gdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4O1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICAgICAgcmlnaHRPZkN1cnNvciA9IGxpbmUuc3Vic3RyaW5nKGNvbHVtbik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoY29sdW1uID49IGxpbmUubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBsaW5lLmxlbmd0aCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yUmlnaHQoKTtcXG5cXHQgICAgICAgICAgICBpZiAocm93IDwgdGhpcy5kb2MuZ2V0TGVuZ3RoKCkgLSAxKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JXb3JkUmlnaHQoKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLnNlc3Npb24udG9rZW5SZS5leGVjKHJpZ2h0T2ZDdXJzb3IpKSB7XFxuXFx0ICAgICAgICAgICAgY29sdW1uICs9IHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleDtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24udG9rZW5SZS5sYXN0SW5kZXggPSAwO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JMb25nV29yZExlZnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciByb3cgPSB0aGlzLmxlYWQucm93O1xcblxcdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGVhZC5jb2x1bW47XFxuXFx0ICAgICAgICB2YXIgZm9sZDtcXG5cXHQgICAgICAgIGlmIChmb2xkID0gdGhpcy5zZXNzaW9uLmdldEZvbGRBdChyb3csIGNvbHVtbiwgLTEpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8oZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zZXNzaW9uLmdldEZvbGRTdHJpbmdBdChyb3csIGNvbHVtbiwgLTEpO1xcblxcdCAgICAgICAgaWYgKHN0ciA9PSBudWxsKSB7XFxuXFx0ICAgICAgICAgICAgc3RyID0gdGhpcy5kb2MuZ2V0TGluZShyb3cpLnN1YnN0cmluZygwLCBjb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGxlZnRPZkN1cnNvciA9IGxhbmcuc3RyaW5nUmV2ZXJzZShzdHIpO1xcblxcdCAgICAgICAgdmFyIG1hdGNoO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4ID0gMDtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5leGVjKGxlZnRPZkN1cnNvcikpIHtcXG5cXHQgICAgICAgICAgICBjb2x1bW4gLT0gdGhpcy5zZXNzaW9uLm5vblRva2VuUmUubGFzdEluZGV4O1xcblxcdCAgICAgICAgICAgIGxlZnRPZkN1cnNvciA9IGxlZnRPZkN1cnNvci5zbGljZSh0aGlzLnNlc3Npb24ubm9uVG9rZW5SZS5sYXN0SW5kZXgpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5ub25Ub2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoY29sdW1uIDw9IDApIHtcXG5cXHQgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIDApO1xcblxcdCAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckxlZnQoKTtcXG5cXHQgICAgICAgICAgICBpZiAocm93ID4gMClcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yV29yZExlZnQoKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLnNlc3Npb24udG9rZW5SZS5leGVjKGxlZnRPZkN1cnNvcikpIHtcXG5cXHQgICAgICAgICAgICBjb2x1bW4gLT0gdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4O1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi50b2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHNob3J0V29yZEVuZEluZGV4ID0gZnVuY3Rpb24ocmlnaHRPZkN1cnNvcikge1xcblxcdCAgICAgICAgdmFyIG1hdGNoLCBpbmRleCA9IDAsIGNoO1xcblxcdCAgICAgICAgdmFyIHdoaXRlc3BhY2VSZSA9IC9cXFxccy87XFxuXFx0ICAgICAgICB2YXIgdG9rZW5SZSA9IHRoaXMuc2Vzc2lvbi50b2tlblJlO1xcblxcblxcdCAgICAgICAgdG9rZW5SZS5sYXN0SW5kZXggPSAwO1xcblxcdCAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5zZXNzaW9uLnRva2VuUmUuZXhlYyhyaWdodE9mQ3Vyc29yKSkge1xcblxcdCAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zZXNzaW9uLnRva2VuUmUubGFzdEluZGV4O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB3aGlsZSAoKGNoID0gcmlnaHRPZkN1cnNvcltpbmRleF0pICYmIHdoaXRlc3BhY2VSZS50ZXN0KGNoKSlcXG5cXHQgICAgICAgICAgICAgICAgaW5kZXggKys7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGluZGV4IDwgMSkge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgICB3aGlsZSAoKGNoID0gcmlnaHRPZkN1cnNvcltpbmRleF0pICYmICF0b2tlblJlLnRlc3QoY2gpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpbmRleCArKztcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICh3aGl0ZXNwYWNlUmUudGVzdChjaCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAyKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2ggPSByaWdodE9mQ3Vyc29yW2luZGV4XSkgJiYgd2hpdGVzcGFjZVJlLnRlc3QoY2gpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggKys7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0b2tlblJlLmxhc3RJbmRleCA9IDA7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gaW5kZXg7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvclNob3J0V29yZFJpZ2h0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgcm93ID0gdGhpcy5sZWFkLnJvdztcXG5cXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxlYWQuY29sdW1uO1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICB2YXIgcmlnaHRPZkN1cnNvciA9IGxpbmUuc3Vic3RyaW5nKGNvbHVtbik7XFxuXFxuXFx0ICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBjb2x1bW4sIDEpO1xcblxcdCAgICAgICAgaWYgKGZvbGQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKTtcXG5cXG5cXHQgICAgICAgIGlmIChjb2x1bW4gPT0gbGluZS5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICB2YXIgbCA9IHRoaXMuZG9jLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgcm93Kys7XFxuXFx0ICAgICAgICAgICAgICAgIHJpZ2h0T2ZDdXJzb3IgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICAgICAgfSB3aGlsZSAocm93IDwgbCAmJiAvXlxcXFxzKiQvLnRlc3QocmlnaHRPZkN1cnNvcikpO1xcblxcblxcdCAgICAgICAgICAgIGlmICghL15cXFxccysvLnRlc3QocmlnaHRPZkN1cnNvcikpXFxuXFx0ICAgICAgICAgICAgICAgIHJpZ2h0T2ZDdXJzb3IgPSBcXFwiXFxcIjtcXG5cXHQgICAgICAgICAgICBjb2x1bW4gPSAwO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy4kc2hvcnRXb3JkRW5kSW5kZXgocmlnaHRPZkN1cnNvcik7XFxuXFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhyb3csIGNvbHVtbiArIGluZGV4KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5tb3ZlQ3Vyc29yU2hvcnRXb3JkTGVmdCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJvdyA9IHRoaXMubGVhZC5yb3c7XFxuXFx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sZWFkLmNvbHVtbjtcXG5cXG5cXHQgICAgICAgIHZhciBmb2xkO1xcblxcdCAgICAgICAgaWYgKGZvbGQgPSB0aGlzLnNlc3Npb24uZ2V0Rm9sZEF0KHJvdywgY29sdW1uLCAtMSkpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUN1cnNvclRvKGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKHJvdykuc3Vic3RyaW5nKDAsIGNvbHVtbik7XFxuXFx0ICAgICAgICBpZiAoY29sdW1uID09PSAwKSB7XFxuXFx0ICAgICAgICAgICAgZG8ge1xcblxcdCAgICAgICAgICAgICAgICByb3ctLTtcXG5cXHQgICAgICAgICAgICAgICAgbGluZSA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcXG5cXHQgICAgICAgICAgICB9IHdoaWxlIChyb3cgPiAwICYmIC9eXFxcXHMqJC8udGVzdChsaW5lKSk7XFxuXFxuXFx0ICAgICAgICAgICAgY29sdW1uID0gbGluZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgaWYgKCEvXFxcXHMrJC8udGVzdChsaW5lKSlcXG5cXHQgICAgICAgICAgICAgICAgbGluZSA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGxlZnRPZkN1cnNvciA9IGxhbmcuc3RyaW5nUmV2ZXJzZShsaW5lKTtcXG5cXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMuJHNob3J0V29yZEVuZEluZGV4KGxlZnRPZkN1cnNvcik7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4gLSBpbmRleCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvcldvcmRSaWdodCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kc2VsZWN0TG9uZ1dvcmRzKVxcblxcdCAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckxvbmdXb3JkUmlnaHQoKTtcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JTaG9ydFdvcmRSaWdodCgpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JXb3JkTGVmdCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi4kc2VsZWN0TG9uZ1dvcmRzKVxcblxcdCAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckxvbmdXb3JkTGVmdCgpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclNob3J0V29yZExlZnQoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tb3ZlQ3Vyc29yQnkgPSBmdW5jdGlvbihyb3dzLCBjaGFycykge1xcblxcdCAgICAgICAgdmFyIHNjcmVlblBvcyA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oXFxuXFx0ICAgICAgICAgICAgdGhpcy5sZWFkLnJvdyxcXG5cXHQgICAgICAgICAgICB0aGlzLmxlYWQuY29sdW1uXFxuXFx0ICAgICAgICApO1xcblxcblxcdCAgICAgICAgaWYgKGNoYXJzID09PSAwKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJGRlc2lyZWRDb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgIHNjcmVlblBvcy5jb2x1bW4gPSB0aGlzLiRkZXNpcmVkQ29sdW1uO1xcblxcdCAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IHNjcmVlblBvcy5jb2x1bW47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgZG9jUG9zID0gdGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Qb3Mucm93ICsgcm93cywgc2NyZWVuUG9zLmNvbHVtbik7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChyb3dzICE9PSAwICYmIGNoYXJzID09PSAwICYmIGRvY1Bvcy5yb3cgPT09IHRoaXMubGVhZC5yb3cgJiYgZG9jUG9zLmNvbHVtbiA9PT0gdGhpcy5sZWFkLmNvbHVtbikge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24ubGluZVdpZGdldHMgJiYgdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzW2RvY1Bvcy5yb3ddKVxcblxcdCAgICAgICAgICAgICAgICBkb2NQb3Mucm93Kys7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhkb2NQb3Mucm93LCBkb2NQb3MuY29sdW1uICsgY2hhcnMsIGNoYXJzID09PSAwKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvclRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIGtlZXBEZXNpcmVkQ29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgZm9sZCA9IHRoaXMuc2Vzc2lvbi5nZXRGb2xkQXQocm93LCBjb2x1bW4sIDEpO1xcblxcdCAgICAgICAgaWYgKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICByb3cgPSBmb2xkLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICBjb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMuJGtlZXBEZXNpcmVkQ29sdW1uT25DaGFuZ2UgPSB0cnVlO1xcblxcdCAgICAgICAgdGhpcy5sZWFkLnNldFBvc2l0aW9uKHJvdywgY29sdW1uKTtcXG5cXHQgICAgICAgIHRoaXMuJGtlZXBEZXNpcmVkQ29sdW1uT25DaGFuZ2UgPSBmYWxzZTtcXG5cXG5cXHQgICAgICAgIGlmICgha2VlcERlc2lyZWRDb2x1bW4pXFxuXFx0ICAgICAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUN1cnNvclRvU2NyZWVuID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIGtlZXBEZXNpcmVkQ29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgcG9zID0gdGhpcy5zZXNzaW9uLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihyb3csIGNvbHVtbik7XFxuXFx0ICAgICAgICB0aGlzLm1vdmVDdXJzb3JUbyhwb3Mucm93LCBwb3MuY29sdW1uLCBrZWVwRGVzaXJlZENvbHVtbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLmxlYWQuZGV0YWNoKCk7XFxuXFx0ICAgICAgICB0aGlzLmFuY2hvci5kZXRhY2goKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHRoaXMuZG9jID0gbnVsbDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5mcm9tT3JpZW50ZWRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XFxuXFx0ICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlLCByYW5nZS5jdXJzb3IgPT0gcmFuZ2Uuc3RhcnQpO1xcblxcdCAgICAgICAgdGhpcy4kZGVzaXJlZENvbHVtbiA9IHJhbmdlLmRlc2lyZWRDb2x1bW4gfHwgdGhpcy4kZGVzaXJlZENvbHVtbjtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy50b09yaWVudGVkUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgdmFyIHIgPSB0aGlzLmdldFJhbmdlKCk7XFxuXFx0ICAgICAgICBpZiAocmFuZ2UpIHtcXG5cXHQgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSByLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICByYW5nZS5zdGFydC5yb3cgPSByLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gci5lbmQuY29sdW1uO1xcblxcdCAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSByLmVuZC5yb3c7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHJhbmdlID0gcjtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJhbmdlLmN1cnNvciA9IHRoaXMuaXNCYWNrd2FyZHMoKSA/IHJhbmdlLnN0YXJ0IDogcmFuZ2UuZW5kO1xcblxcdCAgICAgICAgcmFuZ2UuZGVzaXJlZENvbHVtbiA9IHRoaXMuJGRlc2lyZWRDb2x1bW47XFxuXFx0ICAgICAgICByZXR1cm4gcmFuZ2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0UmFuZ2VPZk1vdmVtZW50cyA9IGZ1bmN0aW9uKGZ1bmMpIHtcXG5cXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q3Vyc29yKCk7XFxuXFx0ICAgICAgICB0cnkge1xcblxcdCAgICAgICAgICAgIGZ1bmMuY2FsbChudWxsLCB0aGlzKTtcXG5cXHQgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5nZXRDdXJzb3IoKTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydCxlbmQpO1xcblxcdCAgICAgICAgfSBjYXRjaChlKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnQsc3RhcnQpO1xcblxcdCAgICAgICAgfSBmaW5hbGx5IHtcXG5cXHQgICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHN0YXJ0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy50b0pTT04gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcXG5cXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmFuZ2VzLm1hcChmdW5jdGlvbihyKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByMSA9IHIuY2xvbmUoKTtcXG5cXHQgICAgICAgICAgICAgICAgcjEuaXNCYWNrd2FyZHMgPSByLmN1cnNvciA9PSByLnN0YXJ0O1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gcjE7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIGRhdGEuaXNCYWNrd2FyZHMgPSB0aGlzLmlzQmFja3dhcmRzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gZGF0YTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5mcm9tSlNPTiA9IGZ1bmN0aW9uKGRhdGEpIHtcXG5cXHQgICAgICAgIGlmIChkYXRhLnN0YXJ0ID09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlTGlzdCkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoZGF0YVswXSk7XFxuXFx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aDsgaS0tOyApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciByID0gUmFuZ2UuZnJvbVBvaW50cyhkYXRhW2ldLnN0YXJ0LCBkYXRhW2ldLmVuZCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5pc0JhY2t3YXJkcylcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByLmN1cnNvciA9IHIuc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFJhbmdlKHIsIHRydWUpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICB9IGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAodGhpcy5yYW5nZUxpc3QpXFxuXFx0ICAgICAgICAgICAgdGhpcy50b1NpbmdsZVJhbmdlKGRhdGEpO1xcblxcdCAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShkYXRhLCBkYXRhLmlzQmFja3dhcmRzKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5pc0VxdWFsID0gZnVuY3Rpb24oZGF0YSkge1xcblxcdCAgICAgICAgaWYgKChkYXRhLmxlbmd0aCB8fCB0aGlzLnJhbmdlQ291bnQpICYmIGRhdGEubGVuZ3RoICE9IHRoaXMucmFuZ2VDb3VudClcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgICAgICBpZiAoIWRhdGEubGVuZ3RoIHx8ICF0aGlzLnJhbmdlcylcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZSgpLmlzRXF1YWwoZGF0YSk7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5yYW5nZXMubGVuZ3RoOyBpLS07ICkge1xcblxcdCAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uaXNFcXVhbChkYXRhW2ldKSlcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChTZWxlY3Rpb24ucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLlNlbGVjdGlvbiA9IFNlbGVjdGlvbjtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvdG9rZW5pemVyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFx0dmFyIE1BWF9UT0tFTl9DT1VOVCA9IDIwMDA7XFxuXFx0dmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKHJ1bGVzKSB7XFxuXFx0ICAgIHRoaXMuc3RhdGVzID0gcnVsZXM7XFxuXFxuXFx0ICAgIHRoaXMucmVnRXhwcyA9IHt9O1xcblxcdCAgICB0aGlzLm1hdGNoTWFwcGluZ3MgPSB7fTtcXG5cXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdGVzKSB7XFxuXFx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlc1trZXldO1xcblxcdCAgICAgICAgdmFyIHJ1bGVSZWdFeHBzID0gW107XFxuXFx0ICAgICAgICB2YXIgbWF0Y2hUb3RhbCA9IDA7XFxuXFx0ICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMubWF0Y2hNYXBwaW5nc1trZXldID0ge2RlZmF1bHRUb2tlbjogXFxcInRleHRcXFwifTtcXG5cXHQgICAgICAgIHZhciBmbGFnID0gXFxcImdcXFwiO1xcblxcblxcdCAgICAgICAgdmFyIHNwbGl0dGVyUnVybGVzID0gW107XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJ1bGUgPSBzdGF0ZVtpXTtcXG5cXHQgICAgICAgICAgICBpZiAocnVsZS5kZWZhdWx0VG9rZW4pXFxuXFx0ICAgICAgICAgICAgICAgIG1hcHBpbmcuZGVmYXVsdFRva2VuID0gcnVsZS5kZWZhdWx0VG9rZW47XFxuXFx0ICAgICAgICAgICAgaWYgKHJ1bGUuY2FzZUluc2Vuc2l0aXZlKVxcblxcdCAgICAgICAgICAgICAgICBmbGFnID0gXFxcImdpXFxcIjtcXG5cXHQgICAgICAgICAgICBpZiAocnVsZS5yZWdleCA9PSBudWxsKVxcblxcdCAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAocnVsZS5yZWdleCBpbnN0YW5jZW9mIFJlZ0V4cClcXG5cXHQgICAgICAgICAgICAgICAgcnVsZS5yZWdleCA9IHJ1bGUucmVnZXgudG9TdHJpbmcoKS5zbGljZSgxLCAtMSk7XFxuXFx0ICAgICAgICAgICAgdmFyIGFkanVzdGVkcmVnZXggPSBydWxlLnJlZ2V4O1xcblxcdCAgICAgICAgICAgIHZhciBtYXRjaGNvdW50ID0gbmV3IFJlZ0V4cChcXFwiKD86KFxcXCIgKyBhZGp1c3RlZHJlZ2V4ICsgXFxcIil8KC4pKVxcXCIpLmV4ZWMoXFxcImFcXFwiKS5sZW5ndGggLSAyO1xcblxcdCAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUudG9rZW4pKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChydWxlLnRva2VuLmxlbmd0aCA9PSAxIHx8IG1hdGNoY291bnQgPT0gMSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcnVsZS50b2tlbiA9IHJ1bGUudG9rZW5bMF07XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hjb3VudCAtIDEgIT0gcnVsZS50b2tlbi5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXFxcIm51bWJlciBvZiBjbGFzc2VzIGFuZCByZWdleHAgZ3JvdXBzIGRvZXNuJ3QgbWF0Y2hcXFwiLCB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZSxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBncm91cENvdW50OiBtYXRjaGNvdW50IC0gMVxcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gcnVsZS50b2tlblswXTtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW5BcnJheSA9IHJ1bGUudG9rZW47XFxuXFx0ICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gbnVsbDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUub25NYXRjaCA9IHRoaXMuJGFycmF5VG9rZW5zO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZS50b2tlbiA9PSBcXFwiZnVuY3Rpb25cXFwiICYmICFydWxlLm9uTWF0Y2gpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKG1hdGNoY291bnQgPiAxKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gdGhpcy4kYXBwbHlUb2tlbjtcXG5cXHQgICAgICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gcnVsZS50b2tlbjtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKG1hdGNoY291bnQgPiAxKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICgvXFxcXFxcXFxcXFxcZC8udGVzdChydWxlLnJlZ2V4KSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRyZWdleCA9IHJ1bGUucmVnZXgucmVwbGFjZSgvXFxcXFxcXFwoWzAtOV0rKS9nLCBmdW5jdGlvbihtYXRjaCwgZGlnaXQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcIlxcXFxcXFxcXFxcIiArIChwYXJzZUludChkaWdpdCwgMTApICsgbWF0Y2hUb3RhbCArIDEpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBtYXRjaGNvdW50ID0gMTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGFkanVzdGVkcmVnZXggPSB0aGlzLnJlbW92ZUNhcHR1cmluZ0dyb3VwcyhydWxlLnJlZ2V4KTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBpZiAoIXJ1bGUuc3BsaXRSZWdleCAmJiB0eXBlb2YgcnVsZS50b2tlbiAhPSBcXFwic3RyaW5nXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwbGl0dGVyUnVybGVzLnB1c2gocnVsZSk7IC8vIGZsYWcgd2lsbCBiZSBrbm93biBvbmx5IGF0IHRoZSB2ZXJ5IGVuZFxcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBtYXBwaW5nW21hdGNoVG90YWxdID0gaTtcXG5cXHQgICAgICAgICAgICBtYXRjaFRvdGFsICs9IG1hdGNoY291bnQ7XFxuXFxuXFx0ICAgICAgICAgICAgcnVsZVJlZ0V4cHMucHVzaChhZGp1c3RlZHJlZ2V4KTtcXG5cXHQgICAgICAgICAgICBpZiAoIXJ1bGUub25NYXRjaClcXG5cXHQgICAgICAgICAgICAgICAgcnVsZS5vbk1hdGNoID0gbnVsbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKCFydWxlUmVnRXhwcy5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICBtYXBwaW5nWzBdID0gMDtcXG5cXHQgICAgICAgICAgICBydWxlUmVnRXhwcy5wdXNoKFxcXCIkXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHNwbGl0dGVyUnVybGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xcblxcdCAgICAgICAgICAgIHJ1bGUuc3BsaXRSZWdleCA9IHRoaXMuY3JlYXRlU3BsaXR0ZXJSZWdleHAocnVsZS5yZWdleCwgZmxhZyk7XFxuXFx0ICAgICAgICB9LCB0aGlzKTtcXG5cXG5cXHQgICAgICAgIHRoaXMucmVnRXhwc1trZXldID0gbmV3IFJlZ0V4cChcXFwiKFxcXCIgKyBydWxlUmVnRXhwcy5qb2luKFxcXCIpfChcXFwiKSArIFxcXCIpfCgkKVxcXCIsIGZsYWcpO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuJHNldE1heFRva2VuQ291bnQgPSBmdW5jdGlvbihtKSB7XFxuXFx0ICAgICAgICBNQVhfVE9LRU5fQ09VTlQgPSBtIHwgMDtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJGFwcGx5VG9rZW4gPSBmdW5jdGlvbihzdHIpIHtcXG5cXHQgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnNwbGl0UmVnZXguZXhlYyhzdHIpLnNsaWNlKDEpO1xcblxcdCAgICAgICAgdmFyIHR5cGVzID0gdGhpcy50b2tlbi5hcHBseSh0aGlzLCB2YWx1ZXMpO1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFt7dHlwZTogdHlwZXMsIHZhbHVlOiBzdHJ9XTtcXG5cXG5cXHQgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSlcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZXNbaV0sXFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldXFxuXFx0ICAgICAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gdG9rZW5zO1xcblxcdCAgICB9LFxcblxcblxcdCAgICB0aGlzLiRhcnJheVRva2VucyA9IGZ1bmN0aW9uKHN0cikge1xcblxcdCAgICAgICAgaWYgKCFzdHIpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xcblxcdCAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuc3BsaXRSZWdleC5leGVjKHN0cik7XFxuXFx0ICAgICAgICBpZiAoIXZhbHVlcylcXG5cXHQgICAgICAgICAgICByZXR1cm4gXFxcInRleHRcXFwiO1xcblxcdCAgICAgICAgdmFyIHRva2VucyA9IFtdO1xcblxcdCAgICAgICAgdmFyIHR5cGVzID0gdGhpcy50b2tlbkFycmF5O1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpZiAodmFsdWVzW2kgKyAxXSlcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZXNbaV0sXFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2kgKyAxXVxcblxcdCAgICAgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHRva2VucztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZW1vdmVDYXB0dXJpbmdHcm91cHMgPSBmdW5jdGlvbihzcmMpIHtcXG5cXHQgICAgICAgIHZhciByID0gc3JjLnJlcGxhY2UoXFxuXFx0ICAgICAgICAgICAgL1xcXFxbKD86XFxcXFxcXFwufFteXFxcXF1dKSo/XFxcXF18XFxcXFxcXFwufFxcXFwoXFxcXD9bOj0hXXwoXFxcXCgpL2csXFxuXFx0ICAgICAgICAgICAgZnVuY3Rpb24oeCwgeSkge3JldHVybiB5ID8gXFxcIig/OlxcXCIgOiB4O31cXG5cXHQgICAgICAgICk7XFxuXFx0ICAgICAgICByZXR1cm4gcjtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jcmVhdGVTcGxpdHRlclJlZ2V4cCA9IGZ1bmN0aW9uKHNyYywgZmxhZykge1xcblxcdCAgICAgICAgaWYgKHNyYy5pbmRleE9mKFxcXCIoPz1cXFwiKSAhPSAtMSkge1xcblxcdCAgICAgICAgICAgIHZhciBzdGFjayA9IDA7XFxuXFx0ICAgICAgICAgICAgdmFyIGluQ2hDbGFzcyA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgIHZhciBsYXN0Q2FwdHVyZSA9IHt9O1xcblxcdCAgICAgICAgICAgIHNyYy5yZXBsYWNlKC8oXFxcXFxcXFwuKXwoXFxcXCgoPzpcXFxcP1s9IV0pPyl8KFxcXFwpKXwoW1xcXFxbXFxcXF1dKS9nLCBmdW5jdGlvbihcXG5cXHQgICAgICAgICAgICAgICAgbSwgZXNjLCBwYXJlbk9wZW4sIHBhcmVuQ2xvc2UsIHNxdWFyZSwgaW5kZXhcXG5cXHQgICAgICAgICAgICApIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGluQ2hDbGFzcykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaW5DaENsYXNzID0gc3F1YXJlICE9IFxcXCJdXFxcIjtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcXVhcmUpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGluQ2hDbGFzcyA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW5DbG9zZSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrID09IGxhc3RDYXB0dXJlLnN0YWNrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuZW5kID0gaW5kZXgrMTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2FwdHVyZS5zdGFjayA9IC0xO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgc3RhY2stLTtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbk9wZW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrKys7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW5PcGVuLmxlbmd0aCAhPSAxKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENhcHR1cmUuc3RhY2sgPSBzdGFja1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDYXB0dXJlLnN0YXJ0ID0gaW5kZXg7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIG07XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGxhc3RDYXB0dXJlLmVuZCAhPSBudWxsICYmIC9eXFxcXCkqJC8udGVzdChzcmMuc3Vic3RyKGxhc3RDYXB0dXJlLmVuZCkpKVxcblxcdCAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKDAsIGxhc3RDYXB0dXJlLnN0YXJ0KSArIHNyYy5zdWJzdHIobGFzdENhcHR1cmUuZW5kKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHNyYywgKGZsYWd8fFxcXCJcXFwiKS5yZXBsYWNlKFxcXCJnXFxcIiwgXFxcIlxcXCIpKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMaW5lVG9rZW5zID0gZnVuY3Rpb24obGluZSwgc3RhcnRTdGF0ZSkge1xcblxcdCAgICAgICAgaWYgKHN0YXJ0U3RhdGUgJiYgdHlwZW9mIHN0YXJ0U3RhdGUgIT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBzdGFydFN0YXRlLnNsaWNlKDApO1xcblxcdCAgICAgICAgICAgIHN0YXJ0U3RhdGUgPSBzdGFja1swXTtcXG5cXHQgICAgICAgICAgICBpZiAoc3RhcnRTdGF0ZSA9PT0gXFxcIiN0bXBcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KClcXG5cXHQgICAgICAgICAgICAgICAgc3RhcnRTdGF0ZSA9IHN0YWNrLnNoaWZ0KClcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2VcXG5cXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcXG5cXG5cXHQgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBzdGFydFN0YXRlIHx8IFxcXCJzdGFydFxcXCI7XFxuXFx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgaWYgKCFzdGF0ZSkge1xcblxcdCAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFxcXCJzdGFydFxcXCI7XFxuXFx0ICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLm1hdGNoTWFwcGluZ3NbY3VycmVudFN0YXRlXTtcXG5cXHQgICAgICAgIHZhciByZSA9IHRoaXMucmVnRXhwc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcXG5cXG5cXHQgICAgICAgIHZhciBtYXRjaCwgdG9rZW5zID0gW107XFxuXFx0ICAgICAgICB2YXIgbGFzdEluZGV4ID0gMDtcXG5cXHQgICAgICAgIHZhciBtYXRjaEF0dGVtcHRzID0gMDtcXG5cXG5cXHQgICAgICAgIHZhciB0b2tlbiA9IHt0eXBlOiBudWxsLCB2YWx1ZTogXFxcIlxcXCJ9O1xcblxcblxcdCAgICAgICAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhsaW5lKSkge1xcblxcdCAgICAgICAgICAgIHZhciB0eXBlID0gbWFwcGluZy5kZWZhdWx0VG9rZW47XFxuXFx0ICAgICAgICAgICAgdmFyIHJ1bGUgPSBudWxsO1xcblxcdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzBdO1xcblxcdCAgICAgICAgICAgIHZhciBpbmRleCA9IHJlLmxhc3RJbmRleDtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoaW5kZXggLSB2YWx1ZS5sZW5ndGggPiBsYXN0SW5kZXgpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBsaW5lLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4IC0gdmFsdWUubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT0gdHlwZSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgKz0gc2tpcHBlZDtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0ge3R5cGU6IHR5cGUsIHZhbHVlOiBza2lwcGVkfTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aC0yOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKG1hdGNoW2kgKyAxXSA9PT0gdW5kZWZpbmVkKVxcblxcdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHJ1bGUgPSBzdGF0ZVttYXBwaW5nW2ldXTtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJ1bGUub25NYXRjaClcXG5cXHQgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBydWxlLm9uTWF0Y2godmFsdWUsIGN1cnJlbnRTdGF0ZSwgc3RhY2spO1xcblxcdCAgICAgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICB0eXBlID0gcnVsZS50b2tlbjtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLm5leHQgPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBydWxlLm5leHQ7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHJ1bGUubmV4dChjdXJyZW50U3RhdGUsIHN0YWNrKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXFxcInN0YXRlIGRvZXNuJ3QgZXhpc3RcXFwiLCBjdXJyZW50U3RhdGUpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFxcXCJzdGFydFxcXCI7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMubWF0Y2hNYXBwaW5nc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByZSA9IHRoaXMucmVnRXhwc1tjdXJyZW50U3RhdGVdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gaW5kZXg7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIGlmICh2YWx1ZSkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoKCFydWxlIHx8IHJ1bGUubWVyZ2UgIT09IGZhbHNlKSAmJiB0b2tlbi50eXBlID09PSB0eXBlKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgKz0gdmFsdWU7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7dHlwZTogdHlwZSwgdmFsdWU6IHZhbHVlfTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHt0eXBlOiBudWxsLCB2YWx1ZTogXFxcIlxcXCJ9O1xcblxcdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHR5cGVbaV0pO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPT0gbGluZS5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4O1xcblxcblxcdCAgICAgICAgICAgIGlmIChtYXRjaEF0dGVtcHRzKysgPiBNQVhfVE9LRU5fQ09VTlQpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKG1hdGNoQXR0ZW1wdHMgPiAyICogbGluZS5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXFxcImluZmluaXRlIGxvb3Agd2l0aCBpbiBhY2UgdG9rZW5pemVyXFxcIiwge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0U3RhdGU6IHN0YXJ0U3RhdGUsXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZVxcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGxpbmUubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGluZS5zdWJzdHJpbmcobGFzdEluZGV4LCBsYXN0SW5kZXggKz0gMjAwMCksXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXFxcIm92ZXJmbG93XFxcIlxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBcXFwic3RhcnRcXFwiO1xcblxcdCAgICAgICAgICAgICAgICBzdGFjayA9IFtdO1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAodG9rZW4udHlwZSlcXG5cXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHN0YWNrWzBdICE9PSBjdXJyZW50U3RhdGUpXFxuXFx0ICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQoXFxcIiN0bXBcXFwiLCBjdXJyZW50U3RhdGUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICB0b2tlbnMgOiB0b2tlbnMsXFxuXFx0ICAgICAgICAgICAgc3RhdGUgOiBzdGFjay5sZW5ndGggPyBzdGFjayA6IGN1cnJlbnRTdGF0ZVxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZGF0YSkge1xcblxcdCAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IobXNnKTtcXG5cXHQgICAgICAgIGUuZGF0YSA9IGRhdGE7XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gXFxcIm9iamVjdFxcXCIgJiYgY29uc29sZS5lcnJvcilcXG5cXHQgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZTsgfSk7XFxuXFx0ICAgIH07XFxuXFx0fSkuY2FsbChUb2tlbml6ZXIucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbW9kZS90ZXh0X2hpZ2hsaWdodF9ydWxlc1xcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9sYW5nXFxcIik7XFxuXFxuXFx0dmFyIFRleHRIaWdobGlnaHRSdWxlcyA9IGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICB0aGlzLiRydWxlcyA9IHtcXG5cXHQgICAgICAgIFxcXCJzdGFydFxcXCIgOiBbe1xcblxcdCAgICAgICAgICAgIHRva2VuIDogXFxcImVtcHR5X2xpbmVcXFwiLFxcblxcdCAgICAgICAgICAgIHJlZ2V4IDogJ14kJ1xcblxcdCAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgIGRlZmF1bHRUb2tlbiA6IFxcXCJ0ZXh0XFxcIlxcblxcdCAgICAgICAgfV1cXG5cXHQgICAgfTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXG5cXHQgICAgdGhpcy5hZGRSdWxlcyA9IGZ1bmN0aW9uKHJ1bGVzLCBwcmVmaXgpIHtcXG5cXHQgICAgICAgIGlmICghcHJlZml4KSB7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJ1bGVzKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRydWxlc1trZXldID0gcnVsZXNba2V5XTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gcnVsZXMpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlc1trZXldO1xcblxcdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJ1bGUgPSBzdGF0ZVtpXTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dCB8fCBydWxlLm9uTWF0Y2gpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5uZXh0ICE9IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dFN0YXRlICYmIHJ1bGUubmV4dFN0YXRlLmluZGV4T2YocHJlZml4KSAhPT0gMClcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5uZXh0U3RhdGUgPSBwcmVmaXggKyBydWxlLm5leHRTdGF0ZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubmV4dC5pbmRleE9mKHByZWZpeCkgIT09IDApXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHByZWZpeCArIHJ1bGUubmV4dDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB0aGlzLiRydWxlc1twcmVmaXggKyBrZXldID0gc3RhdGU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0UnVsZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRydWxlcztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5lbWJlZFJ1bGVzID0gZnVuY3Rpb24gKEhpZ2hsaWdodFJ1bGVzLCBwcmVmaXgsIGVzY2FwZVJ1bGVzLCBzdGF0ZXMsIGFwcGVuZCkge1xcblxcdCAgICAgICAgdmFyIGVtYmVkUnVsZXMgPSB0eXBlb2YgSGlnaGxpZ2h0UnVsZXMgPT0gXFxcImZ1bmN0aW9uXFxcIlxcblxcdCAgICAgICAgICAgID8gbmV3IEhpZ2hsaWdodFJ1bGVzKCkuZ2V0UnVsZXMoKVxcblxcdCAgICAgICAgICAgIDogSGlnaGxpZ2h0UnVsZXM7XFxuXFx0ICAgICAgICBpZiAoc3RhdGVzKSB7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZXMubGVuZ3RoOyBpKyspXFxuXFx0ICAgICAgICAgICAgICAgIHN0YXRlc1tpXSA9IHByZWZpeCArIHN0YXRlc1tpXTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgc3RhdGVzID0gW107XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGVtYmVkUnVsZXMpXFxuXFx0ICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHByZWZpeCArIGtleSk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLmFkZFJ1bGVzKGVtYmVkUnVsZXMsIHByZWZpeCk7XFxuXFxuXFx0ICAgICAgICBpZiAoZXNjYXBlUnVsZXMpIHtcXG5cXHQgICAgICAgICAgICB2YXIgYWRkUnVsZXMgPSBBcnJheS5wcm90b3R5cGVbYXBwZW5kID8gXFxcInB1c2hcXFwiIDogXFxcInVuc2hpZnRcXFwiXTtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkrKylcXG5cXHQgICAgICAgICAgICAgICAgYWRkUnVsZXMuYXBwbHkodGhpcy4kcnVsZXNbc3RhdGVzW2ldXSwgbGFuZy5kZWVwQ29weShlc2NhcGVSdWxlcykpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKCF0aGlzLiRlbWJlZHMpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kZW1iZWRzID0gW107XFxuXFx0ICAgICAgICB0aGlzLiRlbWJlZHMucHVzaChwcmVmaXgpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldEVtYmVkcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGVtYmVkcztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdmFyIHB1c2hTdGF0ZSA9IGZ1bmN0aW9uKGN1cnJlbnRTdGF0ZSwgc3RhY2spIHtcXG5cXHQgICAgICAgIGlmIChjdXJyZW50U3RhdGUgIT0gXFxcInN0YXJ0XFxcIiB8fCBzdGFjay5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgc3RhY2sudW5zaGlmdCh0aGlzLm5leHRTdGF0ZSwgY3VycmVudFN0YXRlKTtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLm5leHRTdGF0ZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdmFyIHBvcFN0YXRlID0gZnVuY3Rpb24oY3VycmVudFN0YXRlLCBzdGFjaykge1xcblxcdCAgICAgICAgc3RhY2suc2hpZnQoKTtcXG5cXHQgICAgICAgIHJldHVybiBzdGFjay5zaGlmdCgpIHx8IFxcXCJzdGFydFxcXCI7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMubm9ybWFsaXplUnVsZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBpZCA9IDA7XFxuXFx0ICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLiRydWxlcztcXG5cXHQgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NTdGF0ZShrZXkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlc1trZXldO1xcblxcdCAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NlZCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHN0YXRlW2ldO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIXJ1bGUucmVnZXggJiYgcnVsZS5zdGFydCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcnVsZS5yZWdleCA9IHJ1bGUuc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUubmV4dClcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBydWxlLm5leHQgPSBbXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dC5wdXNoKHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VG9rZW46IHJ1bGUudG9rZW5cXG5cXHQgICAgICAgICAgICAgICAgICAgIH0sIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogcnVsZS50b2tlbiArIFxcXCIuZW5kXFxcIixcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZWdleDogcnVsZS5lbmQgfHwgcnVsZS5zdGFydCxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBcXFwicG9wXFxcIlxcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBydWxlLnRva2VuID0gcnVsZS50b2tlbiArIFxcXCIuc3RhcnRcXFwiO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcnVsZS5wdXNoID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHJ1bGUubmV4dCB8fCBydWxlLnB1c2g7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIEFycmF5LmlzQXJyYXkobmV4dCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZU5hbWUgPSBydWxlLnN0YXRlTmFtZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGVOYW1lKSAge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9IHJ1bGUudG9rZW47XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZU5hbWUgIT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlTmFtZSA9IHN0YXRlTmFtZVswXSB8fCBcXFwiXFxcIjtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNbc3RhdGVOYW1lXSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVOYW1lICs9IGlkKys7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICBydWxlc1tzdGF0ZU5hbWVdID0gbmV4dDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHN0YXRlTmFtZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NTdGF0ZShzdGF0ZU5hbWUpO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQgPT0gXFxcInBvcFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHBvcFN0YXRlO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChydWxlLnB1c2gpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dFN0YXRlID0gcnVsZS5uZXh0IHx8IHJ1bGUucHVzaDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUubmV4dCA9IHB1c2hTdGF0ZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlLnB1c2g7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJ1bGUucnVsZXMpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgaW4gcnVsZS5ydWxlcykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlc1tyXSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNbcl0ucHVzaClcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzW3JdLnB1c2guYXBwbHkocnVsZXNbcl0sIHJ1bGUucnVsZXNbcl0pO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzW3JdID0gcnVsZS5ydWxlc1tyXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJ1bGUuaW5jbHVkZSB8fCB0eXBlb2YgcnVsZSA9PSBcXFwic3RyaW5nXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGluY2x1ZGVOYW1lID0gcnVsZS5pbmNsdWRlIHx8IHJ1bGU7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YXIgdG9JbnNlcnQgPSBydWxlc1tpbmNsdWRlTmFtZV07XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShydWxlKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRvSW5zZXJ0ID0gcnVsZTtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHRvSW5zZXJ0KSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtpLCAxXS5jb25jYXQodG9JbnNlcnQpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubm9Fc2NhcGUpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKHgpIHtyZXR1cm4gIXgubmV4dDt9KTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlLnNwbGljZS5hcHBseShzdGF0ZSwgYXJncyk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpLS07XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b0luc2VydCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChydWxlLmtleXdvcmRNYXApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJ1bGUudG9rZW4gPSB0aGlzLmNyZWF0ZUtleXdvcmRNYXBwZXIoXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5rZXl3b3JkTWFwLCBydWxlLmRlZmF1bHRUb2tlbiB8fCBcXFwidGV4dFxcXCIsIHJ1bGUuY2FzZUluc2Vuc2l0aXZlXFxuXFx0ICAgICAgICAgICAgICAgICAgICApO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGUuZGVmYXVsdFRva2VuO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgT2JqZWN0LmtleXMocnVsZXMpLmZvckVhY2gocHJvY2Vzc1N0YXRlLCB0aGlzKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jcmVhdGVLZXl3b3JkTWFwcGVyID0gZnVuY3Rpb24obWFwLCBkZWZhdWx0VG9rZW4sIGlnbm9yZUNhc2UsIHNwbGl0Q2hhcikge1xcblxcdCAgICAgICAgdmFyIGtleXdvcmRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG5cXHQgICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpIHtcXG5cXHQgICAgICAgICAgICB2YXIgYSA9IG1hcFtjbGFzc05hbWVdO1xcblxcdCAgICAgICAgICAgIGlmIChpZ25vcmVDYXNlKVxcblxcdCAgICAgICAgICAgICAgICBhID0gYS50b0xvd2VyQ2FzZSgpO1xcblxcdCAgICAgICAgICAgIHZhciBsaXN0ID0gYS5zcGxpdChzcGxpdENoYXIgfHwgXFxcInxcXFwiKTtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGg7IGktLTsgKVxcblxcdCAgICAgICAgICAgICAgICBrZXl3b3Jkc1tsaXN0W2ldXSA9IGNsYXNzTmFtZTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihrZXl3b3JkcykpIHtcXG5cXHQgICAgICAgICAgICBrZXl3b3Jkcy5fX3Byb3RvX18gPSBudWxsO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy4ka2V5d29yZExpc3QgPSBPYmplY3Qua2V5cyhrZXl3b3Jkcyk7XFxuXFx0ICAgICAgICBtYXAgPSBudWxsO1xcblxcdCAgICAgICAgcmV0dXJuIGlnbm9yZUNhc2VcXG5cXHQgICAgICAgICAgICA/IGZ1bmN0aW9uKHZhbHVlKSB7cmV0dXJuIGtleXdvcmRzW3ZhbHVlLnRvTG93ZXJDYXNlKCldIHx8IGRlZmF1bHRUb2tlbiB9XFxuXFx0ICAgICAgICAgICAgOiBmdW5jdGlvbih2YWx1ZSkge3JldHVybiBrZXl3b3Jkc1t2YWx1ZV0gfHwgZGVmYXVsdFRva2VuIH07XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0S2V5d29yZHMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRrZXl3b3JkcztcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKFRleHRIaWdobGlnaHRSdWxlcy5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuVGV4dEhpZ2hsaWdodFJ1bGVzID0gVGV4dEhpZ2hsaWdodFJ1bGVzO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb2RlL2JlaGF2aW91clxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBCZWhhdmlvdXIgPSBmdW5jdGlvbigpIHtcXG5cXHQgICB0aGlzLiRiZWhhdmlvdXJzID0ge307XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcblxcdCAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBhY3Rpb24sIGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICBzd2l0Y2ggKHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgICBjYXNlIHRoaXMuJGJlaGF2aW91cnM6XFxuXFx0ICAgICAgICAgICAgICB0aGlzLiRiZWhhdmlvdXJzID0ge307XFxuXFx0ICAgICAgICAgIGNhc2UgdGhpcy4kYmVoYXZpb3Vyc1tuYW1lXTpcXG5cXHQgICAgICAgICAgICAgIHRoaXMuJGJlaGF2aW91cnNbbmFtZV0gPSB7fTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuJGJlaGF2aW91cnNbbmFtZV1bYWN0aW9uXSA9IGNhbGxiYWNrO1xcblxcdCAgICB9XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmFkZEJlaGF2aW91cnMgPSBmdW5jdGlvbiAoYmVoYXZpb3Vycykge1xcblxcdCAgICAgICAgZm9yICh2YXIga2V5IGluIGJlaGF2aW91cnMpIHtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBhY3Rpb24gaW4gYmVoYXZpb3Vyc1trZXldKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKGtleSwgYWN0aW9uLCBiZWhhdmlvdXJzW2tleV1bYWN0aW9uXSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kYmVoYXZpb3VycyAmJiB0aGlzLiRiZWhhdmlvdXJzW25hbWVdKSB7XFxuXFx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGJlaGF2aW91cnNbbmFtZV07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuaW5oZXJpdCA9IGZ1bmN0aW9uIChtb2RlLCBmaWx0ZXIpIHtcXG5cXHQgICAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdCAgICAgICAgICAgIHZhciBiZWhhdmlvdXJzID0gbmV3IG1vZGUoKS5nZXRCZWhhdmlvdXJzKGZpbHRlcik7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBiZWhhdmlvdXJzID0gbW9kZS5nZXRCZWhhdmlvdXJzKGZpbHRlcik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmFkZEJlaGF2aW91cnMoYmVoYXZpb3Vycyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuZ2V0QmVoYXZpb3VycyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcXG5cXHQgICAgICAgIGlmICghZmlsdGVyKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGJlaGF2aW91cnM7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciByZXQgPSB7fVxcblxcdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLiRiZWhhdmlvdXJzW2ZpbHRlcltpXV0pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldFtmaWx0ZXJbaV1dID0gdGhpcy4kYmVoYXZpb3Vyc1tmaWx0ZXJbaV1dO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJldHVybiByZXQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHR9KS5jYWxsKEJlaGF2aW91ci5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuQmVoYXZpb3VyID0gQmVoYXZpb3VyO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS91bmljb2RlXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFx0ZXhwb3J0cy5wYWNrYWdlcyA9IHt9O1xcblxcblxcdGFkZFVuaWNvZGVQYWNrYWdlKHtcXG5cXHQgICAgTDogIFxcXCIwMDQxLTAwNUEwMDYxLTAwN0EwMEFBMDBCNTAwQkEwMEMwLTAwRDYwMEQ4LTAwRjYwMEY4LTAyQzEwMkM2LTAyRDEwMkUwLTAyRTQwMkVDMDJFRTAzNzAtMDM3NDAzNzYwMzc3MDM3QS0wMzdEMDM4NjAzODgtMDM4QTAzOEMwMzhFLTAzQTEwM0EzLTAzRjUwM0Y3LTA0ODEwNDhBLTA1MjUwNTMxLTA1NTYwNTU5MDU2MS0wNTg3MDVEMC0wNUVBMDVGMC0wNUYyMDYyMS0wNjRBMDY2RTA2NkYwNjcxLTA2RDMwNkQ1MDZFNTA2RTYwNkVFMDZFRjA2RkEtMDZGQzA2RkYwNzEwMDcxMi0wNzJGMDc0RC0wN0E1MDdCMTA3Q0EtMDdFQTA3RjQwN0Y1MDdGQTA4MDAtMDgxNTA4MUEwODI0MDgyODA5MDQtMDkzOTA5M0QwOTUwMDk1OC0wOTYxMDk3MTA5NzIwOTc5LTA5N0YwOTg1LTA5OEMwOThGMDk5MDA5OTMtMDlBODA5QUEtMDlCMDA5QjIwOUI2LTA5QjkwOUJEMDlDRTA5REMwOUREMDlERi0wOUUxMDlGMDA5RjEwQTA1LTBBMEEwQTBGMEExMDBBMTMtMEEyODBBMkEtMEEzMDBBMzIwQTMzMEEzNTBBMzYwQTM4MEEzOTBBNTktMEE1QzBBNUUwQTcyLTBBNzQwQTg1LTBBOEQwQThGLTBBOTEwQTkzLTBBQTgwQUFBLTBBQjAwQUIyMEFCMzBBQjUtMEFCOTBBQkQwQUQwMEFFMDBBRTEwQjA1LTBCMEMwQjBGMEIxMDBCMTMtMEIyODBCMkEtMEIzMDBCMzIwQjMzMEIzNS0wQjM5MEIzRDBCNUMwQjVEMEI1Ri0wQjYxMEI3MTBCODMwQjg1LTBCOEEwQjhFLTBCOTAwQjkyLTBCOTUwQjk5MEI5QTBCOUMwQjlFMEI5RjBCQTMwQkE0MEJBOC0wQkFBMEJBRS0wQkI5MEJEMDBDMDUtMEMwQzBDMEUtMEMxMDBDMTItMEMyODBDMkEtMEMzMzBDMzUtMEMzOTBDM0QwQzU4MEM1OTBDNjAwQzYxMEM4NS0wQzhDMEM4RS0wQzkwMEM5Mi0wQ0E4MENBQS0wQ0IzMENCNS0wQ0I5MENCRDBDREUwQ0UwMENFMTBEMDUtMEQwQzBEMEUtMEQxMDBEMTItMEQyODBEMkEtMEQzOTBEM0QwRDYwMEQ2MTBEN0EtMEQ3RjBEODUtMEQ5NjBEOUEtMERCMTBEQjMtMERCQjBEQkQwREMwLTBEQzYwRTAxLTBFMzAwRTMyMEUzMzBFNDAtMEU0NjBFODEwRTgyMEU4NDBFODcwRTg4MEU4QTBFOEQwRTk0LTBFOTcwRTk5LTBFOUYwRUExLTBFQTMwRUE1MEVBNzBFQUEwRUFCMEVBRC0wRUIwMEVCMjBFQjMwRUJEMEVDMC0wRUM0MEVDNjBFREMwRUREMEYwMDBGNDAtMEY0NzBGNDktMEY2QzBGODgtMEY4QjEwMDAtMTAyQTEwM0YxMDUwLTEwNTUxMDVBLTEwNUQxMDYxMTA2NTEwNjYxMDZFLTEwNzAxMDc1LTEwODExMDhFMTBBMC0xMEM1MTBEMC0xMEZBMTBGQzExMDAtMTI0ODEyNEEtMTI0RDEyNTAtMTI1NjEyNTgxMjVBLTEyNUQxMjYwLTEyODgxMjhBLTEyOEQxMjkwLTEyQjAxMkIyLTEyQjUxMkI4LTEyQkUxMkMwMTJDMi0xMkM1MTJDOC0xMkQ2MTJEOC0xMzEwMTMxMi0xMzE1MTMxOC0xMzVBMTM4MC0xMzhGMTNBMC0xM0Y0MTQwMS0xNjZDMTY2Ri0xNjdGMTY4MS0xNjlBMTZBMC0xNkVBMTcwMC0xNzBDMTcwRS0xNzExMTcyMC0xNzMxMTc0MC0xNzUxMTc2MC0xNzZDMTc2RS0xNzcwMTc4MC0xN0IzMTdENzE3REMxODIwLTE4NzcxODgwLTE4QTgxOEFBMThCMC0xOEY1MTkwMC0xOTFDMTk1MC0xOTZEMTk3MC0xOTc0MTk4MC0xOUFCMTlDMS0xOUM3MUEwMC0xQTE2MUEyMC0xQTU0MUFBNzFCMDUtMUIzMzFCNDUtMUI0QjFCODMtMUJBMDFCQUUxQkFGMUMwMC0xQzIzMUM0RC0xQzRGMUM1QS0xQzdEMUNFOS0xQ0VDMUNFRS0xQ0YxMUQwMC0xREJGMUUwMC0xRjE1MUYxOC0xRjFEMUYyMC0xRjQ1MUY0OC0xRjREMUY1MC0xRjU3MUY1OTFGNUIxRjVEMUY1Ri0xRjdEMUY4MC0xRkI0MUZCNi0xRkJDMUZCRTFGQzItMUZDNDFGQzYtMUZDQzFGRDAtMUZEMzFGRDYtMUZEQjFGRTAtMUZFQzFGRjItMUZGNDFGRjYtMUZGQzIwNzEyMDdGMjA5MC0yMDk0MjEwMjIxMDcyMTBBLTIxMTMyMTE1MjExOS0yMTFEMjEyNDIxMjYyMTI4MjEyQS0yMTJEMjEyRi0yMTM5MjEzQy0yMTNGMjE0NS0yMTQ5MjE0RTIxODMyMTg0MkMwMC0yQzJFMkMzMC0yQzVFMkM2MC0yQ0U0MkNFQi0yQ0VFMkQwMC0yRDI1MkQzMC0yRDY1MkQ2RjJEODAtMkQ5NjJEQTAtMkRBNjJEQTgtMkRBRTJEQjAtMkRCNjJEQjgtMkRCRTJEQzAtMkRDNjJEQzgtMkRDRTJERDAtMkRENjJERDgtMkRERTJFMkYzMDA1MzAwNjMwMzEtMzAzNTMwM0IzMDNDMzA0MS0zMDk2MzA5RC0zMDlGMzBBMS0zMEZBMzBGQy0zMEZGMzEwNS0zMTJEMzEzMS0zMThFMzFBMC0zMUI3MzFGMC0zMUZGMzQwMC00REI1NEUwMC05RkNCQTAwMC1BNDhDQTREMC1BNEZEQTUwMC1BNjBDQTYxMC1BNjFGQTYyQUE2MkJBNjQwLUE2NUZBNjYyLUE2NkVBNjdGLUE2OTdBNkEwLUE2RTVBNzE3LUE3MUZBNzIyLUE3ODhBNzhCQTc4Q0E3RkItQTgwMUE4MDMtQTgwNUE4MDctQTgwQUE4MEMtQTgyMkE4NDAtQTg3M0E4ODItQThCM0E4RjItQThGN0E4RkJBOTBBLUE5MjVBOTMwLUE5NDZBOTYwLUE5N0NBOTg0LUE5QjJBOUNGQUEwMC1BQTI4QUE0MC1BQTQyQUE0NC1BQTRCQUE2MC1BQTc2QUE3QUFBODAtQUFBRkFBQjFBQUI1QUFCNkFBQjktQUFCREFBQzBBQUMyQUFEQi1BQUREQUJDMC1BQkUyQUMwMC1EN0EzRDdCMC1EN0M2RDdDQi1EN0ZCRjkwMC1GQTJERkEzMC1GQTZERkE3MC1GQUQ5RkIwMC1GQjA2RkIxMy1GQjE3RkIxREZCMUYtRkIyOEZCMkEtRkIzNkZCMzgtRkIzQ0ZCM0VGQjQwRkI0MUZCNDNGQjQ0RkI0Ni1GQkIxRkJEMy1GRDNERkQ1MC1GRDhGRkQ5Mi1GREM3RkRGMC1GREZCRkU3MC1GRTc0RkU3Ni1GRUZDRkYyMS1GRjNBRkY0MS1GRjVBRkY2Ni1GRkJFRkZDMi1GRkM3RkZDQS1GRkNGRkZEMi1GRkQ3RkZEQS1GRkRDXFxcIixcXG5cXHQgICAgTGw6IFxcXCIwMDYxLTAwN0EwMEFBMDBCNTAwQkEwMERGLTAwRjYwMEY4LTAwRkYwMTAxMDEwMzAxMDUwMTA3MDEwOTAxMEIwMTBEMDEwRjAxMTEwMTEzMDExNTAxMTcwMTE5MDExQjAxMUQwMTFGMDEyMTAxMjMwMTI1MDEyNzAxMjkwMTJCMDEyRDAxMkYwMTMxMDEzMzAxMzUwMTM3MDEzODAxM0EwMTNDMDEzRTAxNDAwMTQyMDE0NDAxNDYwMTQ4MDE0OTAxNEIwMTREMDE0RjAxNTEwMTUzMDE1NTAxNTcwMTU5MDE1QjAxNUQwMTVGMDE2MTAxNjMwMTY1MDE2NzAxNjkwMTZCMDE2RDAxNkYwMTcxMDE3MzAxNzUwMTc3MDE3QTAxN0MwMTdFLTAxODAwMTgzMDE4NTAxODgwMThDMDE4RDAxOTIwMTk1MDE5OS0wMTlCMDE5RTAxQTEwMUEzMDFBNTAxQTgwMUFBMDFBQjAxQUQwMUIwMDFCNDAxQjYwMUI5MDFCQTAxQkQtMDFCRjAxQzYwMUM5MDFDQzAxQ0UwMUQwMDFEMjAxRDQwMUQ2MDFEODAxREEwMURDMDFERDAxREYwMUUxMDFFMzAxRTUwMUU3MDFFOTAxRUIwMUVEMDFFRjAxRjAwMUYzMDFGNTAxRjkwMUZCMDFGRDAxRkYwMjAxMDIwMzAyMDUwMjA3MDIwOTAyMEIwMjBEMDIwRjAyMTEwMjEzMDIxNTAyMTcwMjE5MDIxQjAyMUQwMjFGMDIyMTAyMjMwMjI1MDIyNzAyMjkwMjJCMDIyRDAyMkYwMjMxMDIzMy0wMjM5MDIzQzAyM0YwMjQwMDI0MjAyNDcwMjQ5MDI0QjAyNEQwMjRGLTAyOTMwMjk1LTAyQUYwMzcxMDM3MzAzNzcwMzdCLTAzN0QwMzkwMDNBQy0wM0NFMDNEMDAzRDEwM0Q1LTAzRDcwM0Q5MDNEQjAzREQwM0RGMDNFMTAzRTMwM0U1MDNFNzAzRTkwM0VCMDNFRDAzRUYtMDNGMzAzRjUwM0Y4MDNGQjAzRkMwNDMwLTA0NUYwNDYxMDQ2MzA0NjUwNDY3MDQ2OTA0NkIwNDZEMDQ2RjA0NzEwNDczMDQ3NTA0NzcwNDc5MDQ3QjA0N0QwNDdGMDQ4MTA0OEIwNDhEMDQ4RjA0OTEwNDkzMDQ5NTA0OTcwNDk5MDQ5QjA0OUQwNDlGMDRBMTA0QTMwNEE1MDRBNzA0QTkwNEFCMDRBRDA0QUYwNEIxMDRCMzA0QjUwNEI3MDRCOTA0QkIwNEJEMDRCRjA0QzIwNEM0MDRDNjA0QzgwNENBMDRDQzA0Q0UwNENGMDREMTA0RDMwNEQ1MDRENzA0RDkwNERCMDRERDA0REYwNEUxMDRFMzA0RTUwNEU3MDRFOTA0RUIwNEVEMDRFRjA0RjEwNEYzMDRGNTA0RjcwNEY5MDRGQjA0RkQwNEZGMDUwMTA1MDMwNTA1MDUwNzA1MDkwNTBCMDUwRDA1MEYwNTExMDUxMzA1MTUwNTE3MDUxOTA1MUIwNTFEMDUxRjA1MjEwNTIzMDUyNTA1NjEtMDU4NzFEMDAtMUQyQjFENjItMUQ3NzFENzktMUQ5QTFFMDExRTAzMUUwNTFFMDcxRTA5MUUwQjFFMEQxRTBGMUUxMTFFMTMxRTE1MUUxNzFFMTkxRTFCMUUxRDFFMUYxRTIxMUUyMzFFMjUxRTI3MUUyOTFFMkIxRTJEMUUyRjFFMzExRTMzMUUzNTFFMzcxRTM5MUUzQjFFM0QxRTNGMUU0MTFFNDMxRTQ1MUU0NzFFNDkxRTRCMUU0RDFFNEYxRTUxMUU1MzFFNTUxRTU3MUU1OTFFNUIxRTVEMUU1RjFFNjExRTYzMUU2NTFFNjcxRTY5MUU2QjFFNkQxRTZGMUU3MTFFNzMxRTc1MUU3NzFFNzkxRTdCMUU3RDFFN0YxRTgxMUU4MzFFODUxRTg3MUU4OTFFOEIxRThEMUU4RjFFOTExRTkzMUU5NS0xRTlEMUU5RjFFQTExRUEzMUVBNTFFQTcxRUE5MUVBQjFFQUQxRUFGMUVCMTFFQjMxRUI1MUVCNzFFQjkxRUJCMUVCRDFFQkYxRUMxMUVDMzFFQzUxRUM3MUVDOTFFQ0IxRUNEMUVDRjFFRDExRUQzMUVENTFFRDcxRUQ5MUVEQjFFREQxRURGMUVFMTFFRTMxRUU1MUVFNzFFRTkxRUVCMUVFRDFFRUYxRUYxMUVGMzFFRjUxRUY3MUVGOTFFRkIxRUZEMUVGRi0xRjA3MUYxMC0xRjE1MUYyMC0xRjI3MUYzMC0xRjM3MUY0MC0xRjQ1MUY1MC0xRjU3MUY2MC0xRjY3MUY3MC0xRjdEMUY4MC0xRjg3MUY5MC0xRjk3MUZBMC0xRkE3MUZCMC0xRkI0MUZCNjFGQjcxRkJFMUZDMi0xRkM0MUZDNjFGQzcxRkQwLTFGRDMxRkQ2MUZENzFGRTAtMUZFNzFGRjItMUZGNDFGRjYxRkY3MjEwQTIxMEUyMTBGMjExMzIxMkYyMTM0MjEzOTIxM0MyMTNEMjE0Ni0yMTQ5MjE0RTIxODQyQzMwLTJDNUUyQzYxMkM2NTJDNjYyQzY4MkM2QTJDNkMyQzcxMkM3MzJDNzQyQzc2LTJDN0MyQzgxMkM4MzJDODUyQzg3MkM4OTJDOEIyQzhEMkM4RjJDOTEyQzkzMkM5NTJDOTcyQzk5MkM5QjJDOUQyQzlGMkNBMTJDQTMyQ0E1MkNBNzJDQTkyQ0FCMkNBRDJDQUYyQ0IxMkNCMzJDQjUyQ0I3MkNCOTJDQkIyQ0JEMkNCRjJDQzEyQ0MzMkNDNTJDQzcyQ0M5MkNDQjJDQ0QyQ0NGMkNEMTJDRDMyQ0Q1MkNENzJDRDkyQ0RCMkNERDJDREYyQ0UxMkNFMzJDRTQyQ0VDMkNFRTJEMDAtMkQyNUE2NDFBNjQzQTY0NUE2NDdBNjQ5QTY0QkE2NERBNjRGQTY1MUE2NTNBNjU1QTY1N0E2NTlBNjVCQTY1REE2NUZBNjYzQTY2NUE2NjdBNjY5QTY2QkE2NkRBNjgxQTY4M0E2ODVBNjg3QTY4OUE2OEJBNjhEQTY4RkE2OTFBNjkzQTY5NUE2OTdBNzIzQTcyNUE3MjdBNzI5QTcyQkE3MkRBNzJGLUE3MzFBNzMzQTczNUE3MzdBNzM5QTczQkE3M0RBNzNGQTc0MUE3NDNBNzQ1QTc0N0E3NDlBNzRCQTc0REE3NEZBNzUxQTc1M0E3NTVBNzU3QTc1OUE3NUJBNzVEQTc1RkE3NjFBNzYzQTc2NUE3NjdBNzY5QTc2QkE3NkRBNzZGQTc3MS1BNzc4QTc3QUE3N0NBNzdGQTc4MUE3ODNBNzg1QTc4N0E3OENGQjAwLUZCMDZGQjEzLUZCMTdGRjQxLUZGNUFcXFwiLFxcblxcdCAgICBMdTogXFxcIjAwNDEtMDA1QTAwQzAtMDBENjAwRDgtMDBERTAxMDAwMTAyMDEwNDAxMDYwMTA4MDEwQTAxMEMwMTBFMDExMDAxMTIwMTE0MDExNjAxMTgwMTFBMDExQzAxMUUwMTIwMDEyMjAxMjQwMTI2MDEyODAxMkEwMTJDMDEyRTAxMzAwMTMyMDEzNDAxMzYwMTM5MDEzQjAxM0QwMTNGMDE0MTAxNDMwMTQ1MDE0NzAxNEEwMTRDMDE0RTAxNTAwMTUyMDE1NDAxNTYwMTU4MDE1QTAxNUMwMTVFMDE2MDAxNjIwMTY0MDE2NjAxNjgwMTZBMDE2QzAxNkUwMTcwMDE3MjAxNzQwMTc2MDE3ODAxNzkwMTdCMDE3RDAxODEwMTgyMDE4NDAxODYwMTg3MDE4OS0wMThCMDE4RS0wMTkxMDE5MzAxOTQwMTk2LTAxOTgwMTlDMDE5RDAxOUYwMUEwMDFBMjAxQTQwMUE2MDFBNzAxQTkwMUFDMDFBRTAxQUYwMUIxLTAxQjMwMUI1MDFCNzAxQjgwMUJDMDFDNDAxQzcwMUNBMDFDRDAxQ0YwMUQxMDFEMzAxRDUwMUQ3MDFEOTAxREIwMURFMDFFMDAxRTIwMUU0MDFFNjAxRTgwMUVBMDFFQzAxRUUwMUYxMDFGNDAxRjYtMDFGODAxRkEwMUZDMDFGRTAyMDAwMjAyMDIwNDAyMDYwMjA4MDIwQTAyMEMwMjBFMDIxMDAyMTIwMjE0MDIxNjAyMTgwMjFBMDIxQzAyMUUwMjIwMDIyMjAyMjQwMjI2MDIyODAyMkEwMjJDMDIyRTAyMzAwMjMyMDIzQTAyM0IwMjNEMDIzRTAyNDEwMjQzLTAyNDYwMjQ4MDI0QTAyNEMwMjRFMDM3MDAzNzIwMzc2MDM4NjAzODgtMDM4QTAzOEMwMzhFMDM4RjAzOTEtMDNBMTAzQTMtMDNBQjAzQ0YwM0QyLTAzRDQwM0Q4MDNEQTAzREMwM0RFMDNFMDAzRTIwM0U0MDNFNjAzRTgwM0VBMDNFQzAzRUUwM0Y0MDNGNzAzRjkwM0ZBMDNGRC0wNDJGMDQ2MDA0NjIwNDY0MDQ2NjA0NjgwNDZBMDQ2QzA0NkUwNDcwMDQ3MjA0NzQwNDc2MDQ3ODA0N0EwNDdDMDQ3RTA0ODAwNDhBMDQ4QzA0OEUwNDkwMDQ5MjA0OTQwNDk2MDQ5ODA0OUEwNDlDMDQ5RTA0QTAwNEEyMDRBNDA0QTYwNEE4MDRBQTA0QUMwNEFFMDRCMDA0QjIwNEI0MDRCNjA0QjgwNEJBMDRCQzA0QkUwNEMwMDRDMTA0QzMwNEM1MDRDNzA0QzkwNENCMDRDRDA0RDAwNEQyMDRENDA0RDYwNEQ4MDREQTA0REMwNERFMDRFMDA0RTIwNEU0MDRFNjA0RTgwNEVBMDRFQzA0RUUwNEYwMDRGMjA0RjQwNEY2MDRGODA0RkEwNEZDMDRGRTA1MDAwNTAyMDUwNDA1MDYwNTA4MDUwQTA1MEMwNTBFMDUxMDA1MTIwNTE0MDUxNjA1MTgwNTFBMDUxQzA1MUUwNTIwMDUyMjA1MjQwNTMxLTA1NTYxMEEwLTEwQzUxRTAwMUUwMjFFMDQxRTA2MUUwODFFMEExRTBDMUUwRTFFMTAxRTEyMUUxNDFFMTYxRTE4MUUxQTFFMUMxRTFFMUUyMDFFMjIxRTI0MUUyNjFFMjgxRTJBMUUyQzFFMkUxRTMwMUUzMjFFMzQxRTM2MUUzODFFM0ExRTNDMUUzRTFFNDAxRTQyMUU0NDFFNDYxRTQ4MUU0QTFFNEMxRTRFMUU1MDFFNTIxRTU0MUU1NjFFNTgxRTVBMUU1QzFFNUUxRTYwMUU2MjFFNjQxRTY2MUU2ODFFNkExRTZDMUU2RTFFNzAxRTcyMUU3NDFFNzYxRTc4MUU3QTFFN0MxRTdFMUU4MDFFODIxRTg0MUU4NjFFODgxRThBMUU4QzFFOEUxRTkwMUU5MjFFOTQxRTlFMUVBMDFFQTIxRUE0MUVBNjFFQTgxRUFBMUVBQzFFQUUxRUIwMUVCMjFFQjQxRUI2MUVCODFFQkExRUJDMUVCRTFFQzAxRUMyMUVDNDFFQzYxRUM4MUVDQTFFQ0MxRUNFMUVEMDFFRDIxRUQ0MUVENjFFRDgxRURBMUVEQzFFREUxRUUwMUVFMjFFRTQxRUU2MUVFODFFRUExRUVDMUVFRTFFRjAxRUYyMUVGNDFFRjYxRUY4MUVGQTFFRkMxRUZFMUYwOC0xRjBGMUYxOC0xRjFEMUYyOC0xRjJGMUYzOC0xRjNGMUY0OC0xRjREMUY1OTFGNUIxRjVEMUY1RjFGNjgtMUY2RjFGQjgtMUZCQjFGQzgtMUZDQjFGRDgtMUZEQjFGRTgtMUZFQzFGRjgtMUZGQjIxMDIyMTA3MjEwQi0yMTBEMjExMC0yMTEyMjExNTIxMTktMjExRDIxMjQyMTI2MjEyODIxMkEtMjEyRDIxMzAtMjEzMzIxM0UyMTNGMjE0NTIxODMyQzAwLTJDMkUyQzYwMkM2Mi0yQzY0MkM2NzJDNjkyQzZCMkM2RC0yQzcwMkM3MjJDNzUyQzdFLTJDODAyQzgyMkM4NDJDODYyQzg4MkM4QTJDOEMyQzhFMkM5MDJDOTIyQzk0MkM5NjJDOTgyQzlBMkM5QzJDOUUyQ0EwMkNBMjJDQTQyQ0E2MkNBODJDQUEyQ0FDMkNBRTJDQjAyQ0IyMkNCNDJDQjYyQ0I4MkNCQTJDQkMyQ0JFMkNDMDJDQzIyQ0M0MkNDNjJDQzgyQ0NBMkNDQzJDQ0UyQ0QwMkNEMjJDRDQyQ0Q2MkNEODJDREEyQ0RDMkNERTJDRTAyQ0UyMkNFQjJDRURBNjQwQTY0MkE2NDRBNjQ2QTY0OEE2NEFBNjRDQTY0RUE2NTBBNjUyQTY1NEE2NTZBNjU4QTY1QUE2NUNBNjVFQTY2MkE2NjRBNjY2QTY2OEE2NkFBNjZDQTY4MEE2ODJBNjg0QTY4NkE2ODhBNjhBQTY4Q0E2OEVBNjkwQTY5MkE2OTRBNjk2QTcyMkE3MjRBNzI2QTcyOEE3MkFBNzJDQTcyRUE3MzJBNzM0QTczNkE3MzhBNzNBQTczQ0E3M0VBNzQwQTc0MkE3NDRBNzQ2QTc0OEE3NEFBNzRDQTc0RUE3NTBBNzUyQTc1NEE3NTZBNzU4QTc1QUE3NUNBNzVFQTc2MEE3NjJBNzY0QTc2NkE3NjhBNzZBQTc2Q0E3NkVBNzc5QTc3QkE3N0RBNzdFQTc4MEE3ODJBNzg0QTc4NkE3OEJGRjIxLUZGM0FcXFwiLFxcblxcdCAgICBMdDogXFxcIjAxQzUwMUM4MDFDQjAxRjIxRjg4LTFGOEYxRjk4LTFGOUYxRkE4LTFGQUYxRkJDMUZDQzFGRkNcXFwiLFxcblxcdCAgICBMbTogXFxcIjAyQjAtMDJDMTAyQzYtMDJEMTAyRTAtMDJFNDAyRUMwMkVFMDM3NDAzN0EwNTU5MDY0MDA2RTUwNkU2MDdGNDA3RjUwN0ZBMDgxQTA4MjQwODI4MDk3MTBFNDYwRUM2MTBGQzE3RDcxODQzMUFBNzFDNzgtMUM3RDFEMkMtMUQ2MTFENzgxRDlCLTFEQkYyMDcxMjA3RjIwOTAtMjA5NDJDN0QyRDZGMkUyRjMwMDUzMDMxLTMwMzUzMDNCMzA5RDMwOUUzMEZDLTMwRkVBMDE1QTRGOC1BNEZEQTYwQ0E2N0ZBNzE3LUE3MUZBNzcwQTc4OEE5Q0ZBQTcwQUFEREZGNzBGRjlFRkY5RlxcXCIsXFxuXFx0ICAgIExvOiBcXFwiMDFCQjAxQzAtMDFDMzAyOTQwNUQwLTA1RUEwNUYwLTA1RjIwNjIxLTA2M0YwNjQxLTA2NEEwNjZFMDY2RjA2NzEtMDZEMzA2RDUwNkVFMDZFRjA2RkEtMDZGQzA2RkYwNzEwMDcxMi0wNzJGMDc0RC0wN0E1MDdCMTA3Q0EtMDdFQTA4MDAtMDgxNTA5MDQtMDkzOTA5M0QwOTUwMDk1OC0wOTYxMDk3MjA5NzktMDk3RjA5ODUtMDk4QzA5OEYwOTkwMDk5My0wOUE4MDlBQS0wOUIwMDlCMjA5QjYtMDlCOTA5QkQwOUNFMDlEQzA5REQwOURGLTA5RTEwOUYwMDlGMTBBMDUtMEEwQTBBMEYwQTEwMEExMy0wQTI4MEEyQS0wQTMwMEEzMjBBMzMwQTM1MEEzNjBBMzgwQTM5MEE1OS0wQTVDMEE1RTBBNzItMEE3NDBBODUtMEE4RDBBOEYtMEE5MTBBOTMtMEFBODBBQUEtMEFCMDBBQjIwQUIzMEFCNS0wQUI5MEFCRDBBRDAwQUUwMEFFMTBCMDUtMEIwQzBCMEYwQjEwMEIxMy0wQjI4MEIyQS0wQjMwMEIzMjBCMzMwQjM1LTBCMzkwQjNEMEI1QzBCNUQwQjVGLTBCNjEwQjcxMEI4MzBCODUtMEI4QTBCOEUtMEI5MDBCOTItMEI5NTBCOTkwQjlBMEI5QzBCOUUwQjlGMEJBMzBCQTQwQkE4LTBCQUEwQkFFLTBCQjkwQkQwMEMwNS0wQzBDMEMwRS0wQzEwMEMxMi0wQzI4MEMyQS0wQzMzMEMzNS0wQzM5MEMzRDBDNTgwQzU5MEM2MDBDNjEwQzg1LTBDOEMwQzhFLTBDOTAwQzkyLTBDQTgwQ0FBLTBDQjMwQ0I1LTBDQjkwQ0JEMENERTBDRTAwQ0UxMEQwNS0wRDBDMEQwRS0wRDEwMEQxMi0wRDI4MEQyQS0wRDM5MEQzRDBENjAwRDYxMEQ3QS0wRDdGMEQ4NS0wRDk2MEQ5QS0wREIxMERCMy0wREJCMERCRDBEQzAtMERDNjBFMDEtMEUzMDBFMzIwRTMzMEU0MC0wRTQ1MEU4MTBFODIwRTg0MEU4NzBFODgwRThBMEU4RDBFOTQtMEU5NzBFOTktMEU5RjBFQTEtMEVBMzBFQTUwRUE3MEVBQTBFQUIwRUFELTBFQjAwRUIyMEVCMzBFQkQwRUMwLTBFQzQwRURDMEVERDBGMDAwRjQwLTBGNDcwRjQ5LTBGNkMwRjg4LTBGOEIxMDAwLTEwMkExMDNGMTA1MC0xMDU1MTA1QS0xMDVEMTA2MTEwNjUxMDY2MTA2RS0xMDcwMTA3NS0xMDgxMTA4RTEwRDAtMTBGQTExMDAtMTI0ODEyNEEtMTI0RDEyNTAtMTI1NjEyNTgxMjVBLTEyNUQxMjYwLTEyODgxMjhBLTEyOEQxMjkwLTEyQjAxMkIyLTEyQjUxMkI4LTEyQkUxMkMwMTJDMi0xMkM1MTJDOC0xMkQ2MTJEOC0xMzEwMTMxMi0xMzE1MTMxOC0xMzVBMTM4MC0xMzhGMTNBMC0xM0Y0MTQwMS0xNjZDMTY2Ri0xNjdGMTY4MS0xNjlBMTZBMC0xNkVBMTcwMC0xNzBDMTcwRS0xNzExMTcyMC0xNzMxMTc0MC0xNzUxMTc2MC0xNzZDMTc2RS0xNzcwMTc4MC0xN0IzMTdEQzE4MjAtMTg0MjE4NDQtMTg3NzE4ODAtMThBODE4QUExOEIwLTE4RjUxOTAwLTE5MUMxOTUwLTE5NkQxOTcwLTE5NzQxOTgwLTE5QUIxOUMxLTE5QzcxQTAwLTFBMTYxQTIwLTFBNTQxQjA1LTFCMzMxQjQ1LTFCNEIxQjgzLTFCQTAxQkFFMUJBRjFDMDAtMUMyMzFDNEQtMUM0RjFDNUEtMUM3NzFDRTktMUNFQzFDRUUtMUNGMTIxMzUtMjEzODJEMzAtMkQ2NTJEODAtMkQ5NjJEQTAtMkRBNjJEQTgtMkRBRTJEQjAtMkRCNjJEQjgtMkRCRTJEQzAtMkRDNjJEQzgtMkRDRTJERDAtMkRENjJERDgtMkRERTMwMDYzMDNDMzA0MS0zMDk2MzA5RjMwQTEtMzBGQTMwRkYzMTA1LTMxMkQzMTMxLTMxOEUzMUEwLTMxQjczMUYwLTMxRkYzNDAwLTREQjU0RTAwLTlGQ0JBMDAwLUEwMTRBMDE2LUE0OENBNEQwLUE0RjdBNTAwLUE2MEJBNjEwLUE2MUZBNjJBQTYyQkE2NkVBNkEwLUE2RTVBN0ZCLUE4MDFBODAzLUE4MDVBODA3LUE4MEFBODBDLUE4MjJBODQwLUE4NzNBODgyLUE4QjNBOEYyLUE4RjdBOEZCQTkwQS1BOTI1QTkzMC1BOTQ2QTk2MC1BOTdDQTk4NC1BOUIyQUEwMC1BQTI4QUE0MC1BQTQyQUE0NC1BQTRCQUE2MC1BQTZGQUE3MS1BQTc2QUE3QUFBODAtQUFBRkFBQjFBQUI1QUFCNkFBQjktQUFCREFBQzBBQUMyQUFEQkFBRENBQkMwLUFCRTJBQzAwLUQ3QTNEN0IwLUQ3QzZEN0NCLUQ3RkJGOTAwLUZBMkRGQTMwLUZBNkRGQTcwLUZBRDlGQjFERkIxRi1GQjI4RkIyQS1GQjM2RkIzOC1GQjNDRkIzRUZCNDBGQjQxRkI0M0ZCNDRGQjQ2LUZCQjFGQkQzLUZEM0RGRDUwLUZEOEZGRDkyLUZEQzdGREYwLUZERkJGRTcwLUZFNzRGRTc2LUZFRkNGRjY2LUZGNkZGRjcxLUZGOURGRkEwLUZGQkVGRkMyLUZGQzdGRkNBLUZGQ0ZGRkQyLUZGRDdGRkRBLUZGRENcXFwiLFxcblxcdCAgICBNOiAgXFxcIjAzMDAtMDM2RjA0ODMtMDQ4OTA1OTEtMDVCRDA1QkYwNUMxMDVDMjA1QzQwNUM1MDVDNzA2MTAtMDYxQTA2NEItMDY1RTA2NzAwNkQ2LTA2REMwNkRFLTA2RTQwNkU3MDZFODA2RUEtMDZFRDA3MTEwNzMwLTA3NEEwN0E2LTA3QjAwN0VCLTA3RjMwODE2LTA4MTkwODFCLTA4MjMwODI1LTA4MjcwODI5LTA4MkQwOTAwLTA5MDMwOTNDMDkzRS0wOTRFMDk1MS0wOTU1MDk2MjA5NjMwOTgxLTA5ODMwOUJDMDlCRS0wOUM0MDlDNzA5QzgwOUNCLTA5Q0QwOUQ3MDlFMjA5RTMwQTAxLTBBMDMwQTNDMEEzRS0wQTQyMEE0NzBBNDgwQTRCLTBBNEQwQTUxMEE3MDBBNzEwQTc1MEE4MS0wQTgzMEFCQzBBQkUtMEFDNTBBQzctMEFDOTBBQ0ItMEFDRDBBRTIwQUUzMEIwMS0wQjAzMEIzQzBCM0UtMEI0NDBCNDcwQjQ4MEI0Qi0wQjREMEI1NjBCNTcwQjYyMEI2MzBCODIwQkJFLTBCQzIwQkM2LTBCQzgwQkNBLTBCQ0QwQkQ3MEMwMS0wQzAzMEMzRS0wQzQ0MEM0Ni0wQzQ4MEM0QS0wQzREMEM1NTBDNTYwQzYyMEM2MzBDODIwQzgzMENCQzBDQkUtMENDNDBDQzYtMENDODBDQ0EtMENDRDBDRDUwQ0Q2MENFMjBDRTMwRDAyMEQwMzBEM0UtMEQ0NDBENDYtMEQ0ODBENEEtMEQ0RDBENTcwRDYyMEQ2MzBEODIwRDgzMERDQTBEQ0YtMERENDBERDYwREQ4LTBEREYwREYyMERGMzBFMzEwRTM0LTBFM0EwRTQ3LTBFNEUwRUIxMEVCNC0wRUI5MEVCQjBFQkMwRUM4LTBFQ0QwRjE4MEYxOTBGMzUwRjM3MEYzOTBGM0UwRjNGMEY3MS0wRjg0MEY4NjBGODcwRjkwLTBGOTcwRjk5LTBGQkMwRkM2MTAyQi0xMDNFMTA1Ni0xMDU5MTA1RS0xMDYwMTA2Mi0xMDY0MTA2Ny0xMDZEMTA3MS0xMDc0MTA4Mi0xMDhEMTA4RjEwOUEtMTA5RDEzNUYxNzEyLTE3MTQxNzMyLTE3MzQxNzUyMTc1MzE3NzIxNzczMTdCNi0xN0QzMTdERDE4MEItMTgwRDE4QTkxOTIwLTE5MkIxOTMwLTE5M0IxOUIwLTE5QzAxOUM4MTlDOTFBMTctMUExQjFBNTUtMUE1RTFBNjAtMUE3QzFBN0YxQjAwLTFCMDQxQjM0LTFCNDQxQjZCLTFCNzMxQjgwLTFCODIxQkExLTFCQUExQzI0LTFDMzcxQ0QwLTFDRDIxQ0Q0LTFDRTgxQ0VEMUNGMjFEQzAtMURFNjFERkQtMURGRjIwRDAtMjBGMDJDRUYtMkNGMTJERTAtMkRGRjMwMkEtMzAyRjMwOTkzMDlBQTY2Ri1BNjcyQTY3Q0E2N0RBNkYwQTZGMUE4MDJBODA2QTgwQkE4MjMtQTgyN0E4ODBBODgxQThCNC1BOEM0QThFMC1BOEYxQTkyNi1BOTJEQTk0Ny1BOTUzQTk4MC1BOTgzQTlCMy1BOUMwQUEyOS1BQTM2QUE0M0FBNENBQTREQUE3QkFBQjBBQUIyLUFBQjRBQUI3QUFCOEFBQkVBQUJGQUFDMUFCRTMtQUJFQUFCRUNBQkVERkIxRUZFMDAtRkUwRkZFMjAtRkUyNlxcXCIsXFxuXFx0ICAgIE1uOiBcXFwiMDMwMC0wMzZGMDQ4My0wNDg3MDU5MS0wNUJEMDVCRjA1QzEwNUMyMDVDNDA1QzUwNUM3MDYxMC0wNjFBMDY0Qi0wNjVFMDY3MDA2RDYtMDZEQzA2REYtMDZFNDA2RTcwNkU4MDZFQS0wNkVEMDcxMTA3MzAtMDc0QTA3QTYtMDdCMDA3RUItMDdGMzA4MTYtMDgxOTA4MUItMDgyMzA4MjUtMDgyNzA4MjktMDgyRDA5MDAtMDkwMjA5M0MwOTQxLTA5NDgwOTREMDk1MS0wOTU1MDk2MjA5NjMwOTgxMDlCQzA5QzEtMDlDNDA5Q0QwOUUyMDlFMzBBMDEwQTAyMEEzQzBBNDEwQTQyMEE0NzBBNDgwQTRCLTBBNEQwQTUxMEE3MDBBNzEwQTc1MEE4MTBBODIwQUJDMEFDMS0wQUM1MEFDNzBBQzgwQUNEMEFFMjBBRTMwQjAxMEIzQzBCM0YwQjQxLTBCNDQwQjREMEI1NjBCNjIwQjYzMEI4MjBCQzAwQkNEMEMzRS0wQzQwMEM0Ni0wQzQ4MEM0QS0wQzREMEM1NTBDNTYwQzYyMEM2MzBDQkMwQ0JGMENDNjBDQ0MwQ0NEMENFMjBDRTMwRDQxLTBENDQwRDREMEQ2MjBENjMwRENBMEREMi0wREQ0MERENjBFMzEwRTM0LTBFM0EwRTQ3LTBFNEUwRUIxMEVCNC0wRUI5MEVCQjBFQkMwRUM4LTBFQ0QwRjE4MEYxOTBGMzUwRjM3MEYzOTBGNzEtMEY3RTBGODAtMEY4NDBGODYwRjg3MEY5MC0wRjk3MEY5OS0wRkJDMEZDNjEwMkQtMTAzMDEwMzItMTAzNzEwMzkxMDNBMTAzRDEwM0UxMDU4MTA1OTEwNUUtMTA2MDEwNzEtMTA3NDEwODIxMDg1MTA4NjEwOEQxMDlEMTM1RjE3MTItMTcxNDE3MzItMTczNDE3NTIxNzUzMTc3MjE3NzMxN0I3LTE3QkQxN0M2MTdDOS0xN0QzMTdERDE4MEItMTgwRDE4QTkxOTIwLTE5MjIxOTI3MTkyODE5MzIxOTM5LTE5M0IxQTE3MUExODFBNTYxQTU4LTFBNUUxQTYwMUE2MjFBNjUtMUE2QzFBNzMtMUE3QzFBN0YxQjAwLTFCMDMxQjM0MUIzNi0xQjNBMUIzQzFCNDIxQjZCLTFCNzMxQjgwMUI4MTFCQTItMUJBNTFCQTgxQkE5MUMyQy0xQzMzMUMzNjFDMzcxQ0QwLTFDRDIxQ0Q0LTFDRTAxQ0UyLTFDRTgxQ0VEMURDMC0xREU2MURGRC0xREZGMjBEMC0yMERDMjBFMTIwRTUtMjBGMDJDRUYtMkNGMTJERTAtMkRGRjMwMkEtMzAyRjMwOTkzMDlBQTY2RkE2N0NBNjdEQTZGMEE2RjFBODAyQTgwNkE4MEJBODI1QTgyNkE4QzRBOEUwLUE4RjFBOTI2LUE5MkRBOTQ3LUE5NTFBOTgwLUE5ODJBOUIzQTlCNi1BOUI5QTlCQ0FBMjktQUEyRUFBMzFBQTMyQUEzNUFBMzZBQTQzQUE0Q0FBQjBBQUIyLUFBQjRBQUI3QUFCOEFBQkVBQUJGQUFDMUFCRTVBQkU4QUJFREZCMUVGRTAwLUZFMEZGRTIwLUZFMjZcXFwiLFxcblxcdCAgICBNYzogXFxcIjA5MDMwOTNFLTA5NDAwOTQ5LTA5NEMwOTRFMDk4MjA5ODMwOUJFLTA5QzAwOUM3MDlDODA5Q0IwOUNDMDlENzBBMDMwQTNFLTBBNDAwQTgzMEFCRS0wQUMwMEFDOTBBQ0IwQUNDMEIwMjBCMDMwQjNFMEI0MDBCNDcwQjQ4MEI0QjBCNEMwQjU3MEJCRTBCQkYwQkMxMEJDMjBCQzYtMEJDODBCQ0EtMEJDQzBCRDcwQzAxLTBDMDMwQzQxLTBDNDQwQzgyMEM4MzBDQkUwQ0MwLTBDQzQwQ0M3MENDODBDQ0EwQ0NCMENENTBDRDYwRDAyMEQwMzBEM0UtMEQ0MDBENDYtMEQ0ODBENEEtMEQ0QzBENTcwRDgyMEQ4MzBEQ0YtMEREMTBERDgtMERERjBERjIwREYzMEYzRTBGM0YwRjdGMTAyQjEwMkMxMDMxMTAzODEwM0IxMDNDMTA1NjEwNTcxMDYyLTEwNjQxMDY3LTEwNkQxMDgzMTA4NDEwODctMTA4QzEwOEYxMDlBLTEwOUMxN0I2MTdCRS0xN0M1MTdDNzE3QzgxOTIzLTE5MjYxOTI5LTE5MkIxOTMwMTkzMTE5MzMtMTkzODE5QjAtMTlDMDE5QzgxOUM5MUExOS0xQTFCMUE1NTFBNTcxQTYxMUE2MzFBNjQxQTZELTFBNzIxQjA0MUIzNTFCM0IxQjNELTFCNDExQjQzMUI0NDFCODIxQkExMUJBNjFCQTcxQkFBMUMyNC0xQzJCMUMzNDFDMzUxQ0UxMUNGMkE4MjNBODI0QTgyN0E4ODBBODgxQThCNC1BOEMzQTk1MkE5NTNBOTgzQTlCNEE5QjVBOUJBQTlCQkE5QkQtQTlDMEFBMkZBQTMwQUEzM0FBMzRBQTREQUE3QkFCRTNBQkU0QUJFNkFCRTdBQkU5QUJFQUFCRUNcXFwiLFxcblxcdCAgICBNZTogXFxcIjA0ODgwNDg5MDZERTIwREQtMjBFMDIwRTItMjBFNEE2NzAtQTY3MlxcXCIsXFxuXFx0ICAgIE46ICBcXFwiMDAzMC0wMDM5MDBCMjAwQjMwMEI5MDBCQy0wMEJFMDY2MC0wNjY5MDZGMC0wNkY5MDdDMC0wN0M5MDk2Ni0wOTZGMDlFNi0wOUVGMDlGNC0wOUY5MEE2Ni0wQTZGMEFFNi0wQUVGMEI2Ni0wQjZGMEJFNi0wQkYyMEM2Ni0wQzZGMEM3OC0wQzdFMENFNi0wQ0VGMEQ2Ni0wRDc1MEU1MC0wRTU5MEVEMC0wRUQ5MEYyMC0wRjMzMTA0MC0xMDQ5MTA5MC0xMDk5MTM2OS0xMzdDMTZFRS0xNkYwMTdFMC0xN0U5MTdGMC0xN0Y5MTgxMC0xODE5MTk0Ni0xOTRGMTlEMC0xOURBMUE4MC0xQTg5MUE5MC0xQTk5MUI1MC0xQjU5MUJCMC0xQkI5MUM0MC0xQzQ5MUM1MC0xQzU5MjA3MDIwNzQtMjA3OTIwODAtMjA4OTIxNTAtMjE4MjIxODUtMjE4OTI0NjAtMjQ5QjI0RUEtMjRGRjI3NzYtMjc5MzJDRkQzMDA3MzAyMS0zMDI5MzAzOC0zMDNBMzE5Mi0zMTk1MzIyMC0zMjI5MzI1MS0zMjVGMzI4MC0zMjg5MzJCMS0zMkJGQTYyMC1BNjI5QTZFNi1BNkVGQTgzMC1BODM1QThEMC1BOEQ5QTkwMC1BOTA5QTlEMC1BOUQ5QUE1MC1BQTU5QUJGMC1BQkY5RkYxMC1GRjE5XFxcIixcXG5cXHQgICAgTmQ6IFxcXCIwMDMwLTAwMzkwNjYwLTA2NjkwNkYwLTA2RjkwN0MwLTA3QzkwOTY2LTA5NkYwOUU2LTA5RUYwQTY2LTBBNkYwQUU2LTBBRUYwQjY2LTBCNkYwQkU2LTBCRUYwQzY2LTBDNkYwQ0U2LTBDRUYwRDY2LTBENkYwRTUwLTBFNTkwRUQwLTBFRDkwRjIwLTBGMjkxMDQwLTEwNDkxMDkwLTEwOTkxN0UwLTE3RTkxODEwLTE4MTkxOTQ2LTE5NEYxOUQwLTE5REExQTgwLTFBODkxQTkwLTFBOTkxQjUwLTFCNTkxQkIwLTFCQjkxQzQwLTFDNDkxQzUwLTFDNTlBNjIwLUE2MjlBOEQwLUE4RDlBOTAwLUE5MDlBOUQwLUE5RDlBQTUwLUFBNTlBQkYwLUFCRjlGRjEwLUZGMTlcXFwiLFxcblxcdCAgICBObDogXFxcIjE2RUUtMTZGMDIxNjAtMjE4MjIxODUtMjE4ODMwMDczMDIxLTMwMjkzMDM4LTMwM0FBNkU2LUE2RUZcXFwiLFxcblxcdCAgICBObzogXFxcIjAwQjIwMEIzMDBCOTAwQkMtMDBCRTA5RjQtMDlGOTBCRjAtMEJGMjBDNzgtMEM3RTBENzAtMEQ3NTBGMkEtMEYzMzEzNjktMTM3QzE3RjAtMTdGOTIwNzAyMDc0LTIwNzkyMDgwLTIwODkyMTUwLTIxNUYyMTg5MjQ2MC0yNDlCMjRFQS0yNEZGMjc3Ni0yNzkzMkNGRDMxOTItMzE5NTMyMjAtMzIyOTMyNTEtMzI1RjMyODAtMzI4OTMyQjEtMzJCRkE4MzAtQTgzNVxcXCIsXFxuXFx0ICAgIFA6ICBcXFwiMDAyMS0wMDIzMDAyNS0wMDJBMDAyQy0wMDJGMDAzQTAwM0IwMDNGMDA0MDAwNUItMDA1RDAwNUYwMDdCMDA3RDAwQTEwMEFCMDBCNzAwQkIwMEJGMDM3RTAzODcwNTVBLTA1NUYwNTg5MDU4QTA1QkUwNUMwMDVDMzA1QzYwNUYzMDVGNDA2MDkwNjBBMDYwQzA2MEQwNjFCMDYxRTA2MUYwNjZBLTA2NkQwNkQ0MDcwMC0wNzBEMDdGNy0wN0Y5MDgzMC0wODNFMDk2NDA5NjUwOTcwMERGNDBFNEYwRTVBMEU1QjBGMDQtMEYxMjBGM0EtMEYzRDBGODUwRkQwLTBGRDQxMDRBLTEwNEYxMEZCMTM2MS0xMzY4MTQwMDE2NkQxNjZFMTY5QjE2OUMxNkVCLTE2RUQxNzM1MTczNjE3RDQtMTdENjE3RDgtMTdEQTE4MDAtMTgwQTE5NDQxOTQ1MTlERTE5REYxQTFFMUExRjFBQTAtMUFBNjFBQTgtMUFBRDFCNUEtMUI2MDFDM0ItMUMzRjFDN0UxQzdGMUNEMzIwMTAtMjAyNzIwMzAtMjA0MzIwNDUtMjA1MTIwNTMtMjA1RTIwN0QyMDdFMjA4RDIwOEUyMzI5MjMyQTI3NjgtMjc3NTI3QzUyN0M2MjdFNi0yN0VGMjk4My0yOTk4MjlEOC0yOURCMjlGQzI5RkQyQ0Y5LTJDRkMyQ0ZFMkNGRjJFMDAtMkUyRTJFMzAyRTMxMzAwMS0zMDAzMzAwOC0zMDExMzAxNC0zMDFGMzAzMDMwM0QzMEEwMzBGQkE0RkVBNEZGQTYwRC1BNjBGQTY3M0E2N0VBNkYyLUE2RjdBODc0LUE4NzdBOENFQThDRkE4RjgtQThGQUE5MkVBOTJGQTk1RkE5QzEtQTlDREE5REVBOURGQUE1Qy1BQTVGQUFERUFBREZBQkVCRkQzRUZEM0ZGRTEwLUZFMTlGRTMwLUZFNTJGRTU0LUZFNjFGRTYzRkU2OEZFNkFGRTZCRkYwMS1GRjAzRkYwNS1GRjBBRkYwQy1GRjBGRkYxQUZGMUJGRjFGRkYyMEZGM0ItRkYzREZGM0ZGRjVCRkY1REZGNUYtRkY2NVxcXCIsXFxuXFx0ICAgIFBkOiBcXFwiMDAyRDA1OEEwNUJFMTQwMDE4MDYyMDEwLTIwMTUyRTE3MkUxQTMwMUMzMDMwMzBBMEZFMzFGRTMyRkU1OEZFNjNGRjBEXFxcIixcXG5cXHQgICAgUHM6IFxcXCIwMDI4MDA1QjAwN0IwRjNBMEYzQzE2OUIyMDFBMjAxRTIwNDUyMDdEMjA4RDIzMjkyNzY4Mjc2QTI3NkMyNzZFMjc3MDI3NzIyNzc0MjdDNTI3RTYyN0U4MjdFQTI3RUMyN0VFMjk4MzI5ODUyOTg3Mjk4OTI5OEIyOThEMjk4RjI5OTEyOTkzMjk5NTI5OTcyOUQ4MjlEQTI5RkMyRTIyMkUyNDJFMjYyRTI4MzAwODMwMEEzMDBDMzAwRTMwMTAzMDE0MzAxNjMwMTgzMDFBMzAxREZEM0VGRTE3RkUzNUZFMzdGRTM5RkUzQkZFM0RGRTNGRkU0MUZFNDNGRTQ3RkU1OUZFNUJGRTVERkYwOEZGM0JGRjVCRkY1RkZGNjJcXFwiLFxcblxcdCAgICBQZTogXFxcIjAwMjkwMDVEMDA3RDBGM0IwRjNEMTY5QzIwNDYyMDdFMjA4RTIzMkEyNzY5Mjc2QjI3NkQyNzZGMjc3MTI3NzMyNzc1MjdDNjI3RTcyN0U5MjdFQjI3RUQyN0VGMjk4NDI5ODYyOTg4Mjk4QTI5OEMyOThFMjk5MDI5OTIyOTk0Mjk5NjI5OTgyOUQ5MjlEQjI5RkQyRTIzMkUyNTJFMjcyRTI5MzAwOTMwMEIzMDBEMzAwRjMwMTEzMDE1MzAxNzMwMTkzMDFCMzAxRTMwMUZGRDNGRkUxOEZFMzZGRTM4RkUzQUZFM0NGRTNFRkU0MEZFNDJGRTQ0RkU0OEZFNUFGRTVDRkU1RUZGMDlGRjNERkY1REZGNjBGRjYzXFxcIixcXG5cXHQgICAgUGk6IFxcXCIwMEFCMjAxODIwMUIyMDFDMjAxRjIwMzkyRTAyMkUwNDJFMDkyRTBDMkUxQzJFMjBcXFwiLFxcblxcdCAgICBQZjogXFxcIjAwQkIyMDE5MjAxRDIwM0EyRTAzMkUwNTJFMEEyRTBEMkUxRDJFMjFcXFwiLFxcblxcdCAgICBQYzogXFxcIjAwNUYyMDNGMjA0MDIwNTRGRTMzRkUzNEZFNEQtRkU0RkZGM0ZcXFwiLFxcblxcdCAgICBQbzogXFxcIjAwMjEtMDAyMzAwMjUtMDAyNzAwMkEwMDJDMDAyRTAwMkYwMDNBMDAzQjAwM0YwMDQwMDA1QzAwQTEwMEI3MDBCRjAzN0UwMzg3MDU1QS0wNTVGMDU4OTA1QzAwNUMzMDVDNjA1RjMwNUY0MDYwOTA2MEEwNjBDMDYwRDA2MUIwNjFFMDYxRjA2NkEtMDY2RDA2RDQwNzAwLTA3MEQwN0Y3LTA3RjkwODMwLTA4M0UwOTY0MDk2NTA5NzAwREY0MEU0RjBFNUEwRTVCMEYwNC0wRjEyMEY4NTBGRDAtMEZENDEwNEEtMTA0RjEwRkIxMzYxLTEzNjgxNjZEMTY2RTE2RUItMTZFRDE3MzUxNzM2MTdENC0xN0Q2MTdEOC0xN0RBMTgwMC0xODA1MTgwNy0xODBBMTk0NDE5NDUxOURFMTlERjFBMUUxQTFGMUFBMC0xQUE2MUFBOC0xQUFEMUI1QS0xQjYwMUMzQi0xQzNGMUM3RTFDN0YxQ0QzMjAxNjIwMTcyMDIwLTIwMjcyMDMwLTIwMzgyMDNCLTIwM0UyMDQxLTIwNDMyMDQ3LTIwNTEyMDUzMjA1NS0yMDVFMkNGOS0yQ0ZDMkNGRTJDRkYyRTAwMkUwMTJFMDYtMkUwODJFMEIyRTBFLTJFMTYyRTE4MkUxOTJFMUIyRTFFMkUxRjJFMkEtMkUyRTJFMzAyRTMxMzAwMS0zMDAzMzAzRDMwRkJBNEZFQTRGRkE2MEQtQTYwRkE2NzNBNjdFQTZGMi1BNkY3QTg3NC1BODc3QThDRUE4Q0ZBOEY4LUE4RkFBOTJFQTkyRkE5NUZBOUMxLUE5Q0RBOURFQTlERkFBNUMtQUE1RkFBREVBQURGQUJFQkZFMTAtRkUxNkZFMTlGRTMwRkU0NUZFNDZGRTQ5LUZFNENGRTUwLUZFNTJGRTU0LUZFNTdGRTVGLUZFNjFGRTY4RkU2QUZFNkJGRjAxLUZGMDNGRjA1LUZGMDdGRjBBRkYwQ0ZGMEVGRjBGRkYxQUZGMUJGRjFGRkYyMEZGM0NGRjYxRkY2NEZGNjVcXFwiLFxcblxcdCAgICBTOiAgXFxcIjAwMjQwMDJCMDAzQy0wMDNFMDA1RTAwNjAwMDdDMDA3RTAwQTItMDBBOTAwQUMwMEFFLTAwQjEwMEI0MDBCNjAwQjgwMEQ3MDBGNzAyQzItMDJDNTAyRDItMDJERjAyRTUtMDJFQjAyRUQwMkVGLTAyRkYwMzc1MDM4NDAzODUwM0Y2MDQ4MjA2MDYtMDYwODA2MEIwNjBFMDYwRjA2RTkwNkZEMDZGRTA3RjYwOUYyMDlGMzA5RkEwOUZCMEFGMTBCNzAwQkYzLTBCRkEwQzdGMENGMTBDRjIwRDc5MEUzRjBGMDEtMEYwMzBGMTMtMEYxNzBGMUEtMEYxRjBGMzQwRjM2MEYzODBGQkUtMEZDNTBGQzctMEZDQzBGQ0UwRkNGMEZENS0wRkQ4MTA5RTEwOUYxMzYwMTM5MC0xMzk5MTdEQjE5NDAxOUUwLTE5RkYxQjYxLTFCNkExQjc0LTFCN0MxRkJEMUZCRi0xRkMxMUZDRC0xRkNGMUZERC0xRkRGMUZFRC0xRkVGMUZGRDFGRkUyMDQ0MjA1MjIwN0EtMjA3QzIwOEEtMjA4QzIwQTAtMjBCODIxMDAyMTAxMjEwMy0yMTA2MjEwODIxMDkyMTE0MjExNi0yMTE4MjExRS0yMTIzMjEyNTIxMjcyMTI5MjEyRTIxM0EyMTNCMjE0MC0yMTQ0MjE0QS0yMTREMjE0RjIxOTAtMjMyODIzMkItMjNFODI0MDAtMjQyNjI0NDAtMjQ0QTI0OUMtMjRFOTI1MDAtMjZDRDI2Q0YtMjZFMTI2RTMyNkU4LTI2RkYyNzAxLTI3MDQyNzA2LTI3MDkyNzBDLTI3MjcyNzI5LTI3NEIyNzREMjc0Ri0yNzUyMjc1Ni0yNzVFMjc2MS0yNzY3Mjc5NDI3OTgtMjdBRjI3QjEtMjdCRTI3QzAtMjdDNDI3QzctMjdDQTI3Q0MyN0QwLTI3RTUyN0YwLTI5ODIyOTk5LTI5RDcyOURDLTI5RkIyOUZFLTJCNEMyQjUwLTJCNTkyQ0U1LTJDRUEyRTgwLTJFOTkyRTlCLTJFRjMyRjAwLTJGRDUyRkYwLTJGRkIzMDA0MzAxMjMwMTMzMDIwMzAzNjMwMzczMDNFMzAzRjMwOUIzMDlDMzE5MDMxOTEzMTk2LTMxOUYzMUMwLTMxRTMzMjAwLTMyMUUzMjJBLTMyNTAzMjYwLTMyN0YzMjhBLTMyQjAzMkMwLTMyRkUzMzAwLTMzRkY0REMwLTRERkZBNDkwLUE0QzZBNzAwLUE3MTZBNzIwQTcyMUE3ODlBNzhBQTgyOC1BODJCQTgzNi1BODM5QUE3Ny1BQTc5RkIyOUZERkNGREZERkU2MkZFNjQtRkU2NkZFNjlGRjA0RkYwQkZGMUMtRkYxRUZGM0VGRjQwRkY1Q0ZGNUVGRkUwLUZGRTZGRkU4LUZGRUVGRkZDRkZGRFxcXCIsXFxuXFx0ICAgIFNtOiBcXFwiMDAyQjAwM0MtMDAzRTAwN0MwMDdFMDBBQzAwQjEwMEQ3MDBGNzAzRjYwNjA2LTA2MDgyMDQ0MjA1MjIwN0EtMjA3QzIwOEEtMjA4QzIxNDAtMjE0NDIxNEIyMTkwLTIxOTQyMTlBMjE5QjIxQTAyMUEzMjFBNjIxQUUyMUNFMjFDRjIxRDIyMUQ0MjFGNC0yMkZGMjMwOC0yMzBCMjMyMDIzMjEyMzdDMjM5Qi0yM0IzMjNEQy0yM0UxMjVCNzI1QzEyNUY4LTI1RkYyNjZGMjdDMC0yN0M0MjdDNy0yN0NBMjdDQzI3RDAtMjdFNTI3RjAtMjdGRjI5MDAtMjk4MjI5OTktMjlENzI5REMtMjlGQjI5RkUtMkFGRjJCMzAtMkI0NDJCNDctMkI0Q0ZCMjlGRTYyRkU2NC1GRTY2RkYwQkZGMUMtRkYxRUZGNUNGRjVFRkZFMkZGRTktRkZFQ1xcXCIsXFxuXFx0ICAgIFNjOiBcXFwiMDAyNDAwQTItMDBBNTA2MEIwOUYyMDlGMzA5RkIwQUYxMEJGOTBFM0YxN0RCMjBBMC0yMEI4QTgzOEZERkNGRTY5RkYwNEZGRTBGRkUxRkZFNUZGRTZcXFwiLFxcblxcdCAgICBTazogXFxcIjAwNUUwMDYwMDBBODAwQUYwMEI0MDBCODAyQzItMDJDNTAyRDItMDJERjAyRTUtMDJFQjAyRUQwMkVGLTAyRkYwMzc1MDM4NDAzODUxRkJEMUZCRi0xRkMxMUZDRC0xRkNGMUZERC0xRkRGMUZFRC0xRkVGMUZGRDFGRkUzMDlCMzA5Q0E3MDAtQTcxNkE3MjBBNzIxQTc4OUE3OEFGRjNFRkY0MEZGRTNcXFwiLFxcblxcdCAgICBTbzogXFxcIjAwQTYwMEE3MDBBOTAwQUUwMEIwMDBCNjA0ODIwNjBFMDYwRjA2RTkwNkZEMDZGRTA3RjYwOUZBMEI3MDBCRjMtMEJGODBCRkEwQzdGMENGMTBDRjIwRDc5MEYwMS0wRjAzMEYxMy0wRjE3MEYxQS0wRjFGMEYzNDBGMzYwRjM4MEZCRS0wRkM1MEZDNy0wRkNDMEZDRTBGQ0YwRkQ1LTBGRDgxMDlFMTA5RjEzNjAxMzkwLTEzOTkxOTQwMTlFMC0xOUZGMUI2MS0xQjZBMUI3NC0xQjdDMjEwMDIxMDEyMTAzLTIxMDYyMTA4MjEwOTIxMTQyMTE2LTIxMTgyMTFFLTIxMjMyMTI1MjEyNzIxMjkyMTJFMjEzQTIxM0IyMTRBMjE0QzIxNEQyMTRGMjE5NS0yMTk5MjE5Qy0yMTlGMjFBMTIxQTIyMUE0MjFBNTIxQTctMjFBRDIxQUYtMjFDRDIxRDAyMUQxMjFEMzIxRDUtMjFGMzIzMDAtMjMwNzIzMEMtMjMxRjIzMjItMjMyODIzMkItMjM3QjIzN0QtMjM5QTIzQjQtMjNEQjIzRTItMjNFODI0MDAtMjQyNjI0NDAtMjQ0QTI0OUMtMjRFOTI1MDAtMjVCNjI1QjgtMjVDMDI1QzItMjVGNzI2MDAtMjY2RTI2NzAtMjZDRDI2Q0YtMjZFMTI2RTMyNkU4LTI2RkYyNzAxLTI3MDQyNzA2LTI3MDkyNzBDLTI3MjcyNzI5LTI3NEIyNzREMjc0Ri0yNzUyMjc1Ni0yNzVFMjc2MS0yNzY3Mjc5NDI3OTgtMjdBRjI3QjEtMjdCRTI4MDAtMjhGRjJCMDAtMkIyRjJCNDUyQjQ2MkI1MC0yQjU5MkNFNS0yQ0VBMkU4MC0yRTk5MkU5Qi0yRUYzMkYwMC0yRkQ1MkZGMC0yRkZCMzAwNDMwMTIzMDEzMzAyMDMwMzYzMDM3MzAzRTMwM0YzMTkwMzE5MTMxOTYtMzE5RjMxQzAtMzFFMzMyMDAtMzIxRTMyMkEtMzI1MDMyNjAtMzI3RjMyOEEtMzJCMDMyQzAtMzJGRTMzMDAtMzNGRjREQzAtNERGRkE0OTAtQTRDNkE4MjgtQTgyQkE4MzZBODM3QTgzOUFBNzctQUE3OUZERkRGRkU0RkZFOEZGRURGRkVFRkZGQ0ZGRkRcXFwiLFxcblxcdCAgICBaOiAgXFxcIjAwMjAwMEEwMTY4MDE4MEUyMDAwLTIwMEEyMDI4MjAyOTIwMkYyMDVGMzAwMFxcXCIsXFxuXFx0ICAgIFpzOiBcXFwiMDAyMDAwQTAxNjgwMTgwRTIwMDAtMjAwQTIwMkYyMDVGMzAwMFxcXCIsXFxuXFx0ICAgIFpsOiBcXFwiMjAyOFxcXCIsXFxuXFx0ICAgIFpwOiBcXFwiMjAyOVxcXCIsXFxuXFx0ICAgIEM6ICBcXFwiMDAwMC0wMDFGMDA3Ri0wMDlGMDBBRDAzNzgwMzc5MDM3Ri0wMzgzMDM4QjAzOEQwM0EyMDUyNi0wNTMwMDU1NzA1NTgwNTYwMDU4ODA1OEItMDU5MDA1QzgtMDVDRjA1RUItMDVFRjA1RjUtMDYwNTA2MUMwNjFEMDYyMDA2NUYwNkREMDcwRTA3MEYwNzRCMDc0QzA3QjItMDdCRjA3RkItMDdGRjA4MkUwODJGMDgzRi0wOEZGMDkzQTA5M0IwOTRGMDk1NjA5NTcwOTczLTA5NzgwOTgwMDk4NDA5OEQwOThFMDk5MTA5OTIwOUE5MDlCMTA5QjMtMDlCNTA5QkEwOUJCMDlDNTA5QzYwOUM5MDlDQTA5Q0YtMDlENjA5RDgtMDlEQjA5REUwOUU0MDlFNTA5RkMtMEEwMDBBMDQwQTBCLTBBMEUwQTExMEExMjBBMjkwQTMxMEEzNDBBMzcwQTNBMEEzQjBBM0QwQTQzLTBBNDYwQTQ5MEE0QTBBNEUtMEE1MDBBNTItMEE1ODBBNUQwQTVGLTBBNjUwQTc2LTBBODAwQTg0MEE4RTBBOTIwQUE5MEFCMTBBQjQwQUJBMEFCQjBBQzYwQUNBMEFDRTBBQ0YwQUQxLTBBREYwQUU0MEFFNTBBRjAwQUYyLTBCMDAwQjA0MEIwRDBCMEUwQjExMEIxMjBCMjkwQjMxMEIzNDBCM0EwQjNCMEI0NTBCNDYwQjQ5MEI0QTBCNEUtMEI1NTBCNTgtMEI1QjBCNUUwQjY0MEI2NTBCNzItMEI4MTBCODQwQjhCLTBCOEQwQjkxMEI5Ni0wQjk4MEI5QjBCOUQwQkEwLTBCQTIwQkE1LTBCQTcwQkFCLTBCQUQwQkJBLTBCQkQwQkMzLTBCQzUwQkM5MEJDRTBCQ0YwQkQxLTBCRDYwQkQ4LTBCRTUwQkZCLTBDMDAwQzA0MEMwRDBDMTEwQzI5MEMzNDBDM0EtMEMzQzBDNDUwQzQ5MEM0RS0wQzU0MEM1NzBDNUEtMEM1RjBDNjQwQzY1MEM3MC0wQzc3MEM4MDBDODEwQzg0MEM4RDBDOTEwQ0E5MENCNDBDQkEwQ0JCMENDNTBDQzkwQ0NFLTBDRDQwQ0Q3LTBDREQwQ0RGMENFNDBDRTUwQ0YwMENGMy0wRDAxMEQwNDBEMEQwRDExMEQyOTBEM0EtMEQzQzBENDUwRDQ5MEQ0RS0wRDU2MEQ1OC0wRDVGMEQ2NDBENjUwRDc2LTBENzgwRDgwMEQ4MTBEODQwRDk3LTBEOTkwREIyMERCQzBEQkUwREJGMERDNy0wREM5MERDQi0wRENFMERENTBERDcwREUwLTBERjEwREY1LTBFMDAwRTNCLTBFM0UwRTVDLTBFODAwRTgzMEU4NTBFODYwRTg5MEU4QjBFOEMwRThFLTBFOTMwRTk4MEVBMDBFQTQwRUE2MEVBODBFQTkwRUFDMEVCQTBFQkUwRUJGMEVDNTBFQzcwRUNFMEVDRjBFREEwRURCMEVERS0wRUZGMEY0ODBGNkQtMEY3MDBGOEMtMEY4RjBGOTgwRkJEMEZDRDBGRDktMEZGRjEwQzYtMTBDRjEwRkQtMTBGRjEyNDkxMjRFMTI0RjEyNTcxMjU5MTI1RTEyNUYxMjg5MTI4RTEyOEYxMkIxMTJCNjEyQjcxMkJGMTJDMTEyQzYxMkM3MTJENzEzMTExMzE2MTMxNzEzNUItMTM1RTEzN0QtMTM3RjEzOUEtMTM5RjEzRjUtMTNGRjE2OUQtMTY5RjE2RjEtMTZGRjE3MEQxNzE1LTE3MUYxNzM3LTE3M0YxNzU0LTE3NUYxNzZEMTc3MTE3NzQtMTc3RjE3QjQxN0I1MTdERTE3REYxN0VBLTE3RUYxN0ZBLTE3RkYxODBGMTgxQS0xODFGMTg3OC0xODdGMThBQi0xOEFGMThGNi0xOEZGMTkxRC0xOTFGMTkyQy0xOTJGMTkzQy0xOTNGMTk0MS0xOTQzMTk2RTE5NkYxOTc1LTE5N0YxOUFDLTE5QUYxOUNBLTE5Q0YxOURCLTE5REQxQTFDMUExRDFBNUYxQTdEMUE3RTFBOEEtMUE4RjFBOUEtMUE5RjFBQUUtMUFGRjFCNEMtMUI0RjFCN0QtMUI3RjFCQUItMUJBRDFCQkEtMUJGRjFDMzgtMUMzQTFDNEEtMUM0QzFDODAtMUNDRjFDRjMtMUNGRjFERTctMURGQzFGMTYxRjE3MUYxRTFGMUYxRjQ2MUY0NzFGNEUxRjRGMUY1ODFGNUExRjVDMUY1RTFGN0UxRjdGMUZCNTFGQzUxRkQ0MUZENTFGREMxRkYwMUZGMTFGRjUxRkZGMjAwQi0yMDBGMjAyQS0yMDJFMjA2MC0yMDZGMjA3MjIwNzMyMDhGMjA5NS0yMDlGMjBCOS0yMENGMjBGMS0yMEZGMjE4QS0yMThGMjNFOS0yM0ZGMjQyNy0yNDNGMjQ0Qi0yNDVGMjZDRTI2RTIyNkU0LTI2RTcyNzAwMjcwNTI3MEEyNzBCMjcyODI3NEMyNzRFMjc1My0yNzU1Mjc1RjI3NjAyNzk1LTI3OTcyN0IwMjdCRjI3Q0IyN0NELTI3Q0YyQjRELTJCNEYyQjVBLTJCRkYyQzJGMkM1RjJDRjItMkNGODJEMjYtMkQyRjJENjYtMkQ2RTJENzAtMkQ3RjJEOTctMkQ5RjJEQTcyREFGMkRCNzJEQkYyREM3MkRDRjJERDcyRERGMkUzMi0yRTdGMkU5QTJFRjQtMkVGRjJGRDYtMkZFRjJGRkMtMkZGRjMwNDAzMDk3MzA5ODMxMDAtMzEwNDMxMkUtMzEzMDMxOEYzMUI4LTMxQkYzMUU0LTMxRUYzMjFGMzJGRjREQjYtNERCRjlGQ0MtOUZGRkE0OEQtQTQ4RkE0QzctQTRDRkE2MkMtQTYzRkE2NjBBNjYxQTY3NC1BNjdCQTY5OC1BNjlGQTZGOC1BNkZGQTc4RC1BN0ZBQTgyQy1BODJGQTgzQS1BODNGQTg3OC1BODdGQThDNS1BOENEQThEQS1BOERGQThGQy1BOEZGQTk1NC1BOTVFQTk3RC1BOTdGQTlDRUE5REEtQTlEREE5RTAtQTlGRkFBMzctQUEzRkFBNEVBQTRGQUE1QUFBNUJBQTdDLUFBN0ZBQUMzLUFBREFBQUUwLUFCQkZBQkVFQUJFRkFCRkEtQUJGRkQ3QTQtRDdBRkQ3QzctRDdDQUQ3RkMtRjhGRkZBMkVGQTJGRkE2RUZBNkZGQURBLUZBRkZGQjA3LUZCMTJGQjE4LUZCMUNGQjM3RkIzREZCM0ZGQjQyRkI0NUZCQjItRkJEMkZENDAtRkQ0RkZEOTBGRDkxRkRDOC1GREVGRkRGRUZERkZGRTFBLUZFMUZGRTI3LUZFMkZGRTUzRkU2N0ZFNkMtRkU2RkZFNzVGRUZELUZGMDBGRkJGLUZGQzFGRkM4RkZDOUZGRDBGRkQxRkZEOEZGRDlGRkRELUZGREZGRkU3RkZFRi1GRkZCRkZGRUZGRkZcXFwiLFxcblxcdCAgICBDYzogXFxcIjAwMDAtMDAxRjAwN0YtMDA5RlxcXCIsXFxuXFx0ICAgIENmOiBcXFwiMDBBRDA2MDAtMDYwMzA2REQwNzBGMTdCNDE3QjUyMDBCLTIwMEYyMDJBLTIwMkUyMDYwLTIwNjQyMDZBLTIwNkZGRUZGRkZGOS1GRkZCXFxcIixcXG5cXHQgICAgQ286IFxcXCJFMDAwLUY4RkZcXFwiLFxcblxcdCAgICBDczogXFxcIkQ4MDAtREZGRlxcXCIsXFxuXFx0ICAgIENuOiBcXFwiMDM3ODAzNzkwMzdGLTAzODMwMzhCMDM4RDAzQTIwNTI2LTA1MzAwNTU3MDU1ODA1NjAwNTg4MDU4Qi0wNTkwMDVDOC0wNUNGMDVFQi0wNUVGMDVGNS0wNUZGMDYwNDA2MDUwNjFDMDYxRDA2MjAwNjVGMDcwRTA3NEIwNzRDMDdCMi0wN0JGMDdGQi0wN0ZGMDgyRTA4MkYwODNGLTA4RkYwOTNBMDkzQjA5NEYwOTU2MDk1NzA5NzMtMDk3ODA5ODAwOTg0MDk4RDA5OEUwOTkxMDk5MjA5QTkwOUIxMDlCMy0wOUI1MDlCQTA5QkIwOUM1MDlDNjA5QzkwOUNBMDlDRi0wOUQ2MDlEOC0wOURCMDlERTA5RTQwOUU1MDlGQy0wQTAwMEEwNDBBMEItMEEwRTBBMTEwQTEyMEEyOTBBMzEwQTM0MEEzNzBBM0EwQTNCMEEzRDBBNDMtMEE0NjBBNDkwQTRBMEE0RS0wQTUwMEE1Mi0wQTU4MEE1RDBBNUYtMEE2NTBBNzYtMEE4MDBBODQwQThFMEE5MjBBQTkwQUIxMEFCNDBBQkEwQUJCMEFDNjBBQ0EwQUNFMEFDRjBBRDEtMEFERjBBRTQwQUU1MEFGMDBBRjItMEIwMDBCMDQwQjBEMEIwRTBCMTEwQjEyMEIyOTBCMzEwQjM0MEIzQTBCM0IwQjQ1MEI0NjBCNDkwQjRBMEI0RS0wQjU1MEI1OC0wQjVCMEI1RTBCNjQwQjY1MEI3Mi0wQjgxMEI4NDBCOEItMEI4RDBCOTEwQjk2LTBCOTgwQjlCMEI5RDBCQTAtMEJBMjBCQTUtMEJBNzBCQUItMEJBRDBCQkEtMEJCRDBCQzMtMEJDNTBCQzkwQkNFMEJDRjBCRDEtMEJENjBCRDgtMEJFNTBCRkItMEMwMDBDMDQwQzBEMEMxMTBDMjkwQzM0MEMzQS0wQzNDMEM0NTBDNDkwQzRFLTBDNTQwQzU3MEM1QS0wQzVGMEM2NDBDNjUwQzcwLTBDNzcwQzgwMEM4MTBDODQwQzhEMEM5MTBDQTkwQ0I0MENCQTBDQkIwQ0M1MENDOTBDQ0UtMENENDBDRDctMENERDBDREYwQ0U0MENFNTBDRjAwQ0YzLTBEMDEwRDA0MEQwRDBEMTEwRDI5MEQzQS0wRDNDMEQ0NTBENDkwRDRFLTBENTYwRDU4LTBENUYwRDY0MEQ2NTBENzYtMEQ3ODBEODAwRDgxMEQ4NDBEOTctMEQ5OTBEQjIwREJDMERCRTBEQkYwREM3LTBEQzkwRENCLTBEQ0UwREQ1MERENzBERTAtMERGMTBERjUtMEUwMDBFM0ItMEUzRTBFNUMtMEU4MDBFODMwRTg1MEU4NjBFODkwRThCMEU4QzBFOEUtMEU5MzBFOTgwRUEwMEVBNDBFQTYwRUE4MEVBOTBFQUMwRUJBMEVCRTBFQkYwRUM1MEVDNzBFQ0UwRUNGMEVEQTBFREIwRURFLTBFRkYwRjQ4MEY2RC0wRjcwMEY4Qy0wRjhGMEY5ODBGQkQwRkNEMEZEOS0wRkZGMTBDNi0xMENGMTBGRC0xMEZGMTI0OTEyNEUxMjRGMTI1NzEyNTkxMjVFMTI1RjEyODkxMjhFMTI4RjEyQjExMkI2MTJCNzEyQkYxMkMxMTJDNjEyQzcxMkQ3MTMxMTEzMTYxMzE3MTM1Qi0xMzVFMTM3RC0xMzdGMTM5QS0xMzlGMTNGNS0xM0ZGMTY5RC0xNjlGMTZGMS0xNkZGMTcwRDE3MTUtMTcxRjE3MzctMTczRjE3NTQtMTc1RjE3NkQxNzcxMTc3NC0xNzdGMTdERTE3REYxN0VBLTE3RUYxN0ZBLTE3RkYxODBGMTgxQS0xODFGMTg3OC0xODdGMThBQi0xOEFGMThGNi0xOEZGMTkxRC0xOTFGMTkyQy0xOTJGMTkzQy0xOTNGMTk0MS0xOTQzMTk2RTE5NkYxOTc1LTE5N0YxOUFDLTE5QUYxOUNBLTE5Q0YxOURCLTE5REQxQTFDMUExRDFBNUYxQTdEMUE3RTFBOEEtMUE4RjFBOUEtMUE5RjFBQUUtMUFGRjFCNEMtMUI0RjFCN0QtMUI3RjFCQUItMUJBRDFCQkEtMUJGRjFDMzgtMUMzQTFDNEEtMUM0QzFDODAtMUNDRjFDRjMtMUNGRjFERTctMURGQzFGMTYxRjE3MUYxRTFGMUYxRjQ2MUY0NzFGNEUxRjRGMUY1ODFGNUExRjVDMUY1RTFGN0UxRjdGMUZCNTFGQzUxRkQ0MUZENTFGREMxRkYwMUZGMTFGRjUxRkZGMjA2NS0yMDY5MjA3MjIwNzMyMDhGMjA5NS0yMDlGMjBCOS0yMENGMjBGMS0yMEZGMjE4QS0yMThGMjNFOS0yM0ZGMjQyNy0yNDNGMjQ0Qi0yNDVGMjZDRTI2RTIyNkU0LTI2RTcyNzAwMjcwNTI3MEEyNzBCMjcyODI3NEMyNzRFMjc1My0yNzU1Mjc1RjI3NjAyNzk1LTI3OTcyN0IwMjdCRjI3Q0IyN0NELTI3Q0YyQjRELTJCNEYyQjVBLTJCRkYyQzJGMkM1RjJDRjItMkNGODJEMjYtMkQyRjJENjYtMkQ2RTJENzAtMkQ3RjJEOTctMkQ5RjJEQTcyREFGMkRCNzJEQkYyREM3MkRDRjJERDcyRERGMkUzMi0yRTdGMkU5QTJFRjQtMkVGRjJGRDYtMkZFRjJGRkMtMkZGRjMwNDAzMDk3MzA5ODMxMDAtMzEwNDMxMkUtMzEzMDMxOEYzMUI4LTMxQkYzMUU0LTMxRUYzMjFGMzJGRjREQjYtNERCRjlGQ0MtOUZGRkE0OEQtQTQ4RkE0QzctQTRDRkE2MkMtQTYzRkE2NjBBNjYxQTY3NC1BNjdCQTY5OC1BNjlGQTZGOC1BNkZGQTc4RC1BN0ZBQTgyQy1BODJGQTgzQS1BODNGQTg3OC1BODdGQThDNS1BOENEQThEQS1BOERGQThGQy1BOEZGQTk1NC1BOTVFQTk3RC1BOTdGQTlDRUE5REEtQTlEREE5RTAtQTlGRkFBMzctQUEzRkFBNEVBQTRGQUE1QUFBNUJBQTdDLUFBN0ZBQUMzLUFBREFBQUUwLUFCQkZBQkVFQUJFRkFCRkEtQUJGRkQ3QTQtRDdBRkQ3QzctRDdDQUQ3RkMtRDdGRkZBMkVGQTJGRkE2RUZBNkZGQURBLUZBRkZGQjA3LUZCMTJGQjE4LUZCMUNGQjM3RkIzREZCM0ZGQjQyRkI0NUZCQjItRkJEMkZENDAtRkQ0RkZEOTBGRDkxRkRDOC1GREVGRkRGRUZERkZGRTFBLUZFMUZGRTI3LUZFMkZGRTUzRkU2N0ZFNkMtRkU2RkZFNzVGRUZERkVGRUZGMDBGRkJGLUZGQzFGRkM4RkZDOUZGRDBGRkQxRkZEOEZGRDlGRkRELUZGREZGRkU3RkZFRi1GRkY4RkZGRUZGRkZcXFwiXFxuXFx0fSk7XFxuXFxuXFx0ZnVuY3Rpb24gYWRkVW5pY29kZVBhY2thZ2UgKHBhY2spIHtcXG5cXHQgICAgdmFyIGNvZGVQb2ludCA9IC9cXFxcd3s0fS9nO1xcblxcdCAgICBmb3IgKHZhciBuYW1lIGluIHBhY2spXFxuXFx0ICAgICAgICBleHBvcnRzLnBhY2thZ2VzW25hbWVdID0gcGFja1tuYW1lXS5yZXBsYWNlKGNvZGVQb2ludCwgXFxcIlxcXFxcXFxcdSQmXFxcIik7XFxuXFx0fTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvdG9rZW5faXRlcmF0b3JcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHR2YXIgVG9rZW5JdGVyYXRvciA9IGZ1bmN0aW9uKHNlc3Npb24sIGluaXRpYWxSb3csIGluaXRpYWxDb2x1bW4pIHtcXG5cXHQgICAgdGhpcy4kc2Vzc2lvbiA9IHNlc3Npb247XFxuXFx0ICAgIHRoaXMuJHJvdyA9IGluaXRpYWxSb3c7XFxuXFx0ICAgIHRoaXMuJHJvd1Rva2VucyA9IHNlc3Npb24uZ2V0VG9rZW5zKGluaXRpYWxSb3cpO1xcblxcblxcdCAgICB2YXIgdG9rZW4gPSBzZXNzaW9uLmdldFRva2VuQXQoaW5pdGlhbFJvdywgaW5pdGlhbENvbHVtbik7XFxuXFx0ICAgIHRoaXMuJHRva2VuSW5kZXggPSB0b2tlbiA/IHRva2VuLmluZGV4IDogLTE7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7IFxcblxcdCAgICB0aGlzLnN0ZXBCYWNrd2FyZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kdG9rZW5JbmRleCAtPSAxO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB3aGlsZSAodGhpcy4kdG9rZW5JbmRleCA8IDApIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRyb3cgLT0gMTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kcm93IDwgMCkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRyb3cgPSAwO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJHJvd1Rva2VucyA9IHRoaXMuJHNlc3Npb24uZ2V0VG9rZW5zKHRoaXMuJHJvdyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kdG9rZW5JbmRleCA9IHRoaXMuJHJvd1Rva2Vucy5sZW5ndGggLSAxO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHJvd1Rva2Vuc1t0aGlzLiR0b2tlbkluZGV4XTtcXG5cXHQgICAgfTsgICBcXG5cXHQgICAgdGhpcy5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kdG9rZW5JbmRleCArPSAxO1xcblxcdCAgICAgICAgdmFyIHJvd0NvdW50O1xcblxcdCAgICAgICAgd2hpbGUgKHRoaXMuJHRva2VuSW5kZXggPj0gdGhpcy4kcm93VG9rZW5zLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJHJvdyArPSAxO1xcblxcdCAgICAgICAgICAgIGlmICghcm93Q291bnQpXFxuXFx0ICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy4kc2Vzc2lvbi5nZXRMZW5ndGgoKTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kcm93ID49IHJvd0NvdW50KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJHJvdyA9IHJvd0NvdW50IC0gMTtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIHRoaXMuJHJvd1Rva2VucyA9IHRoaXMuJHNlc3Npb24uZ2V0VG9rZW5zKHRoaXMuJHJvdyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kdG9rZW5JbmRleCA9IDA7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kcm93VG9rZW5zW3RoaXMuJHRva2VuSW5kZXhdO1xcblxcdCAgICB9OyAgICAgIFxcblxcdCAgICB0aGlzLmdldEN1cnJlbnRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRyb3dUb2tlbnNbdGhpcy4kdG9rZW5JbmRleF07XFxuXFx0ICAgIH07ICAgICAgXFxuXFx0ICAgIHRoaXMuZ2V0Q3VycmVudFRva2VuUm93ID0gZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHJvdztcXG5cXHQgICAgfTsgICAgIFxcblxcdCAgICB0aGlzLmdldEN1cnJlbnRUb2tlbkNvbHVtbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJvd1Rva2VucyA9IHRoaXMuJHJvd1Rva2VucztcXG5cXHQgICAgICAgIHZhciB0b2tlbkluZGV4ID0gdGhpcy4kdG9rZW5JbmRleDtcXG5cXHQgICAgICAgIHZhciBjb2x1bW4gPSByb3dUb2tlbnNbdG9rZW5JbmRleF0uc3RhcnQ7XFxuXFx0ICAgICAgICBpZiAoY29sdW1uICE9PSB1bmRlZmluZWQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGNvbHVtbjtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgIGNvbHVtbiA9IDA7XFxuXFx0ICAgICAgICB3aGlsZSAodG9rZW5JbmRleCA+IDApIHtcXG5cXHQgICAgICAgICAgICB0b2tlbkluZGV4IC09IDE7XFxuXFx0ICAgICAgICAgICAgY29sdW1uICs9IHJvd1Rva2Vuc1t0b2tlbkluZGV4XS52YWx1ZS5sZW5ndGg7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHJldHVybiBjb2x1bW47ICBcXG5cXHQgICAgfTtcXG5cXHQgICAgICAgICAgICBcXG5cXHR9KS5jYWxsKFRva2VuSXRlcmF0b3IucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLlRva2VuSXRlcmF0b3IgPSBUb2tlbkl0ZXJhdG9yO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb2RlL3RleHRcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvdG9rZW5pemVyXFxcIixcXFwiYWNlL21vZGUvdGV4dF9oaWdobGlnaHRfcnVsZXNcXFwiLFxcXCJhY2UvbW9kZS9iZWhhdmlvdXJcXFwiLFxcXCJhY2UvdW5pY29kZVxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCIsXFxcImFjZS90b2tlbl9pdGVyYXRvclxcXCIsXFxcImFjZS9yYW5nZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBUb2tlbml6ZXIgPSBhY2VxdWlyZShcXFwiLi4vdG9rZW5pemVyXFxcIikuVG9rZW5pemVyO1xcblxcdHZhciBUZXh0SGlnaGxpZ2h0UnVsZXMgPSBhY2VxdWlyZShcXFwiLi90ZXh0X2hpZ2hsaWdodF9ydWxlc1xcXCIpLlRleHRIaWdobGlnaHRSdWxlcztcXG5cXHR2YXIgQmVoYXZpb3VyID0gYWNlcXVpcmUoXFxcIi4vYmVoYXZpb3VyXFxcIikuQmVoYXZpb3VyO1xcblxcdHZhciB1bmljb2RlID0gYWNlcXVpcmUoXFxcIi4uL3VuaWNvZGVcXFwiKTtcXG5cXHR2YXIgbGFuZyA9IGFjZXF1aXJlKFxcXCIuLi9saWIvbGFuZ1xcXCIpO1xcblxcdHZhciBUb2tlbkl0ZXJhdG9yID0gYWNlcXVpcmUoXFxcIi4uL3Rva2VuX2l0ZXJhdG9yXFxcIikuVG9rZW5JdGVyYXRvcjtcXG5cXHR2YXIgUmFuZ2UgPSBhY2VxdWlyZShcXFwiLi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXG5cXHR2YXIgTW9kZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLkhpZ2hsaWdodFJ1bGVzID0gVGV4dEhpZ2hsaWdodFJ1bGVzO1xcblxcdCAgICB0aGlzLiRiZWhhdmlvdXIgPSBuZXcgQmVoYXZpb3VyKCk7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIHRoaXMudG9rZW5SZSA9IG5ldyBSZWdFeHAoXFxcIl5bXFxcIlxcblxcdCAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLkxcXG5cXHQgICAgICAgICsgdW5pY29kZS5wYWNrYWdlcy5NbiArIHVuaWNvZGUucGFja2FnZXMuTWNcXG5cXHQgICAgICAgICsgdW5pY29kZS5wYWNrYWdlcy5OZFxcblxcdCAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLlBjICsgXFxcIlxcXFxcXFxcJF9dK1xcXCIsIFxcXCJnXFxcIlxcblxcdCAgICApO1xcblxcblxcdCAgICB0aGlzLm5vblRva2VuUmUgPSBuZXcgUmVnRXhwKFxcXCJeKD86W15cXFwiXFxuXFx0ICAgICAgICArIHVuaWNvZGUucGFja2FnZXMuTFxcblxcdCAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLk1uICsgdW5pY29kZS5wYWNrYWdlcy5NY1xcblxcdCAgICAgICAgKyB1bmljb2RlLnBhY2thZ2VzLk5kXFxuXFx0ICAgICAgICArIHVuaWNvZGUucGFja2FnZXMuUGMgKyBcXFwiXFxcXFxcXFwkX118XFxcXFxcXFxzXSkrXFxcIiwgXFxcImdcXFwiXFxuXFx0ICAgICk7XFxuXFxuXFx0ICAgIHRoaXMuZ2V0VG9rZW5pemVyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJHRva2VuaXplcikge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGhpZ2hsaWdodFJ1bGVzID0gdGhpcy4kaGlnaGxpZ2h0UnVsZXMgfHwgbmV3IHRoaXMuSGlnaGxpZ2h0UnVsZXMoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHRoaXMuJGhpZ2hsaWdodFJ1bGVzLmdldFJ1bGVzKCkpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHRva2VuaXplcjtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5saW5lQ29tbWVudFN0YXJ0ID0gXFxcIlxcXCI7XFxuXFx0ICAgIHRoaXMuYmxvY2tDb21tZW50ID0gXFxcIlxcXCI7XFxuXFxuXFx0ICAgIHRoaXMudG9nZ2xlQ29tbWVudExpbmVzID0gZnVuY3Rpb24oc3RhdGUsIHNlc3Npb24sIHN0YXJ0Um93LCBlbmRSb3cpIHtcXG5cXHQgICAgICAgIHZhciBkb2MgPSBzZXNzaW9uLmRvYztcXG5cXG5cXHQgICAgICAgIHZhciBpZ25vcmVCbGFua0xpbmVzID0gdHJ1ZTtcXG5cXHQgICAgICAgIHZhciBzaG91bGRSZW1vdmUgPSB0cnVlO1xcblxcdCAgICAgICAgdmFyIG1pbkluZGVudCA9IEluZmluaXR5O1xcblxcdCAgICAgICAgdmFyIHRhYlNpemUgPSBzZXNzaW9uLmdldFRhYlNpemUoKTtcXG5cXHQgICAgICAgIHZhciBpbnNlcnRBdFRhYlN0b3AgPSBmYWxzZTtcXG5cXG5cXHQgICAgICAgIGlmICghdGhpcy5saW5lQ29tbWVudFN0YXJ0KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCF0aGlzLmJsb2NrQ29tbWVudClcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgICAgIHZhciBsaW5lQ29tbWVudFN0YXJ0ID0gdGhpcy5ibG9ja0NvbW1lbnQuc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50RW5kID0gdGhpcy5ibG9ja0NvbW1lbnQuZW5kO1xcblxcdCAgICAgICAgICAgIHZhciByZWdleHBTdGFydCA9IG5ldyBSZWdFeHAoXFxcIl4oXFxcXFxcXFxzKikoPzpcXFwiICsgbGFuZy5lc2NhcGVSZWdFeHAobGluZUNvbW1lbnRTdGFydCkgKyBcXFwiKVxcXCIpO1xcblxcdCAgICAgICAgICAgIHZhciByZWdleHBFbmQgPSBuZXcgUmVnRXhwKFxcXCIoPzpcXFwiICsgbGFuZy5lc2NhcGVSZWdFeHAobGluZUNvbW1lbnRFbmQpICsgXFxcIilcXFxcXFxcXHMqJFxcXCIpO1xcblxcblxcdCAgICAgICAgICAgIHZhciBjb21tZW50ID0gZnVuY3Rpb24obGluZSwgaSkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAodGVzdFJlbW92ZShsaW5lLCBpKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVCbGFua0xpbmVzIHx8IC9cXFxcUy8udGVzdChsaW5lKSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7cm93OiBpLCBjb2x1bW46IGxpbmUubGVuZ3RofSwgbGluZUNvbW1lbnRFbmQpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZG9jLmluc2VydEluTGluZSh7cm93OiBpLCBjb2x1bW46IG1pbkluZGVudH0sIGxpbmVDb21tZW50U3RhcnQpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgdW5jb21tZW50ID0gZnVuY3Rpb24obGluZSwgaSkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKG0gPSBsaW5lLm1hdGNoKHJlZ2V4cEVuZCkpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBkb2MucmVtb3ZlSW5MaW5lKGksIGxpbmUubGVuZ3RoIC0gbVswXS5sZW5ndGgsIGxpbmUubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKG0gPSBsaW5lLm1hdGNoKHJlZ2V4cFN0YXJ0KSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIGRvYy5yZW1vdmVJbkxpbmUoaSwgbVsxXS5sZW5ndGgsIG1bMF0ubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICB9O1xcblxcblxcdCAgICAgICAgICAgIHZhciB0ZXN0UmVtb3ZlID0gZnVuY3Rpb24obGluZSwgcm93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyZWdleHBTdGFydC50ZXN0KGxpbmUpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xcblxcdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnY29tbWVudCcpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmxpbmVDb21tZW50U3RhcnQpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByZWdleHBTdGFydCA9IHRoaXMubGluZUNvbW1lbnRTdGFydC5tYXAobGFuZy5lc2NhcGVSZWdFeHApLmpvaW4oXFxcInxcXFwiKTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50U3RhcnQgPSB0aGlzLmxpbmVDb21tZW50U3RhcnRbMF07XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJlZ2V4cFN0YXJ0ID0gbGFuZy5lc2NhcGVSZWdFeHAodGhpcy5saW5lQ29tbWVudFN0YXJ0KTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGxpbmVDb21tZW50U3RhcnQgPSB0aGlzLmxpbmVDb21tZW50U3RhcnQ7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJlZ2V4cFN0YXJ0ID0gbmV3IFJlZ0V4cChcXFwiXihcXFxcXFxcXHMqKSg/OlxcXCIgKyByZWdleHBTdGFydCArIFxcXCIpID9cXFwiKTtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICBpbnNlcnRBdFRhYlN0b3AgPSBzZXNzaW9uLmdldFVzZVNvZnRUYWJzKCk7XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIHVuY29tbWVudCA9IGZ1bmN0aW9uKGxpbmUsIGkpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKHJlZ2V4cFN0YXJ0KTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKCFtKSByZXR1cm47XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG1bMV0ubGVuZ3RoLCBlbmQgPSBtWzBdLmxlbmd0aDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRJbnNlcnRTcGFjZShsaW5lLCBzdGFydCwgZW5kKSAmJiBtWzBdW2VuZCAtIDFdID09IFxcXCIgXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVuZC0tO1xcblxcdCAgICAgICAgICAgICAgICBkb2MucmVtb3ZlSW5MaW5lKGksIHN0YXJ0LCBlbmQpO1xcblxcdCAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRXaXRoU3BhY2UgPSBsaW5lQ29tbWVudFN0YXJ0ICsgXFxcIiBcXFwiO1xcblxcdCAgICAgICAgICAgIHZhciBjb21tZW50ID0gZnVuY3Rpb24obGluZSwgaSkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZUJsYW5rTGluZXMgfHwgL1xcXFxTLy50ZXN0KGxpbmUpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSW5zZXJ0U3BhY2UobGluZSwgbWluSW5kZW50LCBtaW5JbmRlbnQpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRJbkxpbmUoe3JvdzogaSwgY29sdW1uOiBtaW5JbmRlbnR9LCBjb21tZW50V2l0aFNwYWNlKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBkb2MuaW5zZXJ0SW5MaW5lKHtyb3c6IGksIGNvbHVtbjogbWluSW5kZW50fSwgbGluZUNvbW1lbnRTdGFydCk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgIHZhciB0ZXN0UmVtb3ZlID0gZnVuY3Rpb24obGluZSwgaSkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXhwU3RhcnQudGVzdChsaW5lKTtcXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHZhciBzaG91bGRJbnNlcnRTcGFjZSA9IGZ1bmN0aW9uKGxpbmUsIGJlZm9yZSwgYWZ0ZXIpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHNwYWNlcyA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChiZWZvcmUtLSAmJiBsaW5lLmNoYXJBdChiZWZvcmUpID09IFxcXCIgXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwYWNlcysrO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoc3BhY2VzICUgdGFiU2l6ZSAhPSAwKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gMDtcXG5cXHQgICAgICAgICAgICAgICAgd2hpbGUgKGxpbmUuY2hhckF0KGFmdGVyKyspID09IFxcXCIgXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwYWNlcysrO1xcblxcdCAgICAgICAgICAgICAgICBpZiAodGFiU2l6ZSA+IDIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VzICUgdGFiU2l6ZSAhPSB0YWJTaXplIC0gMTtcXG5cXHQgICAgICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlcyAlIHRhYlNpemUgPT0gMDtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGZ1bmN0aW9uIGl0ZXIoZnVuKSB7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93OyBpIDw9IGVuZFJvdzsgaSsrKVxcblxcdCAgICAgICAgICAgICAgICBmdW4oZG9jLmdldExpbmUoaSksIGkpO1xcblxcdCAgICAgICAgfVxcblxcblxcblxcdCAgICAgICAgdmFyIG1pbkVtcHR5TGVuZ3RoID0gSW5maW5pdHk7XFxuXFx0ICAgICAgICBpdGVyKGZ1bmN0aW9uKGxpbmUsIGkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgaW5kZW50ID0gbGluZS5zZWFyY2goL1xcXFxTLyk7XFxuXFx0ICAgICAgICAgICAgaWYgKGluZGVudCAhPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IG1pbkluZGVudClcXG5cXHQgICAgICAgICAgICAgICAgICAgIG1pbkluZGVudCA9IGluZGVudDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSAmJiAhdGVzdFJlbW92ZShsaW5lLCBpKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbW92ZSA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWluRW1wdHlMZW5ndGggPiBsaW5lLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgICAgICBtaW5FbXB0eUxlbmd0aCA9IGxpbmUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0pO1xcblxcblxcdCAgICAgICAgaWYgKG1pbkluZGVudCA9PSBJbmZpbml0eSkge1xcblxcdCAgICAgICAgICAgIG1pbkluZGVudCA9IG1pbkVtcHR5TGVuZ3RoO1xcblxcdCAgICAgICAgICAgIGlnbm9yZUJsYW5rTGluZXMgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICBzaG91bGRSZW1vdmUgPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChpbnNlcnRBdFRhYlN0b3AgJiYgbWluSW5kZW50ICUgdGFiU2l6ZSAhPSAwKVxcblxcdCAgICAgICAgICAgIG1pbkluZGVudCA9IE1hdGguZmxvb3IobWluSW5kZW50IC8gdGFiU2l6ZSkgKiB0YWJTaXplO1xcblxcblxcdCAgICAgICAgaXRlcihzaG91bGRSZW1vdmUgPyB1bmNvbW1lbnQgOiBjb21tZW50KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy50b2dnbGVCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbihzdGF0ZSwgc2Vzc2lvbiwgcmFuZ2UsIGN1cnNvcikge1xcblxcdCAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLmJsb2NrQ29tbWVudDtcXG5cXHQgICAgICAgIGlmICghY29tbWVudClcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBpZiAoIWNvbW1lbnQuc3RhcnQgJiYgY29tbWVudFswXSlcXG5cXHQgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudFswXTtcXG5cXG5cXHQgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XFxuXFxuXFx0ICAgICAgICB2YXIgc2VsID0gc2Vzc2lvbi5zZWxlY3Rpb247XFxuXFx0ICAgICAgICB2YXIgaW5pdGlhbFJhbmdlID0gc2Vzc2lvbi5zZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XFxuXFx0ICAgICAgICB2YXIgc3RhcnRSb3csIGNvbERpZmY7XFxuXFxuXFx0ICAgICAgICBpZiAodG9rZW4gJiYgL2NvbW1lbnQvLnRlc3QodG9rZW4udHlwZSkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhcnRSYW5nZSwgZW5kUmFuZ2U7XFxuXFx0ICAgICAgICAgICAgd2hpbGUgKHRva2VuICYmIC9jb21tZW50Ly50ZXN0KHRva2VuLnR5cGUpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBpID0gdG9rZW4udmFsdWUuaW5kZXhPZihjb21tZW50LnN0YXJ0KTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSArIGk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzdGFydFJhbmdlID0gbmV3IFJhbmdlKHJvdywgY29sdW1uLCByb3csIGNvbHVtbiArIGNvbW1lbnQuc3RhcnQubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgIHZhciB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xcblxcdCAgICAgICAgICAgIHdoaWxlICh0b2tlbiAmJiAvY29tbWVudC8udGVzdCh0b2tlbi50eXBlKSkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgaSA9IHRva2VuLnZhbHVlLmluZGV4T2YoY29tbWVudC5lbmQpO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoaSAhPSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpICsgaTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVuZFJhbmdlID0gbmV3IFJhbmdlKHJvdywgY29sdW1uLCByb3csIGNvbHVtbiArIGNvbW1lbnQuZW5kLmxlbmd0aCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmIChlbmRSYW5nZSlcXG5cXHQgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmUoZW5kUmFuZ2UpO1xcblxcdCAgICAgICAgICAgIGlmIChzdGFydFJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlKHN0YXJ0UmFuZ2UpO1xcblxcdCAgICAgICAgICAgICAgICBzdGFydFJvdyA9IHN0YXJ0UmFuZ2Uuc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgICAgICBjb2xEaWZmID0gLWNvbW1lbnQuc3RhcnQubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgY29sRGlmZiA9IGNvbW1lbnQuc3RhcnQubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIHN0YXJ0Um93ID0gcmFuZ2Uuc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHJhbmdlLmVuZCwgY29tbWVudC5lbmQpO1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHJhbmdlLnN0YXJ0LCBjb21tZW50LnN0YXJ0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChpbml0aWFsUmFuZ2Uuc3RhcnQucm93ID09IHN0YXJ0Um93KVxcblxcdCAgICAgICAgICAgIGluaXRpYWxSYW5nZS5zdGFydC5jb2x1bW4gKz0gY29sRGlmZjtcXG5cXHQgICAgICAgIGlmIChpbml0aWFsUmFuZ2UuZW5kLnJvdyA9PSBzdGFydFJvdylcXG5cXHQgICAgICAgICAgICBpbml0aWFsUmFuZ2UuZW5kLmNvbHVtbiArPSBjb2xEaWZmO1xcblxcdCAgICAgICAgc2Vzc2lvbi5zZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UoaW5pdGlhbFJhbmdlKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXROZXh0TGluZUluZGVudCA9IGZ1bmN0aW9uKHN0YXRlLCBsaW5lLCB0YWIpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRnZXRJbmRlbnQobGluZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuY2hlY2tPdXRkZW50ID0gZnVuY3Rpb24oc3RhdGUsIGxpbmUsIGlucHV0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYXV0b091dGRlbnQgPSBmdW5jdGlvbihzdGF0ZSwgZG9jLCByb3cpIHtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kZ2V0SW5kZW50ID0gZnVuY3Rpb24obGluZSkge1xcblxcdCAgICAgICAgcmV0dXJuIGxpbmUubWF0Y2goL15cXFxccyovKVswXTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbihzZXNzaW9uKSB7XFxuXFx0ICAgICAgICByZXR1cm4gbnVsbDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jcmVhdGVNb2RlRGVsZWdhdGVzID0gZnVuY3Rpb24gKG1hcHBpbmcpIHtcXG5cXHQgICAgICAgIHRoaXMuJGVtYmVkcyA9IFtdO1xcblxcdCAgICAgICAgdGhpcy4kbW9kZXMgPSB7fTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgaW4gbWFwcGluZykge1xcblxcdCAgICAgICAgICAgIGlmIChtYXBwaW5nW2ldKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGVtYmVkcy5wdXNoKGkpO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRtb2Rlc1tpXSA9IG5ldyBtYXBwaW5nW2ldKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGRlbGVnYXRpb25zID0gWyd0b2dnbGVCbG9ja0NvbW1lbnQnLCAndG9nZ2xlQ29tbWVudExpbmVzJywgJ2dldE5leHRMaW5lSW5kZW50JywgXFxuXFx0ICAgICAgICAgICAgJ2NoZWNrT3V0ZGVudCcsICdhdXRvT3V0ZGVudCcsICd0cmFuc2Zvcm1BY3Rpb24nLCAnZ2V0Q29tcGxldGlvbnMnXTtcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZWdhdGlvbnMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAoZnVuY3Rpb24oc2NvcGUpIHtcXG5cXHQgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBkZWxlZ2F0aW9uc1tpXTtcXG5cXHQgICAgICAgICAgICAgIHZhciBkZWZhdWx0SGFuZGxlciA9IHNjb3BlW2Z1bmN0aW9uTmFtZV07XFxuXFx0ICAgICAgICAgICAgICBzY29wZVtkZWxlZ2F0aW9uc1tpXV0gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZGVsZWdhdG9yKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRzLCBkZWZhdWx0SGFuZGxlcik7XFxuXFx0ICAgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgIH0gKHRoaXMpKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kZGVsZWdhdG9yID0gZnVuY3Rpb24obWV0aG9kLCBhcmdzLCBkZWZhdWx0SGFuZGxlcikge1xcblxcdCAgICAgICAgdmFyIHN0YXRlID0gYXJnc1swXTtcXG5cXHQgICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0ICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVswXTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kZW1iZWRzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRtb2Rlc1t0aGlzLiRlbWJlZHNbaV1dKSBjb250aW51ZTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgc3BsaXQgPSBzdGF0ZS5zcGxpdCh0aGlzLiRlbWJlZHNbaV0pO1xcblxcdCAgICAgICAgICAgIGlmICghc3BsaXRbMF0gJiYgc3BsaXRbMV0pIHtcXG5cXHQgICAgICAgICAgICAgICAgYXJnc1swXSA9IHNwbGl0WzFdO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IHRoaXMuJG1vZGVzW3RoaXMuJGVtYmVkc1tpXV07XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBtb2RlW21ldGhvZF0uYXBwbHkobW9kZSwgYXJncyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIHJldCA9IGRlZmF1bHRIYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblxcdCAgICAgICAgcmV0dXJuIGRlZmF1bHRIYW5kbGVyID8gcmV0IDogdW5kZWZpbmVkO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnRyYW5zZm9ybUFjdGlvbiA9IGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcGFyYW0pIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRiZWhhdmlvdXIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgYmVoYXZpb3VycyA9IHRoaXMuJGJlaGF2aW91ci5nZXRCZWhhdmlvdXJzKCk7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGJlaGF2aW91cnMpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGJlaGF2aW91cnNba2V5XVthY3Rpb25dKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gYmVoYXZpb3Vyc1trZXldW2FjdGlvbl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5nZXRLZXl3b3JkcyA9IGZ1bmN0aW9uKGFwcGVuZCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRpb25LZXl3b3Jkcykge1xcblxcdCAgICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuJHRva2VuaXplci5ydWxlcztcXG5cXHQgICAgICAgICAgICB2YXIgY29tcGxldGlvbktleXdvcmRzID0gW107XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgcnVsZSBpbiBydWxlcykge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgcnVsZUl0ciA9IHJ1bGVzW3J1bGVdO1xcblxcdCAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgbCA9IHJ1bGVJdHIubGVuZ3RoOyByIDwgbDsgcisrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGVJdHJbcl0udG9rZW4gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9rZXl3b3JkfHN1cHBvcnR8c3RvcmFnZS8udGVzdChydWxlSXRyW3JdLnRva2VuKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbktleXdvcmRzLnB1c2gocnVsZUl0cltyXS5yZWdleCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVsZUl0cltyXS50b2tlbiA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMCwgYUxlbmd0aCA9IHJ1bGVJdHJbcl0udG9rZW4ubGVuZ3RoOyBhIDwgYUxlbmd0aDsgYSsrKSB7ICAgIFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL2tleXdvcmR8c3VwcG9ydHxzdG9yYWdlLy50ZXN0KHJ1bGVJdHJbcl0udG9rZW5bYV0pKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVJdHJbcl0ucmVnZXgubWF0Y2goL1xcXFwoLis/XFxcXCkvZylbYV07XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uS2V5d29yZHMucHVzaChydWxlLnN1YnN0cigxLCBydWxlLmxlbmd0aCAtIDIpKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25LZXl3b3JkcyA9IGNvbXBsZXRpb25LZXl3b3JkcztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICghYXBwZW5kKVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLiRrZXl3b3JkTGlzdDtcXG5cXHQgICAgICAgIHJldHVybiBjb21wbGV0aW9uS2V5d29yZHMuY29uY2F0KHRoaXMuJGtleXdvcmRMaXN0IHx8IFtdKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJGNyZWF0ZUtleXdvcmRMaXN0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGhpZ2hsaWdodFJ1bGVzKVxcblxcdCAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5pemVyKCk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4ka2V5d29yZExpc3QgPSB0aGlzLiRoaWdobGlnaHRSdWxlcy4ka2V5d29yZExpc3QgfHwgW107XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0Q29tcGxldGlvbnMgPSBmdW5jdGlvbihzdGF0ZSwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgpIHtcXG5cXHQgICAgICAgIHZhciBrZXl3b3JkcyA9IHRoaXMuJGtleXdvcmRMaXN0IHx8IHRoaXMuJGNyZWF0ZUtleXdvcmRMaXN0KCk7XFxuXFx0ICAgICAgICByZXR1cm4ga2V5d29yZHMubWFwKGZ1bmN0aW9uKHdvcmQpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICBuYW1lOiB3b3JkLFxcblxcdCAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcXG5cXHQgICAgICAgICAgICAgICAgc2NvcmU6IDAsXFxuXFx0ICAgICAgICAgICAgICAgIG1ldGE6IFxcXCJrZXl3b3JkXFxcIlxcblxcdCAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kaWQgPSBcXFwiYWNlL21vZGUvdGV4dFxcXCI7XFxuXFx0fSkuY2FsbChNb2RlLnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5Nb2RlID0gTW9kZTtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvYW5jaG9yXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXG5cXHR2YXIgQW5jaG9yID0gZXhwb3J0cy5BbmNob3IgPSBmdW5jdGlvbihkb2MsIHJvdywgY29sdW1uKSB7XFxuXFx0ICAgIHRoaXMuJG9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xcblxcdCAgICB0aGlzLmF0dGFjaChkb2MpO1xcblxcdCAgICBcXG5cXHQgICAgaWYgKHR5cGVvZiBjb2x1bW4gPT0gXFxcInVuZGVmaW5lZFxcXCIpXFxuXFx0ICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHJvdy5yb3csIHJvdy5jb2x1bW4pO1xcblxcdCAgICBlbHNlXFxuXFx0ICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHJvdywgY29sdW1uKTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXG5cXHQgICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xcblxcdCAgICB0aGlzLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCh0aGlzLnJvdywgdGhpcy5jb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy4kaW5zZXJ0UmlnaHQgPSBmYWxzZTtcXG5cXHQgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IGUuZGF0YTtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IGRlbHRhLnJhbmdlO1xcblxcblxcdCAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PSByYW5nZS5lbmQucm93ICYmIHJhbmdlLnN0YXJ0LnJvdyAhPSB0aGlzLnJvdylcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID4gdGhpcy5yb3cpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA9PSB0aGlzLnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPiB0aGlzLmNvbHVtbilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB2YXIgcm93ID0gdGhpcy5yb3c7XFxuXFx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW47XFxuXFx0ICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XFxuXFxuXFx0ICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09PSBcXFwiaW5zZXJ0VGV4dFxcXCIpIHtcXG5cXHQgICAgICAgICAgICBpZiAoc3RhcnQucm93ID09PSByb3cgJiYgc3RhcnQuY29sdW1uIDw9IGNvbHVtbikge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoc3RhcnQuY29sdW1uID09PSBjb2x1bW4gJiYgdGhpcy4kaW5zZXJ0UmlnaHQpIHtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydC5yb3cgPT09IGVuZC5yb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSBlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY29sdW1uIC09IHN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvdyArPSBlbmQucm93IC0gc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydC5yb3cgIT09IGVuZC5yb3cgJiYgc3RhcnQucm93IDwgcm93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyArPSBlbmQucm93IC0gc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09PSBcXFwiaW5zZXJ0TGluZXNcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHN0YXJ0LnJvdyA9PT0gcm93ICYmIGNvbHVtbiA9PT0gMCAmJiB0aGlzLiRpbnNlcnRSaWdodCkge1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChzdGFydC5yb3cgPD0gcm93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyArPSBlbmQucm93IC0gc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09PSBcXFwicmVtb3ZlVGV4dFxcXCIpIHtcXG5cXHQgICAgICAgICAgICBpZiAoc3RhcnQucm93ID09PSByb3cgJiYgc3RhcnQuY29sdW1uIDwgY29sdW1uKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChlbmQuY29sdW1uID49IGNvbHVtbilcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gTWF0aC5tYXgoMCwgY29sdW1uIC0gKGVuZC5jb2x1bW4gLSBzdGFydC5jb2x1bW4pKTtcXG5cXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0LnJvdyAhPT0gZW5kLnJvdyAmJiBzdGFydC5yb3cgPCByb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGVuZC5yb3cgPT09IHJvdylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IE1hdGgubWF4KDAsIGNvbHVtbiAtIGVuZC5jb2x1bW4pICsgc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgICAgICAgICByb3cgLT0gKGVuZC5yb3cgLSBzdGFydC5yb3cpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kLnJvdyA9PT0gcm93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyAtPSBlbmQucm93IC0gc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLm1heCgwLCBjb2x1bW4gLSBlbmQuY29sdW1uKSArIHN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcXFwicmVtb3ZlTGluZXNcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHN0YXJ0LnJvdyA8PSByb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGVuZC5yb3cgPD0gcm93KVxcblxcdCAgICAgICAgICAgICAgICAgICAgcm93IC09IGVuZC5yb3cgLSBzdGFydC5yb3c7XFxuXFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcm93ID0gc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gMDtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocm93LCBjb2x1bW4sIHRydWUpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIG5vQ2xpcCkge1xcblxcdCAgICAgICAgdmFyIHBvcztcXG5cXHQgICAgICAgIGlmIChub0NsaXApIHtcXG5cXHQgICAgICAgICAgICBwb3MgPSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdzogcm93LFxcblxcdCAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtblxcblxcdCAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHBvcyA9IHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKHRoaXMucm93ID09IHBvcy5yb3cgJiYgdGhpcy5jb2x1bW4gPT0gcG9zLmNvbHVtbilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB2YXIgb2xkID0ge1xcblxcdCAgICAgICAgICAgIHJvdzogdGhpcy5yb3csXFxuXFx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtblxcblxcdCAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgIHRoaXMucm93ID0gcG9zLnJvdztcXG5cXHQgICAgICAgIHRoaXMuY29sdW1uID0gcG9zLmNvbHVtbjtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIiwge1xcblxcdCAgICAgICAgICAgIG9sZDogb2xkLFxcblxcdCAgICAgICAgICAgIHZhbHVlOiBwb3NcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VcXFwiLCB0aGlzLiRvbkNoYW5nZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYXR0YWNoID0gZnVuY3Rpb24oZG9jKSB7XFxuXFx0ICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jIHx8IHRoaXMuZG9jdW1lbnQ7XFxuXFx0ICAgICAgICB0aGlzLmRvY3VtZW50Lm9uKFxcXCJjaGFuZ2VcXFwiLCB0aGlzLiRvbkNoYW5nZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgdmFyIHBvcyA9IHt9O1xcblxcblxcdCAgICAgICAgaWYgKHJvdyA+PSB0aGlzLmRvY3VtZW50LmdldExlbmd0aCgpKSB7XFxuXFx0ICAgICAgICAgICAgcG9zLnJvdyA9IE1hdGgubWF4KDAsIHRoaXMuZG9jdW1lbnQuZ2V0TGVuZ3RoKCkgLSAxKTtcXG5cXHQgICAgICAgICAgICBwb3MuY29sdW1uID0gdGhpcy5kb2N1bWVudC5nZXRMaW5lKHBvcy5yb3cpLmxlbmd0aDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2UgaWYgKHJvdyA8IDApIHtcXG5cXHQgICAgICAgICAgICBwb3Mucm93ID0gMDtcXG5cXHQgICAgICAgICAgICBwb3MuY29sdW1uID0gMDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgIHBvcy5yb3cgPSByb3c7XFxuXFx0ICAgICAgICAgICAgcG9zLmNvbHVtbiA9IE1hdGgubWluKHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGgsIE1hdGgubWF4KDAsIGNvbHVtbikpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKGNvbHVtbiA8IDApXFxuXFx0ICAgICAgICAgICAgcG9zLmNvbHVtbiA9IDA7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gcG9zO1xcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoQW5jaG9yLnByb3RvdHlwZSk7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2RvY3VtZW50XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiLFxcXCJhY2UvcmFuZ2VcXFwiLFxcXCJhY2UvYW5jaG9yXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXFxcIi4vbGliL2V2ZW50X2VtaXR0ZXJcXFwiKS5FdmVudEVtaXR0ZXI7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXHR2YXIgQW5jaG9yID0gYWNlcXVpcmUoXFxcIi4vYW5jaG9yXFxcIikuQW5jaG9yO1xcblxcblxcdHZhciBEb2N1bWVudCA9IGZ1bmN0aW9uKHRleHQpIHtcXG5cXHQgICAgdGhpcy4kbGluZXMgPSBbXTtcXG5cXHQgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XFxuXFx0ICAgICAgICB0aGlzLiRsaW5lcyA9IFtcXFwiXFxcIl07XFxuXFx0ICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0KSkge1xcblxcdCAgICAgICAgdGhpcy5faW5zZXJ0TGluZXMoMCwgdGV4dCk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICB0aGlzLmluc2VydCh7cm93OiAwLCBjb2x1bW46MH0sIHRleHQpO1xcblxcdCAgICB9XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcXG5cXHQgICAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHRleHQpIHtcXG5cXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgdGhpcy5yZW1vdmUobmV3IFJhbmdlKDAsIDAsIGxlbiwgdGhpcy5nZXRMaW5lKGxlbi0xKS5sZW5ndGgpKTtcXG5cXHQgICAgICAgIHRoaXMuaW5zZXJ0KHtyb3c6IDAsIGNvbHVtbjowfSwgdGV4dCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldEFsbExpbmVzKCkuam9pbih0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY3JlYXRlQW5jaG9yID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHJldHVybiBuZXcgQW5jaG9yKHRoaXMsIHJvdywgY29sdW1uKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgaWYgKFxcXCJhYWFcXFwiLnNwbGl0KC9hLykubGVuZ3RoID09PSAwKVxcblxcdCAgICAgICAgdGhpcy4kc3BsaXQgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxcXHJcXFxcbnxcXFxcci9nLCBcXFwiXFxcXG5cXFwiKS5zcGxpdChcXFwiXFxcXG5cXFwiKTtcXG5cXHQgICAgICAgIH07XFxuXFx0ICAgIGVsc2VcXG5cXHQgICAgICAgIHRoaXMuJHNwbGl0ID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXFxcclxcXFxufFxcXFxyfFxcXFxuLyk7XFxuXFx0ICAgICAgICB9O1xcblxcblxcblxcdCAgICB0aGlzLiRkZXRlY3ROZXdMaW5lID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXi4qPyhcXFxcclxcXFxufFxcXFxyfFxcXFxuKS9tKTtcXG5cXHQgICAgICAgIHRoaXMuJGF1dG9OZXdMaW5lID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFxcXCJcXFxcblxcXCI7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZU5ld0xpbmVNb2RlXFxcIik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgc3dpdGNoICh0aGlzLiRuZXdMaW5lTW9kZSkge1xcblxcdCAgICAgICAgICBjYXNlIFxcXCJ3aW5kb3dzXFxcIjpcXG5cXHQgICAgICAgICAgICByZXR1cm4gXFxcIlxcXFxyXFxcXG5cXFwiO1xcblxcdCAgICAgICAgICBjYXNlIFxcXCJ1bml4XFxcIjpcXG5cXHQgICAgICAgICAgICByZXR1cm4gXFxcIlxcXFxuXFxcIjtcXG5cXHQgICAgICAgICAgZGVmYXVsdDpcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy4kYXV0b05ld0xpbmUgfHwgXFxcIlxcXFxuXFxcIjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kYXV0b05ld0xpbmUgPSBcXFwiXFxcIjtcXG5cXHQgICAgdGhpcy4kbmV3TGluZU1vZGUgPSBcXFwiYXV0b1xcXCI7XFxuXFx0ICAgIHRoaXMuc2V0TmV3TGluZU1vZGUgPSBmdW5jdGlvbihuZXdMaW5lTW9kZSkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJG5ld0xpbmVNb2RlID09PSBuZXdMaW5lTW9kZSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB0aGlzLiRuZXdMaW5lTW9kZSA9IG5ld0xpbmVNb2RlO1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VOZXdMaW5lTW9kZVxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldE5ld0xpbmVNb2RlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kbmV3TGluZU1vZGU7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaXNOZXdMaW5lID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgcmV0dXJuICh0ZXh0ID09IFxcXCJcXFxcclxcXFxuXFxcIiB8fCB0ZXh0ID09IFxcXCJcXFxcclxcXCIgfHwgdGV4dCA9PSBcXFwiXFxcXG5cXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMaW5lID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kbGluZXNbcm93XSB8fCBcXFwiXFxcIjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMaW5lcyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kbGluZXMuc2xpY2UoZmlyc3RSb3csIGxhc3RSb3cgKyAxKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRBbGxMaW5lcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZXMoMCwgdGhpcy5nZXRMZW5ndGgoKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kbGluZXMubGVuZ3RoO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFRleHRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XFxuXFx0ICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID09IHJhbmdlLmVuZC5yb3cpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdylcXG5cXHQgICAgICAgICAgICAgICAgLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4sIHJhbmdlLmVuZC5jb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5nZXRMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpO1xcblxcdCAgICAgICAgbGluZXNbMF0gPSAobGluZXNbMF0gfHwgXFxcIlxcXCIpLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgdmFyIGwgPSBsaW5lcy5sZW5ndGggLSAxO1xcblxcdCAgICAgICAgaWYgKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cgPT0gbClcXG5cXHQgICAgICAgICAgICBsaW5lc1tsXSA9IGxpbmVzW2xdLnN1YnN0cmluZygwLCByYW5nZS5lbmQuY29sdW1uKTtcXG5cXHQgICAgICAgIHJldHVybiBsaW5lcy5qb2luKHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kY2xpcFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHQgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgaWYgKHBvc2l0aW9uLnJvdyA+PSBsZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICBwb3NpdGlvbi5yb3cgPSBNYXRoLm1heCgwLCBsZW5ndGggLSAxKTtcXG5cXHQgICAgICAgICAgICBwb3NpdGlvbi5jb2x1bW4gPSB0aGlzLmdldExpbmUobGVuZ3RoLTEpLmxlbmd0aDtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24ucm93IDwgMClcXG5cXHQgICAgICAgICAgICBwb3NpdGlvbi5yb3cgPSAwO1xcblxcdCAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmluc2VydCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCB0ZXh0KSB7XFxuXFx0ICAgICAgICBpZiAoIXRleHQgfHwgdGV4dC5sZW5ndGggPT09IDApXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xcblxcblxcdCAgICAgICAgcG9zaXRpb24gPSB0aGlzLiRjbGlwUG9zaXRpb24ocG9zaXRpb24pO1xcblxcdCAgICAgICAgaWYgKHRoaXMuZ2V0TGVuZ3RoKCkgPD0gMSlcXG5cXHQgICAgICAgICAgICB0aGlzLiRkZXRlY3ROZXdMaW5lKHRleHQpO1xcblxcblxcdCAgICAgICAgdmFyIGxpbmVzID0gdGhpcy4kc3BsaXQodGV4dCk7XFxuXFx0ICAgICAgICB2YXIgZmlyc3RMaW5lID0gbGluZXMuc3BsaWNlKDAsIDEpWzBdO1xcblxcdCAgICAgICAgdmFyIGxhc3RMaW5lID0gbGluZXMubGVuZ3RoID09IDAgPyBudWxsIDogbGluZXMuc3BsaWNlKGxpbmVzLmxlbmd0aCAtIDEsIDEpWzBdO1xcblxcblxcdCAgICAgICAgcG9zaXRpb24gPSB0aGlzLmluc2VydEluTGluZShwb3NpdGlvbiwgZmlyc3RMaW5lKTtcXG5cXHQgICAgICAgIGlmIChsYXN0TGluZSAhPT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5pbnNlcnROZXdMaW5lKHBvc2l0aW9uKTsgLy8gdGVybWluYXRlIGZpcnN0IGxpbmVcXG5cXHQgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2luc2VydExpbmVzKHBvc2l0aW9uLnJvdywgbGluZXMpO1xcblxcdCAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5pbnNlcnRJbkxpbmUocG9zaXRpb24sIGxhc3RMaW5lIHx8IFxcXCJcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBwb3NpdGlvbjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pbnNlcnRMaW5lcyA9IGZ1bmN0aW9uKHJvdywgbGluZXMpIHtcXG5cXHQgICAgICAgIGlmIChyb3cgPj0gdGhpcy5nZXRMZW5ndGgoKSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnQoe3Jvdzogcm93LCBjb2x1bW46IDB9LCBcXFwiXFxcXG5cXFwiICsgbGluZXMuam9pbihcXFwiXFxcXG5cXFwiKSk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TGluZXMoTWF0aC5tYXgocm93LCAwKSwgbGluZXMpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLl9pbnNlcnRMaW5lcyA9IGZ1bmN0aW9uKHJvdywgbGluZXMpIHtcXG5cXHQgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gMClcXG5cXHQgICAgICAgICAgICByZXR1cm4ge3Jvdzogcm93LCBjb2x1bW46IDB9O1xcblxcdCAgICAgICAgd2hpbGUgKGxpbmVzLmxlbmd0aCA+IDB4RjAwMCkge1xcblxcdCAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9pbnNlcnRMaW5lcyhyb3csIGxpbmVzLnNsaWNlKDAsIDB4RjAwMCkpO1xcblxcdCAgICAgICAgICAgIGxpbmVzID0gbGluZXMuc2xpY2UoMHhGMDAwKTtcXG5cXHQgICAgICAgICAgICByb3cgPSBlbmQucm93O1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGFyZ3MgPSBbcm93LCAwXTtcXG5cXHQgICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBsaW5lcyk7XFxuXFx0ICAgICAgICB0aGlzLiRsaW5lcy5zcGxpY2UuYXBwbHkodGhpcy4kbGluZXMsIGFyZ3MpO1xcblxcblxcdCAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHJvdywgMCwgcm93ICsgbGluZXMubGVuZ3RoLCAwKTtcXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IHtcXG5cXHQgICAgICAgICAgICBhY3Rpb246IFxcXCJpbnNlcnRMaW5lc1xcXCIsXFxuXFx0ICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxcblxcdCAgICAgICAgICAgIGxpbmVzOiBsaW5lc1xcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIiwgeyBkYXRhOiBkZWx0YSB9KTtcXG5cXHQgICAgICAgIHJldHVybiByYW5nZS5lbmQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaW5zZXJ0TmV3TGluZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XFxuXFx0ICAgICAgICBwb3NpdGlvbiA9IHRoaXMuJGNsaXBQb3NpdGlvbihwb3NpdGlvbik7XFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd10gfHwgXFxcIlxcXCI7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRsaW5lc1twb3NpdGlvbi5yb3ddID0gbGluZS5zdWJzdHJpbmcoMCwgcG9zaXRpb24uY29sdW1uKTtcXG5cXHQgICAgICAgIHRoaXMuJGxpbmVzLnNwbGljZShwb3NpdGlvbi5yb3cgKyAxLCAwLCBsaW5lLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4sIGxpbmUubGVuZ3RoKSk7XFxuXFxuXFx0ICAgICAgICB2YXIgZW5kID0ge1xcblxcdCAgICAgICAgICAgIHJvdyA6IHBvc2l0aW9uLnJvdyArIDEsXFxuXFx0ICAgICAgICAgICAgY29sdW1uIDogMFxcblxcdCAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IHtcXG5cXHQgICAgICAgICAgICBhY3Rpb246IFxcXCJpbnNlcnRUZXh0XFxcIixcXG5cXHQgICAgICAgICAgICByYW5nZTogUmFuZ2UuZnJvbVBvaW50cyhwb3NpdGlvbiwgZW5kKSxcXG5cXHQgICAgICAgICAgICB0ZXh0OiB0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKVxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIiwgeyBkYXRhOiBkZWx0YSB9KTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBlbmQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaW5zZXJ0SW5MaW5lID0gZnVuY3Rpb24ocG9zaXRpb24sIHRleHQpIHtcXG5cXHQgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxcblxcdCAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcXG5cXG5cXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy4kbGluZXNbcG9zaXRpb24ucm93XSB8fCBcXFwiXFxcIjtcXG5cXG5cXHQgICAgICAgIHRoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd10gPSBsaW5lLnN1YnN0cmluZygwLCBwb3NpdGlvbi5jb2x1bW4pICsgdGV4dFxcblxcdCAgICAgICAgICAgICAgICArIGxpbmUuc3Vic3RyaW5nKHBvc2l0aW9uLmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICB2YXIgZW5kID0ge1xcblxcdCAgICAgICAgICAgIHJvdyA6IHBvc2l0aW9uLnJvdyxcXG5cXHQgICAgICAgICAgICBjb2x1bW4gOiBwb3NpdGlvbi5jb2x1bW4gKyB0ZXh0Lmxlbmd0aFxcblxcdCAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IHtcXG5cXHQgICAgICAgICAgICBhY3Rpb246IFxcXCJpbnNlcnRUZXh0XFxcIixcXG5cXHQgICAgICAgICAgICByYW5nZTogUmFuZ2UuZnJvbVBvaW50cyhwb3NpdGlvbiwgZW5kKSxcXG5cXHQgICAgICAgICAgICB0ZXh0OiB0ZXh0XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VcXFwiLCB7IGRhdGE6IGRlbHRhIH0pO1xcblxcblxcdCAgICAgICAgcmV0dXJuIGVuZDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpXFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xcblxcdCAgICAgICAgcmFuZ2Uuc3RhcnQgPSB0aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2Uuc3RhcnQpO1xcblxcdCAgICAgICAgcmFuZ2UuZW5kID0gdGhpcy4kY2xpcFBvc2l0aW9uKHJhbmdlLmVuZCk7XFxuXFxuXFx0ICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcXG5cXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIHZhciBsYXN0Um93ID0gcmFuZ2UuZW5kLnJvdztcXG5cXG5cXHQgICAgICAgIGlmIChyYW5nZS5pc011bHRpTGluZSgpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZpcnN0RnVsbFJvdyA9IHJhbmdlLnN0YXJ0LmNvbHVtbiA9PSAwID8gZmlyc3RSb3cgOiBmaXJzdFJvdyArIDE7XFxuXFx0ICAgICAgICAgICAgdmFyIGxhc3RGdWxsUm93ID0gbGFzdFJvdyAtIDE7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHJhbmdlLmVuZC5jb2x1bW4gPiAwKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUluTGluZShsYXN0Um93LCAwLCByYW5nZS5lbmQuY29sdW1uKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAobGFzdEZ1bGxSb3cgPj0gZmlyc3RGdWxsUm93KVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaW5lcyhmaXJzdEZ1bGxSb3csIGxhc3RGdWxsUm93KTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoZmlyc3RGdWxsUm93ICE9IGZpcnN0Um93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5MaW5lKGZpcnN0Um93LCByYW5nZS5zdGFydC5jb2x1bW4sIHRoaXMuZ2V0TGluZShmaXJzdFJvdykubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOZXdMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW1vdmVJbkxpbmUoZmlyc3RSb3csIHJhbmdlLnN0YXJ0LmNvbHVtbiwgcmFuZ2UuZW5kLmNvbHVtbik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlSW5MaW5lID0gZnVuY3Rpb24ocm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAoc3RhcnRDb2x1bW4gPT0gZW5kQ29sdW1uKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShyb3csIHN0YXJ0Q29sdW1uLCByb3csIGVuZENvbHVtbik7XFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ2V0TGluZShyb3cpO1xcblxcdCAgICAgICAgdmFyIHJlbW92ZWQgPSBsaW5lLnN1YnN0cmluZyhzdGFydENvbHVtbiwgZW5kQ29sdW1uKTtcXG5cXHQgICAgICAgIHZhciBuZXdMaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgc3RhcnRDb2x1bW4pICsgbGluZS5zdWJzdHJpbmcoZW5kQ29sdW1uLCBsaW5lLmxlbmd0aCk7XFxuXFx0ICAgICAgICB0aGlzLiRsaW5lcy5zcGxpY2Uocm93LCAxLCBuZXdMaW5lKTtcXG5cXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IHtcXG5cXHQgICAgICAgICAgICBhY3Rpb246IFxcXCJyZW1vdmVUZXh0XFxcIixcXG5cXHQgICAgICAgICAgICByYW5nZTogcmFuZ2UsXFxuXFx0ICAgICAgICAgICAgdGV4dDogcmVtb3ZlZFxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIiwgeyBkYXRhOiBkZWx0YSB9KTtcXG5cXHQgICAgICAgIHJldHVybiByYW5nZS5zdGFydDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZW1vdmVMaW5lcyA9IGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XFxuXFx0ICAgICAgICBpZiAoZmlyc3RSb3cgPCAwIHx8IGxhc3RSb3cgPj0gdGhpcy5nZXRMZW5ndGgoKSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUobmV3IFJhbmdlKGZpcnN0Um93LCAwLCBsYXN0Um93ICsgMSwgMCkpO1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUxpbmVzKGZpcnN0Um93LCBsYXN0Um93KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5fcmVtb3ZlTGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGZpcnN0Um93LCAwLCBsYXN0Um93ICsgMSwgMCk7XFxuXFx0ICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuJGxpbmVzLnNwbGljZShmaXJzdFJvdywgbGFzdFJvdyAtIGZpcnN0Um93ICsgMSk7XFxuXFxuXFx0ICAgICAgICB2YXIgZGVsdGEgPSB7XFxuXFx0ICAgICAgICAgICAgYWN0aW9uOiBcXFwicmVtb3ZlTGluZXNcXFwiLFxcblxcdCAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcXG5cXHQgICAgICAgICAgICBubDogdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCksXFxuXFx0ICAgICAgICAgICAgbGluZXM6IHJlbW92ZWRcXG5cXHQgICAgICAgIH07XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVxcXCIsIHsgZGF0YTogZGVsdGEgfSk7XFxuXFx0ICAgICAgICByZXR1cm4gcmVtb3ZlZDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZW1vdmVOZXdMaW5lID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICB2YXIgZmlyc3RMaW5lID0gdGhpcy5nZXRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICB2YXIgc2Vjb25kTGluZSA9IHRoaXMuZ2V0TGluZShyb3crMSk7XFxuXFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBmaXJzdExpbmUubGVuZ3RoLCByb3crMSwgMCk7XFxuXFx0ICAgICAgICB2YXIgbGluZSA9IGZpcnN0TGluZSArIHNlY29uZExpbmU7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRsaW5lcy5zcGxpY2Uocm93LCAyLCBsaW5lKTtcXG5cXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IHtcXG5cXHQgICAgICAgICAgICBhY3Rpb246IFxcXCJyZW1vdmVUZXh0XFxcIixcXG5cXHQgICAgICAgICAgICByYW5nZTogcmFuZ2UsXFxuXFx0ICAgICAgICAgICAgdGV4dDogdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKClcXG5cXHQgICAgICAgIH07XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVxcXCIsIHsgZGF0YTogZGVsdGEgfSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVwbGFjZSA9IGZ1bmN0aW9uKHJhbmdlLCB0ZXh0KSB7XFxuXFx0ICAgICAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSlcXG5cXHQgICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XFxuXFx0ICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMCAmJiByYW5nZS5pc0VtcHR5KCkpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgaWYgKHRleHQgPT0gdGhpcy5nZXRUZXh0UmFuZ2UocmFuZ2UpKVxcblxcdCAgICAgICAgICAgIHJldHVybiByYW5nZS5lbmQ7XFxuXFxuXFx0ICAgICAgICB0aGlzLnJlbW92ZShyYW5nZSk7XFxuXFx0ICAgICAgICBpZiAodGV4dCkge1xcblxcdCAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmluc2VydChyYW5nZS5zdGFydCwgdGV4dCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICBlbmQgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBlbmQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYXBwbHlEZWx0YXMgPSBmdW5jdGlvbihkZWx0YXMpIHtcXG5cXHQgICAgICAgIGZvciAodmFyIGk9MDsgaTxkZWx0YXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhkZWx0YS5yYW5nZS5zdGFydCwgZGVsdGEucmFuZ2UuZW5kKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoZGVsdGEuYWN0aW9uID09IFxcXCJpbnNlcnRMaW5lc1xcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0TGluZXMocmFuZ2Uuc3RhcnQucm93LCBkZWx0YS5saW5lcyk7XFxuXFx0ICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFxcXCJpbnNlcnRUZXh0XFxcIilcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQocmFuZ2Uuc3RhcnQsIGRlbHRhLnRleHQpO1xcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcXFwicmVtb3ZlTGluZXNcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cgLSAxKTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXFxcInJlbW92ZVRleHRcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShyYW5nZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmV2ZXJ0RGVsdGFzID0gZnVuY3Rpb24oZGVsdGFzKSB7XFxuXFx0ICAgICAgICBmb3IgKHZhciBpPWRlbHRhcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGRlbHRhID0gZGVsdGFzW2ldO1xcblxcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoZGVsdGEucmFuZ2Uuc3RhcnQsIGRlbHRhLnJhbmdlLmVuZCk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGRlbHRhLmFjdGlvbiA9PSBcXFwiaW5zZXJ0TGluZXNcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cgLSAxKTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXFxcImluc2VydFRleHRcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFxcXCJyZW1vdmVMaW5lc1xcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydExpbmVzKHJhbmdlLnN0YXJ0LnJvdywgZGVsdGEubGluZXMpO1xcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcXFwicmVtb3ZlVGV4dFxcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHJhbmdlLnN0YXJ0LCBkZWx0YS50ZXh0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pbmRleFRvUG9zaXRpb24gPSBmdW5jdGlvbihpbmRleCwgc3RhcnRSb3cpIHtcXG5cXHQgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuJGxpbmVzIHx8IHRoaXMuZ2V0QWxsTGluZXMoKTtcXG5cXHQgICAgICAgIHZhciBuZXdsaW5lTGVuZ3RoID0gdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0Um93IHx8IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpbmRleCAtPSBsaW5lc1tpXS5sZW5ndGggKyBuZXdsaW5lTGVuZ3RoO1xcblxcdCAgICAgICAgICAgIGlmIChpbmRleCA8IDApXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB7cm93OiBpLCBjb2x1bW46IGluZGV4ICsgbGluZXNbaV0ubGVuZ3RoICsgbmV3bGluZUxlbmd0aH07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4ge3JvdzogbC0xLCBjb2x1bW46IGxpbmVzW2wtMV0ubGVuZ3RofTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5wb3NpdGlvblRvSW5kZXggPSBmdW5jdGlvbihwb3MsIHN0YXJ0Um93KSB7XFxuXFx0ICAgICAgICB2YXIgbGluZXMgPSB0aGlzLiRsaW5lcyB8fCB0aGlzLmdldEFsbExpbmVzKCk7XFxuXFx0ICAgICAgICB2YXIgbmV3bGluZUxlbmd0aCA9IHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpLmxlbmd0aDtcXG5cXHQgICAgICAgIHZhciBpbmRleCA9IDA7XFxuXFx0ICAgICAgICB2YXIgcm93ID0gTWF0aC5taW4ocG9zLnJvdywgbGluZXMubGVuZ3RoKTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSBzdGFydFJvdyB8fCAwOyBpIDwgcm93OyArK2kpXFxuXFx0ICAgICAgICAgICAgaW5kZXggKz0gbGluZXNbaV0ubGVuZ3RoICsgbmV3bGluZUxlbmd0aDtcXG5cXG5cXHQgICAgICAgIHJldHVybiBpbmRleCArIHBvcy5jb2x1bW47XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChEb2N1bWVudC5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudDtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvYmFja2dyb3VuZF90b2tlbml6ZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvZXZlbnRfZW1pdHRlclxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFxcXCIuL2xpYi9ldmVudF9lbWl0dGVyXFxcIikuRXZlbnRFbWl0dGVyO1xcblxcblxcdHZhciBCYWNrZ3JvdW5kVG9rZW5pemVyID0gZnVuY3Rpb24odG9rZW5pemVyLCBlZGl0b3IpIHtcXG5cXHQgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XFxuXFx0ICAgIHRoaXMubGluZXMgPSBbXTtcXG5cXHQgICAgdGhpcy5zdGF0ZXMgPSBbXTtcXG5cXHQgICAgdGhpcy5jdXJyZW50TGluZSA9IDA7XFxuXFx0ICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xcblxcblxcdCAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuXFx0ICAgIHRoaXMuJHdvcmtlciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCFzZWxmLnJ1bm5pbmcpIHsgcmV0dXJuOyB9XFxuXFxuXFx0ICAgICAgICB2YXIgd29ya2VyU3RhcnQgPSBuZXcgRGF0ZSgpO1xcblxcdCAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gc2VsZi5jdXJyZW50TGluZTtcXG5cXHQgICAgICAgIHZhciBlbmRMaW5lID0gLTE7XFxuXFx0ICAgICAgICB2YXIgZG9jID0gc2VsZi5kb2M7XFxuXFxuXFx0ICAgICAgICB3aGlsZSAoc2VsZi5saW5lc1tjdXJyZW50TGluZV0pXFxuXFx0ICAgICAgICAgICAgY3VycmVudExpbmUrKztcXG5cXG5cXHQgICAgICAgIHZhciBzdGFydExpbmUgPSBjdXJyZW50TGluZTtcXG5cXG5cXHQgICAgICAgIHZhciBsZW4gPSBkb2MuZ2V0TGVuZ3RoKCk7XFxuXFx0ICAgICAgICB2YXIgcHJvY2Vzc2VkTGluZXMgPSAwO1xcblxcdCAgICAgICAgc2VsZi5ydW5uaW5nID0gZmFsc2U7XFxuXFx0ICAgICAgICB3aGlsZSAoY3VycmVudExpbmUgPCBsZW4pIHtcXG5cXHQgICAgICAgICAgICBzZWxmLiR0b2tlbml6ZVJvdyhjdXJyZW50TGluZSk7XFxuXFx0ICAgICAgICAgICAgZW5kTGluZSA9IGN1cnJlbnRMaW5lO1xcblxcdCAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgY3VycmVudExpbmUrKztcXG5cXHQgICAgICAgICAgICB9IHdoaWxlIChzZWxmLmxpbmVzW2N1cnJlbnRMaW5lXSk7XFxuXFx0ICAgICAgICAgICAgcHJvY2Vzc2VkTGluZXMgKys7XFxuXFx0ICAgICAgICAgICAgaWYgKChwcm9jZXNzZWRMaW5lcyAlIDUgPT09IDApICYmIChuZXcgRGF0ZSgpIC0gd29ya2VyU3RhcnQpID4gMjApIHsgICAgICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgICAgIHNlbGYucnVubmluZyA9IHNldFRpbWVvdXQoc2VsZi4kd29ya2VyLCAyMCk7XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHNlbGYuY3VycmVudExpbmUgPSBjdXJyZW50TGluZTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHN0YXJ0TGluZSA8PSBlbmRMaW5lKVxcblxcdCAgICAgICAgICAgIHNlbGYuZmlyZVVwZGF0ZUV2ZW50KHN0YXJ0TGluZSwgZW5kTGluZSk7XFxuXFx0ICAgIH07XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKXtcXG5cXG5cXHQgICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xcblxcdCAgICB0aGlzLnNldFRva2VuaXplciA9IGZ1bmN0aW9uKHRva2VuaXplcikge1xcblxcdCAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XFxuXFx0ICAgICAgICB0aGlzLmxpbmVzID0gW107XFxuXFx0ICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xcblxcblxcdCAgICAgICAgdGhpcy5zdGFydCgwKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKGRvYykge1xcblxcdCAgICAgICAgdGhpcy5kb2MgPSBkb2M7XFxuXFx0ICAgICAgICB0aGlzLmxpbmVzID0gW107XFxuXFx0ICAgICAgICB0aGlzLnN0YXRlcyA9IFtdO1xcblxcblxcdCAgICAgICAgdGhpcy5zdG9wKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZmlyZVVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcXG5cXHQgICAgICAgIHZhciBkYXRhID0ge1xcblxcdCAgICAgICAgICAgIGZpcnN0OiBmaXJzdFJvdyxcXG5cXHQgICAgICAgICAgICBsYXN0OiBsYXN0Um93XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJ1cGRhdGVcXFwiLCB7ZGF0YTogZGF0YX0pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oc3RhcnRSb3cpIHtcXG5cXHQgICAgICAgIHRoaXMuY3VycmVudExpbmUgPSBNYXRoLm1pbihzdGFydFJvdyB8fCAwLCB0aGlzLmN1cnJlbnRMaW5lLCB0aGlzLmRvYy5nZXRMZW5ndGgoKSk7XFxuXFx0ICAgICAgICB0aGlzLmxpbmVzLnNwbGljZSh0aGlzLmN1cnJlbnRMaW5lLCB0aGlzLmxpbmVzLmxlbmd0aCk7XFxuXFx0ICAgICAgICB0aGlzLnN0YXRlcy5zcGxpY2UodGhpcy5jdXJyZW50TGluZSwgdGhpcy5zdGF0ZXMubGVuZ3RoKTtcXG5cXG5cXHQgICAgICAgIHRoaXMuc3RvcCgpO1xcblxcdCAgICAgICAgdGhpcy5ydW5uaW5nID0gc2V0VGltZW91dCh0aGlzLiR3b3JrZXIsIDcwMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnNjaGVkdWxlU3RhcnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy5ydW5uaW5nKVxcblxcdCAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHNldFRpbWVvdXQodGhpcy4kd29ya2VyLCA3MDApO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZU9uQ2hhbmdlID0gZnVuY3Rpb24oZGVsdGEpIHtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IGRlbHRhLnJhbmdlO1xcblxcdCAgICAgICAgdmFyIHN0YXJ0Um93ID0gcmFuZ2Uuc3RhcnQucm93O1xcblxcdCAgICAgICAgdmFyIGxlbiA9IHJhbmdlLmVuZC5yb3cgLSBzdGFydFJvdztcXG5cXG5cXHQgICAgICAgIGlmIChsZW4gPT09IDApIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmxpbmVzW3N0YXJ0Um93XSA9IG51bGw7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcXFwicmVtb3ZlVGV4dFxcXCIgfHwgZGVsdGEuYWN0aW9uID09IFxcXCJyZW1vdmVMaW5lc1xcXCIpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmxpbmVzLnNwbGljZShzdGFydFJvdywgbGVuICsgMSwgbnVsbCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zdGF0ZXMuc3BsaWNlKHN0YXJ0Um93LCBsZW4gKyAxLCBudWxsKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW4gKyAxKTtcXG5cXHQgICAgICAgICAgICBhcmdzLnVuc2hpZnQoc3RhcnRSb3csIDEpO1xcblxcdCAgICAgICAgICAgIHRoaXMubGluZXMuc3BsaWNlLmFwcGx5KHRoaXMubGluZXMsIGFyZ3MpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc3RhdGVzLnNwbGljZS5hcHBseSh0aGlzLnN0YXRlcywgYXJncyk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gTWF0aC5taW4oc3RhcnRSb3csIHRoaXMuY3VycmVudExpbmUsIHRoaXMuZG9jLmdldExlbmd0aCgpKTtcXG5cXG5cXHQgICAgICAgIHRoaXMuc3RvcCgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpXFxuXFx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucnVubmluZyk7XFxuXFx0ICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRUb2tlbnMgPSBmdW5jdGlvbihyb3cpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmxpbmVzW3Jvd10gfHwgdGhpcy4kdG9rZW5pemVSb3cocm93KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTdGF0ZSA9IGZ1bmN0aW9uKHJvdykge1xcblxcdCAgICAgICAgaWYgKHRoaXMuY3VycmVudExpbmUgPT0gcm93KVxcblxcdCAgICAgICAgICAgIHRoaXMuJHRva2VuaXplUm93KHJvdyk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbcm93XSB8fCBcXFwic3RhcnRcXFwiO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiR0b2tlbml6ZVJvdyA9IGZ1bmN0aW9uKHJvdykge1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlc1tyb3cgLSAxXTtcXG5cXG5cXHQgICAgICAgIHZhciBkYXRhID0gdGhpcy50b2tlbml6ZXIuZ2V0TGluZVRva2VucyhsaW5lLCBzdGF0ZSwgcm93KTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnN0YXRlc1tyb3ddICsgXFxcIlxcXCIgIT09IGRhdGEuc3RhdGUgKyBcXFwiXFxcIikge1xcblxcdCAgICAgICAgICAgIHRoaXMuc3RhdGVzW3Jvd10gPSBkYXRhLnN0YXRlO1xcblxcdCAgICAgICAgICAgIHRoaXMubGluZXNbcm93ICsgMV0gPSBudWxsO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMaW5lID4gcm93ICsgMSlcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IHJvdyArIDE7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudExpbmUgPT0gcm93KSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9IHJvdyArIDE7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tyb3ddID0gZGF0YS50b2tlbnM7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChCYWNrZ3JvdW5kVG9rZW5pemVyLnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5CYWNrZ3JvdW5kVG9rZW5pemVyID0gQmFja2dyb3VuZFRva2VuaXplcjtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2Uvc2VhcmNoX2hpZ2hsaWdodFxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL3JhbmdlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIGxhbmcgPSBhY2VxdWlyZShcXFwiLi9saWIvbGFuZ1xcXCIpO1xcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXG5cXHR2YXIgU2VhcmNoSGlnaGxpZ2h0ID0gZnVuY3Rpb24ocmVnRXhwLCBjbGF6eiwgdHlwZSkge1xcblxcdCAgICB0aGlzLnNldFJlZ2V4cChyZWdFeHApO1xcblxcdCAgICB0aGlzLmNsYXp6ID0gY2xheno7XFxuXFx0ICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgXFxcInRleHRcXFwiO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLk1BWF9SQU5HRVMgPSA1MDA7XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnNldFJlZ2V4cCA9IGZ1bmN0aW9uKHJlZ0V4cCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMucmVnRXhwK1xcXCJcXFwiID09IHJlZ0V4cCtcXFwiXFxcIilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB0aGlzLnJlZ0V4cCA9IHJlZ0V4cDtcXG5cXHQgICAgICAgIHRoaXMuY2FjaGUgPSBbXTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihodG1sLCBtYXJrZXJMYXllciwgc2Vzc2lvbiwgY29uZmlnKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMucmVnRXhwKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBzdGFydCA9IGNvbmZpZy5maXJzdFJvdywgZW5kID0gY29uZmlnLmxhc3RSb3c7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5jYWNoZVtpXTtcXG5cXHQgICAgICAgICAgICBpZiAocmFuZ2VzID09IG51bGwpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2VzID0gbGFuZy5nZXRNYXRjaE9mZnNldHMoc2Vzc2lvbi5nZXRMaW5lKGkpLCB0aGlzLnJlZ0V4cCk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gdGhpcy5NQVhfUkFOR0VTKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gcmFuZ2VzLnNsaWNlKDAsIHRoaXMuTUFYX1JBTkdFUyk7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlcyA9IHJhbmdlcy5tYXAoZnVuY3Rpb24obWF0Y2gpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2UoaSwgbWF0Y2gub2Zmc2V0LCBpLCBtYXRjaC5vZmZzZXQgKyBtYXRjaC5sZW5ndGgpO1xcblxcdCAgICAgICAgICAgICAgICB9KTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5jYWNoZVtpXSA9IHJhbmdlcy5sZW5ndGggPyByYW5nZXMgOiBcXFwiXFxcIjtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJhbmdlcy5sZW5ndGg7IGogLS07ICkge1xcblxcdCAgICAgICAgICAgICAgICBtYXJrZXJMYXllci5kcmF3U2luZ2xlTGluZU1hcmtlcihcXG5cXHQgICAgICAgICAgICAgICAgICAgIGh0bWwsIHJhbmdlc1tqXS50b1NjcmVlblJhbmdlKHNlc3Npb24pLCB0aGlzLmNsYXp6LCBjb25maWcpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKFNlYXJjaEhpZ2hsaWdodC5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuU2VhcmNoSGlnaGxpZ2h0ID0gU2VhcmNoSGlnaGxpZ2h0O1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9lZGl0X3Nlc3Npb24vZm9sZF9saW5lXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3JhbmdlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4uL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFx0ZnVuY3Rpb24gRm9sZExpbmUoZm9sZERhdGEsIGZvbGRzKSB7XFxuXFx0ICAgIHRoaXMuZm9sZERhdGEgPSBmb2xkRGF0YTtcXG5cXHQgICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZHMpKSB7XFxuXFx0ICAgICAgICB0aGlzLmZvbGRzID0gZm9sZHM7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHMgPSBbIGZvbGRzIF07XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgdmFyIGxhc3QgPSBmb2xkc1tmb2xkcy5sZW5ndGggLSAxXTtcXG5cXHQgICAgdGhpcy5yYW5nZSA9IG5ldyBSYW5nZShmb2xkc1swXS5zdGFydC5yb3csIGZvbGRzWzBdLnN0YXJ0LmNvbHVtbixcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0LmVuZC5yb3csIGxhc3QuZW5kLmNvbHVtbik7XFxuXFx0ICAgIHRoaXMuc3RhcnQgPSB0aGlzLnJhbmdlLnN0YXJ0O1xcblxcdCAgICB0aGlzLmVuZCAgID0gdGhpcy5yYW5nZS5lbmQ7XFxuXFxuXFx0ICAgIHRoaXMuZm9sZHMuZm9yRWFjaChmdW5jdGlvbihmb2xkKSB7XFxuXFx0ICAgICAgICBmb2xkLnNldEZvbGRMaW5lKHRoaXMpO1xcblxcdCAgICB9LCB0aGlzKTtcXG5cXHR9XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLnNoaWZ0Um93ID0gZnVuY3Rpb24oc2hpZnQpIHtcXG5cXHQgICAgICAgIHRoaXMuc3RhcnQucm93ICs9IHNoaWZ0O1xcblxcdCAgICAgICAgdGhpcy5lbmQucm93ICs9IHNoaWZ0O1xcblxcdCAgICAgICAgdGhpcy5mb2xkcy5mb3JFYWNoKGZ1bmN0aW9uKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICBmb2xkLnN0YXJ0LnJvdyArPSBzaGlmdDtcXG5cXHQgICAgICAgICAgICBmb2xkLmVuZC5yb3cgKz0gc2hpZnQ7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hZGRGb2xkID0gZnVuY3Rpb24oZm9sZCkge1xcblxcdCAgICAgICAgaWYgKGZvbGQuc2FtZVJvdykge1xcblxcdCAgICAgICAgICAgIGlmIChmb2xkLnN0YXJ0LnJvdyA8IHRoaXMuc3RhcnRSb3cgfHwgZm9sZC5lbmRSb3cgPiB0aGlzLmVuZFJvdykge1xcblxcdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkNhbid0IGFkZCBhIGZvbGQgdG8gdGhpcyBGb2xkTGluZSBhcyBpdCBoYXMgbm8gY29ubmVjdGlvblxcXCIpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB0aGlzLmZvbGRzLnB1c2goZm9sZCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIC1hLnJhbmdlLmNvbXBhcmVFbmQoYi5zdGFydC5yb3csIGIuc3RhcnQuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICB9KTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5yYW5nZS5jb21wYXJlRW5kKGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbikgPiAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZW5kLnJvdyA9IGZvbGQuZW5kLnJvdztcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gIGZvbGQuZW5kLmNvbHVtbjtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2UuY29tcGFyZVN0YXJ0KGZvbGQuZW5kLnJvdywgZm9sZC5lbmQuY29sdW1uKSA8IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5yb3cgPSBmb2xkLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5jb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGZvbGQuc3RhcnQucm93ID09IHRoaXMuZW5kLnJvdykge1xcblxcdCAgICAgICAgICAgIHRoaXMuZm9sZHMucHVzaChmb2xkKTtcXG5cXHQgICAgICAgICAgICB0aGlzLmVuZC5yb3cgPSBmb2xkLmVuZC5yb3c7XFxuXFx0ICAgICAgICAgICAgdGhpcy5lbmQuY29sdW1uID0gZm9sZC5lbmQuY29sdW1uO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChmb2xkLmVuZC5yb3cgPT0gdGhpcy5zdGFydC5yb3cpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmZvbGRzLnVuc2hpZnQoZm9sZCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zdGFydC5yb3cgPSBmb2xkLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICB0aGlzLnN0YXJ0LmNvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIlRyeWluZyB0byBhZGQgZm9sZCB0byBGb2xkUm93IHRoYXQgZG9lc24ndCBoYXZlIGEgbWF0Y2hpbmcgcm93XFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBmb2xkLmZvbGRMaW5lID0gdGhpcztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jb250YWluc1JvdyA9IGZ1bmN0aW9uKHJvdykge1xcblxcdCAgICAgICAgcmV0dXJuIHJvdyA+PSB0aGlzLnN0YXJ0LnJvdyAmJiByb3cgPD0gdGhpcy5lbmQucm93O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLndhbGsgPSBmdW5jdGlvbihjYWxsYmFjaywgZW5kUm93LCBlbmRDb2x1bW4pIHtcXG5cXHQgICAgICAgIHZhciBsYXN0RW5kID0gMCxcXG5cXHQgICAgICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHMsXFxuXFx0ICAgICAgICAgICAgZm9sZCxcXG5cXHQgICAgICAgICAgICBjbXAsIHN0b3AsIGlzTmV3Um93ID0gdHJ1ZTtcXG5cXG5cXHQgICAgICAgIGlmIChlbmRSb3cgPT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgIGVuZFJvdyA9IHRoaXMuZW5kLnJvdztcXG5cXHQgICAgICAgICAgICBlbmRDb2x1bW4gPSB0aGlzLmVuZC5jb2x1bW47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgZm9sZCA9IGZvbGRzW2ldO1xcblxcblxcdCAgICAgICAgICAgIGNtcCA9IGZvbGQucmFuZ2UuY29tcGFyZVN0YXJ0KGVuZFJvdywgZW5kQ29sdW1uKTtcXG5cXHQgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGVuZFJvdywgZW5kQ29sdW1uLCBsYXN0RW5kLCBpc05ld1Jvdyk7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbiwgbGFzdEVuZCwgaXNOZXdSb3cpO1xcblxcdCAgICAgICAgICAgIHN0b3AgPSAhc3RvcCAmJiBjYWxsYmFjayhmb2xkLnBsYWNlaG9sZGVyLCBmb2xkLnN0YXJ0LnJvdywgZm9sZC5zdGFydC5jb2x1bW4sIGxhc3RFbmQpO1xcblxcdCAgICAgICAgICAgIGlmIChzdG9wIHx8IGNtcCA9PT0gMCkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlzTmV3Um93ID0gIWZvbGQuc2FtZVJvdztcXG5cXHQgICAgICAgICAgICBsYXN0RW5kID0gZm9sZC5lbmQuY29sdW1uO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgY2FsbGJhY2sobnVsbCwgZW5kUm93LCBlbmRDb2x1bW4sIGxhc3RFbmQsIGlzTmV3Um93KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXROZXh0Rm9sZFRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHZhciBmb2xkLCBjbXA7XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9sZHMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBmb2xkID0gdGhpcy5mb2xkc1tpXTtcXG5cXHQgICAgICAgICAgICBjbXAgPSBmb2xkLnJhbmdlLmNvbXBhcmVFbmQocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvbGQ6IGZvbGQsXFxuXFx0ICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiYWZ0ZXJcXFwiXFxuXFx0ICAgICAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvbGQ6IGZvbGQsXFxuXFx0ICAgICAgICAgICAgICAgICAgICBraW5kOiBcXFwiaW5zaWRlXFxcIlxcblxcdCAgICAgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmFkZFJlbW92ZUNoYXJzID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIGxlbikge1xcblxcdCAgICAgICAgdmFyIHJldCA9IHRoaXMuZ2V0TmV4dEZvbGRUbyhyb3csIGNvbHVtbiksXFxuXFx0ICAgICAgICAgICAgZm9sZCwgZm9sZHM7XFxuXFx0ICAgICAgICBpZiAocmV0KSB7XFxuXFx0ICAgICAgICAgICAgZm9sZCA9IHJldC5mb2xkO1xcblxcdCAgICAgICAgICAgIGlmIChyZXQua2luZCA9PSBcXFwiaW5zaWRlXFxcIlxcblxcdCAgICAgICAgICAgICAgICAmJiBmb2xkLnN0YXJ0LmNvbHVtbiAhPSBjb2x1bW5cXG5cXHQgICAgICAgICAgICAgICAgJiYgZm9sZC5zdGFydC5yb3cgIT0gcm93KVxcblxcdCAgICAgICAgICAgIHtcXG5cXHQgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKHJvdywgY29sdW1uLCBmb2xkKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGZvbGQuc3RhcnQucm93ID09IHJvdykge1xcblxcdCAgICAgICAgICAgICAgICBmb2xkcyA9IHRoaXMuZm9sZHM7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBpID0gZm9sZHMuaW5kZXhPZihmb2xkKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQuY29sdW1uICs9IGxlbjtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBmb3IgKGk7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZm9sZCA9IGZvbGRzW2ldO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZm9sZC5zdGFydC5jb2x1bW4gKz0gbGVuO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmb2xkLnNhbWVSb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb2xkLmVuZC5jb2x1bW4gKz0gbGVuO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZW5kLmNvbHVtbiArPSBsZW47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNwbGl0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHZhciBwb3MgPSB0aGlzLmdldE5leHRGb2xkVG8ocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBpZiAoIXBvcyB8fCBwb3Mua2luZCA9PSBcXFwiaW5zaWRlXFxcIilcXG5cXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgIHZhciBmb2xkID0gcG9zLmZvbGQ7XFxuXFx0ICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmZvbGRzO1xcblxcdCAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy5mb2xkRGF0YTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIGkgPSBmb2xkcy5pbmRleE9mKGZvbGQpO1xcblxcdCAgICAgICAgdmFyIGZvbGRCZWZvcmUgPSBmb2xkc1tpIC0gMV07XFxuXFx0ICAgICAgICB0aGlzLmVuZC5yb3cgPSBmb2xkQmVmb3JlLmVuZC5yb3c7XFxuXFx0ICAgICAgICB0aGlzLmVuZC5jb2x1bW4gPSBmb2xkQmVmb3JlLmVuZC5jb2x1bW47XFxuXFx0ICAgICAgICBmb2xkcyA9IGZvbGRzLnNwbGljZShpLCBmb2xkcy5sZW5ndGggLSBpKTtcXG5cXG5cXHQgICAgICAgIHZhciBuZXdGb2xkTGluZSA9IG5ldyBGb2xkTGluZShmb2xkRGF0YSwgZm9sZHMpO1xcblxcdCAgICAgICAgZm9sZERhdGEuc3BsaWNlKGZvbGREYXRhLmluZGV4T2YodGhpcykgKyAxLCAwLCBuZXdGb2xkTGluZSk7XFxuXFx0ICAgICAgICByZXR1cm4gbmV3Rm9sZExpbmU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMubWVyZ2UgPSBmdW5jdGlvbihmb2xkTGluZU5leHQpIHtcXG5cXHQgICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lTmV4dC5mb2xkcztcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmFkZEZvbGQoZm9sZHNbaV0pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy5mb2xkRGF0YTtcXG5cXHQgICAgICAgIGZvbGREYXRhLnNwbGljZShmb2xkRGF0YS5pbmRleE9mKGZvbGRMaW5lTmV4dCksIDEpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgcmV0ID0gW3RoaXMucmFuZ2UudG9TdHJpbmcoKSArIFxcXCI6IFtcXFwiIF07XFxuXFxuXFx0ICAgICAgICB0aGlzLmZvbGRzLmZvckVhY2goZnVuY3Rpb24oZm9sZCkge1xcblxcdCAgICAgICAgICAgIHJldC5wdXNoKFxcXCIgIFxcXCIgKyBmb2xkLnRvU3RyaW5nKCkpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICByZXQucHVzaChcXFwiXVxcXCIpO1xcblxcdCAgICAgICAgcmV0dXJuIHJldC5qb2luKFxcXCJcXFxcblxcXCIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmlkeFRvUG9zaXRpb24gPSBmdW5jdGlvbihpZHgpIHtcXG5cXHQgICAgICAgIHZhciBsYXN0Rm9sZEVuZENvbHVtbiA9IDA7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9sZHMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZm9sZHNbaV07XFxuXFxuXFx0ICAgICAgICAgICAgaWR4IC09IGZvbGQuc3RhcnQuY29sdW1uIC0gbGFzdEZvbGRFbmRDb2x1bW47XFxuXFx0ICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvdzogZm9sZC5zdGFydC5yb3csXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGZvbGQuc3RhcnQuY29sdW1uICsgaWR4XFxuXFx0ICAgICAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIGlkeCAtPSBmb2xkLnBsYWNlaG9sZGVyLmxlbmd0aDtcXG5cXHQgICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZm9sZC5zdGFydDtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgbGFzdEZvbGRFbmRDb2x1bW4gPSBmb2xkLmVuZC5jb2x1bW47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgIHJvdzogdGhpcy5lbmQucm93LFxcblxcdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5lbmQuY29sdW1uICsgaWR4XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9O1xcblxcdH0pLmNhbGwoRm9sZExpbmUucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLkZvbGRMaW5lID0gRm9sZExpbmU7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL3JhbmdlX2xpc3RcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvcmFuZ2VcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHR2YXIgUmFuZ2UgPSBhY2VxdWlyZShcXFwiLi9yYW5nZVxcXCIpLlJhbmdlO1xcblxcdHZhciBjb21wYXJlUG9pbnRzID0gUmFuZ2UuY29tcGFyZVBvaW50cztcXG5cXG5cXHR2YXIgUmFuZ2VMaXN0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMucmFuZ2VzID0gW107XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuY29tcGFyZVBvaW50cyA9IGNvbXBhcmVQb2ludHM7XFxuXFxuXFx0ICAgIHRoaXMucG9pbnRJbmRleCA9IGZ1bmN0aW9uKHBvcywgZXhjbHVkZUVkZ2VzLCBzdGFydEluZGV4KSB7XFxuXFx0ICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmFuZ2VzO1xcblxcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xcblxcdCAgICAgICAgICAgIHZhciBjbXBFbmQgPSBjb21wYXJlUG9pbnRzKHBvcywgcmFuZ2UuZW5kKTtcXG5cXHQgICAgICAgICAgICBpZiAoY21wRW5kID4gMClcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgdmFyIGNtcFN0YXJ0ID0gY29tcGFyZVBvaW50cyhwb3MsIHJhbmdlLnN0YXJ0KTtcXG5cXHQgICAgICAgICAgICBpZiAoY21wRW5kID09PSAwKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZUVkZ2VzICYmIGNtcFN0YXJ0ICE9PSAwID8gLWktMiA6IGk7XFxuXFx0ICAgICAgICAgICAgaWYgKGNtcFN0YXJ0ID4gMCB8fCAoY21wU3RhcnQgPT09IDAgJiYgIWV4Y2x1ZGVFZGdlcykpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBpO1xcblxcblxcdCAgICAgICAgICAgIHJldHVybiAtaS0xO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIC1pIC0gMTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hZGQgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgdmFyIGV4Y2x1ZGVFZGdlcyA9ICFyYW5nZS5pc0VtcHR5KCk7XFxuXFx0ICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMucG9pbnRJbmRleChyYW5nZS5zdGFydCwgZXhjbHVkZUVkZ2VzKTtcXG5cXHQgICAgICAgIGlmIChzdGFydEluZGV4IDwgMClcXG5cXHQgICAgICAgICAgICBzdGFydEluZGV4ID0gLXN0YXJ0SW5kZXggLSAxO1xcblxcblxcdCAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHJhbmdlLmVuZCwgZXhjbHVkZUVkZ2VzLCBzdGFydEluZGV4KTtcXG5cXG5cXHQgICAgICAgIGlmIChlbmRJbmRleCA8IDApXFxuXFx0ICAgICAgICAgICAgZW5kSW5kZXggPSAtZW5kSW5kZXggLSAxO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIGVuZEluZGV4Kys7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc3BsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4IC0gc3RhcnRJbmRleCwgcmFuZ2UpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmFkZExpc3QgPSBmdW5jdGlvbihsaXN0KSB7XFxuXFx0ICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07ICkge1xcblxcdCAgICAgICAgICAgIHJlbW92ZWQucHVzaC5jYWxsKHJlbW92ZWQsIHRoaXMuYWRkKGxpc3RbaV0pKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiByZW1vdmVkO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnN1YnN0cmFjdFBvaW50ID0gZnVuY3Rpb24ocG9zKSB7XFxuXFx0ICAgICAgICB2YXIgaSA9IHRoaXMucG9pbnRJbmRleChwb3MpO1xcblxcblxcdCAgICAgICAgaWYgKGkgPj0gMClcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc3BsaWNlKGksIDEpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1lcmdlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xcblxcdCAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnJhbmdlcztcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgbGlzdCA9IGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVQb2ludHMoYS5zdGFydCwgYi5zdGFydCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIG5leHQgPSBsaXN0WzBdLCByYW5nZTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIHJhbmdlID0gbmV4dDtcXG5cXHQgICAgICAgICAgICBuZXh0ID0gbGlzdFtpXTtcXG5cXHQgICAgICAgICAgICB2YXIgY21wID0gY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuc3RhcnQpO1xcblxcdCAgICAgICAgICAgIGlmIChjbXAgPCAwKVxcblxcdCAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoY21wID09IDAgJiYgIXJhbmdlLmlzRW1wdHkoKSAmJiAhbmV4dC5pc0VtcHR5KCkpXFxuXFx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcblxcblxcdCAgICAgICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5lbmQpIDwgMCkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5lbmQucm93ID0gbmV4dC5lbmQucm93O1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gbmV4dC5lbmQuY29sdW1uO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcXG5cXHQgICAgICAgICAgICByZW1vdmVkLnB1c2gobmV4dCk7XFxuXFx0ICAgICAgICAgICAgbmV4dCA9IHJhbmdlO1xcblxcdCAgICAgICAgICAgIGktLTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdGhpcy5yYW5nZXMgPSBsaXN0O1xcblxcblxcdCAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuY29udGFpbnMgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRJbmRleCh7cm93OiByb3csIGNvbHVtbjogY29sdW1ufSkgPj0gMDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jb250YWluc1BvaW50ID0gZnVuY3Rpb24ocG9zKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5wb2ludEluZGV4KHBvcykgPj0gMDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yYW5nZUF0UG9pbnQgPSBmdW5jdGlvbihwb3MpIHtcXG5cXHQgICAgICAgIHZhciBpID0gdGhpcy5wb2ludEluZGV4KHBvcyk7XFxuXFx0ICAgICAgICBpZiAoaSA+PSAwKVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpXTtcXG5cXHQgICAgfTtcXG5cXG5cXG5cXHQgICAgdGhpcy5jbGlwUm93cyA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBlbmRSb3cpIHtcXG5cXHQgICAgICAgIHZhciBsaXN0ID0gdGhpcy5yYW5nZXM7XFxuXFx0ICAgICAgICBpZiAobGlzdFswXS5zdGFydC5yb3cgPiBlbmRSb3cgfHwgbGlzdFtsaXN0Lmxlbmd0aCAtIDFdLnN0YXJ0LnJvdyA8IHN0YXJ0Um93KVxcblxcdCAgICAgICAgICAgIHJldHVybiBbXTtcXG5cXG5cXHQgICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHtyb3c6IHN0YXJ0Um93LCBjb2x1bW46IDB9KTtcXG5cXHQgICAgICAgIGlmIChzdGFydEluZGV4IDwgMClcXG5cXHQgICAgICAgICAgICBzdGFydEluZGV4ID0gLXN0YXJ0SW5kZXggLSAxO1xcblxcdCAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5wb2ludEluZGV4KHtyb3c6IGVuZFJvdywgY29sdW1uOiAwfSwgc3RhcnRJbmRleCk7XFxuXFx0ICAgICAgICBpZiAoZW5kSW5kZXggPCAwKVxcblxcdCAgICAgICAgICAgIGVuZEluZGV4ID0gLWVuZEluZGV4IC0gMTtcXG5cXG5cXHQgICAgICAgIHZhciBjbGlwcGVkID0gW107XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcXG5cXHQgICAgICAgICAgICBjbGlwcGVkLnB1c2gobGlzdFtpXSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gY2xpcHBlZDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZW1vdmVBbGwgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5zcGxpY2UoMCwgdGhpcy5yYW5nZXMubGVuZ3RoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hdHRhY2ggPSBmdW5jdGlvbihzZXNzaW9uKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZXNzaW9uKVxcblxcdCAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xcblxcdCAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMuJG9uQ2hhbmdlLmJpbmQodGhpcyk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ub24oJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG9uQ2hhbmdlID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGNoYW5nZVJhbmdlID0gZS5kYXRhLnJhbmdlO1xcblxcdCAgICAgICAgaWYgKGUuZGF0YS5hY3Rpb25bMF0gPT0gXFxcImlcXFwiKXtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSBjaGFuZ2VSYW5nZS5zdGFydDtcXG5cXHQgICAgICAgICAgICB2YXIgZW5kID0gY2hhbmdlUmFuZ2UuZW5kO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgZW5kID0gY2hhbmdlUmFuZ2Uuc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2hhbmdlUmFuZ2UuZW5kO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIHN0YXJ0Um93ID0gc3RhcnQucm93O1xcblxcdCAgICAgICAgdmFyIGVuZFJvdyA9IGVuZC5yb3c7XFxuXFx0ICAgICAgICB2YXIgbGluZURpZiA9IGVuZFJvdyAtIHN0YXJ0Um93O1xcblxcblxcdCAgICAgICAgdmFyIGNvbERpZmYgPSAtc3RhcnQuY29sdW1uICsgZW5kLmNvbHVtbjtcXG5cXHQgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcztcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xcblxcdCAgICAgICAgICAgIHZhciByID0gcmFuZ2VzW2ldO1xcblxcdCAgICAgICAgICAgIGlmIChyLmVuZC5yb3cgPCBzdGFydFJvdylcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgaWYgKHIuc3RhcnQucm93ID4gc3RhcnRSb3cpXFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgICAgICAgIGlmIChyLnN0YXJ0LnJvdyA9PSBzdGFydFJvdyAmJiByLnN0YXJ0LmNvbHVtbiA+PSBzdGFydC5jb2x1bW4gKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0LmNvbHVtbiA9PSBzdGFydC5jb2x1bW4gJiYgdGhpcy4kaW5zZXJ0UmlnaHQpIHtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHIuc3RhcnQuY29sdW1uICs9IGNvbERpZmY7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByLnN0YXJ0LnJvdyArPSBsaW5lRGlmO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmIChyLmVuZC5yb3cgPT0gc3RhcnRSb3cgJiYgci5lbmQuY29sdW1uID49IHN0YXJ0LmNvbHVtbikge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoci5lbmQuY29sdW1uID09IHN0YXJ0LmNvbHVtbiAmJiB0aGlzLiRpbnNlcnRSaWdodCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHIuZW5kLmNvbHVtbiA9PSBzdGFydC5jb2x1bW4gJiYgY29sRGlmZiA+IDAgJiYgaSA8IG4gLSAxKSB7ICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHIuZW5kLmNvbHVtbiA+IHIuc3RhcnQuY29sdW1uICYmIHIuZW5kLmNvbHVtbiA9PSByYW5nZXNbaSsxXS5zdGFydC5jb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgci5lbmQuY29sdW1uIC09IGNvbERpZmY7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgci5lbmQuY29sdW1uICs9IGNvbERpZmY7XFxuXFx0ICAgICAgICAgICAgICAgIHIuZW5kLnJvdyArPSBsaW5lRGlmO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChsaW5lRGlmICE9IDAgJiYgaSA8IG4pIHtcXG5cXHQgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgciA9IHJhbmdlc1tpXTtcXG5cXHQgICAgICAgICAgICAgICAgci5zdGFydC5yb3cgKz0gbGluZURpZjtcXG5cXHQgICAgICAgICAgICAgICAgci5lbmQucm93ICs9IGxpbmVEaWY7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoUmFuZ2VMaXN0LnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5SYW5nZUxpc3QgPSBSYW5nZUxpc3Q7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3JhbmdlXFxcIixcXFwiYWNlL3JhbmdlX2xpc3RcXFwiLFxcXCJhY2UvbGliL29vcFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBSYW5nZSA9IGFjZXF1aXJlKFxcXCIuLi9yYW5nZVxcXCIpLlJhbmdlO1xcblxcdHZhciBSYW5nZUxpc3QgPSBhY2VxdWlyZShcXFwiLi4vcmFuZ2VfbGlzdFxcXCIpLlJhbmdlTGlzdDtcXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9vb3BcXFwiKVxcblxcdHZhciBGb2xkID0gZXhwb3J0cy5Gb2xkID0gZnVuY3Rpb24ocmFuZ2UsIHBsYWNlaG9sZGVyKSB7XFxuXFx0ICAgIHRoaXMuZm9sZExpbmUgPSBudWxsO1xcblxcdCAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XFxuXFx0ICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcXG5cXHQgICAgdGhpcy5zdGFydCA9IHJhbmdlLnN0YXJ0O1xcblxcdCAgICB0aGlzLmVuZCA9IHJhbmdlLmVuZDtcXG5cXG5cXHQgICAgdGhpcy5zYW1lUm93ID0gcmFuZ2Uuc3RhcnQucm93ID09IHJhbmdlLmVuZC5yb3c7XFxuXFx0ICAgIHRoaXMuc3ViRm9sZHMgPSB0aGlzLnJhbmdlcyA9IFtdO1xcblxcdH07XFxuXFxuXFx0b29wLmluaGVyaXRzKEZvbGQsIFJhbmdlTGlzdCk7XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gJ1xcXCInICsgdGhpcy5wbGFjZWhvbGRlciArICdcXFwiICcgKyB0aGlzLnJhbmdlLnRvU3RyaW5nKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0Rm9sZExpbmUgPSBmdW5jdGlvbihmb2xkTGluZSkge1xcblxcdCAgICAgICAgdGhpcy5mb2xkTGluZSA9IGZvbGRMaW5lO1xcblxcdCAgICAgICAgdGhpcy5zdWJGb2xkcy5mb3JFYWNoKGZ1bmN0aW9uKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICBmb2xkLnNldEZvbGRMaW5lKGZvbGRMaW5lKTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlLmNsb25lKCk7XFxuXFx0ICAgICAgICB2YXIgZm9sZCA9IG5ldyBGb2xkKHJhbmdlLCB0aGlzLnBsYWNlaG9sZGVyKTtcXG5cXHQgICAgICAgIHRoaXMuc3ViRm9sZHMuZm9yRWFjaChmdW5jdGlvbihzdWJGb2xkKSB7XFxuXFx0ICAgICAgICAgICAgZm9sZC5zdWJGb2xkcy5wdXNoKHN1YkZvbGQuY2xvbmUoKSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIGZvbGQuY29sbGFwc2VDaGlsZHJlbiA9IHRoaXMuY29sbGFwc2VDaGlsZHJlbjtcXG5cXHQgICAgICAgIHJldHVybiBmb2xkO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmFkZFN1YkZvbGQgPSBmdW5jdGlvbihmb2xkKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5yYW5nZS5pc0VxdWFsKGZvbGQpKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIGlmICghdGhpcy5yYW5nZS5jb250YWluc1JhbmdlKGZvbGQpKVxcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiQSBmb2xkIGNhbid0IGludGVyc2VjdCBhbHJlYWR5IGV4aXN0aW5nIGZvbGRcXFwiICsgZm9sZC5yYW5nZSArIHRoaXMucmFuZ2UpO1xcblxcdCAgICAgICAgY29uc3VtZVJhbmdlKGZvbGQsIHRoaXMuc3RhcnQpO1xcblxcblxcdCAgICAgICAgdmFyIHJvdyA9IGZvbGQuc3RhcnQucm93LCBjb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBjbXAgPSAtMTsgaSA8IHRoaXMuc3ViRm9sZHMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBjbXAgPSB0aGlzLnN1YkZvbGRzW2ldLnJhbmdlLmNvbXBhcmUocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgICAgIGlmIChjbXAgIT0gMSlcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB2YXIgYWZ0ZXJTdGFydCA9IHRoaXMuc3ViRm9sZHNbaV07XFxuXFxuXFx0ICAgICAgICBpZiAoY21wID09IDApXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGFmdGVyU3RhcnQuYWRkU3ViRm9sZChmb2xkKTtcXG5cXHQgICAgICAgIHZhciByb3cgPSBmb2xkLnJhbmdlLmVuZC5yb3csIGNvbHVtbiA9IGZvbGQucmFuZ2UuZW5kLmNvbHVtbjtcXG5cXHQgICAgICAgIGZvciAodmFyIGogPSBpLCBjbXAgPSAtMTsgaiA8IHRoaXMuc3ViRm9sZHMubGVuZ3RoOyBqKyspIHtcXG5cXHQgICAgICAgICAgICBjbXAgPSB0aGlzLnN1YkZvbGRzW2pdLnJhbmdlLmNvbXBhcmUocm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgICAgIGlmIChjbXAgIT0gMSlcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB2YXIgYWZ0ZXJFbmQgPSB0aGlzLnN1YkZvbGRzW2pdO1xcblxcblxcdCAgICAgICAgaWYgKGNtcCA9PSAwKVxcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiQSBmb2xkIGNhbid0IGludGVyc2VjdCBhbHJlYWR5IGV4aXN0aW5nIGZvbGRcXFwiICsgZm9sZC5yYW5nZSArIHRoaXMucmFuZ2UpO1xcblxcblxcdCAgICAgICAgdmFyIGNvbnN1bWVkRm9sZHMgPSB0aGlzLnN1YkZvbGRzLnNwbGljZShpLCBqIC0gaSwgZm9sZCk7XFxuXFx0ICAgICAgICBmb2xkLnNldEZvbGRMaW5lKHRoaXMuZm9sZExpbmUpO1xcblxcblxcdCAgICAgICAgcmV0dXJuIGZvbGQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnJlc3RvcmVSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XFxuXFx0ICAgICAgICByZXR1cm4gcmVzdG9yZVJhbmdlKHJhbmdlLCB0aGlzLnN0YXJ0KTtcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKEZvbGQucHJvdG90eXBlKTtcXG5cXG5cXHRmdW5jdGlvbiBjb25zdW1lUG9pbnQocG9pbnQsIGFuY2hvcikge1xcblxcdCAgICBwb2ludC5yb3cgLT0gYW5jaG9yLnJvdztcXG5cXHQgICAgaWYgKHBvaW50LnJvdyA9PSAwKVxcblxcdCAgICAgICAgcG9pbnQuY29sdW1uIC09IGFuY2hvci5jb2x1bW47XFxuXFx0fVxcblxcdGZ1bmN0aW9uIGNvbnN1bWVSYW5nZShyYW5nZSwgYW5jaG9yKSB7XFxuXFx0ICAgIGNvbnN1bWVQb2ludChyYW5nZS5zdGFydCwgYW5jaG9yKTtcXG5cXHQgICAgY29uc3VtZVBvaW50KHJhbmdlLmVuZCwgYW5jaG9yKTtcXG5cXHR9XFxuXFx0ZnVuY3Rpb24gcmVzdG9yZVBvaW50KHBvaW50LCBhbmNob3IpIHtcXG5cXHQgICAgaWYgKHBvaW50LnJvdyA9PSAwKVxcblxcdCAgICAgICAgcG9pbnQuY29sdW1uICs9IGFuY2hvci5jb2x1bW47XFxuXFx0ICAgIHBvaW50LnJvdyArPSBhbmNob3Iucm93O1xcblxcdH1cXG5cXHRmdW5jdGlvbiByZXN0b3JlUmFuZ2UocmFuZ2UsIGFuY2hvcikge1xcblxcdCAgICByZXN0b3JlUG9pbnQocmFuZ2Uuc3RhcnQsIGFuY2hvcik7XFxuXFx0ICAgIHJlc3RvcmVQb2ludChyYW5nZS5lbmQsIGFuY2hvcik7XFxuXFx0fVxcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9lZGl0X3Nlc3Npb24vZm9sZGluZ1xcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9yYW5nZVxcXCIsXFxcImFjZS9lZGl0X3Nlc3Npb24vZm9sZF9saW5lXFxcIixcXFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkXFxcIixcXFwiYWNlL3Rva2VuX2l0ZXJhdG9yXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4uL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFx0dmFyIEZvbGRMaW5lID0gYWNlcXVpcmUoXFxcIi4vZm9sZF9saW5lXFxcIikuRm9sZExpbmU7XFxuXFx0dmFyIEZvbGQgPSBhY2VxdWlyZShcXFwiLi9mb2xkXFxcIikuRm9sZDtcXG5cXHR2YXIgVG9rZW5JdGVyYXRvciA9IGFjZXF1aXJlKFxcXCIuLi90b2tlbl9pdGVyYXRvclxcXCIpLlRva2VuSXRlcmF0b3I7XFxuXFxuXFx0ZnVuY3Rpb24gRm9sZGluZygpIHtcXG5cXHQgICAgdGhpcy5nZXRGb2xkQXQgPSBmdW5jdGlvbihyb3csIGNvbHVtbiwgc2lkZSkge1xcblxcdCAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3cpO1xcblxcdCAgICAgICAgaWYgKCFmb2xkTGluZSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG5cXG5cXHQgICAgICAgIHZhciBmb2xkcyA9IGZvbGRMaW5lLmZvbGRzO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIHZhciBmb2xkID0gZm9sZHNbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKGZvbGQucmFuZ2UuY29udGFpbnMocm93LCBjb2x1bW4pKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzaWRlID09IDEgJiYgZm9sZC5yYW5nZS5pc0VuZChyb3csIGNvbHVtbikpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gLTEgJiYgZm9sZC5yYW5nZS5pc1N0YXJ0KHJvdywgY29sdW1uKSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvbGQ7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEZvbGRzSW5SYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XFxuXFx0ICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XFxuXFx0ICAgICAgICB2YXIgZm9sZExpbmVzID0gdGhpcy4kZm9sZERhdGE7XFxuXFx0ICAgICAgICB2YXIgZm91bmRGb2xkcyA9IFtdO1xcblxcblxcdCAgICAgICAgc3RhcnQuY29sdW1uICs9IDE7XFxuXFx0ICAgICAgICBlbmQuY29sdW1uIC09IDE7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGRMaW5lcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIHZhciBjbXAgPSBmb2xkTGluZXNbaV0ucmFuZ2UuY29tcGFyZVJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgICAgICBpZiAoY21wID09IDIpIHtcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA9PSAtMikge1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmVzW2ldLmZvbGRzO1xcblxcdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9sZHMubGVuZ3RoOyBqKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGZvbGQgPSBmb2xkc1tqXTtcXG5cXHQgICAgICAgICAgICAgICAgY21wID0gZm9sZC5yYW5nZS5jb21wYXJlUmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoY21wID09IC0yKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT0gMikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgICAgICAgICBpZiAoY21wID09IDQyKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBmb3VuZEZvbGRzLnB1c2goZm9sZCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgc3RhcnQuY29sdW1uIC09IDE7XFxuXFx0ICAgICAgICBlbmQuY29sdW1uICs9IDE7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gZm91bmRGb2xkcztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRGb2xkc0luUmFuZ2VMaXN0ID0gZnVuY3Rpb24ocmFuZ2VzKSB7XFxuXFx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZXMpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZvbGRzID0gW107XFxuXFx0ICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24ocmFuZ2UpIHtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZHMgPSBmb2xkcy5jb25jYXQodGhpcy5nZXRGb2xkc0luUmFuZ2UocmFuZ2UpKTtcXG5cXHQgICAgICAgICAgICB9LCB0aGlzKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UocmFuZ2VzKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBmb2xkcztcXG5cXHQgICAgfVxcblxcdCAgICB0aGlzLmdldEFsbEZvbGRzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgZm9sZHMgPSBbXTtcXG5cXHQgICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkTGluZXMubGVuZ3RoOyBpKyspXFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb2xkTGluZXNbaV0uZm9sZHMubGVuZ3RoOyBqKyspXFxuXFx0ICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goZm9sZExpbmVzW2ldLmZvbGRzW2pdKTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBmb2xkcztcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRGb2xkU3RyaW5nQXQgPSBmdW5jdGlvbihyb3csIGNvbHVtbiwgdHJpbSwgZm9sZExpbmUpIHtcXG5cXHQgICAgICAgIGZvbGRMaW5lID0gZm9sZExpbmUgfHwgdGhpcy5nZXRGb2xkTGluZShyb3cpO1xcblxcdCAgICAgICAgaWYgKCFmb2xkTGluZSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG5cXG5cXHQgICAgICAgIHZhciBsYXN0Rm9sZCA9IHtcXG5cXHQgICAgICAgICAgICBlbmQ6IHsgY29sdW1uOiAwIH1cXG5cXHQgICAgICAgIH07XFxuXFx0ICAgICAgICB2YXIgc3RyLCBmb2xkO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkTGluZS5mb2xkcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIGZvbGQgPSBmb2xkTGluZS5mb2xkc1tpXTtcXG5cXHQgICAgICAgICAgICB2YXIgY21wID0gZm9sZC5yYW5nZS5jb21wYXJlRW5kKHJvdywgY29sdW1uKTtcXG5cXHQgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHN0ciA9IHRoaXNcXG5cXHQgICAgICAgICAgICAgICAgICAgIC5nZXRMaW5lKGZvbGQuc3RhcnQucm93KVxcblxcdCAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZyhsYXN0Rm9sZC5lbmQuY29sdW1uLCBmb2xkLnN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGxhc3RGb2xkID0gZm9sZDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICghc3RyKVxcblxcdCAgICAgICAgICAgIHN0ciA9IHRoaXMuZ2V0TGluZShmb2xkLnN0YXJ0LnJvdykuc3Vic3RyaW5nKGxhc3RGb2xkLmVuZC5jb2x1bW4pO1xcblxcblxcdCAgICAgICAgaWYgKHRyaW0gPT0gLTEpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgY29sdW1uIC0gbGFzdEZvbGQuZW5kLmNvbHVtbik7XFxuXFx0ICAgICAgICBlbHNlIGlmICh0cmltID09IDEpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoY29sdW1uIC0gbGFzdEZvbGQuZW5kLmNvbHVtbik7XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHN0cjtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRGb2xkTGluZSA9IGZ1bmN0aW9uKGRvY1Jvdywgc3RhcnRGb2xkTGluZSkge1xcblxcdCAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGE7XFxuXFx0ICAgICAgICB2YXIgaSA9IDA7XFxuXFx0ICAgICAgICBpZiAoc3RhcnRGb2xkTGluZSlcXG5cXHQgICAgICAgICAgICBpID0gZm9sZERhdGEuaW5kZXhPZihzdGFydEZvbGRMaW5lKTtcXG5cXHQgICAgICAgIGlmIChpID09IC0xKVxcblxcdCAgICAgICAgICAgIGkgPSAwO1xcblxcdCAgICAgICAgZm9yIChpOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkRGF0YVtpXTtcXG5cXHQgICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93IDw9IGRvY1JvdyAmJiBmb2xkTGluZS5lbmQucm93ID49IGRvY1Jvdykge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZm9sZExpbmU7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChmb2xkTGluZS5lbmQucm93ID4gZG9jUm93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldE5leHRGb2xkTGluZSA9IGZ1bmN0aW9uKGRvY1Jvdywgc3RhcnRGb2xkTGluZSkge1xcblxcdCAgICAgICAgdmFyIGZvbGREYXRhID0gdGhpcy4kZm9sZERhdGE7XFxuXFx0ICAgICAgICB2YXIgaSA9IDA7XFxuXFx0ICAgICAgICBpZiAoc3RhcnRGb2xkTGluZSlcXG5cXHQgICAgICAgICAgICBpID0gZm9sZERhdGEuaW5kZXhPZihzdGFydEZvbGRMaW5lKTtcXG5cXHQgICAgICAgIGlmIChpID09IC0xKVxcblxcdCAgICAgICAgICAgIGkgPSAwO1xcblxcdCAgICAgICAgZm9yIChpOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkRGF0YVtpXTtcXG5cXHQgICAgICAgICAgICBpZiAoZm9sZExpbmUuZW5kLnJvdyA+PSBkb2NSb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvbGRMaW5lO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldEZvbGRlZFJvd0NvdW50ID0gZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcXG5cXHQgICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhLCByb3dDb3VudCA9IGxhc3QtZmlyc3QrMTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSBmb2xkRGF0YVtpXSxcXG5cXHQgICAgICAgICAgICAgICAgZW5kID0gZm9sZExpbmUuZW5kLnJvdyxcXG5cXHQgICAgICAgICAgICAgICAgc3RhcnQgPSBmb2xkTGluZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICAgICAgaWYgKGVuZCA+PSBsYXN0KSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmKHN0YXJ0IDwgbGFzdCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnQgPj0gZmlyc3QpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgLT0gbGFzdC1zdGFydDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByb3dDb3VudCA9IDA7Ly9pbiBvbmUgZm9sZFxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZihlbmQgPj0gZmlyc3Qpe1xcblxcdCAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gZmlyc3QpIC8vZm9sZCBpbnNpZGUgcmFuZ2VcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvd0NvdW50IC09ICBlbmQtc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvd0NvdW50IC09ICBlbmQtZmlyc3QrMTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gcm93Q291bnQ7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGFkZEZvbGRMaW5lID0gZnVuY3Rpb24oZm9sZExpbmUpIHtcXG5cXHQgICAgICAgIHRoaXMuJGZvbGREYXRhLnB1c2goZm9sZExpbmUpO1xcblxcdCAgICAgICAgdGhpcy4kZm9sZERhdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQucm93IC0gYi5zdGFydC5yb3c7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHJldHVybiBmb2xkTGluZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5hZGRGb2xkID0gZnVuY3Rpb24ocGxhY2Vob2xkZXIsIHJhbmdlKSB7XFxuXFx0ICAgICAgICB2YXIgZm9sZERhdGEgPSB0aGlzLiRmb2xkRGF0YTtcXG5cXHQgICAgICAgIHZhciBhZGRlZCA9IGZhbHNlO1xcblxcdCAgICAgICAgdmFyIGZvbGQ7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChwbGFjZWhvbGRlciBpbnN0YW5jZW9mIEZvbGQpXFxuXFx0ICAgICAgICAgICAgZm9sZCA9IHBsYWNlaG9sZGVyO1xcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgICAgZm9sZCA9IG5ldyBGb2xkKHJhbmdlLCBwbGFjZWhvbGRlcik7XFxuXFx0ICAgICAgICAgICAgZm9sZC5jb2xsYXBzZUNoaWxkcmVuID0gcmFuZ2UuY29sbGFwc2VDaGlsZHJlbjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuJGNsaXBSYW5nZVRvRG9jdW1lbnQoZm9sZC5yYW5nZSk7XFxuXFxuXFx0ICAgICAgICB2YXIgc3RhcnRSb3cgPSBmb2xkLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIHZhciBzdGFydENvbHVtbiA9IGZvbGQuc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgdmFyIGVuZFJvdyA9IGZvbGQuZW5kLnJvdztcXG5cXHQgICAgICAgIHZhciBlbmRDb2x1bW4gPSBmb2xkLmVuZC5jb2x1bW47XFxuXFx0ICAgICAgICBpZiAoIShzdGFydFJvdyA8IGVuZFJvdyB8fCBcXG5cXHQgICAgICAgICAgICBzdGFydFJvdyA9PSBlbmRSb3cgJiYgc3RhcnRDb2x1bW4gPD0gZW5kQ29sdW1uIC0gMikpXFxuXFx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGUgcmFuZ2UgaGFzIHRvIGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyB3aWR0aFxcXCIpO1xcblxcblxcdCAgICAgICAgdmFyIHN0YXJ0Rm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHN0YXJ0Um93LCBzdGFydENvbHVtbiwgMSk7XFxuXFx0ICAgICAgICB2YXIgZW5kRm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KGVuZFJvdywgZW5kQ29sdW1uLCAtMSk7XFxuXFx0ICAgICAgICBpZiAoc3RhcnRGb2xkICYmIGVuZEZvbGQgPT0gc3RhcnRGb2xkKVxcblxcdCAgICAgICAgICAgIHJldHVybiBzdGFydEZvbGQuYWRkU3ViRm9sZChmb2xkKTtcXG5cXG5cXHQgICAgICAgIGlmIChzdGFydEZvbGQgJiYgIXN0YXJ0Rm9sZC5yYW5nZS5pc1N0YXJ0KHN0YXJ0Um93LCBzdGFydENvbHVtbikpXFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKHN0YXJ0Rm9sZCk7XFxuXFxuXFx0ICAgICAgICBpZiAoZW5kRm9sZCAmJiAhZW5kRm9sZC5yYW5nZS5pc0VuZChlbmRSb3csIGVuZENvbHVtbikpXFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkKGVuZEZvbGQpO1xcblxcdCAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZm9sZC5yYW5nZSk7XFxuXFx0ICAgICAgICBpZiAoZm9sZHMubGVuZ3RoID4gMCkge1xcblxcdCAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZHMoZm9sZHMpO1xcblxcdCAgICAgICAgICAgIGZvbGRzLmZvckVhY2goZnVuY3Rpb24oc3ViRm9sZCkge1xcblxcdCAgICAgICAgICAgICAgICBmb2xkLmFkZFN1YkZvbGQoc3ViRm9sZCk7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbGREYXRhLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZERhdGFbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKGVuZFJvdyA9PSBmb2xkTGluZS5zdGFydC5yb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkRm9sZChmb2xkKTtcXG5cXHQgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0Um93ID09IGZvbGRMaW5lLmVuZC5yb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZExpbmUuYWRkRm9sZChmb2xkKTtcXG5cXHQgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIWZvbGQuc2FtZVJvdykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lTmV4dCA9IGZvbGREYXRhW2kgKyAxXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZU5leHQgJiYgZm9sZExpbmVOZXh0LnN0YXJ0LnJvdyA9PSBlbmRSb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5tZXJnZShmb2xkTGluZU5leHQpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kUm93IDw9IGZvbGRMaW5lLnN0YXJ0LnJvdykge1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoIWFkZGVkKVxcblxcdCAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy4kYWRkRm9sZExpbmUobmV3IEZvbGRMaW5lKHRoaXMuJGZvbGREYXRhLCBmb2xkKSk7XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoZm9sZExpbmUuc3RhcnQucm93LCBmb2xkTGluZS5zdGFydC5yb3cpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd0xlbmd0aENhY2hlKGZvbGRMaW5lLnN0YXJ0LnJvdywgZm9sZExpbmUuc3RhcnQucm93KTtcXG5cXHQgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcXG5cXHQgICAgICAgIHRoaXMuX2VtaXQoXFxcImNoYW5nZUZvbGRcXFwiLCB7IGRhdGE6IGZvbGQsIGFjdGlvbjogXFxcImFkZFxcXCIgfSk7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gZm9sZDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hZGRGb2xkcyA9IGZ1bmN0aW9uKGZvbGRzKSB7XFxuXFx0ICAgICAgICBmb2xkcy5mb3JFYWNoKGZ1bmN0aW9uKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmFkZEZvbGQoZm9sZCk7XFxuXFx0ICAgICAgICB9LCB0aGlzKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZW1vdmVGb2xkID0gZnVuY3Rpb24oZm9sZCkge1xcblxcdCAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZC5mb2xkTGluZTtcXG5cXHQgICAgICAgIHZhciBzdGFydFJvdyA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIHZhciBlbmRSb3cgPSBmb2xkTGluZS5lbmQucm93O1xcblxcblxcdCAgICAgICAgdmFyIGZvbGRMaW5lcyA9IHRoaXMuJGZvbGREYXRhO1xcblxcdCAgICAgICAgdmFyIGZvbGRzID0gZm9sZExpbmUuZm9sZHM7XFxuXFx0ICAgICAgICBpZiAoZm9sZHMubGVuZ3RoID09IDEpIHtcXG5cXHQgICAgICAgICAgICBmb2xkTGluZXMuc3BsaWNlKGZvbGRMaW5lcy5pbmRleE9mKGZvbGRMaW5lKSwgMSk7XFxuXFx0ICAgICAgICB9IGVsc2VcXG5cXHQgICAgICAgIGlmIChmb2xkTGluZS5yYW5nZS5pc0VuZChmb2xkLmVuZC5yb3csIGZvbGQuZW5kLmNvbHVtbikpIHtcXG5cXHQgICAgICAgICAgICBmb2xkcy5wb3AoKTtcXG5cXHQgICAgICAgICAgICBmb2xkTGluZS5lbmQucm93ID0gZm9sZHNbZm9sZHMubGVuZ3RoIC0gMV0uZW5kLnJvdztcXG5cXHQgICAgICAgICAgICBmb2xkTGluZS5lbmQuY29sdW1uID0gZm9sZHNbZm9sZHMubGVuZ3RoIC0gMV0uZW5kLmNvbHVtbjtcXG5cXHQgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgaWYgKGZvbGRMaW5lLnJhbmdlLmlzU3RhcnQoZm9sZC5zdGFydC5yb3csIGZvbGQuc3RhcnQuY29sdW1uKSkge1xcblxcdCAgICAgICAgICAgIGZvbGRzLnNoaWZ0KCk7XFxuXFx0ICAgICAgICAgICAgZm9sZExpbmUuc3RhcnQucm93ID0gZm9sZHNbMF0uc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgIGZvbGRMaW5lLnN0YXJ0LmNvbHVtbiA9IGZvbGRzWzBdLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgaWYgKGZvbGQuc2FtZVJvdykge1xcblxcdCAgICAgICAgICAgIGZvbGRzLnNwbGljZShmb2xkcy5pbmRleE9mKGZvbGQpLCAxKTtcXG5cXHQgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAge1xcblxcdCAgICAgICAgICAgIHZhciBuZXdGb2xkTGluZSA9IGZvbGRMaW5lLnNwbGl0KGZvbGQuc3RhcnQucm93LCBmb2xkLnN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgZm9sZHMgPSBuZXdGb2xkTGluZS5mb2xkcztcXG5cXHQgICAgICAgICAgICBmb2xkcy5zaGlmdCgpO1xcblxcdCAgICAgICAgICAgIG5ld0ZvbGRMaW5lLnN0YXJ0LnJvdyA9IGZvbGRzWzBdLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICBuZXdGb2xkTGluZS5zdGFydC5jb2x1bW4gPSBmb2xkc1swXS5zdGFydC5jb2x1bW47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJHVwZGF0aW5nKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YShzdGFydFJvdywgZW5kUm93KTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd0xlbmd0aENhY2hlKHN0YXJ0Um93LCBlbmRSb3cpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xcblxcdCAgICAgICAgdGhpcy5fZW1pdChcXFwiY2hhbmdlRm9sZFxcXCIsIHsgZGF0YTogZm9sZCwgYWN0aW9uOiBcXFwicmVtb3ZlXFxcIiB9KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZW1vdmVGb2xkcyA9IGZ1bmN0aW9uKGZvbGRzKSB7XFxuXFx0ICAgICAgICB2YXIgY2xvbmVGb2xkcyA9IFtdO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIGNsb25lRm9sZHMucHVzaChmb2xkc1tpXSk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBjbG9uZUZvbGRzLmZvckVhY2goZnVuY3Rpb24oZm9sZCkge1xcblxcdCAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcXG5cXHQgICAgICAgIH0sIHRoaXMpO1xcblxcdCAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmV4cGFuZEZvbGQgPSBmdW5jdGlvbihmb2xkKSB7XFxuXFx0ICAgICAgICB0aGlzLnJlbW92ZUZvbGQoZm9sZCk7XFxuXFx0ICAgICAgICBmb2xkLnN1YkZvbGRzLmZvckVhY2goZnVuY3Rpb24oc3ViRm9sZCkge1xcblxcdCAgICAgICAgICAgIGZvbGQucmVzdG9yZVJhbmdlKHN1YkZvbGQpO1xcblxcdCAgICAgICAgICAgIHRoaXMuYWRkRm9sZChzdWJGb2xkKTtcXG5cXHQgICAgICAgIH0sIHRoaXMpO1xcblxcdCAgICAgICAgaWYgKGZvbGQuY29sbGFwc2VDaGlsZHJlbiA+IDApIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmZvbGRBbGwoZm9sZC5zdGFydC5yb3crMSwgZm9sZC5lbmQucm93LCBmb2xkLmNvbGxhcHNlQ2hpbGRyZW4tMSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBmb2xkLnN1YkZvbGRzID0gW107XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZXhwYW5kRm9sZHMgPSBmdW5jdGlvbihmb2xkcykge1xcblxcdCAgICAgICAgZm9sZHMuZm9yRWFjaChmdW5jdGlvbihmb2xkKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkKGZvbGQpO1xcblxcdCAgICAgICAgfSwgdGhpcyk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMudW5mb2xkID0gZnVuY3Rpb24obG9jYXRpb24sIGV4cGFuZElubmVyKSB7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UsIGZvbGRzO1xcblxcdCAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcXG5cXHQgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZSgwLCAwLCB0aGlzLmdldExlbmd0aCgpLCAwKTtcXG5cXHQgICAgICAgICAgICBleHBhbmRJbm5lciA9IHRydWU7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PSBcXFwibnVtYmVyXFxcIilcXG5cXHQgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShsb2NhdGlvbiwgMCwgbG9jYXRpb24sIHRoaXMuZ2V0TGluZShsb2NhdGlvbikubGVuZ3RoKTtcXG5cXHQgICAgICAgIGVsc2UgaWYgKFxcXCJyb3dcXFwiIGluIGxvY2F0aW9uKVxcblxcdCAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhsb2NhdGlvbiwgbG9jYXRpb24pO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHJhbmdlID0gbG9jYXRpb247XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2VMaXN0KHJhbmdlKTtcXG5cXHQgICAgICAgIGlmIChleHBhbmRJbm5lcikge1xcblxcdCAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZHMoZm9sZHMpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3ViRm9sZHMgPSBmb2xkcztcXG5cXHQgICAgICAgICAgICB3aGlsZSAoc3ViRm9sZHMubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZHMoc3ViRm9sZHMpO1xcblxcdCAgICAgICAgICAgICAgICBzdWJGb2xkcyA9IHRoaXMuZ2V0Rm9sZHNJblJhbmdlTGlzdChyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKGZvbGRzLmxlbmd0aClcXG5cXHQgICAgICAgICAgICByZXR1cm4gZm9sZHM7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaXNSb3dGb2xkZWQgPSBmdW5jdGlvbihkb2NSb3csIHN0YXJ0Rm9sZFJvdykge1xcblxcdCAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRGb2xkTGluZShkb2NSb3csIHN0YXJ0Rm9sZFJvdyk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0Um93Rm9sZEVuZCA9IGZ1bmN0aW9uKGRvY1Jvdywgc3RhcnRGb2xkUm93KSB7XFxuXFx0ICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGRvY1Jvdywgc3RhcnRGb2xkUm93KTtcXG5cXHQgICAgICAgIHJldHVybiBmb2xkTGluZSA/IGZvbGRMaW5lLmVuZC5yb3cgOiBkb2NSb3c7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0Um93Rm9sZFN0YXJ0ID0gZnVuY3Rpb24oZG9jUm93LCBzdGFydEZvbGRSb3cpIHtcXG5cXHQgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZG9jUm93LCBzdGFydEZvbGRSb3cpO1xcblxcdCAgICAgICAgcmV0dXJuIGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogZG9jUm93O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldEZvbGREaXNwbGF5TGluZSA9IGZ1bmN0aW9uKGZvbGRMaW5lLCBlbmRSb3csIGVuZENvbHVtbiwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAoc3RhcnRSb3cgPT0gbnVsbClcXG5cXHQgICAgICAgICAgICBzdGFydFJvdyA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIGlmIChzdGFydENvbHVtbiA9PSBudWxsKVxcblxcdCAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gMDtcXG5cXHQgICAgICAgIGlmIChlbmRSb3cgPT0gbnVsbClcXG5cXHQgICAgICAgICAgICBlbmRSb3cgPSBmb2xkTGluZS5lbmQucm93O1xcblxcdCAgICAgICAgaWYgKGVuZENvbHVtbiA9PSBudWxsKVxcblxcdCAgICAgICAgICAgIGVuZENvbHVtbiA9IHRoaXMuZ2V0TGluZShlbmRSb3cpLmxlbmd0aDtcXG5cXHQgICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcXG5cXHQgICAgICAgIHZhciB0ZXh0TGluZSA9IFxcXCJcXFwiO1xcblxcblxcdCAgICAgICAgZm9sZExpbmUud2FsayhmdW5jdGlvbihwbGFjZWhvbGRlciwgcm93LCBjb2x1bW4sIGxhc3RDb2x1bW4pIHtcXG5cXHQgICAgICAgICAgICBpZiAocm93IDwgc3RhcnRSb3cpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICBpZiAocm93ID09IHN0YXJ0Um93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjb2x1bW4gPCBzdGFydENvbHVtbilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICAgICAgbGFzdENvbHVtbiA9IE1hdGgubWF4KHN0YXJ0Q29sdW1uLCBsYXN0Q29sdW1uKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyICE9IG51bGwpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGV4dExpbmUgKz0gcGxhY2Vob2xkZXI7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgdGV4dExpbmUgKz0gZG9jLmdldExpbmUocm93KS5zdWJzdHJpbmcobGFzdENvbHVtbiwgY29sdW1uKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9LCBlbmRSb3csIGVuZENvbHVtbik7XFxuXFx0ICAgICAgICByZXR1cm4gdGV4dExpbmU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0RGlzcGxheUxpbmUgPSBmdW5jdGlvbihyb3csIGVuZENvbHVtbiwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKHJvdyk7XFxuXFxuXFx0ICAgICAgICBpZiAoIWZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmU7XFxuXFx0ICAgICAgICAgICAgbGluZSA9IHRoaXMuZG9jLmdldExpbmUocm93KTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gbGluZS5zdWJzdHJpbmcoc3RhcnRDb2x1bW4gfHwgMCwgZW5kQ29sdW1uIHx8IGxpbmUubGVuZ3RoKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9sZERpc3BsYXlMaW5lKFxcblxcdCAgICAgICAgICAgICAgICBmb2xkTGluZSwgcm93LCBlbmRDb2x1bW4sIHN0YXJ0Um93LCBzdGFydENvbHVtbik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGNsb25lRm9sZERhdGEgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBmZCA9IFtdO1xcblxcdCAgICAgICAgZmQgPSB0aGlzLiRmb2xkRGF0YS5tYXAoZnVuY3Rpb24oZm9sZExpbmUpIHtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZHMgPSBmb2xkTGluZS5mb2xkcy5tYXAoZnVuY3Rpb24oZm9sZCkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZm9sZC5jbG9uZSgpO1xcblxcdCAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZExpbmUoZmQsIGZvbGRzKTtcXG5cXHQgICAgICAgIH0pO1xcblxcblxcdCAgICAgICAgcmV0dXJuIGZkO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnRvZ2dsZUZvbGQgPSBmdW5jdGlvbih0cnlUb1VuZm9sZCkge1xcblxcdCAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlKCk7XFxuXFx0ICAgICAgICB2YXIgZm9sZDtcXG5cXHQgICAgICAgIHZhciBicmFja2V0UG9zO1xcblxcblxcdCAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xcblxcdCAgICAgICAgICAgIHZhciBjdXJzb3IgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgICAgICBmb2xkID0gdGhpcy5nZXRGb2xkQXQoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkKGZvbGQpO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChicmFja2V0UG9zID0gdGhpcy5maW5kTWF0Y2hpbmdCcmFja2V0KGN1cnNvcikpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmVQb2ludChicmFja2V0UG9zKSA9PSAxKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQgPSBicmFja2V0UG9zO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSBicmFja2V0UG9zO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uKys7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uLS07XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWNrZXRQb3MgPSB0aGlzLmZpbmRNYXRjaGluZ0JyYWNrZXQoe3JvdzogY3Vyc29yLnJvdywgY29sdW1uOiBjdXJzb3IuY29sdW1uICsgMX0pKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlUG9pbnQoYnJhY2tldFBvcykgPT0gMSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA9IGJyYWNrZXRQb3M7XFxuXFx0ICAgICAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0ID0gYnJhY2tldFBvcztcXG5cXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uKys7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmdldENvbW1lbnRGb2xkUmFuZ2UoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbikgfHwgcmFuZ2U7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgaWYgKHRyeVRvVW5mb2xkICYmIGZvbGRzLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZEZvbGRzKGZvbGRzKTtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9sZHMubGVuZ3RoID09IDEgKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGZvbGQgPSBmb2xkc1swXTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoIWZvbGQpXFxuXFx0ICAgICAgICAgICAgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcXG5cXG5cXHQgICAgICAgIGlmIChmb2xkICYmIGZvbGQucmFuZ2UudG9TdHJpbmcoKSA9PSByYW5nZS50b1N0cmluZygpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5leHBhbmRGb2xkKGZvbGQpO1xcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IFxcXCIuLi5cXFwiO1xcblxcdCAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpKSB7XFxuXFx0ICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgaWYocGxhY2Vob2xkZXIubGVuZ3RoIDwgNClcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIudHJpbSgpLnN1YnN0cmluZygwLCAyKSArIFxcXCIuLlxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLmFkZEZvbGQocGxhY2Vob2xkZXIsIHJhbmdlKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRDb21tZW50Rm9sZFJhbmdlID0gZnVuY3Rpb24ocm93LCBjb2x1bW4sIGRpcikge1xcblxcdCAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XFxuXFx0ICAgICAgICBpZiAodG9rZW4gJiYgL15jb21tZW50fHN0cmluZy8udGVzdCh0b2tlbi50eXBlKSkge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAodG9rZW4udHlwZS5yZXBsYWNlKC9cXFxcLi4qLywgXFxcIlxcXFxcXFxcLlxcXCIpKTtcXG5cXHQgICAgICAgICAgICBpZiAoZGlyICE9IDEpIHtcXG5cXHQgICAgICAgICAgICAgICAgZG8ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcXG5cXHQgICAgICAgICAgICAgICAgfSB3aGlsZSh0b2tlbiAmJiByZS50ZXN0KHRva2VuLnR5cGUpKTtcXG5cXHQgICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XFxuXFx0ICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAyO1xcblxcblxcdCAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3IFRva2VuSXRlcmF0b3IodGhpcywgcm93LCBjb2x1bW4pO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGlmIChkaXIgIT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgZG8ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xcblxcdCAgICAgICAgICAgICAgICB9IHdoaWxlKHRva2VuICYmIHJlLnRlc3QodG9rZW4udHlwZSkpO1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xcblxcblxcdCAgICAgICAgICAgIHJhbmdlLmVuZC5yb3cgPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKTtcXG5cXHQgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyB0b2tlbi52YWx1ZS5sZW5ndGggLSAyO1xcblxcdCAgICAgICAgICAgIHJldHVybiByYW5nZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5mb2xkQWxsID0gZnVuY3Rpb24oc3RhcnRSb3csIGVuZFJvdywgZGVwdGgpIHtcXG5cXHQgICAgICAgIGlmIChkZXB0aCA9PSB1bmRlZmluZWQpXFxuXFx0ICAgICAgICAgICAgZGVwdGggPSAxMDAwMDA7IC8vIEpTT04uc3RyaW5naWZ5IGRvZXNuJ3QgaGFubGUgSW5maW5pdHlcXG5cXHQgICAgICAgIHZhciBmb2xkV2lkZ2V0cyA9IHRoaXMuZm9sZFdpZGdldHM7XFxuXFx0ICAgICAgICBpZiAoIWZvbGRXaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHJldHVybjsgLy8gbW9kZSBkb2Vzbid0IHN1cHBvcnQgZm9sZGluZ1xcblxcdCAgICAgICAgZW5kUm93ID0gZW5kUm93IHx8IHRoaXMuZ2V0TGVuZ3RoKCk7XFxuXFx0ICAgICAgICBzdGFydFJvdyA9IHN0YXJ0Um93IHx8IDA7XFxuXFx0ICAgICAgICBmb3IgKHZhciByb3cgPSBzdGFydFJvdzsgcm93IDwgZW5kUm93OyByb3crKykge1xcblxcdCAgICAgICAgICAgIGlmIChmb2xkV2lkZ2V0c1tyb3ddID09IG51bGwpXFxuXFx0ICAgICAgICAgICAgICAgIGZvbGRXaWRnZXRzW3Jvd10gPSB0aGlzLmdldEZvbGRXaWRnZXQocm93KTtcXG5cXHQgICAgICAgICAgICBpZiAoZm9sZFdpZGdldHNbcm93XSAhPSBcXFwic3RhcnRcXFwiKVxcblxcdCAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZShyb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5pc011bHRpTGluZSgpXFxuXFx0ICAgICAgICAgICAgICAgICYmIHJhbmdlLmVuZC5yb3cgPD0gZW5kUm93XFxuXFx0ICAgICAgICAgICAgICAgICYmIHJhbmdlLnN0YXJ0LnJvdyA+PSBzdGFydFJvd1xcblxcdCAgICAgICAgICAgICkge1xcblxcdCAgICAgICAgICAgICAgICByb3cgPSByYW5nZS5lbmQucm93O1xcblxcdCAgICAgICAgICAgICAgICB0cnkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGQgPSB0aGlzLmFkZEZvbGQoXFxcIi4uLlxcXCIsIHJhbmdlKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb2xkKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGZvbGQuY29sbGFwc2VDaGlsZHJlbiA9IGRlcHRoO1xcblxcdCAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHt9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiRmb2xkU3R5bGVzID0ge1xcblxcdCAgICAgICAgXFxcIm1hbnVhbFxcXCI6IDEsXFxuXFx0ICAgICAgICBcXFwibWFya2JlZ2luXFxcIjogMSxcXG5cXHQgICAgICAgIFxcXCJtYXJrYmVnaW5lbmRcXFwiOiAxXFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJGZvbGRTdHlsZSA9IFxcXCJtYXJrYmVnaW5cXFwiO1xcblxcdCAgICB0aGlzLnNldEZvbGRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGZvbGRTdHlsZXNbc3R5bGVdKVxcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaW52YWxpZCBmb2xkIHN0eWxlOiBcXFwiICsgc3R5bGUgKyBcXFwiW1xcXCIgKyBPYmplY3Qua2V5cyh0aGlzLiRmb2xkU3R5bGVzKS5qb2luKFxcXCIsIFxcXCIpICsgXFxcIl1cXFwiKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHRoaXMuJGZvbGRTdHlsZSA9PSBzdHlsZSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB0aGlzLiRmb2xkU3R5bGUgPSBzdHlsZTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHN0eWxlID09IFxcXCJtYW51YWxcXFwiKVxcblxcdCAgICAgICAgICAgIHRoaXMudW5mb2xkKCk7XFxuXFx0ICAgICAgICB2YXIgbW9kZSA9IHRoaXMuJGZvbGRNb2RlO1xcblxcdCAgICAgICAgdGhpcy4kc2V0Rm9sZGluZyhudWxsKTtcXG5cXHQgICAgICAgIHRoaXMuJHNldEZvbGRpbmcobW9kZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHNldEZvbGRpbmcgPSBmdW5jdGlvbihmb2xkTW9kZSkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJGZvbGRNb2RlID09IGZvbGRNb2RlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMuJGZvbGRNb2RlID0gZm9sZE1vZGU7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuJHVwZGF0ZUZvbGRXaWRnZXRzKTtcXG5cXHQgICAgICAgIHRoaXMuX2VtaXQoXFxcImNoYW5nZUFubm90YXRpb25cXFwiKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKCFmb2xkTW9kZSB8fCB0aGlzLiRmb2xkU3R5bGUgPT0gXFxcIm1hbnVhbFxcXCIpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmZvbGRXaWRnZXRzID0gbnVsbDtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMuZm9sZFdpZGdldHMgPSBbXTtcXG5cXHQgICAgICAgIHRoaXMuZ2V0Rm9sZFdpZGdldCA9IGZvbGRNb2RlLmdldEZvbGRXaWRnZXQuYmluZChmb2xkTW9kZSwgdGhpcywgdGhpcy4kZm9sZFN0eWxlKTtcXG5cXHQgICAgICAgIHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlID0gZm9sZE1vZGUuZ2V0Rm9sZFdpZGdldFJhbmdlLmJpbmQoZm9sZE1vZGUsIHRoaXMsIHRoaXMuJGZvbGRTdHlsZSk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMuJHVwZGF0ZUZvbGRXaWRnZXRzID0gdGhpcy51cGRhdGVGb2xkV2lkZ2V0cy5iaW5kKHRoaXMpO1xcblxcdCAgICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy4kdXBkYXRlRm9sZFdpZGdldHMpO1xcblxcdCAgICAgICAgXFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YSA9IGZ1bmN0aW9uIChyb3csIGlnbm9yZUN1cnJlbnQpIHtcXG5cXHQgICAgICAgIHZhciBmdyA9IHRoaXMuZm9sZFdpZGdldHM7XFxuXFx0ICAgICAgICBpZiAoIWZ3IHx8IChpZ25vcmVDdXJyZW50ICYmIGZ3W3Jvd10pKVxcblxcdCAgICAgICAgICAgIHJldHVybiB7fTtcXG5cXG5cXHQgICAgICAgIHZhciBpID0gcm93IC0gMSwgZmlyc3RSYW5nZTtcXG5cXHQgICAgICAgIHdoaWxlIChpID49IDApIHtcXG5cXHQgICAgICAgICAgICB2YXIgYyA9IGZ3W2ldO1xcblxcdCAgICAgICAgICAgIGlmIChjID09IG51bGwpXFxuXFx0ICAgICAgICAgICAgICAgIGMgPSBmd1tpXSA9IHRoaXMuZ2V0Rm9sZFdpZGdldChpKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoYyA9PSBcXFwic3RhcnRcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlKGkpO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmFuZ2UpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJhbmdlID0gcmFuZ2U7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5lbmQucm93ID49IHJvdylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpLS07XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgIHJhbmdlOiBpICE9PSAtMSAmJiByYW5nZSxcXG5cXHQgICAgICAgICAgICBmaXJzdFJhbmdlOiBmaXJzdFJhbmdlXFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHRoaXMub25Gb2xkV2lkZ2V0Q2xpY2sgPSBmdW5jdGlvbihyb3csIGUpIHtcXG5cXHQgICAgICAgIGUgPSBlLmRvbUV2ZW50O1xcblxcdCAgICAgICAgdmFyIG9wdGlvbnMgPSB7XFxuXFx0ICAgICAgICAgICAgY2hpbGRyZW46IGUuc2hpZnRLZXksXFxuXFx0ICAgICAgICAgICAgYWxsOiBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5LFxcblxcdCAgICAgICAgICAgIHNpYmxpbmdzOiBlLmFsdEtleVxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy4kdG9nZ2xlRm9sZFdpZGdldChyb3csIG9wdGlvbnMpO1xcblxcdCAgICAgICAgaWYgKCFyYW5nZSkge1xcblxcdCAgICAgICAgICAgIHZhciBlbCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpXFxuXFx0ICAgICAgICAgICAgaWYgKGVsICYmIC9hY2VfZm9sZC13aWRnZXQvLnRlc3QoZWwuY2xhc3NOYW1lKSlcXG5cXHQgICAgICAgICAgICAgICAgZWwuY2xhc3NOYW1lICs9IFxcXCIgYWNlX2ludmFsaWRcXFwiO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy4kdG9nZ2xlRm9sZFdpZGdldCA9IGZ1bmN0aW9uKHJvdywgb3B0aW9ucykge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLmdldEZvbGRXaWRnZXQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmdldEZvbGRXaWRnZXQocm93KTtcXG5cXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHJvdyk7XFxuXFxuXFx0ICAgICAgICB2YXIgZGlyID0gdHlwZSA9PT0gXFxcImVuZFxcXCIgPyAtMSA6IDE7XFxuXFx0ICAgICAgICB2YXIgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJvdywgZGlyID09PSAtMSA/IDAgOiBsaW5lLmxlbmd0aCwgZGlyKTtcXG5cXG5cXHQgICAgICAgIGlmIChmb2xkKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gfHwgb3B0aW9ucy5hbGwpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kRm9sZChmb2xkKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEZvbGRXaWRnZXRSYW5nZShyb3csIHRydWUpO1xcblxcdCAgICAgICAgaWYgKHJhbmdlICYmICFyYW5nZS5pc011bHRpTGluZSgpKSB7XFxuXFx0ICAgICAgICAgICAgZm9sZCA9IHRoaXMuZ2V0Rm9sZEF0KHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLCAxKTtcXG5cXHQgICAgICAgICAgICBpZiAoZm9sZCAmJiByYW5nZS5pc0VxdWFsKGZvbGQucmFuZ2UpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKG9wdGlvbnMuc2libGluZ3MpIHtcXG5cXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YShyb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChkYXRhLnJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGRhdGEucmFuZ2Uuc3RhcnQucm93ICsgMTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGVuZFJvdyA9IGRhdGEucmFuZ2UuZW5kLnJvdztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkQWxsKHN0YXJ0Um93LCBlbmRSb3csIG9wdGlvbnMuYWxsID8gMTAwMDAgOiAwKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jaGlsZHJlbikge1xcblxcdCAgICAgICAgICAgIGVuZFJvdyA9IHJhbmdlID8gcmFuZ2UuZW5kLnJvdyA6IHRoaXMuZ2V0TGVuZ3RoKCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkQWxsKHJvdyArIDEsIHJhbmdlLmVuZC5yb3csIG9wdGlvbnMuYWxsID8gMTAwMDAgOiAwKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UpIHtcXG5cXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGwpIFxcblxcdCAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZUNoaWxkcmVuID0gMTAwMDA7XFxuXFx0ICAgICAgICAgICAgdGhpcy5hZGRGb2xkKFxcXCIuLi5cXFwiLCByYW5nZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHJldHVybiByYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIFxcblxcdCAgICBcXG5cXHQgICAgdGhpcy50b2dnbGVGb2xkV2lkZ2V0ID0gZnVuY3Rpb24odG9nZ2xlUGFyZW50KSB7XFxuXFx0ICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xcblxcdCAgICAgICAgcm93ID0gdGhpcy5nZXRSb3dGb2xkU3RhcnQocm93KTtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IHRoaXMuJHRvZ2dsZUZvbGRXaWRnZXQocm93LCB7fSk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChyYW5nZSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0UGFyZW50Rm9sZFJhbmdlRGF0YShyb3csIHRydWUpO1xcblxcdCAgICAgICAgcmFuZ2UgPSBkYXRhLnJhbmdlIHx8IGRhdGEuZmlyc3RSYW5nZTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgcm93ID0gcmFuZ2Uuc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgIHZhciBmb2xkID0gdGhpcy5nZXRGb2xkQXQocm93LCB0aGlzLmdldExpbmUocm93KS5sZW5ndGgsIDEpO1xcblxcblxcdCAgICAgICAgICAgIGlmIChmb2xkKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRm9sZChmb2xkKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLmFkZEZvbGQoXFxcIi4uLlxcXCIsIHJhbmdlKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMudXBkYXRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICB2YXIgZGVsdGEgPSBlLmRhdGE7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBkZWx0YS5yYW5nZTtcXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIHZhciBsZW4gPSByYW5nZS5lbmQucm93IC0gZmlyc3RSb3c7XFxuXFxuXFx0ICAgICAgICBpZiAobGVuID09PSAwKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkV2lkZ2V0c1tmaXJzdFJvd10gPSBudWxsO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5hY3Rpb24gPT0gXFxcInJlbW92ZVRleHRcXFwiIHx8IGRlbHRhLmFjdGlvbiA9PSBcXFwicmVtb3ZlTGluZXNcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkV2lkZ2V0cy5zcGxpY2UoZmlyc3RSb3csIGxlbiArIDEsIG51bGwpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5KGxlbiArIDEpO1xcblxcdCAgICAgICAgICAgIGFyZ3MudW5zaGlmdChmaXJzdFJvdywgMSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkV2lkZ2V0cy5zcGxpY2UuYXBwbHkodGhpcy5mb2xkV2lkZ2V0cywgYXJncyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0fVxcblxcblxcdGV4cG9ydHMuRm9sZGluZyA9IEZvbGRpbmc7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2VkaXRfc2Vzc2lvbi9icmFja2V0X21hdGNoXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3Rva2VuX2l0ZXJhdG9yXFxcIixcXFwiYWNlL3JhbmdlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIFRva2VuSXRlcmF0b3IgPSBhY2VxdWlyZShcXFwiLi4vdG9rZW5faXRlcmF0b3JcXFwiKS5Ub2tlbkl0ZXJhdG9yO1xcblxcdHZhciBSYW5nZSA9IGFjZXF1aXJlKFxcXCIuLi9yYW5nZVxcXCIpLlJhbmdlO1xcblxcblxcblxcdGZ1bmN0aW9uIEJyYWNrZXRNYXRjaCgpIHtcXG5cXG5cXHQgICAgdGhpcy5maW5kTWF0Y2hpbmdCcmFja2V0ID0gZnVuY3Rpb24ocG9zaXRpb24sIGNocikge1xcblxcdCAgICAgICAgaWYgKHBvc2l0aW9uLmNvbHVtbiA9PSAwKSByZXR1cm4gbnVsbDtcXG5cXG5cXHQgICAgICAgIHZhciBjaGFyQmVmb3JlQ3Vyc29yID0gY2hyIHx8IHRoaXMuZ2V0TGluZShwb3NpdGlvbi5yb3cpLmNoYXJBdChwb3NpdGlvbi5jb2x1bW4tMSk7XFxuXFx0ICAgICAgICBpZiAoY2hhckJlZm9yZUN1cnNvciA9PSBcXFwiXFxcIikgcmV0dXJuIG51bGw7XFxuXFxuXFx0ICAgICAgICB2YXIgbWF0Y2ggPSBjaGFyQmVmb3JlQ3Vyc29yLm1hdGNoKC8oW1xcXFwoXFxcXFtcXFxce10pfChbXFxcXClcXFxcXVxcXFx9XSkvKTtcXG5cXHQgICAgICAgIGlmICghbWF0Y2gpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFxuXFx0ICAgICAgICBpZiAobWF0Y2hbMV0pXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZpbmRDbG9zaW5nQnJhY2tldChtYXRjaFsxXSwgcG9zaXRpb24pO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLiRmaW5kT3BlbmluZ0JyYWNrZXQobWF0Y2hbMl0sIHBvc2l0aW9uKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuZ2V0QnJhY2tldFJhbmdlID0gZnVuY3Rpb24ocG9zKSB7XFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuZ2V0TGluZShwb3Mucm93KTtcXG5cXHQgICAgICAgIHZhciBiZWZvcmUgPSB0cnVlLCByYW5nZTtcXG5cXG5cXHQgICAgICAgIHZhciBjaHIgPSBsaW5lLmNoYXJBdChwb3MuY29sdW1uLTEpO1xcblxcdCAgICAgICAgdmFyIG1hdGNoID0gY2hyICYmIGNoci5tYXRjaCgvKFtcXFxcKFxcXFxbXFxcXHtdKXwoW1xcXFwpXFxcXF1cXFxcfV0pLyk7XFxuXFx0ICAgICAgICBpZiAoIW1hdGNoKSB7XFxuXFx0ICAgICAgICAgICAgY2hyID0gbGluZS5jaGFyQXQocG9zLmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgcG9zID0ge3JvdzogcG9zLnJvdywgY29sdW1uOiBwb3MuY29sdW1uICsgMX07XFxuXFx0ICAgICAgICAgICAgbWF0Y2ggPSBjaHIgJiYgY2hyLm1hdGNoKC8oW1xcXFwoXFxcXFtcXFxce10pfChbXFxcXClcXFxcXVxcXFx9XSkvKTtcXG5cXHQgICAgICAgICAgICBiZWZvcmUgPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICghbWF0Y2gpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFxuXFx0ICAgICAgICBpZiAobWF0Y2hbMV0pIHtcXG5cXHQgICAgICAgICAgICB2YXIgYnJhY2tldFBvcyA9IHRoaXMuJGZpbmRDbG9zaW5nQnJhY2tldChtYXRjaFsxXSwgcG9zKTtcXG5cXHQgICAgICAgICAgICBpZiAoIWJyYWNrZXRQb3MpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICAgICAgICAgIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhwb3MsIGJyYWNrZXRQb3MpO1xcblxcdCAgICAgICAgICAgIGlmICghYmVmb3JlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uLS07XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHJhbmdlLmVuZDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGJyYWNrZXRQb3MgPSB0aGlzLiRmaW5kT3BlbmluZ0JyYWNrZXQobWF0Y2hbMl0sIHBvcyk7XFxuXFx0ICAgICAgICAgICAgaWYgKCFicmFja2V0UG9zKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG5cXHQgICAgICAgICAgICByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoYnJhY2tldFBvcywgcG9zKTtcXG5cXHQgICAgICAgICAgICBpZiAoIWJlZm9yZSkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4rKztcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbi0tO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICByYW5nZS5jdXJzb3IgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgcmV0dXJuIHJhbmdlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRicmFja2V0cyA9IHtcXG5cXHQgICAgICAgIFxcXCIpXFxcIjogXFxcIihcXFwiLFxcblxcdCAgICAgICAgXFxcIihcXFwiOiBcXFwiKVxcXCIsXFxuXFx0ICAgICAgICBcXFwiXVxcXCI6IFxcXCJbXFxcIixcXG5cXHQgICAgICAgIFxcXCJbXFxcIjogXFxcIl1cXFwiLFxcblxcdCAgICAgICAgXFxcIntcXFwiOiBcXFwifVxcXCIsXFxuXFx0ICAgICAgICBcXFwifVxcXCI6IFxcXCJ7XFxcIlxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRmaW5kT3BlbmluZ0JyYWNrZXQgPSBmdW5jdGlvbihicmFja2V0LCBwb3NpdGlvbiwgdHlwZVJlKSB7XFxuXFx0ICAgICAgICB2YXIgb3BlbkJyYWNrZXQgPSB0aGlzLiRicmFja2V0c1ticmFja2V0XTtcXG5cXHQgICAgICAgIHZhciBkZXB0aCA9IDE7XFxuXFxuXFx0ICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLCBwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XFxuXFx0ICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcXG5cXHQgICAgICAgIGlmICghdG9rZW4pXFxuXFx0ICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xcblxcdCAgICAgICAgaWYgKCF0b2tlbilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgICBpZiAoIXR5cGVSZSl7XFxuXFx0ICAgICAgICAgICAgdHlwZVJlID0gbmV3IFJlZ0V4cChcXG5cXHQgICAgICAgICAgICAgICAgXFxcIihcXFxcXFxcXC4/XFxcIiArXFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuLnR5cGUucmVwbGFjZShcXFwiLlxcXCIsIFxcXCJcXFxcXFxcXC5cXFwiKS5yZXBsYWNlKFxcXCJycGFyZW5cXFwiLCBcXFwiLnBhcmVuXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcYig/OmVuZHxzdGFydHxiZWdpbilcXFxcYi8sIFxcXCJcXFwiKVxcblxcdCAgICAgICAgICAgICAgICArIFxcXCIpK1xcXCJcXG5cXHQgICAgICAgICAgICApO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIHZhbHVlSW5kZXggPSBwb3NpdGlvbi5jb2x1bW4gLSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSAtIDI7XFxuXFx0ICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgd2hpbGUgKHRydWUpIHtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgICAgIHdoaWxlICh2YWx1ZUluZGV4ID49IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGNociA9IHZhbHVlLmNoYXJBdCh2YWx1ZUluZGV4KTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGNociA9PSBvcGVuQnJhY2tldCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZGVwdGggLT0gMTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtyb3c6IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHZhbHVlSW5kZXggKyBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKX07XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09IGJyYWNrZXQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgdmFsdWVJbmRleCAtPSAxO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBkbyB7XFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XFxuXFx0ICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgIXR5cGVSZS50ZXN0KHRva2VuLnR5cGUpKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbClcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XFxuXFx0ICAgICAgICAgICAgdmFsdWVJbmRleCA9IHZhbHVlLmxlbmd0aCAtIDE7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRmaW5kQ2xvc2luZ0JyYWNrZXQgPSBmdW5jdGlvbihicmFja2V0LCBwb3NpdGlvbiwgdHlwZVJlKSB7XFxuXFx0ICAgICAgICB2YXIgY2xvc2luZ0JyYWNrZXQgPSB0aGlzLiRicmFja2V0c1ticmFja2V0XTtcXG5cXHQgICAgICAgIHZhciBkZXB0aCA9IDE7XFxuXFxuXFx0ICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLCBwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XFxuXFx0ICAgICAgICB2YXIgdG9rZW4gPSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKTtcXG5cXHQgICAgICAgIGlmICghdG9rZW4pXFxuXFx0ICAgICAgICAgICAgdG9rZW4gPSBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xcblxcdCAgICAgICAgaWYgKCF0b2tlbilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICBpZiAoIXR5cGVSZSl7XFxuXFx0ICAgICAgICAgICAgdHlwZVJlID0gbmV3IFJlZ0V4cChcXG5cXHQgICAgICAgICAgICAgICAgXFxcIihcXFxcXFxcXC4/XFxcIiArXFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuLnR5cGUucmVwbGFjZShcXFwiLlxcXCIsIFxcXCJcXFxcXFxcXC5cXFwiKS5yZXBsYWNlKFxcXCJscGFyZW5cXFwiLCBcXFwiLnBhcmVuXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcYig/OmVuZHxzdGFydHxiZWdpbilcXFxcYi8sIFxcXCJcXFwiKVxcblxcdCAgICAgICAgICAgICAgICArIFxcXCIpK1xcXCJcXG5cXHQgICAgICAgICAgICApO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIHZhbHVlSW5kZXggPSBwb3NpdGlvbi5jb2x1bW4gLSBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKTtcXG5cXG5cXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWU7XFxuXFx0ICAgICAgICAgICAgdmFyIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIHdoaWxlICh2YWx1ZUluZGV4IDwgdmFsdWVMZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGNociA9IHZhbHVlLmNoYXJBdCh2YWx1ZUluZGV4KTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGNociA9PSBjbG9zaW5nQnJhY2tldCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZGVwdGggLT0gMTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtyb3c6IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHZhbHVlSW5kZXggKyBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKX07XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hyID09IGJyYWNrZXQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgdmFsdWVJbmRleCArPSAxO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBkbyB7XFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcXG5cXHQgICAgICAgICAgICB9IHdoaWxlICh0b2tlbiAmJiAhdHlwZVJlLnRlc3QodG9rZW4udHlwZSkpO1xcblxcblxcdCAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKVxcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXG5cXHQgICAgICAgICAgICB2YWx1ZUluZGV4ID0gMDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgIH07XFxuXFx0fVxcblxcdGV4cG9ydHMuQnJhY2tldE1hdGNoID0gQnJhY2tldE1hdGNoO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9lZGl0X3Nlc3Npb25cXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCIsXFxcImFjZS9jb25maWdcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiLFxcXCJhY2Uvc2VsZWN0aW9uXFxcIixcXFwiYWNlL21vZGUvdGV4dFxcXCIsXFxcImFjZS9yYW5nZVxcXCIsXFxcImFjZS9kb2N1bWVudFxcXCIsXFxcImFjZS9iYWNrZ3JvdW5kX3Rva2VuaXplclxcXCIsXFxcImFjZS9zZWFyY2hfaGlnaGxpZ2h0XFxcIixcXFwiYWNlL2VkaXRfc2Vzc2lvbi9mb2xkaW5nXFxcIixcXFwiYWNlL2VkaXRfc2Vzc2lvbi9icmFja2V0X21hdGNoXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgbGFuZyA9IGFjZXF1aXJlKFxcXCIuL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIGNvbmZpZyA9IGFjZXF1aXJlKFxcXCIuL2NvbmZpZ1xcXCIpO1xcblxcdHZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXHR2YXIgU2VsZWN0aW9uID0gYWNlcXVpcmUoXFxcIi4vc2VsZWN0aW9uXFxcIikuU2VsZWN0aW9uO1xcblxcdHZhciBUZXh0TW9kZSA9IGFjZXF1aXJlKFxcXCIuL21vZGUvdGV4dFxcXCIpLk1vZGU7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXHR2YXIgRG9jdW1lbnQgPSBhY2VxdWlyZShcXFwiLi9kb2N1bWVudFxcXCIpLkRvY3VtZW50O1xcblxcdHZhciBCYWNrZ3JvdW5kVG9rZW5pemVyID0gYWNlcXVpcmUoXFxcIi4vYmFja2dyb3VuZF90b2tlbml6ZXJcXFwiKS5CYWNrZ3JvdW5kVG9rZW5pemVyO1xcblxcdHZhciBTZWFyY2hIaWdobGlnaHQgPSBhY2VxdWlyZShcXFwiLi9zZWFyY2hfaGlnaGxpZ2h0XFxcIikuU2VhcmNoSGlnaGxpZ2h0O1xcblxcblxcdHZhciBFZGl0U2Vzc2lvbiA9IGZ1bmN0aW9uKHRleHQsIG1vZGUpIHtcXG5cXHQgICAgdGhpcy4kYnJlYWtwb2ludHMgPSBbXTtcXG5cXHQgICAgdGhpcy4kZGVjb3JhdGlvbnMgPSBbXTtcXG5cXHQgICAgdGhpcy4kZnJvbnRNYXJrZXJzID0ge307XFxuXFx0ICAgIHRoaXMuJGJhY2tNYXJrZXJzID0ge307XFxuXFx0ICAgIHRoaXMuJG1hcmtlcklkID0gMTtcXG5cXHQgICAgdGhpcy4kdW5kb1NlbGVjdCA9IHRydWU7XFxuXFxuXFx0ICAgIHRoaXMuJGZvbGREYXRhID0gW107XFxuXFx0ICAgIHRoaXMuJGZvbGREYXRhLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5qb2luKFxcXCJcXFxcblxcXCIpO1xcblxcdCAgICB9XFxuXFx0ICAgIHRoaXMub24oXFxcImNoYW5nZUZvbGRcXFwiLCB0aGlzLm9uQ2hhbmdlRm9sZC5iaW5kKHRoaXMpKTtcXG5cXHQgICAgdGhpcy4kb25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XFxuXFxuXFx0ICAgIGlmICh0eXBlb2YgdGV4dCAhPSBcXFwib2JqZWN0XFxcIiB8fCAhdGV4dC5nZXRMaW5lKVxcblxcdCAgICAgICAgdGV4dCA9IG5ldyBEb2N1bWVudCh0ZXh0KTtcXG5cXG5cXHQgICAgdGhpcy5zZXREb2N1bWVudCh0ZXh0KTtcXG5cXHQgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKHRoaXMpO1xcblxcblxcdCAgICBjb25maWcucmVzZXRPcHRpb25zKHRoaXMpO1xcblxcdCAgICB0aGlzLnNldE1vZGUobW9kZSk7XFxuXFx0ICAgIGNvbmZpZy5fc2lnbmFsKFxcXCJzZXNzaW9uXFxcIiwgdGhpcyk7XFxuXFx0fTtcXG5cXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcXG5cXHQgICAgdGhpcy5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKGRvYykge1xcblxcdCAgICAgICAgaWYgKHRoaXMuZG9jKVxcblxcdCAgICAgICAgICAgIHRoaXMuZG9jLnJlbW92ZUxpc3RlbmVyKFxcXCJjaGFuZ2VcXFwiLCB0aGlzLiRvbkNoYW5nZSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLmRvYyA9IGRvYztcXG5cXHQgICAgICAgIGRvYy5vbihcXFwiY2hhbmdlXFxcIiwgdGhpcy4kb25DaGFuZ2UpO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMuYmdUb2tlbml6ZXIpXFxuXFx0ICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zZXREb2N1bWVudCh0aGlzLmdldERvY3VtZW50KCkpO1xcblxcblxcdCAgICAgICAgdGhpcy5yZXNldENhY2hlcygpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5kb2M7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUgPSBmdW5jdGlvbihkb2NSb3cpIHtcXG5cXHQgICAgICAgIGlmICghZG9jUm93KSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUgPSBbXTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZSA9IFtdO1xcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHZhciBsID0gdGhpcy4kZG9jUm93Q2FjaGUubGVuZ3RoO1xcblxcdCAgICAgICAgdmFyIGkgPSB0aGlzLiRnZXRSb3dDYWNoZUluZGV4KHRoaXMuJGRvY1Jvd0NhY2hlLCBkb2NSb3cpICsgMTtcXG5cXHQgICAgICAgIGlmIChsID4gaSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGRvY1Jvd0NhY2hlLnNwbGljZShpLCBsKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZS5zcGxpY2UoaSwgbCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGdldFJvd0NhY2hlSW5kZXggPSBmdW5jdGlvbihjYWNoZUFycmF5LCB2YWwpIHtcXG5cXHQgICAgICAgIHZhciBsb3cgPSAwO1xcblxcdCAgICAgICAgdmFyIGhpID0gY2FjaGVBcnJheS5sZW5ndGggLSAxO1xcblxcblxcdCAgICAgICAgd2hpbGUgKGxvdyA8PSBoaSkge1xcblxcdCAgICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGkpID4+IDE7XFxuXFx0ICAgICAgICAgICAgdmFyIGMgPSBjYWNoZUFycmF5W21pZF07XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHZhbCA+IGMpXFxuXFx0ICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XFxuXFx0ICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgYylcXG5cXHQgICAgICAgICAgICAgICAgaGkgPSBtaWQgLSAxO1xcblxcdCAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1pZDtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBsb3cgLTE7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMucmVzZXRDYWNoZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcXG5cXHQgICAgICAgIHRoaXMuJHdyYXBEYXRhID0gW107XFxuXFx0ICAgICAgICB0aGlzLiRyb3dMZW5ndGhDYWNoZSA9IFtdO1xcblxcdCAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcXG5cXHQgICAgICAgIGlmICh0aGlzLmJnVG9rZW5pemVyKVxcblxcdCAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc3RhcnQoMCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25DaGFuZ2VGb2xkID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGZvbGQgPSBlLmRhdGE7XFxuXFx0ICAgICAgICB0aGlzLiRyZXNldFJvd0NhY2hlKGZvbGQuc3RhcnQucm93KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IGUuZGF0YTtcXG5cXHQgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcXG5cXG5cXHQgICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoZGVsdGEucmFuZ2Uuc3RhcnQucm93KTtcXG5cXG5cXHQgICAgICAgIHZhciByZW1vdmVkRm9sZHMgPSB0aGlzLiR1cGRhdGVJbnRlcm5hbERhdGFPbkNoYW5nZShlKTtcXG5cXHQgICAgICAgIGlmICghdGhpcy4kZnJvbVVuZG8gJiYgdGhpcy4kdW5kb01hbmFnZXIgJiYgIWRlbHRhLmlnbm9yZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGRlbHRhc0RvYy5wdXNoKGRlbHRhKTtcXG5cXHQgICAgICAgICAgICBpZiAocmVtb3ZlZEZvbGRzICYmIHJlbW92ZWRGb2xkcy5sZW5ndGggIT0gMCkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRkZWx0YXNGb2xkLnB1c2goe1xcblxcdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcXFwicmVtb3ZlRm9sZHNcXFwiLFxcblxcdCAgICAgICAgICAgICAgICAgICAgZm9sZHM6ICByZW1vdmVkRm9sZHNcXG5cXHQgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIHRoaXMuJGluZm9ybVVuZG9NYW5hZ2VyLnNjaGVkdWxlKCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLmJnVG9rZW5pemVyICYmIHRoaXMuYmdUb2tlbml6ZXIuJHVwZGF0ZU9uQ2hhbmdlKGRlbHRhKTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIiwgZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICB0aGlzLmRvYy5zZXRWYWx1ZSh0ZXh0KTtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVUbygwLCAwKTtcXG5cXG5cXHQgICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XFxuXFx0ICAgICAgICB0aGlzLiRkZWx0YXMgPSBbXTtcXG5cXHQgICAgICAgIHRoaXMuJGRlbHRhc0RvYyA9IFtdO1xcblxcdCAgICAgICAgdGhpcy4kZGVsdGFzRm9sZCA9IFtdO1xcblxcdCAgICAgICAgdGhpcy5zZXRVbmRvTWFuYWdlcih0aGlzLiR1bmRvTWFuYWdlcik7XFxuXFx0ICAgICAgICB0aGlzLmdldFVuZG9NYW5hZ2VyKCkucmVzZXQoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRWYWx1ZSA9XFxuXFx0ICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRWYWx1ZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFN0YXRlID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5iZ1Rva2VuaXplci5nZXRTdGF0ZShyb3cpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFRva2VucyA9IGZ1bmN0aW9uKHJvdykge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuYmdUb2tlbml6ZXIuZ2V0VG9rZW5zKHJvdyk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0VG9rZW5BdCA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5iZ1Rva2VuaXplci5nZXRUb2tlbnMocm93KTtcXG5cXHQgICAgICAgIHZhciB0b2tlbiwgYyA9IDA7XFxuXFx0ICAgICAgICBpZiAoY29sdW1uID09IG51bGwpIHtcXG5cXHQgICAgICAgICAgICBpID0gdG9rZW5zLmxlbmd0aCAtIDE7XFxuXFx0ICAgICAgICAgICAgYyA9IHRoaXMuZ2V0TGluZShyb3cpLmxlbmd0aDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgYyArPSB0b2tlbnNbaV0udmFsdWUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoYyA+PSBjb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcXG5cXHQgICAgICAgIGlmICghdG9rZW4pXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgICAgICB0b2tlbi5pbmRleCA9IGk7XFxuXFx0ICAgICAgICB0b2tlbi5zdGFydCA9IGMgLSB0b2tlbi52YWx1ZS5sZW5ndGg7XFxuXFx0ICAgICAgICByZXR1cm4gdG9rZW47XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VW5kb01hbmFnZXIgPSBmdW5jdGlvbih1bmRvTWFuYWdlcikge1xcblxcdCAgICAgICAgdGhpcy4kdW5kb01hbmFnZXIgPSB1bmRvTWFuYWdlcjtcXG5cXHQgICAgICAgIHRoaXMuJGRlbHRhcyA9IFtdO1xcblxcdCAgICAgICAgdGhpcy4kZGVsdGFzRG9jID0gW107XFxuXFx0ICAgICAgICB0aGlzLiRkZWx0YXNGb2xkID0gW107XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy4kaW5mb3JtVW5kb01hbmFnZXIpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kaW5mb3JtVW5kb01hbmFnZXIuY2FuY2VsKCk7XFxuXFxuXFx0ICAgICAgICBpZiAodW5kb01hbmFnZXIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuXFx0ICAgICAgICAgICAgdGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHNlbGYuJGluZm9ybVVuZG9NYW5hZ2VyLmNhbmNlbCgpO1xcblxcblxcdCAgICAgICAgICAgICAgICBpZiAoc2VsZi4kZGVsdGFzRm9sZC5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuJGRlbHRhcy5wdXNoKHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogXFxcImZvbGRcXFwiLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhczogc2VsZi4kZGVsdGFzRm9sZFxcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzZWxmLiRkZWx0YXNGb2xkID0gW107XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHNlbGYuJGRlbHRhc0RvYy5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuJGRlbHRhcy5wdXNoKHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBncm91cDogXFxcImRvY1xcXCIsXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFzOiBzZWxmLiRkZWx0YXNEb2NcXG5cXHQgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2VsZi4kZGVsdGFzRG9jID0gW107XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHNlbGYuJGRlbHRhcy5sZW5ndGggPiAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB1bmRvTWFuYWdlci5leGVjdXRlKHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFxcXCJhY2V1cGRhdGVcXFwiLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtzZWxmLiRkZWx0YXMsIHNlbGZdLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlOiBzZWxmLm1lcmdlVW5kb0RlbHRhc1xcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgc2VsZi5tZXJnZVVuZG9EZWx0YXMgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICAgICAgc2VsZi4kZGVsdGFzID0gW107XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRpbmZvcm1VbmRvTWFuYWdlciA9IGxhbmcuZGVsYXllZENhbGwodGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tYXJrVW5kb0dyb3VwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kc3luY0luZm9ybVVuZG9NYW5hZ2VyKVxcblxcdCAgICAgICAgICAgIHRoaXMuJHN5bmNJbmZvcm1VbmRvTWFuYWdlcigpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy4kZGVmYXVsdFVuZG9NYW5hZ2VyID0ge1xcblxcdCAgICAgICAgdW5kbzogZnVuY3Rpb24oKSB7fSxcXG5cXHQgICAgICAgIHJlZG86IGZ1bmN0aW9uKCkge30sXFxuXFx0ICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7fVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFVuZG9NYW5hZ2VyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kdW5kb01hbmFnZXIgfHwgdGhpcy4kZGVmYXVsdFVuZG9NYW5hZ2VyO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFRhYlN0cmluZyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuZ2V0VXNlU29mdFRhYnMoKSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiBsYW5nLnN0cmluZ1JlcGVhdChcXFwiIFxcXCIsIHRoaXMuZ2V0VGFiU2l6ZSgpKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFxcXCJcXFxcdFxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VXNlU29mdFRhYnMgPSBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJ1c2VTb2Z0VGFic1xcXCIsIHZhbCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0VXNlU29mdFRhYnMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiR1c2VTb2Z0VGFicyAmJiAhdGhpcy4kbW9kZS4kaW5kZW50V2l0aFRhYnM7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VGFiU2l6ZSA9IGZ1bmN0aW9uKHRhYlNpemUpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJ0YWJTaXplXFxcIiwgdGFiU2l6ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0VGFiU2l6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHRhYlNpemU7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaXNUYWJTdG9wID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiR1c2VTb2Z0VGFicyAmJiAocG9zaXRpb24uY29sdW1uICUgdGhpcy4kdGFiU2l6ZSA9PT0gMCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG92ZXJ3cml0ZSA9IGZhbHNlO1xcblxcdCAgICB0aGlzLnNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uKG92ZXJ3cml0ZSkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcIm92ZXJ3cml0ZVxcXCIsIG92ZXJ3cml0ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0T3ZlcndyaXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kb3ZlcndyaXRlO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnRvZ2dsZU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPdmVyd3JpdGUoIXRoaXMuJG92ZXJ3cml0ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYWRkR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGRlY29yYXRpb25zW3Jvd10pXFxuXFx0ICAgICAgICAgICAgdGhpcy4kZGVjb3JhdGlvbnNbcm93XSA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgdGhpcy4kZGVjb3JhdGlvbnNbcm93XSArPSBcXFwiIFxcXCIgKyBjbGFzc05hbWU7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZUJyZWFrcG9pbnRcXFwiLCB7fSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKSB7XFxuXFx0ICAgICAgICB0aGlzLiRkZWNvcmF0aW9uc1tyb3ddID0gKHRoaXMuJGRlY29yYXRpb25zW3Jvd10gfHwgXFxcIlxcXCIpLnJlcGxhY2UoXFxcIiBcXFwiICsgY2xhc3NOYW1lLCBcXFwiXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZUJyZWFrcG9pbnRcXFwiLCB7fSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0QnJlYWtwb2ludHMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRicmVha3BvaW50cztcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRCcmVha3BvaW50cyA9IGZ1bmN0aW9uKHJvd3MpIHtcXG5cXHQgICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzID0gW107XFxuXFx0ICAgICAgICBmb3IgKHZhciBpPTA7IGk8cm93cy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzW3Jvd3NbaV1dID0gXFxcImFjZV9icmVha3BvaW50XFxcIjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlQnJlYWtwb2ludFxcXCIsIHt9KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5jbGVhckJyZWFrcG9pbnRzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRicmVha3BvaW50cyA9IFtdO1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VCcmVha3BvaW50XFxcIiwge30pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldEJyZWFrcG9pbnQgPSBmdW5jdGlvbihyb3csIGNsYXNzTmFtZSkge1xcblxcdCAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKVxcblxcdCAgICAgICAgICAgIGNsYXNzTmFtZSA9IFxcXCJhY2VfYnJlYWtwb2ludFxcXCI7XFxuXFx0ICAgICAgICBpZiAoY2xhc3NOYW1lKVxcblxcdCAgICAgICAgICAgIHRoaXMuJGJyZWFrcG9pbnRzW3Jvd10gPSBjbGFzc05hbWU7XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuJGJyZWFrcG9pbnRzW3Jvd107XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZUJyZWFrcG9pbnRcXFwiLCB7fSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY2xlYXJCcmVha3BvaW50ID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICBkZWxldGUgdGhpcy4kYnJlYWtwb2ludHNbcm93XTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlQnJlYWtwb2ludFxcXCIsIHt9KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5hZGRNYXJrZXIgPSBmdW5jdGlvbihyYW5nZSwgY2xhenosIHR5cGUsIGluRnJvbnQpIHtcXG5cXHQgICAgICAgIHZhciBpZCA9IHRoaXMuJG1hcmtlcklkKys7XFxuXFxuXFx0ICAgICAgICB2YXIgbWFya2VyID0ge1xcblxcdCAgICAgICAgICAgIHJhbmdlIDogcmFuZ2UsXFxuXFx0ICAgICAgICAgICAgdHlwZSA6IHR5cGUgfHwgXFxcImxpbmVcXFwiLFxcblxcdCAgICAgICAgICAgIHJlbmRlcmVyOiB0eXBlb2YgdHlwZSA9PSBcXFwiZnVuY3Rpb25cXFwiID8gdHlwZSA6IG51bGwsXFxuXFx0ICAgICAgICAgICAgY2xhenogOiBjbGF6eixcXG5cXHQgICAgICAgICAgICBpbkZyb250OiAhIWluRnJvbnQsXFxuXFx0ICAgICAgICAgICAgaWQ6IGlkXFxuXFx0ICAgICAgICB9O1xcblxcblxcdCAgICAgICAgaWYgKGluRnJvbnQpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRmcm9udE1hcmtlcnNbaWRdID0gbWFya2VyO1xcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlRnJvbnRNYXJrZXJcXFwiKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kYmFja01hcmtlcnNbaWRdID0gbWFya2VyO1xcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlQmFja01hcmtlclxcXCIpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIGlkO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmFkZER5bmFtaWNNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXIsIGluRnJvbnQpIHtcXG5cXHQgICAgICAgIGlmICghbWFya2VyLnVwZGF0ZSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgaWQgPSB0aGlzLiRtYXJrZXJJZCsrO1xcblxcdCAgICAgICAgbWFya2VyLmlkID0gaWQ7XFxuXFx0ICAgICAgICBtYXJrZXIuaW5Gcm9udCA9ICEhaW5Gcm9udDtcXG5cXG5cXHQgICAgICAgIGlmIChpbkZyb250KSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kZnJvbnRNYXJrZXJzW2lkXSA9IG1hcmtlcjtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZUZyb250TWFya2VyXFxcIik7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGJhY2tNYXJrZXJzW2lkXSA9IG1hcmtlcjtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZUJhY2tNYXJrZXJcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBtYXJrZXI7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24obWFya2VySWQpIHtcXG5cXHQgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLiRmcm9udE1hcmtlcnNbbWFya2VySWRdIHx8IHRoaXMuJGJhY2tNYXJrZXJzW21hcmtlcklkXTtcXG5cXHQgICAgICAgIGlmICghbWFya2VyKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHZhciBtYXJrZXJzID0gbWFya2VyLmluRnJvbnQgPyB0aGlzLiRmcm9udE1hcmtlcnMgOiB0aGlzLiRiYWNrTWFya2VycztcXG5cXHQgICAgICAgIGlmIChtYXJrZXIpIHtcXG5cXHQgICAgICAgICAgICBkZWxldGUgKG1hcmtlcnNbbWFya2VySWRdKTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwobWFya2VyLmluRnJvbnQgPyBcXFwiY2hhbmdlRnJvbnRNYXJrZXJcXFwiIDogXFxcImNoYW5nZUJhY2tNYXJrZXJcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oaW5Gcm9udCkge1xcblxcdCAgICAgICAgcmV0dXJuIGluRnJvbnQgPyB0aGlzLiRmcm9udE1hcmtlcnMgOiB0aGlzLiRiYWNrTWFya2VycztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5oaWdobGlnaHQgPSBmdW5jdGlvbihyZSkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiRzZWFyY2hIaWdobGlnaHQpIHtcXG5cXHQgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gbmV3IFNlYXJjaEhpZ2hsaWdodChudWxsLCBcXFwiYWNlX3NlbGVjdGVkLXdvcmRcXFwiLCBcXFwidGV4dFxcXCIpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHNlYXJjaEhpZ2hsaWdodCA9IHRoaXMuYWRkRHluYW1pY01hcmtlcihoaWdobGlnaHQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy4kc2VhcmNoSGlnaGxpZ2h0LnNldFJlZ2V4cChyZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaGlnaGxpZ2h0TGluZXMgPSBmdW5jdGlvbihzdGFydFJvdywgZW5kUm93LCBjbGF6eiwgaW5Gcm9udCkge1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiBlbmRSb3cgIT0gXFxcIm51bWJlclxcXCIpIHtcXG5cXHQgICAgICAgICAgICBjbGF6eiA9IGVuZFJvdztcXG5cXHQgICAgICAgICAgICBlbmRSb3cgPSBzdGFydFJvdztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICghY2xhenopXFxuXFx0ICAgICAgICAgICAgY2xhenogPSBcXFwiYWNlX3N0ZXBcXFwiO1xcblxcblxcdCAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0Um93LCAwLCBlbmRSb3csIEluZmluaXR5KTtcXG5cXHQgICAgICAgIHJhbmdlLmlkID0gdGhpcy5hZGRNYXJrZXIocmFuZ2UsIGNsYXp6LCBcXFwiZnVsbExpbmVcXFwiLCBpbkZyb250KTtcXG5cXHQgICAgICAgIHJldHVybiByYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGFubm90YXRpb25zKSB7XFxuXFx0ICAgICAgICB0aGlzLiRhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VBbm5vdGF0aW9uXFxcIiwge30pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEFubm90YXRpb25zID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kYW5ub3RhdGlvbnMgfHwgW107XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5zZXRBbm5vdGF0aW9ucyhbXSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJGRldGVjdE5ld0xpbmUgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICB2YXIgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eLio/KFxcXFxyP1xcXFxuKS9tKTtcXG5cXHQgICAgICAgIGlmIChtYXRjaCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGF1dG9OZXdMaW5lID0gbWF0Y2hbMV07XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGF1dG9OZXdMaW5lID0gXFxcIlxcXFxuXFxcIjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRXb3JkUmFuZ2UgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUocm93KTtcXG5cXG5cXHQgICAgICAgIHZhciBpblRva2VuID0gZmFsc2U7XFxuXFx0ICAgICAgICBpZiAoY29sdW1uID4gMClcXG5cXHQgICAgICAgICAgICBpblRva2VuID0gISFsaW5lLmNoYXJBdChjb2x1bW4gLSAxKS5tYXRjaCh0aGlzLnRva2VuUmUpO1xcblxcblxcdCAgICAgICAgaWYgKCFpblRva2VuKVxcblxcdCAgICAgICAgICAgIGluVG9rZW4gPSAhIWxpbmUuY2hhckF0KGNvbHVtbikubWF0Y2godGhpcy50b2tlblJlKTtcXG5cXG5cXHQgICAgICAgIGlmIChpblRva2VuKVxcblxcdCAgICAgICAgICAgIHZhciByZSA9IHRoaXMudG9rZW5SZTtcXG5cXHQgICAgICAgIGVsc2UgaWYgKC9eXFxcXHMrJC8udGVzdChsaW5lLnNsaWNlKGNvbHVtbi0xLCBjb2x1bW4rMSkpKVxcblxcdCAgICAgICAgICAgIHZhciByZSA9IC9cXFxccy87XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgdmFyIHJlID0gdGhpcy5ub25Ub2tlblJlO1xcblxcblxcdCAgICAgICAgdmFyIHN0YXJ0ID0gY29sdW1uO1xcblxcdCAgICAgICAgaWYgKHN0YXJ0ID4gMCkge1xcblxcdCAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgc3RhcnQtLTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgd2hpbGUgKHN0YXJ0ID49IDAgJiYgbGluZS5jaGFyQXQoc3RhcnQpLm1hdGNoKHJlKSk7XFxuXFx0ICAgICAgICAgICAgc3RhcnQrKztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciBlbmQgPSBjb2x1bW47XFxuXFx0ICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgbGluZS5jaGFyQXQoZW5kKS5tYXRjaChyZSkpIHtcXG5cXHQgICAgICAgICAgICBlbmQrKztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uocm93LCBzdGFydCwgcm93LCBlbmQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEFXb3JkUmFuZ2UgPSBmdW5jdGlvbihyb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgdmFyIHdvcmRSYW5nZSA9IHRoaXMuZ2V0V29yZFJhbmdlKHJvdywgY29sdW1uKTtcXG5cXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKHdvcmRSYW5nZS5lbmQucm93KTtcXG5cXG5cXHQgICAgICAgIHdoaWxlIChsaW5lLmNoYXJBdCh3b3JkUmFuZ2UuZW5kLmNvbHVtbikubWF0Y2goL1sgXFxcXHRdLykpIHtcXG5cXHQgICAgICAgICAgICB3b3JkUmFuZ2UuZW5kLmNvbHVtbiArPSAxO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHdvcmRSYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXROZXdMaW5lTW9kZSA9IGZ1bmN0aW9uKG5ld0xpbmVNb2RlKSB7XFxuXFx0ICAgICAgICB0aGlzLmRvYy5zZXROZXdMaW5lTW9kZShuZXdMaW5lTW9kZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TmV3TGluZU1vZGUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXROZXdMaW5lTW9kZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFVzZVdvcmtlciA9IGZ1bmN0aW9uKHVzZVdvcmtlcikgeyB0aGlzLnNldE9wdGlvbihcXFwidXNlV29ya2VyXFxcIiwgdXNlV29ya2VyKTsgfTtcXG5cXHQgICAgdGhpcy5nZXRVc2VXb3JrZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuJHVzZVdvcmtlcjsgfTtcXG5cXHQgICAgdGhpcy5vblJlbG9hZFRva2VuaXplciA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHZhciByb3dzID0gZS5kYXRhO1xcblxcdCAgICAgICAgdGhpcy5iZ1Rva2VuaXplci5zdGFydChyb3dzLmZpcnN0KTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwidG9rZW5pemVyVXBkYXRlXFxcIiwgZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG1vZGVzID0ge307XFxuXFx0ICAgIHRoaXMuJG1vZGUgPSBudWxsO1xcblxcdCAgICB0aGlzLiRtb2RlSWQgPSBudWxsO1xcblxcdCAgICB0aGlzLnNldE1vZGUgPSBmdW5jdGlvbihtb2RlLCBjYikge1xcblxcdCAgICAgICAgaWYgKG1vZGUgJiYgdHlwZW9mIG1vZGUgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKG1vZGUuZ2V0VG9rZW5pemVyKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kb25DaGFuZ2VNb2RlKG1vZGUpO1xcblxcdCAgICAgICAgICAgIHZhciBvcHRpb25zID0gbW9kZTtcXG5cXHQgICAgICAgICAgICB2YXIgcGF0aCA9IG9wdGlvbnMucGF0aDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcGF0aCA9IG1vZGUgfHwgXFxcImFjZS9tb2RlL3RleHRcXFwiO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKCF0aGlzLiRtb2Rlc1tcXFwiYWNlL21vZGUvdGV4dFxcXCJdKVxcblxcdCAgICAgICAgICAgIHRoaXMuJG1vZGVzW1xcXCJhY2UvbW9kZS90ZXh0XFxcIl0gPSBuZXcgVGV4dE1vZGUoKTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLiRtb2Rlc1twYXRoXSAmJiAhb3B0aW9ucykge1xcblxcdCAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlTW9kZSh0aGlzLiRtb2Rlc1twYXRoXSk7XFxuXFx0ICAgICAgICAgICAgY2IgJiYgY2IoKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLiRtb2RlSWQgPSBwYXRoO1xcblxcdCAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoW1xcXCJtb2RlXFxcIiwgcGF0aF0sIGZ1bmN0aW9uKG0pIHtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kbW9kZUlkICE9PSBwYXRoKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoKTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kbW9kZXNbcGF0aF0gJiYgIW9wdGlvbnMpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRvbkNoYW5nZU1vZGUodGhpcy4kbW9kZXNbcGF0aF0pO1xcblxcdCAgICAgICAgICAgIGlmIChtICYmIG0uTW9kZSkge1xcblxcdCAgICAgICAgICAgICAgICBtID0gbmV3IG0uTW9kZShvcHRpb25zKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiRtb2Rlc1twYXRoXSA9IG07XFxuXFx0ICAgICAgICAgICAgICAgICAgICBtLiRpZCA9IHBhdGg7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKG0pO1xcblxcdCAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJG1vZGUpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlKHRoaXMuJG1vZGVzW1xcXCJhY2UvbW9kZS90ZXh0XFxcIl0sIHRydWUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRvbkNoYW5nZU1vZGUgPSBmdW5jdGlvbihtb2RlLCAkaXNQbGFjZWhvbGRlcikge1xcblxcdCAgICAgICAgaWYgKCEkaXNQbGFjZWhvbGRlcilcXG5cXHQgICAgICAgICAgICB0aGlzLiRtb2RlSWQgPSBtb2RlLiRpZDtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRtb2RlID09PSBtb2RlKSBcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB0aGlzLiRtb2RlID0gbW9kZTtcXG5cXG5cXHQgICAgICAgIHRoaXMuJHN0b3BXb3JrZXIoKTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLiR1c2VXb3JrZXIpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcXG5cXG5cXHQgICAgICAgIHZhciB0b2tlbml6ZXIgPSBtb2RlLmdldFRva2VuaXplcigpO1xcblxcblxcdCAgICAgICAgaWYodG9rZW5pemVyLmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgICAgIHZhciBvblJlbG9hZFRva2VuaXplciA9IHRoaXMub25SZWxvYWRUb2tlbml6ZXIuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICB0b2tlbml6ZXIuYWRkRXZlbnRMaXN0ZW5lcihcXFwidXBkYXRlXFxcIiwgb25SZWxvYWRUb2tlbml6ZXIpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKCF0aGlzLmJnVG9rZW5pemVyKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplciA9IG5ldyBCYWNrZ3JvdW5kVG9rZW5pemVyKHRva2VuaXplcik7XFxuXFx0ICAgICAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcXG5cXHQgICAgICAgICAgICB0aGlzLmJnVG9rZW5pemVyLmFkZEV2ZW50TGlzdGVuZXIoXFxcInVwZGF0ZVxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgX3NlbGYuX3NpZ25hbChcXFwidG9rZW5pemVyVXBkYXRlXFxcIiwgZSk7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0VG9rZW5pemVyKHRva2VuaXplcik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnNldERvY3VtZW50KHRoaXMuZ2V0RG9jdW1lbnQoKSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnRva2VuUmUgPSBtb2RlLnRva2VuUmU7XFxuXFx0ICAgICAgICB0aGlzLm5vblRva2VuUmUgPSBtb2RlLm5vblRva2VuUmU7XFxuXFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmICghJGlzUGxhY2Vob2xkZXIpIHtcXG5cXHQgICAgICAgICAgICBpZiAobW9kZS5hdHRhY2hUb1Nlc3Npb24pXFxuXFx0ICAgICAgICAgICAgICAgIG1vZGUuYXR0YWNoVG9TZXNzaW9uKHRoaXMpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJG9wdGlvbnMud3JhcE1ldGhvZC5zZXQuY2FsbCh0aGlzLCB0aGlzLiR3cmFwTWV0aG9kKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRzZXRGb2xkaW5nKG1vZGUuZm9sZGluZ1J1bGVzKTtcXG5cXHQgICAgICAgICAgICB0aGlzLmJnVG9rZW5pemVyLnN0YXJ0KDApO1xcblxcdCAgICAgICAgICAgIHRoaXMuX2VtaXQoXFxcImNoYW5nZU1vZGVcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kc3RvcFdvcmtlciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHdvcmtlcikge1xcblxcdCAgICAgICAgICAgIHRoaXMuJHdvcmtlci50ZXJtaW5hdGUoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSBudWxsO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRzdGFydFdvcmtlciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdHJ5IHtcXG5cXHQgICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSB0aGlzLiRtb2RlLmNyZWF0ZVdvcmtlcih0aGlzKTtcXG5cXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG5cXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkNvdWxkIG5vdCBsb2FkIHdvcmtlclxcXCIpO1xcblxcdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcXG5cXHQgICAgICAgICAgICB9ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJHdvcmtlciA9IG51bGw7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJG1vZGU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHNjcm9sbFRvcCA9IDA7XFxuXFx0ICAgIHRoaXMuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kc2Nyb2xsVG9wID09PSBzY3JvbGxUb3AgfHwgaXNOYU4oc2Nyb2xsVG9wKSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB0aGlzLiRzY3JvbGxUb3AgPSBzY3JvbGxUb3A7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVNjcm9sbFRvcFxcXCIsIHNjcm9sbFRvcCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kc2Nyb2xsVG9wO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRzY3JvbGxMZWZ0ID0gMDtcXG5cXHQgICAgdGhpcy5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24oc2Nyb2xsTGVmdCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHNjcm9sbExlZnQgPT09IHNjcm9sbExlZnQgfHwgaXNOYU4oc2Nyb2xsTGVmdCkpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdGhpcy4kc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVNjcm9sbExlZnRcXFwiLCBzY3JvbGxMZWZ0KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kc2Nyb2xsTGVmdDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTY3JlZW5XaWR0aCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kY29tcHV0ZVdpZHRoKCk7XFxuXFx0ICAgICAgICBpZiAodGhpcy5saW5lV2lkZ2V0cykgXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0TGluZVdpZGdldE1heFdpZHRoKCksIHRoaXMuc2NyZWVuV2lkdGgpO1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuV2lkdGg7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmdldExpbmVXaWRnZXRNYXhXaWR0aCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHNXaWR0aCAhPSBudWxsKSByZXR1cm4gdGhpcy5saW5lV2lkZ2V0c1dpZHRoO1xcblxcdCAgICAgICAgdmFyIHdpZHRoID0gMDtcXG5cXHQgICAgICAgIHRoaXMubGluZVdpZGdldHMuZm9yRWFjaChmdW5jdGlvbih3KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHcgJiYgdy5zY3JlZW5XaWR0aCA+IHdpZHRoKVxcblxcdCAgICAgICAgICAgICAgICB3aWR0aCA9IHcuc2NyZWVuV2lkdGg7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmxpbmVXaWRnZXRXaWR0aCA9IHdpZHRoO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRjb21wdXRlV2lkdGggPSBmdW5jdGlvbihmb3JjZSkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJG1vZGlmaWVkIHx8IGZvcmNlKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSBmYWxzZTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjcmVlbldpZHRoID0gdGhpcy4kd3JhcExpbWl0O1xcblxcblxcdCAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZG9jLmdldEFsbExpbmVzKCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGNhY2hlID0gdGhpcy4kcm93TGVuZ3RoQ2FjaGU7XFxuXFx0ICAgICAgICAgICAgdmFyIGxvbmdlc3RTY3JlZW5MaW5lID0gMDtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZEluZGV4ID0gMDtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLiRmb2xkRGF0YVtmb2xkSW5kZXhdO1xcblxcdCAgICAgICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xcblxcdCAgICAgICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XFxuXFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoaSA+IGZvbGRTdGFydCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaSA9IGZvbGRMaW5lLmVuZC5yb3cgKyAxO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gbGVuKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLiRmb2xkRGF0YVtmb2xkSW5kZXgrK107XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZVtpXSA9PSBudWxsKVxcblxcdCAgICAgICAgICAgICAgICAgICAgY2FjaGVbaV0gPSB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aChsaW5lc1tpXSlbMF07XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZVtpXSA+IGxvbmdlc3RTY3JlZW5MaW5lKVxcblxcdCAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdFNjcmVlbkxpbmUgPSBjYWNoZVtpXTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy5zY3JlZW5XaWR0aCA9IGxvbmdlc3RTY3JlZW5MaW5lO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldExpbmUgPSBmdW5jdGlvbihyb3cpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRMaW5lKHJvdyk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldExpbmVzKGZpcnN0Um93LCBsYXN0Um93KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvYy5nZXRMZW5ndGgoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRUZXh0UmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmdldFRleHRSYW5nZShyYW5nZSB8fCB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pbnNlcnQgPSBmdW5jdGlvbihwb3NpdGlvbiwgdGV4dCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZG9jLmluc2VydChwb3NpdGlvbiwgdGV4dCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24ocmFuZ2UpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvYy5yZW1vdmUocmFuZ2UpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnVuZG9DaGFuZ2VzID0gZnVuY3Rpb24oZGVsdGFzLCBkb250U2VsZWN0KSB7XFxuXFx0ICAgICAgICBpZiAoIWRlbHRhcy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSB0cnVlO1xcblxcdCAgICAgICAgdmFyIGxhc3RVbmRvUmFuZ2UgPSBudWxsO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IGRlbHRhcy5sZW5ndGggLSAxOyBpICE9IC0xOyBpLS0pIHtcXG5cXHQgICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKGRlbHRhLmdyb3VwID09IFxcXCJkb2NcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZG9jLnJldmVydERlbHRhcyhkZWx0YS5kZWx0YXMpO1xcblxcdCAgICAgICAgICAgICAgICBsYXN0VW5kb1JhbmdlID1cXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdldFVuZG9TZWxlY3Rpb24oZGVsdGEuZGVsdGFzLCB0cnVlLCBsYXN0VW5kb1JhbmdlKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBkZWx0YS5kZWx0YXMuZm9yRWFjaChmdW5jdGlvbihmb2xkRGVsdGEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRm9sZHMoZm9sZERlbHRhLmZvbGRzKTtcXG5cXHQgICAgICAgICAgICAgICAgfSwgdGhpcyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSBmYWxzZTtcXG5cXHQgICAgICAgIGxhc3RVbmRvUmFuZ2UgJiZcXG5cXHQgICAgICAgICAgICB0aGlzLiR1bmRvU2VsZWN0ICYmXFxuXFx0ICAgICAgICAgICAgIWRvbnRTZWxlY3QgJiZcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShsYXN0VW5kb1JhbmdlKTtcXG5cXHQgICAgICAgIHJldHVybiBsYXN0VW5kb1JhbmdlO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnJlZG9DaGFuZ2VzID0gZnVuY3Rpb24oZGVsdGFzLCBkb250U2VsZWN0KSB7XFxuXFx0ICAgICAgICBpZiAoIWRlbHRhcy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdGhpcy4kZnJvbVVuZG8gPSB0cnVlO1xcblxcdCAgICAgICAgdmFyIGxhc3RVbmRvUmFuZ2UgPSBudWxsO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKGRlbHRhLmdyb3VwID09IFxcXCJkb2NcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZG9jLmFwcGx5RGVsdGFzKGRlbHRhLmRlbHRhcyk7XFxuXFx0ICAgICAgICAgICAgICAgIGxhc3RVbmRvUmFuZ2UgPVxcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2V0VW5kb1NlbGVjdGlvbihkZWx0YS5kZWx0YXMsIGZhbHNlLCBsYXN0VW5kb1JhbmdlKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLiRmcm9tVW5kbyA9IGZhbHNlO1xcblxcdCAgICAgICAgbGFzdFVuZG9SYW5nZSAmJlxcblxcdCAgICAgICAgICAgIHRoaXMuJHVuZG9TZWxlY3QgJiZcXG5cXHQgICAgICAgICAgICAhZG9udFNlbGVjdCAmJlxcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKGxhc3RVbmRvUmFuZ2UpO1xcblxcdCAgICAgICAgcmV0dXJuIGxhc3RVbmRvUmFuZ2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VW5kb1NlbGVjdCA9IGZ1bmN0aW9uKGVuYWJsZSkge1xcblxcdCAgICAgICAgdGhpcy4kdW5kb1NlbGVjdCA9IGVuYWJsZTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kZ2V0VW5kb1NlbGVjdGlvbiA9IGZ1bmN0aW9uKGRlbHRhcywgaXNVbmRvLCBsYXN0VW5kb1JhbmdlKSB7XFxuXFx0ICAgICAgICBmdW5jdGlvbiBpc0luc2VydChkZWx0YSkge1xcblxcdCAgICAgICAgICAgIHZhciBpbnNlcnQgPVxcblxcdCAgICAgICAgICAgICAgICBkZWx0YS5hY3Rpb24gPT09IFxcXCJpbnNlcnRUZXh0XFxcIiB8fCBkZWx0YS5hY3Rpb24gPT09IFxcXCJpbnNlcnRMaW5lc1xcXCI7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGlzVW5kbyA/ICFpbnNlcnQgOiBpbnNlcnQ7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgZGVsdGEgPSBkZWx0YXNbMF07XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UsIHBvaW50O1xcblxcdCAgICAgICAgdmFyIGxhc3REZWx0YUlzSW5zZXJ0ID0gZmFsc2U7XFxuXFx0ICAgICAgICBpZiAoaXNJbnNlcnQoZGVsdGEpKSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnJhbmdlLnN0YXJ0LCBkZWx0YS5yYW5nZS5lbmQpO1xcblxcdCAgICAgICAgICAgIGxhc3REZWx0YUlzSW5zZXJ0ID0gdHJ1ZTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnJhbmdlLnN0YXJ0LCBkZWx0YS5yYW5nZS5zdGFydCk7XFxuXFx0ICAgICAgICAgICAgbGFzdERlbHRhSXNJbnNlcnQgPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgZGVsdGEgPSBkZWx0YXNbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKGlzSW5zZXJ0KGRlbHRhKSkge1xcblxcdCAgICAgICAgICAgICAgICBwb2ludCA9IGRlbHRhLnJhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZShwb2ludC5yb3csIHBvaW50LmNvbHVtbikgPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGRlbHRhLnJhbmdlLnN0YXJ0KTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBwb2ludCA9IGRlbHRhLnJhbmdlLmVuZDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmNvbXBhcmUocG9pbnQucm93LCBwb2ludC5jb2x1bW4pID09IDEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChkZWx0YS5yYW5nZS5lbmQpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGxhc3REZWx0YUlzSW5zZXJ0ID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBwb2ludCA9IGRlbHRhLnJhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgICAgICAgICBpZiAocmFuZ2UuY29tcGFyZShwb2ludC5yb3csIHBvaW50LmNvbHVtbikgPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlID1cXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBSYW5nZS5mcm9tUG9pbnRzKGRlbHRhLnJhbmdlLnN0YXJ0LCBkZWx0YS5yYW5nZS5zdGFydCk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgbGFzdERlbHRhSXNJbnNlcnQgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAobGFzdFVuZG9SYW5nZSAhPSBudWxsKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKFJhbmdlLmNvbXBhcmVQb2ludHMobGFzdFVuZG9SYW5nZS5zdGFydCwgcmFuZ2Uuc3RhcnQpID09PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGxhc3RVbmRvUmFuZ2Uuc3RhcnQuY29sdW1uICs9IHJhbmdlLmVuZC5jb2x1bW4gLSByYW5nZS5zdGFydC5jb2x1bW47XFxuXFx0ICAgICAgICAgICAgICAgIGxhc3RVbmRvUmFuZ2UuZW5kLmNvbHVtbiArPSByYW5nZS5lbmQuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICB2YXIgY21wID0gbGFzdFVuZG9SYW5nZS5jb21wYXJlUmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgICAgIGlmIChjbXAgPT0gMSkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChsYXN0VW5kb1JhbmdlLnN0YXJ0KTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQobGFzdFVuZG9SYW5nZS5lbmQpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiByYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24ocmFuZ2UsIHRleHQpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvYy5yZXBsYWNlKHJhbmdlLCB0ZXh0KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tb3ZlVGV4dCA9IGZ1bmN0aW9uKGZyb21SYW5nZSwgdG9Qb3NpdGlvbiwgY29weSkge1xcblxcdCAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldFRleHRSYW5nZShmcm9tUmFuZ2UpO1xcblxcdCAgICAgICAgdmFyIGZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZnJvbVJhbmdlKTtcXG5cXG5cXHQgICAgICAgIHZhciB0b1JhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyh0b1Bvc2l0aW9uLCB0b1Bvc2l0aW9uKTtcXG5cXHQgICAgICAgIGlmICghY29weSkge1xcblxcdCAgICAgICAgICAgIHRoaXMucmVtb3ZlKGZyb21SYW5nZSk7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvd0RpZmYgPSBmcm9tUmFuZ2Uuc3RhcnQucm93IC0gZnJvbVJhbmdlLmVuZC5yb3c7XFxuXFx0ICAgICAgICAgICAgdmFyIGNvbGxEaWZmID0gcm93RGlmZiA/IC1mcm9tUmFuZ2UuZW5kLmNvbHVtbiA6IGZyb21SYW5nZS5zdGFydC5jb2x1bW4gLSBmcm9tUmFuZ2UuZW5kLmNvbHVtbjtcXG5cXHQgICAgICAgICAgICBpZiAoY29sbERpZmYpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHRvUmFuZ2Uuc3RhcnQucm93ID09IGZyb21SYW5nZS5lbmQucm93ICYmIHRvUmFuZ2Uuc3RhcnQuY29sdW1uID4gZnJvbVJhbmdlLmVuZC5jb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b1JhbmdlLnN0YXJ0LmNvbHVtbiArPSBjb2xsRGlmZjtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHRvUmFuZ2UuZW5kLnJvdyA9PSBmcm9tUmFuZ2UuZW5kLnJvdyAmJiB0b1JhbmdlLmVuZC5jb2x1bW4gPiBmcm9tUmFuZ2UuZW5kLmNvbHVtbilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRvUmFuZ2UuZW5kLmNvbHVtbiArPSBjb2xsRGlmZjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKHJvd0RpZmYgJiYgdG9SYW5nZS5zdGFydC5yb3cgPj0gZnJvbVJhbmdlLmVuZC5yb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgdG9SYW5nZS5zdGFydC5yb3cgKz0gcm93RGlmZjtcXG5cXHQgICAgICAgICAgICAgICAgdG9SYW5nZS5lbmQucm93ICs9IHJvd0RpZmY7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdG9SYW5nZS5lbmQgPSB0aGlzLmluc2VydCh0b1JhbmdlLnN0YXJ0LCB0ZXh0KTtcXG5cXHQgICAgICAgIGlmIChmb2xkcy5sZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICB2YXIgb2xkU3RhcnQgPSBmcm9tUmFuZ2Uuc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gdG9SYW5nZS5zdGFydDtcXG5cXHQgICAgICAgICAgICB2YXIgcm93RGlmZiA9IG5ld1N0YXJ0LnJvdyAtIG9sZFN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgY29sbERpZmYgPSBuZXdTdGFydC5jb2x1bW4gLSBvbGRTdGFydC5jb2x1bW47XFxuXFx0ICAgICAgICAgICAgdGhpcy5hZGRGb2xkcyhmb2xkcy5tYXAoZnVuY3Rpb24oeCkge1xcblxcdCAgICAgICAgICAgICAgICB4ID0geC5jbG9uZSgpO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoeC5zdGFydC5yb3cgPT0gb2xkU3RhcnQucm93KVxcblxcdCAgICAgICAgICAgICAgICAgICAgeC5zdGFydC5jb2x1bW4gKz0gY29sbERpZmY7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh4LmVuZC5yb3cgPT0gb2xkU3RhcnQucm93KVxcblxcdCAgICAgICAgICAgICAgICAgICAgeC5lbmQuY29sdW1uICs9IGNvbGxEaWZmO1xcblxcdCAgICAgICAgICAgICAgICB4LnN0YXJ0LnJvdyArPSByb3dEaWZmO1xcblxcdCAgICAgICAgICAgICAgICB4LmVuZC5yb3cgKz0gcm93RGlmZjtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHg7XFxuXFx0ICAgICAgICAgICAgfSkpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIHRvUmFuZ2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaW5kZW50Um93cyA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBlbmRSb3csIGluZGVudFN0cmluZykge1xcblxcdCAgICAgICAgaW5kZW50U3RyaW5nID0gaW5kZW50U3RyaW5nLnJlcGxhY2UoL1xcXFx0L2csIHRoaXMuZ2V0VGFiU3RyaW5nKCkpO1xcblxcdCAgICAgICAgZm9yICh2YXIgcm93PXN0YXJ0Um93OyByb3c8PWVuZFJvdzsgcm93KyspXFxuXFx0ICAgICAgICAgICAgdGhpcy5pbnNlcnQoe3Jvdzogcm93LCBjb2x1bW46MH0sIGluZGVudFN0cmluZyk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMub3V0ZGVudFJvd3MgPSBmdW5jdGlvbiAocmFuZ2UpIHtcXG5cXHQgICAgICAgIHZhciByb3dSYW5nZSA9IHJhbmdlLmNvbGxhcHNlUm93cygpO1xcblxcdCAgICAgICAgdmFyIGRlbGV0ZVJhbmdlID0gbmV3IFJhbmdlKDAsIDAsIDAsIDApO1xcblxcdCAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRhYlNpemUoKTtcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSByb3dSYW5nZS5zdGFydC5yb3c7IGkgPD0gcm93UmFuZ2UuZW5kLnJvdzsgKytpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUoaSk7XFxuXFxuXFx0ICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQucm93ID0gaTtcXG5cXHQgICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQucm93ID0gaTtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemU7ICsrailcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGxpbmUuY2hhckF0KGopICE9ICcgJylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIGlmIChqIDwgc2l6ZSAmJiBsaW5lLmNoYXJBdChqKSA9PSAnXFxcXHQnKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlLnN0YXJ0LmNvbHVtbiA9IGo7XFxuXFx0ICAgICAgICAgICAgICAgIGRlbGV0ZVJhbmdlLmVuZC5jb2x1bW4gPSBqICsgMTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBkZWxldGVSYW5nZS5zdGFydC5jb2x1bW4gPSAwO1xcblxcdCAgICAgICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQuY29sdW1uID0gajtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW1vdmUoZGVsZXRlUmFuZ2UpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRtb3ZlTGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdywgZGlyKSB7XFxuXFx0ICAgICAgICBmaXJzdFJvdyA9IHRoaXMuZ2V0Um93Rm9sZFN0YXJ0KGZpcnN0Um93KTtcXG5cXHQgICAgICAgIGxhc3RSb3cgPSB0aGlzLmdldFJvd0ZvbGRFbmQobGFzdFJvdyk7XFxuXFx0ICAgICAgICBpZiAoZGlyIDwgMCkge1xcblxcdCAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvd0ZvbGRTdGFydChmaXJzdFJvdyArIGRpcik7XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA8IDApIHJldHVybiAwO1xcblxcdCAgICAgICAgICAgIHZhciBkaWZmID0gcm93LWZpcnN0Um93O1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChkaXIgPiAwKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93Rm9sZEVuZChsYXN0Um93ICsgZGlyKTtcXG5cXHQgICAgICAgICAgICBpZiAocm93ID4gdGhpcy5kb2MuZ2V0TGVuZ3RoKCktMSkgcmV0dXJuIDA7XFxuXFx0ICAgICAgICAgICAgdmFyIGRpZmYgPSByb3ctbGFzdFJvdztcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgZmlyc3RSb3cgPSB0aGlzLiRjbGlwUm93VG9Eb2N1bWVudChmaXJzdFJvdyk7XFxuXFx0ICAgICAgICAgICAgbGFzdFJvdyA9IHRoaXMuJGNsaXBSb3dUb0RvY3VtZW50KGxhc3RSb3cpO1xcblxcdCAgICAgICAgICAgIHZhciBkaWZmID0gbGFzdFJvdyAtIGZpcnN0Um93ICsgMTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShmaXJzdFJvdywgMCwgbGFzdFJvdywgTnVtYmVyLk1BWF9WQUxVRSk7XFxuXFx0ICAgICAgICB2YXIgZm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShyYW5nZSkubWFwKGZ1bmN0aW9uKHgpe1xcblxcdCAgICAgICAgICAgIHggPSB4LmNsb25lKCk7XFxuXFx0ICAgICAgICAgICAgeC5zdGFydC5yb3cgKz0gZGlmZjtcXG5cXHQgICAgICAgICAgICB4LmVuZC5yb3cgKz0gZGlmZjtcXG5cXHQgICAgICAgICAgICByZXR1cm4geDtcXG5cXHQgICAgICAgIH0pO1xcblxcblxcdCAgICAgICAgdmFyIGxpbmVzID0gZGlyID09IDBcXG5cXHQgICAgICAgICAgICA/IHRoaXMuZG9jLmdldExpbmVzKGZpcnN0Um93LCBsYXN0Um93KVxcblxcdCAgICAgICAgICAgIDogdGhpcy5kb2MucmVtb3ZlTGluZXMoZmlyc3RSb3csIGxhc3RSb3cpO1xcblxcdCAgICAgICAgdGhpcy5kb2MuaW5zZXJ0TGluZXMoZmlyc3RSb3crZGlmZiwgbGluZXMpO1xcblxcdCAgICAgICAgZm9sZHMubGVuZ3RoICYmIHRoaXMuYWRkRm9sZHMoZm9sZHMpO1xcblxcdCAgICAgICAgcmV0dXJuIGRpZmY7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUxpbmVzVXAgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJG1vdmVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdywgLTEpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVMaW5lc0Rvd24gPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJG1vdmVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdywgMSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZHVwbGljYXRlTGluZXMgPSBmdW5jdGlvbihmaXJzdFJvdywgbGFzdFJvdykge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJG1vdmVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdywgMCk7XFxuXFx0ICAgIH07XFxuXFxuXFxuXFx0ICAgIHRoaXMuJGNsaXBSb3dUb0RvY3VtZW50ID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm93LCB0aGlzLmRvYy5nZXRMZW5ndGgoKS0xKSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGNsaXBDb2x1bW5Ub1JvdyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAoY29sdW1uIDwgMClcXG5cXHQgICAgICAgICAgICByZXR1cm4gMDtcXG5cXHQgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmRvYy5nZXRMaW5lKHJvdykubGVuZ3RoLCBjb2x1bW4pO1xcblxcdCAgICB9O1xcblxcblxcblxcdCAgICB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIGNvbHVtbiA9IE1hdGgubWF4KDAsIGNvbHVtbik7XFxuXFxuXFx0ICAgICAgICBpZiAocm93IDwgMCkge1xcblxcdCAgICAgICAgICAgIHJvdyA9IDA7XFxuXFx0ICAgICAgICAgICAgY29sdW1uID0gMDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuZG9jLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgICAgIGlmIChyb3cgPj0gbGVuKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyA9IGxlbiAtIDE7XFxuXFx0ICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuZG9jLmdldExpbmUobGVuLTEpLmxlbmd0aDtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLm1pbih0aGlzLmRvYy5nZXRMaW5lKHJvdykubGVuZ3RoLCBjb2x1bW4pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgcm93OiByb3csXFxuXFx0ICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cXG5cXHQgICAgICAgIH07XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGNsaXBSYW5nZVRvRG9jdW1lbnQgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA8IDApIHtcXG5cXHQgICAgICAgICAgICByYW5nZS5zdGFydC5yb3cgPSAwO1xcblxcdCAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IDA7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHRoaXMuJGNsaXBDb2x1bW5Ub1JvdyhcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93LFxcblxcdCAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW5cXG5cXHQgICAgICAgICAgICApO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGxlbiA9IHRoaXMuZG9jLmdldExlbmd0aCgpIC0gMTtcXG5cXHQgICAgICAgIGlmIChyYW5nZS5lbmQucm93ID4gbGVuKSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IGxlbjtcXG5cXHQgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gdGhpcy5kb2MuZ2V0TGluZShsZW4pLmxlbmd0aDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IHRoaXMuJGNsaXBDb2x1bW5Ub1JvdyhcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyxcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtblxcblxcdCAgICAgICAgICAgICk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gcmFuZ2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJHdyYXBMaW1pdCA9IDgwO1xcblxcdCAgICB0aGlzLiR1c2VXcmFwTW9kZSA9IGZhbHNlO1xcblxcdCAgICB0aGlzLiR3cmFwTGltaXRSYW5nZSA9IHtcXG5cXHQgICAgICAgIG1pbiA6IG51bGwsXFxuXFx0ICAgICAgICBtYXggOiBudWxsXFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VXNlV3JhcE1vZGUgPSBmdW5jdGlvbih1c2VXcmFwTW9kZSkge1xcblxcdCAgICAgICAgaWYgKHVzZVdyYXBNb2RlICE9IHRoaXMuJHVzZVdyYXBNb2RlKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kdXNlV3JhcE1vZGUgPSB1c2VXcmFwTW9kZTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRtb2RpZmllZCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kcmVzZXRSb3dDYWNoZSgwKTtcXG5cXHQgICAgICAgICAgICBpZiAodXNlV3JhcE1vZGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJHdyYXBEYXRhID0gQXJyYXkobGVuKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoMCwgbGVuIC0gMSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlV3JhcE1vZGVcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRVc2VXcmFwTW9kZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHVzZVdyYXBNb2RlO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFdyYXBMaW1pdFJhbmdlID0gZnVuY3Rpb24obWluLCBtYXgpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiR3cmFwTGltaXRSYW5nZS5taW4gIT09IG1pbiB8fCB0aGlzLiR3cmFwTGltaXRSYW5nZS5tYXggIT09IG1heCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJHdyYXBMaW1pdFJhbmdlID0ge1xcblxcdCAgICAgICAgICAgICAgICBtaW46IG1pbixcXG5cXHQgICAgICAgICAgICAgICAgbWF4OiBtYXhcXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVdyYXBNb2RlXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYWRqdXN0V3JhcExpbWl0ID0gZnVuY3Rpb24oZGVzaXJlZExpbWl0LCAkcHJpbnRNYXJnaW4pIHtcXG5cXHQgICAgICAgIHZhciBsaW1pdHMgPSB0aGlzLiR3cmFwTGltaXRSYW5nZTtcXG5cXHQgICAgICAgIGlmIChsaW1pdHMubWF4IDwgMClcXG5cXHQgICAgICAgICAgICBsaW1pdHMgPSB7bWluOiAkcHJpbnRNYXJnaW4sIG1heDogJHByaW50TWFyZ2lufTtcXG5cXHQgICAgICAgIHZhciB3cmFwTGltaXQgPSB0aGlzLiRjb25zdHJhaW5XcmFwTGltaXQoZGVzaXJlZExpbWl0LCBsaW1pdHMubWluLCBsaW1pdHMubWF4KTtcXG5cXHQgICAgICAgIGlmICh3cmFwTGltaXQgIT0gdGhpcy4kd3JhcExpbWl0ICYmIHdyYXBMaW1pdCA+IDEpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiR3cmFwTGltaXQgPSB3cmFwTGltaXQ7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbW9kaWZpZWQgPSB0cnVlO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiR1c2VXcmFwTW9kZSkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YSgwLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlV3JhcExpbWl0XFxcIik7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRjb25zdHJhaW5XcmFwTGltaXQgPSBmdW5jdGlvbih3cmFwTGltaXQsIG1pbiwgbWF4KSB7XFxuXFx0ICAgICAgICBpZiAobWluKVxcblxcdCAgICAgICAgICAgIHdyYXBMaW1pdCA9IE1hdGgubWF4KG1pbiwgd3JhcExpbWl0KTtcXG5cXG5cXHQgICAgICAgIGlmIChtYXgpXFxuXFx0ICAgICAgICAgICAgd3JhcExpbWl0ID0gTWF0aC5taW4obWF4LCB3cmFwTGltaXQpO1xcblxcblxcdCAgICAgICAgcmV0dXJuIHdyYXBMaW1pdDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRXcmFwTGltaXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiR3cmFwTGltaXQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0V3JhcExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XFxuXFx0ICAgICAgICB0aGlzLnNldFdyYXBMaW1pdFJhbmdlKGxpbWl0LCBsaW1pdCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0V3JhcExpbWl0UmFuZ2UgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgbWluIDogdGhpcy4kd3JhcExpbWl0UmFuZ2UubWluLFxcblxcdCAgICAgICAgICAgIG1heCA6IHRoaXMuJHdyYXBMaW1pdFJhbmdlLm1heFxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kdXBkYXRlSW50ZXJuYWxEYXRhT25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICB2YXIgdXNlV3JhcE1vZGUgPSB0aGlzLiR1c2VXcmFwTW9kZTtcXG5cXHQgICAgICAgIHZhciBsZW47XFxuXFx0ICAgICAgICB2YXIgYWN0aW9uID0gZS5kYXRhLmFjdGlvbjtcXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IGUuZGF0YS5yYW5nZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICB2YXIgbGFzdFJvdyA9IGUuZGF0YS5yYW5nZS5lbmQucm93O1xcblxcdCAgICAgICAgdmFyIHN0YXJ0ID0gZS5kYXRhLnJhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgdmFyIGVuZCA9IGUuZGF0YS5yYW5nZS5lbmQ7XFxuXFx0ICAgICAgICB2YXIgcmVtb3ZlZEZvbGRzID0gbnVsbDtcXG5cXG5cXHQgICAgICAgIGlmIChhY3Rpb24uaW5kZXhPZihcXFwiTGluZXNcXFwiKSAhPSAtMSkge1xcblxcdCAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXFxcImluc2VydExpbmVzXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICBsYXN0Um93ID0gZmlyc3RSb3cgKyAoZS5kYXRhLmxpbmVzLmxlbmd0aCk7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgbGFzdFJvdyA9IGZpcnN0Um93O1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBsZW4gPSBlLmRhdGEubGluZXMgPyBlLmRhdGEubGluZXMubGVuZ3RoIDogbGFzdFJvdyAtIGZpcnN0Um93O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBsZW4gPSBsYXN0Um93IC0gZmlyc3RSb3c7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLiR1cGRhdGluZyA9IHRydWU7XFxuXFx0ICAgICAgICBpZiAobGVuICE9IDApIHtcXG5cXHQgICAgICAgICAgICBpZiAoYWN0aW9uLmluZGV4T2YoXFxcInJlbW92ZVxcXCIpICE9IC0xKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXNbdXNlV3JhcE1vZGUgPyBcXFwiJHdyYXBEYXRhXFxcIiA6IFxcXCIkcm93TGVuZ3RoQ2FjaGVcXFwiXS5zcGxpY2UoZmlyc3RSb3csIGxlbik7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZXMgPSB0aGlzLiRmb2xkRGF0YTtcXG5cXHQgICAgICAgICAgICAgICAgcmVtb3ZlZEZvbGRzID0gdGhpcy5nZXRGb2xkc0luUmFuZ2UoZS5kYXRhLnJhbmdlKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGb2xkcyhyZW1vdmVkRm9sZHMpO1xcblxcblxcdCAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGVuZC5yb3cpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgaWR4ID0gMDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRSZW1vdmVDaGFycyhlbmQucm93LCBlbmQuY29sdW1uLCBzdGFydC5jb2x1bW4gLSBlbmQuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KC1sZW4pO1xcblxcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lQmVmb3JlID0gdGhpcy5nZXRGb2xkTGluZShmaXJzdFJvdyk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmVCZWZvcmUgJiYgZm9sZExpbmVCZWZvcmUgIT09IGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmVCZWZvcmUubWVyZ2UoZm9sZExpbmUpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gZm9sZExpbmVCZWZvcmU7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZHggPSBmb2xkTGluZXMuaW5kZXhPZihmb2xkTGluZSkgKyAxO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGZvciAoaWR4OyBpZHggPCBmb2xkTGluZXMubGVuZ3RoOyBpZHgrKykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gZm9sZExpbmVzW2lkeF07XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZExpbmUuc3RhcnQucm93ID49IGVuZC5yb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdygtbGVuKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICBsYXN0Um93ID0gZmlyc3RSb3c7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW4pO1xcblxcdCAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoZmlyc3RSb3csIDApO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgYXJyID0gdXNlV3JhcE1vZGUgPyB0aGlzLiR3cmFwRGF0YSA6IHRoaXMuJHJvd0xlbmd0aENhY2hlXFxuXFx0ICAgICAgICAgICAgICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBhcmdzKTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGZvbGRMaW5lcyA9IHRoaXMuJGZvbGREYXRhO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLmdldEZvbGRMaW5lKGZpcnN0Um93KTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGlkeCA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGNtcCA9IGZvbGRMaW5lLnJhbmdlLmNvbXBhcmVJbnNpZGUoc3RhcnQucm93LCBzdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSBmb2xkTGluZS5zcGxpdChzdGFydC5yb3csIHN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KGxlbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZFJlbW92ZUNoYXJzKGxhc3RSb3csIDAsIGVuZC5jb2x1bW4gLSBzdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLmFkZFJlbW92ZUNoYXJzKGZpcnN0Um93LCAwLCBlbmQuY29sdW1uIC0gc3RhcnQuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5zaGlmdFJvdyhsZW4pO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgaWR4ID0gZm9sZExpbmVzLmluZGV4T2YoZm9sZExpbmUpICsgMTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICBmb3IgKGlkeDsgaWR4IDwgZm9sZExpbmVzLmxlbmd0aDsgaWR4KyspIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IGZvbGRMaW5lc1tpZHhdO1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRMaW5lLnN0YXJ0LnJvdyA+PSBmaXJzdFJvdykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGZvbGRMaW5lLnNoaWZ0Um93KGxlbik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGxlbiA9IE1hdGguYWJzKGUuZGF0YS5yYW5nZS5zdGFydC5jb2x1bW4gLSBlLmRhdGEucmFuZ2UuZW5kLmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgaWYgKGFjdGlvbi5pbmRleE9mKFxcXCJyZW1vdmVcXFwiKSAhPSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICByZW1vdmVkRm9sZHMgPSB0aGlzLmdldEZvbGRzSW5SYW5nZShlLmRhdGEucmFuZ2UpO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZvbGRzKHJlbW92ZWRGb2xkcyk7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGxlbiA9IC1sZW47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChmb2xkTGluZSkge1xcblxcdCAgICAgICAgICAgICAgICBmb2xkTGluZS5hZGRSZW1vdmVDaGFycyhmaXJzdFJvdywgc3RhcnQuY29sdW1uLCBsZW4pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmICh1c2VXcmFwTW9kZSAmJiB0aGlzLiR3cmFwRGF0YS5sZW5ndGggIT0gdGhpcy5kb2MuZ2V0TGVuZ3RoKCkpIHtcXG5cXHQgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJkb2MuZ2V0TGVuZ3RoKCkgYW5kICR3cmFwRGF0YS5sZW5ndGggaGF2ZSB0byBiZSB0aGUgc2FtZSFcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuJHVwZGF0aW5nID0gZmFsc2U7XFxuXFxuXFx0ICAgICAgICBpZiAodXNlV3JhcE1vZGUpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kdXBkYXRlV3JhcERhdGEoZmlyc3RSb3csIGxhc3RSb3cpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMuJHVwZGF0ZVJvd0xlbmd0aENhY2hlKGZpcnN0Um93LCBsYXN0Um93KTtcXG5cXG5cXHQgICAgICAgIHJldHVybiByZW1vdmVkRm9sZHM7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZVJvd0xlbmd0aENhY2hlID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3csIGIpIHtcXG5cXHQgICAgICAgIHRoaXMuJHJvd0xlbmd0aENhY2hlW2ZpcnN0Um93XSA9IG51bGw7XFxuXFx0ICAgICAgICB0aGlzLiRyb3dMZW5ndGhDYWNoZVtsYXN0Um93XSA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZVdyYXBEYXRhID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcXG5cXHQgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuZG9jLmdldEFsbExpbmVzKCk7XFxuXFx0ICAgICAgICB2YXIgdGFiU2l6ZSA9IHRoaXMuZ2V0VGFiU2l6ZSgpO1xcblxcdCAgICAgICAgdmFyIHdyYXBEYXRhID0gdGhpcy4kd3JhcERhdGE7XFxuXFx0ICAgICAgICB2YXIgd3JhcExpbWl0ID0gdGhpcy4kd3JhcExpbWl0O1xcblxcdCAgICAgICAgdmFyIHRva2VucztcXG5cXHQgICAgICAgIHZhciBmb2xkTGluZTtcXG5cXG5cXHQgICAgICAgIHZhciByb3cgPSBmaXJzdFJvdztcXG5cXHQgICAgICAgIGxhc3RSb3cgPSBNYXRoLm1pbihsYXN0Um93LCBsaW5lcy5sZW5ndGggLSAxKTtcXG5cXHQgICAgICAgIHdoaWxlIChyb3cgPD0gbGFzdFJvdykge1xcblxcdCAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5nZXRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcXG5cXHQgICAgICAgICAgICBpZiAoIWZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRva2VucyA9IHRoaXMuJGdldERpc3BsYXlUb2tlbnMobGluZXNbcm93XSk7XFxuXFx0ICAgICAgICAgICAgICAgIHdyYXBEYXRhW3Jvd10gPSB0aGlzLiRjb21wdXRlV3JhcFNwbGl0cyh0b2tlbnMsIHdyYXBMaW1pdCwgdGFiU2l6ZSk7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyArKztcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXTtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZExpbmUud2FsayhmdW5jdGlvbihwbGFjZWhvbGRlciwgcm93LCBjb2x1bW4sIGxhc3RDb2x1bW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2Fsa1Rva2VucztcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrVG9rZW5zID0gdGhpcy4kZ2V0RGlzcGxheVRva2VucyhcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLCB0b2tlbnMubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1Rva2Vuc1swXSA9IFBMQUNFSE9MREVSX1NUQVJUO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHdhbGtUb2tlbnMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtUb2tlbnNbaV0gPSBQTEFDRUhPTERFUl9CT0RZO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fsa1Rva2VucyA9IHRoaXMuJGdldERpc3BsYXlUb2tlbnMoXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tyb3ddLnN1YnN0cmluZyhsYXN0Q29sdW1uLCBjb2x1bW4pLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQod2Fsa1Rva2Vucyk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb2xkTGluZS5lbmQucm93LFxcblxcdCAgICAgICAgICAgICAgICAgICAgbGluZXNbZm9sZExpbmUuZW5kLnJvd10ubGVuZ3RoICsgMVxcblxcdCAgICAgICAgICAgICAgICApO1xcblxcblxcdCAgICAgICAgICAgICAgICB3cmFwRGF0YVtmb2xkTGluZS5zdGFydC5yb3ddID0gdGhpcy4kY29tcHV0ZVdyYXBTcGxpdHModG9rZW5zLCB3cmFwTGltaXQsIHRhYlNpemUpO1xcblxcdCAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93ICsgMTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHZhciBDSEFSID0gMSxcXG5cXHQgICAgICAgIENIQVJfRVhUID0gMixcXG5cXHQgICAgICAgIFBMQUNFSE9MREVSX1NUQVJUID0gMyxcXG5cXHQgICAgICAgIFBMQUNFSE9MREVSX0JPRFkgPSAgNCxcXG5cXHQgICAgICAgIFBVTkNUVUFUSU9OID0gOSxcXG5cXHQgICAgICAgIFNQQUNFID0gMTAsXFxuXFx0ICAgICAgICBUQUIgPSAxMSxcXG5cXHQgICAgICAgIFRBQl9TUEFDRSA9IDEyO1xcblxcblxcblxcdCAgICB0aGlzLiRjb21wdXRlV3JhcFNwbGl0cyA9IGZ1bmN0aW9uKHRva2Vucywgd3JhcExpbWl0KSB7XFxuXFx0ICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIHNwbGl0cyA9IFtdO1xcblxcdCAgICAgICAgdmFyIGRpc3BsYXlMZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xcblxcdCAgICAgICAgdmFyIGxhc3RTcGxpdCA9IDAsIGxhc3REb2NTcGxpdCA9IDA7XFxuXFxuXFx0ICAgICAgICB2YXIgaXNDb2RlID0gdGhpcy4kd3JhcEFzQ29kZTtcXG5cXG5cXHQgICAgICAgIGZ1bmN0aW9uIGFkZFNwbGl0KHNjcmVlblBvcykge1xcblxcdCAgICAgICAgICAgIHZhciBkaXNwbGF5ZWQgPSB0b2tlbnMuc2xpY2UobGFzdFNwbGl0LCBzY3JlZW5Qb3MpO1xcblxcdCAgICAgICAgICAgIHZhciBsZW4gPSBkaXNwbGF5ZWQubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIGRpc3BsYXllZC5qb2luKFxcXCJcXFwiKS5cXG5cXHQgICAgICAgICAgICAgICAgcmVwbGFjZSgvMTIvZywgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMTtcXG5cXHQgICAgICAgICAgICAgICAgfSkuXFxuXFx0ICAgICAgICAgICAgICAgIHJlcGxhY2UoLzIvZywgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBsZW4gLT0gMTtcXG5cXHQgICAgICAgICAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICAgICAgbGFzdERvY1NwbGl0ICs9IGxlbjtcXG5cXHQgICAgICAgICAgICBzcGxpdHMucHVzaChsYXN0RG9jU3BsaXQpO1xcblxcdCAgICAgICAgICAgIGxhc3RTcGxpdCA9IHNjcmVlblBvcztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHdoaWxlIChkaXNwbGF5TGVuZ3RoIC0gbGFzdFNwbGl0ID4gd3JhcExpbWl0KSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHNwbGl0ID0gbGFzdFNwbGl0ICsgd3JhcExpbWl0O1xcblxcdCAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXQgLSAxXSA+PSBTUEFDRSAmJiB0b2tlbnNbc3BsaXRdID49IFNQQUNFKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGFkZFNwbGl0KHNwbGl0KTtcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXRdID09IFBMQUNFSE9MREVSX1NUQVJUIHx8IHRva2Vuc1tzcGxpdF0gPT0gUExBQ0VIT0xERVJfQk9EWSkge1xcblxcdCAgICAgICAgICAgICAgICBmb3IgKHNwbGl0OyBzcGxpdCAhPSBsYXN0U3BsaXQgLSAxOyBzcGxpdC0tKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zW3NwbGl0XSA9PSBQTEFDRUhPTERFUl9TVEFSVCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzcGxpdCA+IGxhc3RTcGxpdCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgYWRkU3BsaXQoc3BsaXQpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgc3BsaXQgPSBsYXN0U3BsaXQgKyB3cmFwTGltaXQ7XFxuXFx0ICAgICAgICAgICAgICAgIGZvciAoc3BsaXQ7IHNwbGl0IDwgdG9rZW5zLmxlbmd0aDsgc3BsaXQrKykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tzcGxpdF0gIT0gUExBQ0VIT0xERVJfQk9EWSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzcGxpdCA9PSB0b2tlbnMubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhazsgIC8vIEJyZWFrcyB0aGUgd2hpbGUtbG9vcC5cXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBhZGRTcGxpdChzcGxpdCk7XFxuXFx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB2YXIgbWluU3BsaXQgPSBNYXRoLm1heChzcGxpdCAtIChpc0NvZGUgPyAxMCA6IHdyYXBMaW1pdC0od3JhcExpbWl0Pj4yKSksIGxhc3RTcGxpdCAtIDEpO1xcblxcdCAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPCBQTEFDRUhPTERFUl9TVEFSVCkge1xcblxcdCAgICAgICAgICAgICAgICBzcGxpdCAtLTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKGlzQ29kZSkge1xcblxcdCAgICAgICAgICAgICAgICB3aGlsZSAoc3BsaXQgPiBtaW5TcGxpdCAmJiB0b2tlbnNbc3BsaXRdIDwgUExBQ0VIT0xERVJfU1RBUlQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwbGl0IC0tO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdCA+IG1pblNwbGl0ICYmIHRva2Vuc1tzcGxpdF0gPT0gUFVOQ1RVQVRJT04pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwbGl0IC0tO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0ID4gbWluU3BsaXQgJiYgdG9rZW5zW3NwbGl0XSA8IFNQQUNFKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzcGxpdCAtLTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpZiAoc3BsaXQgPiBtaW5TcGxpdCkge1xcblxcdCAgICAgICAgICAgICAgICBhZGRTcGxpdCgrK3NwbGl0KTtcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHNwbGl0ID0gbGFzdFNwbGl0ICsgd3JhcExpbWl0O1xcblxcdCAgICAgICAgICAgIGlmICh0b2tlbnNbc3BsaXRdID09IENIQVJfRVhUKVxcblxcdCAgICAgICAgICAgICAgICBzcGxpdC0tO1xcblxcdCAgICAgICAgICAgIGFkZFNwbGl0KHNwbGl0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBzcGxpdHM7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJGdldERpc3BsYXlUb2tlbnMgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xcblxcdCAgICAgICAgdmFyIGFyciA9IFtdO1xcblxcdCAgICAgICAgdmFyIHRhYlNpemU7XFxuXFx0ICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcXG5cXHQgICAgICAgICAgICBpZiAoYyA9PSA5KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRhYlNpemUgPSB0aGlzLmdldFNjcmVlblRhYlNpemUoYXJyLmxlbmd0aCArIG9mZnNldCk7XFxuXFx0ICAgICAgICAgICAgICAgIGFyci5wdXNoKFRBQik7XFxuXFx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgdGFiU2l6ZTsgbisrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChUQUJfU1BBQ0UpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gMzIpIHtcXG5cXHQgICAgICAgICAgICAgICAgYXJyLnB1c2goU1BBQ0UpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZigoYyA+IDM5ICYmIGMgPCA0OCkgfHwgKGMgPiA1NyAmJiBjIDwgNjQpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGFyci5wdXNoKFBVTkNUVUFUSU9OKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgZWxzZSBpZiAoYyA+PSAweDExMDAgJiYgaXNGdWxsV2lkdGgoYykpIHtcXG5cXHQgICAgICAgICAgICAgICAgYXJyLnB1c2goQ0hBUiwgQ0hBUl9FWFQpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIGFyci5wdXNoKENIQVIpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBhcnI7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJGdldFN0cmluZ1NjcmVlbldpZHRoID0gZnVuY3Rpb24oc3RyLCBtYXhTY3JlZW5Db2x1bW4sIHNjcmVlbkNvbHVtbikge1xcblxcdCAgICAgICAgaWYgKG1heFNjcmVlbkNvbHVtbiA9PSAwKVxcblxcdCAgICAgICAgICAgIHJldHVybiBbMCwgMF07XFxuXFx0ICAgICAgICBpZiAobWF4U2NyZWVuQ29sdW1uID09IG51bGwpXFxuXFx0ICAgICAgICAgICAgbWF4U2NyZWVuQ29sdW1uID0gSW5maW5pdHk7XFxuXFx0ICAgICAgICBzY3JlZW5Db2x1bW4gPSBzY3JlZW5Db2x1bW4gfHwgMDtcXG5cXG5cXHQgICAgICAgIHZhciBjLCBjb2x1bW47XFxuXFx0ICAgICAgICBmb3IgKGNvbHVtbiA9IDA7IGNvbHVtbiA8IHN0ci5sZW5ndGg7IGNvbHVtbisrKSB7XFxuXFx0ICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgaWYgKGMgPT0gOSkge1xcblxcdCAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gdGhpcy5nZXRTY3JlZW5UYWJTaXplKHNjcmVlbkNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKGMgPj0gMHgxMTAwICYmIGlzRnVsbFdpZHRoKGMpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAyO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpZiAoc2NyZWVuQ29sdW1uID4gbWF4U2NyZWVuQ29sdW1uKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBbc2NyZWVuQ29sdW1uLCBjb2x1bW5dO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmxpbmVXaWRnZXRzID0gbnVsbDtcXG5cXHQgICAgdGhpcy5nZXRSb3dMZW5ndGggPSBmdW5jdGlvbihyb3cpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHZhciBoID0gdGhpcy5saW5lV2lkZ2V0c1tyb3ddICYmIHRoaXMubGluZVdpZGdldHNbcm93XS5yb3dDb3VudCB8fCAwO1xcblxcdCAgICAgICAgZWxzZSBcXG5cXHQgICAgICAgICAgICBoID0gMFxcblxcdCAgICAgICAgaWYgKCF0aGlzLiR1c2VXcmFwTW9kZSB8fCAhdGhpcy4kd3JhcERhdGFbcm93XSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiAxICsgaDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHdyYXBEYXRhW3Jvd10ubGVuZ3RoICsgMSArIGg7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0Um93TGluZUNvdW50ID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlIHx8ICF0aGlzLiR3cmFwRGF0YVtyb3ddKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIDE7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLiR3cmFwRGF0YVtyb3ddLmxlbmd0aCArIDE7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0U2NyZWVuTGFzdFJvd0NvbHVtbiA9IGZ1bmN0aW9uKHNjcmVlblJvdykge1xcblxcdCAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgTnVtYmVyLk1BWF9WQUxVRSk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRvU2NyZWVuQ29sdW1uKHBvcy5yb3csIHBvcy5jb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldERvY3VtZW50TGFzdFJvd0NvbHVtbiA9IGZ1bmN0aW9uKGRvY1JvdywgZG9jQ29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgc2NyZWVuUm93ID0gdGhpcy5kb2N1bWVudFRvU2NyZWVuUm93KGRvY1JvdywgZG9jQ29sdW1uKTtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldFNjcmVlbkxhc3RSb3dDb2x1bW4oc2NyZWVuUm93KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXREb2N1bWVudExhc3RSb3dDb2x1bW5Qb3NpdGlvbiA9IGZ1bmN0aW9uKGRvY1JvdywgZG9jQ29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgc2NyZWVuUm93ID0gdGhpcy5kb2N1bWVudFRvU2NyZWVuUm93KGRvY1JvdywgZG9jQ29sdW1uKTtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvRG9jdW1lbnRQb3NpdGlvbihzY3JlZW5Sb3csIE51bWJlci5NQVhfVkFMVUUgLyAxMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0Um93U3BsaXREYXRhID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHdyYXBEYXRhW3Jvd107XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0U2NyZWVuVGFiU2l6ZSA9IGZ1bmN0aW9uKHNjcmVlbkNvbHVtbikge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHRhYlNpemUgLSBzY3JlZW5Db2x1bW4gJSB0aGlzLiR0YWJTaXplO1xcblxcdCAgICB9O1xcblxcblxcblxcdCAgICB0aGlzLnNjcmVlblRvRG9jdW1lbnRSb3cgPSBmdW5jdGlvbihzY3JlZW5Sb3csIHNjcmVlbkNvbHVtbikge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9Eb2N1bWVudFBvc2l0aW9uKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKS5yb3c7XFxuXFx0ICAgIH07XFxuXFxuXFxuXFx0ICAgIHRoaXMuc2NyZWVuVG9Eb2N1bWVudENvbHVtbiA9IGZ1bmN0aW9uKHNjcmVlblJvdywgc2NyZWVuQ29sdW1uKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuUm93LCBzY3JlZW5Db2x1bW4pLmNvbHVtbjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbihzY3JlZW5Sb3csIHNjcmVlbkNvbHVtbikge1xcblxcdCAgICAgICAgaWYgKHNjcmVlblJvdyA8IDApXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHtyb3c6IDAsIGNvbHVtbjogMH07XFxuXFxuXFx0ICAgICAgICB2YXIgbGluZTtcXG5cXHQgICAgICAgIHZhciBkb2NSb3cgPSAwO1xcblxcdCAgICAgICAgdmFyIGRvY0NvbHVtbiA9IDA7XFxuXFx0ICAgICAgICB2YXIgY29sdW1uO1xcblxcdCAgICAgICAgdmFyIHJvdyA9IDA7XFxuXFx0ICAgICAgICB2YXIgcm93TGVuZ3RoID0gMDtcXG5cXG5cXHQgICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuJHNjcmVlblJvd0NhY2hlO1xcblxcdCAgICAgICAgdmFyIGkgPSB0aGlzLiRnZXRSb3dDYWNoZUluZGV4KHJvd0NhY2hlLCBzY3JlZW5Sb3cpO1xcblxcdCAgICAgICAgdmFyIGwgPSByb3dDYWNoZS5sZW5ndGg7XFxuXFx0ICAgICAgICBpZiAobCAmJiBpID49IDApIHtcXG5cXHQgICAgICAgICAgICB2YXIgcm93ID0gcm93Q2FjaGVbaV07XFxuXFx0ICAgICAgICAgICAgdmFyIGRvY1JvdyA9IHRoaXMuJGRvY1Jvd0NhY2hlW2ldO1xcblxcdCAgICAgICAgICAgIHZhciBkb0NhY2hlID0gc2NyZWVuUm93ID4gcm93Q2FjaGVbbCAtIDFdO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgZG9DYWNoZSA9ICFsO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIG1heFJvdyA9IHRoaXMuZ2V0TGVuZ3RoKCkgLSAxO1xcblxcdCAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5nZXROZXh0Rm9sZExpbmUoZG9jUm93KTtcXG5cXHQgICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xcblxcblxcdCAgICAgICAgd2hpbGUgKHJvdyA8PSBzY3JlZW5Sb3cpIHtcXG5cXHQgICAgICAgICAgICByb3dMZW5ndGggPSB0aGlzLmdldFJvd0xlbmd0aChkb2NSb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChyb3cgKyByb3dMZW5ndGggPiBzY3JlZW5Sb3cgfHwgZG9jUm93ID49IG1heFJvdykge1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICByb3cgKz0gcm93TGVuZ3RoO1xcblxcdCAgICAgICAgICAgICAgICBkb2NSb3crKztcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGRvY1JvdyA+IGZvbGRTdGFydCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZG9jUm93ID0gZm9sZExpbmUuZW5kLnJvdysxO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShkb2NSb3csIGZvbGRMaW5lKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGRvQ2FjaGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUucHVzaChkb2NSb3cpO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZS5wdXNoKHJvdyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKGZvbGRMaW5lICYmIGZvbGRMaW5lLnN0YXJ0LnJvdyA8PSBkb2NSb3cpIHtcXG5cXHQgICAgICAgICAgICBsaW5lID0gdGhpcy5nZXRGb2xkRGlzcGxheUxpbmUoZm9sZExpbmUpO1xcblxcdCAgICAgICAgICAgIGRvY1JvdyA9IGZvbGRMaW5lLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAocm93ICsgcm93TGVuZ3RoIDw9IHNjcmVlblJvdyB8fCBkb2NSb3cgPiBtYXhSb3cpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICByb3c6IG1heFJvdyxcXG5cXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmdldExpbmUobWF4Um93KS5sZW5ndGhcXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBsaW5lID0gdGhpcy5nZXRMaW5lKGRvY1Jvdyk7XFxuXFx0ICAgICAgICAgICAgZm9sZExpbmUgPSBudWxsO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHRoaXMuJHdyYXBEYXRhW2RvY1Jvd107XFxuXFx0ICAgICAgICAgICAgaWYgKHNwbGl0cykge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3BsaXRJbmRleCA9IE1hdGguZmxvb3Ioc2NyZWVuUm93IC0gcm93KTtcXG5cXHQgICAgICAgICAgICAgICAgY29sdW1uID0gc3BsaXRzW3NwbGl0SW5kZXhdO1xcblxcdCAgICAgICAgICAgICAgICBpZihzcGxpdEluZGV4ID4gMCAmJiBzcGxpdHMubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBkb2NDb2x1bW4gPSBzcGxpdHNbc3BsaXRJbmRleCAtIDFdIHx8IHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV07XFxuXFx0ICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoZG9jQ29sdW1uKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGRvY0NvbHVtbiArPSB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aChsaW5lLCBzY3JlZW5Db2x1bW4pWzFdO1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlICYmIGRvY0NvbHVtbiA+PSBjb2x1bW4pXFxuXFx0ICAgICAgICAgICAgZG9jQ29sdW1uID0gY29sdW1uIC0gMTtcXG5cXG5cXHQgICAgICAgIGlmIChmb2xkTGluZSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gZm9sZExpbmUuaWR4VG9Qb3NpdGlvbihkb2NDb2x1bW4pO1xcblxcblxcdCAgICAgICAgcmV0dXJuIHtyb3c6IGRvY1JvdywgY29sdW1uOiBkb2NDb2x1bW59O1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbiA9IGZ1bmN0aW9uKGRvY1JvdywgZG9jQ29sdW1uKSB7XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIGRvY0NvbHVtbiA9PT0gXFxcInVuZGVmaW5lZFxcXCIpXFxuXFx0ICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQoZG9jUm93LnJvdywgZG9jUm93LmNvbHVtbik7XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgcG9zID0gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudChkb2NSb3csIGRvY0NvbHVtbik7XFxuXFxuXFx0ICAgICAgICBkb2NSb3cgPSBwb3Mucm93O1xcblxcdCAgICAgICAgZG9jQ29sdW1uID0gcG9zLmNvbHVtbjtcXG5cXG5cXHQgICAgICAgIHZhciBzY3JlZW5Sb3cgPSAwO1xcblxcdCAgICAgICAgdmFyIGZvbGRTdGFydFJvdyA9IG51bGw7XFxuXFx0ICAgICAgICB2YXIgZm9sZCA9IG51bGw7XFxuXFx0ICAgICAgICBmb2xkID0gdGhpcy5nZXRGb2xkQXQoZG9jUm93LCBkb2NDb2x1bW4sIDEpO1xcblxcdCAgICAgICAgaWYgKGZvbGQpIHtcXG5cXHQgICAgICAgICAgICBkb2NSb3cgPSBmb2xkLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICBkb2NDb2x1bW4gPSBmb2xkLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciByb3dFbmQsIHJvdyA9IDA7XFxuXFxuXFxuXFx0ICAgICAgICB2YXIgcm93Q2FjaGUgPSB0aGlzLiRkb2NSb3dDYWNoZTtcXG5cXHQgICAgICAgIHZhciBpID0gdGhpcy4kZ2V0Um93Q2FjaGVJbmRleChyb3dDYWNoZSwgZG9jUm93KTtcXG5cXHQgICAgICAgIHZhciBsID0gcm93Q2FjaGUubGVuZ3RoO1xcblxcdCAgICAgICAgaWYgKGwgJiYgaSA+PSAwKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvdyA9IHJvd0NhY2hlW2ldO1xcblxcdCAgICAgICAgICAgIHZhciBzY3JlZW5Sb3cgPSB0aGlzLiRzY3JlZW5Sb3dDYWNoZVtpXTtcXG5cXHQgICAgICAgICAgICB2YXIgZG9DYWNoZSA9IGRvY1JvdyA+IHJvd0NhY2hlW2wgLSAxXTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGRvQ2FjaGUgPSAhbDtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuZ2V0TmV4dEZvbGRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgP2ZvbGRMaW5lLnN0YXJ0LnJvdyA6SW5maW5pdHk7XFxuXFxuXFx0ICAgICAgICB3aGlsZSAocm93IDwgZG9jUm93KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA+PSBmb2xkU3RhcnQpIHtcXG5cXHQgICAgICAgICAgICAgICAgcm93RW5kID0gZm9sZExpbmUuZW5kLnJvdyArIDE7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyb3dFbmQgPiBkb2NSb3cpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLmdldE5leHRGb2xkTGluZShyb3dFbmQsIGZvbGRMaW5lKTtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgP2ZvbGRMaW5lLnN0YXJ0LnJvdyA6SW5maW5pdHk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICByb3dFbmQgPSByb3cgKyAxO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBzY3JlZW5Sb3cgKz0gdGhpcy5nZXRSb3dMZW5ndGgocm93KTtcXG5cXHQgICAgICAgICAgICByb3cgPSByb3dFbmQ7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGRvQ2FjaGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kZG9jUm93Q2FjaGUucHVzaChyb3cpO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRzY3JlZW5Sb3dDYWNoZS5wdXNoKHNjcmVlblJvdyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIHRleHRMaW5lID0gXFxcIlxcXCI7XFxuXFx0ICAgICAgICBpZiAoZm9sZExpbmUgJiYgcm93ID49IGZvbGRTdGFydCkge1xcblxcdCAgICAgICAgICAgIHRleHRMaW5lID0gdGhpcy5nZXRGb2xkRGlzcGxheUxpbmUoZm9sZExpbmUsIGRvY1JvdywgZG9jQ29sdW1uKTtcXG5cXHQgICAgICAgICAgICBmb2xkU3RhcnRSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRleHRMaW5lID0gdGhpcy5nZXRMaW5lKGRvY1Jvdykuc3Vic3RyaW5nKDAsIGRvY0NvbHVtbik7XFxuXFx0ICAgICAgICAgICAgZm9sZFN0YXJ0Um93ID0gZG9jUm93O1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKHRoaXMuJHVzZVdyYXBNb2RlKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHdyYXBSb3cgPSB0aGlzLiR3cmFwRGF0YVtmb2xkU3RhcnRSb3ddO1xcblxcdCAgICAgICAgICAgIGlmICh3cmFwUm93KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBzY3JlZW5Sb3dPZmZzZXQgPSAwO1xcblxcdCAgICAgICAgICAgICAgICB3aGlsZSAodGV4dExpbmUubGVuZ3RoID49IHdyYXBSb3dbc2NyZWVuUm93T2Zmc2V0XSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2NyZWVuUm93ICsrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2NyZWVuUm93T2Zmc2V0Kys7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgdGV4dExpbmUgPSB0ZXh0TGluZS5zdWJzdHJpbmcoXFxuXFx0ICAgICAgICAgICAgICAgICAgICB3cmFwUm93W3NjcmVlblJvd09mZnNldCAtIDFdIHx8IDAsIHRleHRMaW5lLmxlbmd0aFxcblxcdCAgICAgICAgICAgICAgICApO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgcm93OiBzY3JlZW5Sb3csXFxuXFx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLiRnZXRTdHJpbmdTY3JlZW5XaWR0aCh0ZXh0TGluZSlbMF1cXG5cXHQgICAgICAgIH07XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZG9jdW1lbnRUb1NjcmVlbkNvbHVtbiA9IGZ1bmN0aW9uKHJvdywgZG9jQ29sdW1uKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocm93LCBkb2NDb2x1bW4pLmNvbHVtbjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5kb2N1bWVudFRvU2NyZWVuUm93ID0gZnVuY3Rpb24oZG9jUm93LCBkb2NDb2x1bW4pIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihkb2NSb3csIGRvY0NvbHVtbikucm93O1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNjcmVlbkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHNjcmVlblJvd3MgPSAwO1xcblxcdCAgICAgICAgdmFyIGZvbGQgPSBudWxsO1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiR1c2VXcmFwTW9kZSkge1xcblxcdCAgICAgICAgICAgIHNjcmVlblJvd3MgPSB0aGlzLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgICAgIHZhciBmb2xkRGF0YSA9IHRoaXMuJGZvbGREYXRhO1xcblxcdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9sZERhdGEubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZCA9IGZvbGREYXRhW2ldO1xcblxcdCAgICAgICAgICAgICAgICBzY3JlZW5Sb3dzIC09IGZvbGQuZW5kLnJvdyAtIGZvbGQuc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGxhc3RSb3cgPSB0aGlzLiR3cmFwRGF0YS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvdyA9IDAsIGkgPSAwO1xcblxcdCAgICAgICAgICAgIHZhciBmb2xkID0gdGhpcy4kZm9sZERhdGFbaSsrXTtcXG5cXHQgICAgICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDpJbmZpbml0eTtcXG5cXG5cXHQgICAgICAgICAgICB3aGlsZSAocm93IDwgbGFzdFJvdykge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3BsaXRzID0gdGhpcy4kd3JhcERhdGFbcm93XTtcXG5cXHQgICAgICAgICAgICAgICAgc2NyZWVuUm93cyArPSBzcGxpdHMgPyBzcGxpdHMubGVuZ3RoICsgMSA6IDE7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyArKztcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcm93ID0gZm9sZC5lbmQucm93KzE7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb2xkID0gdGhpcy4kZm9sZERhdGFbaSsrXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGQgP2ZvbGQuc3RhcnQucm93IDpJbmZpbml0eTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh0aGlzLmxpbmVXaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHNjcmVlblJvd3MgKz0gdGhpcy4kZ2V0V2lkZ2V0U2NyZWVuTGVuZ3RoKCk7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gc2NyZWVuUm93cztcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy4kc2V0Rm9udE1ldHJpY3MgPSBmdW5jdGlvbihmbSkge1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5iZ1Rva2VuaXplcikge1xcblxcdCAgICAgICAgICAgIHRoaXMuYmdUb2tlbml6ZXIuc2V0RG9jdW1lbnQobnVsbCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5iZ1Rva2VuaXplciA9IG51bGw7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLiRzdG9wV29ya2VyKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIGZ1bmN0aW9uIGlzRnVsbFdpZHRoKGMpIHtcXG5cXHQgICAgICAgIGlmIChjIDwgMHgxMTAwKVxcblxcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgICAgIHJldHVybiBjID49IDB4MTEwMCAmJiBjIDw9IDB4MTE1RiB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHgxMUEzICYmIGMgPD0gMHgxMUE3IHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweDExRkEgJiYgYyA8PSAweDExRkYgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4MjMyOSAmJiBjIDw9IDB4MjMyQSB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHgyRTgwICYmIGMgPD0gMHgyRTk5IHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweDJFOUIgJiYgYyA8PSAweDJFRjMgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4MkYwMCAmJiBjIDw9IDB4MkZENSB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHgyRkYwICYmIGMgPD0gMHgyRkZCIHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweDMwMDAgJiYgYyA8PSAweDMwM0UgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4MzA0MSAmJiBjIDw9IDB4MzA5NiB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHgzMDk5ICYmIGMgPD0gMHgzMEZGIHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweDMxMDUgJiYgYyA8PSAweDMxMkQgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4MzEzMSAmJiBjIDw9IDB4MzE4RSB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHgzMTkwICYmIGMgPD0gMHgzMUJBIHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweDMxQzAgJiYgYyA8PSAweDMxRTMgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4MzFGMCAmJiBjIDw9IDB4MzIxRSB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHgzMjIwICYmIGMgPD0gMHgzMjQ3IHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweDMyNTAgJiYgYyA8PSAweDMyRkUgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4MzMwMCAmJiBjIDw9IDB4NERCRiB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHg0RTAwICYmIGMgPD0gMHhBNDhDIHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweEE0OTAgJiYgYyA8PSAweEE0QzYgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4QTk2MCAmJiBjIDw9IDB4QTk3QyB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHhBQzAwICYmIGMgPD0gMHhEN0EzIHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweEQ3QjAgJiYgYyA8PSAweEQ3QzYgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4RDdDQiAmJiBjIDw9IDB4RDdGQiB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHhGOTAwICYmIGMgPD0gMHhGQUZGIHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweEZFMTAgJiYgYyA8PSAweEZFMTkgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4RkUzMCAmJiBjIDw9IDB4RkU1MiB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHhGRTU0ICYmIGMgPD0gMHhGRTY2IHx8XFxuXFx0ICAgICAgICAgICAgICAgYyA+PSAweEZFNjggJiYgYyA8PSAweEZFNkIgfHxcXG5cXHQgICAgICAgICAgICAgICBjID49IDB4RkYwMSAmJiBjIDw9IDB4RkY2MCB8fFxcblxcdCAgICAgICAgICAgICAgIGMgPj0gMHhGRkUwICYmIGMgPD0gMHhGRkU2O1xcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoRWRpdFNlc3Npb24ucHJvdG90eXBlKTtcXG5cXG5cXHRhY2VxdWlyZShcXFwiLi9lZGl0X3Nlc3Npb24vZm9sZGluZ1xcXCIpLkZvbGRpbmcuY2FsbChFZGl0U2Vzc2lvbi5wcm90b3R5cGUpO1xcblxcdGFjZXF1aXJlKFxcXCIuL2VkaXRfc2Vzc2lvbi9icmFja2V0X21hdGNoXFxcIikuQnJhY2tldE1hdGNoLmNhbGwoRWRpdFNlc3Npb24ucHJvdG90eXBlKTtcXG5cXG5cXG5cXHRjb25maWcuZGVmaW5lT3B0aW9ucyhFZGl0U2Vzc2lvbi5wcm90b3R5cGUsIFxcXCJzZXNzaW9uXFxcIiwge1xcblxcdCAgICB3cmFwOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PSBcXFwib2ZmXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBcXFwiZnJlZVxcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBcXFwicHJpbnRNYXJnaW5cXFwiKVxcblxcdCAgICAgICAgICAgICAgICB2YWx1ZSA9IC0xO1xcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcXFwic3RyaW5nXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IGZhbHNlO1xcblxcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiR3cmFwID09IHZhbHVlKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNldFVzZVdyYXBNb2RlKGZhbHNlKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgY29sID0gdHlwZW9mIHZhbHVlID09IFxcXCJudW1iZXJcXFwiID8gdmFsdWUgOiBudWxsO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNldFdyYXBMaW1pdFJhbmdlKGNvbCwgY29sKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zZXRVc2VXcmFwTW9kZSh0cnVlKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy4kd3JhcCA9IHZhbHVlO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VXNlV3JhcE1vZGUoKSkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAodGhpcy4kd3JhcCA9PSAtMSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwicHJpbnRNYXJnaW5cXFwiO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0V3JhcExpbWl0UmFuZ2UoKS5taW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImZyZWVcXFwiO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFxcXCJvZmZcXFwiO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcXG5cXHQgICAgfSwgICAgXFxuXFx0ICAgIHdyYXBNZXRob2Q6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XFxuXFx0ICAgICAgICAgICAgdmFsID0gdmFsID09IFxcXCJhdXRvXFxcIlxcblxcdCAgICAgICAgICAgICAgICA/IHRoaXMuJG1vZGUudHlwZSAhPSBcXFwidGV4dFxcXCJcXG5cXHQgICAgICAgICAgICAgICAgOiB2YWwgIT0gXFxcInRleHRcXFwiO1xcblxcdCAgICAgICAgICAgIGlmICh2YWwgIT0gdGhpcy4kd3JhcEFzQ29kZSkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiR3cmFwQXNDb2RlID0gdmFsO1xcblxcdCAgICAgICAgICAgICAgICBpZiAodGhpcy4kdXNlV3JhcE1vZGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlc2V0Um93Q2FjaGUoMCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiR1cGRhdGVXcmFwRGF0YSgwLCB0aGlzLmdldExlbmd0aCgpIC0gMSk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiBcXFwiYXV0b1xcXCJcXG5cXHQgICAgfSxcXG5cXHQgICAgZmlyc3RMaW5lTnVtYmVyOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge3RoaXMuX3NpZ25hbChcXFwiY2hhbmdlQnJlYWtwb2ludFxcXCIpO30sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IDFcXG5cXHQgICAgfSxcXG5cXHQgICAgdXNlV29ya2VyOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHVzZVdvcmtlcikge1xcblxcdCAgICAgICAgICAgIHRoaXMuJHVzZVdvcmtlciA9IHVzZVdvcmtlcjtcXG5cXG5cXHQgICAgICAgICAgICB0aGlzLiRzdG9wV29ya2VyKCk7XFxuXFx0ICAgICAgICAgICAgaWYgKHVzZVdvcmtlcilcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kc3RhcnRXb3JrZXIoKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgdXNlU29mdFRhYnM6IHtpbml0aWFsVmFsdWU6IHRydWV9LFxcblxcdCAgICB0YWJTaXplOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRhYlNpemUpIHtcXG5cXHQgICAgICAgICAgICBpZiAoaXNOYU4odGFiU2l6ZSkgfHwgdGhpcy4kdGFiU2l6ZSA9PT0gdGFiU2l6ZSkgcmV0dXJuO1xcblxcblxcdCAgICAgICAgICAgIHRoaXMuJG1vZGlmaWVkID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRyb3dMZW5ndGhDYWNoZSA9IFtdO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHRhYlNpemUgPSB0YWJTaXplO1xcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlVGFiU2l6ZVxcXCIpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogNCxcXG5cXHQgICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgb3ZlcndyaXRlOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge3RoaXMuX3NpZ25hbChcXFwiY2hhbmdlT3ZlcndyaXRlXFxcIik7fSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcXG5cXHQgICAgfSxcXG5cXHQgICAgbmV3TGluZU1vZGU6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7dGhpcy5kb2Muc2V0TmV3TGluZU1vZGUodmFsKX0sXFxuXFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRvYy5nZXROZXdMaW5lTW9kZSgpfSxcXG5cXHQgICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgbW9kZToge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHsgdGhpcy5zZXRNb2RlKHZhbCkgfSxcXG5cXHQgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLiRtb2RlSWQgfVxcblxcdCAgICB9XFxuXFx0fSk7XFxuXFxuXFx0ZXhwb3J0cy5FZGl0U2Vzc2lvbiA9IEVkaXRTZXNzaW9uO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9zZWFyY2hcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2xhbmdcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9yYW5nZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4vbGliL2xhbmdcXFwiKTtcXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBSYW5nZSA9IGFjZXF1aXJlKFxcXCIuL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFxuXFx0dmFyIFNlYXJjaCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLiRvcHRpb25zID0ge307XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xcblxcdCAgICAgICAgb29wLm1peGluKHRoaXMuJG9wdGlvbnMsIG9wdGlvbnMpO1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXM7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIGxhbmcuY29weU9iamVjdCh0aGlzLiRvcHRpb25zKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xcblxcdCAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZmluZCA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcXG5cXHQgICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuJG1hdGNoSXRlcmF0b3Ioc2Vzc2lvbiwgdGhpcy4kb3B0aW9ucyk7XFxuXFxuXFx0ICAgICAgICBpZiAoIWl0ZXJhdG9yKVxcblxcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXG5cXHQgICAgICAgIHZhciBmaXJzdFJhbmdlID0gbnVsbDtcXG5cXHQgICAgICAgIGl0ZXJhdG9yLmZvckVhY2goZnVuY3Rpb24ocmFuZ2UsIHJvdywgb2Zmc2V0KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCFyYW5nZS5zdGFydCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gcmFuZ2Uub2Zmc2V0ICsgKG9mZnNldCB8fCAwKTtcXG5cXHQgICAgICAgICAgICAgICAgZmlyc3RSYW5nZSA9IG5ldyBSYW5nZShyb3csIGNvbHVtbiwgcm93LCBjb2x1bW4rcmFuZ2UubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgZmlyc3RSYW5nZSA9IHJhbmdlO1xcblxcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gZmlyc3RSYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5maW5kQWxsID0gZnVuY3Rpb24oc2Vzc2lvbikge1xcblxcdCAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xcblxcdCAgICAgICAgaWYgKCFvcHRpb25zLm5lZWRsZSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gW107XFxuXFx0ICAgICAgICB0aGlzLiRhc3NlbWJsZVJlZ0V4cChvcHRpb25zKTtcXG5cXG5cXHQgICAgICAgIHZhciByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XFxuXFx0ICAgICAgICB2YXIgbGluZXMgPSByYW5nZVxcblxcdCAgICAgICAgICAgID8gc2Vzc2lvbi5nZXRMaW5lcyhyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpXFxuXFx0ICAgICAgICAgICAgOiBzZXNzaW9uLmRvYy5nZXRBbGxMaW5lcygpO1xcblxcblxcdCAgICAgICAgdmFyIHJhbmdlcyA9IFtdO1xcblxcdCAgICAgICAgdmFyIHJlID0gb3B0aW9ucy5yZTtcXG5cXHQgICAgICAgIGlmIChvcHRpb25zLiRpc011bHRpTGluZSkge1xcblxcdCAgICAgICAgICAgIHZhciBsZW4gPSByZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgdmFyIG1heFJvdyA9IGxpbmVzLmxlbmd0aCAtIGxlbjtcXG5cXHQgICAgICAgICAgICB2YXIgcHJldlJhbmdlO1xcblxcdCAgICAgICAgICAgIG91dGVyOiBmb3IgKHZhciByb3cgPSByZS5vZmZzZXQgfHwgMDsgcm93IDw9IG1heFJvdzsgcm93KyspIHtcXG5cXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lc1tyb3cgKyBqXS5zZWFyY2gocmVbal0pID09IC0xKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xcblxcdCAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IGxpbmVzW3Jvd107XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbcm93ICsgbGVuIC0gMV07XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRMaW5lLmxlbmd0aCAtIHN0YXJ0TGluZS5tYXRjaChyZVswXSlbMF0ubGVuZ3RoO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBsaW5lLm1hdGNoKHJlW2xlbiAtIDFdKVswXS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgICAgICBpZiAocHJldlJhbmdlICYmIHByZXZSYW5nZS5lbmQucm93ID09PSByb3cgJiZcXG5cXHQgICAgICAgICAgICAgICAgICAgIHByZXZSYW5nZS5lbmQuY29sdW1uID4gc3RhcnRJbmRleFxcblxcdCAgICAgICAgICAgICAgICApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHByZXZSYW5nZSA9IG5ldyBSYW5nZShcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvdywgc3RhcnRJbmRleCwgcm93ICsgbGVuIC0gMSwgZW5kSW5kZXhcXG5cXHQgICAgICAgICAgICAgICAgKSk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChsZW4gPiAyKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93ICsgbGVuIC0gMjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsYW5nLmdldE1hdGNoT2Zmc2V0cyhsaW5lc1tpXSwgcmUpO1xcblxcdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbal07XFxuXFx0ICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoaSwgbWF0Y2gub2Zmc2V0LCBpLCBtYXRjaC5vZmZzZXQgKyBtYXRjaC5sZW5ndGgpKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChyYW5nZSkge1xcblxcdCAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICB2YXIgZW5kQ29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgICAgIHZhciBpID0gMCwgaiA9IHJhbmdlcy5sZW5ndGggLSAxO1xcblxcdCAgICAgICAgICAgIHdoaWxlIChpIDwgaiAmJiByYW5nZXNbaV0uc3RhcnQuY29sdW1uIDwgc3RhcnRDb2x1bW4gJiYgcmFuZ2VzW2ldLnN0YXJ0LnJvdyA9PSByYW5nZS5zdGFydC5yb3cpXFxuXFx0ICAgICAgICAgICAgICAgIGkrKztcXG5cXG5cXHQgICAgICAgICAgICB3aGlsZSAoaSA8IGogJiYgcmFuZ2VzW2pdLmVuZC5jb2x1bW4gPiBlbmRDb2x1bW4gJiYgcmFuZ2VzW2pdLmVuZC5yb3cgPT0gcmFuZ2UuZW5kLnJvdylcXG5cXHQgICAgICAgICAgICAgICAgai0tO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHJhbmdlcyA9IHJhbmdlcy5zbGljZShpLCBqICsgMSk7XFxuXFx0ICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2VzW2ldLnN0YXJ0LnJvdyArPSByYW5nZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlc1tpXS5lbmQucm93ICs9IHJhbmdlLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICByZXR1cm4gcmFuZ2VzO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnJlcGxhY2UgPSBmdW5jdGlvbihpbnB1dCwgcmVwbGFjZW1lbnQpIHtcXG5cXHQgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcXG5cXG5cXHQgICAgICAgIHZhciByZSA9IHRoaXMuJGFzc2VtYmxlUmVnRXhwKG9wdGlvbnMpO1xcblxcdCAgICAgICAgaWYgKG9wdGlvbnMuJGlzTXVsdGlMaW5lKVxcblxcdCAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcXG5cXG5cXHQgICAgICAgIGlmICghcmUpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhpbnB1dCk7XFxuXFx0ICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzBdLmxlbmd0aCAhPSBpbnB1dC5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHJlcGxhY2VtZW50ID0gaW5wdXQucmVwbGFjZShyZSwgcmVwbGFjZW1lbnQpO1xcblxcdCAgICAgICAgaWYgKG9wdGlvbnMucHJlc2VydmVDYXNlKSB7XFxuXFx0ICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5zcGxpdChcXFwiXFxcIik7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgaW5wdXQubGVuZ3RoKTsgaS0tOyApIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gaW5wdXRbaV07XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaC50b0xvd2VyQ2FzZSgpICE9IGNoKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRbaV0gPSByZXBsYWNlbWVudFtpXS50b1VwcGVyQ2FzZSgpO1xcblxcdCAgICAgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFtpXSA9IHJlcGxhY2VtZW50W2ldLnRvTG93ZXJDYXNlKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQuam9pbihcXFwiXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kbWF0Y2hJdGVyYXRvciA9IGZ1bmN0aW9uKHNlc3Npb24sIG9wdGlvbnMpIHtcXG5cXHQgICAgICAgIHZhciByZSA9IHRoaXMuJGFzc2VtYmxlUmVnRXhwKG9wdGlvbnMpO1xcblxcdCAgICAgICAgaWYgKCFyZSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFxuXFx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGNhbGxiYWNrLCBiYWNrd2FyZHMgPSBvcHRpb25zLmJhY2t3YXJkcztcXG5cXG5cXHQgICAgICAgIGlmIChvcHRpb25zLiRpc011bHRpTGluZSkge1xcblxcdCAgICAgICAgICAgIHZhciBsZW4gPSByZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgdmFyIG1hdGNoSXRlcmF0b3IgPSBmdW5jdGlvbihsaW5lLCByb3csIG9mZnNldCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGxpbmUuc2VhcmNoKHJlWzBdKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gLTEpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93ICsgaSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zZWFyY2gocmVbaV0pID09IC0xKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBsaW5lLm1hdGNoKHJlW2xlbiAtIDFdKVswXS5sZW5ndGg7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShyb3csIHN0YXJ0SW5kZXgsIHJvdyArIGxlbiAtIDEsIGVuZEluZGV4KTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHJlLm9mZnNldCA9PSAxKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5yb3ctLTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IE51bWJlci5NQVhfVkFMVUU7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0KVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uICs9IG9mZnNldDtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHJhbmdlKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGJhY2t3YXJkcykge1xcblxcdCAgICAgICAgICAgIHZhciBtYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24obGluZSwgcm93LCBzdGFydEluZGV4KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gbGFuZy5nZXRNYXRjaE9mZnNldHMobGluZSwgcmUpO1xcblxcdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2hlcy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pXFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sobWF0Y2hlc1tpXSwgcm93LCBzdGFydEluZGV4KSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgbWF0Y2hJdGVyYXRvciA9IGZ1bmN0aW9uKGxpbmUsIHJvdywgc3RhcnRJbmRleCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxhbmcuZ2V0TWF0Y2hPZmZzZXRzKGxpbmUsIHJlKTtcXG5cXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKVxcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG1hdGNoZXNbaV0sIHJvdywgc3RhcnRJbmRleCkpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24oX2NhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gX2NhbGxiYWNrO1xcblxcdCAgICAgICAgICAgICAgICBzZWxmLiRsaW5lSXRlcmF0b3Ioc2Vzc2lvbiwgb3B0aW9ucykuZm9yRWFjaChtYXRjaEl0ZXJhdG9yKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRhc3NlbWJsZVJlZ0V4cCA9IGZ1bmN0aW9uKG9wdGlvbnMsICRkaXNhYmxlRmFrZU11bHRpbGluZSkge1xcblxcdCAgICAgICAgaWYgKG9wdGlvbnMubmVlZGxlIGluc3RhbmNlb2YgUmVnRXhwKVxcblxcdCAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gb3B0aW9ucy5uZWVkbGU7XFxuXFxuXFx0ICAgICAgICB2YXIgbmVlZGxlID0gb3B0aW9ucy5uZWVkbGU7XFxuXFxuXFx0ICAgICAgICBpZiAoIW9wdGlvbnMubmVlZGxlKVxcblxcdCAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlID0gZmFsc2U7XFxuXFxuXFx0ICAgICAgICBpZiAoIW9wdGlvbnMucmVnRXhwKVxcblxcdCAgICAgICAgICAgIG5lZWRsZSA9IGxhbmcuZXNjYXBlUmVnRXhwKG5lZWRsZSk7XFxuXFxuXFx0ICAgICAgICBpZiAob3B0aW9ucy53aG9sZVdvcmQpXFxuXFx0ICAgICAgICAgICAgbmVlZGxlID0gXFxcIlxcXFxcXFxcYlxcXCIgKyBuZWVkbGUgKyBcXFwiXFxcXFxcXFxiXFxcIjtcXG5cXG5cXHQgICAgICAgIHZhciBtb2RpZmllciA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IFxcXCJnbVxcXCIgOiBcXFwiZ21pXFxcIjtcXG5cXG5cXHQgICAgICAgIG9wdGlvbnMuJGlzTXVsdGlMaW5lID0gISRkaXNhYmxlRmFrZU11bHRpbGluZSAmJiAvW1xcXFxuXFxcXHJdLy50ZXN0KG5lZWRsZSk7XFxuXFx0ICAgICAgICBpZiAob3B0aW9ucy4kaXNNdWx0aUxpbmUpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmUgPSB0aGlzLiRhc3NlbWJsZU11bHRpbGluZVJlZ0V4cChuZWVkbGUsIG1vZGlmaWVyKTtcXG5cXG5cXHQgICAgICAgIHRyeSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChuZWVkbGUsIG1vZGlmaWVyKTtcXG5cXHQgICAgICAgIH0gY2F0Y2goZSkge1xcblxcdCAgICAgICAgICAgIHJlID0gZmFsc2U7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gb3B0aW9ucy5yZSA9IHJlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRhc3NlbWJsZU11bHRpbGluZVJlZ0V4cCA9IGZ1bmN0aW9uKG5lZWRsZSwgbW9kaWZpZXIpIHtcXG5cXHQgICAgICAgIHZhciBwYXJ0cyA9IG5lZWRsZS5yZXBsYWNlKC9cXFxcclxcXFxufFxcXFxyfFxcXFxuL2csIFxcXCIkXFxcXG5eXFxcIikuc3BsaXQoXFxcIlxcXFxuXFxcIik7XFxuXFx0ICAgICAgICB2YXIgcmUgPSBbXTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHRyeSB7XFxuXFx0ICAgICAgICAgICAgcmUucHVzaChuZXcgUmVnRXhwKHBhcnRzW2ldLCBtb2RpZmllcikpO1xcblxcdCAgICAgICAgfSBjYXRjaChlKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKHBhcnRzWzBdID09IFxcXCJcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgcmUuc2hpZnQoKTtcXG5cXHQgICAgICAgICAgICByZS5vZmZzZXQgPSAxO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZS5vZmZzZXQgPSAwO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIHJlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRsaW5lSXRlcmF0b3IgPSBmdW5jdGlvbihzZXNzaW9uLCBvcHRpb25zKSB7XFxuXFx0ICAgICAgICB2YXIgYmFja3dhcmRzID0gb3B0aW9ucy5iYWNrd2FyZHMgPT0gdHJ1ZTtcXG5cXHQgICAgICAgIHZhciBza2lwQ3VycmVudCA9IG9wdGlvbnMuc2tpcEN1cnJlbnQgIT0gZmFsc2U7XFxuXFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBvcHRpb25zLnJhbmdlO1xcblxcdCAgICAgICAgdmFyIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcXG5cXHQgICAgICAgIGlmICghc3RhcnQpXFxuXFx0ICAgICAgICAgICAgc3RhcnQgPSByYW5nZSA/IHJhbmdlW2JhY2t3YXJkcyA/IFxcXCJlbmRcXFwiIDogXFxcInN0YXJ0XFxcIl0gOiBzZXNzaW9uLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xcblxcdCAgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHN0YXJ0LnN0YXJ0KVxcblxcdCAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRbc2tpcEN1cnJlbnQgIT0gYmFja3dhcmRzID8gXFxcImVuZFxcXCIgOiBcXFwic3RhcnRcXFwiXTtcXG5cXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IHJhbmdlID8gcmFuZ2Uuc3RhcnQucm93IDogMDtcXG5cXHQgICAgICAgIHZhciBsYXN0Um93ID0gcmFuZ2UgPyByYW5nZS5lbmQucm93IDogc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDE7XFxuXFxuXFx0ICAgICAgICB2YXIgZm9yRWFjaCA9IGJhY2t3YXJkcyA/IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByb3cgPSBzdGFydC5yb3c7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdykuc3Vic3RyaW5nKDAsIHN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhsaW5lLCByb3cpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgICAgICAgICBmb3IgKHJvdy0tOyByb3cgPj0gZmlyc3RSb3c7IHJvdy0tKVxcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKHNlc3Npb24uZ2V0TGluZShyb3cpLCByb3cpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud3JhcCA9PSBmYWxzZSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgICAgICAgICAgZm9yIChyb3cgPSBsYXN0Um93LCBmaXJzdFJvdyA9IHN0YXJ0LnJvdzsgcm93ID49IGZpcnN0Um93OyByb3ctLSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhzZXNzaW9uLmdldExpbmUocm93KSwgcm93KSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByb3cgPSBzdGFydC5yb3c7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdykuc3Vic3RyKHN0YXJ0LmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhsaW5lLCByb3csIHN0YXJ0LmNvbHVtbikpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGZvciAocm93ID0gcm93KzE7IHJvdyA8PSBsYXN0Um93OyByb3crKylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhzZXNzaW9uLmdldExpbmUocm93KSwgcm93KSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndyYXAgPT0gZmFsc2UpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGZvciAocm93ID0gZmlyc3RSb3csIGxhc3RSb3cgPSBzdGFydC5yb3c7IHJvdyA8PSBsYXN0Um93OyByb3crKylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhzZXNzaW9uLmdldExpbmUocm93KSwgcm93KSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgcmV0dXJuIHtmb3JFYWNoOiBmb3JFYWNofTtcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKFNlYXJjaC5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuU2VhcmNoID0gU2VhcmNoO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2tleXNcXFwiLFxcXCJhY2UvbGliL3VzZXJhZ2VudFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBrZXlVdGlsID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9rZXlzXFxcIik7XFxuXFx0dmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvdXNlcmFnZW50XFxcIik7XFxuXFx0dmFyIEtFWV9NT0RTID0ga2V5VXRpbC5LRVlfTU9EUztcXG5cXG5cXHRmdW5jdGlvbiBIYXNoSGFuZGxlcihjb25maWcsIHBsYXRmb3JtKSB7XFxuXFx0ICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybSB8fCAodXNlcmFnZW50LmlzTWFjID8gXFxcIm1hY1xcXCIgOiBcXFwid2luXFxcIik7XFxuXFx0ICAgIHRoaXMuY29tbWFuZHMgPSB7fTtcXG5cXHQgICAgdGhpcy5jb21tYW5kS2V5QmluZGluZyA9IHt9O1xcblxcdCAgICB0aGlzLmFkZENvbW1hbmRzKGNvbmZpZyk7XFxuXFx0ICAgIHRoaXMuJHNpbmdsZUNvbW1hbmQgPSB0cnVlO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBNdWx0aUhhc2hIYW5kbGVyKGNvbmZpZywgcGxhdGZvcm0pIHtcXG5cXHQgICAgSGFzaEhhbmRsZXIuY2FsbCh0aGlzLCBjb25maWcsIHBsYXRmb3JtKTtcXG5cXHQgICAgdGhpcy4kc2luZ2xlQ29tbWFuZCA9IGZhbHNlO1xcblxcdH1cXG5cXG5cXHRNdWx0aUhhc2hIYW5kbGVyLnByb3RvdHlwZSA9IEhhc2hIYW5kbGVyLnByb3RvdHlwZTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFxuXFx0ICAgIHRoaXMuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uKGNvbW1hbmQpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLmNvbW1hbmRzW2NvbW1hbmQubmFtZV0pXFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW1vdmVDb21tYW5kKGNvbW1hbmQpO1xcblxcblxcdCAgICAgICAgdGhpcy5jb21tYW5kc1tjb21tYW5kLm5hbWVdID0gY29tbWFuZDtcXG5cXG5cXHQgICAgICAgIGlmIChjb21tYW5kLmJpbmRLZXkpXFxuXFx0ICAgICAgICAgICAgdGhpcy5fYnVpbGRLZXlIYXNoKGNvbW1hbmQpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnJlbW92ZUNvbW1hbmQgPSBmdW5jdGlvbihjb21tYW5kLCBrZWVwQ29tbWFuZCkge1xcblxcdCAgICAgICAgdmFyIG5hbWUgPSBjb21tYW5kICYmICh0eXBlb2YgY29tbWFuZCA9PT0gJ3N0cmluZycgPyBjb21tYW5kIDogY29tbWFuZC5uYW1lKTtcXG5cXHQgICAgICAgIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzW25hbWVdO1xcblxcdCAgICAgICAgaWYgKCFrZWVwQ29tbWFuZClcXG5cXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5jb21tYW5kc1tuYW1lXTtcXG5cXHQgICAgICAgIHZhciBja2IgPSB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nO1xcblxcdCAgICAgICAgZm9yICh2YXIga2V5SWQgaW4gY2tiKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGNtZEdyb3VwID0gY2tiW2tleUlkXTtcXG5cXHQgICAgICAgICAgICBpZiAoY21kR3JvdXAgPT0gY29tbWFuZCkge1xcblxcdCAgICAgICAgICAgICAgICBkZWxldGUgY2tiW2tleUlkXTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY21kR3JvdXApKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBpID0gY21kR3JvdXAuaW5kZXhPZihjb21tYW5kKTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNtZEdyb3VwLnNwbGljZShpLCAxKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChjbWRHcm91cC5sZW5ndGggPT0gMSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBja2Jba2V5SWRdID0gY21kR3JvdXBbMF07XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYmluZEtleSA9IGZ1bmN0aW9uKGtleSwgY29tbWFuZCwgYXNEZWZhdWx0KSB7XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIGtleSA9PSBcXFwib2JqZWN0XFxcIilcXG5cXHQgICAgICAgICAgICBrZXkgPSBrZXlbdGhpcy5wbGF0Zm9ybV07XFxuXFx0ICAgICAgICBpZiAoIWtleSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgPT0gXFxcImZ1bmN0aW9uXFxcIilcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDb21tYW5kKHtleGVjOiBjb21tYW5kLCBiaW5kS2V5OiBrZXksIG5hbWU6IGNvbW1hbmQubmFtZSB8fCBrZXl9KTtcXG5cXG5cXHQgICAgICAgIGtleS5zcGxpdChcXFwifFxcXCIpLmZvckVhY2goZnVuY3Rpb24oa2V5UGFydCkge1xcblxcdCAgICAgICAgICAgIHZhciBjaGFpbiA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgICAgIGlmIChrZXlQYXJ0LmluZGV4T2YoXFxcIiBcXFwiKSAhPSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBrZXlQYXJ0LnNwbGl0KC9cXFxccysvKTtcXG5cXHQgICAgICAgICAgICAgICAga2V5UGFydCA9IHBhcnRzLnBvcCgpO1xcblxcdCAgICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKGtleVBhcnQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5wYXJzZUtleXMoa2V5UGFydCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBLRVlfTU9EU1tiaW5kaW5nLmhhc2hJZF0gKyBiaW5kaW5nLmtleTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNoYWluICs9IChjaGFpbiA/IFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIGlkO1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ29tbWFuZFRvQmluZGluZyhjaGFpbiwgXFxcImNoYWluS2V5c1xcXCIpO1xcblxcdCAgICAgICAgICAgICAgICB9LCB0aGlzKTtcXG5cXHQgICAgICAgICAgICAgICAgY2hhaW4gKz0gXFxcIiBcXFwiO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMucGFyc2VLZXlzKGtleVBhcnQpO1xcblxcdCAgICAgICAgICAgIHZhciBpZCA9IEtFWV9NT0RTW2JpbmRpbmcuaGFzaElkXSArIGJpbmRpbmcua2V5O1xcblxcdCAgICAgICAgICAgIHRoaXMuX2FkZENvbW1hbmRUb0JpbmRpbmcoY2hhaW4gKyBpZCwgY29tbWFuZCwgYXNEZWZhdWx0KTtcXG5cXHQgICAgICAgIH0sIHRoaXMpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLl9hZGRDb21tYW5kVG9CaW5kaW5nID0gZnVuY3Rpb24oa2V5SWQsIGNvbW1hbmQsIGFzRGVmYXVsdCkge1xcblxcdCAgICAgICAgdmFyIGNrYiA9IHRoaXMuY29tbWFuZEtleUJpbmRpbmcsIGk7XFxuXFx0ICAgICAgICBpZiAoIWNvbW1hbmQpIHtcXG5cXHQgICAgICAgICAgICBkZWxldGUgY2tiW2tleUlkXTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoIWNrYltrZXlJZF0gfHwgdGhpcy4kc2luZ2xlQ29tbWFuZCkge1xcblxcdCAgICAgICAgICAgIGNrYltrZXlJZF0gPSBjb21tYW5kO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2tiW2tleUlkXSkpIHtcXG5cXHQgICAgICAgICAgICAgICAgY2tiW2tleUlkXSA9IFtja2Jba2V5SWRdXTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKChpID0gY2tiW2tleUlkXS5pbmRleE9mKGNvbW1hbmQpKSAhPSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICBja2Jba2V5SWRdLnNwbGljZShpLCAxKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGFzRGVmYXVsdCB8fCBjb21tYW5kLmlzRGVmYXVsdClcXG5cXHQgICAgICAgICAgICAgICAgY2tiW2tleUlkXS51bnNoaWZ0KGNvbW1hbmQpO1xcblxcdCAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgY2tiW2tleUlkXS5wdXNoKGNvbW1hbmQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmFkZENvbW1hbmRzID0gZnVuY3Rpb24oY29tbWFuZHMpIHtcXG5cXHQgICAgICAgIGNvbW1hbmRzICYmIE9iamVjdC5rZXlzKGNvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcXG5cXHQgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGNvbW1hbmRzW25hbWVdO1xcblxcdCAgICAgICAgICAgIGlmICghY29tbWFuZClcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRLZXkoY29tbWFuZCwgbmFtZSk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSBcXFwiZnVuY3Rpb25cXFwiKVxcblxcdCAgICAgICAgICAgICAgICBjb21tYW5kID0geyBleGVjOiBjb21tYW5kIH07XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kICE9PSBcXFwib2JqZWN0XFxcIilcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgICAgIGlmICghY29tbWFuZC5uYW1lKVxcblxcdCAgICAgICAgICAgICAgICBjb21tYW5kLm5hbWUgPSBuYW1lO1xcblxcblxcdCAgICAgICAgICAgIHRoaXMuYWRkQ29tbWFuZChjb21tYW5kKTtcXG5cXHQgICAgICAgIH0sIHRoaXMpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnJlbW92ZUNvbW1hbmRzID0gZnVuY3Rpb24oY29tbWFuZHMpIHtcXG5cXHQgICAgICAgIE9iamVjdC5rZXlzKGNvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbW1hbmQoY29tbWFuZHNbbmFtZV0pO1xcblxcdCAgICAgICAgfSwgdGhpcyk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYmluZEtleXMgPSBmdW5jdGlvbihrZXlMaXN0KSB7XFxuXFx0ICAgICAgICBPYmplY3Qua2V5cyhrZXlMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuYmluZEtleShrZXksIGtleUxpc3Rba2V5XSk7XFxuXFx0ICAgICAgICB9LCB0aGlzKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5fYnVpbGRLZXlIYXNoID0gZnVuY3Rpb24oY29tbWFuZCkge1xcblxcdCAgICAgICAgdGhpcy5iaW5kS2V5KGNvbW1hbmQuYmluZEtleSwgY29tbWFuZCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucGFyc2VLZXlzID0gZnVuY3Rpb24oa2V5cykge1xcblxcdCAgICAgICAgdmFyIHBhcnRzID0ga2V5cy50b0xvd2VyQ2FzZSgpLnNwbGl0KC9bXFxcXC1cXFxcK10oW1xcXFwtXFxcXCtdKT8vKS5maWx0ZXIoZnVuY3Rpb24oeCl7cmV0dXJuIHh9KTtcXG5cXHQgICAgICAgIHZhciBrZXkgPSBwYXJ0cy5wb3AoKTtcXG5cXG5cXHQgICAgICAgIHZhciBrZXlDb2RlID0ga2V5VXRpbFtrZXldO1xcblxcdCAgICAgICAgaWYgKGtleVV0aWwuRlVOQ1RJT05fS0VZU1trZXlDb2RlXSlcXG5cXHQgICAgICAgICAgICBrZXkgPSBrZXlVdGlsLkZVTkNUSU9OX0tFWVNba2V5Q29kZV0udG9Mb3dlckNhc2UoKTtcXG5cXHQgICAgICAgIGVsc2UgaWYgKCFwYXJ0cy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHtrZXk6IGtleSwgaGFzaElkOiAtMX07XFxuXFx0ICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXSA9PSBcXFwic2hpZnRcXFwiKVxcblxcdCAgICAgICAgICAgIHJldHVybiB7a2V5OiBrZXkudG9VcHBlckNhc2UoKSwgaGFzaElkOiAtMX07XFxuXFxuXFx0ICAgICAgICB2YXIgaGFzaElkID0gMDtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGg7IGktLTspIHtcXG5cXHQgICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBrZXlVdGlsLktFWV9NT0RTW3BhcnRzW2ldXTtcXG5cXHQgICAgICAgICAgICBpZiAobW9kaWZpZXIgPT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT0gXFxcInVuZGVmaW5lZFxcXCIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJpbnZhbGlkIG1vZGlmaWVyIFxcXCIgKyBwYXJ0c1tpXSArIFxcXCIgaW4gXFxcIiArIGtleXMpO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGhhc2hJZCB8PSBtb2RpZmllcjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiB7a2V5OiBrZXksIGhhc2hJZDogaGFzaElkfTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5maW5kS2V5Q29tbWFuZCA9IGZ1bmN0aW9uIGZpbmRLZXlDb21tYW5kKGhhc2hJZCwga2V5U3RyaW5nKSB7XFxuXFx0ICAgICAgICB2YXIga2V5ID0gS0VZX01PRFNbaGFzaElkXSArIGtleVN0cmluZztcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRLZXlCaW5kaW5nW2tleV07XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuaGFuZGxlS2V5Ym9hcmQgPSBmdW5jdGlvbihkYXRhLCBoYXNoSWQsIGtleVN0cmluZywga2V5Q29kZSkge1xcblxcdCAgICAgICAgdmFyIGtleSA9IEtFWV9NT0RTW2hhc2hJZF0gKyBrZXlTdHJpbmc7XFxuXFx0ICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuY29tbWFuZEtleUJpbmRpbmdba2V5XTtcXG5cXHQgICAgICAgIGlmIChkYXRhLiRrZXlDaGFpbikge1xcblxcdCAgICAgICAgICAgIGRhdGEuJGtleUNoYWluICs9IFxcXCIgXFxcIiArIGtleTtcXG5cXHQgICAgICAgICAgICBjb21tYW5kID0gdGhpcy5jb21tYW5kS2V5QmluZGluZ1tkYXRhLiRrZXlDaGFpbl0gfHwgY29tbWFuZDtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChjb21tYW5kKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gXFxcImNoYWluS2V5c1xcXCIgfHwgY29tbWFuZFtjb21tYW5kLmxlbmd0aCAtIDFdID09IFxcXCJjaGFpbktleXNcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGRhdGEuJGtleUNoYWluID0gZGF0YS4ka2V5Q2hhaW4gfHwga2V5O1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4ge2NvbW1hbmQ6IFxcXCJudWxsXFxcIn07XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKGRhdGEuJGtleUNoYWluICYmIGtleUNvZGUgPiAwKVxcblxcdCAgICAgICAgICAgIGRhdGEuJGtleUNoYWluID0gXFxcIlxcXCI7XFxuXFx0ICAgICAgICByZXR1cm4ge2NvbW1hbmQ6IGNvbW1hbmR9O1xcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoSGFzaEhhbmRsZXIucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLkhhc2hIYW5kbGVyID0gSGFzaEhhbmRsZXI7XFxuXFx0ZXhwb3J0cy5NdWx0aUhhc2hIYW5kbGVyID0gTXVsdGlIYXNoSGFuZGxlcjtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvY29tbWFuZHMvY29tbWFuZF9tYW5hZ2VyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiLFxcXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXFxcIixcXFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIE11bHRpSGFzaEhhbmRsZXIgPSBhY2VxdWlyZShcXFwiLi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXFxcIikuTXVsdGlIYXNoSGFuZGxlcjtcXG5cXHR2YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9ldmVudF9lbWl0dGVyXFxcIikuRXZlbnRFbWl0dGVyO1xcblxcblxcdHZhciBDb21tYW5kTWFuYWdlciA9IGZ1bmN0aW9uKHBsYXRmb3JtLCBjb21tYW5kcykge1xcblxcdCAgICBNdWx0aUhhc2hIYW5kbGVyLmNhbGwodGhpcywgY29tbWFuZHMsIHBsYXRmb3JtKTtcXG5cXHQgICAgdGhpcy5ieU5hbWUgPSB0aGlzLmNvbW1hbmRzO1xcblxcdCAgICB0aGlzLnNldERlZmF1bHRIYW5kbGVyKFxcXCJleGVjXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgcmV0dXJuIGUuY29tbWFuZC5leGVjKGUuZWRpdG9yLCBlLmFyZ3MgfHwge30pO1xcblxcdCAgICB9KTtcXG5cXHR9O1xcblxcblxcdG9vcC5pbmhlcml0cyhDb21tYW5kTWFuYWdlciwgTXVsdGlIYXNoSGFuZGxlcik7XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XFxuXFxuXFx0ICAgIHRoaXMuZXhlYyA9IGZ1bmN0aW9uKGNvbW1hbmQsIGVkaXRvciwgYXJncykge1xcblxcdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tbWFuZCkpIHtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gY29tbWFuZC5sZW5ndGg7IGktLTsgKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4ZWMoY29tbWFuZFtpXSwgZWRpdG9yLCBhcmdzKSkgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gXFxcInN0cmluZ1xcXCIpXFxuXFx0ICAgICAgICAgICAgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbY29tbWFuZF07XFxuXFxuXFx0ICAgICAgICBpZiAoIWNvbW1hbmQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcblxcdCAgICAgICAgaWYgKGVkaXRvciAmJiBlZGl0b3IuJHJlYWRPbmx5ICYmICFjb21tYW5kLnJlYWRPbmx5KVxcblxcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXG5cXHQgICAgICAgIHZhciBlID0ge2VkaXRvcjogZWRpdG9yLCBjb21tYW5kOiBjb21tYW5kLCBhcmdzOiBhcmdzfTtcXG5cXHQgICAgICAgIGUucmV0dXJuVmFsdWUgPSB0aGlzLl9lbWl0KFxcXCJleGVjXFxcIiwgZSk7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImFmdGVyRXhlY1xcXCIsIGUpO1xcblxcblxcdCAgICAgICAgcmV0dXJuIGUucmV0dXJuVmFsdWUgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnRvZ2dsZVJlY29yZGluZyA9IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJGluUmVwbGF5KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIGVkaXRvciAmJiBlZGl0b3IuX2VtaXQoXFxcImNoYW5nZVN0YXR1c1xcXCIpO1xcblxcdCAgICAgICAgaWYgKHRoaXMucmVjb3JkaW5nKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tYWNyby5wb3AoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImV4ZWNcXFwiLCB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hY3JvLmxlbmd0aClcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5tYWNybyA9IHRoaXMub2xkTWFjcm87XFxuXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nID0gZmFsc2U7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGFkZENvbW1hbmRUb01hY3JvKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kYWRkQ29tbWFuZFRvTWFjcm8gPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubWFjcm8ucHVzaChbZS5jb21tYW5kLCBlLmFyZ3NdKTtcXG5cXHQgICAgICAgICAgICB9LmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLm9sZE1hY3JvID0gdGhpcy5tYWNybztcXG5cXHQgICAgICAgIHRoaXMubWFjcm8gPSBbXTtcXG5cXHQgICAgICAgIHRoaXMub24oXFxcImV4ZWNcXFwiLCB0aGlzLiRhZGRDb21tYW5kVG9NYWNybyk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnJlcGxheSA9IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJGluUmVwbGF5IHx8ICF0aGlzLm1hY3JvKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnJlY29yZGluZylcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVSZWNvcmRpbmcoZWRpdG9yKTtcXG5cXG5cXHQgICAgICAgIHRyeSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kaW5SZXBsYXkgPSB0cnVlO1xcblxcdCAgICAgICAgICAgIHRoaXMubWFjcm8uZm9yRWFjaChmdW5jdGlvbih4KSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PSBcXFwic3RyaW5nXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlYyh4LCBlZGl0b3IpO1xcblxcdCAgICAgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWMoeFswXSwgZWRpdG9yLCB4WzFdKTtcXG5cXHQgICAgICAgICAgICB9LCB0aGlzKTtcXG5cXHQgICAgICAgIH0gZmluYWxseSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kaW5SZXBsYXkgPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy50cmltTWFjcm8gPSBmdW5jdGlvbihtKSB7XFxuXFx0ICAgICAgICByZXR1cm4gbS5tYXAoZnVuY3Rpb24oeCl7XFxuXFx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB4WzBdICE9IFxcXCJzdHJpbmdcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB4WzBdID0geFswXS5uYW1lO1xcblxcdCAgICAgICAgICAgIGlmICgheFsxXSlcXG5cXHQgICAgICAgICAgICAgICAgeCA9IHhbMF07XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHg7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5Db21tYW5kTWFuYWdlciA9IENvbW1hbmRNYW5hZ2VyO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9jb21tYW5kcy9kZWZhdWx0X2NvbW1hbmRzXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9sYW5nXFxcIixcXFwiYWNlL2NvbmZpZ1xcXCIsXFxcImFjZS9yYW5nZVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIGNvbmZpZyA9IGFjZXF1aXJlKFxcXCIuLi9jb25maWdcXFwiKTtcXG5cXHR2YXIgUmFuZ2UgPSBhY2VxdWlyZShcXFwiLi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXG5cXHRmdW5jdGlvbiBiaW5kS2V5KHdpbiwgbWFjKSB7XFxuXFx0ICAgIHJldHVybiB7d2luOiB3aW4sIG1hYzogbWFjfTtcXG5cXHR9XFxuXFx0ZXhwb3J0cy5jb21tYW5kcyA9IFt7XFxuXFx0ICAgIG5hbWU6IFxcXCJzaG93U2V0dGluZ3NNZW51XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC0sXFxcIiwgXFxcIkNvbW1hbmQtLFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFxcXCJhY2UvZXh0L3NldHRpbmdzX21lbnVcXFwiLCBmdW5jdGlvbihtb2R1bGUpIHtcXG5cXHQgICAgICAgICAgICBtb2R1bGUuaW5pdChlZGl0b3IpO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5zaG93U2V0dGluZ3NNZW51KCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfSxcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJnb1RvTmV4dEVycm9yXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LUVcXFwiLCBcXFwiQ3RybC1FXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXFxcImFjZS9leHQvZXJyb3JfbWFya2VyXFxcIiwgZnVuY3Rpb24obW9kdWxlKSB7XFxuXFx0ICAgICAgICAgICAgbW9kdWxlLnNob3dFcnJvck1hcmtlcihlZGl0b3IsIDEpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiYW5pbWF0ZVxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZ29Ub1ByZXZpb3VzRXJyb3JcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtU2hpZnQtRVxcXCIsIFxcXCJDdHJsLVNoaWZ0LUVcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XFxuXFx0ICAgICAgICBjb25maWcubG9hZE1vZHVsZShcXFwiYWNlL2V4dC9lcnJvcl9tYXJrZXJcXFwiLCBmdW5jdGlvbihtb2R1bGUpIHtcXG5cXHQgICAgICAgICAgICBtb2R1bGUuc2hvd0Vycm9yTWFya2VyKGVkaXRvciwgLTEpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiYW5pbWF0ZVxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0YWxsXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1BXFxcIiwgXFxcIkNvbW1hbmQtQVxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdEFsbCgpOyB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImNlbnRlcnNlbGVjdGlvblxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgXFxcIkN0cmwtTFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNlbnRlclNlbGVjdGlvbigpOyB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvdG9saW5lXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1MXFxcIiwgXFxcIkNvbW1hbmQtTFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgICAgIHZhciBsaW5lID0gcGFyc2VJbnQocHJvbXB0KFxcXCJFbnRlciBsaW5lIG51bWJlcjpcXFwiKSwgMTApO1xcblxcdCAgICAgICAgaWYgKCFpc05hTihsaW5lKSkge1xcblxcdCAgICAgICAgICAgIGVkaXRvci5nb3RvTGluZShsaW5lKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJmb2xkXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LUx8Q3RybC1GMVxcXCIsIFxcXCJDb21tYW5kLUFsdC1MfENvbW1hbmQtRjFcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGQoZmFsc2UpOyB9LFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImNlbnRlclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwidW5mb2xkXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LVNoaWZ0LUx8Q3RybC1TaGlmdC1GMVxcXCIsIFxcXCJDb21tYW5kLUFsdC1TaGlmdC1MfENvbW1hbmQtU2hpZnQtRjFcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGQodHJ1ZSk7IH0sXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY2VudGVyXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJ0b2dnbGVGb2xkV2lkZ2V0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiRjJcXFwiLCBcXFwiRjJcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnRvZ2dsZUZvbGRXaWRnZXQoKTsgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjZW50ZXJcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInRvZ2dsZVBhcmVudEZvbGRXaWRnZXRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtRjJcXFwiLCBcXFwiQWx0LUYyXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2Vzc2lvbi50b2dnbGVGb2xkV2lkZ2V0KHRydWUpOyB9LFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImNlbnRlclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZm9sZGFsbFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtQWx0LTBcXFwiLCBcXFwiQ3RybC1Db21tYW5kLU9wdGlvbi0wXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2Vzc2lvbi5mb2xkQWxsKCk7IH0sXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY2VudGVyXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJmb2xkT3RoZXJcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtMFxcXCIsIFxcXCJDb21tYW5kLU9wdGlvbi0wXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBcXG5cXHQgICAgICAgIGVkaXRvci5zZXNzaW9uLmZvbGRBbGwoKTtcXG5cXHQgICAgICAgIGVkaXRvci5zZXNzaW9uLnVuZm9sZChlZGl0b3Iuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpKTtcXG5cXHQgICAgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjZW50ZXJcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInVuZm9sZGFsbFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkFsdC1TaGlmdC0wXFxcIiwgXFxcIkNvbW1hbmQtT3B0aW9uLVNoaWZ0LTBcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZXNzaW9uLnVuZm9sZCgpOyB9LFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImNlbnRlclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZmluZG5leHRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLUtcXFwiLCBcXFwiQ29tbWFuZC1HXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZmluZE5leHQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjZW50ZXJcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImZpbmRwcmV2aW91c1xcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtU2hpZnQtS1xcXCIsIFxcXCJDb21tYW5kLVNoaWZ0LUdcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5maW5kUHJldmlvdXMoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjZW50ZXJcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdE9yRmluZE5leHRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtS1xcXCIsIFxcXCJDdHJsLUdcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XFxuXFx0ICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbi5pc0VtcHR5KCkpXFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgZWRpdG9yLmZpbmROZXh0KCk7IFxcblxcdCAgICB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdE9yRmluZFByZXZpb3VzXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LVNoaWZ0LUtcXFwiLCBcXFwiQ3RybC1TaGlmdC1HXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBcXG5cXHQgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzRW1wdHkoKSlcXG5cXHQgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICBlZGl0b3IuZmluZFByZXZpb3VzKCk7XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZmluZFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtRlxcXCIsIFxcXCJDb21tYW5kLUZcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XFxuXFx0ICAgICAgICBjb25maWcubG9hZE1vZHVsZShcXFwiYWNlL2V4dC9zZWFyY2hib3hcXFwiLCBmdW5jdGlvbihlKSB7ZS5TZWFyY2goZWRpdG9yKX0pO1xcblxcdCAgICB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcIm92ZXJ3cml0ZVxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IFxcXCJJbnNlcnRcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdHRvc3RhcnRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVNoaWZ0LUhvbWVcXFwiLCBcXFwiQ29tbWFuZC1TaGlmdC1VcFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdEZpbGVTdGFydCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJhbmltYXRlXFxcIixcXG5cXHQgICAgYWNlQ29tbWFuZEdyb3VwOiBcXFwiZmlsZUp1bXBcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZ290b3N0YXJ0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1Ib21lXFxcIiwgXFxcIkNvbW1hbmQtSG9tZXxDb21tYW5kLVVwXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVGaWxlU3RhcnQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWUsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiYW5pbWF0ZVxcXCIsXFxuXFx0ICAgIGFjZUNvbW1hbmRHcm91cDogXFxcImZpbGVKdW1wXFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdHVwXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiU2hpZnQtVXBcXFwiLCBcXFwiU2hpZnQtVXBcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RVcCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvbGluZXVwXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiVXBcXFwiLCBcXFwiVXB8Q3RybC1QXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvciwgYXJncykgeyBlZGl0b3IubmF2aWdhdGVVcChhcmdzLnRpbWVzKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJzZWxlY3R0b2VuZFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtU2hpZnQtRW5kXFxcIiwgXFxcIkNvbW1hbmQtU2hpZnQtRG93blxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdEZpbGVFbmQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWUsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiYW5pbWF0ZVxcXCIsXFxuXFx0ICAgIGFjZUNvbW1hbmRHcm91cDogXFxcImZpbGVKdW1wXFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvdG9lbmRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLUVuZFxcXCIsIFxcXCJDb21tYW5kLUVuZHxDb21tYW5kLURvd25cXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZUZpbGVFbmQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWUsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiYW5pbWF0ZVxcXCIsXFxuXFx0ICAgIGFjZUNvbW1hbmRHcm91cDogXFxcImZpbGVKdW1wXFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdGRvd25cXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJTaGlmdC1Eb3duXFxcIiwgXFxcIlNoaWZ0LURvd25cXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3REb3duKCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJnb2xpbmVkb3duXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiRG93blxcXCIsIFxcXCJEb3dufEN0cmwtTlxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IsIGFyZ3MpIHsgZWRpdG9yLm5hdmlnYXRlRG93bihhcmdzLnRpbWVzKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdHdvcmRsZWZ0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1TaGlmdC1MZWZ0XFxcIiwgXFxcIk9wdGlvbi1TaGlmdC1MZWZ0XFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0V29yZExlZnQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvdG93b3JkbGVmdFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtTGVmdFxcXCIsIFxcXCJPcHRpb24tTGVmdFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLm5hdmlnYXRlV29yZExlZnQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdHRvbGluZXN0YXJ0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LVNoaWZ0LUxlZnRcXFwiLCBcXFwiQ29tbWFuZC1TaGlmdC1MZWZ0XFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0TGluZVN0YXJ0KCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJnb3RvbGluZXN0YXJ0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LUxlZnR8SG9tZVxcXCIsIFxcXCJDb21tYW5kLUxlZnR8SG9tZXxDdHJsLUFcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZUxpbmVTdGFydCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0bGVmdFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIlNoaWZ0LUxlZnRcXFwiLCBcXFwiU2hpZnQtTGVmdFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExlZnQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvdG9sZWZ0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiTGVmdFxcXCIsIFxcXCJMZWZ0fEN0cmwtQlxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IsIGFyZ3MpIHsgZWRpdG9yLm5hdmlnYXRlTGVmdChhcmdzLnRpbWVzKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdHdvcmRyaWdodFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtU2hpZnQtUmlnaHRcXFwiLCBcXFwiT3B0aW9uLVNoaWZ0LVJpZ2h0XFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0V29yZFJpZ2h0KCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJnb3Rvd29yZHJpZ2h0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1SaWdodFxcXCIsIFxcXCJPcHRpb24tUmlnaHRcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5uYXZpZ2F0ZVdvcmRSaWdodCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0dG9saW5lZW5kXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LVNoaWZ0LVJpZ2h0XFxcIiwgXFxcIkNvbW1hbmQtU2hpZnQtUmlnaHRcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5zZWxlY3RMaW5lRW5kKCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJnb3RvbGluZWVuZFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkFsdC1SaWdodHxFbmRcXFwiLCBcXFwiQ29tbWFuZC1SaWdodHxFbmR8Q3RybC1FXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubmF2aWdhdGVMaW5lRW5kKCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJzZWxlY3RyaWdodFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIlNoaWZ0LVJpZ2h0XFxcIiwgXFxcIlNoaWZ0LVJpZ2h0XFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmlnaHQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvdG9yaWdodFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIlJpZ2h0XFxcIiwgXFxcIlJpZ2h0fEN0cmwtRlxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IsIGFyZ3MpIHsgZWRpdG9yLm5hdmlnYXRlUmlnaHQoYXJncy50aW1lcyk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJzZWxlY3RwYWdlZG93blxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IFxcXCJTaGlmdC1QYWdlRG93blxcXCIsXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0UGFnZURvd24oKTsgfSxcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJwYWdlZG93blxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgXFxcIk9wdGlvbi1QYWdlRG93blxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNjcm9sbFBhZ2VEb3duKCk7IH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZ290b3BhZ2Vkb3duXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiUGFnZURvd25cXFwiLCBcXFwiUGFnZURvd258Q3RybC1WXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuZ290b1BhZ2VEb3duKCk7IH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0cGFnZXVwXFxcIixcXG5cXHQgICAgYmluZEtleTogXFxcIlNoaWZ0LVBhZ2VVcFxcXCIsXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0UGFnZVVwKCk7IH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwicGFnZXVwXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShudWxsLCBcXFwiT3B0aW9uLVBhZ2VVcFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNjcm9sbFBhZ2VVcCgpOyB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImdvdG9wYWdldXBcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBcXFwiUGFnZVVwXFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5nb3RvUGFnZVVwKCk7IH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2Nyb2xsdXBcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVVwXFxcIiwgbnVsbCksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGUpIHsgZS5yZW5kZXJlci5zY3JvbGxCeSgwLCAtMiAqIGUucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodCk7IH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2Nyb2xsZG93blxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtRG93blxcXCIsIG51bGwpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlKSB7IGUucmVuZGVyZXIuc2Nyb2xsQnkoMCwgMiAqIGUucmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodCk7IH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0bGluZXN0YXJ0XFxcIixcXG5cXHQgICAgYmluZEtleTogXFxcIlNoaWZ0LUhvbWVcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExpbmVTdGFydCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0bGluZWVuZFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IFxcXCJTaGlmdC1FbmRcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdExpbmVFbmQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInRvZ2dsZXJlY29yZGluZ1xcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtQWx0LUVcXFwiLCBcXFwiQ29tbWFuZC1PcHRpb24tRVxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVJlY29yZGluZyhlZGl0b3IpOyB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInJlcGxheW1hY3JvXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1TaGlmdC1FXFxcIiwgXFxcIkNvbW1hbmQtU2hpZnQtRVxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNvbW1hbmRzLnJlcGxheShlZGl0b3IpOyB9LFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImp1bXB0b21hdGNoaW5nXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1QXFxcIiwgXFxcIkN0cmwtUFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmp1bXBUb01hdGNoaW5nKCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0dG9tYXRjaGluZ1xcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtU2hpZnQtUFxcXCIsIFxcXCJDdHJsLVNoaWZ0LVBcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5qdW1wVG9NYXRjaGluZyh0cnVlKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgcmVhZE9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJwYXNzS2V5c1RvQnJvd3NlclxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIm51bGxcXFwiLCBcXFwibnVsbFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbigpIHt9LFxcblxcdCAgICBwYXNzRXZlbnQ6IHRydWUsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSxcXG5cXHR7XFxuXFx0ICAgIG5hbWU6IFxcXCJjdXRcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgZWRpdG9yLl9lbWl0KFxcXCJjdXRcXFwiLCByYW5nZSk7XFxuXFxuXFx0ICAgICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiLFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwicmVtb3ZlbGluZVxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtRFxcXCIsIFxcXCJDb21tYW5kLURcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5yZW1vdmVMaW5lcygpOyB9LFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCIsXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaExpbmVcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZHVwbGljYXRlU2VsZWN0aW9uXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1TaGlmdC1EXFxcIiwgXFxcIkNvbW1hbmQtU2hpZnQtRFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmR1cGxpY2F0ZVNlbGVjdGlvbigpOyB9LFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCIsXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaFxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJzb3J0bGluZXNcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLUFsdC1TXFxcIiwgXFxcIkNvbW1hbmQtQWx0LVNcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zb3J0TGluZXMoKTsgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJzZWxlY3Rpb25cXFwiLFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hMaW5lXFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInRvZ2dsZWNvbW1lbnRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLS9cXFwiLCBcXFwiQ29tbWFuZC0vXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IudG9nZ2xlQ29tbWVudExpbmVzKCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaExpbmVcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcInNlbGVjdGlvblBhcnRcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwidG9nZ2xlQmxvY2tDb21tZW50XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1TaGlmdC0vXFxcIiwgXFxcIkNvbW1hbmQtU2hpZnQtL1xcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnRvZ2dsZUJsb2NrQ29tbWVudCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcInNlbGVjdGlvblBhcnRcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwibW9kaWZ5TnVtYmVyVXBcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVNoaWZ0LVVwXFxcIiwgXFxcIkFsdC1TaGlmdC1VcFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLm1vZGlmeU51bWJlcigxKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcIm1vZGlmeU51bWJlckRvd25cXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVNoaWZ0LURvd25cXFwiLCBcXFwiQWx0LVNoaWZ0LURvd25cXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5tb2RpZnlOdW1iZXIoLTEpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwicmVwbGFjZVxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtSFxcXCIsIFxcXCJDb21tYW5kLU9wdGlvbi1GXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICAgICAgY29uZmlnLmxvYWRNb2R1bGUoXFxcImFjZS9leHQvc2VhcmNoYm94XFxcIiwgZnVuY3Rpb24oZSkge2UuU2VhcmNoKGVkaXRvciwgdHJ1ZSl9KTtcXG5cXHQgICAgfVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInVuZG9cXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVpcXFwiLCBcXFwiQ29tbWFuZC1aXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IudW5kbygpOyB9XFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwicmVkb1xcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtU2hpZnQtWnxDdHJsLVlcXFwiLCBcXFwiQ29tbWFuZC1TaGlmdC1afENvbW1hbmQtWVxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlZG8oKTsgfVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImNvcHlsaW5lc3VwXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQWx0LVNoaWZ0LVVwXFxcIiwgXFxcIkNvbW1hbmQtT3B0aW9uLVVwXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuY29weUxpbmVzVXAoKTsgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwibW92ZWxpbmVzdXBcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtVXBcXFwiLCBcXFwiT3B0aW9uLVVwXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IubW92ZUxpbmVzVXAoKTsgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiY29weWxpbmVzZG93blxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkFsdC1TaGlmdC1Eb3duXFxcIiwgXFxcIkNvbW1hbmQtT3B0aW9uLURvd25cXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb3B5TGluZXNEb3duKCk7IH0sXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwiY3Vyc29yXFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcIm1vdmVsaW5lc2Rvd25cXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtRG93blxcXCIsIFxcXCJPcHRpb24tRG93blxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLm1vdmVMaW5lc0Rvd24oKTsgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZGVsXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiRGVsZXRlXFxcIiwgXFxcIkRlbGV0ZXxDdHJsLUR8U2hpZnQtRGVsZXRlXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IucmVtb3ZlKFxcXCJyaWdodFxcXCIpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJiYWNrc3BhY2VcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcblxcdCAgICAgICAgXFxcIlNoaWZ0LUJhY2tzcGFjZXxCYWNrc3BhY2VcXFwiLFxcblxcdCAgICAgICAgXFxcIkN0cmwtQmFja3NwYWNlfFNoaWZ0LUJhY2tzcGFjZXxCYWNrc3BhY2V8Q3RybC1IXFxcIlxcblxcdCAgICApLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZShcXFwibGVmdFxcXCIpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJjdXRfb3JfZGVsZXRlXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiU2hpZnQtRGVsZXRlXFxcIiwgbnVsbCksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBcXG5cXHQgICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xcblxcdCAgICAgICAgICAgIGVkaXRvci5yZW1vdmUoXFxcImxlZnRcXFwiKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJyZW1vdmV0b2xpbmVzdGFydFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkFsdC1CYWNrc3BhY2VcXFwiLCBcXFwiQ29tbWFuZC1CYWNrc3BhY2VcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5yZW1vdmVUb0xpbmVTdGFydCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJyZW1vdmV0b2xpbmVlbmRcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJBbHQtRGVsZXRlXFxcIiwgXFxcIkN0cmwtS1xcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVRvTGluZUVuZCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJyZW1vdmV3b3JkbGVmdFxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtQmFja3NwYWNlXFxcIiwgXFxcIkFsdC1CYWNrc3BhY2V8Q3RybC1BbHQtQmFja3NwYWNlXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IucmVtb3ZlV29yZExlZnQoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwicmVtb3Zld29yZHJpZ2h0XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1EZWxldGVcXFwiLCBcXFwiQWx0LURlbGV0ZVxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnJlbW92ZVdvcmRSaWdodCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJvdXRkZW50XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiU2hpZnQtVGFiXFxcIiwgXFxcIlNoaWZ0LVRhYlxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmJsb2NrT3V0ZGVudCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcInNlbGVjdGlvblBhcnRcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiaW5kZW50XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiVGFiXFxcIiwgXFxcIlRhYlxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmluZGVudCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcInNlbGVjdGlvblBhcnRcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiYmxvY2tvdXRkZW50XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1bXFxcIiwgXFxcIkN0cmwtW1xcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmJsb2NrT3V0ZGVudCgpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hMaW5lXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJzZWxlY3Rpb25QYXJ0XFxcIlxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImJsb2NraW5kZW50XFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1dXFxcIiwgXFxcIkN0cmwtXVxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmJsb2NrSW5kZW50KCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBcXFwiZm9yRWFjaExpbmVcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcInNlbGVjdGlvblBhcnRcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiaW5zZXJ0c3RyaW5nXFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBzdHIpIHsgZWRpdG9yLmluc2VydChzdHIpOyB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJpbnNlcnR0ZXh0XFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yLCBhcmdzKSB7XFxuXFx0ICAgICAgICBlZGl0b3IuaW5zZXJ0KGxhbmcuc3RyaW5nUmVwZWF0KGFyZ3MudGV4dCAgfHwgXFxcIlxcXCIsIGFyZ3MudGltZXMgfHwgMSkpO1xcblxcdCAgICB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCJcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJzcGxpdGxpbmVcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KG51bGwsIFxcXCJDdHJsLU9cXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zcGxpdExpbmUoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwidHJhbnNwb3NlbGV0dGVyc1xcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkoXFxcIkN0cmwtVFxcXCIsIFxcXCJDdHJsLVRcXFwiKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci50cmFuc3Bvc2VMZXR0ZXJzKCk7IH0sXFxuXFx0ICAgIG11bHRpU2VsZWN0QWN0aW9uOiBmdW5jdGlvbihlZGl0b3IpIHtlZGl0b3IudHJhbnNwb3NlU2VsZWN0aW9ucygxKTsgfSxcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwidG91cHBlcmNhc2VcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVVcXFwiLCBcXFwiQ3RybC1VXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IudG9VcHBlckNhc2UoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwidG9sb3dlcmNhc2VcXFwiLFxcblxcdCAgICBiaW5kS2V5OiBiaW5kS2V5KFxcXCJDdHJsLVNoaWZ0LVVcXFwiLCBcXFwiQ3RybC1TaGlmdC1VXFxcIiksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IudG9Mb3dlckNhc2UoKTsgfSxcXG5cXHQgICAgbXVsdGlTZWxlY3RBY3Rpb246IFxcXCJmb3JFYWNoXFxcIixcXG5cXHQgICAgc2Nyb2xsSW50b1ZpZXc6IFxcXCJjdXJzb3JcXFwiXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiZXhwYW5kdG9saW5lXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShcXFwiQ3RybC1TaGlmdC1MXFxcIiwgXFxcIkNvbW1hbmQtU2hpZnQtTFxcXCIpLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcXG5cXG5cXHQgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IHJhbmdlLmVuZC5jb2x1bW4gPSAwO1xcblxcdCAgICAgICAgcmFuZ2UuZW5kLnJvdysrO1xcblxcdCAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSwgZmFsc2UpO1xcblxcdCAgICB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICBzY3JvbGxJbnRvVmlldzogXFxcImN1cnNvclxcXCIsXFxuXFx0ICAgIHJlYWRPbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwiam9pbmxpbmVzXFxcIixcXG5cXHQgICAgYmluZEtleTogYmluZEtleShudWxsLCBudWxsKSxcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XFxuXFx0ICAgICAgICB2YXIgaXNCYWNrd2FyZHMgPSBlZGl0b3Iuc2VsZWN0aW9uLmlzQmFja3dhcmRzKCk7XFxuXFx0ICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBpc0JhY2t3YXJkcyA/IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uTGVhZCgpIDogZWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25BbmNob3IoKTtcXG5cXHQgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSBpc0JhY2t3YXJkcyA/IGVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uQW5jaG9yKCkgOiBlZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkxlYWQoKTtcXG5cXHQgICAgICAgIHZhciBmaXJzdExpbmVFbmRDb2wgPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TGluZShzZWxlY3Rpb25TdGFydC5yb3cpLmxlbmd0aFxcblxcdCAgICAgICAgdmFyIHNlbGVjdGVkVGV4dCA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UoZWRpdG9yLnNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcXG5cXHQgICAgICAgIHZhciBzZWxlY3RlZENvdW50ID0gc2VsZWN0ZWRUZXh0LnJlcGxhY2UoL1xcXFxuXFxcXHMqLywgXFxcIiBcXFwiKS5sZW5ndGg7XFxuXFx0ICAgICAgICB2YXIgaW5zZXJ0TGluZSA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKHNlbGVjdGlvblN0YXJ0LnJvdyk7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gc2VsZWN0aW9uU3RhcnQucm93ICsgMTsgaSA8PSBzZWxlY3Rpb25FbmQucm93ICsgMTsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGN1ckxpbmUgPSBsYW5nLnN0cmluZ1RyaW1MZWZ0KGxhbmcuc3RyaW5nVHJpbVJpZ2h0KGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMaW5lKGkpKSk7XFxuXFx0ICAgICAgICAgICAgaWYgKGN1ckxpbmUubGVuZ3RoICE9PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGN1ckxpbmUgPSBcXFwiIFxcXCIgKyBjdXJMaW5lO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpbnNlcnRMaW5lICs9IGN1ckxpbmU7XFxuXFx0ICAgICAgICB9O1xcblxcblxcdCAgICAgICAgaWYgKHNlbGVjdGlvbkVuZC5yb3cgKyAxIDwgKGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMZW5ndGgoKSAtIDEpKSB7XFxuXFx0ICAgICAgICAgICAgaW5zZXJ0TGluZSArPSBlZGl0b3Iuc2Vzc2lvbi5kb2MuZ2V0TmV3TGluZUNoYXJhY3RlcigpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICBlZGl0b3Iuc2Vzc2lvbi5kb2MucmVwbGFjZShuZXcgUmFuZ2Uoc2VsZWN0aW9uU3RhcnQucm93LCAwLCBzZWxlY3Rpb25FbmQucm93ICsgMiwgMCksIGluc2VydExpbmUpO1xcblxcblxcdCAgICAgICAgaWYgKHNlbGVjdGVkQ291bnQgPiAwKSB7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG8oc2VsZWN0aW9uU3RhcnQucm93LCBzZWxlY3Rpb25TdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2VsZWN0VG8oc2VsZWN0aW9uU3RhcnQucm93LCBzZWxlY3Rpb25TdGFydC5jb2x1bW4gKyBzZWxlY3RlZENvdW50KTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgZmlyc3RMaW5lRW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoc2VsZWN0aW9uU3RhcnQucm93KS5sZW5ndGggPiBmaXJzdExpbmVFbmRDb2wgPyAoZmlyc3RMaW5lRW5kQ29sICsgMSkgOiBmaXJzdExpbmVFbmRDb2w7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG8oc2VsZWN0aW9uU3RhcnQucm93LCBmaXJzdExpbmVFbmRDb2wpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBtdWx0aVNlbGVjdEFjdGlvbjogXFxcImZvckVhY2hcXFwiLFxcblxcdCAgICByZWFkT25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImludmVydFNlbGVjdGlvblxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IGJpbmRLZXkobnVsbCwgbnVsbCksXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICAgICAgdmFyIGVuZFJvdyA9IGVkaXRvci5zZXNzaW9uLmRvYy5nZXRMZW5ndGgoKSAtIDE7XFxuXFx0ICAgICAgICB2YXIgZW5kQ29sID0gZWRpdG9yLnNlc3Npb24uZG9jLmdldExpbmUoZW5kUm93KS5sZW5ndGg7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2VzID0gZWRpdG9yLnNlbGVjdGlvbi5yYW5nZUxpc3QucmFuZ2VzO1xcblxcdCAgICAgICAgdmFyIG5ld1JhbmdlcyA9IFtdO1xcblxcdCAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPCAxKSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2VzID0gW2VkaXRvci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKV07XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIGlmIChpID09IChyYW5nZXMubGVuZ3RoIC0gMSkpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKCEocmFuZ2VzW2ldLmVuZC5yb3cgPT09IGVuZFJvdyAmJiByYW5nZXNbaV0uZW5kLmNvbHVtbiA9PT0gZW5kQ29sKSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKHJhbmdlc1tpXS5lbmQucm93LCByYW5nZXNbaV0uZW5kLmNvbHVtbiwgZW5kUm93LCBlbmRDb2wpKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoIShyYW5nZXNbaV0uc3RhcnQucm93ID09PSAwICYmIHJhbmdlc1tpXS5zdGFydC5jb2x1bW4gPT09IDApKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBuZXdSYW5nZXMucHVzaChuZXcgUmFuZ2UoMCwgMCwgcmFuZ2VzW2ldLnN0YXJ0LnJvdywgcmFuZ2VzW2ldLnN0YXJ0LmNvbHVtbikpO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgbmV3UmFuZ2VzLnB1c2gobmV3IFJhbmdlKHJhbmdlc1tpLTFdLmVuZC5yb3csIHJhbmdlc1tpLTFdLmVuZC5jb2x1bW4sIHJhbmdlc1tpXS5zdGFydC5yb3csIHJhbmdlc1tpXS5zdGFydC5jb2x1bW4pKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBlZGl0b3IuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xcblxcdCAgICAgICAgZWRpdG9yLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFxuXFx0ICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbmV3UmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5hZGRSYW5nZShuZXdSYW5nZXNbaV0sIGZhbHNlKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgcmVhZE9ubHk6IHRydWUsXFxuXFx0ICAgIHNjcm9sbEludG9WaWV3OiBcXFwibm9uZVxcXCJcXG5cXHR9XTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvZWRpdG9yXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9maXhvbGRicm93c2Vyc1xcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvbGliL2xhbmdcXFwiLFxcXCJhY2UvbGliL3VzZXJhZ2VudFxcXCIsXFxcImFjZS9rZXlib2FyZC90ZXh0aW5wdXRcXFwiLFxcXCJhY2UvbW91c2UvbW91c2VfaGFuZGxlclxcXCIsXFxcImFjZS9tb3VzZS9mb2xkX2hhbmRsZXJcXFwiLFxcXCJhY2Uva2V5Ym9hcmQva2V5YmluZGluZ1xcXCIsXFxcImFjZS9lZGl0X3Nlc3Npb25cXFwiLFxcXCJhY2Uvc2VhcmNoXFxcIixcXFwiYWNlL3JhbmdlXFxcIixcXFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXFxcIixcXFwiYWNlL2NvbW1hbmRzL2NvbW1hbmRfbWFuYWdlclxcXCIsXFxcImFjZS9jb21tYW5kcy9kZWZhdWx0X2NvbW1hbmRzXFxcIixcXFwiYWNlL2NvbmZpZ1xcXCIsXFxcImFjZS90b2tlbl9pdGVyYXRvclxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGFjZXF1aXJlKFxcXCIuL2xpYi9maXhvbGRicm93c2Vyc1xcXCIpO1xcblxcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIGRvbSA9IGFjZXF1aXJlKFxcXCIuL2xpYi9kb21cXFwiKTtcXG5cXHR2YXIgbGFuZyA9IGFjZXF1aXJlKFxcXCIuL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFxcXCIuL2xpYi91c2VyYWdlbnRcXFwiKTtcXG5cXHR2YXIgVGV4dElucHV0ID0gYWNlcXVpcmUoXFxcIi4va2V5Ym9hcmQvdGV4dGlucHV0XFxcIikuVGV4dElucHV0O1xcblxcdHZhciBNb3VzZUhhbmRsZXIgPSBhY2VxdWlyZShcXFwiLi9tb3VzZS9tb3VzZV9oYW5kbGVyXFxcIikuTW91c2VIYW5kbGVyO1xcblxcdHZhciBGb2xkSGFuZGxlciA9IGFjZXF1aXJlKFxcXCIuL21vdXNlL2ZvbGRfaGFuZGxlclxcXCIpLkZvbGRIYW5kbGVyO1xcblxcdHZhciBLZXlCaW5kaW5nID0gYWNlcXVpcmUoXFxcIi4va2V5Ym9hcmQva2V5YmluZGluZ1xcXCIpLktleUJpbmRpbmc7XFxuXFx0dmFyIEVkaXRTZXNzaW9uID0gYWNlcXVpcmUoXFxcIi4vZWRpdF9zZXNzaW9uXFxcIikuRWRpdFNlc3Npb247XFxuXFx0dmFyIFNlYXJjaCA9IGFjZXF1aXJlKFxcXCIuL3NlYXJjaFxcXCIpLlNlYXJjaDtcXG5cXHR2YXIgUmFuZ2UgPSBhY2VxdWlyZShcXFwiLi9yYW5nZVxcXCIpLlJhbmdlO1xcblxcdHZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXHR2YXIgQ29tbWFuZE1hbmFnZXIgPSBhY2VxdWlyZShcXFwiLi9jb21tYW5kcy9jb21tYW5kX21hbmFnZXJcXFwiKS5Db21tYW5kTWFuYWdlcjtcXG5cXHR2YXIgZGVmYXVsdENvbW1hbmRzID0gYWNlcXVpcmUoXFxcIi4vY29tbWFuZHMvZGVmYXVsdF9jb21tYW5kc1xcXCIpLmNvbW1hbmRzO1xcblxcdHZhciBjb25maWcgPSBhY2VxdWlyZShcXFwiLi9jb25maWdcXFwiKTtcXG5cXHR2YXIgVG9rZW5JdGVyYXRvciA9IGFjZXF1aXJlKFxcXCIuL3Rva2VuX2l0ZXJhdG9yXFxcIikuVG9rZW5JdGVyYXRvcjtcXG5cXHR2YXIgRWRpdG9yID0gZnVuY3Rpb24ocmVuZGVyZXIsIHNlc3Npb24pIHtcXG5cXHQgICAgdmFyIGNvbnRhaW5lciA9IHJlbmRlcmVyLmdldENvbnRhaW5lckVsZW1lbnQoKTtcXG5cXHQgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XFxuXFx0ICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcXG5cXG5cXHQgICAgdGhpcy5jb21tYW5kcyA9IG5ldyBDb21tYW5kTWFuYWdlcih1c2VyYWdlbnQuaXNNYWMgPyBcXFwibWFjXFxcIiA6IFxcXCJ3aW5cXFwiLCBkZWZhdWx0Q29tbWFuZHMpO1xcblxcdCAgICB0aGlzLnRleHRJbnB1dCAgPSBuZXcgVGV4dElucHV0KHJlbmRlcmVyLmdldFRleHRBcmVhQ29udGFpbmVyKCksIHRoaXMpO1xcblxcdCAgICB0aGlzLnJlbmRlcmVyLnRleHRhcmVhID0gdGhpcy50ZXh0SW5wdXQuZ2V0RWxlbWVudCgpO1xcblxcdCAgICB0aGlzLmtleUJpbmRpbmcgPSBuZXcgS2V5QmluZGluZyh0aGlzKTtcXG5cXHQgICAgdGhpcy4kbW91c2VIYW5kbGVyID0gbmV3IE1vdXNlSGFuZGxlcih0aGlzKTtcXG5cXHQgICAgbmV3IEZvbGRIYW5kbGVyKHRoaXMpO1xcblxcblxcdCAgICB0aGlzLiRibG9ja1Njcm9sbGluZyA9IDA7XFxuXFx0ICAgIHRoaXMuJHNlYXJjaCA9IG5ldyBTZWFyY2goKS5zZXQoe1xcblxcdCAgICAgICAgd3JhcDogdHJ1ZVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy4kaGlzdG9yeVRyYWNrZXIgPSB0aGlzLiRoaXN0b3J5VHJhY2tlci5iaW5kKHRoaXMpO1xcblxcdCAgICB0aGlzLmNvbW1hbmRzLm9uKFxcXCJleGVjXFxcIiwgdGhpcy4kaGlzdG9yeVRyYWNrZXIpO1xcblxcblxcdCAgICB0aGlzLiRpbml0T3BlcmF0aW9uTGlzdGVuZXJzKCk7XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLl8kZW1pdElucHV0RXZlbnQgPSBsYW5nLmRlbGF5ZWRDYWxsKGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJpbnB1dFxcXCIsIHt9KTtcXG5cXHQgICAgICAgIGlmICh0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLmJnVG9rZW5pemVyKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5iZ1Rva2VuaXplci5zY2hlZHVsZVN0YXJ0KCk7XFxuXFx0ICAgIH0uYmluZCh0aGlzKSk7XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLm9uKFxcXCJjaGFuZ2VcXFwiLCBmdW5jdGlvbihfLCBfc2VsZikge1xcblxcdCAgICAgICAgX3NlbGYuXyRlbWl0SW5wdXRFdmVudC5zY2hlZHVsZSgzMSk7XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICB0aGlzLnNldFNlc3Npb24oc2Vzc2lvbiB8fCBuZXcgRWRpdFNlc3Npb24oXFxcIlxcXCIpKTtcXG5cXHQgICAgY29uZmlnLnJlc2V0T3B0aW9ucyh0aGlzKTtcXG5cXHQgICAgY29uZmlnLl9zaWduYWwoXFxcImVkaXRvclxcXCIsIHRoaXMpO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCl7XFxuXFxuXFx0ICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcXG5cXG5cXHQgICAgdGhpcy4kaW5pdE9wZXJhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgZnVuY3Rpb24gbGFzdChhKSB7cmV0dXJuIGFbYS5sZW5ndGggLSAxXX1cXG5cXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xcblxcdCAgICAgICAgdGhpcy5jb21tYW5kcy5vbihcXFwiZXhlY1xcXCIsIHRoaXMuc3RhcnRPcGVyYXRpb24uYmluZCh0aGlzKSwgdHJ1ZSk7XFxuXFx0ICAgICAgICB0aGlzLmNvbW1hbmRzLm9uKFxcXCJhZnRlckV4ZWNcXFwiLCB0aGlzLmVuZE9wZXJhdGlvbi5iaW5kKHRoaXMpLCB0cnVlKTtcXG5cXG5cXHQgICAgICAgIHRoaXMuJG9wUmVzZXRUaW1lciA9IGxhbmcuZGVsYXllZENhbGwodGhpcy5lbmRPcGVyYXRpb24uYmluZCh0aGlzKSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLm9uKFxcXCJjaGFuZ2VcXFwiLCBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmN1ck9wIHx8IHRoaXMuc3RhcnRPcGVyYXRpb24oKTtcXG5cXHQgICAgICAgICAgICB0aGlzLmN1ck9wLmRvY0NoYW5nZWQgPSB0cnVlO1xcblxcdCAgICAgICAgfS5iaW5kKHRoaXMpLCB0cnVlKTtcXG5cXG5cXHQgICAgICAgIHRoaXMub24oXFxcImNoYW5nZVNlbGVjdGlvblxcXCIsIGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuY3VyT3AgfHwgdGhpcy5zdGFydE9wZXJhdGlvbigpO1xcblxcdCAgICAgICAgICAgIHRoaXMuY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XFxuXFx0ICAgICAgICB9LmJpbmQodGhpcyksIHRydWUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmN1ck9wID0gbnVsbDtcXG5cXHQgICAgdGhpcy5wcmV2T3AgPSB7fTtcXG5cXHQgICAgdGhpcy5zdGFydE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGNvbW1hZEV2ZW50KSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5jdXJPcCkge1xcblxcdCAgICAgICAgICAgIGlmICghY29tbWFkRXZlbnQgfHwgdGhpcy5jdXJPcC5jb21tYW5kKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgdGhpcy5wcmV2T3AgPSB0aGlzLmN1ck9wO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKCFjb21tYWRFdmVudCkge1xcblxcdCAgICAgICAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcXG5cXHQgICAgICAgICAgICBjb21tYWRFdmVudCA9IHt9O1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy4kb3BSZXNldFRpbWVyLnNjaGVkdWxlKCk7XFxuXFx0ICAgICAgICB0aGlzLmN1ck9wID0ge1xcblxcdCAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hZEV2ZW50LmNvbW1hbmQgfHwge30sXFxuXFx0ICAgICAgICAgICAgYXJnczogY29tbWFkRXZlbnQuYXJncyxcXG5cXHQgICAgICAgICAgICBzY3JvbGxUb3A6IHRoaXMucmVuZGVyZXIuc2Nyb2xsVG9wXFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmVuZE9wZXJhdGlvbiA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLmN1ck9wKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGUgJiYgZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1ck9wID0gbnVsbDtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuY3VyT3AuY29tbWFuZDtcXG5cXHQgICAgICAgICAgICBpZiAoY29tbWFuZCAmJiBjb21tYW5kLnNjcm9sbEludG9WaWV3KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZC5zY3JvbGxJbnRvVmlldykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiY2VudGVyXFxcIjpcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KG51bGwsIDAuNSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJhbmltYXRlXFxcIjpcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcImN1cnNvclxcXCI6XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldygpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwic2VsZWN0aW9uUGFydFxcXCI6XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5yZW5kZXJlci5sYXllckNvbmZpZztcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQucm93ID49IGNvbmZpZy5sYXN0Um93IHx8IHJhbmdlLmVuZC5yb3cgPD0gY29uZmlnLmZpcnN0Um93KSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcodGhpcy5zZWxlY3Rpb24uYW5jaG9yLCB0aGlzLnNlbGVjdGlvbi5sZWFkKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLnNjcm9sbEludG9WaWV3ID09IFxcXCJhbmltYXRlXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYW5pbWF0ZVNjcm9sbGluZyh0aGlzLmN1ck9wLnNjcm9sbFRvcCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMucHJldk9wID0gdGhpcy5jdXJPcDtcXG5cXHQgICAgICAgICAgICB0aGlzLmN1ck9wID0gbnVsbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy4kbWVyZ2VhYmxlQ29tbWFuZHMgPSBbXFxcImJhY2tzcGFjZVxcXCIsIFxcXCJkZWxcXFwiLCBcXFwiaW5zZXJ0c3RyaW5nXFxcIl07XFxuXFx0ICAgIHRoaXMuJGhpc3RvcnlUcmFja2VyID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiRtZXJnZVVuZG9EZWx0YXMpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdmFyIHByZXYgPSB0aGlzLnByZXZPcDtcXG5cXHQgICAgICAgIHZhciBtZXJnZWFibGVDb21tYW5kcyA9IHRoaXMuJG1lcmdlYWJsZUNvbW1hbmRzO1xcblxcdCAgICAgICAgdmFyIHNob3VsZE1lcmdlID0gcHJldi5jb21tYW5kICYmIChlLmNvbW1hbmQubmFtZSA9PSBwcmV2LmNvbW1hbmQubmFtZSk7XFxuXFx0ICAgICAgICBpZiAoZS5jb21tYW5kLm5hbWUgPT0gXFxcImluc2VydHN0cmluZ1xcXCIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgdGV4dCA9IGUuYXJncztcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5tZXJnZU5leHRDb21tYW5kID09PSB1bmRlZmluZWQpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VOZXh0Q29tbWFuZCA9IHRydWU7XFxuXFxuXFx0ICAgICAgICAgICAgc2hvdWxkTWVyZ2UgPSBzaG91bGRNZXJnZVxcblxcdCAgICAgICAgICAgICAgICAmJiB0aGlzLm1lcmdlTmV4dENvbW1hbmQgLy8gcHJldmlvdXMgY29tbWFuZCBhbGxvd3MgdG8gY29hbGVzY2Ugd2l0aFxcblxcdCAgICAgICAgICAgICAgICAmJiAoIS9cXFxccy8udGVzdCh0ZXh0KSB8fCAvXFxcXHMvLnRlc3QocHJldi5hcmdzKSk7IC8vIHByZXZpb3VzIGluc2VydGlvbiB3YXMgb2Ygc2FtZSB0eXBlXFxuXFxuXFx0ICAgICAgICAgICAgdGhpcy5tZXJnZU5leHRDb21tYW5kID0gdHJ1ZTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgc2hvdWxkTWVyZ2UgPSBzaG91bGRNZXJnZVxcblxcdCAgICAgICAgICAgICAgICAmJiBtZXJnZWFibGVDb21tYW5kcy5pbmRleE9mKGUuY29tbWFuZC5uYW1lKSAhPT0gLTE7IC8vIHRoZSBjb21tYW5kIGlzIG1lcmdlYWJsZVxcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKFxcblxcdCAgICAgICAgICAgIHRoaXMuJG1lcmdlVW5kb0RlbHRhcyAhPSBcXFwiYWx3YXlzXFxcIlxcblxcdCAgICAgICAgICAgICYmIERhdGUubm93KCkgLSB0aGlzLnNlcXVlbmNlU3RhcnRUaW1lID4gMjAwMFxcblxcdCAgICAgICAgKSB7XFxuXFx0ICAgICAgICAgICAgc2hvdWxkTWVyZ2UgPSBmYWxzZTsgLy8gdGhlIHNlcXVlbmNlIGlzIHRvbyBsb25nXFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoc2hvdWxkTWVyZ2UpXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm1lcmdlVW5kb0RlbHRhcyA9IHRydWU7XFxuXFx0ICAgICAgICBlbHNlIGlmIChtZXJnZWFibGVDb21tYW5kcy5pbmRleE9mKGUuY29tbWFuZC5uYW1lKSAhPT0gLTEpXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXF1ZW5jZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0S2V5Ym9hcmRIYW5kbGVyID0gZnVuY3Rpb24oa2V5Ym9hcmRIYW5kbGVyLCBjYikge1xcblxcdCAgICAgICAgaWYgKGtleWJvYXJkSGFuZGxlciAmJiB0eXBlb2Yga2V5Ym9hcmRIYW5kbGVyID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGtleWJpbmRpbmdJZCA9IGtleWJvYXJkSGFuZGxlcjtcXG5cXHQgICAgICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcdCAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFtcXFwia2V5YmluZGluZ1xcXCIsIGtleWJvYXJkSGFuZGxlcl0sIGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoX3NlbGYuJGtleWJpbmRpbmdJZCA9PSBrZXlib2FyZEhhbmRsZXIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBfc2VsZi5rZXlCaW5kaW5nLnNldEtleWJvYXJkSGFuZGxlcihtb2R1bGUgJiYgbW9kdWxlLmhhbmRsZXIpO1xcblxcdCAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xcblxcdCAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRrZXliaW5kaW5nSWQgPSBudWxsO1xcblxcdCAgICAgICAgICAgIHRoaXMua2V5QmluZGluZy5zZXRLZXlib2FyZEhhbmRsZXIoa2V5Ym9hcmRIYW5kbGVyKTtcXG5cXHQgICAgICAgICAgICBjYiAmJiBjYigpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEtleWJvYXJkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMua2V5QmluZGluZy5nZXRLZXlib2FyZEhhbmRsZXIoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PSBzZXNzaW9uKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHZhciBvbGRTZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgaWYgKG9sZFNlc3Npb24pIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlXFxcIiwgdGhpcy4kb25Eb2N1bWVudENoYW5nZSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZU1vZGVcXFwiLCB0aGlzLiRvbkNoYW5nZU1vZGUpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJ0b2tlbml6ZXJVcGRhdGVcXFwiLCB0aGlzLiRvblRva2VuaXplclVwZGF0ZSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVRhYlNpemVcXFwiLCB0aGlzLiRvbkNoYW5nZVRhYlNpemUpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VXcmFwTGltaXRcXFwiLCB0aGlzLiRvbkNoYW5nZVdyYXBMaW1pdCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVdyYXBNb2RlXFxcIiwgdGhpcy4kb25DaGFuZ2VXcmFwTW9kZSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIm9uQ2hhbmdlRm9sZFxcXCIsIHRoaXMuJG9uQ2hhbmdlRm9sZCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZUZyb250TWFya2VyXFxcIiwgdGhpcy4kb25DaGFuZ2VGcm9udE1hcmtlcik7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZUJhY2tNYXJrZXJcXFwiLCB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VCcmVha3BvaW50XFxcIiwgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50KTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlQW5ub3RhdGlvblxcXCIsIHRoaXMuJG9uQ2hhbmdlQW5ub3RhdGlvbik7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZU92ZXJ3cml0ZVxcXCIsIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlU2Nyb2xsVG9wXFxcIiwgdGhpcy4kb25TY3JvbGxUb3BDaGFuZ2UpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VTY3JvbGxMZWZ0XFxcIiwgdGhpcy4kb25TY3JvbGxMZWZ0Q2hhbmdlKTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZXNzaW9uLmdldFNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VDdXJzb3JcXFwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVNlbGVjdGlvblxcXCIsIHRoaXMuJG9uU2VsZWN0aW9uQ2hhbmdlKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XFxuXFx0ICAgICAgICBpZiAoc2Vzc2lvbikge1xcblxcdCAgICAgICAgICAgIHRoaXMuJG9uRG9jdW1lbnRDaGFuZ2UgPSB0aGlzLm9uRG9jdW1lbnRDaGFuZ2UuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVxcXCIsIHRoaXMuJG9uRG9jdW1lbnRDaGFuZ2UpO1xcblxcdCAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcXG5cXHQgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VNb2RlID0gdGhpcy5vbkNoYW5nZU1vZGUuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZU1vZGVcXFwiLCB0aGlzLiRvbkNoYW5nZU1vZGUpO1xcblxcdCAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLiRvblRva2VuaXplclVwZGF0ZSA9IHRoaXMub25Ub2tlbml6ZXJVcGRhdGUuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcInRva2VuaXplclVwZGF0ZVxcXCIsIHRoaXMuJG9uVG9rZW5pemVyVXBkYXRlKTtcXG5cXHQgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VUYWJTaXplID0gdGhpcy5yZW5kZXJlci5vbkNoYW5nZVRhYlNpemUuYmluZCh0aGlzLnJlbmRlcmVyKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVRhYlNpemVcXFwiLCB0aGlzLiRvbkNoYW5nZVRhYlNpemUpO1xcblxcdCAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLiRvbkNoYW5nZVdyYXBMaW1pdCA9IHRoaXMub25DaGFuZ2VXcmFwTGltaXQuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVdyYXBMaW1pdFxcXCIsIHRoaXMuJG9uQ2hhbmdlV3JhcExpbWl0KTtcXG5cXHQgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VXcmFwTW9kZSA9IHRoaXMub25DaGFuZ2VXcmFwTW9kZS5iaW5kKHRoaXMpO1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlV3JhcE1vZGVcXFwiLCB0aGlzLiRvbkNoYW5nZVdyYXBNb2RlKTtcXG5cXHQgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VGb2xkID0gdGhpcy5vbkNoYW5nZUZvbGQuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZUZvbGRcXFwiLCB0aGlzLiRvbkNoYW5nZUZvbGQpO1xcblxcdCAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLiRvbkNoYW5nZUZyb250TWFya2VyID0gdGhpcy5vbkNoYW5nZUZyb250TWFya2VyLmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZUZyb250TWFya2VyXFxcIiwgdGhpcy4kb25DaGFuZ2VGcm9udE1hcmtlcik7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJG9uQ2hhbmdlQmFja01hcmtlciA9IHRoaXMub25DaGFuZ2VCYWNrTWFya2VyLmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZUJhY2tNYXJrZXJcXFwiLCB0aGlzLiRvbkNoYW5nZUJhY2tNYXJrZXIpO1xcblxcdCAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLiRvbkNoYW5nZUJyZWFrcG9pbnQgPSB0aGlzLm9uQ2hhbmdlQnJlYWtwb2ludC5iaW5kKHRoaXMpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VCcmVha3BvaW50XFxcIiwgdGhpcy4kb25DaGFuZ2VCcmVha3BvaW50KTtcXG5cXHQgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25DaGFuZ2VBbm5vdGF0aW9uID0gdGhpcy5vbkNoYW5nZUFubm90YXRpb24uYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlQW5ub3RhdGlvblxcXCIsIHRoaXMuJG9uQ2hhbmdlQW5ub3RhdGlvbik7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlID0gdGhpcy5vbkN1cnNvckNoYW5nZS5iaW5kKHRoaXMpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VPdmVyd3JpdGVcXFwiLCB0aGlzLiRvbkN1cnNvckNoYW5nZSk7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJG9uU2Nyb2xsVG9wQ2hhbmdlID0gdGhpcy5vblNjcm9sbFRvcENoYW5nZS5iaW5kKHRoaXMpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VTY3JvbGxUb3BcXFwiLCB0aGlzLiRvblNjcm9sbFRvcENoYW5nZSk7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJG9uU2Nyb2xsTGVmdENoYW5nZSA9IHRoaXMub25TY3JvbGxMZWZ0Q2hhbmdlLmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVNjcm9sbExlZnRcXFwiLCB0aGlzLiRvblNjcm9sbExlZnRDaGFuZ2UpO1xcblxcdCAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlc3Npb24uZ2V0U2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlQ3Vyc29yXFxcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xcblxcdCAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiLCB0aGlzLiRvblNlbGVjdGlvbkNoYW5nZSk7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMub25DaGFuZ2VNb2RlKCk7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nICs9IDE7XFxuXFx0ICAgICAgICAgICAgdGhpcy5vbkN1cnNvckNoYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XFxuXFx0ICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMub25TY3JvbGxUb3BDaGFuZ2UoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsTGVmdENoYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlRnJvbnRNYXJrZXIoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlQmFja01hcmtlcigpO1xcblxcdCAgICAgICAgICAgIHRoaXMub25DaGFuZ2VCcmVha3BvaW50KCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5vbkNoYW5nZUFubm90YXRpb24oKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSAmJiB0aGlzLnJlbmRlcmVyLmFkanVzdFdyYXBMaW1pdCgpO1xcblxcdCAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTZXNzaW9uKHNlc3Npb24pO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VTZXNzaW9uXFxcIiwge1xcblxcdCAgICAgICAgICAgIHNlc3Npb246IHNlc3Npb24sXFxuXFx0ICAgICAgICAgICAgb2xkU2Vzc2lvbjogb2xkU2Vzc2lvblxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIG9sZFNlc3Npb24gJiYgb2xkU2Vzc2lvbi5fc2lnbmFsKFxcXCJjaGFuZ2VFZGl0b3JcXFwiLCB7b2xkRWRpdG9yOiB0aGlzfSk7XFxuXFx0ICAgICAgICBzZXNzaW9uICYmIHNlc3Npb24uX3NpZ25hbChcXFwiY2hhbmdlRWRpdG9yXFxcIiwge2VkaXRvcjogdGhpc30pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNlc3Npb24gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb247XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWwsIGN1cnNvclBvcykge1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLmRvYy5zZXRWYWx1ZSh2YWwpO1xcblxcblxcdCAgICAgICAgaWYgKCFjdXJzb3JQb3MpXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcXG5cXHQgICAgICAgIGVsc2UgaWYgKGN1cnNvclBvcyA9PSAxKVxcblxcdCAgICAgICAgICAgIHRoaXMubmF2aWdhdGVGaWxlRW5kKCk7XFxuXFx0ICAgICAgICBlbHNlIGlmIChjdXJzb3JQb3MgPT0gLTEpXFxuXFx0ICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUZpbGVTdGFydCgpO1xcblxcblxcdCAgICAgICAgcmV0dXJuIHZhbDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRWYWx1ZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLm9uUmVzaXplKGZvcmNlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRUaGVtZSA9IGZ1bmN0aW9uKHRoZW1lLCBjYikge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRUaGVtZSh0aGVtZSwgY2IpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFRoZW1lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRUaGVtZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoc3R5bGUpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnVuc2V0U3R5bGUgPSBmdW5jdGlvbihzdHlsZSkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51bnNldFN0eWxlKHN0eWxlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRGb250U2l6ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcXFwiZm9udFNpemVcXFwiKSB8fFxcblxcdCAgICAgICAgICAgZG9tLmNvbXB1dGVkU3R5bGUodGhpcy5jb250YWluZXIsIFxcXCJmb250U2l6ZVxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldEZvbnRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcImZvbnRTaXplXFxcIiwgc2l6ZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGhpZ2hsaWdodEJyYWNrZXRzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZXNzaW9uLiRicmFja2V0SGlnaGxpZ2h0KSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcih0aGlzLnNlc3Npb24uJGJyYWNrZXRIaWdobGlnaHQpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kYnJhY2tldEhpZ2hsaWdodCA9IG51bGw7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0UGVuZGluZykge1xcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcXG5cXHQgICAgICAgIHRoaXMuJGhpZ2hsaWdodFBlbmRpbmcgPSB0cnVlO1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBzZWxmLiRoaWdobGlnaHRQZW5kaW5nID0gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlc3Npb24gPSBzZWxmLnNlc3Npb247XFxuXFx0ICAgICAgICAgICAgaWYgKCFzZXNzaW9uIHx8ICFzZXNzaW9uLmJnVG9rZW5pemVyKSByZXR1cm47XFxuXFx0ICAgICAgICAgICAgdmFyIHBvcyA9IHNlc3Npb24uZmluZE1hdGNoaW5nQnJhY2tldChzZWxmLmdldEN1cnNvclBvc2l0aW9uKCkpO1xcblxcdCAgICAgICAgICAgIGlmIChwb3MpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKHBvcy5yb3csIHBvcy5jb2x1bW4sIHBvcy5yb3csIHBvcy5jb2x1bW4gKyAxKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHNlc3Npb24uJG1vZGUuZ2V0TWF0Y2hpbmcpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2Vzc2lvbi4kbW9kZS5nZXRNYXRjaGluZyhzZWxmLnNlc3Npb24pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpZiAocmFuZ2UpXFxuXFx0ICAgICAgICAgICAgICAgIHNlc3Npb24uJGJyYWNrZXRIaWdobGlnaHQgPSBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXFxcImFjZV9icmFja2V0XFxcIiwgXFxcInRleHRcXFwiKTtcXG5cXHQgICAgICAgIH0sIDUwKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy4kaGlnaGxpZ2h0VGFncyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJGhpZ2hsaWdodFRhZ1BlbmRpbmcpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcdCAgICAgICAgdGhpcy4kaGlnaGxpZ2h0VGFnUGVuZGluZyA9IHRydWU7XFxuXFx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIHNlbGYuJGhpZ2hsaWdodFRhZ1BlbmRpbmcgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHNlbGYuc2Vzc2lvbjtcXG5cXHQgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24uYmdUb2tlbml6ZXIpIHJldHVybjtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB2YXIgcG9zID0gc2VsZi5nZXRDdXJzb3JQb3NpdGlvbigpO1xcblxcdCAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlbGYuc2Vzc2lvbiwgcG9zLnJvdywgcG9zLmNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgdmFyIHRva2VuID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuKCk7XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbi50eXBlLmluZGV4T2YoJ3RhZy1uYW1lJykgPT09IC0xKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKHNlc3Npb24uJHRhZ0hpZ2hsaWdodCk7XFxuXFx0ICAgICAgICAgICAgICAgIHNlc3Npb24uJHRhZ0hpZ2hsaWdodCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIHRhZyA9IHRva2VuLnZhbHVlO1xcblxcdCAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XFxuXFx0ICAgICAgICAgICAgdmFyIHByZXZUb2tlbiA9IGl0ZXJhdG9yLnN0ZXBCYWNrd2FyZCgpO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT0gJzwnKXtcXG5cXHQgICAgICAgICAgICAgICAgZG8ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcHJldlRva2VuID0gdG9rZW47XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi52YWx1ZSA9PT0gdGFnICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpe1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPC8nKXtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgZGVwdGggPj0gMCk7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgZG8ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwcmV2VG9rZW47XFxuXFx0ICAgICAgICAgICAgICAgICAgICBwcmV2VG9rZW4gPSBpdGVyYXRvci5zdGVwQmFja3dhcmQoKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnZhbHVlID09PSB0YWcgJiYgdG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpICE9PSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8Jykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPC8nKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2VG9rZW4gJiYgZGVwdGggPD0gMCk7XFxuXFx0ICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGlmICghdG9rZW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0KTtcXG5cXHQgICAgICAgICAgICAgICAgc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0ID0gbnVsbDtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB2YXIgcm93ID0gaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuUm93KCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbkNvbHVtbigpO1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZShyb3csIGNvbHVtbiwgcm93LCBjb2x1bW4rdG9rZW4udmFsdWUubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICBpZiAoc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0ICYmIHJhbmdlLmNvbXBhcmVSYW5nZShzZXNzaW9uLiRiYWNrTWFya2Vyc1tzZXNzaW9uLiR0YWdIaWdobGlnaHRdLnJhbmdlKSE9PTApIHtcXG5cXHQgICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIoc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0KTtcXG5cXHQgICAgICAgICAgICAgICAgc2Vzc2lvbi4kdGFnSGlnaGxpZ2h0ID0gbnVsbDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgaWYgKHJhbmdlICYmICFzZXNzaW9uLiR0YWdIaWdobGlnaHQpXFxuXFx0ICAgICAgICAgICAgICAgIHNlc3Npb24uJHRhZ0hpZ2hsaWdodCA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcXFwiYWNlX2JyYWNrZXRcXFwiLCBcXFwidGV4dFxcXCIpO1xcblxcdCAgICAgICAgfSwgNTApO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmZvY3VzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBfc2VsZi50ZXh0SW5wdXQuZm9jdXMoKTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgdGhpcy50ZXh0SW5wdXQuZm9jdXMoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pc0ZvY3VzZWQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnRleHRJbnB1dC5pc0ZvY3VzZWQoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5ibHVyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnRleHRJbnB1dC5ibHVyKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMub25Gb2N1cyA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRpc0ZvY3VzZWQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdGhpcy4kaXNGb2N1c2VkID0gdHJ1ZTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2hvd0N1cnNvcigpO1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci52aXN1YWxpemVGb2N1cygpO1xcblxcdCAgICAgICAgdGhpcy5fZW1pdChcXFwiZm9jdXNcXFwiLCBlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5vbkJsdXIgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJGlzRm9jdXNlZClcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB0aGlzLiRpc0ZvY3VzZWQgPSBmYWxzZTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuaGlkZUN1cnNvcigpO1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci52aXN1YWxpemVCbHVyKCk7XFxuXFx0ICAgICAgICB0aGlzLl9lbWl0KFxcXCJibHVyXFxcIiwgZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGN1cnNvckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5vbkRvY3VtZW50Q2hhbmdlID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGRlbHRhID0gZS5kYXRhO1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gZGVsdGEucmFuZ2U7XFxuXFx0ICAgICAgICB2YXIgbGFzdFJvdztcXG5cXG5cXHQgICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdyAmJiBkZWx0YS5hY3Rpb24gIT0gXFxcImluc2VydExpbmVzXFxcIiAmJiBkZWx0YS5hY3Rpb24gIT0gXFxcInJlbW92ZUxpbmVzXFxcIilcXG5cXHQgICAgICAgICAgICBsYXN0Um93ID0gcmFuZ2UuZW5kLnJvdztcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICBsYXN0Um93ID0gSW5maW5pdHk7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUxpbmVzKHJhbmdlLnN0YXJ0LnJvdywgbGFzdFJvdywgdGhpcy5zZXNzaW9uLiR1c2VXcmFwTW9kZSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVxcXCIsIGUpO1xcblxcdCAgICAgICAgdGhpcy4kY3Vyc29yQ2hhbmdlKCk7XFxuXFx0ICAgICAgICB0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Ub2tlbml6ZXJVcGRhdGUgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICB2YXIgcm93cyA9IGUuZGF0YTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlTGluZXMocm93cy5maXJzdCwgcm93cy5sYXN0KTtcXG5cXHQgICAgfTtcXG5cXG5cXG5cXHQgICAgdGhpcy5vblNjcm9sbFRvcENoYW5nZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1kodGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vblNjcm9sbExlZnRDaGFuZ2UgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsVG9YKHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxMZWZ0KCkpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm9uQ3Vyc29yQ2hhbmdlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRjdXJzb3JDaGFuZ2UoKTtcXG5cXG5cXHQgICAgICAgIGlmICghdGhpcy4kYmxvY2tTY3JvbGxpbmcpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLiRoaWdobGlnaHRCcmFja2V0cygpO1xcblxcdCAgICAgICAgdGhpcy4kaGlnaGxpZ2h0VGFncygpO1xcblxcdCAgICAgICAgdGhpcy4kdXBkYXRlSGlnaGxpZ2h0QWN0aXZlTGluZSgpO1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kdXBkYXRlSGlnaGxpZ2h0QWN0aXZlTGluZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLmdldFNlc3Npb24oKTtcXG5cXG5cXHQgICAgICAgIHZhciBoaWdobGlnaHQ7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kaGlnaGxpZ2h0QWN0aXZlTGluZSkge1xcblxcdCAgICAgICAgICAgIGlmICgodGhpcy4kc2VsZWN0aW9uU3R5bGUgIT0gXFxcImxpbmVcXFwiIHx8ICF0aGlzLnNlbGVjdGlvbi5pc011bHRpTGluZSgpKSlcXG5cXHQgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLiRtYXhMaW5lcyAmJiB0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkgPT09IDEgJiYgISh0aGlzLnJlbmRlcmVyLiRtaW5MaW5lcyA+IDEpKVxcblxcdCAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyICYmICFoaWdobGlnaHQpIHtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyLmlkKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyID0gbnVsbDtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoIXNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIgJiYgaGlnaGxpZ2h0KSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGhpZ2hsaWdodC5yb3csIGhpZ2hsaWdodC5jb2x1bW4sIGhpZ2hsaWdodC5yb3csIEluZmluaXR5KTtcXG5cXHQgICAgICAgICAgICByYW5nZS5pZCA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcXFwiYWNlX2FjdGl2ZS1saW5lXFxcIiwgXFxcInNjcmVlbkxpbmVcXFwiKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyID0gcmFuZ2U7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGhpZ2hsaWdodCkge1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuc3RhcnQucm93ID0gaGlnaGxpZ2h0LnJvdztcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLiRoaWdobGlnaHRMaW5lTWFya2VyLmVuZC5yb3cgPSBoaWdobGlnaHQucm93O1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uJGhpZ2hsaWdodExpbmVNYXJrZXIuc3RhcnQuY29sdW1uID0gaGlnaGxpZ2h0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLl9zaWduYWwoXFxcImNoYW5nZUJhY2tNYXJrZXJcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcblxcdCAgICAgICAgaWYgKHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcikge1xcblxcdCAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKHNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXIgPSBudWxsO1xcblxcblxcdCAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGUoKTtcXG5cXHQgICAgICAgICAgICBzZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXIgPSBzZXNzaW9uLmFkZE1hcmtlcihyYW5nZSwgXFxcImFjZV9zZWxlY3Rpb25cXFwiLCBzdHlsZSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUhpZ2hsaWdodEFjdGl2ZUxpbmUoKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciByZSA9IHRoaXMuJGhpZ2hsaWdodFNlbGVjdGVkV29yZCAmJiB0aGlzLiRnZXRTZWxlY3Rpb25IaWdoTGlnaHRSZWdleHAoKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5oaWdobGlnaHQocmUpO1xcblxcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kZ2V0U2VsZWN0aW9uSGlnaExpZ2h0UmVnZXhwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcXG5cXG5cXHQgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XFxuXFx0ICAgICAgICBpZiAoc2VsZWN0aW9uLmlzRW1wdHkoKSB8fCBzZWxlY3Rpb24uaXNNdWx0aUxpbmUoKSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB2YXIgc3RhcnRPdXRlciA9IHNlbGVjdGlvbi5zdGFydC5jb2x1bW4gLSAxO1xcblxcdCAgICAgICAgdmFyIGVuZE91dGVyID0gc2VsZWN0aW9uLmVuZC5jb2x1bW4gKyAxO1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoc2VsZWN0aW9uLnN0YXJ0LnJvdyk7XFxuXFx0ICAgICAgICB2YXIgbGluZUNvbHMgPSBsaW5lLmxlbmd0aDtcXG5cXHQgICAgICAgIHZhciBuZWVkbGUgPSBsaW5lLnN1YnN0cmluZyhNYXRoLm1heChzdGFydE91dGVyLCAwKSxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihlbmRPdXRlciwgbGluZUNvbHMpKTtcXG5cXHQgICAgICAgIGlmICgoc3RhcnRPdXRlciA+PSAwICYmIC9eW1xcXFx3XFxcXGRdLy50ZXN0KG5lZWRsZSkpIHx8XFxuXFx0ICAgICAgICAgICAgKGVuZE91dGVyIDw9IGxpbmVDb2xzICYmIC9bXFxcXHdcXFxcZF0kLy50ZXN0KG5lZWRsZSkpKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIG5lZWRsZSA9IGxpbmUuc3Vic3RyaW5nKHNlbGVjdGlvbi5zdGFydC5jb2x1bW4sIHNlbGVjdGlvbi5lbmQuY29sdW1uKTtcXG5cXHQgICAgICAgIGlmICghL15bXFxcXHdcXFxcZF0rJC8udGVzdChuZWVkbGUpKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHZhciByZSA9IHRoaXMuJHNlYXJjaC4kYXNzZW1ibGVSZWdFeHAoe1xcblxcdCAgICAgICAgICAgIHdob2xlV29yZDogdHJ1ZSxcXG5cXHQgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0cnVlLFxcblxcdCAgICAgICAgICAgIG5lZWRsZTogbmVlZGxlXFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIHJldHVybiByZTtcXG5cXHQgICAgfTtcXG5cXG5cXG5cXHQgICAgdGhpcy5vbkNoYW5nZUZyb250TWFya2VyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUZyb250TWFya2VycygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uQ2hhbmdlQmFja01hcmtlciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xcblxcdCAgICB9O1xcblxcblxcblxcdCAgICB0aGlzLm9uQ2hhbmdlQnJlYWtwb2ludCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCcmVha3BvaW50cygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uQ2hhbmdlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbm5vdGF0aW9ucyh0aGlzLnNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKSk7XFxuXFx0ICAgIH07XFxuXFxuXFxuXFx0ICAgIHRoaXMub25DaGFuZ2VNb2RlID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVUZXh0KCk7XFxuXFx0ICAgICAgICB0aGlzLl9lbWl0KFxcXCJjaGFuZ2VNb2RlXFxcIiwgZSk7XFxuXFx0ICAgIH07XFxuXFxuXFxuXFx0ICAgIHRoaXMub25DaGFuZ2VXcmFwTGltaXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlRnVsbCgpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uQ2hhbmdlV3JhcE1vZGUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIub25SZXNpemUodHJ1ZSk7XFxuXFx0ICAgIH07XFxuXFxuXFxuXFx0ICAgIHRoaXMub25DaGFuZ2VGb2xkID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUZ1bGwoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0Q29weVRleHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiY29weVxcXCIsIHRleHQpO1xcblxcdCAgICAgICAgcmV0dXJuIHRleHQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMub25Db3B5ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXFxcImNvcHlcXFwiLCB0aGlzKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5vbkN1dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5jb21tYW5kcy5leGVjKFxcXCJjdXRcXFwiLCB0aGlzKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5vblBhc3RlID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHJlYWRPbmx5KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBlID0ge3RleHQ6IHRleHR9O1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJwYXN0ZVxcXCIsIGUpO1xcblxcdCAgICAgICAgdGhpcy5pbnNlcnQoZS50ZXh0LCB0cnVlKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uKGNvbW1hbmQsIGFyZ3MpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzLmV4ZWMoY29tbWFuZCwgdGhpcywgYXJncyk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaW5zZXJ0ID0gZnVuY3Rpb24odGV4dCwgcGFzdGVkKSB7XFxuXFx0ICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcXG5cXHQgICAgICAgIHZhciBtb2RlID0gc2Vzc2lvbi5nZXRNb2RlKCk7XFxuXFx0ICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMuZ2V0QmVoYXZpb3Vyc0VuYWJsZWQoKSAmJiAhcGFzdGVkKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG1vZGUudHJhbnNmb3JtQWN0aW9uKHNlc3Npb24uZ2V0U3RhdGUoY3Vyc29yLnJvdyksICdpbnNlcnRpb24nLCB0aGlzLCBzZXNzaW9uLCB0ZXh0KTtcXG5cXHQgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh0ZXh0ICE9PSB0cmFuc2Zvcm0udGV4dCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm1lcmdlVW5kb0RlbHRhcyA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kbWVyZ2VOZXh0Q29tbWFuZCA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIHRleHQgPSB0cmFuc2Zvcm0udGV4dDtcXG5cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmICh0ZXh0ID09IFxcXCJcXFxcdFxcXCIpXFxuXFx0ICAgICAgICAgICAgdGV4dCA9IHRoaXMuc2Vzc2lvbi5nZXRUYWJTdHJpbmcoKTtcXG5cXHQgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgICAgIGN1cnNvciA9IHRoaXMuc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xcblxcdCAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Vzc2lvbi5nZXRPdmVyd3JpdGUoKSkge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBSYW5nZS5mcm9tUG9pbnRzKGN1cnNvciwgY3Vyc29yKTtcXG5cXHQgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uICs9IHRleHQubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKHRleHQgPT0gXFxcIlxcXFxuXFxcIiB8fCB0ZXh0ID09IFxcXCJcXFxcclxcXFxuXFxcIikge1xcblxcdCAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChjdXJzb3IuY29sdW1uID4gbGluZS5zZWFyY2goL1xcXFxTfCQvKSkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgZCA9IGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pLnNlYXJjaCgvXFxcXFN8JC8pO1xcblxcdCAgICAgICAgICAgICAgICBzZXNzaW9uLmRvYy5yZW1vdmVJbkxpbmUoY3Vyc29yLnJvdywgY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIGQpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXG5cXHQgICAgICAgIHZhciBzdGFydCA9IGN1cnNvci5jb2x1bW47XFxuXFx0ICAgICAgICB2YXIgbGluZVN0YXRlID0gc2Vzc2lvbi5nZXRTdGF0ZShjdXJzb3Iucm93KTtcXG5cXHQgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgdmFyIHNob3VsZE91dGRlbnQgPSBtb2RlLmNoZWNrT3V0ZGVudChsaW5lU3RhdGUsIGxpbmUsIHRleHQpO1xcblxcdCAgICAgICAgdmFyIGVuZCA9IHNlc3Npb24uaW5zZXJ0KGN1cnNvciwgdGV4dCk7XFxuXFxuXFx0ICAgICAgICBpZiAodHJhbnNmb3JtICYmIHRyYW5zZm9ybS5zZWxlY3Rpb24pIHtcXG5cXHQgICAgICAgICAgICBpZiAodHJhbnNmb3JtLnNlbGVjdGlvbi5sZW5ndGggPT0gMikgeyAvLyBUcmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgY29sdW1uXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKFxcblxcdCAgICAgICAgICAgICAgICAgICAgbmV3IFJhbmdlKGN1cnNvci5yb3csIHN0YXJ0ICsgdHJhbnNmb3JtLnNlbGVjdGlvblswXSxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3Iucm93LCBzdGFydCArIHRyYW5zZm9ybS5zZWxlY3Rpb25bMV0pKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgeyAvLyBUcmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm93LlxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShcXG5cXHQgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZShjdXJzb3Iucm93ICsgdHJhbnNmb3JtLnNlbGVjdGlvblswXSxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uc2VsZWN0aW9uWzFdLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvci5yb3cgKyB0cmFuc2Zvcm0uc2VsZWN0aW9uWzJdLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5zZWxlY3Rpb25bM10pKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoc2Vzc2lvbi5nZXREb2N1bWVudCgpLmlzTmV3TGluZSh0ZXh0KSkge1xcblxcdCAgICAgICAgICAgIHZhciBsaW5lSW5kZW50ID0gbW9kZS5nZXROZXh0TGluZUluZGVudChsaW5lU3RhdGUsIGxpbmUuc2xpY2UoMCwgY3Vyc29yLmNvbHVtbiksIHNlc3Npb24uZ2V0VGFiU3RyaW5nKCkpO1xcblxcblxcdCAgICAgICAgICAgIHNlc3Npb24uaW5zZXJ0KHtyb3c6IGN1cnNvci5yb3crMSwgY29sdW1uOiAwfSwgbGluZUluZGVudCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoc2hvdWxkT3V0ZGVudClcXG5cXHQgICAgICAgICAgICBtb2RlLmF1dG9PdXRkZW50KGxpbmVTdGF0ZSwgc2Vzc2lvbiwgY3Vyc29yLnJvdyk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25UZXh0SW5wdXQgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICB0aGlzLmtleUJpbmRpbmcub25UZXh0SW5wdXQodGV4dCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Db21tYW5kS2V5ID0gZnVuY3Rpb24oZSwgaGFzaElkLCBrZXlDb2RlKSB7XFxuXFx0ICAgICAgICB0aGlzLmtleUJpbmRpbmcub25Db21tYW5kS2V5KGUsIGhhc2hJZCwga2V5Q29kZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0T3ZlcndyaXRlID0gZnVuY3Rpb24ob3ZlcndyaXRlKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2V0T3ZlcndyaXRlKG92ZXJ3cml0ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0T3ZlcndyaXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldE92ZXJ3cml0ZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnRvZ2dsZU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnRvZ2dsZU92ZXJ3cml0ZSgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNjcm9sbFNwZWVkID0gZnVuY3Rpb24oc3BlZWQpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJzY3JvbGxTcGVlZFxcXCIsIHNwZWVkKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFxcXCJzY3JvbGxTcGVlZFxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldERyYWdEZWxheSA9IGZ1bmN0aW9uKGRyYWdEZWxheSkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcImRyYWdEZWxheVxcXCIsIGRyYWdEZWxheSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0RHJhZ0RlbGF5ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcImRyYWdEZWxheVxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlID0gZnVuY3Rpb24odmFsKSB7XFxuXFx0ICAgICAgICB0aGlzLnNldE9wdGlvbihcXFwic2VsZWN0aW9uU3R5bGVcXFwiLCB2YWwpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNlbGVjdGlvblN0eWxlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcInNlbGVjdGlvblN0eWxlXFxcIik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0SGlnaGxpZ2h0QWN0aXZlTGluZSA9IGZ1bmN0aW9uKHNob3VsZEhpZ2hsaWdodCkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcImhpZ2hsaWdodEFjdGl2ZUxpbmVcXFwiLCBzaG91bGRIaWdobGlnaHQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEhpZ2hsaWdodEFjdGl2ZUxpbmUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcXFwiaGlnaGxpZ2h0QWN0aXZlTGluZVxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldEhpZ2hsaWdodEd1dHRlckxpbmUgPSBmdW5jdGlvbihzaG91bGRIaWdobGlnaHQpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJoaWdobGlnaHRHdXR0ZXJMaW5lXFxcIiwgc2hvdWxkSGlnaGxpZ2h0KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRIaWdobGlnaHRHdXR0ZXJMaW5lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcImhpZ2hsaWdodEd1dHRlckxpbmVcXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRIaWdobGlnaHRTZWxlY3RlZFdvcmQgPSBmdW5jdGlvbihzaG91bGRIaWdobGlnaHQpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJoaWdobGlnaHRTZWxlY3RlZFdvcmRcXFwiLCBzaG91bGRIaWdobGlnaHQpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEhpZ2hsaWdodFNlbGVjdGVkV29yZCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGhpZ2hsaWdodFNlbGVjdGVkV29yZDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uKHNob3VsZEFuaW1hdGUpe1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBbmltYXRlZFNjcm9sbChzaG91bGRBbmltYXRlKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uKCl7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRBbmltYXRlZFNjcm9sbCgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24oc2hvd0ludmlzaWJsZXMpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2hvd0ludmlzaWJsZXMoc2hvd0ludmlzaWJsZXMpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRTaG93SW52aXNpYmxlcygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbihkaXNwbGF5KSB7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnNldERpc3BsYXlJbmRlbnRHdWlkZXMoZGlzcGxheSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0RGlzcGxheUluZGVudEd1aWRlcygpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNob3dQcmludE1hcmdpbiA9IGZ1bmN0aW9uKHNob3dQcmludE1hcmdpbikge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaG93UHJpbnRNYXJnaW4oc2hvd1ByaW50TWFyZ2luKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTaG93UHJpbnRNYXJnaW4gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFNob3dQcmludE1hcmdpbigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFByaW50TWFyZ2luQ29sdW1uID0gZnVuY3Rpb24oc2hvd1ByaW50TWFyZ2luKSB7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByaW50TWFyZ2luQ29sdW1uKHNob3dQcmludE1hcmdpbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0UHJpbnRNYXJnaW5Db2x1bW4gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFByaW50TWFyZ2luQ29sdW1uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0UmVhZE9ubHkgPSBmdW5jdGlvbihyZWFkT25seSkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcInJlYWRPbmx5XFxcIiwgcmVhZE9ubHkpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFJlYWRPbmx5ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcInJlYWRPbmx5XFxcIik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0QmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcImJlaGF2aW91cnNFbmFibGVkXFxcIiwgZW5hYmxlZCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0QmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcImJlaGF2aW91cnNFbmFibGVkXFxcIik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0V3JhcEJlaGF2aW91cnNFbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJ3cmFwQmVoYXZpb3Vyc0VuYWJsZWRcXFwiLCBlbmFibGVkKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcIndyYXBCZWhhdmlvdXJzRW5hYmxlZFxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNob3dGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKHNob3cpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJzaG93Rm9sZFdpZGdldHNcXFwiLCBzaG93KTtcXG5cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcXFwic2hvd0ZvbGRXaWRnZXRzXFxcIik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0RmFkZUZvbGRXaWRnZXRzID0gZnVuY3Rpb24oZmFkZSkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcImZhZGVGb2xkV2lkZ2V0c1xcXCIsIGZhZGUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldEZhZGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFxcXCJmYWRlRm9sZFdpZGdldHNcXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbihkaXIpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpe1xcblxcdCAgICAgICAgICAgIGlmIChkaXIgPT0gXFxcImxlZnRcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RMZWZ0KCk7XFxuXFx0ICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RSaWdodCgpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuZ2V0QmVoYXZpb3Vyc0VuYWJsZWQoKSkge1xcblxcdCAgICAgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNlc3Npb24uZ2V0U3RhdGUocmFuZ2Uuc3RhcnQucm93KTtcXG5cXHQgICAgICAgICAgICB2YXIgbmV3X3JhbmdlID0gc2Vzc2lvbi5nZXRNb2RlKCkudHJhbnNmb3JtQWN0aW9uKHN0YXRlLCAnZGVsZXRpb24nLCB0aGlzLCBzZXNzaW9uLCByYW5nZSk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHJhbmdlLmVuZC5jb2x1bW4gPT09IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT0gXFxcIlxcXFxuXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocmFuZ2UuZW5kLnJvdyk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoL15cXFxccyskLy50ZXN0KGxpbmUpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbiA9IGxpbmUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmIChuZXdfcmFuZ2UpXFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3X3JhbmdlO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZShyYW5nZSk7XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlV29yZFJpZ2h0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmRSaWdodCgpO1xcblxcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZSh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpO1xcblxcdCAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnJlbW92ZVdvcmRMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmRMZWZ0KCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlVG9MaW5lU3RhcnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0TGluZVN0YXJ0KCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVtb3ZlVG9MaW5lRW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdExpbmVFbmQoKTtcXG5cXG5cXHQgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIGlmIChyYW5nZS5zdGFydC5jb2x1bW4gPT0gcmFuZ2UuZW5kLmNvbHVtbiAmJiByYW5nZS5zdGFydC5yb3cgPT0gcmFuZ2UuZW5kLnJvdykge1xcblxcdCAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSAwO1xcblxcdCAgICAgICAgICAgIHJhbmdlLmVuZC5yb3crKztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmUocmFuZ2UpO1xcblxcdCAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNwbGl0TGluZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcXG5cXHQgICAgICAgIHRoaXMuaW5zZXJ0KFxcXCJcXFxcblxcXCIpO1xcblxcdCAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihjdXJzb3IpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnRyYW5zcG9zZUxldHRlcnMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcXG5cXHQgICAgICAgIHZhciBjb2x1bW4gPSBjdXJzb3IuY29sdW1uO1xcblxcdCAgICAgICAgaWYgKGNvbHVtbiA9PT0gMClcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMuc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgdmFyIHN3YXAsIHJhbmdlO1xcblxcdCAgICAgICAgaWYgKGNvbHVtbiA8IGxpbmUubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgc3dhcCA9IGxpbmUuY2hhckF0KGNvbHVtbikgKyBsaW5lLmNoYXJBdChjb2x1bW4tMSk7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLnJvdywgY29sdW1uLTEsIGN1cnNvci5yb3csIGNvbHVtbisxKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgIHN3YXAgPSBsaW5lLmNoYXJBdChjb2x1bW4tMSkgKyBsaW5lLmNoYXJBdChjb2x1bW4tMik7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLnJvdywgY29sdW1uLTIsIGN1cnNvci5yb3csIGNvbHVtbik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgc3dhcCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudG9Mb3dlckNhc2UgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBvcmlnaW5hbFJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdFdvcmQoKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgdGV4dC50b0xvd2VyQ2FzZSgpKTtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKG9yaWdpbmFsUmFuZ2UpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnRvVXBwZXJDYXNlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgb3JpZ2luYWxSYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RXb3JkKCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCk7XFxuXFx0ICAgICAgICB2YXIgdGV4dCA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHRleHQudG9VcHBlckNhc2UoKSk7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShvcmlnaW5hbFJhbmdlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pbmRlbnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcblxcdCAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LnJvdyA8IHJhbmdlLmVuZC5yb3cpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cygpO1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uaW5kZW50Um93cyhyb3dzLmZpcnN0LCByb3dzLmxhc3QsIFxcXCJcXFxcdFxcXCIpO1xcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAocmFuZ2Uuc3RhcnQuY29sdW1uIDwgcmFuZ2UuZW5kLmNvbHVtbikge1xcblxcdCAgICAgICAgICAgIHZhciB0ZXh0ID0gc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgICAgIGlmICghL15cXFxccyskLy50ZXN0KHRleHQpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XFxuXFx0ICAgICAgICAgICAgICAgIHNlc3Npb24uaW5kZW50Um93cyhyb3dzLmZpcnN0LCByb3dzLmxhc3QsIFxcXCJcXFxcdFxcXCIpO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xcblxcdCAgICAgICAgdmFyIHBvc2l0aW9uID0gcmFuZ2Uuc3RhcnQ7XFxuXFx0ICAgICAgICB2YXIgc2l6ZSA9IHNlc3Npb24uZ2V0VGFiU2l6ZSgpO1xcblxcdCAgICAgICAgdmFyIGNvbHVtbiA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlbkNvbHVtbihwb3NpdGlvbi5yb3csIHBvc2l0aW9uLmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmdldFVzZVNvZnRUYWJzKCkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgY291bnQgPSAoc2l6ZSAtIGNvbHVtbiAlIHNpemUpO1xcblxcdCAgICAgICAgICAgIHZhciBpbmRlbnRTdHJpbmcgPSBsYW5nLnN0cmluZ1JlcGVhdChcXFwiIFxcXCIsIGNvdW50KTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGNvdW50ID0gY29sdW1uICUgc2l6ZTtcXG5cXHQgICAgICAgICAgICB3aGlsZSAobGluZVtyYW5nZS5zdGFydC5jb2x1bW5dID09IFxcXCIgXFxcIiAmJiBjb3VudCkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4tLTtcXG5cXHQgICAgICAgICAgICAgICAgY291bnQtLTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgICAgIGluZGVudFN0cmluZyA9IFxcXCJcXFxcdFxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnQoaW5kZW50U3RyaW5nKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5ibG9ja0luZGVudCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MoKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5pbmRlbnRSb3dzKHJvd3MuZmlyc3QsIHJvd3MubGFzdCwgXFxcIlxcXFx0XFxcIik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYmxvY2tPdXRkZW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZXNzaW9uLmdldFNlbGVjdGlvbigpO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLm91dGRlbnRSb3dzKHNlbGVjdGlvbi5nZXRSYW5nZSgpKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zb3J0TGluZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XFxuXFx0ICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcXG5cXG5cXHQgICAgICAgIHZhciBsaW5lcyA9IFtdO1xcblxcdCAgICAgICAgZm9yIChpID0gcm93cy5maXJzdDsgaSA8PSByb3dzLmxhc3Q7IGkrKylcXG5cXHQgICAgICAgICAgICBsaW5lcy5wdXNoKHNlc3Npb24uZ2V0TGluZShpKSk7XFxuXFxuXFx0ICAgICAgICBsaW5lcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcXG5cXHQgICAgICAgICAgICBpZiAoYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpKSByZXR1cm4gLTE7XFxuXFx0ICAgICAgICAgICAgaWYgKGEudG9Mb3dlckNhc2UoKSA+IGIudG9Mb3dlckNhc2UoKSkgcmV0dXJuIDE7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIDA7XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIHZhciBkZWxldGVSYW5nZSA9IG5ldyBSYW5nZSgwLCAwLCAwLCAwKTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSByb3dzLmZpcnN0OyBpIDw9IHJvd3MubGFzdDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUoaSk7XFxuXFx0ICAgICAgICAgICAgZGVsZXRlUmFuZ2Uuc3RhcnQucm93ID0gaTtcXG5cXHQgICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQucm93ID0gaTtcXG5cXHQgICAgICAgICAgICBkZWxldGVSYW5nZS5lbmQuY29sdW1uID0gbGluZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgc2Vzc2lvbi5yZXBsYWNlKGRlbGV0ZVJhbmdlLCBsaW5lc1tpLXJvd3MuZmlyc3RdKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy50b2dnbGVDb21tZW50TGluZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Vzc2lvbi5nZXRTdGF0ZSh0aGlzLmdldEN1cnNvclBvc2l0aW9uKCkucm93KTtcXG5cXHQgICAgICAgIHZhciByb3dzID0gdGhpcy4kZ2V0U2VsZWN0ZWRSb3dzKCk7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uZ2V0TW9kZSgpLnRvZ2dsZUNvbW1lbnRMaW5lcyhzdGF0ZSwgdGhpcy5zZXNzaW9uLCByb3dzLmZpcnN0LCByb3dzLmxhc3QpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnRvZ2dsZUJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcXG5cXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Vzc2lvbi5nZXRTdGF0ZShjdXJzb3Iucm93KTtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5nZXRNb2RlKCkudG9nZ2xlQmxvY2tDb21tZW50KHN0YXRlLCB0aGlzLnNlc3Npb24sIHJhbmdlLCBjdXJzb3IpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldE51bWJlckF0ID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHZhciBfbnVtYmVyUnggPSAvW1xcXFwtXT9bMC05XSsoPzpcXFxcLlswLTldKyk/L2c7XFxuXFx0ICAgICAgICBfbnVtYmVyUngubGFzdEluZGV4ID0gMDtcXG5cXG5cXHQgICAgICAgIHZhciBzID0gdGhpcy5zZXNzaW9uLmdldExpbmUocm93KTtcXG5cXHQgICAgICAgIHdoaWxlIChfbnVtYmVyUngubGFzdEluZGV4IDwgY29sdW1uKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIG0gPSBfbnVtYmVyUnguZXhlYyhzKTtcXG5cXHQgICAgICAgICAgICBpZihtLmluZGV4IDw9IGNvbHVtbiAmJiBtLmluZGV4K21bMF0ubGVuZ3RoID49IGNvbHVtbil7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBudW1iZXIgPSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbVswXSxcXG5cXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBtLmluZGV4LFxcblxcdCAgICAgICAgICAgICAgICAgICAgZW5kOiBtLmluZGV4K21bMF0ubGVuZ3RoXFxuXFx0ICAgICAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW9kaWZ5TnVtYmVyID0gZnVuY3Rpb24oYW1vdW50KSB7XFxuXFx0ICAgICAgICB2YXIgcm93ID0gdGhpcy5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCkucm93O1xcblxcdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuc2VsZWN0aW9uLmdldEN1cnNvcigpLmNvbHVtbjtcXG5cXHQgICAgICAgIHZhciBjaGFyUmFuZ2UgPSBuZXcgUmFuZ2Uocm93LCBjb2x1bW4tMSwgcm93LCBjb2x1bW4pO1xcblxcblxcdCAgICAgICAgdmFyIGMgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKGNoYXJSYW5nZSk7XFxuXFx0ICAgICAgICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQoYykpICYmIGlzRmluaXRlKGMpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIG5yID0gdGhpcy5nZXROdW1iZXJBdChyb3csIGNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgaWYgKG5yKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBmcCA9IG5yLnZhbHVlLmluZGV4T2YoXFxcIi5cXFwiKSA+PSAwID8gbnIuc3RhcnQgKyBuci52YWx1ZS5pbmRleE9mKFxcXCIuXFxcIikgKyAxIDogbnIuZW5kO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBuci5zdGFydCArIG5yLnZhbHVlLmxlbmd0aCAtIGZwO1xcblxcblxcdCAgICAgICAgICAgICAgICB2YXIgdCA9IHBhcnNlRmxvYXQobnIudmFsdWUpO1xcblxcdCAgICAgICAgICAgICAgICB0ICo9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XFxuXFxuXFxuXFx0ICAgICAgICAgICAgICAgIGlmKGZwICE9PSBuci5lbmQgJiYgY29sdW1uIDwgZnApe1xcblxcdCAgICAgICAgICAgICAgICAgICAgYW1vdW50ICo9IE1hdGgucG93KDEwLCBuci5lbmQgLSBjb2x1bW4gLSAxKTtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGFtb3VudCAqPSBNYXRoLnBvdygxMCwgbnIuZW5kIC0gY29sdW1uKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICB0ICs9IGFtb3VudDtcXG5cXHQgICAgICAgICAgICAgICAgdCAvPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbm5yID0gdC50b0ZpeGVkKGRlY2ltYWxzKTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VSYW5nZSA9IG5ldyBSYW5nZShyb3csIG5yLnN0YXJ0LCByb3csIG5yLmVuZCk7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZXBsYWNlKHJlcGxhY2VSYW5nZSwgbm5yKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8ocm93LCBNYXRoLm1heChuci5zdGFydCArMSwgY29sdW1uICsgbm5yLmxlbmd0aCAtIG5yLnZhbHVlLmxlbmd0aCkpO1xcblxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZW1vdmVMaW5lcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJvd3MgPSB0aGlzLiRnZXRTZWxlY3RlZFJvd3MoKTtcXG5cXHQgICAgICAgIHZhciByYW5nZTtcXG5cXHQgICAgICAgIGlmIChyb3dzLmZpcnN0ID09PSAwIHx8IHJvd3MubGFzdCsxIDwgdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpKVxcblxcdCAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKHJvd3MuZmlyc3QsIDAsIHJvd3MubGFzdCsxLCAwKTtcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShcXG5cXHQgICAgICAgICAgICAgICAgcm93cy5maXJzdC0xLCB0aGlzLnNlc3Npb24uZ2V0TGluZShyb3dzLmZpcnN0LTEpLmxlbmd0aCxcXG5cXHQgICAgICAgICAgICAgICAgcm93cy5sYXN0LCB0aGlzLnNlc3Npb24uZ2V0TGluZShyb3dzLmxhc3QpLmxlbmd0aFxcblxcdCAgICAgICAgICAgICk7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcXG5cXHQgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5kdXBsaWNhdGVTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzZWwgPSB0aGlzLnNlbGVjdGlvbjtcXG5cXHQgICAgICAgIHZhciBkb2MgPSB0aGlzLnNlc3Npb247XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuZ2V0UmFuZ2UoKTtcXG5cXHQgICAgICAgIHZhciByZXZlcnNlID0gc2VsLmlzQmFja3dhcmRzKCk7XFxuXFx0ICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICBkb2MuZHVwbGljYXRlTGluZXMocm93LCByb3cpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgcG9pbnQgPSByZXZlcnNlID8gcmFuZ2Uuc3RhcnQgOiByYW5nZS5lbmQ7XFxuXFx0ICAgICAgICAgICAgdmFyIGVuZFBvaW50ID0gZG9jLmluc2VydChwb2ludCwgZG9jLmdldFRleHRSYW5nZShyYW5nZSksIGZhbHNlKTtcXG5cXHQgICAgICAgICAgICByYW5nZS5zdGFydCA9IHBvaW50O1xcblxcdCAgICAgICAgICAgIHJhbmdlLmVuZCA9IGVuZFBvaW50O1xcblxcblxcdCAgICAgICAgICAgIHNlbC5zZXRTZWxlY3Rpb25SYW5nZShyYW5nZSwgcmV2ZXJzZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubW92ZUxpbmVzRG93biA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZUxpbmVzKGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5tb3ZlTGluZXNEb3duKGZpcnN0Um93LCBsYXN0Um93KTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVMaW5lc1VwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlTGluZXMoZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLm1vdmVMaW5lc1VwKGZpcnN0Um93LCBsYXN0Um93KTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVUZXh0ID0gZnVuY3Rpb24ocmFuZ2UsIHRvUG9zaXRpb24sIGNvcHkpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24ubW92ZVRleHQocmFuZ2UsIHRvUG9zaXRpb24sIGNvcHkpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNvcHlMaW5lc1VwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlTGluZXMoZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3cpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uZHVwbGljYXRlTGluZXMoZmlyc3RSb3csIGxhc3RSb3cpO1xcblxcdCAgICAgICAgICAgIHJldHVybiAwO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY29weUxpbmVzRG93biA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZUxpbmVzKGZ1bmN0aW9uKGZpcnN0Um93LCBsYXN0Um93KSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5kdXBsaWNhdGVMaW5lcyhmaXJzdFJvdywgbGFzdFJvdyk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy4kbW92ZUxpbmVzID0gZnVuY3Rpb24obW92ZXIpIHtcXG5cXHQgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcXG5cXHQgICAgICAgIGlmICghc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlIHx8IHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuJGdldFNlbGVjdGVkUm93cyhyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmVzTW92ZWQgPSBtb3Zlci5jYWxsKHRoaXMsIHJvd3MuZmlyc3QsIHJvd3MubGFzdCk7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UubW92ZUJ5KGxpbmVzTW92ZWQsIDApO1xcblxcdCAgICAgICAgICAgIHNlbGVjdGlvbi5mcm9tT3JpZW50ZWRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZXMgPSBzZWxlY3Rpb24ucmFuZ2VMaXN0LnJhbmdlcztcXG5cXHQgICAgICAgICAgICBzZWxlY3Rpb24ucmFuZ2VMaXN0LmRldGFjaCh0aGlzLnNlc3Npb24pO1xcblxcblxcdCAgICAgICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07ICkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgcmFuZ2VJbmRleCA9IGk7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciByb3dzID0gcmFuZ2VzW2ldLmNvbGxhcHNlUm93cygpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHJvd3MuZW5kLnJvdztcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gcm93cy5zdGFydC5yb3c7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvd3MgPSByYW5nZXNbaV0uY29sbGFwc2VSb3dzKCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QgLSByb3dzLmVuZC5yb3cgPD0gMSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHJvd3MuZW5kLnJvdztcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBpKys7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHZhciBsaW5lc01vdmVkID0gbW92ZXIuY2FsbCh0aGlzLCBmaXJzdCwgbGFzdCk7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZUluZGV4ID49IGkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlc1tyYW5nZUluZGV4XS5tb3ZlQnkobGluZXNNb3ZlZCwgMCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByYW5nZUluZGV4LS07XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9uLmZyb21PcmllbnRlZFJhbmdlKHNlbGVjdGlvbi5yYW5nZXNbMF0pO1xcblxcdCAgICAgICAgICAgIHNlbGVjdGlvbi5yYW5nZUxpc3QuYXR0YWNoKHRoaXMuc2Vzc2lvbik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJGdldFNlbGVjdGVkUm93cyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpLmNvbGxhcHNlUm93cygpO1xcblxcblxcdCAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICBmaXJzdDogdGhpcy5zZXNzaW9uLmdldFJvd0ZvbGRTdGFydChyYW5nZS5zdGFydC5yb3cpLFxcblxcdCAgICAgICAgICAgIGxhc3Q6IHRoaXMuc2Vzc2lvbi5nZXRSb3dGb2xkRW5kKHJhbmdlLmVuZC5yb3cpXFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uQ29tcG9zaXRpb25TdGFydCA9IGZ1bmN0aW9uKHRleHQpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2hvd0NvbXBvc2l0aW9uKHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24oKSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25Db21wb3NpdGlvblVwZGF0ZSA9IGZ1bmN0aW9uKHRleHQpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q29tcG9zaXRpb25UZXh0KHRleHQpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9uQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuaGlkZUNvbXBvc2l0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0Rmlyc3RWaXNpYmxlUm93ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRGaXJzdFZpc2libGVSb3coKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMYXN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0TGFzdFZpc2libGVSb3coKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pc1Jvd1Zpc2libGUgPSBmdW5jdGlvbihyb3cpIHtcXG5cXHQgICAgICAgIHJldHVybiAocm93ID49IHRoaXMuZ2V0Rmlyc3RWaXNpYmxlUm93KCkgJiYgcm93IDw9IHRoaXMuZ2V0TGFzdFZpc2libGVSb3coKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaXNSb3dGdWxseVZpc2libGUgPSBmdW5jdGlvbihyb3cpIHtcXG5cXHQgICAgICAgIHJldHVybiAocm93ID49IHRoaXMucmVuZGVyZXIuZ2V0Rmlyc3RGdWxseVZpc2libGVSb3coKSAmJiByb3cgPD0gdGhpcy5yZW5kZXJlci5nZXRMYXN0RnVsbHlWaXNpYmxlUm93KCkpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiRnZXRWaXNpYmxlUm93Q291bnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFNjcm9sbEJvdHRvbVJvdygpIC0gdGhpcy5yZW5kZXJlci5nZXRTY3JvbGxUb3BSb3coKSArIDE7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG1vdmVCeVBhZ2UgPSBmdW5jdGlvbihkaXIsIHNlbGVjdCkge1xcblxcdCAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcXG5cXHQgICAgICAgIHZhciBjb25maWcgPSB0aGlzLnJlbmRlcmVyLmxheWVyQ29uZmlnO1xcblxcdCAgICAgICAgdmFyIHJvd3MgPSBkaXIgKiBNYXRoLmZsb29yKGNvbmZpZy5oZWlnaHQgLyBjb25maWcubGluZUhlaWdodCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZysrO1xcblxcdCAgICAgICAgaWYgKHNlbGVjdCA9PT0gdHJ1ZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLiRtb3ZlU2VsZWN0aW9uKGZ1bmN0aW9uKCl7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvckJ5KHJvd3MsIDApO1xcblxcdCAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QgPT09IGZhbHNlKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckJ5KHJvd3MsIDApO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZy0tO1xcblxcblxcdCAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHJlbmRlcmVyLnNjcm9sbFRvcDtcXG5cXG5cXHQgICAgICAgIHJlbmRlcmVyLnNjcm9sbEJ5KDAsIHJvd3MgKiBjb25maWcubGluZUhlaWdodCk7XFxuXFx0ICAgICAgICBpZiAoc2VsZWN0ICE9IG51bGwpXFxuXFx0ICAgICAgICAgICAgcmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcXG5cXG5cXHQgICAgICAgIHJlbmRlcmVyLmFuaW1hdGVTY3JvbGxpbmcoc2Nyb2xsVG9wKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZWxlY3RQYWdlRG93biA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbW92ZUJ5UGFnZSgxLCB0cnVlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZWxlY3RQYWdlVXAgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoLTEsIHRydWUpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdvdG9QYWdlRG93biA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKDEsIGZhbHNlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nb3RvUGFnZVVwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKC0xLCBmYWxzZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2Nyb2xsUGFnZURvd24gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJG1vdmVCeVBhZ2UoMSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2Nyb2xsUGFnZVVwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlQnlQYWdlKC0xKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zY3JvbGxUb1JvdyA9IGZ1bmN0aW9uKHJvdykge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5zY3JvbGxUb1Jvdyhyb3cpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNjcm9sbFRvTGluZSA9IGZ1bmN0aW9uKGxpbmUsIGNlbnRlciwgYW5pbWF0ZSwgY2FsbGJhY2spIHtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsVG9MaW5lKGxpbmUsIGNlbnRlciwgYW5pbWF0ZSwgY2FsbGJhY2spO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNlbnRlclNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgdmFyIHBvcyA9IHtcXG5cXHQgICAgICAgICAgICByb3c6IE1hdGguZmxvb3IocmFuZ2Uuc3RhcnQucm93ICsgKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cpIC8gMiksXFxuXFx0ICAgICAgICAgICAgY29sdW1uOiBNYXRoLmZsb29yKHJhbmdlLnN0YXJ0LmNvbHVtbiArIChyYW5nZS5lbmQuY29sdW1uIC0gcmFuZ2Uuc3RhcnQuY29sdW1uKSAvIDIpXFxuXFx0ICAgICAgICB9O1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci5hbGlnbkN1cnNvcihwb3MsIDAuNSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0Q3Vyc29yUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5nZXRDdXJzb3IoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRDdXJzb3JQb3NpdGlvblNjcmVlbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5nZXRDdXJzb3JQb3NpdGlvbigpKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmdldFJhbmdlKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2VsZWN0QWxsID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xcblxcdCAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0QWxsKCk7XFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyAtPSAxO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JUbyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG8ocm93LCBjb2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uID0gZnVuY3Rpb24ocG9zKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihwb3MpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmp1bXBUb01hdGNoaW5nID0gZnVuY3Rpb24oc2VsZWN0LCBleHBhbmQpIHtcXG5cXHQgICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmdldEN1cnNvclBvc2l0aW9uKCk7XFxuXFx0ICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcih0aGlzLnNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICAgICAgdmFyIHByZXZUb2tlbiA9IGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpO1xcblxcdCAgICAgICAgdmFyIHRva2VuID0gcHJldlRva2VuIHx8IGl0ZXJhdG9yLnN0ZXBGb3J3YXJkKCk7XFxuXFxuXFx0ICAgICAgICBpZiAoIXRva2VuKSByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgbWF0Y2hUeXBlO1xcblxcdCAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XFxuXFx0ICAgICAgICB2YXIgZGVwdGggPSB7fTtcXG5cXHQgICAgICAgIHZhciBpID0gY3Vyc29yLmNvbHVtbiAtIHRva2VuLnN0YXJ0O1xcblxcdCAgICAgICAgdmFyIGJyYWNrZXRUeXBlO1xcblxcdCAgICAgICAgdmFyIGJyYWNrZXRzID0ge1xcblxcdCAgICAgICAgICAgIFxcXCIpXFxcIjogXFxcIihcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCIoXFxcIjogXFxcIihcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJdXFxcIjogXFxcIltcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJbXFxcIjogXFxcIltcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJ7XFxcIjogXFxcIntcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJ9XFxcIjogXFxcIntcXFwiXFxuXFx0ICAgICAgICB9O1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBkbyB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlLm1hdGNoKC9be30oKVxcXFxbXFxcXF1dL2cpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgdG9rZW4udmFsdWUubGVuZ3RoICYmICFmb3VuZDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXRzW3Rva2VuLnZhbHVlW2ldXSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgICAgICAgICAgYnJhY2tldFR5cGUgPSBicmFja2V0c1t0b2tlbi52YWx1ZVtpXV0gKyAnLicgKyB0b2tlbi50eXBlLnJlcGxhY2UoXFxcInJwYXJlblxcXCIsIFxcXCJscGFyZW5cXFwiKTtcXG5cXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkZXB0aFticmFja2V0VHlwZV0pKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhbYnJhY2tldFR5cGVdID0gMDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWVbaV0pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcoJzpcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGhbYnJhY2tldFR5cGVdKys7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOlxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ30nOlxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aFticmFja2V0VHlwZV0tLTtcXG5cXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoW2JyYWNrZXRUeXBlXSA9PT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoVHlwZSA9ICdicmFja2V0JztcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGRlcHRoW3Rva2VuLnZhbHVlXSkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGRlcHRoW3Rva2VuLnZhbHVlXSA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8Jykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgZGVwdGhbdG9rZW4udmFsdWVdKys7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPC8nKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBkZXB0aFt0b2tlbi52YWx1ZV0tLTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGRlcHRoW3Rva2VuLnZhbHVlXSA9PT0gLTEpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIG1hdGNoVHlwZSA9ICd0YWcnO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIGlmICghZm91bmQpIHtcXG5cXHQgICAgICAgICAgICAgICAgcHJldlRva2VuID0gdG9rZW47XFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuID0gaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcXG5cXHQgICAgICAgICAgICAgICAgaSA9IDA7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSB3aGlsZSAodG9rZW4gJiYgIWZvdW5kKTtcXG5cXHQgICAgICAgIGlmICghbWF0Y2hUeXBlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHZhciByYW5nZSwgcG9zO1xcblxcdCAgICAgICAgaWYgKG1hdGNoVHlwZSA9PT0gJ2JyYWNrZXQnKSB7XFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnNlc3Npb24uZ2V0QnJhY2tldFJhbmdlKGN1cnNvcik7XFxuXFx0ICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShcXG5cXHQgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxcblxcdCAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpIC0gMSxcXG5cXHQgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxcblxcdCAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyBpIC0gMVxcblxcdCAgICAgICAgICAgICAgICApO1xcblxcdCAgICAgICAgICAgICAgICBwb3MgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGV4cGFuZCB8fCBwb3Mucm93ID09PSBjdXJzb3Iucm93ICYmIE1hdGguYWJzKHBvcy5jb2x1bW4gLSBjdXJzb3IuY29sdW1uKSA8IDIpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRCcmFja2V0UmFuZ2UocG9zKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIGlmIChtYXRjaFR5cGUgPT09ICd0YWcnKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSAhPT0gLTEpIFxcblxcdCAgICAgICAgICAgICAgICB2YXIgdGFnID0gdG9rZW4udmFsdWU7XFxuXFx0ICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoXFxuXFx0ICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxcblxcdCAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSAtIDIsXFxuXFx0ICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpLFxcblxcdCAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Db2x1bW4oKSAtIDJcXG5cXHQgICAgICAgICAgICApO1xcblxcdCAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlKGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pID09PSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcHJldlRva2VuO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcHJldlRva2VuID0gaXRlcmF0b3Iuc3RlcEJhY2t3YXJkKCk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VG9rZW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnR5cGUuaW5kZXhPZigndGFnLWNsb3NlJykgIT09IC0xKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSwgaXRlcmF0b3IuZ2V0Q3VycmVudFRva2VuQ29sdW1uKCkgKyAxKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSB0YWcgJiYgdG9rZW4udHlwZS5pbmRleE9mKCd0YWctbmFtZScpICE9PSAtMSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnPCcpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoW3RhZ10rKztcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICc8LycpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoW3RhZ10tLTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoW3RhZ10gPT09IDApXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2VG9rZW4gJiYgIWZvdW5kKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUuaW5kZXhPZigndGFnLW5hbWUnKSkge1xcblxcdCAgICAgICAgICAgICAgICBwb3MgPSByYW5nZS5zdGFydDtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHBvcy5yb3cgPT0gY3Vyc29yLnJvdyAmJiBNYXRoLmFicyhwb3MuY29sdW1uIC0gY3Vyc29yLmNvbHVtbikgPCAyKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcG9zID0gcmFuZ2UuZW5kO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHBvcyA9IHJhbmdlICYmIHJhbmdlLmN1cnNvciB8fCBwb3M7XFxuXFx0ICAgICAgICBpZiAocG9zKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgZXhwYW5kKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UgJiYgcmFuZ2UuaXNFcXVhbCh0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3RUbyhwb3Mucm93LCBwb3MuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVUbyhwb3Mucm93LCBwb3MuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ290b0xpbmUgPSBmdW5jdGlvbihsaW5lTnVtYmVyLCBjb2x1bW4sIGFuaW1hdGUpIHtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24udW5mb2xkKHtyb3c6IGxpbmVOdW1iZXIgLSAxLCBjb2x1bW46IGNvbHVtbiB8fCAwfSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xcblxcdCAgICAgICAgdGhpcy5leGl0TXVsdGlTZWxlY3RNb2RlICYmIHRoaXMuZXhpdE11bHRpU2VsZWN0TW9kZSgpO1xcblxcdCAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG8obGluZU51bWJlciAtIDEsIGNvbHVtbiB8fCAwKTtcXG5cXHQgICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XFxuXFxuXFx0ICAgICAgICBpZiAoIXRoaXMuaXNSb3dGdWxseVZpc2libGUobGluZU51bWJlciAtIDEpKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9MaW5lKGxpbmVOdW1iZXIgLSAxLCB0cnVlLCBhbmltYXRlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5uYXZpZ2F0ZVRvID0gZnVuY3Rpb24ocm93LCBjb2x1bW4pIHtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVUbyhyb3csIGNvbHVtbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubmF2aWdhdGVVcCA9IGZ1bmN0aW9uKHRpbWVzKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNNdWx0aUxpbmUoKSAmJiAhdGhpcy5zZWxlY3Rpb24uaXNCYWNrd2FyZHMoKSkge1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uLmFuY2hvci5nZXRQb3NpdGlvbigpO1xcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKHNlbGVjdGlvblN0YXJ0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yQnkoLXRpbWVzIHx8IC0xLCAwKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5uYXZpZ2F0ZURvd24gPSBmdW5jdGlvbih0aW1lcykge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLmlzTXVsdGlMaW5lKCkgJiYgdGhpcy5zZWxlY3Rpb24uaXNCYWNrd2FyZHMoKSkge1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbi5hbmNob3IuZ2V0UG9zaXRpb24oKTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25FbmQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JCeSh0aW1lcyB8fCAxLCAwKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5uYXZpZ2F0ZUxlZnQgPSBmdW5jdGlvbih0aW1lcykge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkuc3RhcnQ7XFxuXFx0ICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihzZWxlY3Rpb25TdGFydCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICB0aW1lcyA9IHRpbWVzIHx8IDE7XFxuXFx0ICAgICAgICAgICAgd2hpbGUgKHRpbWVzLS0pIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZUN1cnNvckxlZnQoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubmF2aWdhdGVSaWdodCA9IGZ1bmN0aW9uKHRpbWVzKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3Rpb25FbmQgPSB0aGlzLmdldFNlbGVjdGlvblJhbmdlKCkuZW5kO1xcblxcdCAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvUG9zaXRpb24oc2VsZWN0aW9uRW5kKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRpbWVzID0gdGltZXMgfHwgMTtcXG5cXHQgICAgICAgICAgICB3aGlsZSAodGltZXMtLSkge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yUmlnaHQoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubmF2aWdhdGVMaW5lU3RhcnQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JMaW5lU3RhcnQoKTtcXG5cXHQgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5uYXZpZ2F0ZUxpbmVFbmQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JMaW5lRW5kKCk7XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubmF2aWdhdGVGaWxlRW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yRmlsZUVuZCgpO1xcblxcdCAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLm5hdmlnYXRlRmlsZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yRmlsZVN0YXJ0KCk7XFxuXFx0ICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubmF2aWdhdGVXb3JkUmlnaHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLm1vdmVDdXJzb3JXb3JkUmlnaHQoKTtcXG5cXHQgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5uYXZpZ2F0ZVdvcmRMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yV29yZExlZnQoKTtcXG5cXHQgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24ocmVwbGFjZW1lbnQsIG9wdGlvbnMpIHtcXG5cXHQgICAgICAgIGlmIChvcHRpb25zKVxcblxcdCAgICAgICAgICAgIHRoaXMuJHNlYXJjaC5zZXQob3B0aW9ucyk7XFxuXFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLiRzZWFyY2guZmluZCh0aGlzLnNlc3Npb24pO1xcblxcdCAgICAgICAgdmFyIHJlcGxhY2VkID0gMDtcXG5cXHQgICAgICAgIGlmICghcmFuZ2UpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMuJHRyeVJlcGxhY2UocmFuZ2UsIHJlcGxhY2VtZW50KSkge1xcblxcdCAgICAgICAgICAgIHJlcGxhY2VkID0gMTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChyYW5nZSAhPT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNjcm9sbFNlbGVjdGlvbkludG9WaWV3KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnJlcGxhY2VBbGwgPSBmdW5jdGlvbihyZXBsYWNlbWVudCwgb3B0aW9ucykge1xcblxcdCAgICAgICAgaWYgKG9wdGlvbnMpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRzZWFyY2guc2V0KG9wdGlvbnMpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuJHNlYXJjaC5maW5kQWxsKHRoaXMuc2Vzc2lvbik7XFxuXFx0ICAgICAgICB2YXIgcmVwbGFjZWQgPSAwO1xcblxcdCAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxcblxcdCAgICAgICAgICAgIHJldHVybiByZXBsYWNlZDtcXG5cXG5cXHQgICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nICs9IDE7XFxuXFxuXFx0ICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgdGhpcy5zZWxlY3Rpb24ubW92ZVRvKDAsIDApO1xcblxcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcblxcdCAgICAgICAgICAgIGlmKHRoaXMuJHRyeVJlcGxhY2UocmFuZ2VzW2ldLCByZXBsYWNlbWVudCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmVwbGFjZWQrKztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb24pO1xcblxcdCAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgLT0gMTtcXG5cXG5cXHQgICAgICAgIHJldHVybiByZXBsYWNlZDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kdHJ5UmVwbGFjZSA9IGZ1bmN0aW9uKHJhbmdlLCByZXBsYWNlbWVudCkge1xcblxcdCAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICByZXBsYWNlbWVudCA9IHRoaXMuJHNlYXJjaC5yZXBsYWNlKGlucHV0LCByZXBsYWNlbWVudCk7XFxuXFx0ICAgICAgICBpZiAocmVwbGFjZW1lbnQgIT09IG51bGwpIHtcXG5cXHQgICAgICAgICAgICByYW5nZS5lbmQgPSB0aGlzLnNlc3Npb24ucmVwbGFjZShyYW5nZSwgcmVwbGFjZW1lbnQpO1xcblxcdCAgICAgICAgICAgIHJldHVybiByYW5nZTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TGFzdFNlYXJjaE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRzZWFyY2guZ2V0T3B0aW9ucygpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmZpbmQgPSBmdW5jdGlvbihuZWVkbGUsIG9wdGlvbnMsIGFuaW1hdGUpIHtcXG5cXHQgICAgICAgIGlmICghb3B0aW9ucylcXG5cXHQgICAgICAgICAgICBvcHRpb25zID0ge307XFxuXFxuXFx0ICAgICAgICBpZiAodHlwZW9mIG5lZWRsZSA9PSBcXFwic3RyaW5nXFxcIiB8fCBuZWVkbGUgaW5zdGFuY2VvZiBSZWdFeHApXFxuXFx0ICAgICAgICAgICAgb3B0aW9ucy5uZWVkbGUgPSBuZWVkbGU7XFxuXFx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmVlZGxlID09IFxcXCJvYmplY3RcXFwiKVxcblxcdCAgICAgICAgICAgIG9vcC5taXhpbihvcHRpb25zLCBuZWVkbGUpO1xcblxcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcXG5cXHQgICAgICAgIGlmIChvcHRpb25zLm5lZWRsZSA9PSBudWxsKSB7XFxuXFx0ICAgICAgICAgICAgbmVlZGxlID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSlcXG5cXHQgICAgICAgICAgICAgICAgfHwgdGhpcy4kc2VhcmNoLiRvcHRpb25zLm5lZWRsZTtcXG5cXHQgICAgICAgICAgICBpZiAoIW5lZWRsZSkge1xcblxcdCAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuc2Vzc2lvbi5nZXRXb3JkUmFuZ2UocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgICAgICBuZWVkbGUgPSB0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldCh7bmVlZGxlOiBuZWVkbGV9KTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMuJHNlYXJjaC5zZXQob3B0aW9ucyk7XFxuXFx0ICAgICAgICBpZiAoIW9wdGlvbnMuc3RhcnQpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kc2VhcmNoLnNldCh7c3RhcnQ6IHJhbmdlfSk7XFxuXFxuXFx0ICAgICAgICB2YXIgbmV3UmFuZ2UgPSB0aGlzLiRzZWFyY2guZmluZCh0aGlzLnNlc3Npb24pO1xcblxcdCAgICAgICAgaWYgKG9wdGlvbnMucHJldmVudFNjcm9sbClcXG5cXHQgICAgICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XFxuXFx0ICAgICAgICBpZiAobmV3UmFuZ2UpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnJldmVhbFJhbmdlKG5ld1JhbmdlLCBhbmltYXRlKTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAob3B0aW9ucy5iYWNrd2FyZHMpXFxuXFx0ICAgICAgICAgICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5lbmQ7XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgcmFuZ2UuZW5kID0gcmFuZ2Uuc3RhcnQ7XFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRSYW5nZShyYW5nZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZmluZE5leHQgPSBmdW5jdGlvbihvcHRpb25zLCBhbmltYXRlKSB7XFxuXFx0ICAgICAgICB0aGlzLmZpbmQoe3NraXBDdXJyZW50OiB0cnVlLCBiYWNrd2FyZHM6IGZhbHNlfSwgb3B0aW9ucywgYW5pbWF0ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZmluZFByZXZpb3VzID0gZnVuY3Rpb24ob3B0aW9ucywgYW5pbWF0ZSkge1xcblxcdCAgICAgICAgdGhpcy5maW5kKG9wdGlvbnMsIHtza2lwQ3VycmVudDogdHJ1ZSwgYmFja3dhcmRzOiB0cnVlfSwgYW5pbWF0ZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMucmV2ZWFsUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSwgYW5pbWF0ZSkge1xcblxcdCAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi51bmZvbGQocmFuZ2UpO1xcblxcdCAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgLT0gMTtcXG5cXG5cXHQgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnJlbmRlcmVyLnNjcm9sbFRvcDtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgMC41KTtcXG5cXHQgICAgICAgIGlmIChhbmltYXRlICE9PSBmYWxzZSlcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFuaW1hdGVTY3JvbGxpbmcoc2Nyb2xsVG9wKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy51bmRvID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZysrO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkudW5kbygpO1xcblxcdCAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmctLTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZWRvID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZysrO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkucmVkbygpO1xcblxcdCAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmctLTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiZGVzdHJveVxcXCIsIHRoaXMpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kZXN0cm95KCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3ID0gZnVuY3Rpb24oZW5hYmxlKSB7XFxuXFx0ICAgICAgICBpZiAoIWVuYWJsZSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgcmVjdDtcXG5cXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcXG5cXHQgICAgICAgIHZhciBzaG91bGRTY3JvbGwgPSBmYWxzZTtcXG5cXHQgICAgICAgIGlmICghdGhpcy4kc2Nyb2xsQW5jaG9yKVxcblxcdCAgICAgICAgICAgIHRoaXMuJHNjcm9sbEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcdCAgICAgICAgdmFyIHNjcm9sbEFuY2hvciA9IHRoaXMuJHNjcm9sbEFuY2hvcjtcXG5cXHQgICAgICAgIHNjcm9sbEFuY2hvci5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOmFic29sdXRlXFxcIjtcXG5cXHQgICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZShzY3JvbGxBbmNob3IsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xcblxcdCAgICAgICAgdmFyIG9uQ2hhbmdlU2VsZWN0aW9uID0gdGhpcy5vbihcXFwiY2hhbmdlU2VsZWN0aW9uXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gdHJ1ZTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgdmFyIG9uQmVmb3JlUmVuZGVyID0gdGhpcy5yZW5kZXJlci5vbihcXFwiYmVmb3JlUmVuZGVyXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbClcXG5cXHQgICAgICAgICAgICAgICAgcmVjdCA9IHNlbGYucmVuZGVyZXIuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICB2YXIgb25BZnRlclJlbmRlciA9IHRoaXMucmVuZGVyZXIub24oXFxcImFmdGVyUmVuZGVyXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiByZWN0ICYmIChzZWxmLmlzRm9jdXNlZCgpXFxuXFx0ICAgICAgICAgICAgICAgIHx8IHNlbGYuc2VhcmNoQm94ICYmIHNlbGYuc2VhcmNoQm94LmlzRm9jdXNlZCgpKVxcblxcdCAgICAgICAgICAgICkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBzZWxmLnJlbmRlcmVyO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgcG9zID0gcmVuZGVyZXIuJGN1cnNvckxheWVyLiRwaXhlbFBvcztcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHJlbmRlcmVyLmxheWVyQ29uZmlnO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdG9wID0gcG9zLnRvcCAtIGNvbmZpZy5vZmZzZXQ7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChwb3MudG9wID49IDAgJiYgdG9wICsgcmVjdC50b3AgPCAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSB0cnVlO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy50b3AgPCBjb25maWcuaGVpZ2h0ICYmXFxuXFx0ICAgICAgICAgICAgICAgICAgICBwb3MudG9wICsgcmVjdC50b3AgKyBjb25maWcubGluZUhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2Nyb2xsID0gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSBudWxsO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgIT0gbnVsbCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yLnN0eWxlLnRvcCA9IHRvcCArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvci5zdHlsZS5oZWlnaHQgPSBjb25maWcubGluZUhlaWdodCArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3Iuc2Nyb2xsSW50b1ZpZXcoc2hvdWxkU2Nyb2xsKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBzaG91bGRTY3JvbGwgPSByZWN0ID0gbnVsbDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3ID0gZnVuY3Rpb24oZW5hYmxlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGVuYWJsZSlcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNldEF1dG9TY3JvbGxFZGl0b3JJbnRvVmlldztcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVNlbGVjdGlvblxcXCIsIG9uQ2hhbmdlU2VsZWN0aW9uKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImFmdGVyUmVuZGVyXFxcIiwgb25BZnRlclJlbmRlcik7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJiZWZvcmVSZW5kZXJcXFwiLCBvbkJlZm9yZVJlbmRlcik7XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9O1xcblxcblxcblxcdCAgICB0aGlzLiRyZXNldEN1cnNvclN0eWxlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLiRjdXJzb3JTdHlsZSB8fCBcXFwiYWNlXFxcIjtcXG5cXHQgICAgICAgIHZhciBjdXJzb3JMYXllciA9IHRoaXMucmVuZGVyZXIuJGN1cnNvckxheWVyO1xcblxcdCAgICAgICAgaWYgKCFjdXJzb3JMYXllcilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBjdXJzb3JMYXllci5zZXRTbW9vdGhCbGlua2luZygvc21vb3RoLy50ZXN0KHN0eWxlKSk7XFxuXFx0ICAgICAgICBjdXJzb3JMYXllci5pc0JsaW5raW5nID0gIXRoaXMuJHJlYWRPbmx5ICYmIHN0eWxlICE9IFxcXCJ3aWRlXFxcIjtcXG5cXHQgICAgICAgIGRvbS5zZXRDc3NDbGFzcyhjdXJzb3JMYXllci5lbGVtZW50LCBcXFwiYWNlX3NsaW0tY3Vyc29yc1xcXCIsIC9zbGltLy50ZXN0KHN0eWxlKSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChFZGl0b3IucHJvdG90eXBlKTtcXG5cXG5cXG5cXG5cXHRjb25maWcuZGVmaW5lT3B0aW9ucyhFZGl0b3IucHJvdG90eXBlLCBcXFwiZWRpdG9yXFxcIiwge1xcblxcdCAgICBzZWxlY3Rpb25TdHlsZToge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbihzdHlsZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVNlbGVjdGlvblN0eWxlXFxcIiwge2RhdGE6IHN0eWxlfSk7XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiBcXFwibGluZVxcXCJcXG5cXHQgICAgfSxcXG5cXHQgICAgaGlnaGxpZ2h0QWN0aXZlTGluZToge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbigpIHt0aGlzLiR1cGRhdGVIaWdobGlnaHRBY3RpdmVMaW5lKCk7fSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxcblxcdCAgICB9LFxcblxcdCAgICBoaWdobGlnaHRTZWxlY3RlZFdvcmQ6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24oc2hvdWxkSGlnaGxpZ2h0KSB7dGhpcy4kb25TZWxlY3Rpb25DaGFuZ2UoKTt9LFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXFxuXFx0ICAgIH0sXFxuXFx0ICAgIHJlYWRPbmx5OiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHJlYWRPbmx5KSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kcmVzZXRDdXJzb3JTdHlsZSgpOyBcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IGZhbHNlXFxuXFx0ICAgIH0sXFxuXFx0ICAgIGN1cnNvclN0eWxlOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkgeyB0aGlzLiRyZXNldEN1cnNvclN0eWxlKCk7IH0sXFxuXFx0ICAgICAgICB2YWx1ZXM6IFtcXFwiYWNlXFxcIiwgXFxcInNsaW1cXFwiLCBcXFwic21vb3RoXFxcIiwgXFxcIndpZGVcXFwiXSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogXFxcImFjZVxcXCJcXG5cXHQgICAgfSxcXG5cXHQgICAgbWVyZ2VVbmRvRGVsdGFzOiB7XFxuXFx0ICAgICAgICB2YWx1ZXM6IFtmYWxzZSwgdHJ1ZSwgXFxcImFsd2F5c1xcXCJdLFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXFxuXFx0ICAgIH0sXFxuXFx0ICAgIGJlaGF2aW91cnNFbmFibGVkOiB7aW5pdGlhbFZhbHVlOiB0cnVlfSxcXG5cXHQgICAgd3JhcEJlaGF2aW91cnNFbmFibGVkOiB7aW5pdGlhbFZhbHVlOiB0cnVlfSxcXG5cXHQgICAgYXV0b1Njcm9sbEVkaXRvckludG9WaWV3OiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge3RoaXMuc2V0QXV0b1Njcm9sbEVkaXRvckludG9WaWV3KHZhbCl9XFxuXFx0ICAgIH0sXFxuXFxuXFx0ICAgIGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlOiBcXFwicmVuZGVyZXJcXFwiLFxcblxcdCAgICB2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZTogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgaGlnaGxpZ2h0R3V0dGVyTGluZTogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgYW5pbWF0ZWRTY3JvbGw6IFxcXCJyZW5kZXJlclxcXCIsXFxuXFx0ICAgIHNob3dJbnZpc2libGVzOiBcXFwicmVuZGVyZXJcXFwiLFxcblxcdCAgICBzaG93UHJpbnRNYXJnaW46IFxcXCJyZW5kZXJlclxcXCIsXFxuXFx0ICAgIHByaW50TWFyZ2luQ29sdW1uOiBcXFwicmVuZGVyZXJcXFwiLFxcblxcdCAgICBwcmludE1hcmdpbjogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgZmFkZUZvbGRXaWRnZXRzOiBcXFwicmVuZGVyZXJcXFwiLFxcblxcdCAgICBzaG93Rm9sZFdpZGdldHM6IFxcXCJyZW5kZXJlclxcXCIsXFxuXFx0ICAgIHNob3dMaW5lTnVtYmVyczogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgc2hvd0d1dHRlcjogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgZGlzcGxheUluZGVudEd1aWRlczogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgZm9udFNpemU6IFxcXCJyZW5kZXJlclxcXCIsXFxuXFx0ICAgIGZvbnRGYW1pbHk6IFxcXCJyZW5kZXJlclxcXCIsXFxuXFx0ICAgIG1heExpbmVzOiBcXFwicmVuZGVyZXJcXFwiLFxcblxcdCAgICBtaW5MaW5lczogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgc2Nyb2xsUGFzdEVuZDogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgZml4ZWRXaWR0aEd1dHRlcjogXFxcInJlbmRlcmVyXFxcIixcXG5cXHQgICAgdGhlbWU6IFxcXCJyZW5kZXJlclxcXCIsXFxuXFxuXFx0ICAgIHNjcm9sbFNwZWVkOiBcXFwiJG1vdXNlSGFuZGxlclxcXCIsXFxuXFx0ICAgIGRyYWdEZWxheTogXFxcIiRtb3VzZUhhbmRsZXJcXFwiLFxcblxcdCAgICBkcmFnRW5hYmxlZDogXFxcIiRtb3VzZUhhbmRsZXJcXFwiLFxcblxcdCAgICBmb2N1c1RpbW91dDogXFxcIiRtb3VzZUhhbmRsZXJcXFwiLFxcblxcdCAgICB0b29sdGlwRm9sbG93c01vdXNlOiBcXFwiJG1vdXNlSGFuZGxlclxcXCIsXFxuXFxuXFx0ICAgIGZpcnN0TGluZU51bWJlcjogXFxcInNlc3Npb25cXFwiLFxcblxcdCAgICBvdmVyd3JpdGU6IFxcXCJzZXNzaW9uXFxcIixcXG5cXHQgICAgbmV3TGluZU1vZGU6IFxcXCJzZXNzaW9uXFxcIixcXG5cXHQgICAgdXNlV29ya2VyOiBcXFwic2Vzc2lvblxcXCIsXFxuXFx0ICAgIHVzZVNvZnRUYWJzOiBcXFwic2Vzc2lvblxcXCIsXFxuXFx0ICAgIHRhYlNpemU6IFxcXCJzZXNzaW9uXFxcIixcXG5cXHQgICAgd3JhcDogXFxcInNlc3Npb25cXFwiLFxcblxcdCAgICBmb2xkU3R5bGU6IFxcXCJzZXNzaW9uXFxcIixcXG5cXHQgICAgbW9kZTogXFxcInNlc3Npb25cXFwiXFxuXFx0fSk7XFxuXFxuXFx0ZXhwb3J0cy5FZGl0b3IgPSBFZGl0b3I7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL3VuZG9tYW5hZ2VyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFx0dmFyIFVuZG9NYW5hZ2VyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMucmVzZXQoKTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXHQgICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xcblxcdCAgICAgICAgdmFyIGRlbHRhcyA9IG9wdGlvbnMuYXJnc1swXTtcXG5cXHQgICAgICAgIHRoaXMuJGRvYyAgPSBvcHRpb25zLmFyZ3NbMV07XFxuXFx0ICAgICAgICBpZiAob3B0aW9ucy5tZXJnZSAmJiB0aGlzLmhhc1VuZG8oKSl7XFxuXFx0ICAgICAgICAgICAgdGhpcy5kaXJ0eUNvdW50ZXItLTtcXG5cXHQgICAgICAgICAgICBkZWx0YXMgPSB0aGlzLiR1bmRvU3RhY2sucG9wKCkuY29uY2F0KGRlbHRhcyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLiR1bmRvU3RhY2sucHVzaChkZWx0YXMpO1xcblxcdCAgICAgICAgdGhpcy4kcmVkb1N0YWNrID0gW107XFxuXFxuXFx0ICAgICAgICBpZiAodGhpcy5kaXJ0eUNvdW50ZXIgPCAwKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5kaXJ0eUNvdW50ZXIgPSBOYU47XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmRpcnR5Q291bnRlcisrO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbihkb250U2VsZWN0KSB7XFxuXFx0ICAgICAgICB2YXIgZGVsdGFzID0gdGhpcy4kdW5kb1N0YWNrLnBvcCgpO1xcblxcdCAgICAgICAgdmFyIHVuZG9TZWxlY3Rpb25SYW5nZSA9IG51bGw7XFxuXFx0ICAgICAgICBpZiAoZGVsdGFzKSB7XFxuXFx0ICAgICAgICAgICAgdW5kb1NlbGVjdGlvblJhbmdlID1cXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kZG9jLnVuZG9DaGFuZ2VzKGRlbHRhcywgZG9udFNlbGVjdCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kcmVkb1N0YWNrLnB1c2goZGVsdGFzKTtcXG5cXHQgICAgICAgICAgICB0aGlzLmRpcnR5Q291bnRlci0tO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgcmV0dXJuIHVuZG9TZWxlY3Rpb25SYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZWRvID0gZnVuY3Rpb24oZG9udFNlbGVjdCkge1xcblxcdCAgICAgICAgdmFyIGRlbHRhcyA9IHRoaXMuJHJlZG9TdGFjay5wb3AoKTtcXG5cXHQgICAgICAgIHZhciByZWRvU2VsZWN0aW9uUmFuZ2UgPSBudWxsO1xcblxcdCAgICAgICAgaWYgKGRlbHRhcykge1xcblxcdCAgICAgICAgICAgIHJlZG9TZWxlY3Rpb25SYW5nZSA9XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGRvYy5yZWRvQ2hhbmdlcyhkZWx0YXMsIGRvbnRTZWxlY3QpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHVuZG9TdGFjay5wdXNoKGRlbHRhcyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5kaXJ0eUNvdW50ZXIrKztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiByZWRvU2VsZWN0aW9uUmFuZ2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJHVuZG9TdGFjayA9IFtdO1xcblxcdCAgICAgICAgdGhpcy4kcmVkb1N0YWNrID0gW107XFxuXFx0ICAgICAgICB0aGlzLmRpcnR5Q291bnRlciA9IDA7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaGFzVW5kbyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHVuZG9TdGFjay5sZW5ndGggPiAwO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmhhc1JlZG8gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiRyZWRvU3RhY2subGVuZ3RoID4gMDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5tYXJrQ2xlYW4gPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuZGlydHlDb3VudGVyID0gMDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5pc0NsZWFuID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eUNvdW50ZXIgPT09IDA7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChVbmRvTWFuYWdlci5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuVW5kb01hbmFnZXIgPSBVbmRvTWFuYWdlcjtcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGF5ZXIvZ3V0dGVyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCIsXFxcImFjZS9saWIvZXZlbnRfZW1pdHRlclxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXG5cXHR2YXIgR3V0dGVyID0gZnVuY3Rpb24ocGFyZW50RWwpIHtcXG5cXHQgICAgdGhpcy5lbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcdCAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXFxcImFjZV9sYXllciBhY2VfZ3V0dGVyLWxheWVyXFxcIjtcXG5cXHQgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcXG5cXHQgICAgdGhpcy5zZXRTaG93Rm9sZFdpZGdldHModGhpcy4kc2hvd0ZvbGRXaWRnZXRzKTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuZ3V0dGVyV2lkdGggPSAwO1xcblxcblxcdCAgICB0aGlzLiRhbm5vdGF0aW9ucyA9IFtdO1xcblxcdCAgICB0aGlzLiR1cGRhdGVBbm5vdGF0aW9ucyA9IHRoaXMuJHVwZGF0ZUFubm90YXRpb25zLmJpbmQodGhpcyk7XFxuXFxuXFx0ICAgIHRoaXMuJGNlbGxzID0gW107XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcXG5cXG5cXHQgICAgdGhpcy5zZXRTZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbilcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlXFxcIiwgdGhpcy4kdXBkYXRlQW5ub3RhdGlvbnMpO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcXG5cXHQgICAgICAgIGlmIChzZXNzaW9uKVxcblxcdCAgICAgICAgICAgIHNlc3Npb24ub24oXFxcImNoYW5nZVxcXCIsIHRoaXMuJHVwZGF0ZUFubm90YXRpb25zKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hZGRHdXR0ZXJEZWNvcmF0aW9uID0gZnVuY3Rpb24ocm93LCBjbGFzc05hbWUpe1xcblxcdCAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKVxcblxcdCAgICAgICAgICAgIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLndhcm4oXFxcImRlcHJlY2F0ZWQgdXNlIHNlc3Npb24uYWRkR3V0dGVyRGVjb3JhdGlvblxcXCIpO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLmFkZEd1dHRlckRlY29yYXRpb24ocm93LCBjbGFzc05hbWUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnJlbW92ZUd1dHRlckRlY29yYXRpb24gPSBmdW5jdGlvbihyb3csIGNsYXNzTmFtZSl7XFxuXFx0ICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpXFxuXFx0ICAgICAgICAgICAgY29uc29sZS53YXJuICYmIGNvbnNvbGUud2FybihcXFwiZGVwcmVjYXRlZCB1c2Ugc2Vzc2lvbi5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlR3V0dGVyRGVjb3JhdGlvbihyb3csIGNsYXNzTmFtZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm5vdGF0aW9ucykge1xcblxcdCAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMgPSBbXTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xcblxcdCAgICAgICAgICAgIHZhciByb3cgPSBhbm5vdGF0aW9uLnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgcm93SW5mbyA9IHRoaXMuJGFubm90YXRpb25zW3Jvd107XFxuXFx0ICAgICAgICAgICAgaWYgKCFyb3dJbmZvKVxcblxcdCAgICAgICAgICAgICAgICByb3dJbmZvID0gdGhpcy4kYW5ub3RhdGlvbnNbcm93XSA9IHt0ZXh0OiBbXX07XFxuXFx0ICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB2YXIgYW5ub1RleHQgPSBhbm5vdGF0aW9uLnRleHQ7XFxuXFx0ICAgICAgICAgICAgYW5ub1RleHQgPSBhbm5vVGV4dCA/IGxhbmcuZXNjYXBlSFRNTChhbm5vVGV4dCkgOiBhbm5vdGF0aW9uLmh0bWwgfHwgXFxcIlxcXCI7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHJvd0luZm8udGV4dC5pbmRleE9mKGFubm9UZXh0KSA9PT0gLTEpXFxuXFx0ICAgICAgICAgICAgICAgIHJvd0luZm8udGV4dC5wdXNoKGFubm9UZXh0KTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgdHlwZSA9IGFubm90YXRpb24udHlwZTtcXG5cXHQgICAgICAgICAgICBpZiAodHlwZSA9PSBcXFwiZXJyb3JcXFwiKVxcblxcdCAgICAgICAgICAgICAgICByb3dJbmZvLmNsYXNzTmFtZSA9IFxcXCIgYWNlX2Vycm9yXFxcIjtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IFxcXCJ3YXJuaW5nXFxcIiAmJiByb3dJbmZvLmNsYXNzTmFtZSAhPSBcXFwiIGFjZV9lcnJvclxcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHJvd0luZm8uY2xhc3NOYW1lID0gXFxcIiBhY2Vfd2FybmluZ1xcXCI7XFxuXFx0ICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBcXFwiaW5mb1xcXCIgJiYgKCFyb3dJbmZvLmNsYXNzTmFtZSkpXFxuXFx0ICAgICAgICAgICAgICAgIHJvd0luZm8uY2xhc3NOYW1lID0gXFxcIiBhY2VfaW5mb1xcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZUFubm90YXRpb25zID0gZnVuY3Rpb24gKGUpIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy4kYW5ub3RhdGlvbnMubGVuZ3RoKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBkZWx0YSA9IGUuZGF0YTtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IGRlbHRhLnJhbmdlO1xcblxcdCAgICAgICAgdmFyIGZpcnN0Um93ID0gcmFuZ2Uuc3RhcnQucm93O1xcblxcdCAgICAgICAgdmFyIGxlbiA9IHJhbmdlLmVuZC5yb3cgLSBmaXJzdFJvdztcXG5cXHQgICAgICAgIGlmIChsZW4gPT09IDApIHtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEuYWN0aW9uID09IFxcXCJyZW1vdmVUZXh0XFxcIiB8fCBkZWx0YS5hY3Rpb24gPT0gXFxcInJlbW92ZUxpbmVzXFxcIikge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGFubm90YXRpb25zLnNwbGljZShmaXJzdFJvdywgbGVuICsgMSwgbnVsbCk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xcblxcdCAgICAgICAgICAgIGFyZ3MudW5zaGlmdChmaXJzdFJvdywgMSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kYW5ub3RhdGlvbnMuc3BsaWNlLmFwcGx5KHRoaXMuJGFubm90YXRpb25zLCBhcmdzKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihjb25maWcpIHtcXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgdmFyIGZpcnN0Um93ID0gY29uZmlnLmZpcnN0Um93O1xcblxcdCAgICAgICAgdmFyIGxhc3RSb3cgPSBNYXRoLm1pbihjb25maWcubGFzdFJvdyArIGNvbmZpZy5ndXR0ZXJPZmZzZXQsICAvLyBuZWVkZWQgdG8gY29tcGVuc2F0ZSBmb3IgaG9yIHNjb2xsYmFyXFxuXFx0ICAgICAgICAgICAgc2Vzc2lvbi5nZXRMZW5ndGgoKSAtIDEpO1xcblxcdCAgICAgICAgdmFyIGZvbGQgPSBzZXNzaW9uLmdldE5leHRGb2xkTGluZShmaXJzdFJvdyk7XFxuXFx0ICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZCA/IGZvbGQuc3RhcnQucm93IDogSW5maW5pdHk7XFxuXFx0ICAgICAgICB2YXIgZm9sZFdpZGdldHMgPSB0aGlzLiRzaG93Rm9sZFdpZGdldHMgJiYgc2Vzc2lvbi5mb2xkV2lkZ2V0cztcXG5cXHQgICAgICAgIHZhciBicmVha3BvaW50cyA9IHNlc3Npb24uJGJyZWFrcG9pbnRzO1xcblxcdCAgICAgICAgdmFyIGRlY29yYXRpb25zID0gc2Vzc2lvbi4kZGVjb3JhdGlvbnM7XFxuXFx0ICAgICAgICB2YXIgZmlyc3RMaW5lTnVtYmVyID0gc2Vzc2lvbi4kZmlyc3RMaW5lTnVtYmVyO1xcblxcdCAgICAgICAgdmFyIGxhc3RMaW5lTnVtYmVyID0gMDtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIGd1dHRlclJlbmRlcmVyID0gc2Vzc2lvbi5ndXR0ZXJSZW5kZXJlciB8fCB0aGlzLiRyZW5kZXJlcjtcXG5cXG5cXHQgICAgICAgIHZhciBjZWxsID0gbnVsbDtcXG5cXHQgICAgICAgIHZhciBpbmRleCA9IC0xO1xcblxcdCAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xcblxcdCAgICAgICAgd2hpbGUgKHRydWUpIHtcXG5cXHQgICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyA9IGZvbGQuZW5kLnJvdyArIDE7XFxuXFx0ICAgICAgICAgICAgICAgIGZvbGQgPSBzZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3csIGZvbGQpO1xcblxcdCAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkID8gZm9sZC5zdGFydC5yb3cgOiBJbmZpbml0eTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3RSb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuJGNlbGxzLmxlbmd0aCA+IGluZGV4ICsgMSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY2VsbCA9IHRoaXMuJGNlbGxzLnBvcCgpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKGNlbGwuZWxlbWVudCk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIGNlbGwgPSB0aGlzLiRjZWxsc1srK2luZGV4XTtcXG5cXHQgICAgICAgICAgICBpZiAoIWNlbGwpIHtcXG5cXHQgICAgICAgICAgICAgICAgY2VsbCA9IHtlbGVtZW50OiBudWxsLCB0ZXh0Tm9kZTogbnVsbCwgZm9sZFdpZGdldDogbnVsbH07XFxuXFx0ICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgICAgICAgICAgICAgY2VsbC50ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcXG5cXHQgICAgICAgICAgICAgICAgY2VsbC5lbGVtZW50LmFwcGVuZENoaWxkKGNlbGwudGV4dE5vZGUpO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoY2VsbC5lbGVtZW50KTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kY2VsbHNbaW5kZXhdID0gY2VsbDtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFxcXCJhY2VfZ3V0dGVyLWNlbGwgXFxcIjtcXG5cXHQgICAgICAgICAgICBpZiAoYnJlYWtwb2ludHNbcm93XSlcXG5cXHQgICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IGJyZWFrcG9pbnRzW3Jvd107XFxuXFx0ICAgICAgICAgICAgaWYgKGRlY29yYXRpb25zW3Jvd10pXFxuXFx0ICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBkZWNvcmF0aW9uc1tyb3ddO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiRhbm5vdGF0aW9uc1tyb3ddKVxcblxcdCAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gdGhpcy4kYW5ub3RhdGlvbnNbcm93XS5jbGFzc05hbWU7XFxuXFx0ICAgICAgICAgICAgaWYgKGNlbGwuZWxlbWVudC5jbGFzc05hbWUgIT0gY2xhc3NOYW1lKVxcblxcdCAgICAgICAgICAgICAgICBjZWxsLmVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xcblxcblxcdCAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpICogY29uZmlnLmxpbmVIZWlnaHQgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gY2VsbC5lbGVtZW50LnN0eWxlLmhlaWdodClcXG5cXHQgICAgICAgICAgICAgICAgY2VsbC5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodDtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoZm9sZFdpZGdldHMpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGMgPSBmb2xkV2lkZ2V0c1tyb3ddO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoYyA9PSBudWxsKVxcblxcdCAgICAgICAgICAgICAgICAgICAgYyA9IGZvbGRXaWRnZXRzW3Jvd10gPSBzZXNzaW9uLmdldEZvbGRXaWRnZXQocm93KTtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGMpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKCFjZWxsLmZvbGRXaWRnZXQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNlbGwuZm9sZFdpZGdldCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJzcGFuXFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBjZWxsLmVsZW1lbnQuYXBwZW5kQ2hpbGQoY2VsbC5mb2xkV2lkZ2V0KTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXFxcImFjZV9mb2xkLXdpZGdldCBhY2VfXFxcIiArIGM7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjID09IFxcXCJzdGFydFxcXCIgJiYgcm93ID09IGZvbGRTdGFydCAmJiByb3cgPCBmb2xkLmVuZC5yb3cpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgKz0gXFxcIiBhY2VfY2xvc2VkXFxcIjtcXG5cXHQgICAgICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IFxcXCIgYWNlX29wZW5cXFwiO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoY2VsbC5mb2xkV2lkZ2V0LmNsYXNzTmFtZSAhPSBjbGFzc05hbWUpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjZWxsLmZvbGRXaWRnZXQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xcblxcblxcdCAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoY2VsbC5mb2xkV2lkZ2V0LnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjZWxsLmZvbGRXaWRnZXQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjZWxsLmZvbGRXaWRnZXQpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNlbGwuZWxlbWVudC5yZW1vdmVDaGlsZChjZWxsLmZvbGRXaWRnZXQpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgY2VsbC5mb2xkV2lkZ2V0ID0gbnVsbDtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB2YXIgdGV4dCA9IGxhc3RMaW5lTnVtYmVyID0gZ3V0dGVyUmVuZGVyZXJcXG5cXHQgICAgICAgICAgICAgICAgPyBndXR0ZXJSZW5kZXJlci5nZXRUZXh0KHNlc3Npb24sIHJvdylcXG5cXHQgICAgICAgICAgICAgICAgOiByb3cgKyBmaXJzdExpbmVOdW1iZXI7XFxuXFx0ICAgICAgICAgICAgaWYgKHRleHQgIT0gY2VsbC50ZXh0Tm9kZS5kYXRhKVxcblxcdCAgICAgICAgICAgICAgICBjZWxsLnRleHROb2RlLmRhdGEgPSB0ZXh0O1xcblxcblxcdCAgICAgICAgICAgIHJvdysrO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGNvbmZpZy5taW5IZWlnaHQgKyBcXFwicHhcXFwiO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMuJGZpeGVkV2lkdGggfHwgc2Vzc2lvbi4kdXNlV3JhcE1vZGUpXFxuXFx0ICAgICAgICAgICAgbGFzdExpbmVOdW1iZXIgPSBzZXNzaW9uLmdldExlbmd0aCgpICsgZmlyc3RMaW5lTnVtYmVyO1xcblxcblxcdCAgICAgICAgdmFyIGd1dHRlcldpZHRoID0gZ3V0dGVyUmVuZGVyZXIgXFxuXFx0ICAgICAgICAgICAgPyBndXR0ZXJSZW5kZXJlci5nZXRXaWR0aChzZXNzaW9uLCBsYXN0TGluZU51bWJlciwgY29uZmlnKVxcblxcdCAgICAgICAgICAgIDogbGFzdExpbmVOdW1iZXIudG9TdHJpbmcoKS5sZW5ndGggKiBjb25maWcuY2hhcmFjdGVyV2lkdGg7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZyB8fCB0aGlzLiRjb21wdXRlUGFkZGluZygpO1xcblxcdCAgICAgICAgZ3V0dGVyV2lkdGggKz0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcXG5cXHQgICAgICAgIGlmIChndXR0ZXJXaWR0aCAhPT0gdGhpcy5ndXR0ZXJXaWR0aCAmJiAhaXNOYU4oZ3V0dGVyV2lkdGgpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5ndXR0ZXJXaWR0aCA9IGd1dHRlcldpZHRoO1xcblxcdCAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IE1hdGguY2VpbCh0aGlzLmd1dHRlcldpZHRoKSArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgdGhpcy5fZW1pdChcXFwiY2hhbmdlR3V0dGVyV2lkdGhcXFwiLCBndXR0ZXJXaWR0aCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGZpeGVkV2lkdGggPSBmYWxzZTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJHNob3dMaW5lTnVtYmVycyA9IHRydWU7XFxuXFx0ICAgIHRoaXMuJHJlbmRlcmVyID0gXFxcIlxcXCI7XFxuXFx0ICAgIHRoaXMuc2V0U2hvd0xpbmVOdW1iZXJzID0gZnVuY3Rpb24oc2hvdykge1xcblxcdCAgICAgICAgdGhpcy4kcmVuZGVyZXIgPSAhc2hvdyAmJiB7XFxuXFx0ICAgICAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge3JldHVybiBcXFwiXFxcIn0sXFxuXFx0ICAgICAgICAgICAgZ2V0VGV4dDogZnVuY3Rpb24oKSB7cmV0dXJuIFxcXCJcXFwifVxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuZ2V0U2hvd0xpbmVOdW1iZXJzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kc2hvd0xpbmVOdW1iZXJzO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy4kc2hvd0ZvbGRXaWRnZXRzID0gdHJ1ZTtcXG5cXHQgICAgdGhpcy5zZXRTaG93Rm9sZFdpZGdldHMgPSBmdW5jdGlvbihzaG93KSB7XFxuXFx0ICAgICAgICBpZiAoc2hvdylcXG5cXHQgICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5lbGVtZW50LCBcXFwiYWNlX2ZvbGRpbmctZW5hYmxlZFxcXCIpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFxcXCJhY2VfZm9sZGluZy1lbmFibGVkXFxcIik7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRzaG93Rm9sZFdpZGdldHMgPSBzaG93O1xcblxcdCAgICAgICAgdGhpcy4kcGFkZGluZyA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmdldFNob3dGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHNob3dGb2xkV2lkZ2V0cztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kY29tcHV0ZVBhZGRpbmcgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHtsZWZ0OiAwLCByaWdodDogMH07XFxuXFx0ICAgICAgICB2YXIgc3R5bGUgPSBkb20uY29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZCk7XFxuXFx0ICAgICAgICB0aGlzLiRwYWRkaW5nID0ge307XFxuXFx0ICAgICAgICB0aGlzLiRwYWRkaW5nLmxlZnQgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCkgKyAxIHx8IDA7XFxuXFx0ICAgICAgICB0aGlzLiRwYWRkaW5nLnJpZ2h0ID0gcGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0KSB8fCAwO1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHBhZGRpbmc7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0UmVnaW9uID0gZnVuY3Rpb24ocG9pbnQpIHtcXG5cXHQgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZyB8fCB0aGlzLiRjb21wdXRlUGFkZGluZygpO1xcblxcdCAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0ICAgICAgICBpZiAocG9pbnQueCA8IHBhZGRpbmcubGVmdCArIHJlY3QubGVmdClcXG5cXHQgICAgICAgICAgICByZXR1cm4gXFxcIm1hcmtlcnNcXFwiO1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHNob3dGb2xkV2lkZ2V0cyAmJiBwb2ludC54ID4gcmVjdC5yaWdodCAtIHBhZGRpbmcucmlnaHQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIFxcXCJmb2xkV2lkZ2V0c1xcXCI7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChHdXR0ZXIucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLkd1dHRlciA9IEd1dHRlcjtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGF5ZXIvbWFya2VyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3JhbmdlXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgUmFuZ2UgPSBhY2VxdWlyZShcXFwiLi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXHR2YXIgZG9tID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9kb21cXFwiKTtcXG5cXG5cXHR2YXIgTWFya2VyID0gZnVuY3Rpb24ocGFyZW50RWwpIHtcXG5cXHQgICAgdGhpcy5lbGVtZW50ID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcdCAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gXFxcImFjZV9sYXllciBhY2VfbWFya2VyLWxheWVyXFxcIjtcXG5cXHQgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXG5cXHQgICAgdGhpcy4kcGFkZGluZyA9IDA7XFxuXFxuXFx0ICAgIHRoaXMuc2V0UGFkZGluZyA9IGZ1bmN0aW9uKHBhZGRpbmcpIHtcXG5cXHQgICAgICAgIHRoaXMuJHBhZGRpbmcgPSBwYWRkaW5nO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5zZXRNYXJrZXJzID0gZnVuY3Rpb24obWFya2Vycykge1xcblxcdCAgICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihjb25maWcpIHtcXG5cXHQgICAgICAgIHZhciBjb25maWcgPSBjb25maWcgfHwgdGhpcy5jb25maWc7XFxuXFx0ICAgICAgICBpZiAoIWNvbmZpZylcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcXG5cXG5cXG5cXHQgICAgICAgIHZhciBodG1sID0gW107XFxuXFx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5tYXJrZXJzKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMubWFya2Vyc1trZXldO1xcblxcblxcdCAgICAgICAgICAgIGlmICghbWFya2VyLnJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUoaHRtbCwgdGhpcywgdGhpcy5zZXNzaW9uLCBjb25maWcpO1xcblxcdCAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gbWFya2VyLnJhbmdlLmNsaXBSb3dzKGNvbmZpZy5maXJzdFJvdywgY29uZmlnLmxhc3RSb3cpO1xcblxcdCAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIGNvbnRpbnVlO1xcblxcblxcdCAgICAgICAgICAgIHJhbmdlID0gcmFuZ2UudG9TY3JlZW5SYW5nZSh0aGlzLnNlc3Npb24pO1xcblxcdCAgICAgICAgICAgIGlmIChtYXJrZXIucmVuZGVyZXIpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuJGdldFRvcChyYW5nZS5zdGFydC5yb3csIGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy4kcGFkZGluZyArIHJhbmdlLnN0YXJ0LmNvbHVtbiAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcXG5cXHQgICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcmVyKGh0bWwsIHJhbmdlLCBsZWZ0LCB0b3AsIGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXJrZXIudHlwZSA9PSBcXFwiZnVsbExpbmVcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Z1bGxMaW5lTWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenosIGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXJrZXIudHlwZSA9PSBcXFwic2NyZWVuTGluZVxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5kcmF3U2NyZWVuTGluZU1hcmtlcihodG1sLCByYW5nZSwgbWFya2VyLmNsYXp6LCBjb25maWcpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuaXNNdWx0aUxpbmUoKSkge1xcblxcdCAgICAgICAgICAgICAgICBpZiAobWFya2VyLnR5cGUgPT0gXFxcInRleHRcXFwiKVxcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3VGV4dE1hcmtlcihodG1sLCByYW5nZSwgbWFya2VyLmNsYXp6LCBjb25maWcpO1xcblxcdCAgICAgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdNdWx0aUxpbmVNYXJrZXIoaHRtbCwgcmFuZ2UsIG1hcmtlci5jbGF6eiwgY29uZmlnKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaW5nbGVMaW5lTWFya2VyKGh0bWwsIHJhbmdlLCBtYXJrZXIuY2xhenogKyBcXFwiIGFjZV9zdGFydFxcXCIsIGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGh0bWwuam9pbihcXFwiXFxcIik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGdldFRvcCA9IGZ1bmN0aW9uKHJvdywgbGF5ZXJDb25maWcpIHtcXG5cXHQgICAgICAgIHJldHVybiAocm93IC0gbGF5ZXJDb25maWcuZmlyc3RSb3dTY3JlZW4pICogbGF5ZXJDb25maWcubGluZUhlaWdodDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5kcmF3VGV4dE1hcmtlciA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgbGF5ZXJDb25maWcsIGV4dHJhU3R5bGUpIHtcXG5cXHQgICAgICAgIHZhciByb3cgPSByYW5nZS5zdGFydC5yb3c7XFxuXFxuXFx0ICAgICAgICB2YXIgbGluZVJhbmdlID0gbmV3IFJhbmdlKFxcblxcdCAgICAgICAgICAgIHJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uLFxcblxcdCAgICAgICAgICAgIHJvdywgdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxhc3RSb3dDb2x1bW4ocm93KVxcblxcdCAgICAgICAgKTtcXG5cXHQgICAgICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIoc3RyaW5nQnVpbGRlciwgbGluZVJhbmdlLCBjbGF6eiArIFxcXCIgYWNlX3N0YXJ0XFxcIiwgbGF5ZXJDb25maWcsIDEsIGV4dHJhU3R5bGUpO1xcblxcdCAgICAgICAgcm93ID0gcmFuZ2UuZW5kLnJvdztcXG5cXHQgICAgICAgIGxpbmVSYW5nZSA9IG5ldyBSYW5nZShyb3csIDAsIHJvdywgcmFuZ2UuZW5kLmNvbHVtbik7XFxuXFx0ICAgICAgICB0aGlzLmRyYXdTaW5nbGVMaW5lTWFya2VyKHN0cmluZ0J1aWxkZXIsIGxpbmVSYW5nZSwgY2xhenosIGxheWVyQ29uZmlnLCAwLCBleHRyYVN0eWxlKTtcXG5cXG5cXHQgICAgICAgIGZvciAocm93ID0gcmFuZ2Uuc3RhcnQucm93ICsgMTsgcm93IDwgcmFuZ2UuZW5kLnJvdzsgcm93KyspIHtcXG5cXHQgICAgICAgICAgICBsaW5lUmFuZ2Uuc3RhcnQucm93ID0gcm93O1xcblxcdCAgICAgICAgICAgIGxpbmVSYW5nZS5lbmQucm93ID0gcm93O1xcblxcdCAgICAgICAgICAgIGxpbmVSYW5nZS5lbmQuY29sdW1uID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxhc3RSb3dDb2x1bW4ocm93KTtcXG5cXHQgICAgICAgICAgICB0aGlzLmRyYXdTaW5nbGVMaW5lTWFya2VyKHN0cmluZ0J1aWxkZXIsIGxpbmVSYW5nZSwgY2xhenosIGxheWVyQ29uZmlnLCAxLCBleHRyYVN0eWxlKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5kcmF3TXVsdGlMaW5lTWFya2VyID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgcmFuZ2UsIGNsYXp6LCBjb25maWcsIGV4dHJhU3R5bGUpIHtcXG5cXHQgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy4kcGFkZGluZztcXG5cXHQgICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcXG5cXHQgICAgICAgIHZhciB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93LCBjb25maWcpO1xcblxcdCAgICAgICAgdmFyIGxlZnQgPSBwYWRkaW5nICsgcmFuZ2Uuc3RhcnQuY29sdW1uICogY29uZmlnLmNoYXJhY3RlcldpZHRoO1xcblxcdCAgICAgICAgZXh0cmFTdHlsZSA9IGV4dHJhU3R5bGUgfHwgXFxcIlxcXCI7XFxuXFxuXFx0ICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXFxuXFx0ICAgICAgICAgICAgXFxcIjxkaXYgY2xhc3M9J1xcXCIsIGNsYXp6LCBcXFwiIGFjZV9zdGFydCcgc3R5bGU9J1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcImhlaWdodDpcXFwiLCBoZWlnaHQsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJyaWdodDowO1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcInRvcDpcXFwiLCB0b3AsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJsZWZ0OlxcXCIsIGxlZnQsIFxcXCJweDtcXFwiLCBleHRyYVN0eWxlLCBcXFwiJz48L2Rpdj5cXFwiXFxuXFx0ICAgICAgICApO1xcblxcdCAgICAgICAgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLmVuZC5yb3csIGNvbmZpZyk7XFxuXFx0ICAgICAgICB2YXIgd2lkdGggPSByYW5nZS5lbmQuY29sdW1uICogY29uZmlnLmNoYXJhY3RlcldpZHRoO1xcblxcblxcdCAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxcblxcdCAgICAgICAgICAgIFxcXCI8ZGl2IGNsYXNzPSdcXFwiLCBjbGF6eiwgXFxcIicgc3R5bGU9J1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcImhlaWdodDpcXFwiLCBoZWlnaHQsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJ3aWR0aDpcXFwiLCB3aWR0aCwgXFxcInB4O1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcInRvcDpcXFwiLCB0b3AsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJsZWZ0OlxcXCIsIHBhZGRpbmcsIFxcXCJweDtcXFwiLCBleHRyYVN0eWxlLCBcXFwiJz48L2Rpdj5cXFwiXFxuXFx0ICAgICAgICApO1xcblxcdCAgICAgICAgaGVpZ2h0ID0gKHJhbmdlLmVuZC5yb3cgLSByYW5nZS5zdGFydC5yb3cgLSAxKSAqIGNvbmZpZy5saW5lSGVpZ2h0O1xcblxcdCAgICAgICAgaWYgKGhlaWdodCA8IDApXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdyArIDEsIGNvbmZpZyk7XFxuXFxuXFx0ICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXFxuXFx0ICAgICAgICAgICAgXFxcIjxkaXYgY2xhc3M9J1xcXCIsIGNsYXp6LCBcXFwiJyBzdHlsZT0nXFxcIixcXG5cXHQgICAgICAgICAgICBcXFwiaGVpZ2h0OlxcXCIsIGhlaWdodCwgXFxcInB4O1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcInJpZ2h0OjA7XFxcIixcXG5cXHQgICAgICAgICAgICBcXFwidG9wOlxcXCIsIHRvcCwgXFxcInB4O1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcImxlZnQ6XFxcIiwgcGFkZGluZywgXFxcInB4O1xcXCIsIGV4dHJhU3R5bGUsIFxcXCInPjwvZGl2PlxcXCJcXG5cXHQgICAgICAgICk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZHJhd1NpbmdsZUxpbmVNYXJrZXIgPSBmdW5jdGlvbihzdHJpbmdCdWlsZGVyLCByYW5nZSwgY2xhenosIGNvbmZpZywgZXh0cmFMZW5ndGgsIGV4dHJhU3R5bGUpIHtcXG5cXHQgICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcXG5cXHQgICAgICAgIHZhciB3aWR0aCA9IChyYW5nZS5lbmQuY29sdW1uICsgKGV4dHJhTGVuZ3RoIHx8IDApIC0gcmFuZ2Uuc3RhcnQuY29sdW1uKSAqIGNvbmZpZy5jaGFyYWN0ZXJXaWR0aDtcXG5cXG5cXHQgICAgICAgIHZhciB0b3AgPSB0aGlzLiRnZXRUb3AocmFuZ2Uuc3RhcnQucm93LCBjb25maWcpO1xcblxcdCAgICAgICAgdmFyIGxlZnQgPSB0aGlzLiRwYWRkaW5nICsgcmFuZ2Uuc3RhcnQuY29sdW1uICogY29uZmlnLmNoYXJhY3RlcldpZHRoO1xcblxcblxcdCAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxcblxcdCAgICAgICAgICAgIFxcXCI8ZGl2IGNsYXNzPSdcXFwiLCBjbGF6eiwgXFxcIicgc3R5bGU9J1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcImhlaWdodDpcXFwiLCBoZWlnaHQsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJ3aWR0aDpcXFwiLCB3aWR0aCwgXFxcInB4O1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcInRvcDpcXFwiLCB0b3AsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJsZWZ0OlxcXCIsIGxlZnQsIFxcXCJweDtcXFwiLCBleHRyYVN0eWxlIHx8IFxcXCJcXFwiLCBcXFwiJz48L2Rpdj5cXFwiXFxuXFx0ICAgICAgICApO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmRyYXdGdWxsTGluZU1hcmtlciA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYVN0eWxlKSB7XFxuXFx0ICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcXG5cXHQgICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcXG5cXHQgICAgICAgIGlmIChyYW5nZS5zdGFydC5yb3cgIT0gcmFuZ2UuZW5kLnJvdylcXG5cXHQgICAgICAgICAgICBoZWlnaHQgKz0gdGhpcy4kZ2V0VG9wKHJhbmdlLmVuZC5yb3csIGNvbmZpZykgLSB0b3A7XFxuXFxuXFx0ICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXFxuXFx0ICAgICAgICAgICAgXFxcIjxkaXYgY2xhc3M9J1xcXCIsIGNsYXp6LCBcXFwiJyBzdHlsZT0nXFxcIixcXG5cXHQgICAgICAgICAgICBcXFwiaGVpZ2h0OlxcXCIsIGhlaWdodCwgXFxcInB4O1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcInRvcDpcXFwiLCB0b3AsIFxcXCJweDtcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJsZWZ0OjA7cmlnaHQ6MDtcXFwiLCBleHRyYVN0eWxlIHx8IFxcXCJcXFwiLCBcXFwiJz48L2Rpdj5cXFwiXFxuXFx0ICAgICAgICApO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5kcmF3U2NyZWVuTGluZU1hcmtlciA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHJhbmdlLCBjbGF6eiwgY29uZmlnLCBleHRyYVN0eWxlKSB7XFxuXFx0ICAgICAgICB2YXIgdG9wID0gdGhpcy4kZ2V0VG9wKHJhbmdlLnN0YXJ0LnJvdywgY29uZmlnKTtcXG5cXHQgICAgICAgIHZhciBoZWlnaHQgPSBjb25maWcubGluZUhlaWdodDtcXG5cXG5cXHQgICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChcXG5cXHQgICAgICAgICAgICBcXFwiPGRpdiBjbGFzcz0nXFxcIiwgY2xhenosIFxcXCInIHN0eWxlPSdcXFwiLFxcblxcdCAgICAgICAgICAgIFxcXCJoZWlnaHQ6XFxcIiwgaGVpZ2h0LCBcXFwicHg7XFxcIixcXG5cXHQgICAgICAgICAgICBcXFwidG9wOlxcXCIsIHRvcCwgXFxcInB4O1xcXCIsXFxuXFx0ICAgICAgICAgICAgXFxcImxlZnQ6MDtyaWdodDowO1xcXCIsIGV4dHJhU3R5bGUgfHwgXFxcIlxcXCIsIFxcXCInPjwvZGl2PlxcXCJcXG5cXHQgICAgICAgICk7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChNYXJrZXIucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLk1hcmtlciA9IE1hcmtlcjtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbGF5ZXIvdGV4dFxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvbGliL2xhbmdcXFwiLFxcXCJhY2UvbGliL3VzZXJhZ2VudFxcXCIsXFxcImFjZS9saWIvZXZlbnRfZW1pdHRlclxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvdXNlcmFnZW50XFxcIik7XFxuXFx0dmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXG5cXHR2YXIgVGV4dCA9IGZ1bmN0aW9uKHBhcmVudEVsKSB7XFxuXFx0ICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFxcXCJhY2VfbGF5ZXIgYWNlX3RleHQtbGF5ZXJcXFwiO1xcblxcdCAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xcblxcdCAgICB0aGlzLiR1cGRhdGVFb2xDaGFyID0gdGhpcy4kdXBkYXRlRW9sQ2hhci5iaW5kKHRoaXMpO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XFxuXFxuXFx0ICAgIHRoaXMuRU9GX0NIQVIgPSBcXFwiXFxcXHhCNlxcXCI7XFxuXFx0ICAgIHRoaXMuRU9MX0NIQVJfTEYgPSBcXFwiXFxcXHhBQ1xcXCI7XFxuXFx0ICAgIHRoaXMuRU9MX0NIQVJfQ1JMRiA9IFxcXCJcXFxceGE0XFxcIjtcXG5cXHQgICAgdGhpcy5FT0xfQ0hBUiA9IHRoaXMuRU9MX0NIQVJfTEY7XFxuXFx0ICAgIHRoaXMuVEFCX0NIQVIgPSBcXFwiXFxcXHUyMTkyXFxcIjsgLy9cXFwiXFxcXHUyMUU1XFxcIjtcXG5cXHQgICAgdGhpcy5TUEFDRV9DSEFSID0gXFxcIlxcXFx4QjdcXFwiO1xcblxcdCAgICB0aGlzLiRwYWRkaW5nID0gMDtcXG5cXG5cXHQgICAgdGhpcy4kdXBkYXRlRW9sQ2hhciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIEVPTF9DSEFSID0gdGhpcy5zZXNzaW9uLmRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkgPT0gXFxcIlxcXFxuXFxcIlxcblxcdCAgICAgICAgICAgPyB0aGlzLkVPTF9DSEFSX0xGXFxuXFx0ICAgICAgICAgICA6IHRoaXMuRU9MX0NIQVJfQ1JMRjtcXG5cXHQgICAgICAgIGlmICh0aGlzLkVPTF9DSEFSICE9IEVPTF9DSEFSKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5FT0xfQ0hBUiA9IEVPTF9DSEFSO1xcblxcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHRoaXMuc2V0UGFkZGluZyA9IGZ1bmN0aW9uKHBhZGRpbmcpIHtcXG5cXHQgICAgICAgIHRoaXMuJHBhZGRpbmcgPSBwYWRkaW5nO1xcblxcdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcXFwiMCBcXFwiICsgcGFkZGluZyArIFxcXCJweFxcXCI7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0TGluZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGZvbnRNZXRyaWNzLiRjaGFyYWN0ZXJTaXplLmhlaWdodCB8fCAwO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldENoYXJhY3RlcldpZHRoID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kZm9udE1ldHJpY3MuJGNoYXJhY3RlclNpemUud2lkdGggfHwgMDtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJHNldEZvbnRNZXRyaWNzID0gZnVuY3Rpb24obWVhc3VyZSkge1xcblxcdCAgICAgICAgdGhpcy4kZm9udE1ldHJpY3MgPSBtZWFzdXJlO1xcblxcdCAgICAgICAgdGhpcy4kZm9udE1ldHJpY3Mub24oXFxcImNoYW5nZUNoYXJhY3RlclNpemVcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VDaGFyYWN0ZXJTaXplXFxcIiwgZSk7XFxuXFx0ICAgICAgICB9LmJpbmQodGhpcykpO1xcblxcdCAgICAgICAgdGhpcy4kcG9sbFNpemVDaGFuZ2VzKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgdGhpcy5jaGVja0ZvclNpemVDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRmb250TWV0cmljcy5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuJHBvbGxTaXplQ2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyID0gdGhpcy4kZm9udE1ldHJpY3MuJHBvbGxTaXplQ2hhbmdlcygpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uKSB7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xcblxcdCAgICAgICAgaWYgKHNlc3Npb24pXFxuXFx0ICAgICAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNob3dJbnZpc2libGVzID0gZmFsc2U7XFxuXFx0ICAgIHRoaXMuc2V0U2hvd0ludmlzaWJsZXMgPSBmdW5jdGlvbihzaG93SW52aXNpYmxlcykge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMgPT0gc2hvd0ludmlzaWJsZXMpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcblxcblxcdCAgICAgICAgdGhpcy5zaG93SW52aXNpYmxlcyA9IHNob3dJbnZpc2libGVzO1xcblxcdCAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xcblxcdCAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZGlzcGxheUluZGVudEd1aWRlcyA9IHRydWU7XFxuXFx0ICAgIHRoaXMuc2V0RGlzcGxheUluZGVudEd1aWRlcyA9IGZ1bmN0aW9uKGRpc3BsYXkpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMgPT0gZGlzcGxheSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFxuXFx0ICAgICAgICB0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMgPSBkaXNwbGF5O1xcblxcdCAgICAgICAgdGhpcy4kY29tcHV0ZVRhYlN0cmluZygpO1xcblxcdCAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHRhYlN0cmluZ3MgPSBbXTtcXG5cXHQgICAgdGhpcy5vbkNoYW5nZVRhYlNpemUgPVxcblxcdCAgICB0aGlzLiRjb21wdXRlVGFiU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgdGFiU2l6ZSA9IHRoaXMuc2Vzc2lvbi5nZXRUYWJTaXplKCk7XFxuXFx0ICAgICAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplO1xcblxcdCAgICAgICAgdmFyIHRhYlN0ciA9IHRoaXMuJHRhYlN0cmluZ3MgPSBbMF07XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRhYlNpemUgKyAxOyBpKyspIHtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5zaG93SW52aXNpYmxlcykge1xcblxcdCAgICAgICAgICAgICAgICB0YWJTdHIucHVzaChcXFwiPHNwYW4gY2xhc3M9J2FjZV9pbnZpc2libGUgYWNlX2ludmlzaWJsZV90YWInPlxcXCJcXG5cXHQgICAgICAgICAgICAgICAgICAgICsgdGhpcy5UQUJfQ0hBUlxcblxcdCAgICAgICAgICAgICAgICAgICAgKyBsYW5nLnN0cmluZ1JlcGVhdChcXFwiXFxcXHhhMFxcXCIsIGkgLSAxKVxcblxcdCAgICAgICAgICAgICAgICAgICAgKyBcXFwiPC9zcGFuPlxcXCIpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRhYlN0ci5wdXNoKGxhbmcuc3RyaW5nUmVwZWF0KFxcXCJcXFxceGEwXFxcIiwgaSkpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRpbmRlbnRHdWlkZVJlID0gIC9cXFxcc1xcXFxTfCBcXFxcdHxcXFxcdCB8XFxcXHMkLztcXG5cXHQgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXFxcImFjZV9pbmRlbnQtZ3VpZGVcXFwiO1xcblxcdCAgICAgICAgICAgIHZhciBzcGFjZUNsYXNzID0gXFxcIlxcXCI7XFxuXFx0ICAgICAgICAgICAgdmFyIHRhYkNsYXNzID0gXFxcIlxcXCI7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0ludmlzaWJsZXMpIHtcXG5cXHQgICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IFxcXCIgYWNlX2ludmlzaWJsZVxcXCI7XFxuXFx0ICAgICAgICAgICAgICAgIHNwYWNlQ2xhc3MgPSBcXFwiIGFjZV9pbnZpc2libGVfc3BhY2VcXFwiO1xcblxcdCAgICAgICAgICAgICAgICB0YWJDbGFzcyA9IFxcXCIgYWNlX2ludmlzaWJsZV90YWJcXFwiO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3BhY2VDb250ZW50ID0gbGFuZy5zdHJpbmdSZXBlYXQodGhpcy5TUEFDRV9DSEFSLCB0aGlzLnRhYlNpemUpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdGFiQ29udGVudCA9IHRoaXMuVEFCX0NIQVIgKyBsYW5nLnN0cmluZ1JlcGVhdChcXFwiXFxcXHhhMFxcXCIsIHRoaXMudGFiU2l6ZSAtIDEpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZXtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHNwYWNlQ29udGVudCA9IGxhbmcuc3RyaW5nUmVwZWF0KFxcXCJcXFxceGEwXFxcIiwgdGhpcy50YWJTaXplKTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRhYkNvbnRlbnQgPSBzcGFjZUNvbnRlbnQ7XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIHRoaXMuJHRhYlN0cmluZ3NbXFxcIiBcXFwiXSA9IFxcXCI8c3BhbiBjbGFzcz0nXFxcIiArIGNsYXNzTmFtZSArIHNwYWNlQ2xhc3MgKyBcXFwiJz5cXFwiICsgc3BhY2VDb250ZW50ICsgXFxcIjwvc3Bhbj5cXFwiO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHRhYlN0cmluZ3NbXFxcIlxcXFx0XFxcIl0gPSBcXFwiPHNwYW4gY2xhc3M9J1xcXCIgKyBjbGFzc05hbWUgKyB0YWJDbGFzcyArIFxcXCInPlxcXCIgKyB0YWJDb250ZW50ICsgXFxcIjwvc3Bhbj5cXFwiO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnVwZGF0ZUxpbmVzID0gZnVuY3Rpb24oY29uZmlnLCBmaXJzdFJvdywgbGFzdFJvdykge1xcblxcdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxhc3RSb3cgIT0gY29uZmlnLmxhc3RSb3cgfHxcXG5cXHQgICAgICAgICAgICB0aGlzLmNvbmZpZy5maXJzdFJvdyAhPSBjb25maWcuZmlyc3RSb3cpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNjcm9sbExpbmVzKGNvbmZpZyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcXG5cXG5cXHQgICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWF4KGZpcnN0Um93LCBjb25maWcuZmlyc3RSb3cpO1xcblxcdCAgICAgICAgdmFyIGxhc3QgPSBNYXRoLm1pbihsYXN0Um93LCBjb25maWcubGFzdFJvdyk7XFxuXFxuXFx0ICAgICAgICB2YXIgbGluZUVsZW1lbnRzID0gdGhpcy5lbGVtZW50LmNoaWxkTm9kZXM7XFxuXFx0ICAgICAgICB2YXIgbGluZUVsZW1lbnRzSWR4ID0gMDtcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIHJvdyA9IGNvbmZpZy5maXJzdFJvdzsgcm93IDwgZmlyc3Q7IHJvdysrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldEZvbGRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICAgICAgaWYgKGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChmb2xkTGluZS5jb250YWluc1JvdyhmaXJzdCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZm9sZExpbmUuc3RhcnQucm93O1xcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93O1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGxpbmVFbGVtZW50c0lkeCArKztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciByb3cgPSBmaXJzdDtcXG5cXHQgICAgICAgIHZhciBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93KTtcXG5cXHQgICAgICAgIHZhciBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6IEluZmluaXR5O1xcblxcblxcdCAgICAgICAgd2hpbGUgKHRydWUpIHtcXG5cXHQgICAgICAgICAgICBpZiAocm93ID4gZm9sZFN0YXJ0KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvdyA9IGZvbGRMaW5lLmVuZC5yb3crMTtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdywgZm9sZExpbmUpO1xcblxcdCAgICAgICAgICAgICAgICBmb2xkU3RhcnQgPSBmb2xkTGluZSA/IGZvbGRMaW5lLnN0YXJ0LnJvdyA6SW5maW5pdHk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmIChyb3cgPiBsYXN0KVxcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXG5cXHQgICAgICAgICAgICB2YXIgbGluZUVsZW1lbnQgPSBsaW5lRWxlbWVudHNbbGluZUVsZW1lbnRzSWR4KytdO1xcblxcdCAgICAgICAgICAgIGlmIChsaW5lRWxlbWVudCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IFtdO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRyZW5kZXJMaW5lKFxcblxcdCAgICAgICAgICAgICAgICAgICAgaHRtbCwgcm93LCAhdGhpcy4kdXNlTGluZUdyb3VwcygpLCByb3cgPT0gZm9sZFN0YXJ0ID8gZm9sZExpbmUgOiBmYWxzZVxcblxcdCAgICAgICAgICAgICAgICApO1xcblxcdCAgICAgICAgICAgICAgICBsaW5lRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBjb25maWcubGluZUhlaWdodCAqIHRoaXMuc2Vzc2lvbi5nZXRSb3dMZW5ndGgocm93KSArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LmlubmVySFRNTCA9IGh0bWwuam9pbihcXFwiXFxcIik7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJvdysrO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNjcm9sbExpbmVzID0gZnVuY3Rpb24oY29uZmlnKSB7XFxuXFx0ICAgICAgICB2YXIgb2xkQ29uZmlnID0gdGhpcy5jb25maWc7XFxuXFx0ICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcXG5cXG5cXHQgICAgICAgIGlmICghb2xkQ29uZmlnIHx8IG9sZENvbmZpZy5sYXN0Um93IDwgY29uZmlnLmZpcnN0Um93KVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xcblxcblxcdCAgICAgICAgaWYgKGNvbmZpZy5sYXN0Um93IDwgb2xkQ29uZmlnLmZpcnN0Um93KVxcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShjb25maWcpO1xcblxcblxcdCAgICAgICAgdmFyIGVsID0gdGhpcy5lbGVtZW50O1xcblxcdCAgICAgICAgaWYgKG9sZENvbmZpZy5maXJzdFJvdyA8IGNvbmZpZy5maXJzdFJvdylcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciByb3c9dGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KG9sZENvbmZpZy5maXJzdFJvdywgY29uZmlnLmZpcnN0Um93IC0gMSk7IHJvdz4wOyByb3ctLSlcXG5cXHQgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XFxuXFxuXFx0ICAgICAgICBpZiAob2xkQ29uZmlnLmxhc3RSb3cgPiBjb25maWcubGFzdFJvdylcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciByb3c9dGhpcy5zZXNzaW9uLmdldEZvbGRlZFJvd0NvdW50KGNvbmZpZy5sYXN0Um93ICsgMSwgb2xkQ29uZmlnLmxhc3RSb3cpOyByb3c+MDsgcm93LS0pXFxuXFx0ICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmxhc3RDaGlsZCk7XFxuXFxuXFx0ICAgICAgICBpZiAoY29uZmlnLmZpcnN0Um93IDwgb2xkQ29uZmlnLmZpcnN0Um93KSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy4kcmVuZGVyTGluZXNGcmFnbWVudChjb25maWcsIGNvbmZpZy5maXJzdFJvdywgb2xkQ29uZmlnLmZpcnN0Um93IC0gMSk7XFxuXFx0ICAgICAgICAgICAgaWYgKGVsLmZpcnN0Q2hpbGQpXFxuXFx0ICAgICAgICAgICAgICAgIGVsLmluc2VydEJlZm9yZShmcmFnbWVudCwgZWwuZmlyc3RDaGlsZCk7XFxuXFx0ICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoY29uZmlnLmxhc3RSb3cgPiBvbGRDb25maWcubGFzdFJvdykge1xcblxcdCAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuJHJlbmRlckxpbmVzRnJhZ21lbnQoY29uZmlnLCBvbGRDb25maWcubGFzdFJvdyArIDEsIGNvbmZpZy5sYXN0Um93KTtcXG5cXHQgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHJlbmRlckxpbmVzRnJhZ21lbnQgPSBmdW5jdGlvbihjb25maWcsIGZpcnN0Um93LCBsYXN0Um93KSB7XFxuXFx0ICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XFxuXFx0ICAgICAgICB2YXIgcm93ID0gZmlyc3RSb3c7XFxuXFx0ICAgICAgICB2YXIgZm9sZExpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TmV4dEZvbGRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICB2YXIgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcXG5cXG5cXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA+IGZvbGRTdGFydCkge1xcblxcdCAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93KzE7XFxuXFx0ICAgICAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3csIGZvbGRMaW5lKTtcXG5cXHQgICAgICAgICAgICAgICAgZm9sZFN0YXJ0ID0gZm9sZExpbmUgPyBmb2xkTGluZS5zdGFydC5yb3cgOiBJbmZpbml0eTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3RSb3cpXFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIGh0bWwgPSBbXTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRyZW5kZXJMaW5lKGh0bWwsIHJvdywgZmFsc2UsIHJvdyA9PSBmb2xkU3RhcnQgPyBmb2xkTGluZSA6IGZhbHNlKTtcXG5cXHQgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbC5qb2luKFxcXCJcXFwiKTtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kdXNlTGluZUdyb3VwcygpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAnYWNlX2xpbmVfZ3JvdXAnO1xcblxcdCAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xcblxcdCAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKiB0aGlzLnNlc3Npb24uZ2V0Um93TGVuZ3RoKHJvdykgKyBcXFwicHhcXFwiO1xcblxcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlKGNvbnRhaW5lci5maXJzdENoaWxkKVxcblxcdCAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICByb3crKztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBmcmFnbWVudDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihjb25maWcpIHtcXG5cXHQgICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xcblxcblxcdCAgICAgICAgdmFyIGh0bWwgPSBbXTtcXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IGNvbmZpZy5maXJzdFJvdywgbGFzdFJvdyA9IGNvbmZpZy5sYXN0Um93O1xcblxcblxcdCAgICAgICAgdmFyIHJvdyA9IGZpcnN0Um93O1xcblxcdCAgICAgICAgdmFyIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldE5leHRGb2xkTGluZShyb3cpO1xcblxcdCAgICAgICAgdmFyIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDogSW5maW5pdHk7XFxuXFxuXFx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xcblxcdCAgICAgICAgICAgIGlmIChyb3cgPiBmb2xkU3RhcnQpIHtcXG5cXHQgICAgICAgICAgICAgICAgcm93ID0gZm9sZExpbmUuZW5kLnJvdysxO1xcblxcdCAgICAgICAgICAgICAgICBmb2xkTGluZSA9IHRoaXMuc2Vzc2lvbi5nZXROZXh0Rm9sZExpbmUocm93LCBmb2xkTGluZSk7XFxuXFx0ICAgICAgICAgICAgICAgIGZvbGRTdGFydCA9IGZvbGRMaW5lID8gZm9sZExpbmUuc3RhcnQucm93IDpJbmZpbml0eTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgaWYgKHJvdyA+IGxhc3RSb3cpXFxuXFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiR1c2VMaW5lR3JvdXBzKCkpXFxuXFx0ICAgICAgICAgICAgICAgIGh0bWwucHVzaChcXFwiPGRpdiBjbGFzcz0nYWNlX2xpbmVfZ3JvdXAnIHN0eWxlPSdoZWlnaHQ6XFxcIiwgY29uZmlnLmxpbmVIZWlnaHQqdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aChyb3cpLCBcXFwicHgnPlxcXCIpXFxuXFxuXFx0ICAgICAgICAgICAgdGhpcy4kcmVuZGVyTGluZShodG1sLCByb3csIGZhbHNlLCByb3cgPT0gZm9sZFN0YXJ0ID8gZm9sZExpbmUgOiBmYWxzZSk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHVzZUxpbmVHcm91cHMoKSlcXG5cXHQgICAgICAgICAgICAgICAgaHRtbC5wdXNoKFxcXCI8L2Rpdj5cXFwiKTsgLy8gZW5kIHRoZSBsaW5lIGdyb3VwXFxuXFxuXFx0ICAgICAgICAgICAgcm93Kys7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbC5qb2luKFxcXCJcXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kdGV4dFRva2VuID0ge1xcblxcdCAgICAgICAgXFxcInRleHRcXFwiOiB0cnVlLFxcblxcdCAgICAgICAgXFxcInJwYXJlblxcXCI6IHRydWUsXFxuXFx0ICAgICAgICBcXFwibHBhcmVuXFxcIjogdHJ1ZVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRyZW5kZXJUb2tlbiA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKSB7XFxuXFx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFx0ICAgICAgICB2YXIgcmVwbGFjZVJlZyA9IC9cXFxcdHwmfDx8KCArKXwoW1xcXFx4MDAtXFxcXHgxZlxcXFx4ODAtXFxcXHhhMFxcXFx4YWRcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDAtXFxcXHUyMDBmXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXFxcXHVGRUZGXSl8W1xcXFx1MTEwMC1cXFxcdTExNUZcXFxcdTExQTMtXFxcXHUxMUE3XFxcXHUxMUZBLVxcXFx1MTFGRlxcXFx1MjMyOS1cXFxcdTIzMkFcXFxcdTJFODAtXFxcXHUyRTk5XFxcXHUyRTlCLVxcXFx1MkVGM1xcXFx1MkYwMC1cXFxcdTJGRDVcXFxcdTJGRjAtXFxcXHUyRkZCXFxcXHUzMDAwLVxcXFx1MzAzRVxcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwOTktXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxOTAtXFxcXHUzMUJBXFxcXHUzMUMwLVxcXFx1MzFFM1xcXFx1MzFGMC1cXFxcdTMyMUVcXFxcdTMyMjAtXFxcXHUzMjQ3XFxcXHUzMjUwLVxcXFx1MzJGRVxcXFx1MzMwMC1cXFxcdTREQkZcXFxcdTRFMDAtXFxcXHVBNDhDXFxcXHVBNDkwLVxcXFx1QTRDNlxcXFx1QTk2MC1cXFxcdUE5N0NcXFxcdUFDMDAtXFxcXHVEN0EzXFxcXHVEN0IwLVxcXFx1RDdDNlxcXFx1RDdDQi1cXFxcdUQ3RkJcXFxcdUY5MDAtXFxcXHVGQUZGXFxcXHVGRTEwLVxcXFx1RkUxOVxcXFx1RkUzMC1cXFxcdUZFNTJcXFxcdUZFNTQtXFxcXHVGRTY2XFxcXHVGRTY4LVxcXFx1RkU2QlxcXFx1RkYwMS1cXFxcdUZGNjBcXFxcdUZGRTAtXFxcXHVGRkU2XS9nO1xcblxcdCAgICAgICAgdmFyIHJlcGxhY2VGdW5jID0gZnVuY3Rpb24oYywgYSwgYiwgdGFiSWR4LCBpZHg0KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGEpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2hvd0ludmlzaWJsZXMgP1xcblxcdCAgICAgICAgICAgICAgICAgICAgXFxcIjxzcGFuIGNsYXNzPSdhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2UnPlxcXCIgKyBsYW5nLnN0cmluZ1JlcGVhdChzZWxmLlNQQUNFX0NIQVIsIGMubGVuZ3RoKSArIFxcXCI8L3NwYW4+XFxcIiA6XFxuXFx0ICAgICAgICAgICAgICAgICAgICBsYW5nLnN0cmluZ1JlcGVhdChcXFwiXFxcXHhhMFxcXCIsIGMubGVuZ3RoKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT0gXFxcIiZcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBcXFwiJiMzODtcXFwiO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PSBcXFwiPFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCImIzYwO1xcXCI7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjID09IFxcXCJcXFxcdFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRhYlNpemUgPSBzZWxmLnNlc3Npb24uZ2V0U2NyZWVuVGFiU2l6ZShzY3JlZW5Db2x1bW4gKyB0YWJJZHgpO1xcblxcdCAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gKz0gdGFiU2l6ZSAtIDE7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLiR0YWJTdHJpbmdzW3RhYlNpemVdO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PSBcXFwiXFxcXHUzMDAwXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgY2xhc3NUb1VzZSA9IHNlbGYuc2hvd0ludmlzaWJsZXMgPyBcXFwiYWNlX2NqayBhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2VcXFwiIDogXFxcImFjZV9jamtcXFwiO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBzZWxmLnNob3dJbnZpc2libGVzID8gc2VsZi5TUEFDRV9DSEFSIDogXFxcIlxcXCI7XFxuXFx0ICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiArPSAxO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gXFxcIjxzcGFuIGNsYXNzPSdcXFwiICsgY2xhc3NUb1VzZSArIFxcXCInIHN0eWxlPSd3aWR0aDpcXFwiICtcXG5cXHQgICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aCAqIDIpICtcXG5cXHQgICAgICAgICAgICAgICAgICAgIFxcXCJweCc+XFxcIiArIHNwYWNlICsgXFxcIjwvc3Bhbj5cXFwiO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAoYikge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gXFxcIjxzcGFuIGNsYXNzPSdhY2VfaW52aXNpYmxlIGFjZV9pbnZpc2libGVfc3BhY2UgYWNlX2ludmFsaWQnPlxcXCIgKyBzZWxmLlNQQUNFX0NIQVIgKyBcXFwiPC9zcGFuPlxcXCI7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uICs9IDE7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBcXFwiPHNwYW4gY2xhc3M9J2FjZV9jamsnIHN0eWxlPSd3aWR0aDpcXFwiICtcXG5cXHQgICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5jaGFyYWN0ZXJXaWR0aCAqIDIpICtcXG5cXHQgICAgICAgICAgICAgICAgICAgIFxcXCJweCc+XFxcIiArIGMgKyBcXFwiPC9zcGFuPlxcXCI7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfTtcXG5cXG5cXHQgICAgICAgIHZhciBvdXRwdXQgPSB2YWx1ZS5yZXBsYWNlKHJlcGxhY2VSZWcsIHJlcGxhY2VGdW5jKTtcXG5cXG5cXHQgICAgICAgIGlmICghdGhpcy4kdGV4dFRva2VuW3Rva2VuLnR5cGVdKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBcXFwiYWNlX1xcXCIgKyB0b2tlbi50eXBlLnJlcGxhY2UoL1xcXFwuL2csIFxcXCIgYWNlX1xcXCIpO1xcblxcdCAgICAgICAgICAgIHZhciBzdHlsZSA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09IFxcXCJmb2xkXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgc3R5bGUgPSBcXFwiIHN0eWxlPSd3aWR0aDpcXFwiICsgKHRva2VuLnZhbHVlLmxlbmd0aCAqIHRoaXMuY29uZmlnLmNoYXJhY3RlcldpZHRoKSArIFxcXCJweDsnIFxcXCI7XFxuXFx0ICAgICAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxcXCI8c3BhbiBjbGFzcz0nXFxcIiwgY2xhc3NlcywgXFxcIidcXFwiLCBzdHlsZSwgXFxcIj5cXFwiLCBvdXRwdXQsIFxcXCI8L3NwYW4+XFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBlbHNlIHtcXG5cXHQgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2gob3V0cHV0KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiBzY3JlZW5Db2x1bW4gKyB2YWx1ZS5sZW5ndGg7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMucmVuZGVySW5kZW50R3VpZGUgPSBmdW5jdGlvbihzdHJpbmdCdWlsZGVyLCB2YWx1ZSwgbWF4KSB7XFxuXFx0ICAgICAgICB2YXIgY29scyA9IHZhbHVlLnNlYXJjaCh0aGlzLiRpbmRlbnRHdWlkZVJlKTtcXG5cXHQgICAgICAgIGlmIChjb2xzIDw9IDAgfHwgY29scyA+PSBtYXgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xcblxcdCAgICAgICAgaWYgKHZhbHVlWzBdID09IFxcXCIgXFxcIikge1xcblxcdCAgICAgICAgICAgIGNvbHMgLT0gY29scyAlIHRoaXMudGFiU2l6ZTtcXG5cXHQgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2gobGFuZy5zdHJpbmdSZXBlYXQodGhpcy4kdGFiU3RyaW5nc1tcXFwiIFxcXCJdLCBjb2xzL3RoaXMudGFiU2l6ZSkpO1xcblxcdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoY29scyk7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWzBdID09IFxcXCJcXFxcdFxcXCIpIHtcXG5cXHQgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2gobGFuZy5zdHJpbmdSZXBlYXQodGhpcy4kdGFiU3RyaW5nc1tcXFwiXFxcXHRcXFwiXSwgY29scykpO1xcblxcdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoY29scyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gdmFsdWU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHJlbmRlcldyYXBwZWRMaW5lID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgdG9rZW5zLCBzcGxpdHMsIG9ubHlDb250ZW50cykge1xcblxcdCAgICAgICAgdmFyIGNoYXJzID0gMDtcXG5cXHQgICAgICAgIHZhciBzcGxpdCA9IDA7XFxuXFx0ICAgICAgICB2YXIgc3BsaXRDaGFycyA9IHNwbGl0c1swXTtcXG5cXHQgICAgICAgIHZhciBzY3JlZW5Db2x1bW4gPSAwO1xcblxcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XFxuXFx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdG9rZW4udmFsdWU7XFxuXFx0ICAgICAgICAgICAgaWYgKGkgPT0gMCAmJiB0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMpIHtcXG5cXHQgICAgICAgICAgICAgICAgY2hhcnMgPSB2YWx1ZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZW5kZXJJbmRlbnRHdWlkZShzdHJpbmdCdWlsZGVyLCB2YWx1ZSwgc3BsaXRDaGFycyk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICghdmFsdWUpXFxuXFx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXHQgICAgICAgICAgICAgICAgY2hhcnMgLT0gdmFsdWUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICBpZiAoY2hhcnMgKyB2YWx1ZS5sZW5ndGggPCBzcGxpdENoYXJzKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHNjcmVlbkNvbHVtbiA9IHRoaXMuJHJlbmRlclRva2VuKHN0cmluZ0J1aWxkZXIsIHNjcmVlbkNvbHVtbiwgdG9rZW4sIHZhbHVlKTtcXG5cXHQgICAgICAgICAgICAgICAgY2hhcnMgKz0gdmFsdWUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGFycyArIHZhbHVlLmxlbmd0aCA+PSBzcGxpdENoYXJzKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLCBzY3JlZW5Db2x1bW4sXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4sIHZhbHVlLnN1YnN0cmluZygwLCBzcGxpdENoYXJzIC0gY2hhcnMpXFxuXFx0ICAgICAgICAgICAgICAgICAgICApO1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3BsaXRDaGFycyAtIGNoYXJzKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNoYXJzID0gc3BsaXRDaGFycztcXG5cXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICghb25seUNvbnRlbnRzKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxcXCI8L2Rpdj5cXFwiLFxcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiPGRpdiBjbGFzcz0nYWNlX2xpbmUnIHN0eWxlPSdoZWlnaHQ6XFxcIixcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubGluZUhlaWdodCwgXFxcInB4Jz5cXFwiXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwbGl0ICsrO1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2NyZWVuQ29sdW1uID0gMDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwbGl0Q2hhcnMgPSBzcGxpdHNbc3BsaXRdIHx8IE51bWJlci5NQVhfVkFMVUU7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPSAwKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBjaGFycyArPSB2YWx1ZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLCBzY3JlZW5Db2x1bW4sIHRva2VuLCB2YWx1ZVxcblxcdCAgICAgICAgICAgICAgICAgICAgKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kcmVuZGVyU2ltcGxlTGluZSA9IGZ1bmN0aW9uKHN0cmluZ0J1aWxkZXIsIHRva2Vucykge1xcblxcdCAgICAgICAgdmFyIHNjcmVlbkNvbHVtbiA9IDA7XFxuXFx0ICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbMF07XFxuXFx0ICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcXG5cXHQgICAgICAgIGlmICh0aGlzLmRpc3BsYXlJbmRlbnRHdWlkZXMpXFxuXFx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlbmRlckluZGVudEd1aWRlKHN0cmluZ0J1aWxkZXIsIHZhbHVlKTtcXG5cXHQgICAgICAgIGlmICh2YWx1ZSlcXG5cXHQgICAgICAgICAgICBzY3JlZW5Db2x1bW4gPSB0aGlzLiRyZW5kZXJUb2tlbihzdHJpbmdCdWlsZGVyLCBzY3JlZW5Db2x1bW4sIHRva2VuLCB2YWx1ZSk7XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xcblxcdCAgICAgICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XFxuXFx0ICAgICAgICAgICAgc2NyZWVuQ29sdW1uID0gdGhpcy4kcmVuZGVyVG9rZW4oc3RyaW5nQnVpbGRlciwgc2NyZWVuQ29sdW1uLCB0b2tlbiwgdmFsdWUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiRyZW5kZXJMaW5lID0gZnVuY3Rpb24oc3RyaW5nQnVpbGRlciwgcm93LCBvbmx5Q29udGVudHMsIGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICBpZiAoIWZvbGRMaW5lICYmIGZvbGRMaW5lICE9IGZhbHNlKVxcblxcdCAgICAgICAgICAgIGZvbGRMaW5lID0gdGhpcy5zZXNzaW9uLmdldEZvbGRMaW5lKHJvdyk7XFxuXFxuXFx0ICAgICAgICBpZiAoZm9sZExpbmUpXFxuXFx0ICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuJGdldEZvbGRMaW5lVG9rZW5zKHJvdywgZm9sZExpbmUpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnNlc3Npb24uZ2V0VG9rZW5zKHJvdyk7XFxuXFxuXFxuXFx0ICAgICAgICBpZiAoIW9ubHlDb250ZW50cykge1xcblxcdCAgICAgICAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChcXG5cXHQgICAgICAgICAgICAgICAgXFxcIjxkaXYgY2xhc3M9J2FjZV9saW5lJyBzdHlsZT0naGVpZ2h0OlxcXCIsIFxcblxcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubGluZUhlaWdodCAqIChcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiR1c2VMaW5lR3JvdXBzKCkgPyAxIDp0aGlzLnNlc3Npb24uZ2V0Um93TGVuZ3RoKHJvdylcXG5cXHQgICAgICAgICAgICAgICAgICAgICksIFxcXCJweCc+XFxcIlxcblxcdCAgICAgICAgICAgICk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgIHZhciBzcGxpdHMgPSB0aGlzLnNlc3Npb24uZ2V0Um93U3BsaXREYXRhKHJvdyk7XFxuXFx0ICAgICAgICAgICAgaWYgKHNwbGl0cyAmJiBzcGxpdHMubGVuZ3RoKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRyZW5kZXJXcmFwcGVkTGluZShzdHJpbmdCdWlsZGVyLCB0b2tlbnMsIHNwbGl0cywgb25seUNvbnRlbnRzKTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJHJlbmRlclNpbXBsZUxpbmUoc3RyaW5nQnVpbGRlciwgdG9rZW5zKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnNob3dJbnZpc2libGVzKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGZvbGRMaW5lKVxcblxcdCAgICAgICAgICAgICAgICByb3cgPSBmb2xkTGluZS5lbmQucm93XFxuXFxuXFx0ICAgICAgICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKFxcblxcdCAgICAgICAgICAgICAgICBcXFwiPHNwYW4gY2xhc3M9J2FjZV9pbnZpc2libGUgYWNlX2ludmlzaWJsZV9lb2wnPlxcXCIsXFxuXFx0ICAgICAgICAgICAgICAgIHJvdyA9PSB0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkgLSAxID8gdGhpcy5FT0ZfQ0hBUiA6IHRoaXMuRU9MX0NIQVIsXFxuXFx0ICAgICAgICAgICAgICAgIFxcXCI8L3NwYW4+XFxcIlxcblxcdCAgICAgICAgICAgICk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoIW9ubHlDb250ZW50cylcXG5cXHQgICAgICAgICAgICBzdHJpbmdCdWlsZGVyLnB1c2goXFxcIjwvZGl2PlxcXCIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRnZXRGb2xkTGluZVRva2VucyA9IGZ1bmN0aW9uKHJvdywgZm9sZExpbmUpIHtcXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgdmFyIHJlbmRlclRva2VucyA9IFtdO1xcblxcblxcdCAgICAgICAgZnVuY3Rpb24gYWRkVG9rZW5zKHRva2VucywgZnJvbSwgdG8pIHtcXG5cXHQgICAgICAgICAgICB2YXIgaWR4ID0gMCwgY29sID0gMDtcXG5cXHQgICAgICAgICAgICB3aGlsZSAoKGNvbCArIHRva2Vuc1tpZHhdLnZhbHVlLmxlbmd0aCkgPCBmcm9tKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNvbCArPSB0b2tlbnNbaWR4XS52YWx1ZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgIGlkeCsrO1xcblxcblxcdCAgICAgICAgICAgICAgICBpZiAoaWR4ID09IHRva2Vucy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIGlmIChjb2wgIT0gZnJvbSkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnNbaWR4XS52YWx1ZS5zdWJzdHJpbmcoZnJvbSAtIGNvbCk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAodG8gLSBmcm9tKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRvIC0gZnJvbSk7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRva2Vuc1tpZHhdLnR5cGUsXFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcXG5cXHQgICAgICAgICAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICAgICAgICAgIGNvbCA9IGZyb20gKyB2YWx1ZS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgIGlkeCArPSAxO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICB3aGlsZSAoY29sIDwgdG8gJiYgaWR4IDwgdG9rZW5zLmxlbmd0aCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnNbaWR4XS52YWx1ZTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCArIGNvbCA+IHRvKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByZW5kZXJUb2tlbnMucHVzaCh7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5zW2lkeF0udHlwZSxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc3Vic3RyaW5nKDAsIHRvIC0gY29sKVxcblxcdCAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgICAgICAgICAgICAgcmVuZGVyVG9rZW5zLnB1c2godG9rZW5zW2lkeF0pO1xcblxcdCAgICAgICAgICAgICAgICBjb2wgKz0gdmFsdWUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgICAgICBpZHggKz0gMTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgdG9rZW5zID0gc2Vzc2lvbi5nZXRUb2tlbnMocm93KTtcXG5cXHQgICAgICAgIGZvbGRMaW5lLndhbGsoZnVuY3Rpb24ocGxhY2Vob2xkZXIsIHJvdywgY29sdW1uLCBsYXN0Q29sdW1uLCBpc05ld1Jvdykge1xcblxcdCAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPSBudWxsKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJlbmRlclRva2Vucy5wdXNoKHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IFxcXCJmb2xkXFxcIixcXG5cXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbGFjZWhvbGRlclxcblxcdCAgICAgICAgICAgICAgICB9KTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoaXNOZXdSb3cpXFxuXFx0ICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2Vucyhyb3cpO1xcblxcblxcdCAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aClcXG5cXHQgICAgICAgICAgICAgICAgICAgIGFkZFRva2Vucyh0b2tlbnMsIGxhc3RDb2x1bW4sIGNvbHVtbik7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSwgZm9sZExpbmUuZW5kLnJvdywgdGhpcy5zZXNzaW9uLmdldExpbmUoZm9sZExpbmUuZW5kLnJvdykubGVuZ3RoKTtcXG5cXG5cXHQgICAgICAgIHJldHVybiByZW5kZXJUb2tlbnM7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHVzZUxpbmVHcm91cHMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBjbGVhckludGVydmFsKHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyKTtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRtZWFzdXJlTm9kZSlcXG5cXHQgICAgICAgICAgICB0aGlzLiRtZWFzdXJlTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuJG1lYXN1cmVOb2RlKTtcXG5cXHQgICAgICAgIGRlbGV0ZSB0aGlzLiRtZWFzdXJlTm9kZTtcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKFRleHQucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLlRleHQgPSBUZXh0O1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9sYXllci9jdXJzb3JcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2RvbVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBJRTg7XFxuXFxuXFx0dmFyIEN1cnNvciA9IGZ1bmN0aW9uKHBhcmVudEVsKSB7XFxuXFx0ICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFxcXCJhY2VfbGF5ZXIgYWNlX2N1cnNvci1sYXllclxcXCI7XFxuXFx0ICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoSUU4ID09PSB1bmRlZmluZWQpXFxuXFx0ICAgICAgICBJRTggPSBcXFwib3BhY2l0eVxcXCIgaW4gdGhpcy5lbGVtZW50O1xcblxcblxcdCAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xcblxcdCAgICB0aGlzLmlzQmxpbmtpbmcgPSB0cnVlO1xcblxcdCAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSAxMDAwO1xcblxcdCAgICB0aGlzLnNtb290aEJsaW5raW5nID0gZmFsc2U7XFxuXFxuXFx0ICAgIHRoaXMuY3Vyc29ycyA9IFtdO1xcblxcdCAgICB0aGlzLmN1cnNvciA9IHRoaXMuYWRkQ3Vyc29yKCk7XFxuXFx0ICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFxcXCJhY2VfaGlkZGVuLWN1cnNvcnNcXFwiKTtcXG5cXHQgICAgdGhpcy4kdXBkYXRlQ3Vyc29ycyA9IHRoaXMuJHVwZGF0ZVZpc2liaWxpdHkuYmluZCh0aGlzKTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgIHZhciBjdXJzb3JzID0gdGhpcy5jdXJzb3JzO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IGN1cnNvcnMubGVuZ3RoOyBpLS07IClcXG5cXHQgICAgICAgICAgICBjdXJzb3JzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSB2YWwgPyBcXFwiXFxcIiA6IFxcXCJoaWRkZW5cXFwiO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiR1cGRhdGVPcGFjaXR5ID0gZnVuY3Rpb24odmFsKSB7XFxuXFx0ICAgICAgICB2YXIgY3Vyc29ycyA9IHRoaXMuY3Vyc29ycztcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSBjdXJzb3JzLmxlbmd0aDsgaS0tOyApXFxuXFx0ICAgICAgICAgICAgY3Vyc29yc1tpXS5zdHlsZS5vcGFjaXR5ID0gdmFsID8gXFxcIlxcXCIgOiBcXFwiMFxcXCI7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcblxcdCAgICB0aGlzLiRwYWRkaW5nID0gMDtcXG5cXHQgICAgdGhpcy5zZXRQYWRkaW5nID0gZnVuY3Rpb24ocGFkZGluZykge1xcblxcdCAgICAgICAgdGhpcy4kcGFkZGluZyA9IHBhZGRpbmc7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0QmxpbmtpbmcgPSBmdW5jdGlvbihibGlua2luZykge1xcblxcdCAgICAgICAgaWYgKGJsaW5raW5nICE9IHRoaXMuaXNCbGlua2luZyl7XFxuXFx0ICAgICAgICAgICAgdGhpcy5pc0JsaW5raW5nID0gYmxpbmtpbmc7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zZXRCbGlua0ludGVydmFsID0gZnVuY3Rpb24oYmxpbmtJbnRlcnZhbCkge1xcblxcdCAgICAgICAgaWYgKGJsaW5rSW50ZXJ2YWwgIT0gdGhpcy5ibGlua0ludGVydmFsKXtcXG5cXHQgICAgICAgICAgICB0aGlzLmJsaW5rSW50ZXJ2YWwgPSBibGlua0ludGVydmFsO1xcblxcdCAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2V0U21vb3RoQmxpbmtpbmcgPSBmdW5jdGlvbihzbW9vdGhCbGlua2luZykge1xcblxcdCAgICAgICAgaWYgKHNtb290aEJsaW5raW5nICE9IHRoaXMuc21vb3RoQmxpbmtpbmcgJiYgIUlFOCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc21vb3RoQmxpbmtpbmcgPSBzbW9vdGhCbGlua2luZztcXG5cXHQgICAgICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy5lbGVtZW50LCBcXFwiYWNlX3Ntb290aC1ibGlua2luZ1xcXCIsIHNtb290aEJsaW5raW5nKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiR1cGRhdGVDdXJzb3JzKHRydWUpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHVwZGF0ZUN1cnNvcnMgPSAoc21vb3RoQmxpbmtpbmcgXFxuXFx0ICAgICAgICAgICAgICAgID8gdGhpcy4kdXBkYXRlT3BhY2l0eVxcblxcdCAgICAgICAgICAgICAgICA6IHRoaXMuJHVwZGF0ZVZpc2liaWxpdHkpLmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZXIoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hZGRDdXJzb3IgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgICAgIGVsLmNsYXNzTmFtZSA9IFxcXCJhY2VfY3Vyc29yXFxcIjtcXG5cXHQgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XFxuXFx0ICAgICAgICB0aGlzLmN1cnNvcnMucHVzaChlbCk7XFxuXFx0ICAgICAgICByZXR1cm4gZWw7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMucmVtb3ZlQ3Vyc29yID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5jdXJzb3JzLmxlbmd0aCA+IDEpIHtcXG5cXHQgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmN1cnNvcnMucG9wKCk7XFxuXFx0ICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGVsO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmhpZGVDdXJzb3IgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XFxuXFx0ICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5lbGVtZW50LCBcXFwiYWNlX2hpZGRlbi1jdXJzb3JzXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLnJlc3RhcnRUaW1lcigpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNob3dDdXJzb3IgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcXG5cXHQgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFxcXCJhY2VfaGlkZGVuLWN1cnNvcnNcXFwiKTtcXG5cXHQgICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMucmVzdGFydFRpbWVyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgdXBkYXRlID0gdGhpcy4kdXBkYXRlQ3Vyc29ycztcXG5cXHQgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcXG5cXHQgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zbW9vdGhCbGlua2luZykge1xcblxcdCAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFxcXCJhY2Vfc21vb3RoLWJsaW5raW5nXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHVwZGF0ZSh0cnVlKTtcXG5cXG5cXHQgICAgICAgIGlmICghdGhpcy5pc0JsaW5raW5nIHx8ICF0aGlzLmJsaW5rSW50ZXJ2YWwgfHwgIXRoaXMuaXNWaXNpYmxlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnNtb290aEJsaW5raW5nKSB7XFxuXFx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xcblxcdCAgICAgICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5lbGVtZW50LCBcXFwiYWNlX3Ntb290aC1ibGlua2luZ1xcXCIpO1xcblxcdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHZhciBibGluayA9IGZ1bmN0aW9uKCl7XFxuXFx0ICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgICAgICB1cGRhdGUoZmFsc2UpO1xcblxcdCAgICAgICAgICAgIH0sIDAuNiAqIHRoaXMuYmxpbmtJbnRlcnZhbCk7XFxuXFx0ICAgICAgICB9LmJpbmQodGhpcyk7XFxuXFxuXFx0ICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICB1cGRhdGUodHJ1ZSk7XFxuXFx0ICAgICAgICAgICAgYmxpbmsoKTtcXG5cXHQgICAgICAgIH0sIHRoaXMuYmxpbmtJbnRlcnZhbCk7XFxuXFxuXFx0ICAgICAgICBibGluaygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldFBpeGVsUG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbiwgb25TY3JlZW4pIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy5jb25maWcgfHwgIXRoaXMuc2Vzc2lvbilcXG5cXHQgICAgICAgICAgICByZXR1cm4ge2xlZnQgOiAwLCB0b3AgOiAwfTtcXG5cXG5cXHQgICAgICAgIGlmICghcG9zaXRpb24pXFxuXFx0ICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xcblxcdCAgICAgICAgdmFyIHBvcyA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24ocG9zaXRpb24pO1xcblxcdCAgICAgICAgdmFyIGN1cnNvckxlZnQgPSB0aGlzLiRwYWRkaW5nICsgcG9zLmNvbHVtbiAqIHRoaXMuY29uZmlnLmNoYXJhY3RlcldpZHRoO1xcblxcdCAgICAgICAgdmFyIGN1cnNvclRvcCA9IChwb3Mucm93IC0gKG9uU2NyZWVuID8gdGhpcy5jb25maWcuZmlyc3RSb3dTY3JlZW4gOiAwKSkgKlxcblxcdCAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpbmVIZWlnaHQ7XFxuXFxuXFx0ICAgICAgICByZXR1cm4ge2xlZnQgOiBjdXJzb3JMZWZ0LCB0b3AgOiBjdXJzb3JUb3B9O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xcblxcdCAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XFxuXFxuXFx0ICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycztcXG5cXHQgICAgICAgIHZhciBpID0gMCwgY3Vyc29ySW5kZXggPSAwO1xcblxcblxcdCAgICAgICAgaWYgKHNlbGVjdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCl7XFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9ucyA9IFt7Y3Vyc29yOiBudWxsfV07XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNlbGVjdGlvbnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHBpeGVsUG9zID0gdGhpcy5nZXRQaXhlbFBvc2l0aW9uKHNlbGVjdGlvbnNbaV0uY3Vyc29yLCB0cnVlKTtcXG5cXHQgICAgICAgICAgICBpZiAoKHBpeGVsUG9zLnRvcCA+IGNvbmZpZy5oZWlnaHQgKyBjb25maWcub2Zmc2V0IHx8XFxuXFx0ICAgICAgICAgICAgICAgICBwaXhlbFBvcy50b3AgPCAwKSAmJiBpID4gMSkge1xcblxcdCAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgdmFyIHN0eWxlID0gKHRoaXMuY3Vyc29yc1tjdXJzb3JJbmRleCsrXSB8fCB0aGlzLmFkZEN1cnNvcigpKS5zdHlsZTtcXG5cXG5cXHQgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gcGl4ZWxQb3MubGVmdCArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgc3R5bGUudG9wID0gcGl4ZWxQb3MudG9wICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICBzdHlsZS53aWR0aCA9IGNvbmZpZy5jaGFyYWN0ZXJXaWR0aCArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY29uZmlnLmxpbmVIZWlnaHQgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgd2hpbGUgKHRoaXMuY3Vyc29ycy5sZW5ndGggPiBjdXJzb3JJbmRleClcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbW92ZUN1cnNvcigpO1xcblxcblxcdCAgICAgICAgdmFyIG92ZXJ3cml0ZSA9IHRoaXMuc2Vzc2lvbi5nZXRPdmVyd3JpdGUoKTtcXG5cXHQgICAgICAgIHRoaXMuJHNldE92ZXJ3cml0ZShvdmVyd3JpdGUpO1xcblxcdCAgICAgICAgdGhpcy4kcGl4ZWxQb3MgPSBwaXhlbFBvcztcXG5cXHQgICAgICAgIHRoaXMucmVzdGFydFRpbWVyKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHNldE92ZXJ3cml0ZSA9IGZ1bmN0aW9uKG92ZXJ3cml0ZSkge1xcblxcdCAgICAgICAgaWYgKG92ZXJ3cml0ZSAhPSB0aGlzLm92ZXJ3cml0ZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMub3ZlcndyaXRlID0gb3ZlcndyaXRlO1xcblxcdCAgICAgICAgICAgIGlmIChvdmVyd3JpdGUpXFxuXFx0ICAgICAgICAgICAgICAgIGRvbS5hZGRDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFxcXCJhY2Vfb3ZlcndyaXRlLWN1cnNvcnNcXFwiKTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmVsZW1lbnQsIFxcXCJhY2Vfb3ZlcndyaXRlLWN1cnNvcnNcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XFxuXFx0ICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoQ3Vyc29yLnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5DdXJzb3IgPSBDdXJzb3I7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL3Njcm9sbGJhclxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvbGliL2V2ZW50XFxcIixcXFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgZG9tID0gYWNlcXVpcmUoXFxcIi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9ldmVudFxcXCIpO1xcblxcdHZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXHR2YXIgU2Nyb2xsQmFyID0gZnVuY3Rpb24ocGFyZW50KSB7XFxuXFx0ICAgIHRoaXMuZWxlbWVudCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IFxcXCJhY2Vfc2Nyb2xsYmFyIGFjZV9zY3JvbGxiYXJcXFwiICsgdGhpcy5jbGFzc1N1ZmZpeDtcXG5cXG5cXHQgICAgdGhpcy5pbm5lciA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgdGhpcy5pbm5lci5jbGFzc05hbWUgPSBcXFwiYWNlX3Njcm9sbGJhci1pbm5lclxcXCI7XFxuXFx0ICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlubmVyKTtcXG5cXG5cXHQgICAgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XFxuXFxuXFx0ICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XFxuXFx0ICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XFxuXFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXFxcInNjcm9sbFxcXCIsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXFxcIm1vdXNlZG93blxcXCIsIGV2ZW50LnByZXZlbnREZWZhdWx0KTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXHQgICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xcblxcblxcdCAgICB0aGlzLnNldFZpc2libGUgPSBmdW5jdGlvbihpc1Zpc2libGUpIHtcXG5cXHQgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaXNWaXNpYmxlID8gXFxcIlxcXCIgOiBcXFwibm9uZVxcXCI7XFxuXFx0ICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZTtcXG5cXHQgICAgfTtcXG5cXHR9KS5jYWxsKFNjcm9sbEJhci5wcm90b3R5cGUpO1xcblxcdHZhciBWU2Nyb2xsQmFyID0gZnVuY3Rpb24ocGFyZW50LCByZW5kZXJlcikge1xcblxcdCAgICBTY3JvbGxCYXIuY2FsbCh0aGlzLCBwYXJlbnQpO1xcblxcdCAgICB0aGlzLnNjcm9sbFRvcCA9IDA7XFxuXFx0ICAgIHJlbmRlcmVyLiRzY3JvbGxiYXJXaWR0aCA9IFxcblxcdCAgICB0aGlzLndpZHRoID0gZG9tLnNjcm9sbGJhcldpZHRoKHBhcmVudC5vd25lckRvY3VtZW50KTtcXG5cXHQgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9XFxuXFx0ICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICh0aGlzLndpZHRoIHx8IDE1KSArIDUgKyBcXFwicHhcXFwiO1xcblxcdH07XFxuXFxuXFx0b29wLmluaGVyaXRzKFZTY3JvbGxCYXIsIFNjcm9sbEJhcik7XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICB0aGlzLmNsYXNzU3VmZml4ID0gJy12JztcXG5cXHQgICAgdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLnNraXBFdmVudCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5lbGVtZW50LnNjcm9sbFRvcDtcXG5cXHQgICAgICAgICAgICB0aGlzLl9lbWl0KFxcXCJzY3JvbGxcXFwiLCB7ZGF0YTogdGhpcy5zY3JvbGxUb3B9KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0V2lkdGggPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmlzVmlzaWJsZSA/IHRoaXMud2lkdGggOiAwO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xcblxcdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFxcXCJweFxcXCI7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0SW5uZXJIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcXG5cXHQgICAgICAgIHRoaXMuaW5uZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcXG5cXHQgICAgICAgIHRoaXMuaW5uZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbihzY3JvbGxUb3ApIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPSBzY3JvbGxUb3ApIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNraXBFdmVudCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoVlNjcm9sbEJhci5wcm90b3R5cGUpO1xcblxcdHZhciBIU2Nyb2xsQmFyID0gZnVuY3Rpb24ocGFyZW50LCByZW5kZXJlcikge1xcblxcdCAgICBTY3JvbGxCYXIuY2FsbCh0aGlzLCBwYXJlbnQpO1xcblxcdCAgICB0aGlzLnNjcm9sbExlZnQgPSAwO1xcblxcdCAgICB0aGlzLmhlaWdodCA9IHJlbmRlcmVyLiRzY3JvbGxiYXJXaWR0aDtcXG5cXHQgICAgdGhpcy5pbm5lci5zdHlsZS5oZWlnaHQgPVxcblxcdCAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKHRoaXMuaGVpZ2h0IHx8IDE1KSArIDUgKyBcXFwicHhcXFwiO1xcblxcdH07XFxuXFxuXFx0b29wLmluaGVyaXRzKEhTY3JvbGxCYXIsIFNjcm9sbEJhcik7XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICB0aGlzLmNsYXNzU3VmZml4ID0gJy1oJztcXG5cXHQgICAgdGhpcy5vblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLnNraXBFdmVudCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0O1xcblxcdCAgICAgICAgICAgIHRoaXMuX2VtaXQoXFxcInNjcm9sbFxcXCIsIHtkYXRhOiB0aGlzLnNjcm9sbExlZnR9KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuc2tpcEV2ZW50ID0gZmFsc2U7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5pc1Zpc2libGUgPyB0aGlzLmhlaWdodCA6IDA7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0V2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xcblxcdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBcXFwicHhcXFwiO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldElubmVyV2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xcblxcdCAgICAgICAgdGhpcy5pbm5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgXFxcInB4XFxcIjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoKSB7XFxuXFx0ICAgICAgICB0aGlzLmlubmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyBcXFwicHhcXFwiO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbihzY3JvbGxMZWZ0KSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0ICE9IHNjcm9sbExlZnQpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNraXBFdmVudCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoSFNjcm9sbEJhci5wcm90b3R5cGUpO1xcblxcblxcblxcdGV4cG9ydHMuU2Nyb2xsQmFyID0gVlNjcm9sbEJhcjsgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxcblxcdGV4cG9ydHMuU2Nyb2xsQmFyViA9IFZTY3JvbGxCYXI7IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcXG5cXHRleHBvcnRzLlNjcm9sbEJhckggPSBIU2Nyb2xsQmFyOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XFxuXFxuXFx0ZXhwb3J0cy5WU2Nyb2xsQmFyID0gVlNjcm9sbEJhcjtcXG5cXHRleHBvcnRzLkhTY3JvbGxCYXIgPSBIU2Nyb2xsQmFyO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9yZW5kZXJsb29wXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBldmVudCA9IGFjZXF1aXJlKFxcXCIuL2xpYi9ldmVudFxcXCIpO1xcblxcblxcblxcdHZhciBSZW5kZXJMb29wID0gZnVuY3Rpb24ob25SZW5kZXIsIHdpbikge1xcblxcdCAgICB0aGlzLm9uUmVuZGVyID0gb25SZW5kZXI7XFxuXFx0ICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcblxcdCAgICB0aGlzLmNoYW5nZXMgPSAwO1xcblxcdCAgICB0aGlzLndpbmRvdyA9IHdpbiB8fCB3aW5kb3c7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFxuXFx0ICAgIHRoaXMuc2NoZWR1bGUgPSBmdW5jdGlvbihjaGFuZ2UpIHtcXG5cXHQgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcyB8IGNoYW5nZTtcXG5cXHQgICAgICAgIGlmICghdGhpcy5wZW5kaW5nICYmIHRoaXMuY2hhbmdlcykge1xcblxcdCAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcXG5cXHQgICAgICAgICAgICBldmVudC5uZXh0RnJhbWUoZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgICAgIF9zZWxmLnBlbmRpbmcgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5nZXM7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGFuZ2VzID0gX3NlbGYuY2hhbmdlcykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgX3NlbGYuY2hhbmdlcyA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBfc2VsZi5vblJlbmRlcihjaGFuZ2VzKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH0sIHRoaXMud2luZG93KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKFJlbmRlckxvb3AucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLlJlbmRlckxvb3AgPSBSZW5kZXJMb29wO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9sYXllci9mb250X21ldHJpY3NcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvZG9tXFxcIixcXFwiYWNlL2xpYi9sYW5nXFxcIixcXFwiYWNlL2xpYi91c2VyYWdlbnRcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvdXNlcmFnZW50XFxcIik7XFxuXFx0dmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXG5cXHR2YXIgQ0hBUl9DT1VOVCA9IDA7XFxuXFxuXFx0dmFyIEZvbnRNZXRyaWNzID0gZXhwb3J0cy5Gb250TWV0cmljcyA9IGZ1bmN0aW9uKHBhcmVudEVsLCBpbnRlcnZhbCkge1xcblxcdCAgICB0aGlzLmVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcdCAgICB0aGlzLiRzZXRNZWFzdXJlTm9kZVN0eWxlcyh0aGlzLmVsLnN0eWxlLCB0cnVlKTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJG1haW4gPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIHRoaXMuJHNldE1lYXN1cmVOb2RlU3R5bGVzKHRoaXMuJG1haW4uc3R5bGUpO1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy4kbWVhc3VyZU5vZGUgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIHRoaXMuJHNldE1lYXN1cmVOb2RlU3R5bGVzKHRoaXMuJG1lYXN1cmVOb2RlLnN0eWxlKTtcXG5cXHQgICAgXFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1haW4pO1xcblxcdCAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuJG1lYXN1cmVOb2RlKTtcXG5cXHQgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQodGhpcy5lbCk7XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoIUNIQVJfQ09VTlQpXFxuXFx0ICAgICAgICB0aGlzLiR0ZXN0RnJhY3Rpb25hbFJlY3QoKTtcXG5cXHQgICAgdGhpcy4kbWVhc3VyZU5vZGUuaW5uZXJIVE1MID0gbGFuZy5zdHJpbmdSZXBlYXQoXFxcIlhcXFwiLCBDSEFSX0NPVU5UKTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJGNoYXJhY3RlclNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XFxuXFx0ICAgIHRoaXMuY2hlY2tGb3JTaXplQ2hhbmdlcygpO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgdGhpcy4kY2hhcmFjdGVyU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJHRlc3RGcmFjdGlvbmFsUmVjdCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcdCAgICAgICAgdGhpcy4kc2V0TWVhc3VyZU5vZGVTdHlsZXMoZWwuc3R5bGUpO1xcblxcdCAgICAgICAgZWwuc3R5bGUud2lkdGggPSBcXFwiMC4ycHhcXFwiO1xcblxcdCAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcXG5cXHQgICAgICAgIHZhciB3ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XFxuXFx0ICAgICAgICBpZiAodyA+IDAgJiYgdyA8IDEpXFxuXFx0ICAgICAgICAgICAgQ0hBUl9DT1VOVCA9IDUwO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIENIQVJfQ09VTlQgPSAxMDA7XFxuXFx0ICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJHNldE1lYXN1cmVOb2RlU3R5bGVzID0gZnVuY3Rpb24oc3R5bGUsIGlzUm9vdCkge1xcblxcdCAgICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSBcXFwiYXV0b1xcXCI7XFxuXFx0ICAgICAgICBzdHlsZS5sZWZ0ID0gc3R5bGUudG9wID0gXFxcIi0xMDBweFxcXCI7XFxuXFx0ICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXFxcImhpZGRlblxcXCI7XFxuXFx0ICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFxcXCJmaXhlZFxcXCI7XFxuXFx0ICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gXFxcInByZVxcXCI7XFxuXFxuXFx0ICAgICAgICBpZiAodXNlcmFnZW50LmlzSUUgPCA4KSB7XFxuXFx0ICAgICAgICAgICAgc3R5bGVbXFxcImZvbnQtZmFtaWx5XFxcIl0gPSBcXFwiaW5oZXJpdFxcXCI7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHN0eWxlLmZvbnQgPSBcXFwiaW5oZXJpdFxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IGlzUm9vdCA/IFxcXCJoaWRkZW5cXFwiIDogXFxcInZpc2libGVcXFwiO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmNoZWNrRm9yU2l6ZUNoYW5nZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzaXplID0gdGhpcy4kbWVhc3VyZVNpemVzKCk7XFxuXFx0ICAgICAgICBpZiAoc2l6ZSAmJiAodGhpcy4kY2hhcmFjdGVyU2l6ZS53aWR0aCAhPT0gc2l6ZS53aWR0aCB8fCB0aGlzLiRjaGFyYWN0ZXJTaXplLmhlaWdodCAhPT0gc2l6ZS5oZWlnaHQpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbWVhc3VyZU5vZGUuc3R5bGUuZm9udFdlaWdodCA9IFxcXCJib2xkXFxcIjtcXG5cXHQgICAgICAgICAgICB2YXIgYm9sZFNpemUgPSB0aGlzLiRtZWFzdXJlU2l6ZXMoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRtZWFzdXJlTm9kZS5zdHlsZS5mb250V2VpZ2h0ID0gXFxcIlxcXCI7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY2hhcmFjdGVyU2l6ZSA9IHNpemU7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jaGFyU2l6ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcblxcdCAgICAgICAgICAgIHRoaXMuYWxsb3dCb2xkRm9udHMgPSBib2xkU2l6ZSAmJiBib2xkU2l6ZS53aWR0aCA9PT0gc2l6ZS53aWR0aCAmJiBib2xkU2l6ZS5oZWlnaHQgPT09IHNpemUuaGVpZ2h0O1xcblxcdCAgICAgICAgICAgIHRoaXMuX2VtaXQoXFxcImNoYW5nZUNoYXJhY3RlclNpemVcXFwiLCB7ZGF0YTogc2l6ZX0pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRwb2xsU2l6ZUNoYW5nZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRwb2xsU2l6ZUNoYW5nZXNUaW1lcilcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXI7XFxuXFx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBzZWxmLmNoZWNrRm9yU2l6ZUNoYW5nZXMoKTtcXG5cXHQgICAgICAgIH0sIDUwMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnNldFBvbGxpbmcgPSBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgIGlmICh2YWwpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRwb2xsU2l6ZUNoYW5nZXMoKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHBvbGxTaXplQ2hhbmdlc1RpbWVyKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRwb2xsU2l6ZUNoYW5nZXNUaW1lcjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kbWVhc3VyZVNpemVzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoQ0hBUl9DT1VOVCA9PT0gNTApIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmVjdCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgdHJ5IHsgXFxuXFx0ICAgICAgICAgICAgICAgcmVjdCA9IHRoaXMuJG1lYXN1cmVOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdCAgICAgICAgICAgIH0gY2F0Y2goZSkge1xcblxcdCAgICAgICAgICAgICAgIHJlY3QgPSB7d2lkdGg6IDAsIGhlaWdodDowIH07XFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICB2YXIgc2l6ZSA9IHtcXG5cXHQgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcXG5cXHQgICAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLyBDSEFSX0NPVU5UXFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHNpemUgPSB7XFxuXFx0ICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy4kbWVhc3VyZU5vZGUuY2xpZW50SGVpZ2h0LFxcblxcdCAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy4kbWVhc3VyZU5vZGUuY2xpZW50V2lkdGggLyBDSEFSX0NPVU5UXFxuXFx0ICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChzaXplLndpZHRoID09PSAwIHx8IHNpemUuaGVpZ2h0ID09PSAwKVxcblxcdCAgICAgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICAgICAgcmV0dXJuIHNpemU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG1lYXN1cmVDaGFyV2lkdGggPSBmdW5jdGlvbihjaCkge1xcblxcdCAgICAgICAgdGhpcy4kbWFpbi5pbm5lckhUTUwgPSBsYW5nLnN0cmluZ1JlcGVhdChjaCwgQ0hBUl9DT1VOVCk7XFxuXFx0ICAgICAgICB2YXIgcmVjdCA9IHRoaXMuJG1haW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0ICAgICAgICByZXR1cm4gcmVjdC53aWR0aCAvIENIQVJfQ09VTlQ7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmdldENoYXJhY3RlcldpZHRoID0gZnVuY3Rpb24oY2gpIHtcXG5cXHQgICAgICAgIHZhciB3ID0gdGhpcy5jaGFyU2l6ZXNbY2hdO1xcblxcdCAgICAgICAgaWYgKHcgPT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuY2hhclNpemVzW2NoXSA9IHRoaXMuJG1lYXN1cmVDaGFyV2lkdGgoY2gpIC8gdGhpcy4kY2hhcmFjdGVyU2l6ZS53aWR0aDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiB3O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy4kcG9sbFNpemVDaGFuZ2VzVGltZXIpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuZWwgJiYgdGhpcy5lbC5wYXJlbnROb2RlKVxcblxcdCAgICAgICAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcXG5cXHQgICAgfTtcXG5cXG5cXHR9KS5jYWxsKEZvbnRNZXRyaWNzLnByb3RvdHlwZSk7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL3ZpcnR1YWxfcmVuZGVyZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvZG9tXFxcIixcXFwiYWNlL2NvbmZpZ1xcXCIsXFxcImFjZS9saWIvdXNlcmFnZW50XFxcIixcXFwiYWNlL2xheWVyL2d1dHRlclxcXCIsXFxcImFjZS9sYXllci9tYXJrZXJcXFwiLFxcXCJhY2UvbGF5ZXIvdGV4dFxcXCIsXFxcImFjZS9sYXllci9jdXJzb3JcXFwiLFxcXCJhY2Uvc2Nyb2xsYmFyXFxcIixcXFwiYWNlL3Njcm9sbGJhclxcXCIsXFxcImFjZS9yZW5kZXJsb29wXFxcIixcXFwiYWNlL2xheWVyL2ZvbnRfbWV0cmljc1xcXCIsXFxcImFjZS9saWIvZXZlbnRfZW1pdHRlclxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIGRvbSA9IGFjZXF1aXJlKFxcXCIuL2xpYi9kb21cXFwiKTtcXG5cXHR2YXIgY29uZmlnID0gYWNlcXVpcmUoXFxcIi4vY29uZmlnXFxcIik7XFxuXFx0dmFyIHVzZXJhZ2VudCA9IGFjZXF1aXJlKFxcXCIuL2xpYi91c2VyYWdlbnRcXFwiKTtcXG5cXHR2YXIgR3V0dGVyTGF5ZXIgPSBhY2VxdWlyZShcXFwiLi9sYXllci9ndXR0ZXJcXFwiKS5HdXR0ZXI7XFxuXFx0dmFyIE1hcmtlckxheWVyID0gYWNlcXVpcmUoXFxcIi4vbGF5ZXIvbWFya2VyXFxcIikuTWFya2VyO1xcblxcdHZhciBUZXh0TGF5ZXIgPSBhY2VxdWlyZShcXFwiLi9sYXllci90ZXh0XFxcIikuVGV4dDtcXG5cXHR2YXIgQ3Vyc29yTGF5ZXIgPSBhY2VxdWlyZShcXFwiLi9sYXllci9jdXJzb3JcXFwiKS5DdXJzb3I7XFxuXFx0dmFyIEhTY3JvbGxCYXIgPSBhY2VxdWlyZShcXFwiLi9zY3JvbGxiYXJcXFwiKS5IU2Nyb2xsQmFyO1xcblxcdHZhciBWU2Nyb2xsQmFyID0gYWNlcXVpcmUoXFxcIi4vc2Nyb2xsYmFyXFxcIikuVlNjcm9sbEJhcjtcXG5cXHR2YXIgUmVuZGVyTG9vcCA9IGFjZXF1aXJlKFxcXCIuL3JlbmRlcmxvb3BcXFwiKS5SZW5kZXJMb29wO1xcblxcdHZhciBGb250TWV0cmljcyA9IGFjZXF1aXJlKFxcXCIuL2xheWVyL2ZvbnRfbWV0cmljc1xcXCIpLkZvbnRNZXRyaWNzO1xcblxcdHZhciBFdmVudEVtaXR0ZXIgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcjtcXG5cXHR2YXIgZWRpdG9yQ3NzID0gXFxcIi5hY2VfZWRpdG9yIHtcXFxcXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcXFxcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcXFxcXG5cXHRmb250OiAxMnB4L25vcm1hbCAnTW9uYWNvJywgJ01lbmxvJywgJ1VidW50dSBNb25vJywgJ0NvbnNvbGFzJywgJ3NvdXJjZS1jb2RlLXBybycsIG1vbm9zcGFjZTtcXFxcXFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9zY3JvbGxlciB7XFxcXFxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXFxcXFxuXFx0dG9wOiAwO1xcXFxcXG5cXHRib3R0b206IDA7XFxcXFxcblxcdGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxcXFxcblxcdC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXFxcXFxuXFx0LW1vei11c2VyLXNlbGVjdDogbm9uZTtcXFxcXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXFxcXFxuXFx0dXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdGN1cnNvcjogdGV4dDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2NvbnRlbnQge1xcXFxcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxcXFxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0LXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxcXG5cXHRtaW4td2lkdGg6IDEwMCU7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9kcmFnZ2luZyAuYWNlX3Njcm9sbGVyOmJlZm9yZXtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHR0b3A6IDA7XFxcXFxcblxcdGxlZnQ6IDA7XFxcXFxcblxcdHJpZ2h0OiAwO1xcXFxcXG5cXHRib3R0b206IDA7XFxcXFxcblxcdGNvbnRlbnQ6ICcnO1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDI1MCwgMjUwLCAyNTAsIDAuMDEpO1xcXFxcXG5cXHR6LWluZGV4OiAxMDAwO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZHJhZ2dpbmcuYWNlX2RhcmsgLmFjZV9zY3JvbGxlcjpiZWZvcmV7XFxcXFxcblxcdGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wMSk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9zZWxlY3RpbmcsIC5hY2Vfc2VsZWN0aW5nICoge1xcXFxcXG5cXHRjdXJzb3I6IHRleHQgIWltcG9ydGFudDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2d1dHRlciB7XFxcXFxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0b3ZlcmZsb3cgOiBoaWRkZW47XFxcXFxcblxcdHdpZHRoOiBhdXRvO1xcXFxcXG5cXHR0b3A6IDA7XFxcXFxcblxcdGJvdHRvbTogMDtcXFxcXFxuXFx0bGVmdDogMDtcXFxcXFxuXFx0Y3Vyc29yOiBkZWZhdWx0O1xcXFxcXG5cXHR6LWluZGV4OiA0O1xcXFxcXG5cXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdHVzZXItc2VsZWN0OiBub25lO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZ3V0dGVyLWFjdGl2ZS1saW5lIHtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHRsZWZ0OiAwO1xcXFxcXG5cXHRyaWdodDogMDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3Njcm9sbGVyLmFjZV9zY3JvbGwtbGVmdCB7XFxcXFxcblxcdGJveC1zaGFkb3c6IDE3cHggMCAxNnB4IC0xNnB4IHJnYmEoMCwgMCwgMCwgMC40KSBpbnNldDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2d1dHRlci1jZWxsIHtcXFxcXFxuXFx0cGFkZGluZy1sZWZ0OiAxOXB4O1xcXFxcXG5cXHRwYWRkaW5nLXJpZ2h0OiA2cHg7XFxcXFxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9ndXR0ZXItY2VsbC5hY2VfZXJyb3Ige1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQU1BQUFBb0xROVRBQUFCT0ZCTVZFWC8vLy8vLy8vL1FSc3dGQWIvVWk0d0ZBWXdGQVl3RkFhV0dBZkRSeW16T1NIL1B4c3dGQWIvU2lVd0ZBWXdGQWJVUFJ2alFpRGxsb2c1SGhIZFJ5YnNUaTMvVHl2OVRpcitTeWovVUMzLy8vL1h1cmViTUJJd0ZBYi9SU0hiUHgvZ1V6ZmR3TDNrek1pdktCQXdGQWJidmJuaFB4NjZOaG93RkFZd0ZBYVpKZzh3RkFheEtCRFp1cmYvUkI2bU14Yi9TQ013RkFZd0ZBYnhRQjMrUkI0d0ZBYi9RaHk0T2grNFFpZmJOUmN3RkFZd0ZBWXdGQWIvUVJ6ZE5oZ3dGQVl3RkFiYXY3di9VeTdvYUU2OE1CSzVMeExld3IvcjJOWGV3THN3RkFheEp3NHdGQWJrUFJ5MlB5WXdGQWF4S2hMbTF0TXdGQWF6UGlRd0ZBYVVHQWIvUUJyZk94M2J2cnYvVkMvbWFFNHdGQWJSUEJxNk1STzhReW5ldzhEcDJ0amZ3YjB3RkFieDZlanU1K2J5NnVuczR1SDkvZjM2K3ZyL0drSGpBQUFBWW5SU1RsTUFHdCs2NHJuV3UvYm84ZUFBNEluSDMrRHdvTjdqNGVMaTR4UDk5TmZnNCtiKy91OUIvZURzMU1EMW1PNys0UEhnMk1YYTM0N2c3dkRpek1MTjRlRytQdjdpNWV2cy92Nzl5dTdTMy9EVjcvNDk4WXYyNGVIKzR1ZlEzT3p1L3Y3K3kxM3NScXdBQUFETFNVUkJWSGphWmMvWERzRmdHSUJodERyc2hsaXRtazJJcmJIRnFMMnB2WGYvKzc4RFBva2o3K0Z6OXFwVS85VVhKSWxobVBhVGFRNlFQYXowbW0rNWd3a2dvdmNWNkdaemQ1SnRDUXdnc3hvSE92Sk8xNWtsZVJMQW5NZ0hGSUVTVUVQbWF3QjluZ21lbFR0aXB3d2ZBU2lseE9MeWlWNVVWVXlWQWZiRzBjQ1BIaWcrR0JrekFFTkhTMEFzdFZGNmJhY1pJT3pnTG14c0hidDJPZWNOZ0pDODNKRVJtZVBVWXE4QVJHa0p4Nlh0RnNkZGRCUWdaRTJuUFI2Q0lDWmhhd2pBNEZiL2NodiszOTlrZlIrTU1NREdPUUFBQUFCSlJVNUVya0pnZ2c9PVxcXFxcXFwiKTtcXFxcXFxuXFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXFxcXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogMnB4IGNlbnRlcjtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2d1dHRlci1jZWxsLmFjZV93YXJuaW5nIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXFxcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FNQUFBQW9MUTlUQUFBQW1WQk1WRVgvLy84QUFBRC8vLzhBQUFBQUFBQlBTemIvNXNBQUFBQi9ibEgvNzN6L3Vsa0FBQUFBQUFEODVwa0FBQUFBQUFBQ0FnUC92R3ovcmtEZXJHYkdyVjcvcGtRSUNBZi8vLy9lMElzQUFBRC9vRUQvcVR2aHJuVUFBQUQveUhEL25qY0FBQUR1djJyL256Ly9vVGovcDA2NG9HZi96SEFBQUFBOU5pci90RklBQUFEL3RsVGl1V2YvdGtJQUFBQ3luWEVBQUFBQUFBQXRJUlc3ekJwQkFBQUFNM1JTVGxNQUFCUjFtN1JYTzhMbjMxWjM2elQrbmVYZTVPem9vUkRmbitUWjRwM2gyaFRmNHQzazN1Y3lyTjFLNStYYWtzNTJTZnM5Q1hnckFBQUFqa2xFUVZSNDJvM1BiUStDSUJRRllFd2JvUGhTWWdvWXVuSXFxTG42L3o4dVlkSDhWbWRudTl2ejRXd1hnTi94VFBSRDIrc2dPY1pqc2dlL3doWFpnVWFZWXZUOFFudUphVXJqckhVUXJlR2N6dUVhZlFDTy9TSlR1ZlRicm9Xc1Bnc2xsVmhxM3dKRWsyalVTelgzQ1VFREpDODQ3MDdkalJjNU1UQVF4b0xndXBXUndXNlVCNWZTKytOVjhBYk9aZ25zQzdCcEVBQUFBQUJKUlU1RXJrSmdnZz09XFxcXFxcXCIpO1xcXFxcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiAycHggY2VudGVyO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZ3V0dGVyLWNlbGwuYWNlX2luZm8ge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQUFBQUFBNm1LQzlBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUFKMFVrNVRBQUIyazgwNEFBQUFQa2xFUVZRWTAyTmdJQjY4UXVPM3RpTHpuakF3cEtUZ055RGJNZWd3aXNDSFpVRVRVWlYwWnFPcXVCcFhqMnJ0bnBTSlQxQUVublJtTDJPZ0dnQUFJS2tSUWFwMmh0Z0FBQUFBU1VWT1JLNUNZSUk9XFxcXFxcXCIpO1xcXFxcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiAycHggY2VudGVyO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZGFyayAuYWNlX2d1dHRlci1jZWxsLmFjZV9pbmZvIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXFxcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQkFNQUFBRHQzZUpTQUFBQUpGQk1WRVVBQUFDaG9hR0FnSUFxS2lxK3ZyNnRyYTFaV1ZtVWxKU2JtNXM4UER4dWJtNTZlbnJkZ3pnM0FBQUFBWFJTVGxNQVFPYllaZ0FBQUNsSlJFRlVlTnBqWU1BUGRzTVlIZWd5SlpGUUJsc1VsTUZWQ1dVWUtrQVpNeFpBR2R4bERNUUJBRytUQlA0QjZSeUpBQUFBQUVsRlRrU3VRbUNDXFxcXFxcXCIpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2Nyb2xsYmFyIHtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHRyaWdodDogMDtcXFxcXFxuXFx0Ym90dG9tOiAwO1xcXFxcXG5cXHR6LWluZGV4OiA2O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2Nyb2xsYmFyLWlubmVyIHtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHRjdXJzb3I6IHRleHQ7XFxcXFxcblxcdGxlZnQ6IDA7XFxcXFxcblxcdHRvcDogMDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3Njcm9sbGJhci12e1xcXFxcXG5cXHRvdmVyZmxvdy14OiBoaWRkZW47XFxcXFxcblxcdG92ZXJmbG93LXk6IHNjcm9sbDtcXFxcXFxuXFx0dG9wOiAwO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2Nyb2xsYmFyLWgge1xcXFxcXG5cXHRvdmVyZmxvdy14OiBzY3JvbGw7XFxcXFxcblxcdG92ZXJmbG93LXk6IGhpZGRlbjtcXFxcXFxuXFx0bGVmdDogMDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3ByaW50LW1hcmdpbiB7XFxcXFxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0aGVpZ2h0OiAxMDAlO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfdGV4dC1pbnB1dCB7XFxcXFxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0ei1pbmRleDogMDtcXFxcXFxuXFx0d2lkdGg6IDAuNWVtO1xcXFxcXG5cXHRoZWlnaHQ6IDFlbTtcXFxcXFxuXFx0b3BhY2l0eTogMDtcXFxcXFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxcXFxcblxcdC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXFxcXFxuXFx0YXBwZWFyYW5jZTogbm9uZTtcXFxcXFxuXFx0Ym9yZGVyOiBub25lO1xcXFxcXG5cXHRyZXNpemU6IG5vbmU7XFxcXFxcblxcdG91dGxpbmU6IG5vbmU7XFxcXFxcblxcdG92ZXJmbG93OiBoaWRkZW47XFxcXFxcblxcdGZvbnQ6IGluaGVyaXQ7XFxcXFxcblxcdHBhZGRpbmc6IDAgMXB4O1xcXFxcXG5cXHRtYXJnaW46IDAgLTFweDtcXFxcXFxuXFx0dGV4dC1pbmRlbnQ6IC0xZW07XFxcXFxcblxcdC1tcy11c2VyLXNlbGVjdDogdGV4dDtcXFxcXFxuXFx0LW1vei11c2VyLXNlbGVjdDogdGV4dDtcXFxcXFxuXFx0LXdlYmtpdC11c2VyLXNlbGVjdDogdGV4dDtcXFxcXFxuXFx0dXNlci1zZWxlY3Q6IHRleHQ7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV90ZXh0LWlucHV0LmFjZV9jb21wb3NpdGlvbiB7XFxcXFxcblxcdGJhY2tncm91bmQ6IGluaGVyaXQ7XFxcXFxcblxcdGNvbG9yOiBpbmhlcml0O1xcXFxcXG5cXHR6LWluZGV4OiAxMDAwO1xcXFxcXG5cXHRvcGFjaXR5OiAxO1xcXFxcXG5cXHR0ZXh0LWluZGVudDogMDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2xheWVyIHtcXFxcXFxuXFx0ei1pbmRleDogMTtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcXFxcXG5cXHR3aGl0ZS1zcGFjZTogcHJlO1xcXFxcXG5cXHRoZWlnaHQ6IDEwMCU7XFxcXFxcblxcdHdpZHRoOiAxMDAlO1xcXFxcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9ndXR0ZXItbGF5ZXIge1xcXFxcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxcXFxcblxcdHdpZHRoOiBhdXRvO1xcXFxcXG5cXHR0ZXh0LWFsaWduOiByaWdodDtcXFxcXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV90ZXh0LWxheWVyIHtcXFxcXFxuXFx0Zm9udDogaW5oZXJpdCAhaW1wb3J0YW50O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfY2prIHtcXFxcXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcXFxcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9jdXJzb3ItbGF5ZXIge1xcXFxcXG5cXHR6LWluZGV4OiA0O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfY3Vyc29yIHtcXFxcXFxuXFx0ei1pbmRleDogNDtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Ym9yZGVyLWxlZnQ6IDJweCBzb2xpZFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2xpbS1jdXJzb3JzIC5hY2VfY3Vyc29yIHtcXFxcXFxuXFx0Ym9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX292ZXJ3cml0ZS1jdXJzb3JzIC5hY2VfY3Vyc29yIHtcXFxcXFxuXFx0Ym9yZGVyLWxlZnQtd2lkdGg6IDA7XFxcXFxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2hpZGRlbi1jdXJzb3JzIC5hY2VfY3Vyc29yIHtcXFxcXFxuXFx0b3BhY2l0eTogMC4yO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc21vb3RoLWJsaW5raW5nIC5hY2VfY3Vyc29yIHtcXFxcXFxuXFx0LXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuMThzO1xcXFxcXG5cXHR0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMThzO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZWRpdG9yLmFjZV9tdWx0aXNlbGVjdCAuYWNlX2N1cnNvciB7XFxcXFxcblxcdGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGVwLCAuYWNlX21hcmtlci1sYXllciAuYWNlX3N0YWNrIHtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHR6LWluZGV4OiAzO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0aW9uIHtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHR6LWluZGV4OiA1O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfbWFya2VyLWxheWVyIC5hY2VfYnJhY2tldCB7XFxcXFxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0ei1pbmRleDogNjtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHR6LWluZGV4OiAyO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0ZWQtd29yZCB7XFxcXFxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0ei1pbmRleDogNDtcXFxcXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxcXG5cXHQtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9saW5lIC5hY2VfZm9sZCB7XFxcXFxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0LXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxcXG5cXHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxcXFxcblxcdGhlaWdodDogMTFweDtcXFxcXFxuXFx0bWFyZ2luLXRvcDogLTJweDtcXFxcXFxuXFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcXFxcXFxuXFx0YmFja2dyb3VuZC1pbWFnZTpcXFxcXFxuXFx0dXJsKFxcXFxcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCRUFBQUFKQ0FZQUFBRFU2TWNNQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFKcEpSRUZVZU5waS9QLy9Qd09sZ0FYR1lHUmtsQVZTb2tEOEdtandZMXdhc0tsalFwWUFDdHBDRmVBRGNIVlFmUXlNUUF3endBWkkzd0pLdkNMa2ZLQmFNU0NsQmxSN0JPUWlrQ0ZHUUVFcklIMFZxa2FiaUdDQXF3VWFkQXpaSlJ4UXIvMGd3aVhJYWw4elFRUG5OVlRnSjFUZGF3TDBUNWdCSVAxTVVKTmhCdjJIS29RSEhqcU5yQTRXTzR6WTBnbHlOS0xUMktJZklNQUFRc2RnR2lYdmduWUFBQUFBU1VWT1JLNUNZSUk9XFxcXFxcXCIpLFxcXFxcXG5cXHR1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQTNDQVlBQUFETk5pQTVBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUNKSlJFRlVlTnBpK1AvL2Z4Z1RBd1BEQnhEeEQwNzhSU1grWWVFeURGTUNJTUFBSTNJTm1YaXdmMllBQUFBQVNVVk9SSzVDWUlJPVxcXFxcXFwiKTtcXFxcXFxuXFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdCwgcmVwZWF0LXg7XFxcXFxcblxcdGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXIsIHRvcCBsZWZ0O1xcXFxcXG5cXHRjb2xvcjogdHJhbnNwYXJlbnQ7XFxcXFxcblxcdGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcXFxcXG5cXHRib3JkZXItcmFkaXVzOiAycHg7XFxcXFxcblxcdGN1cnNvcjogcG9pbnRlcjtcXFxcXFxuXFx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9kYXJrIC5hY2VfZm9sZCB7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9mb2xkOmhvdmVye1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOlxcXFxcXG5cXHR1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJFQUFBQUpDQVlBQUFEVTZNY01BQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQUpwSlJFRlVlTnBpL1AvL1B3T2xnQVhHWUdSa2xBVlNva0Q4R21qd1kxd2FzS2xqUXBZQUN0cENGZUFEY0hWUWZReU1RQXd6d0FaSTN3Skt2Q0xrZktCYU1TQ2xCbFI3Qk9RaWtDRkdRRUVySUgwVnFrYWJpR0NBcXdVYWRBelpKUnhRci8wZ3dpWElhbDh6UVFQbk5WVGdKMVRkYXdMMFQ1Z0JJUDFNVUpOaEJ2MkhLb1FISGpxTnJBNFdPNHpZMGdseU5LTFQyS0lmSU1BQVFzZGdHaVh2Z25ZQUFBQUFTVVZPUks1Q1lJST1cXFxcXFxcIiksXFxcXFxcblxcdHVybChcXFxcXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQUVBQUFBM0NBWUFBQUROTmlBNUFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBQ0JKUkVGVWVOcGkrUC8vZno0VEF3UERaeER4RDVYNGk1ZkxNRXdKZ0FBREFFUFZEYmpOdzg3WkFBQUFBRWxGVGtTdVFtQ0NcXFxcXFxcIik7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV90b29sdGlwIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI0ZGRjtcXFxcXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCB0cmFuc3BhcmVudCwgcmdiYSgwLCAwLCAwLCAwLjEpKTtcXFxcXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgdHJhbnNwYXJlbnQsIHJnYmEoMCwgMCwgMCwgMC4xKSk7XFxcXFxcblxcdGJvcmRlcjogMXB4IHNvbGlkIGdyYXk7XFxcXFxcblxcdGJvcmRlci1yYWRpdXM6IDFweDtcXFxcXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcXFxcXFxuXFx0Y29sb3I6IGJsYWNrO1xcXFxcXG5cXHRtYXgtd2lkdGg6IDEwMCU7XFxcXFxcblxcdHBhZGRpbmc6IDNweCA0cHg7XFxcXFxcblxcdHBvc2l0aW9uOiBmaXhlZDtcXFxcXFxuXFx0ei1pbmRleDogOTk5OTk5O1xcXFxcXG5cXHQtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Y3Vyc29yOiBkZWZhdWx0O1xcXFxcXG5cXHR3aGl0ZS1zcGFjZTogcHJlO1xcXFxcXG5cXHR3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxcXFxcblxcdGxpbmUtaGVpZ2h0OiBub3JtYWw7XFxcXFxcblxcdGZvbnQtc3R5bGU6IG5vcm1hbDtcXFxcXFxuXFx0Zm9udC13ZWlnaHQ6IG5vcm1hbDtcXFxcXFxuXFx0bGV0dGVyLXNwYWNpbmc6IG5vcm1hbDtcXFxcXFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9mb2xkaW5nLWVuYWJsZWQgPiAuYWNlX2d1dHRlci1jZWxsIHtcXFxcXFxuXFx0cGFkZGluZy1yaWdodDogMTNweDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2ZvbGQtd2lkZ2V0IHtcXFxcXFxuXFx0LW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXFxcXG5cXHQtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdG1hcmdpbjogMCAtMTJweCAwIDFweDtcXFxcXFxuXFx0ZGlzcGxheTogbm9uZTtcXFxcXFxuXFx0d2lkdGg6IDExcHg7XFxcXFxcblxcdHZlcnRpY2FsLWFsaWduOiB0b3A7XFxcXFxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFxcXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFORWxFUVZSNDJtV0tzUTBBTUF6QzhpeExscnpRanptQmlFanAwQTZXd0JDU1BnS0FYb0xrcVNvdDduTjN5TXdSN3BaMzJOenBLa1ZvREJVeEtBQUFBQUJKUlU1RXJrSmdnZz09XFxcXFxcXCIpO1xcXFxcXG5cXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcXFxcXG5cXHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxcXFxcblxcdGJvcmRlci1yYWRpdXM6IDNweDtcXFxcXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxcXFxcblxcdGN1cnNvcjogcG9pbnRlcjtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2ZvbGRpbmctZW5hYmxlZCAuYWNlX2ZvbGQtd2lkZ2V0IHtcXFxcXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrOyAgIFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZm9sZC13aWRnZXQuYWNlX2VuZCB7XFxcXFxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFxcXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFORWxFUVZSNDJtM0h3UWtBTUFoRDBZenNSY2hGS0k3c0Fpa2VXa3J4d1NjRUIwbmg1ZTdLVFBXaW1aa2k0dFlmVmJYK01ObDRweVpYZWpVTzFRQUFBQUJKUlU1RXJrSmdnZz09XFxcXFxcXCIpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZm9sZC13aWRnZXQuYWNlX2Nsb3NlZCB7XFxcXFxcblxcdGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFxcXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQU1BQUFBR0NBWUFBQUFHNVNRTUFBQUFPVWxFUVZSNDJqWEt3UWtBTUFnRHdLd3FLRDRFd1EyNnNTT2tWV2pnSUlIQXpQaUNnYXFpcW5KSFpuS0lDQkVSSE4xOTRPNWI5dmJMdUFWUkwrbDBZV25aQUFBQUFFbEZUa1N1UW1DQ1hBPT1cXFxcXFxcIik7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9mb2xkLXdpZGdldDpob3ZlciB7XFxcXFxcblxcdGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4zKTtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcXFxcXG5cXHRib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZm9sZC13aWRnZXQ6YWN0aXZlIHtcXFxcXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQpO1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcXFxcXG5cXHRib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0IHtcXFxcXFxuXFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKFxcXFxcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFGQ0FZQUFBQ05ieWJsQUFBQUhrbEVRVlFJVzJQNC8vOC9Bem9HRVE3b0dDYUxMQWhXaVN3QjE0NkJBUUNTVFBZb2NxVDBBQUFBQUVsRlRrU3VRbUNDXFxcXFxcXCIpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0LmFjZV9lbmQge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFVQUFBQUZDQVlBQUFDTmJ5YmxBQUFBSDBsRVFWUUlXMlA0Ly84L0F4UTd3TmpJQWpETWdDNEF4akNWS0JpcklBQUYwa3oycmxoeHBBQUFBQUJKUlU1RXJrSmdnZz09XFxcXFxcXCIpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZGFyayAuYWNlX2ZvbGQtd2lkZ2V0LmFjZV9jbG9zZWQge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFNQUFBQUZDQVlBQUFDQWNWYWlBQUFBSEVsRVFWUUlXMlA0Ly8rL0F4QXpnREFEbE9PQXpuSEFLZ1BXQXdBUmppOFVJRFRmUVFBQUFBQkpSVTVFcmtKZ2dnPT1cXFxcXFxcIik7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQ6aG92ZXIge1xcXFxcXG5cXHRib3gtc2hhZG93OiAwIDFweCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9kYXJrIC5hY2VfZm9sZC13aWRnZXQ6YWN0aXZlIHtcXFxcXFxuXFx0Ym94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX2ZvbGQtd2lkZ2V0LmFjZV9pbnZhbGlkIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI0ZGQjRCNDtcXFxcXFxuXFx0Ym9yZGVyLWNvbG9yOiAjREU1NTU1O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZmFkZS1mb2xkLXdpZGdldHMgLmFjZV9mb2xkLXdpZGdldCB7XFxcXFxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjRzIGVhc2UgMC4wNXM7XFxcXFxcblxcdHRyYW5zaXRpb246IG9wYWNpdHkgMC40cyBlYXNlIDAuMDVzO1xcXFxcXG5cXHRvcGFjaXR5OiAwO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfZmFkZS1mb2xkLXdpZGdldHM6aG92ZXIgLmFjZV9mb2xkLXdpZGdldCB7XFxcXFxcblxcdC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjA1cyBlYXNlIDAuMDVzO1xcXFxcXG5cXHR0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMDVzIGVhc2UgMC4wNXM7XFxcXFxcblxcdG9wYWNpdHk6MTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3VuZGVybGluZSB7XFxcXFxcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfYm9sZCB7XFxcXFxcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfbm9ib2xkIC5hY2VfYm9sZCB7XFxcXFxcblxcdGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9pdGFsaWMge1xcXFxcXG5cXHRmb250LXN0eWxlOiBpdGFsaWM7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9lcnJvci1tYXJrZXIge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMCwgMCwwLjIpO1xcXFxcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxcXFxcblxcdHotaW5kZXg6IDk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9oaWdobGlnaHQtbWFya2VyIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMCwwLjIpO1xcXFxcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxcXFxcblxcdHotaW5kZXg6IDg7XFxcXFxcblxcdH1cXFxcXFxuXFx0XFxcIjtcXG5cXG5cXHRkb20uaW1wb3J0Q3NzU3RyaW5nKGVkaXRvckNzcywgXFxcImFjZV9lZGl0b3JcXFwiKTtcXG5cXG5cXHR2YXIgVmlydHVhbFJlbmRlcmVyID0gZnVuY3Rpb24oY29udGFpbmVyLCB0aGVtZSkge1xcblxcdCAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcblxcdCAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIHRoaXMuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yID0gIXVzZXJhZ2VudC5pc09sZElFO1xcblxcblxcdCAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFxcXCJhY2VfZWRpdG9yXFxcIik7XFxuXFxuXFx0ICAgIHRoaXMuc2V0VGhlbWUodGhlbWUpO1xcblxcblxcdCAgICB0aGlzLiRndXR0ZXIgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIHRoaXMuJGd1dHRlci5jbGFzc05hbWUgPSBcXFwiYWNlX2d1dHRlclxcXCI7XFxuXFx0ICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJGd1dHRlcik7XFxuXFxuXFx0ICAgIHRoaXMuc2Nyb2xsZXIgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIHRoaXMuc2Nyb2xsZXIuY2xhc3NOYW1lID0gXFxcImFjZV9zY3JvbGxlclxcXCI7XFxuXFx0ICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsZXIpO1xcblxcblxcdCAgICB0aGlzLmNvbnRlbnQgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSBcXFwiYWNlX2NvbnRlbnRcXFwiO1xcblxcdCAgICB0aGlzLnNjcm9sbGVyLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XFxuXFxuXFx0ICAgIHRoaXMuJGd1dHRlckxheWVyID0gbmV3IEd1dHRlckxheWVyKHRoaXMuJGd1dHRlcik7XFxuXFx0ICAgIHRoaXMuJGd1dHRlckxheWVyLm9uKFxcXCJjaGFuZ2VHdXR0ZXJXaWR0aFxcXCIsIHRoaXMub25HdXR0ZXJSZXNpemUuYmluZCh0aGlzKSk7XFxuXFxuXFx0ICAgIHRoaXMuJG1hcmtlckJhY2sgPSBuZXcgTWFya2VyTGF5ZXIodGhpcy5jb250ZW50KTtcXG5cXG5cXHQgICAgdmFyIHRleHRMYXllciA9IHRoaXMuJHRleHRMYXllciA9IG5ldyBUZXh0TGF5ZXIodGhpcy5jb250ZW50KTtcXG5cXHQgICAgdGhpcy5jYW52YXMgPSB0ZXh0TGF5ZXIuZWxlbWVudDtcXG5cXG5cXHQgICAgdGhpcy4kbWFya2VyRnJvbnQgPSBuZXcgTWFya2VyTGF5ZXIodGhpcy5jb250ZW50KTtcXG5cXG5cXHQgICAgdGhpcy4kY3Vyc29yTGF5ZXIgPSBuZXcgQ3Vyc29yTGF5ZXIodGhpcy5jb250ZW50KTtcXG5cXHQgICAgdGhpcy4kaG9yaXpTY3JvbGwgPSBmYWxzZTtcXG5cXHQgICAgdGhpcy4kdlNjcm9sbCA9IGZhbHNlO1xcblxcblxcdCAgICB0aGlzLnNjcm9sbEJhciA9IFxcblxcdCAgICB0aGlzLnNjcm9sbEJhclYgPSBuZXcgVlNjcm9sbEJhcih0aGlzLmNvbnRhaW5lciwgdGhpcyk7XFxuXFx0ICAgIHRoaXMuc2Nyb2xsQmFySCA9IG5ldyBIU2Nyb2xsQmFyKHRoaXMuY29udGFpbmVyLCB0aGlzKTtcXG5cXHQgICAgdGhpcy5zY3JvbGxCYXJWLmFkZEV2ZW50TGlzdGVuZXIoXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmICghX3NlbGYuJHNjcm9sbEFuaW1hdGlvbilcXG5cXHQgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcChlLmRhdGEgLSBfc2VsZi5zY3JvbGxNYXJnaW4udG9wKTtcXG5cXHQgICAgfSk7XFxuXFx0ICAgIHRoaXMuc2Nyb2xsQmFySC5hZGRFdmVudExpc3RlbmVyKFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAoIV9zZWxmLiRzY3JvbGxBbmltYXRpb24pXFxuXFx0ICAgICAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KGUuZGF0YSAtIF9zZWxmLnNjcm9sbE1hcmdpbi5sZWZ0KTtcXG5cXHQgICAgfSk7XFxuXFxuXFx0ICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcXG5cXHQgICAgdGhpcy5zY3JvbGxMZWZ0ID0gMDtcXG5cXG5cXHQgICAgdGhpcy5jdXJzb3JQb3MgPSB7XFxuXFx0ICAgICAgICByb3cgOiAwLFxcblxcdCAgICAgICAgY29sdW1uIDogMFxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRmb250TWV0cmljcyA9IG5ldyBGb250TWV0cmljcyh0aGlzLmNvbnRhaW5lciwgNTAwKTtcXG5cXHQgICAgdGhpcy4kdGV4dExheWVyLiRzZXRGb250TWV0cmljcyh0aGlzLiRmb250TWV0cmljcyk7XFxuXFx0ICAgIHRoaXMuJHRleHRMYXllci5hZGRFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VDaGFyYWN0ZXJTaXplXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgX3NlbGYudXBkYXRlQ2hhcmFjdGVyU2l6ZSgpO1xcblxcdCAgICAgICAgX3NlbGYub25SZXNpemUodHJ1ZSwgX3NlbGYuZ3V0dGVyV2lkdGgsIF9zZWxmLiRzaXplLndpZHRoLCBfc2VsZi4kc2l6ZS5oZWlnaHQpO1xcblxcdCAgICAgICAgX3NlbGYuX3NpZ25hbChcXFwiY2hhbmdlQ2hhcmFjdGVyU2l6ZVxcXCIsIGUpO1xcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy4kc2l6ZSA9IHtcXG5cXHQgICAgICAgIHdpZHRoOiAwLFxcblxcdCAgICAgICAgaGVpZ2h0OiAwLFxcblxcdCAgICAgICAgc2Nyb2xsZXJIZWlnaHQ6IDAsXFxuXFx0ICAgICAgICBzY3JvbGxlcldpZHRoOiAwLFxcblxcdCAgICAgICAgJGRpcnR5OiB0cnVlXFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMubGF5ZXJDb25maWcgPSB7XFxuXFx0ICAgICAgICB3aWR0aCA6IDEsXFxuXFx0ICAgICAgICBwYWRkaW5nIDogMCxcXG5cXHQgICAgICAgIGZpcnN0Um93IDogMCxcXG5cXHQgICAgICAgIGZpcnN0Um93U2NyZWVuOiAwLFxcblxcdCAgICAgICAgbGFzdFJvdyA6IDAsXFxuXFx0ICAgICAgICBsaW5lSGVpZ2h0IDogMCxcXG5cXHQgICAgICAgIGNoYXJhY3RlcldpZHRoIDogMCxcXG5cXHQgICAgICAgIG1pbkhlaWdodCA6IDEsXFxuXFx0ICAgICAgICBtYXhIZWlnaHQgOiAxLFxcblxcdCAgICAgICAgb2Zmc2V0IDogMCxcXG5cXHQgICAgICAgIGhlaWdodCA6IDEsXFxuXFx0ICAgICAgICBndXR0ZXJPZmZzZXQ6IDFcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuc2Nyb2xsTWFyZ2luID0ge1xcblxcdCAgICAgICAgbGVmdDogMCxcXG5cXHQgICAgICAgIHJpZ2h0OiAwLFxcblxcdCAgICAgICAgdG9wOiAwLFxcblxcdCAgICAgICAgYm90dG9tOiAwLFxcblxcdCAgICAgICAgdjogMCxcXG5cXHQgICAgICAgIGg6IDBcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kbG9vcCA9IG5ldyBSZW5kZXJMb29wKFxcblxcdCAgICAgICAgdGhpcy4kcmVuZGVyQ2hhbmdlcy5iaW5kKHRoaXMpLFxcblxcdCAgICAgICAgdGhpcy5jb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlld1xcblxcdCAgICApO1xcblxcdCAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xcblxcblxcdCAgICB0aGlzLnVwZGF0ZUNoYXJhY3RlclNpemUoKTtcXG5cXHQgICAgdGhpcy5zZXRQYWRkaW5nKDQpO1xcblxcdCAgICBjb25maWcucmVzZXRPcHRpb25zKHRoaXMpO1xcblxcdCAgICBjb25maWcuX2VtaXQoXFxcInJlbmRlcmVyXFxcIiwgdGhpcyk7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIHRoaXMuQ0hBTkdFX0NVUlNPUiA9IDE7XFxuXFx0ICAgIHRoaXMuQ0hBTkdFX01BUktFUiA9IDI7XFxuXFx0ICAgIHRoaXMuQ0hBTkdFX0dVVFRFUiA9IDQ7XFxuXFx0ICAgIHRoaXMuQ0hBTkdFX1NDUk9MTCA9IDg7XFxuXFx0ICAgIHRoaXMuQ0hBTkdFX0xJTkVTID0gMTY7XFxuXFx0ICAgIHRoaXMuQ0hBTkdFX1RFWFQgPSAzMjtcXG5cXHQgICAgdGhpcy5DSEFOR0VfU0laRSA9IDY0O1xcblxcdCAgICB0aGlzLkNIQU5HRV9NQVJLRVJfQkFDSyA9IDEyODtcXG5cXHQgICAgdGhpcy5DSEFOR0VfTUFSS0VSX0ZST05UID0gMjU2O1xcblxcdCAgICB0aGlzLkNIQU5HRV9GVUxMID0gNTEyO1xcblxcdCAgICB0aGlzLkNIQU5HRV9IX1NDUk9MTCA9IDEwMjQ7XFxuXFxuXFx0ICAgIG9vcC5pbXBsZW1lbnQodGhpcywgRXZlbnRFbWl0dGVyKTtcXG5cXG5cXHQgICAgdGhpcy51cGRhdGVDaGFyYWN0ZXJTaXplID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kdGV4dExheWVyLmFsbG93Qm9sZEZvbnRzICE9IHRoaXMuJGFsbG93Qm9sZEZvbnRzKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kYWxsb3dCb2xkRm9udHMgPSB0aGlzLiR0ZXh0TGF5ZXIuYWxsb3dCb2xkRm9udHM7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXRTdHlsZShcXFwiYWNlX25vYm9sZFxcXCIsICF0aGlzLiRhbGxvd0JvbGRGb250cyk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLmxheWVyQ29uZmlnLmNoYXJhY3RlcldpZHRoID1cXG5cXHQgICAgICAgIHRoaXMuY2hhcmFjdGVyV2lkdGggPSB0aGlzLiR0ZXh0TGF5ZXIuZ2V0Q2hhcmFjdGVyV2lkdGgoKTtcXG5cXHQgICAgICAgIHRoaXMubGF5ZXJDb25maWcubGluZUhlaWdodCA9XFxuXFx0ICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSB0aGlzLiR0ZXh0TGF5ZXIuZ2V0TGluZUhlaWdodCgpO1xcblxcdCAgICAgICAgdGhpcy4kdXBkYXRlUHJpbnRNYXJnaW4oKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTZXNzaW9uID0gZnVuY3Rpb24oc2Vzc2lvbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbilcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uZG9jLm9mZihcXFwiY2hhbmdlTmV3TGluZU1vZGVcXFwiLCB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUpO1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcXG5cXHQgICAgICAgIGlmIChzZXNzaW9uICYmIHRoaXMuc2Nyb2xsTWFyZ2luLnRvcCAmJiBzZXNzaW9uLmdldFNjcm9sbFRvcCgpIDw9IDApXFxuXFx0ICAgICAgICAgICAgc2Vzc2lvbi5zZXRTY3JvbGxUb3AoLXRoaXMuc2Nyb2xsTWFyZ2luLnRvcCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRjdXJzb3JMYXllci5zZXRTZXNzaW9uKHNlc3Npb24pO1xcblxcdCAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRTZXNzaW9uKHNlc3Npb24pO1xcblxcdCAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQuc2V0U2Vzc2lvbihzZXNzaW9uKTtcXG5cXHQgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnNldFNlc3Npb24oc2Vzc2lvbik7XFxuXFx0ICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuc2V0U2Vzc2lvbihzZXNzaW9uKTtcXG5cXHQgICAgICAgIGlmICghc2Vzc2lvbilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uJHNldEZvbnRNZXRyaWNzKHRoaXMuJGZvbnRNZXRyaWNzKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlID0gdGhpcy5vbkNoYW5nZU5ld0xpbmVNb2RlLmJpbmQodGhpcyk7XFxuXFx0ICAgICAgICB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUoKVxcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLmRvYy5vbihcXFwiY2hhbmdlTmV3TGluZU1vZGVcXFwiLCB0aGlzLm9uQ2hhbmdlTmV3TGluZU1vZGUpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnVwZGF0ZUxpbmVzID0gZnVuY3Rpb24oZmlyc3RSb3csIGxhc3RSb3csIGZvcmNlKSB7XFxuXFx0ICAgICAgICBpZiAobGFzdFJvdyA9PT0gdW5kZWZpbmVkKVxcblxcdCAgICAgICAgICAgIGxhc3RSb3cgPSBJbmZpbml0eTtcXG5cXG5cXHQgICAgICAgIGlmICghdGhpcy4kY2hhbmdlZExpbmVzKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY2hhbmdlZExpbmVzID0ge1xcblxcdCAgICAgICAgICAgICAgICBmaXJzdFJvdzogZmlyc3RSb3csXFxuXFx0ICAgICAgICAgICAgICAgIGxhc3RSb3c6IGxhc3RSb3dcXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJGNoYW5nZWRMaW5lcy5maXJzdFJvdyA+IGZpcnN0Um93KVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3cgPSBmaXJzdFJvdztcXG5cXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPCBsYXN0Um93KVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA9IGxhc3RSb3c7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAodGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3cgPCB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGZvcmNlKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMubGFzdFJvdyA9IHRoaXMubGF5ZXJDb25maWcubGFzdFJvdztcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh0aGlzLiRjaGFuZ2VkTGluZXMuZmlyc3RSb3cgPiB0aGlzLmxheWVyQ29uZmlnLmxhc3RSb3cpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9MSU5FUyk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25DaGFuZ2VOZXdMaW5lTW9kZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9URVhUKTtcXG5cXHQgICAgICAgIHRoaXMuJHRleHRMYXllci4kdXBkYXRlRW9sQ2hhcigpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5vbkNoYW5nZVRhYlNpemUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCB8IHRoaXMuQ0hBTkdFX01BUktFUik7XFxuXFx0ICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIub25DaGFuZ2VUYWJTaXplKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudXBkYXRlVGV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9URVhUKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy51cGRhdGVGdWxsID0gZnVuY3Rpb24oZm9yY2UpIHtcXG5cXHQgICAgICAgIGlmIChmb3JjZSlcXG5cXHQgICAgICAgICAgICB0aGlzLiRyZW5kZXJDaGFuZ2VzKHRoaXMuQ0hBTkdFX0ZVTEwsIHRydWUpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudXBkYXRlRm9udFNpemUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJHRleHRMYXllci5jaGVja0ZvclNpemVDaGFuZ2VzKCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGNoYW5nZXMgPSAwO1xcblxcdCAgICB0aGlzLiR1cGRhdGVTaXplQXN5bmMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRsb29wLnBlbmRpbmcpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kc2l6ZS4kZGlydHkgPSB0cnVlO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5vblJlc2l6ZSA9IGZ1bmN0aW9uKGZvcmNlLCBndXR0ZXJXaWR0aCwgd2lkdGgsIGhlaWdodCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMucmVzaXppbmcgPiAyKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXppbmcgPiAwKVxcblxcdCAgICAgICAgICAgIHRoaXMucmVzaXppbmcrKztcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICB0aGlzLnJlc2l6aW5nID0gZm9yY2UgPyAxIDogMDtcXG5cXHQgICAgICAgIHZhciBlbCA9IHRoaXMuY29udGFpbmVyO1xcblxcdCAgICAgICAgaWYgKCFoZWlnaHQpXFxuXFx0ICAgICAgICAgICAgaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0IHx8IGVsLnNjcm9sbEhlaWdodDtcXG5cXHQgICAgICAgIGlmICghd2lkdGgpXFxuXFx0ICAgICAgICAgICAgd2lkdGggPSBlbC5jbGllbnRXaWR0aCB8fCBlbC5zY3JvbGxXaWR0aDtcXG5cXHQgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy4kdXBkYXRlQ2FjaGVkU2l6ZShmb3JjZSwgZ3V0dGVyV2lkdGgsIHdpZHRoLCBoZWlnaHQpO1xcblxcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgfHwgKCF3aWR0aCAmJiAhaGVpZ2h0KSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNpemluZyA9IDA7XFxuXFxuXFx0ICAgICAgICBpZiAoZm9yY2UpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIuJHBhZGRpbmcgPSBudWxsO1xcblxcblxcdCAgICAgICAgaWYgKGZvcmNlKVxcblxcdCAgICAgICAgICAgIHRoaXMuJHJlbmRlckNoYW5nZXMoY2hhbmdlcyB8IHRoaXMuJGNoYW5nZXMsIHRydWUpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUoY2hhbmdlcyB8IHRoaXMuJGNoYW5nZXMpO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMucmVzaXppbmcpXFxuXFx0ICAgICAgICAgICAgdGhpcy5yZXNpemluZyA9IDA7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLiR1cGRhdGVDYWNoZWRTaXplID0gZnVuY3Rpb24oZm9yY2UsIGd1dHRlcldpZHRoLCB3aWR0aCwgaGVpZ2h0KSB7XFxuXFx0ICAgICAgICBoZWlnaHQgLT0gKHRoaXMuJGV4dHJhSGVpZ2h0IHx8IDApO1xcblxcdCAgICAgICAgdmFyIGNoYW5nZXMgPSAwO1xcblxcdCAgICAgICAgdmFyIHNpemUgPSB0aGlzLiRzaXplO1xcblxcdCAgICAgICAgdmFyIG9sZFNpemUgPSB7XFxuXFx0ICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXFxuXFx0ICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcXG5cXHQgICAgICAgICAgICBzY3JvbGxlckhlaWdodDogc2l6ZS5zY3JvbGxlckhlaWdodCxcXG5cXHQgICAgICAgICAgICBzY3JvbGxlcldpZHRoOiBzaXplLnNjcm9sbGVyV2lkdGhcXG5cXHQgICAgICAgIH07XFxuXFx0ICAgICAgICBpZiAoaGVpZ2h0ICYmIChmb3JjZSB8fCBzaXplLmhlaWdodCAhPSBoZWlnaHQpKSB7XFxuXFx0ICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLkNIQU5HRV9TSVpFO1xcblxcblxcdCAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJIZWlnaHQgPSBzaXplLmhlaWdodDtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kaG9yaXpTY3JvbGwpXFxuXFx0ICAgICAgICAgICAgICAgIHNpemUuc2Nyb2xsZXJIZWlnaHQgLT0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5lbGVtZW50LnN0eWxlLmJvdHRvbSA9IHRoaXMuc2Nyb2xsQmFySC5nZXRIZWlnaHQoKSArIFxcXCJweFxcXCI7XFxuXFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMgfCB0aGlzLkNIQU5HRV9TQ1JPTEw7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAod2lkdGggJiYgKGZvcmNlIHx8IHNpemUud2lkdGggIT0gd2lkdGgpKSB7XFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLkNIQU5HRV9TSVpFO1xcblxcdCAgICAgICAgICAgIHNpemUud2lkdGggPSB3aWR0aDtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICBpZiAoZ3V0dGVyV2lkdGggPT0gbnVsbClcXG5cXHQgICAgICAgICAgICAgICAgZ3V0dGVyV2lkdGggPSB0aGlzLiRzaG93R3V0dGVyID8gdGhpcy4kZ3V0dGVyLm9mZnNldFdpZHRoIDogMDtcXG5cXHQgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICB0aGlzLmd1dHRlcldpZHRoID0gZ3V0dGVyV2lkdGg7XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJILmVsZW1lbnQuc3R5bGUubGVmdCA9IFxcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUubGVmdCA9IGd1dHRlcldpZHRoICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICBzaXplLnNjcm9sbGVyV2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIGd1dHRlcldpZHRoIC0gdGhpcy5zY3JvbGxCYXJWLmdldFdpZHRoKCkpOyAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJILmVsZW1lbnQuc3R5bGUucmlnaHQgPSBcXG5cXHQgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLnJpZ2h0ID0gdGhpcy5zY3JvbGxCYXJWLmdldFdpZHRoKCkgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc3R5bGUuYm90dG9tID0gdGhpcy5zY3JvbGxCYXJILmdldEhlaWdodCgpICsgXFxcInB4XFxcIjtcXG5cXG5cXHQgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi5nZXRVc2VXcmFwTW9kZSgpICYmIHRoaXMuYWRqdXN0V3JhcExpbWl0KCkgfHwgZm9yY2UpXFxuXFx0ICAgICAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy5DSEFOR0VfRlVMTDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgc2l6ZS4kZGlydHkgPSAhd2lkdGggfHwgIWhlaWdodDtcXG5cXG5cXHQgICAgICAgIGlmIChjaGFuZ2VzKVxcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwicmVzaXplXFxcIiwgb2xkU2l6ZSk7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gY2hhbmdlcztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5vbkd1dHRlclJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIGd1dHRlcldpZHRoID0gdGhpcy4kc2hvd0d1dHRlciA/IHRoaXMuJGd1dHRlci5vZmZzZXRXaWR0aCA6IDA7XFxuXFx0ICAgICAgICBpZiAoZ3V0dGVyV2lkdGggIT0gdGhpcy5ndXR0ZXJXaWR0aClcXG5cXHQgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzIHw9IHRoaXMuJHVwZGF0ZUNhY2hlZFNpemUodHJ1ZSwgZ3V0dGVyV2lkdGgsIHRoaXMuJHNpemUud2lkdGgsIHRoaXMuJHNpemUuaGVpZ2h0KTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnNlc3Npb24uZ2V0VXNlV3JhcE1vZGUoKSAmJiB0aGlzLmFkanVzdFdyYXBMaW1pdCgpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9GVUxMKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy4kc2l6ZS4kZGlydHkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRjb21wdXRlTGF5ZXJDb25maWcoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX01BUktFUik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYWRqdXN0V3JhcExpbWl0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB0aGlzLiRwYWRkaW5nICogMjtcXG5cXHQgICAgICAgIHZhciBsaW1pdCA9IE1hdGguZmxvb3IoYXZhaWxhYmxlV2lkdGggLyB0aGlzLmNoYXJhY3RlcldpZHRoKTtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uYWRqdXN0V3JhcExpbWl0KGxpbWl0LCB0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgdGhpcy4kcHJpbnRNYXJnaW5Db2x1bW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldEFuaW1hdGVkU2Nyb2xsID0gZnVuY3Rpb24oc2hvdWxkQW5pbWF0ZSl7XFxuXFx0ICAgICAgICB0aGlzLnNldE9wdGlvbihcXFwiYW5pbWF0ZWRTY3JvbGxcXFwiLCBzaG91bGRBbmltYXRlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRBbmltYXRlZFNjcm9sbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGFuaW1hdGVkU2Nyb2xsO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNob3dJbnZpc2libGVzID0gZnVuY3Rpb24oc2hvd0ludmlzaWJsZXMpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJzaG93SW52aXNpYmxlc1xcXCIsIHNob3dJbnZpc2libGVzKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTaG93SW52aXNpYmxlcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFxcXCJzaG93SW52aXNpYmxlc1xcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbihcXFwiZGlzcGxheUluZGVudEd1aWRlc1xcXCIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNldERpc3BsYXlJbmRlbnRHdWlkZXMgPSBmdW5jdGlvbihkaXNwbGF5KSB7XFxuXFx0ICAgICAgICB0aGlzLnNldE9wdGlvbihcXFwiZGlzcGxheUluZGVudEd1aWRlc1xcXCIsIGRpc3BsYXkpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFNob3dQcmludE1hcmdpbiA9IGZ1bmN0aW9uKHNob3dQcmludE1hcmdpbikge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcInNob3dQcmludE1hcmdpblxcXCIsIHNob3dQcmludE1hcmdpbik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0U2hvd1ByaW50TWFyZ2luID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcInNob3dQcmludE1hcmdpblxcXCIpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFByaW50TWFyZ2luQ29sdW1uID0gZnVuY3Rpb24oc2hvd1ByaW50TWFyZ2luKSB7XFxuXFx0ICAgICAgICB0aGlzLnNldE9wdGlvbihcXFwicHJpbnRNYXJnaW5Db2x1bW5cXFwiLCBzaG93UHJpbnRNYXJnaW4pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFByaW50TWFyZ2luQ29sdW1uID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcInByaW50TWFyZ2luQ29sdW1uXFxcIik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0U2hvd0d1dHRlciA9IGZ1bmN0aW9uKCl7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oXFxcInNob3dHdXR0ZXJcXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRTaG93R3V0dGVyID0gZnVuY3Rpb24oc2hvdyl7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zZXRPcHRpb24oXFxcInNob3dHdXR0ZXJcXFwiLCBzaG93KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5nZXRGYWRlRm9sZFdpZGdldHMgPSBmdW5jdGlvbigpe1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFxcXCJmYWRlRm9sZFdpZGdldHNcXFwiKVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnNldEZhZGVGb2xkV2lkZ2V0cyA9IGZ1bmN0aW9uKHNob3cpIHtcXG5cXHQgICAgICAgIHRoaXMuc2V0T3B0aW9uKFxcXCJmYWRlRm9sZFdpZGdldHNcXFwiLCBzaG93KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zZXRIaWdobGlnaHRHdXR0ZXJMaW5lID0gZnVuY3Rpb24oc2hvdWxkSGlnaGxpZ2h0KSB7XFxuXFx0ICAgICAgICB0aGlzLnNldE9wdGlvbihcXFwiaGlnaGxpZ2h0R3V0dGVyTGluZVxcXCIsIHNob3VsZEhpZ2hsaWdodCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0SGlnaGxpZ2h0R3V0dGVyTGluZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKFxcXCJoaWdobGlnaHRHdXR0ZXJMaW5lXFxcIik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZUd1dHRlckxpbmVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci4kcGl4ZWxQb3M7XFxuXFx0ICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5nZXRVc2VXcmFwTW9kZSgpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XFxuXFx0ICAgICAgICAgICAgY3Vyc29yLmNvbHVtbiA9IDA7XFxuXFx0ICAgICAgICAgICAgcG9zID0gdGhpcy4kY3Vyc29yTGF5ZXIuZ2V0UGl4ZWxQb3NpdGlvbihjdXJzb3IsIHRydWUpO1xcblxcdCAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLnNlc3Npb24uZ2V0Um93TGVuZ3RoKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy4kZ3V0dGVyTGluZUhpZ2hsaWdodC5zdHlsZS50b3AgPSBwb3MudG9wIC0gdGhpcy5sYXllckNvbmZpZy5vZmZzZXQgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgdGhpcy4kZ3V0dGVyTGluZUhpZ2hsaWdodC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcXFwicHhcXFwiO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiRzaG93UHJpbnRNYXJnaW4gJiYgIXRoaXMuJHByaW50TWFyZ2luRWwpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgaWYgKCF0aGlzLiRwcmludE1hcmdpbkVsKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGNvbnRhaW5lckVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcdCAgICAgICAgICAgIGNvbnRhaW5lckVsLmNsYXNzTmFtZSA9IFxcXCJhY2VfbGF5ZXIgYWNlX3ByaW50LW1hcmdpbi1sYXllclxcXCI7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kcHJpbnRNYXJnaW5FbCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRwcmludE1hcmdpbkVsLmNsYXNzTmFtZSA9IFxcXCJhY2VfcHJpbnQtbWFyZ2luXFxcIjtcXG5cXHQgICAgICAgICAgICBjb250YWluZXJFbC5hcHBlbmRDaGlsZCh0aGlzLiRwcmludE1hcmdpbkVsKTtcXG5cXHQgICAgICAgICAgICB0aGlzLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lckVsLCB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLiRwcmludE1hcmdpbkVsLnN0eWxlO1xcblxcdCAgICAgICAgc3R5bGUubGVmdCA9ICgodGhpcy5jaGFyYWN0ZXJXaWR0aCAqIHRoaXMuJHByaW50TWFyZ2luQ29sdW1uKSArIHRoaXMuJHBhZGRpbmcpICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLiRzaG93UHJpbnRNYXJnaW4gPyBcXFwidmlzaWJsZVxcXCIgOiBcXFwiaGlkZGVuXFxcIjtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiAmJiB0aGlzLnNlc3Npb24uJHdyYXAgPT0gLTEpXFxuXFx0ICAgICAgICAgICAgdGhpcy5hZGp1c3RXcmFwTGltaXQoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0TW91c2VFdmVudFRhcmdldCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRUZXh0QXJlYUNvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiRrZWVwVGV4dEFyZWFBdEN1cnNvcilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcXG5cXHQgICAgICAgIHZhciBwb3NUb3AgPSB0aGlzLiRjdXJzb3JMYXllci4kcGl4ZWxQb3MudG9wO1xcblxcdCAgICAgICAgdmFyIHBvc0xlZnQgPSB0aGlzLiRjdXJzb3JMYXllci4kcGl4ZWxQb3MubGVmdDtcXG5cXHQgICAgICAgIHBvc1RvcCAtPSBjb25maWcub2Zmc2V0O1xcblxcblxcdCAgICAgICAgdmFyIGggPSB0aGlzLmxpbmVIZWlnaHQ7XFxuXFx0ICAgICAgICBpZiAocG9zVG9wIDwgMCB8fCBwb3NUb3AgPiBjb25maWcuaGVpZ2h0IC0gaClcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICB2YXIgdyA9IHRoaXMuY2hhcmFjdGVyV2lkdGg7XFxuXFx0ICAgICAgICBpZiAodGhpcy4kY29tcG9zaXRpb24pIHtcXG5cXHQgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy50ZXh0YXJlYS52YWx1ZS5yZXBsYWNlKC9eXFxcXHgwMSsvLCBcXFwiXFxcIik7XFxuXFx0ICAgICAgICAgICAgdyAqPSAodGhpcy5zZXNzaW9uLiRnZXRTdHJpbmdTY3JlZW5XaWR0aCh2YWwpWzBdKzIpO1xcblxcdCAgICAgICAgICAgIGggKz0gMjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHBvc0xlZnQgLT0gdGhpcy5zY3JvbGxMZWZ0O1xcblxcdCAgICAgICAgaWYgKHBvc0xlZnQgPiB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB3KVxcblxcdCAgICAgICAgICAgIHBvc0xlZnQgPSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSB3O1xcblxcblxcdCAgICAgICAgcG9zTGVmdCArPSB0aGlzLmd1dHRlcldpZHRoO1xcblxcblxcdCAgICAgICAgdGhpcy50ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBoICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUud2lkdGggPSB3ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUubGVmdCA9IE1hdGgubWluKHBvc0xlZnQsIHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aCAtIHcpICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUudG9wID0gTWF0aC5taW4ocG9zVG9wLCB0aGlzLiRzaXplLmhlaWdodCAtIGgpICsgXFxcInB4XFxcIjtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRGaXJzdFZpc2libGVSb3cgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLmxheWVyQ29uZmlnLmZpcnN0Um93O1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEZpcnN0RnVsbHlWaXNpYmxlUm93ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdyArICh0aGlzLmxheWVyQ29uZmlnLm9mZnNldCA9PT0gMCA/IDAgOiAxKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMYXN0RnVsbHlWaXNpYmxlUm93ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgZmxpbnQgPSBNYXRoLmZsb29yKCh0aGlzLmxheWVyQ29uZmlnLmhlaWdodCArIHRoaXMubGF5ZXJDb25maWcub2Zmc2V0KSAvIHRoaXMubGF5ZXJDb25maWcubGluZUhlaWdodCk7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdyAtIDEgKyBmbGludDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRMYXN0VmlzaWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJDb25maWcubGFzdFJvdztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kcGFkZGluZyA9IG51bGw7XFxuXFx0ICAgIHRoaXMuc2V0UGFkZGluZyA9IGZ1bmN0aW9uKHBhZGRpbmcpIHtcXG5cXHQgICAgICAgIHRoaXMuJHBhZGRpbmcgPSBwYWRkaW5nO1xcblxcdCAgICAgICAgdGhpcy4kdGV4dExheWVyLnNldFBhZGRpbmcocGFkZGluZyk7XFxuXFx0ICAgICAgICB0aGlzLiRjdXJzb3JMYXllci5zZXRQYWRkaW5nKHBhZGRpbmcpO1xcblxcdCAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQuc2V0UGFkZGluZyhwYWRkaW5nKTtcXG5cXHQgICAgICAgIHRoaXMuJG1hcmtlckJhY2suc2V0UGFkZGluZyhwYWRkaW5nKTtcXG5cXHQgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfRlVMTCk7XFxuXFx0ICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5zZXRTY3JvbGxNYXJnaW4gPSBmdW5jdGlvbih0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcXG5cXHQgICAgICAgIHZhciBzbSA9IHRoaXMuc2Nyb2xsTWFyZ2luO1xcblxcdCAgICAgICAgc20udG9wID0gdG9wfDA7XFxuXFx0ICAgICAgICBzbS5ib3R0b20gPSBib3R0b218MDtcXG5cXHQgICAgICAgIHNtLnJpZ2h0ID0gcmlnaHR8MDtcXG5cXHQgICAgICAgIHNtLmxlZnQgPSBsZWZ0fDA7XFxuXFx0ICAgICAgICBzbS52ID0gc20udG9wICsgc20uYm90dG9tO1xcblxcdCAgICAgICAgc20uaCA9IHNtLmxlZnQgKyBzbS5yaWdodDtcXG5cXHQgICAgICAgIGlmIChzbS50b3AgJiYgdGhpcy5zY3JvbGxUb3AgPD0gMCAmJiB0aGlzLnNlc3Npb24pXFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcCgtc20udG9wKTtcXG5cXHQgICAgICAgIHRoaXMudXBkYXRlRnVsbCgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldEhTY3JvbGxCYXJBbHdheXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kaFNjcm9sbEJhckFsd2F5c1Zpc2libGU7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0SFNjcm9sbEJhckFsd2F5c1Zpc2libGUgPSBmdW5jdGlvbihhbHdheXNWaXNpYmxlKSB7XFxuXFx0ICAgICAgICB0aGlzLnNldE9wdGlvbihcXFwiaFNjcm9sbEJhckFsd2F5c1Zpc2libGVcXFwiLCBhbHdheXNWaXNpYmxlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRWU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuJGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFZTY3JvbGxCYXJBbHdheXNWaXNpYmxlID0gZnVuY3Rpb24oYWx3YXlzVmlzaWJsZSkge1xcblxcdCAgICAgICAgdGhpcy5zZXRPcHRpb24oXFxcInZTY3JvbGxCYXJBbHdheXNWaXNpYmxlXFxcIiwgYWx3YXlzVmlzaWJsZSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHVwZGF0ZVNjcm9sbEJhclYgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSB0aGlzLmxheWVyQ29uZmlnLm1heEhlaWdodDtcXG5cXHQgICAgICAgIHZhciBzY3JvbGxlckhlaWdodCA9IHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQ7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJG1heExpbmVzICYmIHRoaXMuJHNjcm9sbFBhc3RFbmQpIHtcXG5cXHQgICAgICAgICAgICBzY3JvbGxIZWlnaHQgLT0gKHNjcm9sbGVySGVpZ2h0IC0gdGhpcy5saW5lSGVpZ2h0KSAqIHRoaXMuJHNjcm9sbFBhc3RFbmQ7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID4gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsZXJIZWlnaHQpIHtcXG5cXHQgICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5zY3JvbGxUb3AgKyBzY3JvbGxlckhlaWdodDtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxCYXJWLnNjcm9sbFRvcCA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdGhpcy5zY3JvbGxCYXJWLnNldFNjcm9sbEhlaWdodChzY3JvbGxIZWlnaHQgKyB0aGlzLnNjcm9sbE1hcmdpbi52KTtcXG5cXHQgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRTY3JvbGxUb3AodGhpcy5zY3JvbGxUb3AgKyB0aGlzLnNjcm9sbE1hcmdpbi50b3ApO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiR1cGRhdGVTY3JvbGxCYXJIID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0U2Nyb2xsV2lkdGgodGhpcy5sYXllckNvbmZpZy53aWR0aCArIDIgKiB0aGlzLiRwYWRkaW5nICsgdGhpcy5zY3JvbGxNYXJnaW4uaCk7XFxuXFx0ICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0U2Nyb2xsTGVmdCh0aGlzLnNjcm9sbExlZnQgKyB0aGlzLnNjcm9sbE1hcmdpbi5sZWZ0KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJGZyb3plbiA9IGZhbHNlO1xcblxcdCAgICB0aGlzLmZyZWV6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kZnJvemVuID0gdHJ1ZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMudW5mcmVlemUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJGZyb3plbiA9IGZhbHNlO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRyZW5kZXJDaGFuZ2VzID0gZnVuY3Rpb24oY2hhbmdlcywgZm9yY2UpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLiRjaGFuZ2VzKSB7XFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLiRjaGFuZ2VzO1xcblxcdCAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMgPSAwO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKCghdGhpcy5zZXNzaW9uIHx8ICF0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCB0aGlzLiRmcm96ZW4pIHx8ICghY2hhbmdlcyAmJiAhZm9yY2UpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyB8PSBjaGFuZ2VzO1xcblxcdCAgICAgICAgICAgIHJldHVybjsgXFxuXFx0ICAgICAgICB9IFxcblxcdCAgICAgICAgaWYgKHRoaXMuJHNpemUuJGRpcnR5KSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY2hhbmdlcyB8PSBjaGFuZ2VzO1xcblxcdCAgICAgICAgICAgIHJldHVybiB0aGlzLm9uUmVzaXplKHRydWUpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKCF0aGlzLmxpbmVIZWlnaHQpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuY2hlY2tGb3JTaXplQ2hhbmdlcygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImJlZm9yZVJlbmRlclxcXCIpO1xcblxcdCAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMubGF5ZXJDb25maWc7XFxuXFx0ICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0ZVTEwgfHxcXG5cXHQgICAgICAgICAgICBjaGFuZ2VzICYgdGhpcy5DSEFOR0VfU0laRSB8fFxcblxcdCAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9URVhUIHx8XFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0xJTkVTIHx8XFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1NDUk9MTCB8fFxcblxcdCAgICAgICAgICAgIGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9IX1NDUk9MTFxcblxcdCAgICAgICAgKSB7XFxuXFx0ICAgICAgICAgICAgY2hhbmdlcyB8PSB0aGlzLiRjb21wdXRlTGF5ZXJDb25maWcoKTtcXG5cXHQgICAgICAgICAgICBpZiAoY29uZmlnLmZpcnN0Um93ICE9IHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3cgJiYgY29uZmlnLmZpcnN0Um93U2NyZWVuID09IHRoaXMubGF5ZXJDb25maWcuZmlyc3RSb3dTY3JlZW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpcy5zY3JvbGxUb3AgKyAoY29uZmlnLmZpcnN0Um93IC0gdGhpcy5sYXllckNvbmZpZy5maXJzdFJvdykgKiB0aGlzLmxpbmVIZWlnaHQ7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzdCA+IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc3Q7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcyB8IHRoaXMuQ0hBTkdFX1NDUk9MTDtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMgfD0gdGhpcy4kY29tcHV0ZUxheWVyQ29uZmlnKCk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgY29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcXG5cXHQgICAgICAgICAgICB0aGlzLiR1cGRhdGVTY3JvbGxCYXJWKCk7XFxuXFx0ICAgICAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9IX1NDUk9MTClcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlU2Nyb2xsQmFySCgpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gKC1jb25maWcub2Zmc2V0KSArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLm1hcmdpblRvcCA9ICgtY29uZmlnLm9mZnNldCkgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS53aWR0aCA9IGNvbmZpZy53aWR0aCArIDIgKiB0aGlzLiRwYWRkaW5nICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gY29uZmlnLm1pbkhlaWdodCArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0hfU0NST0xMKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLm1hcmdpbkxlZnQgPSAtdGhpcy5zY3JvbGxMZWZ0ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmNsYXNzTmFtZSA9IHRoaXMuc2Nyb2xsTGVmdCA8PSAwID8gXFxcImFjZV9zY3JvbGxlclxcXCIgOiBcXFwiYWNlX3Njcm9sbGVyIGFjZV9zY3JvbGwtbGVmdFxcXCI7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0ZVTEwpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJG1hcmtlckJhY2sudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbWFya2VyRnJvbnQudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRHdXR0ZXJMaW5lICYmIHRoaXMuJHVwZGF0ZUd1dHRlckxpbmVIaWdobGlnaHQoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcImFmdGVyUmVuZGVyXFxcIik7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgaWYgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9TQ1JPTEwpIHtcXG5cXHQgICAgICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHwgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0xJTkVTKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIuc2Nyb2xsTGluZXMoY29uZmlnKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kc2hvd0d1dHRlcilcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGF5ZXIudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbWFya2VyQmFjay51cGRhdGUoY29uZmlnKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC51cGRhdGUoY29uZmlnKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRjdXJzb3JMYXllci51cGRhdGUoY29uZmlnKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRHdXR0ZXJMaW5lICYmIHRoaXMuJHVwZGF0ZUd1dHRlckxpbmVIaWdobGlnaHQoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiYWZ0ZXJSZW5kZXJcXFwiKTtcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiR0ZXh0TGF5ZXIudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHNob3dHdXR0ZXIpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0xJTkVTKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHVwZGF0ZUxpbmVzKCkgfHwgKGNoYW5nZXMgJiB0aGlzLkNIQU5HRV9HVVRURVIpICYmIHRoaXMuJHNob3dHdXR0ZXIpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLnVwZGF0ZShjb25maWcpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZWxzZSBpZiAoY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX1RFWFQgfHwgY2hhbmdlcyAmIHRoaXMuQ0hBTkdFX0dVVFRFUikge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci51cGRhdGUoY29uZmlnKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChjaGFuZ2VzICYgdGhpcy5DSEFOR0VfQ1VSU09SKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRoaWdobGlnaHRHdXR0ZXJMaW5lICYmIHRoaXMuJHVwZGF0ZUd1dHRlckxpbmVIaWdobGlnaHQoKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChjaGFuZ2VzICYgKHRoaXMuQ0hBTkdFX01BUktFUiB8IHRoaXMuQ0hBTkdFX01BUktFUl9GUk9OVCkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC51cGRhdGUoY29uZmlnKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChjaGFuZ2VzICYgKHRoaXMuQ0hBTkdFX01BUktFUiB8IHRoaXMuQ0hBTkdFX01BUktFUl9CQUNLKSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJG1hcmtlckJhY2sudXBkYXRlKGNvbmZpZyk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcImFmdGVyUmVuZGVyXFxcIik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLiRhdXRvc2l6ZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuc2Vzc2lvbi5nZXRTY3JlZW5MZW5ndGgoKSAqIHRoaXMubGluZUhlaWdodDtcXG5cXHQgICAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLiRtYXhMaW5lcyAqIHRoaXMubGluZUhlaWdodDtcXG5cXHQgICAgICAgIHZhciBkZXNpcmVkSGVpZ2h0ID0gTWF0aC5tYXgoXFxuXFx0ICAgICAgICAgICAgKHRoaXMuJG1pbkxpbmVzfHwxKSAqIHRoaXMubGluZUhlaWdodCxcXG5cXHQgICAgICAgICAgICBNYXRoLm1pbihtYXhIZWlnaHQsIGhlaWdodClcXG5cXHQgICAgICAgICkgKyB0aGlzLnNjcm9sbE1hcmdpbi52ICsgKHRoaXMuJGV4dHJhSGVpZ2h0IHx8IDApO1xcblxcdCAgICAgICAgdmFyIHZTY3JvbGwgPSBoZWlnaHQgPiBtYXhIZWlnaHQ7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChkZXNpcmVkSGVpZ2h0ICE9IHRoaXMuZGVzaXJlZEhlaWdodCB8fFxcblxcdCAgICAgICAgICAgIHRoaXMuJHNpemUuaGVpZ2h0ICE9IHRoaXMuZGVzaXJlZEhlaWdodCB8fCB2U2Nyb2xsICE9IHRoaXMuJHZTY3JvbGwpIHtcXG5cXHQgICAgICAgICAgICBpZiAodlNjcm9sbCAhPSB0aGlzLiR2U2Nyb2xsKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJHZTY3JvbGwgPSB2U2Nyb2xsO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEJhclYuc2V0VmlzaWJsZSh2U2Nyb2xsKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgdmFyIHcgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcXG5cXHQgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBkZXNpcmVkSGVpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICB0aGlzLiR1cGRhdGVDYWNoZWRTaXplKHRydWUsIHRoaXMuJGd1dHRlcldpZHRoLCB3LCBkZXNpcmVkSGVpZ2h0KTtcXG5cXHQgICAgICAgICAgICB0aGlzLmRlc2lyZWRIZWlnaHQgPSBkZXNpcmVkSGVpZ2h0O1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiYXV0b3NpemVcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJGNvbXB1dGVMYXllckNvbmZpZyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJG1heExpbmVzICYmIHRoaXMubGluZUhlaWdodCA+IDEpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kYXV0b3NpemUoKTtcXG5cXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgdmFyIHNpemUgPSB0aGlzLiRzaXplO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgaGlkZVNjcm9sbGJhcnMgPSBzaXplLmhlaWdodCA8PSAyICogdGhpcy5saW5lSGVpZ2h0O1xcblxcdCAgICAgICAgdmFyIHNjcmVlbkxpbmVzID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbkxlbmd0aCgpO1xcblxcdCAgICAgICAgdmFyIG1heEhlaWdodCA9IHNjcmVlbkxpbmVzICogdGhpcy5saW5lSGVpZ2h0O1xcblxcblxcdCAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuc2Nyb2xsVG9wICUgdGhpcy5saW5lSGVpZ2h0O1xcblxcdCAgICAgICAgdmFyIG1pbkhlaWdodCA9IHNpemUuc2Nyb2xsZXJIZWlnaHQgKyB0aGlzLmxpbmVIZWlnaHQ7XFxuXFxuXFx0ICAgICAgICB2YXIgbG9uZ2VzdExpbmUgPSB0aGlzLiRnZXRMb25nZXN0TGluZSgpO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgaG9yaXpTY3JvbGwgPSAhaGlkZVNjcm9sbGJhcnMgJiYgKHRoaXMuJGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlIHx8XFxuXFx0ICAgICAgICAgICAgc2l6ZS5zY3JvbGxlcldpZHRoIC0gbG9uZ2VzdExpbmUgLSAyICogdGhpcy4kcGFkZGluZyA8IDApO1xcblxcblxcdCAgICAgICAgdmFyIGhTY3JvbGxDaGFuZ2VkID0gdGhpcy4kaG9yaXpTY3JvbGwgIT09IGhvcml6U2Nyb2xsO1xcblxcdCAgICAgICAgaWYgKGhTY3JvbGxDaGFuZ2VkKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kaG9yaXpTY3JvbGwgPSBob3JpelNjcm9sbDtcXG5cXHQgICAgICAgICAgICB0aGlzLnNjcm9sbEJhckguc2V0VmlzaWJsZShob3JpelNjcm9sbCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHZhciBzY3JvbGxQYXN0RW5kID0gIXRoaXMuJG1heExpbmVzICYmIHRoaXMuJHNjcm9sbFBhc3RFbmRcXG5cXHQgICAgICAgICAgICA/IChzaXplLnNjcm9sbGVySGVpZ2h0IC0gdGhpcy5saW5lSGVpZ2h0KSAqIHRoaXMuJHNjcm9sbFBhc3RFbmRcXG5cXHQgICAgICAgICAgICA6IDA7XFxuXFx0ICAgICAgICBtYXhIZWlnaHQgKz0gc2Nyb2xsUGFzdEVuZDtcXG5cXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoTWF0aC5tYXgoLXRoaXMuc2Nyb2xsTWFyZ2luLnRvcCxcXG5cXHQgICAgICAgICAgICBNYXRoLm1pbih0aGlzLnNjcm9sbFRvcCwgbWF4SGVpZ2h0IC0gc2l6ZS5zY3JvbGxlckhlaWdodCArIHRoaXMuc2Nyb2xsTWFyZ2luLmJvdHRvbSkpKTtcXG5cXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KE1hdGgubWF4KC10aGlzLnNjcm9sbE1hcmdpbi5sZWZ0LCBNYXRoLm1pbih0aGlzLnNjcm9sbExlZnQsXFxuXFx0ICAgICAgICAgICAgbG9uZ2VzdExpbmUgKyAyICogdGhpcy4kcGFkZGluZyAtIHNpemUuc2Nyb2xsZXJXaWR0aCArIHRoaXMuc2Nyb2xsTWFyZ2luLnJpZ2h0KSkpO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgdlNjcm9sbCA9ICFoaWRlU2Nyb2xsYmFycyAmJiAodGhpcy4kdlNjcm9sbEJhckFsd2F5c1Zpc2libGUgfHxcXG5cXHQgICAgICAgICAgICBzaXplLnNjcm9sbGVySGVpZ2h0IC0gbWF4SGVpZ2h0ICsgc2Nyb2xsUGFzdEVuZCA8IDAgfHwgdGhpcy5zY3JvbGxUb3ApO1xcblxcdCAgICAgICAgdmFyIHZTY3JvbGxDaGFuZ2VkID0gdGhpcy4kdlNjcm9sbCAhPT0gdlNjcm9sbDtcXG5cXHQgICAgICAgIGlmICh2U2Nyb2xsQ2hhbmdlZCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJHZTY3JvbGwgPSB2U2Nyb2xsO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsQmFyVi5zZXRWaXNpYmxlKHZTY3JvbGwpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIGxpbmVDb3VudCA9IE1hdGguY2VpbChtaW5IZWlnaHQgLyB0aGlzLmxpbmVIZWlnaHQpIC0gMTtcXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoKHRoaXMuc2Nyb2xsVG9wIC0gb2Zmc2V0KSAvIHRoaXMubGluZUhlaWdodCkpO1xcblxcdCAgICAgICAgdmFyIGxhc3RSb3cgPSBmaXJzdFJvdyArIGxpbmVDb3VudDtcXG5cXHQgICAgICAgIHZhciBmaXJzdFJvd1NjcmVlbiwgZmlyc3RSb3dIZWlnaHQ7XFxuXFx0ICAgICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcXG5cXHQgICAgICAgIGZpcnN0Um93ID0gc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50Um93KGZpcnN0Um93LCAwKTtcXG5cXHQgICAgICAgIHZhciBmb2xkTGluZSA9IHNlc3Npb24uZ2V0Rm9sZExpbmUoZmlyc3RSb3cpO1xcblxcdCAgICAgICAgaWYgKGZvbGRMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgZmlyc3RSb3cgPSBmb2xkTGluZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmaXJzdFJvd1NjcmVlbiA9IHNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblJvdyhmaXJzdFJvdywgMCk7XFxuXFx0ICAgICAgICBmaXJzdFJvd0hlaWdodCA9IHNlc3Npb24uZ2V0Um93TGVuZ3RoKGZpcnN0Um93KSAqIGxpbmVIZWlnaHQ7XFxuXFxuXFx0ICAgICAgICBsYXN0Um93ID0gTWF0aC5taW4oc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50Um93KGxhc3RSb3csIDApLCBzZXNzaW9uLmdldExlbmd0aCgpIC0gMSk7XFxuXFx0ICAgICAgICBtaW5IZWlnaHQgPSBzaXplLnNjcm9sbGVySGVpZ2h0ICsgc2Vzc2lvbi5nZXRSb3dMZW5ndGgobGFzdFJvdykgKiBsaW5lSGVpZ2h0ICtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJvd0hlaWdodDtcXG5cXG5cXHQgICAgICAgIG9mZnNldCA9IHRoaXMuc2Nyb2xsVG9wIC0gZmlyc3RSb3dTY3JlZW4gKiBsaW5lSGVpZ2h0O1xcblxcblxcdCAgICAgICAgdmFyIGNoYW5nZXMgPSAwO1xcblxcdCAgICAgICAgaWYgKHRoaXMubGF5ZXJDb25maWcud2lkdGggIT0gbG9uZ2VzdExpbmUpIFxcblxcdCAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLkNIQU5HRV9IX1NDUk9MTDtcXG5cXHQgICAgICAgIGlmIChoU2Nyb2xsQ2hhbmdlZCB8fCB2U2Nyb2xsQ2hhbmdlZCkge1xcblxcdCAgICAgICAgICAgIGNoYW5nZXMgPSB0aGlzLiR1cGRhdGVDYWNoZWRTaXplKHRydWUsIHRoaXMuZ3V0dGVyV2lkdGgsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcInNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkXFxcIik7XFxuXFx0ICAgICAgICAgICAgaWYgKHZTY3JvbGxDaGFuZ2VkKVxcblxcdCAgICAgICAgICAgICAgICBsb25nZXN0TGluZSA9IHRoaXMuJGdldExvbmdlc3RMaW5lKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMubGF5ZXJDb25maWcgPSB7XFxuXFx0ICAgICAgICAgICAgd2lkdGggOiBsb25nZXN0TGluZSxcXG5cXHQgICAgICAgICAgICBwYWRkaW5nIDogdGhpcy4kcGFkZGluZyxcXG5cXHQgICAgICAgICAgICBmaXJzdFJvdyA6IGZpcnN0Um93LFxcblxcdCAgICAgICAgICAgIGZpcnN0Um93U2NyZWVuOiBmaXJzdFJvd1NjcmVlbixcXG5cXHQgICAgICAgICAgICBsYXN0Um93IDogbGFzdFJvdyxcXG5cXHQgICAgICAgICAgICBsaW5lSGVpZ2h0IDogbGluZUhlaWdodCxcXG5cXHQgICAgICAgICAgICBjaGFyYWN0ZXJXaWR0aCA6IHRoaXMuY2hhcmFjdGVyV2lkdGgsXFxuXFx0ICAgICAgICAgICAgbWluSGVpZ2h0IDogbWluSGVpZ2h0LFxcblxcdCAgICAgICAgICAgIG1heEhlaWdodCA6IG1heEhlaWdodCxcXG5cXHQgICAgICAgICAgICBvZmZzZXQgOiBvZmZzZXQsXFxuXFx0ICAgICAgICAgICAgZ3V0dGVyT2Zmc2V0IDogTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChvZmZzZXQgKyBzaXplLmhlaWdodCAtIHNpemUuc2Nyb2xsZXJIZWlnaHQpIC8gbGluZUhlaWdodCkpLFxcblxcdCAgICAgICAgICAgIGhlaWdodCA6IHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHRcXG5cXHQgICAgICAgIH07XFxuXFxuXFx0ICAgICAgICByZXR1cm4gY2hhbmdlcztcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kdXBkYXRlTGluZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBmaXJzdFJvdyA9IHRoaXMuJGNoYW5nZWRMaW5lcy5maXJzdFJvdztcXG5cXHQgICAgICAgIHZhciBsYXN0Um93ID0gdGhpcy4kY2hhbmdlZExpbmVzLmxhc3RSb3c7XFxuXFx0ICAgICAgICB0aGlzLiRjaGFuZ2VkTGluZXMgPSBudWxsO1xcblxcblxcdCAgICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5sYXllckNvbmZpZztcXG5cXG5cXHQgICAgICAgIGlmIChmaXJzdFJvdyA+IGxheWVyQ29uZmlnLmxhc3RSb3cgKyAxKSB7IHJldHVybjsgfVxcblxcdCAgICAgICAgaWYgKGxhc3RSb3cgPCBsYXllckNvbmZpZy5maXJzdFJvdykgeyByZXR1cm47IH1cXG5cXHQgICAgICAgIGlmIChsYXN0Um93ID09PSBJbmZpbml0eSkge1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiRzaG93R3V0dGVyKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci51cGRhdGUobGF5ZXJDb25maWcpO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGUobGF5ZXJDb25maWcpO1xcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuJHRleHRMYXllci51cGRhdGVMaW5lcyhsYXllckNvbmZpZywgZmlyc3RSb3csIGxhc3RSb3cpO1xcblxcdCAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJGdldExvbmdlc3RMaW5lID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgY2hhckNvdW50ID0gdGhpcy5zZXNzaW9uLmdldFNjcmVlbldpZHRoKCk7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zaG93SW52aXNpYmxlcyAmJiAhdGhpcy5zZXNzaW9uLiR1c2VXcmFwTW9kZSlcXG5cXHQgICAgICAgICAgICBjaGFyQ291bnQgKz0gMTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggLSAyICogdGhpcy4kcGFkZGluZywgTWF0aC5yb3VuZChjaGFyQ291bnQgKiB0aGlzLmNoYXJhY3RlcldpZHRoKSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudXBkYXRlRnJvbnRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRtYXJrZXJGcm9udC5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKHRydWUpKTtcXG5cXHQgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfTUFSS0VSX0ZST05UKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy51cGRhdGVCYWNrTWFya2VycyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kbWFya2VyQmFjay5zZXRNYXJrZXJzKHRoaXMuc2Vzc2lvbi5nZXRNYXJrZXJzKCkpO1xcblxcdCAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9NQVJLRVJfQkFDSyk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuYWRkR3V0dGVyRGVjb3JhdGlvbiA9IGZ1bmN0aW9uKHJvdywgY2xhc3NOYW1lKXtcXG5cXHQgICAgICAgIHRoaXMuJGd1dHRlckxheWVyLmFkZEd1dHRlckRlY29yYXRpb24ocm93LCBjbGFzc05hbWUpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnJlbW92ZUd1dHRlckRlY29yYXRpb24gPSBmdW5jdGlvbihyb3csIGNsYXNzTmFtZSl7XFxuXFx0ICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5yZW1vdmVHdXR0ZXJEZWNvcmF0aW9uKHJvdywgY2xhc3NOYW1lKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy51cGRhdGVCcmVha3BvaW50cyA9IGZ1bmN0aW9uKHJvd3MpIHtcXG5cXHQgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfR1VUVEVSKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGFubm90YXRpb25zKSB7XFxuXFx0ICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucyk7XFxuXFx0ICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0dVVFRFUik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudXBkYXRlQ3Vyc29yID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0NVUlNPUik7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuaGlkZUN1cnNvciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy4kY3Vyc29yTGF5ZXIuaGlkZUN1cnNvcigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNob3dDdXJzb3IgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJGN1cnNvckxheWVyLnNob3dDdXJzb3IoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5zY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IGZ1bmN0aW9uKGFuY2hvciwgbGVhZCwgb2Zmc2V0KSB7XFxuXFx0ICAgICAgICB0aGlzLnNjcm9sbEN1cnNvckludG9WaWV3KGFuY2hvciwgb2Zmc2V0KTtcXG5cXHQgICAgICAgIHRoaXMuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobGVhZCwgb2Zmc2V0KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zY3JvbGxDdXJzb3JJbnRvVmlldyA9IGZ1bmN0aW9uKGN1cnNvciwgb2Zmc2V0LCAkdmlld01hcmdpbikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQgPT09IDApXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdmFyIHBvcyA9IHRoaXMuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oY3Vyc29yKTtcXG5cXG5cXHQgICAgICAgIHZhciBsZWZ0ID0gcG9zLmxlZnQ7XFxuXFx0ICAgICAgICB2YXIgdG9wID0gcG9zLnRvcDtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIHRvcE1hcmdpbiA9ICR2aWV3TWFyZ2luICYmICR2aWV3TWFyZ2luLnRvcCB8fCAwO1xcblxcdCAgICAgICAgdmFyIGJvdHRvbU1hcmdpbiA9ICR2aWV3TWFyZ2luICYmICR2aWV3TWFyZ2luLmJvdHRvbSB8fCAwO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy4kc2Nyb2xsQW5pbWF0aW9uID8gdGhpcy5zZXNzaW9uLmdldFNjcm9sbFRvcCgpIDogdGhpcy5zY3JvbGxUb3A7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChzY3JvbGxUb3AgKyB0b3BNYXJnaW4gPiB0b3ApIHtcXG5cXHQgICAgICAgICAgICBpZiAob2Zmc2V0KVxcblxcdCAgICAgICAgICAgICAgICB0b3AgLT0gb2Zmc2V0ICogdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodDtcXG5cXHQgICAgICAgICAgICBpZiAodG9wID09PSAwKVxcblxcdCAgICAgICAgICAgICAgICB0b3AgPSAtdGhpcy5zY3JvbGxNYXJnaW4udG9wO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AodG9wKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsVG9wICsgdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIGJvdHRvbU1hcmdpbiA8IHRvcCArIHRoaXMubGluZUhlaWdodCkge1xcblxcdCAgICAgICAgICAgIGlmIChvZmZzZXQpXFxuXFx0ICAgICAgICAgICAgICAgIHRvcCArPSBvZmZzZXQgKiB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0O1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AodG9wICsgdGhpcy5saW5lSGVpZ2h0IC0gdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcXG5cXG5cXHQgICAgICAgIGlmIChzY3JvbGxMZWZ0ID4gbGVmdCkge1xcblxcdCAgICAgICAgICAgIGlmIChsZWZ0IDwgdGhpcy4kcGFkZGluZyArIDIgKiB0aGlzLmxheWVyQ29uZmlnLmNoYXJhY3RlcldpZHRoKVxcblxcdCAgICAgICAgICAgICAgICBsZWZ0ID0gLXRoaXMuc2Nyb2xsTWFyZ2luLmxlZnQ7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNldFNjcm9sbExlZnQobGVmdCk7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbExlZnQgKyB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGggPCBsZWZ0ICsgdGhpcy5jaGFyYWN0ZXJXaWR0aCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KE1hdGgucm91bmQobGVmdCArIHRoaXMuY2hhcmFjdGVyV2lkdGggLSB0aGlzLiRzaXplLnNjcm9sbGVyV2lkdGgpKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsTGVmdCA8PSB0aGlzLiRwYWRkaW5nICYmIGxlZnQgLSBzY3JvbGxMZWZ0IDwgdGhpcy5jaGFyYWN0ZXJXaWR0aCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KDApO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmdldFNjcm9sbExlZnQoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTY3JvbGxUb3BSb3cgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcCAvIHRoaXMubGluZUhlaWdodDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5nZXRTY3JvbGxCb3R0b21Sb3cgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKCh0aGlzLnNjcm9sbFRvcCArIHRoaXMuJHNpemUuc2Nyb2xsZXJIZWlnaHQpIC8gdGhpcy5saW5lSGVpZ2h0KSAtIDEpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNjcm9sbFRvUm93ID0gZnVuY3Rpb24ocm93KSB7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKHJvdyAqIHRoaXMubGluZUhlaWdodCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYWxpZ25DdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IsIGFsaWdubWVudCkge1xcblxcdCAgICAgICAgaWYgKHR5cGVvZiBjdXJzb3IgPT0gXFxcIm51bWJlclxcXCIpXFxuXFx0ICAgICAgICAgICAgY3Vyc29yID0ge3JvdzogY3Vyc29yLCBjb2x1bW46IDB9O1xcblxcblxcdCAgICAgICAgdmFyIHBvcyA9IHRoaXMuJGN1cnNvckxheWVyLmdldFBpeGVsUG9zaXRpb24oY3Vyc29yKTtcXG5cXHQgICAgICAgIHZhciBoID0gdGhpcy4kc2l6ZS5zY3JvbGxlckhlaWdodCAtIHRoaXMubGluZUhlaWdodDtcXG5cXHQgICAgICAgIHZhciBvZmZzZXQgPSBwb3MudG9wIC0gaCAqIChhbGlnbm1lbnQgfHwgMCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKG9mZnNldCk7XFxuXFx0ICAgICAgICByZXR1cm4gb2Zmc2V0O1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLlNURVBTID0gODtcXG5cXHQgICAgdGhpcy4kY2FsY1N0ZXBzID0gZnVuY3Rpb24oZnJvbVZhbHVlLCB0b1ZhbHVlKXtcXG5cXHQgICAgICAgIHZhciBpID0gMDtcXG5cXHQgICAgICAgIHZhciBsID0gdGhpcy5TVEVQUztcXG5cXHQgICAgICAgIHZhciBzdGVwcyA9IFtdO1xcblxcblxcdCAgICAgICAgdmFyIGZ1bmMgID0gZnVuY3Rpb24odCwgeF9taW4sIGR4KSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGR4ICogKE1hdGgucG93KHQgLSAxLCAzKSArIDEpICsgeF9taW47XFxuXFx0ICAgICAgICB9O1xcblxcblxcdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSlcXG5cXHQgICAgICAgICAgICBzdGVwcy5wdXNoKGZ1bmMoaSAvIHRoaXMuU1RFUFMsIGZyb21WYWx1ZSwgdG9WYWx1ZSAtIGZyb21WYWx1ZSkpO1xcblxcblxcdCAgICAgICAgcmV0dXJuIHN0ZXBzO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNjcm9sbFRvTGluZSA9IGZ1bmN0aW9uKGxpbmUsIGNlbnRlciwgYW5pbWF0ZSwgY2FsbGJhY2spIHtcXG5cXHQgICAgICAgIHZhciBwb3MgPSB0aGlzLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKHtyb3c6IGxpbmUsIGNvbHVtbjogMH0pO1xcblxcdCAgICAgICAgdmFyIG9mZnNldCA9IHBvcy50b3A7XFxuXFx0ICAgICAgICBpZiAoY2VudGVyKVxcblxcdCAgICAgICAgICAgIG9mZnNldCAtPSB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0IC8gMjtcXG5cXG5cXHQgICAgICAgIHZhciBpbml0aWFsU2Nyb2xsID0gdGhpcy5zY3JvbGxUb3A7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsVG9wKG9mZnNldCk7XFxuXFx0ICAgICAgICBpZiAoYW5pbWF0ZSAhPT0gZmFsc2UpXFxuXFx0ICAgICAgICAgICAgdGhpcy5hbmltYXRlU2Nyb2xsaW5nKGluaXRpYWxTY3JvbGwsIGNhbGxiYWNrKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5hbmltYXRlU2Nyb2xsaW5nID0gZnVuY3Rpb24oZnJvbVZhbHVlLCBjYWxsYmFjaykge1xcblxcdCAgICAgICAgdmFyIHRvVmFsdWUgPSB0aGlzLnNjcm9sbFRvcDtcXG5cXHQgICAgICAgIGlmICghdGhpcy4kYW5pbWF0ZWRTY3JvbGwpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKGZyb21WYWx1ZSA9PSB0b1ZhbHVlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHRoaXMuJHNjcm9sbEFuaW1hdGlvbikge1xcblxcdCAgICAgICAgICAgIHZhciBvbGRTdGVwcyA9IHRoaXMuJHNjcm9sbEFuaW1hdGlvbi5zdGVwcztcXG5cXHQgICAgICAgICAgICBpZiAob2xkU3RlcHMubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGZyb21WYWx1ZSA9IG9sZFN0ZXBzWzBdO1xcblxcdCAgICAgICAgICAgICAgICBpZiAoZnJvbVZhbHVlID09IHRvVmFsdWUpXFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgc3RlcHMgPSBfc2VsZi4kY2FsY1N0ZXBzKGZyb21WYWx1ZSwgdG9WYWx1ZSk7XFxuXFx0ICAgICAgICB0aGlzLiRzY3JvbGxBbmltYXRpb24gPSB7ZnJvbTogZnJvbVZhbHVlLCB0bzogdG9WYWx1ZSwgc3RlcHM6IHN0ZXBzfTtcXG5cXG5cXHQgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy4kdGltZXIpO1xcblxcblxcdCAgICAgICAgX3NlbGYuc2Vzc2lvbi5zZXRTY3JvbGxUb3Aoc3RlcHMuc2hpZnQoKSk7XFxuXFx0ICAgICAgICBfc2VsZi5zZXNzaW9uLiRzY3JvbGxUb3AgPSB0b1ZhbHVlO1xcblxcdCAgICAgICAgdGhpcy4kdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBpZiAoc3RlcHMubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgICAgIF9zZWxmLnNlc3Npb24uc2V0U2Nyb2xsVG9wKHN0ZXBzLnNoaWZ0KCkpO1xcblxcdCAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLiRzY3JvbGxUb3AgPSB0b1ZhbHVlO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSBpZiAodG9WYWx1ZSAhPSBudWxsKSB7XFxuXFx0ICAgICAgICAgICAgICAgIF9zZWxmLnNlc3Npb24uJHNjcm9sbFRvcCA9IC0xO1xcblxcdCAgICAgICAgICAgICAgICBfc2VsZi5zZXNzaW9uLnNldFNjcm9sbFRvcCh0b1ZhbHVlKTtcXG5cXHQgICAgICAgICAgICAgICAgdG9WYWx1ZSA9IG51bGw7XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgX3NlbGYuJHRpbWVyID0gY2xlYXJJbnRlcnZhbChfc2VsZi4kdGltZXIpO1xcblxcdCAgICAgICAgICAgICAgICBfc2VsZi4kc2Nyb2xsQW5pbWF0aW9uID0gbnVsbDtcXG5cXHQgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9LCAxMCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2Nyb2xsVG9ZID0gZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3AgIT09IHNjcm9sbFRvcCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfU0NST0xMKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zY3JvbGxUb1ggPSBmdW5jdGlvbihzY3JvbGxMZWZ0KSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0ICE9PSBzY3JvbGxMZWZ0KVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XFxuXFx0ICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0hfU0NST0xMKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zY3JvbGxUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxUb3AoeSk7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2V0U2Nyb2xsTGVmdCh5KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zY3JvbGxCeSA9IGZ1bmN0aW9uKGRlbHRhWCwgZGVsdGFZKSB7XFxuXFx0ICAgICAgICBkZWx0YVkgJiYgdGhpcy5zZXNzaW9uLnNldFNjcm9sbFRvcCh0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgKyBkZWx0YVkpO1xcblxcdCAgICAgICAgZGVsdGFYICYmIHRoaXMuc2Vzc2lvbi5zZXRTY3JvbGxMZWZ0KHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxMZWZ0KCkgKyBkZWx0YVgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmlzU2Nyb2xsYWJsZUJ5ID0gZnVuY3Rpb24oZGVsdGFYLCBkZWx0YVkpIHtcXG5cXHQgICAgICAgIGlmIChkZWx0YVkgPCAwICYmIHRoaXMuc2Vzc2lvbi5nZXRTY3JvbGxUb3AoKSA+PSAxIC0gdGhpcy5zY3JvbGxNYXJnaW4udG9wKVxcblxcdCAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICBpZiAoZGVsdGFZID4gMCAmJiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsVG9wKCkgKyB0aGlzLiRzaXplLnNjcm9sbGVySGVpZ2h0XFxuXFx0ICAgICAgICAgICAgLSB0aGlzLmxheWVyQ29uZmlnLm1heEhlaWdodCA8IC0xICsgdGhpcy5zY3JvbGxNYXJnaW4uYm90dG9tKVxcblxcdCAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuXFx0ICAgICAgICBpZiAoZGVsdGFYIDwgMCAmJiB0aGlzLnNlc3Npb24uZ2V0U2Nyb2xsTGVmdCgpID49IDEgLSB0aGlzLnNjcm9sbE1hcmdpbi5sZWZ0KVxcblxcdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgaWYgKGRlbHRhWCA+IDAgJiYgdGhpcy5zZXNzaW9uLmdldFNjcm9sbExlZnQoKSArIHRoaXMuJHNpemUuc2Nyb2xsZXJXaWR0aFxcblxcdCAgICAgICAgICAgIC0gdGhpcy5sYXllckNvbmZpZy53aWR0aCA8IC0xICsgdGhpcy5zY3JvbGxNYXJnaW4ucmlnaHQpXFxuXFx0ICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5waXhlbFRvU2NyZWVuQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5KSB7XFxuXFx0ICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXG5cXHQgICAgICAgIHZhciBvZmZzZXQgPSAoeCArIHRoaXMuc2Nyb2xsTGVmdCAtIGNhbnZhc1Bvcy5sZWZ0IC0gdGhpcy4kcGFkZGluZykgLyB0aGlzLmNoYXJhY3RlcldpZHRoO1xcblxcdCAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoKHkgKyB0aGlzLnNjcm9sbFRvcCAtIGNhbnZhc1Bvcy50b3ApIC8gdGhpcy5saW5lSGVpZ2h0KTtcXG5cXHQgICAgICAgIHZhciBjb2wgPSBNYXRoLnJvdW5kKG9mZnNldCk7XFxuXFxuXFx0ICAgICAgICByZXR1cm4ge3Jvdzogcm93LCBjb2x1bW46IGNvbCwgc2lkZTogb2Zmc2V0IC0gY29sID4gMCA/IDEgOiAtMX07XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2NyZWVuVG9UZXh0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5KSB7XFxuXFx0ICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXG5cXHQgICAgICAgIHZhciBjb2wgPSBNYXRoLnJvdW5kKFxcblxcdCAgICAgICAgICAgICh4ICsgdGhpcy5zY3JvbGxMZWZ0IC0gY2FudmFzUG9zLmxlZnQgLSB0aGlzLiRwYWRkaW5nKSAvIHRoaXMuY2hhcmFjdGVyV2lkdGhcXG5cXHQgICAgICAgICk7XFxuXFxuXFx0ICAgICAgICB2YXIgcm93ID0gKHkgKyB0aGlzLnNjcm9sbFRvcCAtIGNhbnZhc1Bvcy50b3ApIC8gdGhpcy5saW5lSGVpZ2h0O1xcblxcblxcdCAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24ocm93LCBNYXRoLm1heChjb2wsIDApKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy50ZXh0VG9TY3JlZW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uKHJvdywgY29sdW1uKSB7XFxuXFx0ICAgICAgICB2YXIgY2FudmFzUG9zID0gdGhpcy5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG5cXHQgICAgICAgIHZhciBwb3MgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHJvdywgY29sdW1uKTtcXG5cXG5cXHQgICAgICAgIHZhciB4ID0gdGhpcy4kcGFkZGluZyArIE1hdGgucm91bmQocG9zLmNvbHVtbiAqIHRoaXMuY2hhcmFjdGVyV2lkdGgpO1xcblxcdCAgICAgICAgdmFyIHkgPSBwb3Mucm93ICogdGhpcy5saW5lSGVpZ2h0O1xcblxcblxcdCAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICBwYWdlWDogY2FudmFzUG9zLmxlZnQgKyB4IC0gdGhpcy5zY3JvbGxMZWZ0LFxcblxcdCAgICAgICAgICAgIHBhZ2VZOiBjYW52YXNQb3MudG9wICsgeSAtIHRoaXMuc2Nyb2xsVG9wXFxuXFx0ICAgICAgICB9O1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnZpc3VhbGl6ZUZvY3VzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBkb20uYWRkQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFxcXCJhY2VfZm9jdXNcXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy52aXN1YWxpemVCbHVyID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy5jb250YWluZXIsIFxcXCJhY2VfZm9jdXNcXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zaG93Q29tcG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiRjb21wb3NpdGlvbilcXG5cXHQgICAgICAgICAgICB0aGlzLiRjb21wb3NpdGlvbiA9IHtcXG5cXHQgICAgICAgICAgICAgICAga2VlcFRleHRBcmVhQXRDdXJzb3I6IHRoaXMuJGtlZXBUZXh0QXJlYUF0Q3Vyc29yLFxcblxcdCAgICAgICAgICAgICAgICBjc3NUZXh0OiB0aGlzLnRleHRhcmVhLnN0eWxlLmNzc1RleHRcXG5cXHQgICAgICAgICAgICB9O1xcblxcblxcdCAgICAgICAgdGhpcy4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSB0cnVlO1xcblxcdCAgICAgICAgZG9tLmFkZENzc0NsYXNzKHRoaXMudGV4dGFyZWEsIFxcXCJhY2VfY29tcG9zaXRpb25cXFwiKTtcXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgdGhpcy4kbW92ZVRleHRBcmVhVG9DdXJzb3IoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRDb21wb3NpdGlvblRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XFxuXFx0ICAgICAgICB0aGlzLiRtb3ZlVGV4dEFyZWFUb0N1cnNvcigpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmhpZGVDb21wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLiRjb21wb3NpdGlvbilcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModGhpcy50ZXh0YXJlYSwgXFxcImFjZV9jb21wb3NpdGlvblxcXCIpO1xcblxcdCAgICAgICAgdGhpcy4ka2VlcFRleHRBcmVhQXRDdXJzb3IgPSB0aGlzLiRjb21wb3NpdGlvbi5rZWVwVGV4dEFyZWFBdEN1cnNvcjtcXG5cXHQgICAgICAgIHRoaXMudGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9IHRoaXMuJGNvbXBvc2l0aW9uLmNzc1RleHQ7XFxuXFx0ICAgICAgICB0aGlzLiRjb21wb3NpdGlvbiA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0VGhlbWUgPSBmdW5jdGlvbih0aGVtZSwgY2IpIHtcXG5cXHQgICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XFxuXFx0ICAgICAgICB0aGlzLiR0aGVtZUlkID0gdGhlbWU7XFxuXFx0ICAgICAgICBfc2VsZi5fZGlzcGF0Y2hFdmVudCgndGhlbWVDaGFuZ2UnLHt0aGVtZTp0aGVtZX0pO1xcblxcblxcdCAgICAgICAgaWYgKCF0aGVtZSB8fCB0eXBlb2YgdGhlbWUgPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IHRoZW1lIHx8IHRoaXMuJG9wdGlvbnMudGhlbWUuaW5pdGlhbFZhbHVlO1xcblxcdCAgICAgICAgICAgIGNvbmZpZy5sb2FkTW9kdWxlKFtcXFwidGhlbWVcXFwiLCBtb2R1bGVOYW1lXSwgYWZ0ZXJMb2FkKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgYWZ0ZXJMb2FkKHRoZW1lKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGZ1bmN0aW9uIGFmdGVyTG9hZChtb2R1bGUpIHtcXG5cXHQgICAgICAgICAgICBpZiAoX3NlbGYuJHRoZW1lSWQgIT0gdGhlbWUpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiBjYiAmJiBjYigpO1xcblxcdCAgICAgICAgICAgIGlmICghbW9kdWxlLmNzc0NsYXNzKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgZG9tLmltcG9ydENzc1N0cmluZyhcXG5cXHQgICAgICAgICAgICAgICAgbW9kdWxlLmNzc1RleHQsXFxuXFx0ICAgICAgICAgICAgICAgIG1vZHVsZS5jc3NDbGFzcyxcXG5cXHQgICAgICAgICAgICAgICAgX3NlbGYuY29udGFpbmVyLm93bmVyRG9jdW1lbnRcXG5cXHQgICAgICAgICAgICApO1xcblxcblxcdCAgICAgICAgICAgIGlmIChfc2VsZi50aGVtZSlcXG5cXHQgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNzc0NsYXNzKF9zZWxmLmNvbnRhaW5lciwgX3NlbGYudGhlbWUuY3NzQ2xhc3MpO1xcblxcblxcdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gXFxcInBhZGRpbmdcXFwiIGluIG1vZHVsZSA/IG1vZHVsZS5wYWRkaW5nIFxcblxcdCAgICAgICAgICAgICAgICA6IFxcXCJwYWRkaW5nXFxcIiBpbiAoX3NlbGYudGhlbWUgfHwge30pID8gNCA6IF9zZWxmLiRwYWRkaW5nO1xcblxcdCAgICAgICAgICAgIGlmIChfc2VsZi4kcGFkZGluZyAmJiBwYWRkaW5nICE9IF9zZWxmLiRwYWRkaW5nKVxcblxcdCAgICAgICAgICAgICAgICBfc2VsZi5zZXRQYWRkaW5nKHBhZGRpbmcpO1xcblxcdCAgICAgICAgICAgIF9zZWxmLiR0aGVtZSA9IG1vZHVsZS5jc3NDbGFzcztcXG5cXG5cXHQgICAgICAgICAgICBfc2VsZi50aGVtZSA9IG1vZHVsZTtcXG5cXHQgICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3MoX3NlbGYuY29udGFpbmVyLCBtb2R1bGUuY3NzQ2xhc3MpO1xcblxcdCAgICAgICAgICAgIGRvbS5zZXRDc3NDbGFzcyhfc2VsZi5jb250YWluZXIsIFxcXCJhY2VfZGFya1xcXCIsIG1vZHVsZS5pc0RhcmspO1xcblxcdCAgICAgICAgICAgIGlmIChfc2VsZi4kc2l6ZSkge1xcblxcdCAgICAgICAgICAgICAgICBfc2VsZi4kc2l6ZS53aWR0aCA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIF9zZWxmLiR1cGRhdGVTaXplQXN5bmMoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgX3NlbGYuX2Rpc3BhdGNoRXZlbnQoJ3RoZW1lTG9hZGVkJywge3RoZW1lOm1vZHVsZX0pO1xcblxcdCAgICAgICAgICAgIGNiICYmIGNiKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0VGhlbWUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHJldHVybiB0aGlzLiR0aGVtZUlkO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUsIGluY2x1ZGUpIHtcXG5cXHQgICAgICAgIGRvbS5zZXRDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgc3R5bGUsIGluY2x1ZGUgIT09IGZhbHNlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy51bnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcXG5cXHQgICAgICAgIGRvbS5yZW1vdmVDc3NDbGFzcyh0aGlzLmNvbnRhaW5lciwgc3R5bGUpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5zZXRDdXJzb3JTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5zY3JvbGxlci5zdHlsZS5jdXJzb3IgIT0gc3R5bGUpXFxuXFx0ICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zdHlsZS5jdXJzb3IgPSBzdHlsZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZXRNb3VzZUN1cnNvciA9IGZ1bmN0aW9uKGN1cnNvclN0eWxlKSB7XFxuXFx0ICAgICAgICB0aGlzLnNjcm9sbGVyLnN0eWxlLmN1cnNvciA9IGN1cnNvclN0eWxlO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuJHRleHRMYXllci5kZXN0cm95KCk7XFxuXFx0ICAgICAgICB0aGlzLiRjdXJzb3JMYXllci5kZXN0cm95KCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlKTtcXG5cXG5cXG5cXHRjb25maWcuZGVmaW5lT3B0aW9ucyhWaXJ0dWFsUmVuZGVyZXIucHJvdG90eXBlLCBcXFwicmVuZGVyZXJcXFwiLCB7XFxuXFx0ICAgIGFuaW1hdGVkU2Nyb2xsOiB7aW5pdGlhbFZhbHVlOiBmYWxzZX0sXFxuXFx0ICAgIHNob3dJbnZpc2libGVzOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJHRleHRMYXllci5zZXRTaG93SW52aXNpYmxlcyh2YWx1ZSkpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxcblxcdCAgICB9LFxcblxcdCAgICBzaG93UHJpbnRNYXJnaW46IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24oKSB7IHRoaXMuJHVwZGF0ZVByaW50TWFyZ2luKCk7IH0sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgcHJpbnRNYXJnaW5Db2x1bW46IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24oKSB7IHRoaXMuJHVwZGF0ZVByaW50TWFyZ2luKCk7IH0sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IDgwXFxuXFx0ICAgIH0sXFxuXFx0ICAgIHByaW50TWFyZ2luOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xcblxcdCAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09IFxcXCJudW1iZXJcXFwiKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRwcmludE1hcmdpbkNvbHVtbiA9IHZhbDtcXG5cXHQgICAgICAgICAgICB0aGlzLiRzaG93UHJpbnRNYXJnaW4gPSAhIXZhbDtcXG5cXHQgICAgICAgICAgICB0aGlzLiR1cGRhdGVQcmludE1hcmdpbigpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNob3dQcmludE1hcmdpbiAmJiB0aGlzLiRwcmludE1hcmdpbkNvbHVtbjsgXFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHNob3dHdXR0ZXI6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24oc2hvdyl7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kZ3V0dGVyLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gXFxcImJsb2NrXFxcIiA6IFxcXCJub25lXFxcIjtcXG5cXHQgICAgICAgICAgICB0aGlzLiRsb29wLnNjaGVkdWxlKHRoaXMuQ0hBTkdFX0ZVTEwpO1xcblxcdCAgICAgICAgICAgIHRoaXMub25HdXR0ZXJSZXNpemUoKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgZmFkZUZvbGRXaWRnZXRzOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHNob3cpIHtcXG5cXHQgICAgICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy4kZ3V0dGVyLCBcXFwiYWNlX2ZhZGUtZm9sZC13aWRnZXRzXFxcIiwgc2hvdyk7XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiBmYWxzZVxcblxcdCAgICB9LFxcblxcdCAgICBzaG93Rm9sZFdpZGdldHM6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24oc2hvdykge3RoaXMuJGd1dHRlckxheWVyLnNldFNob3dGb2xkV2lkZ2V0cyhzaG93KX0sXFxuXFx0ICAgICAgICBpbml0aWFsVmFsdWU6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgc2hvd0xpbmVOdW1iZXJzOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHNob3cpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci5zZXRTaG93TGluZU51bWJlcnMoc2hvdyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9HVVRURVIpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogdHJ1ZVxcblxcdCAgICB9LFxcblxcdCAgICBkaXNwbGF5SW5kZW50R3VpZGVzOiB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHNob3cpIHtcXG5cXHQgICAgICAgICAgICBpZiAodGhpcy4kdGV4dExheWVyLnNldERpc3BsYXlJbmRlbnRHdWlkZXMoc2hvdykpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfVEVYVCk7XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgaW5pdGlhbFZhbHVlOiB0cnVlXFxuXFx0ICAgIH0sXFxuXFx0ICAgIGhpZ2hsaWdodEd1dHRlckxpbmU6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24oc2hvdWxkSGlnaGxpZ2h0KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCF0aGlzLiRndXR0ZXJMaW5lSGlnaGxpZ2h0KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxpbmVIaWdobGlnaHQgPSBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuJGd1dHRlckxpbmVIaWdobGlnaHQuY2xhc3NOYW1lID0gXFxcImFjZV9ndXR0ZXItYWN0aXZlLWxpbmVcXFwiO1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLiRndXR0ZXIuYXBwZW5kQ2hpbGQodGhpcy4kZ3V0dGVyTGluZUhpZ2hsaWdodCk7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICB9XFxuXFxuXFx0ICAgICAgICAgICAgdGhpcy4kZ3V0dGVyTGluZUhpZ2hsaWdodC5zdHlsZS5kaXNwbGF5ID0gc2hvdWxkSGlnaGxpZ2h0ID8gXFxcIlxcXCIgOiBcXFwibm9uZVxcXCI7XFxuXFx0ICAgICAgICAgICAgaWYgKHRoaXMuJGN1cnNvckxheWVyLiRwaXhlbFBvcylcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kdXBkYXRlR3V0dGVyTGluZUhpZ2hsaWdodCgpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2UsXFxuXFx0ICAgICAgICB2YWx1ZTogdHJ1ZVxcblxcdCAgICB9LFxcblxcdCAgICBoU2Nyb2xsQmFyQWx3YXlzVmlzaWJsZToge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgICAgICBpZiAoIXRoaXMuJGhTY3JvbGxCYXJBbHdheXNWaXNpYmxlIHx8ICF0aGlzLiRob3JpelNjcm9sbClcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9TQ1JPTEwpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcXG5cXHQgICAgfSxcXG5cXHQgICAgdlNjcm9sbEJhckFsd2F5c1Zpc2libGU6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCF0aGlzLiR2U2Nyb2xsQmFyQWx3YXlzVmlzaWJsZSB8fCAhdGhpcy4kdlNjcm9sbClcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9TQ1JPTEwpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogZmFsc2VcXG5cXHQgICAgfSxcXG5cXHQgICAgZm9udFNpemU6ICB7XFxuXFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHNpemUpIHtcXG5cXHQgICAgICAgICAgICBpZiAodHlwZW9mIHNpemUgPT0gXFxcIm51bWJlclxcXCIpXFxuXFx0ICAgICAgICAgICAgICAgIHNpemUgPSBzaXplICsgXFxcInB4XFxcIjtcXG5cXHQgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5mb250U2l6ZSA9IHNpemU7XFxuXFx0ICAgICAgICAgICAgdGhpcy51cGRhdGVGb250U2l6ZSgpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogMTJcXG5cXHQgICAgfSxcXG5cXHQgICAgZm9udEZhbWlseToge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy51cGRhdGVGb250U2l6ZSgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9LFxcblxcdCAgICBtYXhMaW5lczoge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZUZ1bGwoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgbWluTGluZXM6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy51cGRhdGVGdWxsKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH0sXFxuXFx0ICAgIHNjcm9sbFBhc3RFbmQ6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XFxuXFx0ICAgICAgICAgICAgdmFsID0gK3ZhbCB8fCAwO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLiRzY3JvbGxQYXN0RW5kID09IHZhbClcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIHRoaXMuJHNjcm9sbFBhc3RFbmQgPSB2YWw7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kbG9vcC5zY2hlZHVsZSh0aGlzLkNIQU5HRV9TQ1JPTEwpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogMCxcXG5cXHQgICAgICAgIGhhbmRsZXNTZXQ6IHRydWVcXG5cXHQgICAgfSxcXG5cXHQgICAgZml4ZWRXaWR0aEd1dHRlcjoge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLiRndXR0ZXJMYXllci4kZml4ZWRXaWR0aCA9ICEhdmFsO1xcblxcdCAgICAgICAgICAgIHRoaXMuJGxvb3Auc2NoZWR1bGUodGhpcy5DSEFOR0VfR1VUVEVSKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSxcXG5cXHQgICAgdGhlbWU6IHtcXG5cXHQgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7IHRoaXMuc2V0VGhlbWUodmFsKSB9LFxcblxcdCAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuJHRoZW1lSWQgfHwgdGhpcy50aGVtZTsgfSxcXG5cXHQgICAgICAgIGluaXRpYWxWYWx1ZTogXFxcIi4vdGhlbWUvdGV4dG1hdGVcXFwiLFxcblxcdCAgICAgICAgaGFuZGxlc1NldDogdHJ1ZVxcblxcdCAgICB9XFxuXFx0fSk7XFxuXFxuXFx0ZXhwb3J0cy5WaXJ0dWFsUmVuZGVyZXIgPSBWaXJ0dWFsUmVuZGVyZXI7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL3dvcmtlci93b3JrZXJfY2xpZW50XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiLFxcXCJhY2UvbGliL25ldFxcXCIsXFxcImFjZS9saWIvZXZlbnRfZW1pdHRlclxcXCIsXFxcImFjZS9jb25maWdcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgbmV0ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9uZXRcXFwiKTtcXG5cXHR2YXIgRXZlbnRFbWl0dGVyID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9ldmVudF9lbWl0dGVyXFxcIikuRXZlbnRFbWl0dGVyO1xcblxcdHZhciBjb25maWcgPSBhY2VxdWlyZShcXFwiLi4vY29uZmlnXFxcIik7XFxuXFxuXFx0dmFyIFdvcmtlckNsaWVudCA9IGZ1bmN0aW9uKHRvcExldmVsTmFtZXNwYWNlcywgbW9kLCBjbGFzc25hbWUsIHdvcmtlclVybCkge1xcblxcdCAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IHRoaXMuJHNlbmREZWx0YVF1ZXVlLmJpbmQodGhpcyk7XFxuXFx0ICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSB0aGlzLmNoYW5nZUxpc3RlbmVyLmJpbmQodGhpcyk7XFxuXFx0ICAgIHRoaXMub25NZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcXG5cXHQgICAgaWYgKGFjZXF1aXJlLm5hbWVUb1VybCAmJiAhYWNlcXVpcmUudG9VcmwpXFxuXFx0ICAgICAgICBhY2VxdWlyZS50b1VybCA9IGFjZXF1aXJlLm5hbWVUb1VybDtcXG5cXHQgICAgXFxuXFx0ICAgIGlmIChjb25maWcuZ2V0KFxcXCJwYWNrYWdlZFxcXCIpIHx8ICFhY2VxdWlyZS50b1VybCkge1xcblxcdCAgICAgICAgd29ya2VyVXJsID0gd29ya2VyVXJsIHx8IGNvbmZpZy5tb2R1bGVVcmwobW9kLmlkLCBcXFwid29ya2VyXFxcIilcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIHZhciBub3JtYWxpemVQYXRoID0gdGhpcy4kbm9ybWFsaXplUGF0aDtcXG5cXHQgICAgICAgIHdvcmtlclVybCA9IHdvcmtlclVybCB8fCBub3JtYWxpemVQYXRoKGFjZXF1aXJlLnRvVXJsKFxcXCJhY2Uvd29ya2VyL3dvcmtlci5qc1xcXCIsIG51bGwsIFxcXCJfXFxcIikpO1xcblxcblxcdCAgICAgICAgdmFyIHRsbnMgPSB7fTtcXG5cXHQgICAgICAgIHRvcExldmVsTmFtZXNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKG5zKSB7XFxuXFx0ICAgICAgICAgICAgdGxuc1tuc10gPSBub3JtYWxpemVQYXRoKGFjZXF1aXJlLnRvVXJsKG5zLCBudWxsLCBcXFwiX1xcXCIpLnJlcGxhY2UoLyhcXFxcLmpzKT8oXFxcXD8uKik/JC8sIFxcXCJcXFwiKSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB0cnkge1xcblxcdCAgICAgICAgICAgIHZhciB3b3JrZXJTcmMgPSBtb2Quc3JjO1xcblxcdCAgICB2YXIgQmxvYiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xcblxcdCAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFsgd29ya2VyU3JjIF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pO1xcblxcdCAgICB2YXIgYmxvYlVybCA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcXG5cXG5cXHQgICAgdGhpcy4kd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcXG5cXG5cXHQgICAgfSBjYXRjaChlKSB7XFxuXFx0ICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHdpbmRvdy5ET01FeGNlcHRpb24pIHtcXG5cXHQgICAgICAgICAgICB2YXIgYmxvYiA9IHRoaXMuJHdvcmtlckJsb2Iod29ya2VyVXJsKTtcXG5cXHQgICAgICAgICAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xcblxcdCAgICAgICAgICAgIHZhciBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcXG5cXG5cXHQgICAgICAgICAgICB0aGlzLiR3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVUkwpO1xcblxcdCAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRocm93IGU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgdGhpcy4kd29ya2VyLnBvc3RNZXNzYWdlKHtcXG5cXHQgICAgICAgIGluaXQgOiB0cnVlLFxcblxcdCAgICAgICAgdGxucyA6IHRsbnMsXFxuXFx0ICAgICAgICBtb2R1bGUgOiBtb2QuaWQsXFxuXFx0ICAgICAgICBjbGFzc25hbWUgOiBjbGFzc25hbWVcXG5cXHQgICAgfSk7XFxuXFxuXFx0ICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XFxuXFx0ICAgIHRoaXMuY2FsbGJhY2tzID0ge307XFxuXFxuXFx0ICAgIHRoaXMuJHdvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpe1xcblxcblxcdCAgICBvb3AuaW1wbGVtZW50KHRoaXMsIEV2ZW50RW1pdHRlcik7XFxuXFxuXFx0ICAgIHRoaXMub25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIG1zZyA9IGUuZGF0YTtcXG5cXHQgICAgICAgIHN3aXRjaChtc2cudHlwZSkge1xcblxcdCAgICAgICAgICAgIGNhc2UgXFxcImV2ZW50XFxcIjpcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsKG1zZy5uYW1lLCB7ZGF0YTogbXNnLmRhdGF9KTtcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgY2FzZSBcXFwiY2FsbFxcXCI6XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW21zZy5pZF07XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobXNnLmRhdGEpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW21zZy5pZF07XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgY2FzZSBcXFwiZXJyb3JcXFwiOlxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG1zZy5kYXRhKTtcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgY2FzZSBcXFwibG9nXFxcIjpcXG5cXHQgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cgJiYgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgbXNnLmRhdGEpO1xcblxcdCAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xcblxcdCAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKGVycik7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbihwYXRoKSB7XFxuXFx0ICAgICAgICByZXR1cm4gbmV0LnF1YWxpZnlVUkwocGF0aCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMudGVybWluYXRlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLl9zaWduYWwoXFxcInRlcm1pbmF0ZVxcXCIsIHt9KTtcXG5cXHQgICAgICAgIHRoaXMuZGVsdGFRdWV1ZSA9IG51bGw7XFxuXFx0ICAgICAgICB0aGlzLiR3b3JrZXIudGVybWluYXRlKCk7XFxuXFx0ICAgICAgICB0aGlzLiR3b3JrZXIgPSBudWxsO1xcblxcdCAgICAgICAgaWYgKHRoaXMuJGRvYylcXG5cXHQgICAgICAgICAgICB0aGlzLiRkb2Mub2ZmKFxcXCJjaGFuZ2VcXFwiLCB0aGlzLmNoYW5nZUxpc3RlbmVyKTtcXG5cXHQgICAgICAgIHRoaXMuJGRvYyA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGNtZCwgYXJncykge1xcblxcdCAgICAgICAgdGhpcy4kd29ya2VyLnBvc3RNZXNzYWdlKHtjb21tYW5kOiBjbWQsIGFyZ3M6IGFyZ3N9KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jYWxsID0gZnVuY3Rpb24oY21kLCBhcmdzLCBjYWxsYmFjaykge1xcblxcdCAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5jYWxsYmFja0lkKys7XFxuXFx0ICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XFxuXFx0ICAgICAgICAgICAgYXJncy5wdXNoKGlkKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuc2VuZChjbWQsIGFyZ3MpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmVtaXQgPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xcblxcdCAgICAgICAgdHJ5IHtcXG5cXHQgICAgICAgICAgICB0aGlzLiR3b3JrZXIucG9zdE1lc3NhZ2Uoe2V2ZW50OiBldmVudCwgZGF0YToge2RhdGE6IGRhdGEuZGF0YX19KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGNhdGNoKGV4KSB7XFxuXFx0ICAgICAgICAgICAgY29uc29sZS5lcnJvcihleC5zdGFjayk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYXR0YWNoVG9Eb2N1bWVudCA9IGZ1bmN0aW9uKGRvYykge1xcblxcdCAgICAgICAgaWYodGhpcy4kZG9jKVxcblxcdCAgICAgICAgICAgIHRoaXMudGVybWluYXRlKCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRkb2MgPSBkb2M7XFxuXFx0ICAgICAgICB0aGlzLmNhbGwoXFxcInNldFZhbHVlXFxcIiwgW2RvYy5nZXRWYWx1ZSgpXSk7XFxuXFx0ICAgICAgICBkb2Mub24oXFxcImNoYW5nZVxcXCIsIHRoaXMuY2hhbmdlTGlzdGVuZXIpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLmRlbHRhUXVldWUpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmRlbHRhUXVldWUgPSBbZS5kYXRhXTtcXG5cXHQgICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuJHNlbmREZWx0YVF1ZXVlLCAwKTtcXG5cXHQgICAgICAgIH0gZWxzZVxcblxcdCAgICAgICAgICAgIHRoaXMuZGVsdGFRdWV1ZS5wdXNoKGUuZGF0YSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHNlbmREZWx0YVF1ZXVlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgcSA9IHRoaXMuZGVsdGFRdWV1ZTtcXG5cXHQgICAgICAgIGlmICghcSkgcmV0dXJuO1xcblxcdCAgICAgICAgdGhpcy5kZWx0YVF1ZXVlID0gbnVsbDtcXG5cXHQgICAgICAgIGlmIChxLmxlbmd0aCA+IDIwICYmIHEubGVuZ3RoID4gdGhpcy4kZG9jLmdldExlbmd0aCgpID4+IDEpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLmNhbGwoXFxcInNldFZhbHVlXFxcIiwgW3RoaXMuJGRvYy5nZXRWYWx1ZSgpXSk7XFxuXFx0ICAgICAgICB9IGVsc2VcXG5cXHQgICAgICAgICAgICB0aGlzLmVtaXQoXFxcImNoYW5nZVxcXCIsIHtkYXRhOiBxfSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJHdvcmtlckJsb2IgPSBmdW5jdGlvbih3b3JrZXJVcmwpIHtcXG5cXHQgICAgICAgIHZhciBzY3JpcHQgPSBcXFwiaW1wb3J0U2NyaXB0cygnXFxcIiArIG5ldC5xdWFsaWZ5VVJMKHdvcmtlclVybCkgKyBcXFwiJyk7XFxcIjtcXG5cXHQgICAgICAgIHRyeSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtzY3JpcHRdLCB7XFxcInR5cGVcXFwiOiBcXFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFxcXCJ9KTtcXG5cXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgLy8gQmFja3dhcmRzLWNvbXBhdGliaWxpdHlcXG5cXHQgICAgICAgICAgICB2YXIgQmxvYkJ1aWxkZXIgPSB3aW5kb3cuQmxvYkJ1aWxkZXIgfHwgd2luZG93LldlYktpdEJsb2JCdWlsZGVyIHx8IHdpbmRvdy5Nb3pCbG9iQnVpbGRlcjtcXG5cXHQgICAgICAgICAgICB2YXIgYmxvYkJ1aWxkZXIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcXG5cXHQgICAgICAgICAgICBibG9iQnVpbGRlci5hcHBlbmQoc2NyaXB0KTtcXG5cXHQgICAgICAgICAgICByZXR1cm4gYmxvYkJ1aWxkZXIuZ2V0QmxvYihcXFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFxcXCIpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoV29ya2VyQ2xpZW50LnByb3RvdHlwZSk7XFxuXFxuXFxuXFx0dmFyIFVJV29ya2VyQ2xpZW50ID0gZnVuY3Rpb24odG9wTGV2ZWxOYW1lc3BhY2VzLCBtb2QsIGNsYXNzbmFtZSkge1xcblxcdCAgICB0aGlzLiRzZW5kRGVsdGFRdWV1ZSA9IHRoaXMuJHNlbmREZWx0YVF1ZXVlLmJpbmQodGhpcyk7XFxuXFx0ICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSB0aGlzLmNoYW5nZUxpc3RlbmVyLmJpbmQodGhpcyk7XFxuXFx0ICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XFxuXFx0ICAgIHRoaXMuY2FsbGJhY2tzID0ge307XFxuXFx0ICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xcblxcblxcdCAgICB2YXIgbWFpbiA9IG51bGw7XFxuXFx0ICAgIHZhciBlbWl0U3luYyA9IGZhbHNlO1xcblxcdCAgICB2YXIgc2VuZGVyID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIpO1xcblxcdCAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcblxcdCAgICB0aGlzLiR3b3JrZXIgPSB7fTtcXG5cXHQgICAgdGhpcy4kd29ya2VyLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uKCkge307XFxuXFx0ICAgIHRoaXMuJHdvcmtlci5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIF9zZWxmLm1lc3NhZ2VCdWZmZXIucHVzaChlKTtcXG5cXHQgICAgICAgIGlmIChtYWluKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKGVtaXRTeW5jKVxcblxcdCAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHByb2Nlc3NOZXh0KTtcXG5cXHQgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuc2V0RW1pdFN5bmMgPSBmdW5jdGlvbih2YWwpIHsgZW1pdFN5bmMgPSB2YWwgfTtcXG5cXG5cXHQgICAgdmFyIHByb2Nlc3NOZXh0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgbXNnID0gX3NlbGYubWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xcblxcdCAgICAgICAgaWYgKG1zZy5jb21tYW5kKVxcblxcdCAgICAgICAgICAgIG1haW5bbXNnLmNvbW1hbmRdLmFwcGx5KG1haW4sIG1zZy5hcmdzKTtcXG5cXHQgICAgICAgIGVsc2UgaWYgKG1zZy5ldmVudClcXG5cXHQgICAgICAgICAgICBzZW5kZXIuX3NpZ25hbChtc2cuZXZlbnQsIG1zZy5kYXRhKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgc2VuZGVyLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XFxuXFx0ICAgICAgICBfc2VsZi5vbk1lc3NhZ2Uoe2RhdGE6IG1zZ30pO1xcblxcdCAgICB9O1xcblxcdCAgICBzZW5kZXIuY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFja0lkKSB7XFxuXFx0ICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHt0eXBlOiBcXFwiY2FsbFxcXCIsIGlkOiBjYWxsYmFja0lkLCBkYXRhOiBkYXRhfSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHNlbmRlci5lbWl0ID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xcblxcdCAgICAgICAgdGhpcy5wb3N0TWVzc2FnZSh7dHlwZTogXFxcImV2ZW50XFxcIiwgbmFtZTogbmFtZSwgZGF0YTogZGF0YX0pO1xcblxcdCAgICB9O1xcblxcblxcdCAgICBjb25maWcubG9hZE1vZHVsZShbXFxcIndvcmtlclxcXCIsIG1vZF0sIGZ1bmN0aW9uKE1haW4pIHtcXG5cXHQgICAgICAgIG1haW4gPSBuZXcgTWFpbltjbGFzc25hbWVdKHNlbmRlcik7XFxuXFx0ICAgICAgICB3aGlsZSAoX3NlbGYubWVzc2FnZUJ1ZmZlci5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcXG5cXHQgICAgfSk7XFxuXFx0fTtcXG5cXG5cXHRVSVdvcmtlckNsaWVudC5wcm90b3R5cGUgPSBXb3JrZXJDbGllbnQucHJvdG90eXBlO1xcblxcblxcdGV4cG9ydHMuVUlXb3JrZXJDbGllbnQgPSBVSVdvcmtlckNsaWVudDtcXG5cXHRleHBvcnRzLldvcmtlckNsaWVudCA9IFdvcmtlckNsaWVudDtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvcGxhY2Vob2xkZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvcmFuZ2VcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiLFxcXCJhY2UvbGliL29vcFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBSYW5nZSA9IGFjZXF1aXJlKFxcXCIuL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFx0dmFyIEV2ZW50RW1pdHRlciA9IGFjZXF1aXJlKFxcXCIuL2xpYi9ldmVudF9lbWl0dGVyXFxcIikuRXZlbnRFbWl0dGVyO1xcblxcdHZhciBvb3AgPSBhY2VxdWlyZShcXFwiLi9saWIvb29wXFxcIik7XFxuXFxuXFx0dmFyIFBsYWNlSG9sZGVyID0gZnVuY3Rpb24oc2Vzc2lvbiwgbGVuZ3RoLCBwb3MsIG90aGVycywgbWFpbkNsYXNzLCBvdGhlcnNDbGFzcykge1xcblxcdCAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcdCAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcXG5cXHQgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcXG5cXHQgICAgdGhpcy5kb2MgPSBzZXNzaW9uLmdldERvY3VtZW50KCk7XFxuXFx0ICAgIHRoaXMubWFpbkNsYXNzID0gbWFpbkNsYXNzO1xcblxcdCAgICB0aGlzLm90aGVyc0NsYXNzID0gb3RoZXJzQ2xhc3M7XFxuXFx0ICAgIHRoaXMuJG9uVXBkYXRlID0gdGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpO1xcblxcdCAgICB0aGlzLmRvYy5vbihcXFwiY2hhbmdlXFxcIiwgdGhpcy4kb25VcGRhdGUpO1xcblxcdCAgICB0aGlzLiRvdGhlcnMgPSBvdGhlcnM7XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLiRvbkN1cnNvckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBfc2VsZi5vbkN1cnNvckNoYW5nZSgpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLiRwb3MgPSBwb3M7XFxuXFx0ICAgIHZhciB1bmRvU3RhY2sgPSBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuJHVuZG9TdGFjayB8fCBzZXNzaW9uLmdldFVuZG9NYW5hZ2VyKCkuJHVuZG9zdGFjayB8fCB7bGVuZ3RoOiAtMX07XFxuXFx0ICAgIHRoaXMuJHVuZG9TdGFja0RlcHRoID0gIHVuZG9TdGFjay5sZW5ndGg7XFxuXFx0ICAgIHRoaXMuc2V0dXAoKTtcXG5cXG5cXHQgICAgc2Vzc2lvbi5zZWxlY3Rpb24ub24oXFxcImNoYW5nZUN1cnNvclxcXCIsIHRoaXMuJG9uQ3Vyc29yQ2hhbmdlKTtcXG5cXHR9O1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXG5cXHQgICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xcblxcdCAgICB0aGlzLnNldHVwID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgX3NlbGYgPSB0aGlzO1xcblxcdCAgICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jO1xcblxcdCAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XFxuXFx0ICAgICAgICB2YXIgcG9zID0gdGhpcy4kcG9zO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLnNlbGVjdGlvbkJlZm9yZSA9IHNlc3Npb24uc2VsZWN0aW9uLnRvSlNPTigpO1xcblxcdCAgICAgICAgaWYgKHNlc3Npb24uc2VsZWN0aW9uLmluTXVsdGlTZWxlY3RNb2RlKVxcblxcdCAgICAgICAgICAgIHNlc3Npb24uc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UoKTtcXG5cXG5cXHQgICAgICAgIHRoaXMucG9zID0gZG9jLmNyZWF0ZUFuY2hvcihwb3Mucm93LCBwb3MuY29sdW1uKTtcXG5cXHQgICAgICAgIHRoaXMubWFya2VySWQgPSBzZXNzaW9uLmFkZE1hcmtlcihuZXcgUmFuZ2UocG9zLnJvdywgcG9zLmNvbHVtbiwgcG9zLnJvdywgcG9zLmNvbHVtbiArIHRoaXMubGVuZ3RoKSwgdGhpcy5tYWluQ2xhc3MsIG51bGwsIGZhbHNlKTtcXG5cXHQgICAgICAgIHRoaXMucG9zLm9uKFxcXCJjaGFuZ2VcXFwiLCBmdW5jdGlvbihldmVudCkge1xcblxcdCAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlTWFya2VyKF9zZWxmLm1hcmtlcklkKTtcXG5cXHQgICAgICAgICAgICBfc2VsZi5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShldmVudC52YWx1ZS5yb3csIGV2ZW50LnZhbHVlLmNvbHVtbiwgZXZlbnQudmFsdWUucm93LCBldmVudC52YWx1ZS5jb2x1bW4rX3NlbGYubGVuZ3RoKSwgX3NlbGYubWFpbkNsYXNzLCBudWxsLCBmYWxzZSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHRoaXMub3RoZXJzID0gW107XFxuXFx0ICAgICAgICB0aGlzLiRvdGhlcnMuZm9yRWFjaChmdW5jdGlvbihvdGhlcikge1xcblxcdCAgICAgICAgICAgIHZhciBhbmNob3IgPSBkb2MuY3JlYXRlQW5jaG9yKG90aGVyLnJvdywgb3RoZXIuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICBfc2VsZi5vdGhlcnMucHVzaChhbmNob3IpO1xcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICBzZXNzaW9uLnNldFVuZG9TZWxlY3QoZmFsc2UpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNob3dPdGhlck1hcmtlcnMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIGlmKHRoaXMub3RoZXJzQWN0aXZlKSByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcXG5cXHQgICAgICAgIHZhciBfc2VsZiA9IHRoaXM7XFxuXFx0ICAgICAgICB0aGlzLm90aGVyc0FjdGl2ZSA9IHRydWU7XFxuXFx0ICAgICAgICB0aGlzLm90aGVycy5mb3JFYWNoKGZ1bmN0aW9uKGFuY2hvcikge1xcblxcdCAgICAgICAgICAgIGFuY2hvci5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKG5ldyBSYW5nZShhbmNob3Iucm93LCBhbmNob3IuY29sdW1uLCBhbmNob3Iucm93LCBhbmNob3IuY29sdW1uK19zZWxmLmxlbmd0aCksIF9zZWxmLm90aGVyc0NsYXNzLCBudWxsLCBmYWxzZSk7XFxuXFx0ICAgICAgICAgICAgYW5jaG9yLm9uKFxcXCJjaGFuZ2VcXFwiLCBmdW5jdGlvbihldmVudCkge1xcblxcdCAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZU1hcmtlcihhbmNob3IubWFya2VySWQpO1xcblxcdCAgICAgICAgICAgICAgICBhbmNob3IubWFya2VySWQgPSBzZXNzaW9uLmFkZE1hcmtlcihuZXcgUmFuZ2UoZXZlbnQudmFsdWUucm93LCBldmVudC52YWx1ZS5jb2x1bW4sIGV2ZW50LnZhbHVlLnJvdywgZXZlbnQudmFsdWUuY29sdW1uK19zZWxmLmxlbmd0aCksIF9zZWxmLm90aGVyc0NsYXNzLCBudWxsLCBmYWxzZSk7XFxuXFx0ICAgICAgICAgICAgfSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5oaWRlT3RoZXJNYXJrZXJzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZighdGhpcy5vdGhlcnNBY3RpdmUpIHJldHVybjtcXG5cXHQgICAgICAgIHRoaXMub3RoZXJzQWN0aXZlID0gZmFsc2U7XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3RoZXJzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcih0aGlzLm90aGVyc1tpXS5tYXJrZXJJZCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMub25VcGRhdGUgPSBmdW5jdGlvbihldmVudCkge1xcblxcdCAgICAgICAgdmFyIGRlbHRhID0gZXZlbnQuZGF0YTtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IGRlbHRhLnJhbmdlO1xcblxcdCAgICAgICAgaWYocmFuZ2Uuc3RhcnQucm93ICE9PSByYW5nZS5lbmQucm93KSByZXR1cm47XFxuXFx0ICAgICAgICBpZihyYW5nZS5zdGFydC5yb3cgIT09IHRoaXMucG9zLnJvdykgcmV0dXJuO1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHVwZGF0aW5nKSByZXR1cm47XFxuXFx0ICAgICAgICB0aGlzLiR1cGRhdGluZyA9IHRydWU7XFxuXFx0ICAgICAgICB2YXIgbGVuZ3RoRGlmZiA9IGRlbHRhLmFjdGlvbiA9PT0gXFxcImluc2VydFRleHRcXFwiID8gcmFuZ2UuZW5kLmNvbHVtbiAtIHJhbmdlLnN0YXJ0LmNvbHVtbiA6IHJhbmdlLnN0YXJ0LmNvbHVtbiAtIHJhbmdlLmVuZC5jb2x1bW47XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmKHJhbmdlLnN0YXJ0LmNvbHVtbiA+PSB0aGlzLnBvcy5jb2x1bW4gJiYgcmFuZ2Uuc3RhcnQuY29sdW1uIDw9IHRoaXMucG9zLmNvbHVtbiArIHRoaXMubGVuZ3RoICsgMSkge1xcblxcdCAgICAgICAgICAgIHZhciBkaXN0YW5jZUZyb21TdGFydCA9IHJhbmdlLnN0YXJ0LmNvbHVtbiAtIHRoaXMucG9zLmNvbHVtbjtcXG5cXHQgICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBsZW5ndGhEaWZmO1xcblxcdCAgICAgICAgICAgIGlmKCF0aGlzLnNlc3Npb24uJGZyb21VbmRvKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmKGRlbHRhLmFjdGlvbiA9PT0gXFxcImluc2VydFRleHRcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5vdGhlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSB0aGlzLm90aGVyc1tpXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UG9zID0ge3Jvdzogb3RoZXJQb3Mucm93LCBjb2x1bW46IG90aGVyUG9zLmNvbHVtbiArIGRpc3RhbmNlRnJvbVN0YXJ0fTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlclBvcy5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlclBvcy5jb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvcy5jb2x1bW4gKz0gbGVuZ3RoRGlmZjtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5pbnNlcnQobmV3UG9zLCBkZWx0YS50ZXh0KTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGRlbHRhLmFjdGlvbiA9PT0gXFxcInJlbW92ZVRleHRcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5vdGhlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJQb3MgPSB0aGlzLm90aGVyc1tpXTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UG9zID0ge3Jvdzogb3RoZXJQb3Mucm93LCBjb2x1bW46IG90aGVyUG9zLmNvbHVtbiArIGRpc3RhbmNlRnJvbVN0YXJ0fTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlclBvcy5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlclBvcy5jb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvcy5jb2x1bW4gKz0gbGVuZ3RoRGlmZjtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5yZW1vdmUobmV3IFJhbmdlKG5ld1Bvcy5yb3csIG5ld1Bvcy5jb2x1bW4sIG5ld1Bvcy5yb3csIG5ld1Bvcy5jb2x1bW4gLSBsZW5ndGhEaWZmKSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgaWYocmFuZ2Uuc3RhcnQuY29sdW1uID09PSB0aGlzLnBvcy5jb2x1bW4gJiYgZGVsdGEuYWN0aW9uID09PSBcXFwiaW5zZXJ0VGV4dFxcXCIpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3Muc2V0UG9zaXRpb24odGhpcy5wb3Mucm93LCB0aGlzLnBvcy5jb2x1bW4gLSBsZW5ndGhEaWZmKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3RoZXJzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IHRoaXMub3RoZXJzW2ldO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UG9zID0ge3Jvdzogb3RoZXIucm93LCBjb2x1bW46IG90aGVyLmNvbHVtbiAtIGxlbmd0aERpZmZ9O1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlci5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlci5jb2x1bW4pXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQb3MuY29sdW1uICs9IGxlbmd0aERpZmY7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLnNldFBvc2l0aW9uKG5ld1Bvcy5yb3csIG5ld1Bvcy5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMCk7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgZWxzZSBpZihyYW5nZS5zdGFydC5jb2x1bW4gPT09IHRoaXMucG9zLmNvbHVtbiAmJiBkZWx0YS5hY3Rpb24gPT09IFxcXCJyZW1vdmVUZXh0XFxcIikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3RoZXJzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IHRoaXMub3RoZXJzW2ldO1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvdGhlci5yb3cgPT09IHJhbmdlLnN0YXJ0LnJvdyAmJiByYW5nZS5zdGFydC5jb2x1bW4gPCBvdGhlci5jb2x1bW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLnNldFBvc2l0aW9uKG90aGVyLnJvdywgb3RoZXIuY29sdW1uIC0gbGVuZ3RoRGlmZik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIDApO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHRoaXMucG9zLl9lbWl0KFxcXCJjaGFuZ2VcXFwiLCB7dmFsdWU6IHRoaXMucG9zfSk7XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm90aGVycy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLm90aGVyc1tpXS5fZW1pdChcXFwiY2hhbmdlXFxcIiwge3ZhbHVlOiB0aGlzLm90aGVyc1tpXX0pO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuJHVwZGF0aW5nID0gZmFsc2U7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMub25DdXJzb3JDaGFuZ2UgPSBmdW5jdGlvbihldmVudCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHVwZGF0aW5nIHx8ICF0aGlzLnNlc3Npb24pIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBwb3MgPSB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmdldEN1cnNvcigpO1xcblxcdCAgICAgICAgaWYgKHBvcy5yb3cgPT09IHRoaXMucG9zLnJvdyAmJiBwb3MuY29sdW1uID49IHRoaXMucG9zLmNvbHVtbiAmJiBwb3MuY29sdW1uIDw9IHRoaXMucG9zLmNvbHVtbiArIHRoaXMubGVuZ3RoKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zaG93T3RoZXJNYXJrZXJzKCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5fZW1pdChcXFwiY3Vyc29yRW50ZXJcXFwiLCBldmVudCk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHRoaXMuaGlkZU90aGVyTWFya2VycygpO1xcblxcdCAgICAgICAgICAgIHRoaXMuX2VtaXQoXFxcImN1cnNvckxlYXZlXFxcIiwgZXZlbnQpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9OyAgICBcXG5cXHQgICAgdGhpcy5kZXRhY2ggPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5yZW1vdmVNYXJrZXIodGhpcy5tYXJrZXJJZCk7XFxuXFx0ICAgICAgICB0aGlzLmhpZGVPdGhlck1hcmtlcnMoKTtcXG5cXHQgICAgICAgIHRoaXMuZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImNoYW5nZVxcXCIsIHRoaXMuJG9uVXBkYXRlKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiY2hhbmdlQ3Vyc29yXFxcIiwgdGhpcy4kb25DdXJzb3JDaGFuZ2UpO1xcblxcdCAgICAgICAgdGhpcy5wb3MuZGV0YWNoKCk7XFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3RoZXJzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5vdGhlcnNbaV0uZGV0YWNoKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2V0VW5kb1NlbGVjdCh0cnVlKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZih0aGlzLiR1bmRvU3RhY2tEZXB0aCA9PT0gLTEpXFxuXFx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoXFxcIkNhbmNlbGluZyBwbGFjZWhvbGRlcnMgb25seSBzdXBwb3J0ZWQgd2l0aCB1bmRvIG1hbmFnZXIgYXR0YWNoZWQgdG8gc2Vzc2lvbi5cXFwiKTtcXG5cXHQgICAgICAgIHZhciB1bmRvTWFuYWdlciA9IHRoaXMuc2Vzc2lvbi5nZXRVbmRvTWFuYWdlcigpO1xcblxcdCAgICAgICAgdmFyIHVuZG9zUmVxdWlyZWQgPSAodW5kb01hbmFnZXIuJHVuZG9TdGFjayB8fCB1bmRvTWFuYWdlci4kdW5kb3N0YWNrKS5sZW5ndGggLSB0aGlzLiR1bmRvU3RhY2tEZXB0aDtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5kb3NSZXF1aXJlZDsgaSsrKSB7XFxuXFx0ICAgICAgICAgICAgdW5kb01hbmFnZXIudW5kbyh0cnVlKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkJlZm9yZSlcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uc2VsZWN0aW9uLmZyb21KU09OKHRoaXMuc2VsZWN0aW9uQmVmb3JlKTtcXG5cXHQgICAgfTtcXG5cXHR9KS5jYWxsKFBsYWNlSG9sZGVyLnByb3RvdHlwZSk7XFxuXFxuXFxuXFx0ZXhwb3J0cy5QbGFjZUhvbGRlciA9IFBsYWNlSG9sZGVyO1xcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb3VzZS9tdWx0aV9zZWxlY3RfaGFuZGxlclxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvZXZlbnRcXFwiLFxcXCJhY2UvbGliL3VzZXJhZ2VudFxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFxuXFx0dmFyIGV2ZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9ldmVudFxcXCIpO1xcblxcdHZhciB1c2VyYWdlbnQgPSBhY2VxdWlyZShcXFwiLi4vbGliL3VzZXJhZ2VudFxcXCIpO1xcblxcdGZ1bmN0aW9uIGlzU2FtZVBvaW50KHAxLCBwMikge1xcblxcdCAgICByZXR1cm4gcDEucm93ID09IHAyLnJvdyAmJiBwMS5jb2x1bW4gPT0gcDIuY29sdW1uO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XFxuXFx0ICAgIHZhciBldiA9IGUuZG9tRXZlbnQ7XFxuXFx0ICAgIHZhciBhbHQgPSBldi5hbHRLZXk7XFxuXFx0ICAgIHZhciBzaGlmdCA9IGV2LnNoaWZ0S2V5O1xcblxcdCAgICB2YXIgY3RybCA9IGV2LmN0cmxLZXk7XFxuXFx0ICAgIHZhciBhY2NlbCA9IGUuZ2V0QWNjZWxLZXkoKTtcXG5cXHQgICAgdmFyIGJ1dHRvbiA9IGUuZ2V0QnV0dG9uKCk7XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoY3RybCAmJiB1c2VyYWdlbnQuaXNNYWMpXFxuXFx0ICAgICAgICBidXR0b24gPSBldi5idXR0b247XFxuXFxuXFx0ICAgIGlmIChlLmVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSAmJiBidXR0b24gPT0gMikge1xcblxcdCAgICAgICAgZS5lZGl0b3IudGV4dElucHV0Lm9uQ29udGV4dE1lbnUoZS5kb21FdmVudCk7XFxuXFx0ICAgICAgICByZXR1cm47XFxuXFx0ICAgIH1cXG5cXHQgICAgXFxuXFx0ICAgIGlmICghY3RybCAmJiAhYWx0ICYmICFhY2NlbCkge1xcblxcdCAgICAgICAgaWYgKGJ1dHRvbiA9PT0gMCAmJiBlLmVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSlcXG5cXHQgICAgICAgICAgICBlLmVkaXRvci5leGl0TXVsdGlTZWxlY3RNb2RlKCk7XFxuXFx0ICAgICAgICByZXR1cm47XFxuXFx0ICAgIH1cXG5cXHQgICAgXFxuXFx0ICAgIGlmIChidXR0b24gIT09IDApXFxuXFx0ICAgICAgICByZXR1cm47XFxuXFxuXFx0ICAgIHZhciBlZGl0b3IgPSBlLmVkaXRvcjtcXG5cXHQgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XFxuXFx0ICAgIHZhciBpc011bHRpU2VsZWN0ID0gZWRpdG9yLmluTXVsdGlTZWxlY3RNb2RlO1xcblxcdCAgICB2YXIgcG9zID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XFxuXFx0ICAgIHZhciBjdXJzb3IgPSBzZWxlY3Rpb24uZ2V0Q3Vyc29yKCk7XFxuXFx0ICAgIHZhciBpblNlbGVjdGlvbiA9IGUuaW5TZWxlY3Rpb24oKSB8fCAoc2VsZWN0aW9uLmlzRW1wdHkoKSAmJiBpc1NhbWVQb2ludChwb3MsIGN1cnNvcikpO1xcblxcblxcdCAgICB2YXIgbW91c2VYID0gZS54LCBtb3VzZVkgPSBlLnk7XFxuXFx0ICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgbW91c2VYID0gZS5jbGllbnRYO1xcblxcdCAgICAgICAgbW91c2VZID0gZS5jbGllbnRZO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdmFyIHNlc3Npb24gPSBlZGl0b3Iuc2Vzc2lvbjtcXG5cXHQgICAgdmFyIHNjcmVlbkFuY2hvciA9IGVkaXRvci5yZW5kZXJlci5waXhlbFRvU2NyZWVuQ29vcmRpbmF0ZXMobW91c2VYLCBtb3VzZVkpO1xcblxcdCAgICB2YXIgc2NyZWVuQ3Vyc29yID0gc2NyZWVuQW5jaG9yO1xcblxcdCAgICBcXG5cXHQgICAgdmFyIHNlbGVjdGlvbk1vZGU7XFxuXFx0ICAgIGlmIChlZGl0b3IuJG1vdXNlSGFuZGxlci4kZW5hYmxlSnVtcFRvRGVmKSB7XFxuXFx0ICAgICAgICBpZiAoY3RybCAmJiBhbHQgfHwgYWNjZWwgJiYgYWx0KVxcblxcdCAgICAgICAgICAgIHNlbGVjdGlvbk1vZGUgPSBcXFwiYWRkXFxcIjtcXG5cXHQgICAgICAgIGVsc2UgaWYgKGFsdClcXG5cXHQgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gXFxcImJsb2NrXFxcIjtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIGlmIChhY2NlbCAmJiAhYWx0KSB7XFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9uTW9kZSA9IFxcXCJhZGRcXFwiO1xcblxcdCAgICAgICAgICAgIGlmICghaXNNdWx0aVNlbGVjdCAmJiBzaGlmdClcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChhbHQpIHtcXG5cXHQgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlID0gXFxcImJsb2NrXFxcIjtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcdCAgICBcXG5cXHQgICAgaWYgKHNlbGVjdGlvbk1vZGUgJiYgdXNlcmFnZW50LmlzTWFjICYmIGV2LmN0cmxLZXkpIHtcXG5cXHQgICAgICAgIGVkaXRvci4kbW91c2VIYW5kbGVyLmNhbmNlbENvbnRleHRNZW51KCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKHNlbGVjdGlvbk1vZGUgPT0gXFxcImFkZFxcXCIpIHtcXG5cXHQgICAgICAgIGlmICghaXNNdWx0aVNlbGVjdCAmJiBpblNlbGVjdGlvbilcXG5cXHQgICAgICAgICAgICByZXR1cm47IC8vIGRyYWdnaW5nXFxuXFxuXFx0ICAgICAgICBpZiAoIWlzTXVsdGlTZWxlY3QpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCk7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLmFkZFNlbGVjdGlvbk1hcmtlcihyYW5nZSk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICB2YXIgb2xkUmFuZ2UgPSBzZWxlY3Rpb24ucmFuZ2VMaXN0LnJhbmdlQXRQb2ludChwb3MpO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcrKztcXG5cXHQgICAgICAgIGVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gdHJ1ZTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgaWYgKHNoaWZ0KSB7XFxuXFx0ICAgICAgICAgICAgb2xkUmFuZ2UgPSBudWxsO1xcblxcdCAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLnJhbmdlc1swXTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IucmVtb3ZlU2VsZWN0aW9uTWFya2VyKHJhbmdlKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGVkaXRvci5vbmNlKFxcXCJtb3VzZXVwXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHRtcFNlbCA9IHNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAob2xkUmFuZ2UgJiYgdG1wU2VsLmlzRW1wdHkoKSAmJiBpc1NhbWVQb2ludChvbGRSYW5nZS5jdXJzb3IsIHRtcFNlbC5jdXJzb3IpKVxcblxcdCAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc3Vic3RyYWN0UG9pbnQodG1wU2VsLmN1cnNvcik7XFxuXFx0ICAgICAgICAgICAgZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzaGlmdCkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnN1YnN0cmFjdFBvaW50KHJhbmdlLmN1cnNvcik7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIocmFuZ2UpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UodG1wU2VsKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLiRibG9ja1Njcm9sbGluZy0tO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gZmFsc2U7XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25Nb2RlID09IFxcXCJibG9ja1xcXCIpIHtcXG5cXHQgICAgICAgIGUuc3RvcCgpO1xcblxcdCAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSB0cnVlOyAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgaW5pdGlhbFJhbmdlO1xcblxcdCAgICAgICAgdmFyIHJlY3RTZWwgPSBbXTtcXG5cXHQgICAgICAgIHZhciBibG9ja1NlbGVjdCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIHZhciBuZXdDdXJzb3IgPSBlZGl0b3IucmVuZGVyZXIucGl4ZWxUb1NjcmVlbkNvb3JkaW5hdGVzKG1vdXNlWCwgbW91c2VZKTtcXG5cXHQgICAgICAgICAgICB2YXIgY3Vyc29yID0gc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24obmV3Q3Vyc29yLnJvdywgbmV3Q3Vyc29yLmNvbHVtbik7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGlzU2FtZVBvaW50KHNjcmVlbkN1cnNvciwgbmV3Q3Vyc29yKSAmJiBpc1NhbWVQb2ludChjdXJzb3IsIHNlbGVjdGlvbi5sZWFkKSlcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIHNjcmVlbkN1cnNvciA9IG5ld0N1cnNvcjtcXG5cXG5cXHQgICAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKGN1cnNvcik7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XFxuXFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMocmVjdFNlbCk7XFxuXFx0ICAgICAgICAgICAgcmVjdFNlbCA9IHNlbGVjdGlvbi5yZWN0YW5ndWxhclJhbmdlQmxvY2soc2NyZWVuQ3Vyc29yLCBzY3JlZW5BbmNob3IpO1xcblxcdCAgICAgICAgICAgIGlmIChlZGl0b3IuJG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gJiYgcmVjdFNlbC5sZW5ndGggPT0gMSAmJiByZWN0U2VsWzBdLmlzRW1wdHkoKSlcXG5cXHQgICAgICAgICAgICAgICAgcmVjdFNlbFswXSA9IGVkaXRvci4kbW91c2VIYW5kbGVyLiRjbGlja1NlbGVjdGlvbi5jbG9uZSgpO1xcblxcdCAgICAgICAgICAgIHJlY3RTZWwuZm9yRWFjaChlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyLCBlZGl0b3IpO1xcblxcdCAgICAgICAgICAgIGVkaXRvci51cGRhdGVTZWxlY3Rpb25NYXJrZXJzKCk7XFxuXFx0ICAgICAgICB9O1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBpZiAoaXNNdWx0aVNlbGVjdCAmJiAhYWNjZWwpIHtcXG5cXHQgICAgICAgICAgICBzZWxlY3Rpb24udG9TaW5nbGVSYW5nZSgpO1xcblxcdCAgICAgICAgfSBlbHNlIGlmICghaXNNdWx0aVNlbGVjdCAmJiBhY2NlbCkge1xcblxcdCAgICAgICAgICAgIGluaXRpYWxSYW5nZSA9IHNlbGVjdGlvbi50b09yaWVudGVkUmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IuYWRkU2VsZWN0aW9uTWFya2VyKGluaXRpYWxSYW5nZSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmIChzaGlmdClcXG5cXHQgICAgICAgICAgICBzY3JlZW5BbmNob3IgPSBzZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihzZWxlY3Rpb24ubGVhZCk7ICAgICAgICAgICAgXFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9uLm1vdmVUb1Bvc2l0aW9uKHBvcyk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHNjcmVlbkN1cnNvciA9IHtyb3c6IC0xLCBjb2x1bW46IC0xfTtcXG5cXG5cXHQgICAgICAgIHZhciBvbk1vdXNlU2VsZWN0aW9uRW5kID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnJlbW92ZVNlbGVjdGlvbk1hcmtlcnMocmVjdFNlbCk7XFxuXFx0ICAgICAgICAgICAgaWYgKCFyZWN0U2VsLmxlbmd0aClcXG5cXHQgICAgICAgICAgICAgICAgcmVjdFNlbCA9IFtzZWxlY3Rpb24udG9PcmllbnRlZFJhbmdlKCldO1xcblxcdCAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmcrKztcXG5cXHQgICAgICAgICAgICBpZiAoaW5pdGlhbFJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGVkaXRvci5yZW1vdmVTZWxlY3Rpb25NYXJrZXIoaW5pdGlhbFJhbmdlKTtcXG5cXHQgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnRvU2luZ2xlUmFuZ2UoaW5pdGlhbFJhbmdlKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0U2VsLmxlbmd0aDsgaSsrKVxcblxcdCAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmVjdFNlbFtpXSk7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLmluVmlydHVhbFNlbGVjdGlvbk1vZGUgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICBlZGl0b3IuJG1vdXNlSGFuZGxlci4kY2xpY2tTZWxlY3Rpb24gPSBudWxsO1xcblxcdCAgICAgICAgICAgIGVkaXRvci4kYmxvY2tTY3JvbGxpbmctLTtcXG5cXHQgICAgICAgIH07XFxuXFxuXFx0ICAgICAgICB2YXIgb25TZWxlY3Rpb25JbnRlcnZhbCA9IGJsb2NrU2VsZWN0O1xcblxcblxcdCAgICAgICAgZXZlbnQuY2FwdHVyZShlZGl0b3IuY29udGFpbmVyLCBvbk1vdXNlU2VsZWN0aW9uLCBvbk1vdXNlU2VsZWN0aW9uRW5kKTtcXG5cXHQgICAgICAgIHZhciB0aW1lcklkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7b25TZWxlY3Rpb25JbnRlcnZhbCgpO30sIDIwKTtcXG5cXG5cXHQgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0ICAgIH1cXG5cXHR9XFxuXFxuXFxuXFx0ZXhwb3J0cy5vbk1vdXNlRG93biA9IG9uTW91c2VEb3duO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRleHBvcnRzLmRlZmF1bHRDb21tYW5kcyA9IFt7XFxuXFx0ICAgIG5hbWU6IFxcXCJhZGRDdXJzb3JBYm92ZVxcXCIsXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKC0xKTsgfSxcXG5cXHQgICAgYmluZEtleToge3dpbjogXFxcIkN0cmwtQWx0LVVwXFxcIiwgbWFjOiBcXFwiQ3RybC1BbHQtVXBcXFwifSxcXG5cXHQgICAgcmVhZG9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJhZGRDdXJzb3JCZWxvd1xcXCIsXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZUxpbmVzKDEpOyB9LFxcblxcdCAgICBiaW5kS2V5OiB7d2luOiBcXFwiQ3RybC1BbHQtRG93blxcXCIsIG1hYzogXFxcIkN0cmwtQWx0LURvd25cXFwifSxcXG5cXHQgICAgcmVhZG9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJhZGRDdXJzb3JBYm92ZVNraXBDdXJyZW50XFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlTGluZXMoLTEsIHRydWUpOyB9LFxcblxcdCAgICBiaW5kS2V5OiB7d2luOiBcXFwiQ3RybC1BbHQtU2hpZnQtVXBcXFwiLCBtYWM6IFxcXCJDdHJsLUFsdC1TaGlmdC1VcFxcXCJ9LFxcblxcdCAgICByZWFkb25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImFkZEN1cnNvckJlbG93U2tpcEN1cnJlbnRcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLnNlbGVjdE1vcmVMaW5lcygxLCB0cnVlKTsgfSxcXG5cXHQgICAgYmluZEtleToge3dpbjogXFxcIkN0cmwtQWx0LVNoaWZ0LURvd25cXFwiLCBtYWM6IFxcXCJDdHJsLUFsdC1TaGlmdC1Eb3duXFxcIn0sXFxuXFx0ICAgIHJlYWRvbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0TW9yZUJlZm9yZVxcXCIsXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZSgtMSk7IH0sXFxuXFx0ICAgIGJpbmRLZXk6IHt3aW46IFxcXCJDdHJsLUFsdC1MZWZ0XFxcIiwgbWFjOiBcXFwiQ3RybC1BbHQtTGVmdFxcXCJ9LFxcblxcdCAgICByZWFkb25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNlbGVjdE1vcmVBZnRlclxcXCIsXFxuXFx0ICAgIGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3Iuc2VsZWN0TW9yZSgxKTsgfSxcXG5cXHQgICAgYmluZEtleToge3dpbjogXFxcIkN0cmwtQWx0LVJpZ2h0XFxcIiwgbWFjOiBcXFwiQ3RybC1BbHQtUmlnaHRcXFwifSxcXG5cXHQgICAgcmVhZG9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJzZWxlY3ROZXh0QmVmb3JlXFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlKC0xLCB0cnVlKTsgfSxcXG5cXHQgICAgYmluZEtleToge3dpbjogXFxcIkN0cmwtQWx0LVNoaWZ0LUxlZnRcXFwiLCBtYWM6IFxcXCJDdHJsLUFsdC1TaGlmdC1MZWZ0XFxcIn0sXFxuXFx0ICAgIHJlYWRvbmx5OiB0cnVlXFxuXFx0fSwge1xcblxcdCAgICBuYW1lOiBcXFwic2VsZWN0TmV4dEFmdGVyXFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5zZWxlY3RNb3JlKDEsIHRydWUpOyB9LFxcblxcdCAgICBiaW5kS2V5OiB7d2luOiBcXFwiQ3RybC1BbHQtU2hpZnQtUmlnaHRcXFwiLCBtYWM6IFxcXCJDdHJsLUFsdC1TaGlmdC1SaWdodFxcXCJ9LFxcblxcdCAgICByZWFkb25seTogdHJ1ZVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcInNwbGl0SW50b0xpbmVzXFxcIixcXG5cXHQgICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5tdWx0aVNlbGVjdC5zcGxpdEludG9MaW5lcygpOyB9LFxcblxcdCAgICBiaW5kS2V5OiB7d2luOiBcXFwiQ3RybC1BbHQtTFxcXCIsIG1hYzogXFxcIkN0cmwtQWx0LUxcXFwifSxcXG5cXHQgICAgcmVhZG9ubHk6IHRydWVcXG5cXHR9LCB7XFxuXFx0ICAgIG5hbWU6IFxcXCJhbGlnbkN1cnNvcnNcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmFsaWduQ3Vyc29ycygpOyB9LFxcblxcdCAgICBiaW5kS2V5OiB7d2luOiBcXFwiQ3RybC1BbHQtQVxcXCIsIG1hYzogXFxcIkN0cmwtQWx0LUFcXFwifVxcblxcdH0sIHtcXG5cXHQgICAgbmFtZTogXFxcImZpbmRBbGxcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmZpbmRBbGwoKTsgfSxcXG5cXHQgICAgYmluZEtleToge3dpbjogXFxcIkN0cmwtQWx0LUtcXFwiLCBtYWM6IFxcXCJDdHJsLUFsdC1HXFxcIn0sXFxuXFx0ICAgIHJlYWRvbmx5OiB0cnVlXFxuXFx0fV07XFxuXFx0ZXhwb3J0cy5tdWx0aVNlbGVjdENvbW1hbmRzID0gW3tcXG5cXHQgICAgbmFtZTogXFxcInNpbmdsZVNlbGVjdGlvblxcXCIsXFxuXFx0ICAgIGJpbmRLZXk6IFxcXCJlc2NcXFwiLFxcblxcdCAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmV4aXRNdWx0aVNlbGVjdE1vZGUoKTsgfSxcXG5cXHQgICAgcmVhZG9ubHk6IHRydWUsXFxuXFx0ICAgIGlzQXZhaWxhYmxlOiBmdW5jdGlvbihlZGl0b3IpIHtyZXR1cm4gZWRpdG9yICYmIGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZX1cXG5cXHR9XTtcXG5cXG5cXHR2YXIgSGFzaEhhbmRsZXIgPSBhY2VxdWlyZShcXFwiLi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXFxcIikuSGFzaEhhbmRsZXI7XFxuXFx0ZXhwb3J0cy5rZXlib2FyZEhhbmRsZXIgPSBuZXcgSGFzaEhhbmRsZXIoZXhwb3J0cy5tdWx0aVNlbGVjdENvbW1hbmRzKTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbXVsdGlfc2VsZWN0XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3JhbmdlX2xpc3RcXFwiLFxcXCJhY2UvcmFuZ2VcXFwiLFxcXCJhY2Uvc2VsZWN0aW9uXFxcIixcXFwiYWNlL21vdXNlL211bHRpX3NlbGVjdF9oYW5kbGVyXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCIsXFxcImFjZS9saWIvbGFuZ1xcXCIsXFxcImFjZS9jb21tYW5kcy9tdWx0aV9zZWxlY3RfY29tbWFuZHNcXFwiLFxcXCJhY2Uvc2VhcmNoXFxcIixcXFwiYWNlL2VkaXRfc2Vzc2lvblxcXCIsXFxcImFjZS9lZGl0b3JcXFwiLFxcXCJhY2UvY29uZmlnXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXG5cXHR2YXIgUmFuZ2VMaXN0ID0gYWNlcXVpcmUoXFxcIi4vcmFuZ2VfbGlzdFxcXCIpLlJhbmdlTGlzdDtcXG5cXHR2YXIgUmFuZ2UgPSBhY2VxdWlyZShcXFwiLi9yYW5nZVxcXCIpLlJhbmdlO1xcblxcdHZhciBTZWxlY3Rpb24gPSBhY2VxdWlyZShcXFwiLi9zZWxlY3Rpb25cXFwiKS5TZWxlY3Rpb247XFxuXFx0dmFyIG9uTW91c2VEb3duID0gYWNlcXVpcmUoXFxcIi4vbW91c2UvbXVsdGlfc2VsZWN0X2hhbmRsZXJcXFwiKS5vbk1vdXNlRG93bjtcXG5cXHR2YXIgZXZlbnQgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRcXFwiKTtcXG5cXHR2YXIgbGFuZyA9IGFjZXF1aXJlKFxcXCIuL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIGNvbW1hbmRzID0gYWNlcXVpcmUoXFxcIi4vY29tbWFuZHMvbXVsdGlfc2VsZWN0X2NvbW1hbmRzXFxcIik7XFxuXFx0ZXhwb3J0cy5jb21tYW5kcyA9IGNvbW1hbmRzLmRlZmF1bHRDb21tYW5kcy5jb25jYXQoY29tbWFuZHMubXVsdGlTZWxlY3RDb21tYW5kcyk7XFxuXFx0dmFyIFNlYXJjaCA9IGFjZXF1aXJlKFxcXCIuL3NlYXJjaFxcXCIpLlNlYXJjaDtcXG5cXHR2YXIgc2VhcmNoID0gbmV3IFNlYXJjaCgpO1xcblxcblxcdGZ1bmN0aW9uIGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpIHtcXG5cXHQgICAgc2VhcmNoLiRvcHRpb25zLndyYXAgPSB0cnVlO1xcblxcdCAgICBzZWFyY2guJG9wdGlvbnMubmVlZGxlID0gbmVlZGxlO1xcblxcdCAgICBzZWFyY2guJG9wdGlvbnMuYmFja3dhcmRzID0gZGlyID09IC0xO1xcblxcdCAgICByZXR1cm4gc2VhcmNoLmZpbmQoc2Vzc2lvbik7XFxuXFx0fVxcblxcdHZhciBFZGl0U2Vzc2lvbiA9IGFjZXF1aXJlKFxcXCIuL2VkaXRfc2Vzc2lvblxcXCIpLkVkaXRTZXNzaW9uO1xcblxcdChmdW5jdGlvbigpIHtcXG5cXHQgICAgdGhpcy5nZXRTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kc2VsZWN0aW9uTWFya2VycztcXG5cXHQgICAgfTtcXG5cXHR9KS5jYWxsKEVkaXRTZXNzaW9uLnByb3RvdHlwZSk7XFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLnJhbmdlcyA9IG51bGw7XFxuXFx0ICAgIHRoaXMucmFuZ2VMaXN0ID0gbnVsbDtcXG5cXHQgICAgdGhpcy5hZGRSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlLCAkYmxvY2tDaGFuZ2VFdmVudHMpIHtcXG5cXHQgICAgICAgIGlmICghcmFuZ2UpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgaWYgKCF0aGlzLmluTXVsdGlTZWxlY3RNb2RlICYmIHRoaXMucmFuZ2VDb3VudCA9PT0gMCkge1xcblxcdCAgICAgICAgICAgIHZhciBvbGRSYW5nZSA9IHRoaXMudG9PcmllbnRlZFJhbmdlKCk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYWRkKG9sZFJhbmdlKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnJhbmdlTGlzdC5hZGQocmFuZ2UpO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlTGlzdC5yYW5nZXMubGVuZ3RoICE9IDIpIHtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QucmVtb3ZlQWxsKCk7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiAkYmxvY2tDaGFuZ2VFdmVudHMgfHwgdGhpcy5mcm9tT3JpZW50ZWRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHRoaXMucmFuZ2VMaXN0LnJlbW92ZUFsbCgpO1xcblxcdCAgICAgICAgICAgIHRoaXMucmFuZ2VMaXN0LmFkZChvbGRSYW5nZSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25BZGRSYW5nZShvbGRSYW5nZSk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBpZiAoIXJhbmdlLmN1cnNvcilcXG5cXHQgICAgICAgICAgICByYW5nZS5jdXJzb3IgPSByYW5nZS5lbmQ7XFxuXFxuXFx0ICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LmFkZChyYW5nZSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRvbkFkZFJhbmdlKHJhbmdlKTtcXG5cXG5cXHQgICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aClcXG5cXHQgICAgICAgICAgICB0aGlzLiRvblJlbW92ZVJhbmdlKHJlbW92ZWQpO1xcblxcblxcdCAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDEgJiYgIXRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcIm11bHRpU2VsZWN0XFxcIik7XFxuXFx0ICAgICAgICAgICAgdGhpcy5pbk11bHRpU2VsZWN0TW9kZSA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLiR1bmRvU2VsZWN0ID0gZmFsc2U7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuYXR0YWNoKHRoaXMuc2Vzc2lvbik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICByZXR1cm4gJGJsb2NrQ2hhbmdlRXZlbnRzIHx8IHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLnRvU2luZ2xlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgcmFuZ2UgPSByYW5nZSB8fCB0aGlzLnJhbmdlc1swXTtcXG5cXHQgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yYW5nZUxpc3QucmVtb3ZlQWxsKCk7XFxuXFx0ICAgICAgICBpZiAocmVtb3ZlZC5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25SZW1vdmVSYW5nZShyZW1vdmVkKTtcXG5cXG5cXHQgICAgICAgIHJhbmdlICYmIHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnN1YnN0cmFjdFBvaW50ID0gZnVuY3Rpb24ocG9zKSB7XFxuXFx0ICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmFuZ2VMaXN0LnN1YnN0cmFjdFBvaW50KHBvcyk7XFxuXFx0ICAgICAgICBpZiAocmVtb3ZlZCkge1xcblxcdCAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWRbMF07XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMubWVyZ2VPdmVybGFwcGluZ1JhbmdlcyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLnJhbmdlTGlzdC5tZXJnZSgpO1xcblxcdCAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoKVxcblxcdCAgICAgICAgICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UocmVtb3ZlZCk7XFxuXFx0ICAgICAgICBlbHNlIGlmKHRoaXMucmFuZ2VzWzBdKVxcblxcdCAgICAgICAgICAgIHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UodGhpcy5yYW5nZXNbMF0pO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRvbkFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcXG5cXHQgICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMucmFuZ2VMaXN0LnJhbmdlcy5sZW5ndGg7XFxuXFx0ICAgICAgICB0aGlzLnJhbmdlcy51bnNoaWZ0KHJhbmdlKTtcXG5cXHQgICAgICAgIHRoaXMuX3NpZ25hbChcXFwiYWRkUmFuZ2VcXFwiLCB7cmFuZ2U6IHJhbmdlfSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuJG9uUmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihyZW1vdmVkKSB7XFxuXFx0ICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXMubGVuZ3RoO1xcblxcdCAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA9PSAxICYmIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpIHtcXG5cXHQgICAgICAgICAgICB2YXIgbGFzdFJhbmdlID0gdGhpcy5yYW5nZUxpc3QucmFuZ2VzLnBvcCgpO1xcblxcdCAgICAgICAgICAgIHJlbW92ZWQucHVzaChsYXN0UmFuZ2UpO1xcblxcdCAgICAgICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IDA7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGg7IGktLTsgKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5yYW5nZXMuaW5kZXhPZihyZW1vdmVkW2ldKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnJhbmdlcy5zcGxpY2UoaW5kZXgsIDEpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJyZW1vdmVSYW5nZVxcXCIsIHtyYW5nZXM6IHJlbW92ZWR9KTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQgPT09IDAgJiYgdGhpcy5pbk11bHRpU2VsZWN0TW9kZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgPSBmYWxzZTtcXG5cXHQgICAgICAgICAgICB0aGlzLl9zaWduYWwoXFxcInNpbmdsZVNlbGVjdFxcXCIpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kdW5kb1NlbGVjdCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy5yYW5nZUxpc3QuZGV0YWNoKHRoaXMuc2Vzc2lvbik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBsYXN0UmFuZ2UgPSBsYXN0UmFuZ2UgfHwgdGhpcy5yYW5nZXNbMF07XFxuXFx0ICAgICAgICBpZiAobGFzdFJhbmdlICYmICFsYXN0UmFuZ2UuaXNFcXVhbCh0aGlzLmdldFJhbmdlKCkpKVxcblxcdCAgICAgICAgICAgIHRoaXMuZnJvbU9yaWVudGVkUmFuZ2UobGFzdFJhbmdlKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy4kaW5pdFJhbmdlTGlzdCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMucmFuZ2VMaXN0KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHRoaXMucmFuZ2VMaXN0ID0gbmV3IFJhbmdlTGlzdCgpO1xcblxcdCAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcXG5cXHQgICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IDA7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZ2V0QWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy5yYW5nZUNvdW50ID8gdGhpcy5yYW5nZUxpc3QucmFuZ2VzLmNvbmNhdCgpIDogW3RoaXMuZ2V0UmFuZ2UoKV07XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuc3BsaXRJbnRvTGluZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID4gMSkge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlTGlzdC5yYW5nZXM7XFxuXFx0ICAgICAgICAgICAgdmFyIGxhc3RSYW5nZSA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV07XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhyYW5nZXNbMF0uc3RhcnQsIGxhc3RSYW5nZS5lbmQpO1xcblxcblxcdCAgICAgICAgICAgIHRoaXMudG9TaW5nbGVSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UocmFuZ2UsIGxhc3RSYW5nZS5jdXJzb3IgPT0gbGFzdFJhbmdlLnN0YXJ0KTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHZhciBpc0JhY2t3YXJkcyA9IHRoaXMuaXNCYWNrd2FyZHMoKTtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSByYW5nZS5zdGFydC5yb3c7XFxuXFx0ICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHJhbmdlLmVuZC5yb3c7XFxuXFx0ICAgICAgICAgICAgaWYgKHN0YXJ0Um93ID09IGVuZFJvdykge1xcblxcdCAgICAgICAgICAgICAgICBpZiAoaXNCYWNrd2FyZHMpXFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5lbmQsIGVuZCA9IHJhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xcblxcdCAgICAgICAgICAgICAgICBcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShSYW5nZS5mcm9tUG9pbnRzKGVuZCwgZW5kKSk7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UoUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgc3RhcnQpKTtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgICAgIH1cXG5cXG5cXHQgICAgICAgICAgICB2YXIgcmVjdFNlbCA9IFtdO1xcblxcdCAgICAgICAgICAgIHZhciByID0gdGhpcy5nZXRMaW5lUmFuZ2Uoc3RhcnRSb3csIHRydWUpO1xcblxcdCAgICAgICAgICAgIHIuc3RhcnQuY29sdW1uID0gcmFuZ2Uuc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgICAgIHJlY3RTZWwucHVzaChyKTtcXG5cXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3cgKyAxOyBpIDwgZW5kUm93OyBpKyspXFxuXFx0ICAgICAgICAgICAgICAgIHJlY3RTZWwucHVzaCh0aGlzLmdldExpbmVSYW5nZShpLCB0cnVlKSk7XFxuXFxuXFx0ICAgICAgICAgICAgciA9IHRoaXMuZ2V0TGluZVJhbmdlKGVuZFJvdywgdHJ1ZSk7XFxuXFx0ICAgICAgICAgICAgci5lbmQuY29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtbjtcXG5cXHQgICAgICAgICAgICByZWN0U2VsLnB1c2gocik7XFxuXFxuXFx0ICAgICAgICAgICAgcmVjdFNlbC5mb3JFYWNoKHRoaXMuYWRkUmFuZ2UsIHRoaXMpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnRvZ2dsZUJsb2NrU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA+IDEpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5yYW5nZUxpc3QucmFuZ2VzO1xcblxcdCAgICAgICAgICAgIHZhciBsYXN0UmFuZ2UgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdO1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMocmFuZ2VzWzBdLnN0YXJ0LCBsYXN0UmFuZ2UuZW5kKTtcXG5cXG5cXHQgICAgICAgICAgICB0aGlzLnRvU2luZ2xlUmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKHJhbmdlLCBsYXN0UmFuZ2UuY3Vyc29yID09IGxhc3RSYW5nZS5zdGFydCk7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLnNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uTGVhZCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5zZWxlY3Rpb25BbmNob3IpO1xcblxcblxcdCAgICAgICAgICAgIHZhciByZWN0U2VsID0gdGhpcy5yZWN0YW5ndWxhclJhbmdlQmxvY2soY3Vyc29yLCBhbmNob3IpO1xcblxcdCAgICAgICAgICAgIHJlY3RTZWwuZm9yRWFjaCh0aGlzLmFkZFJhbmdlLCB0aGlzKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZWN0YW5ndWxhclJhbmdlQmxvY2sgPSBmdW5jdGlvbihzY3JlZW5DdXJzb3IsIHNjcmVlbkFuY2hvciwgaW5jbHVkZUVtcHR5TGluZXMpIHtcXG5cXHQgICAgICAgIHZhciByZWN0U2VsID0gW107XFxuXFxuXFx0ICAgICAgICB2YXIgeEJhY2t3YXJkcyA9IHNjcmVlbkN1cnNvci5jb2x1bW4gPCBzY3JlZW5BbmNob3IuY29sdW1uO1xcblxcdCAgICAgICAgaWYgKHhCYWNrd2FyZHMpIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBzY3JlZW5DdXJzb3IuY29sdW1uO1xcblxcdCAgICAgICAgICAgIHZhciBlbmRDb2x1bW4gPSBzY3JlZW5BbmNob3IuY29sdW1uO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBzY3JlZW5BbmNob3IuY29sdW1uO1xcblxcdCAgICAgICAgICAgIHZhciBlbmRDb2x1bW4gPSBzY3JlZW5DdXJzb3IuY29sdW1uO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgdmFyIHlCYWNrd2FyZHMgPSBzY3JlZW5DdXJzb3Iucm93IDwgc2NyZWVuQW5jaG9yLnJvdztcXG5cXHQgICAgICAgIGlmICh5QmFja3dhcmRzKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gc2NyZWVuQ3Vyc29yLnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgZW5kUm93ID0gc2NyZWVuQW5jaG9yLnJvdztcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gc2NyZWVuQW5jaG9yLnJvdztcXG5cXHQgICAgICAgICAgICB2YXIgZW5kUm93ID0gc2NyZWVuQ3Vyc29yLnJvdztcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChzdGFydENvbHVtbiA8IDApXFxuXFx0ICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSAwO1xcblxcdCAgICAgICAgaWYgKHN0YXJ0Um93IDwgMClcXG5cXHQgICAgICAgICAgICBzdGFydFJvdyA9IDA7XFxuXFxuXFx0ICAgICAgICBpZiAoc3RhcnRSb3cgPT0gZW5kUm93KVxcblxcdCAgICAgICAgICAgIGluY2x1ZGVFbXB0eUxpbmVzID0gdHJ1ZTtcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPD0gZW5kUm93OyByb3crKykge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IFJhbmdlLmZyb21Qb2ludHMoXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24ocm93LCBzdGFydENvbHVtbiksXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24ocm93LCBlbmRDb2x1bW4pXFxuXFx0ICAgICAgICAgICAgKTtcXG5cXHQgICAgICAgICAgICBpZiAocmFuZ2UuaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChkb2NFbmQgJiYgaXNTYW1lUG9pbnQocmFuZ2UuZW5kLCBkb2NFbmQpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBkb2NFbmQgPSByYW5nZS5lbmQ7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IHhCYWNrd2FyZHMgPyByYW5nZS5zdGFydCA6IHJhbmdlLmVuZDtcXG5cXHQgICAgICAgICAgICByZWN0U2VsLnB1c2gocmFuZ2UpO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKHlCYWNrd2FyZHMpXFxuXFx0ICAgICAgICAgICAgcmVjdFNlbC5yZXZlcnNlKCk7XFxuXFxuXFx0ICAgICAgICBpZiAoIWluY2x1ZGVFbXB0eUxpbmVzKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGVuZCA9IHJlY3RTZWwubGVuZ3RoIC0gMTtcXG5cXHQgICAgICAgICAgICB3aGlsZSAocmVjdFNlbFtlbmRdLmlzRW1wdHkoKSAmJiBlbmQgPiAwKVxcblxcdCAgICAgICAgICAgICAgICBlbmQtLTtcXG5cXHQgICAgICAgICAgICBpZiAoZW5kID4gMCkge1xcblxcdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xcblxcdCAgICAgICAgICAgICAgICB3aGlsZSAocmVjdFNlbFtzdGFydF0uaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgICAgICAgICAgc3RhcnQrKztcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVuZDsgaSA+PSBzdGFydDsgaS0tKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChyZWN0U2VsW2ldLmlzRW1wdHkoKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJlY3RTZWwuc3BsaWNlKGksIDEpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiByZWN0U2VsO1xcblxcdCAgICB9O1xcblxcdH0pLmNhbGwoU2VsZWN0aW9uLnByb3RvdHlwZSk7XFxuXFx0dmFyIEVkaXRvciA9IGFjZXF1aXJlKFxcXCIuL2VkaXRvclxcXCIpLkVkaXRvcjtcXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uTWFya2VycyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5hZGRTZWxlY3Rpb25NYXJrZXIgPSBmdW5jdGlvbihvcmllbnRlZFJhbmdlKSB7XFxuXFx0ICAgICAgICBpZiAoIW9yaWVudGVkUmFuZ2UuY3Vyc29yKVxcblxcdCAgICAgICAgICAgIG9yaWVudGVkUmFuZ2UuY3Vyc29yID0gb3JpZW50ZWRSYW5nZS5lbmQ7XFxuXFxuXFx0ICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlKCk7XFxuXFx0ICAgICAgICBvcmllbnRlZFJhbmdlLm1hcmtlciA9IHRoaXMuc2Vzc2lvbi5hZGRNYXJrZXIob3JpZW50ZWRSYW5nZSwgXFxcImFjZV9zZWxlY3Rpb25cXFwiLCBzdHlsZSk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uJHNlbGVjdGlvbk1hcmtlcnMucHVzaChvcmllbnRlZFJhbmdlKTtcXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5zZWxlY3Rpb25NYXJrZXJDb3VudCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2Vycy5sZW5ndGg7XFxuXFx0ICAgICAgICByZXR1cm4gb3JpZW50ZWRSYW5nZTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZW1vdmVTZWxlY3Rpb25NYXJrZXIgPSBmdW5jdGlvbihyYW5nZSkge1xcblxcdCAgICAgICAgaWYgKCFyYW5nZS5tYXJrZXIpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXIpO1xcblxcdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzLmluZGV4T2YocmFuZ2UpO1xcblxcdCAgICAgICAgaWYgKGluZGV4ICE9IC0xKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpO1xcblxcdCAgICAgICAgdGhpcy5zZXNzaW9uLnNlbGVjdGlvbk1hcmtlckNvdW50ID0gdGhpcy5zZXNzaW9uLiRzZWxlY3Rpb25NYXJrZXJzLmxlbmd0aDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5yZW1vdmVTZWxlY3Rpb25NYXJrZXJzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XFxuXFx0ICAgICAgICB2YXIgbWFya2VyTGlzdCA9IHRoaXMuc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycztcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07ICkge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcXG5cXHQgICAgICAgICAgICBpZiAoIXJhbmdlLm1hcmtlcilcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnJlbW92ZU1hcmtlcihyYW5nZS5tYXJrZXIpO1xcblxcdCAgICAgICAgICAgIHZhciBpbmRleCA9IG1hcmtlckxpc3QuaW5kZXhPZihyYW5nZSk7XFxuXFx0ICAgICAgICAgICAgaWYgKGluZGV4ICE9IC0xKVxcblxcdCAgICAgICAgICAgICAgICBtYXJrZXJMaXN0LnNwbGljZShpbmRleCwgMSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uc2VsZWN0aW9uTWFya2VyQ291bnQgPSBtYXJrZXJMaXN0Lmxlbmd0aDtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kb25BZGRSYW5nZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHRoaXMuYWRkU2VsZWN0aW9uTWFya2VyKGUucmFuZ2UpO1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVDdXJzb3IoKTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kb25SZW1vdmVSYW5nZSA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0aW9uTWFya2VycyhlLnJhbmdlcyk7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRvbk11bHRpU2VsZWN0ID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgdGhpcy5pbk11bHRpU2VsZWN0TW9kZSA9IHRydWU7XFxuXFxuXFx0ICAgICAgICB0aGlzLnNldFN0eWxlKFxcXCJhY2VfbXVsdGlzZWxlY3RcXFwiKTtcXG5cXHQgICAgICAgIHRoaXMua2V5QmluZGluZy5hZGRLZXlib2FyZEhhbmRsZXIoY29tbWFuZHMua2V5Ym9hcmRIYW5kbGVyKTtcXG5cXHQgICAgICAgIHRoaXMuY29tbWFuZHMuc2V0RGVmYXVsdEhhbmRsZXIoXFxcImV4ZWNcXFwiLCB0aGlzLiRvbk11bHRpU2VsZWN0RXhlYyk7XFxuXFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xcblxcdCAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVCYWNrTWFya2VycygpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRvblNpbmdsZVNlbGVjdCA9IGZ1bmN0aW9uKGUpIHtcXG5cXHQgICAgICAgIGlmICh0aGlzLnNlc3Npb24ubXVsdGlTZWxlY3QuaW5WaXJ0dWFsTW9kZSlcXG5cXHQgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICB0aGlzLmluTXVsdGlTZWxlY3RNb2RlID0gZmFsc2U7XFxuXFxuXFx0ICAgICAgICB0aGlzLnVuc2V0U3R5bGUoXFxcImFjZV9tdWx0aXNlbGVjdFxcXCIpO1xcblxcdCAgICAgICAgdGhpcy5rZXlCaW5kaW5nLnJlbW92ZUtleWJvYXJkSGFuZGxlcihjb21tYW5kcy5rZXlib2FyZEhhbmRsZXIpO1xcblxcblxcdCAgICAgICAgdGhpcy5jb21tYW5kcy5yZW1vdmVEZWZhdWx0SGFuZGxlcihcXFwiZXhlY1xcXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3RFeGVjKTtcXG5cXHQgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQ3Vyc29yKCk7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKCk7XFxuXFx0ICAgICAgICB0aGlzLl9lbWl0KFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kb25NdWx0aVNlbGVjdEV4ZWMgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICB2YXIgY29tbWFuZCA9IGUuY29tbWFuZDtcXG5cXHQgICAgICAgIHZhciBlZGl0b3IgPSBlLmVkaXRvcjtcXG5cXHQgICAgICAgIGlmICghZWRpdG9yLm11bHRpU2VsZWN0KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIGlmICghY29tbWFuZC5tdWx0aVNlbGVjdEFjdGlvbikge1xcblxcdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21tYW5kLmV4ZWMoZWRpdG9yLCBlLmFyZ3MgfHwge30pO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5hZGRSYW5nZShlZGl0b3IubXVsdGlTZWxlY3QudG9PcmllbnRlZFJhbmdlKCkpO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5tdWx0aVNlbGVjdC5tZXJnZU92ZXJsYXBwaW5nUmFuZ2VzKCk7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQubXVsdGlTZWxlY3RBY3Rpb24gPT0gXFxcImZvckVhY2hcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgcmVzdWx0ID0gZWRpdG9yLmZvckVhY2hTZWxlY3Rpb24oY29tbWFuZCwgZS5hcmdzKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5tdWx0aVNlbGVjdEFjdGlvbiA9PSBcXFwiZm9yRWFjaExpbmVcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgcmVzdWx0ID0gZWRpdG9yLmZvckVhY2hTZWxlY3Rpb24oY29tbWFuZCwgZS5hcmdzLCB0cnVlKTtcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZC5tdWx0aVNlbGVjdEFjdGlvbiA9PSBcXFwic2luZ2xlXFxcIikge1xcblxcdCAgICAgICAgICAgIGVkaXRvci5leGl0TXVsdGlTZWxlY3RNb2RlKCk7XFxuXFx0ICAgICAgICAgICAgcmVzdWx0ID0gY29tbWFuZC5leGVjKGVkaXRvciwgZS5hcmdzIHx8IHt9KTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgcmVzdWx0ID0gY29tbWFuZC5tdWx0aVNlbGVjdEFjdGlvbihlZGl0b3IsIGUuYXJncyB8fCB7fSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xcblxcdCAgICB9OyBcXG5cXHQgICAgdGhpcy5mb3JFYWNoU2VsZWN0aW9uID0gZnVuY3Rpb24oY21kLCBhcmdzLCBvcHRpb25zKSB7XFxuXFx0ICAgICAgICBpZiAodGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBrZWVwT3JkZXIgPSBvcHRpb25zICYmIG9wdGlvbnMua2VlcE9yZGVyO1xcblxcdCAgICAgICAgdmFyICRieUxpbmVzID0gb3B0aW9ucyA9PSB0cnVlIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy4kYnlMaW5lc1xcblxcdCAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XFxuXFx0ICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XFxuXFx0ICAgICAgICB2YXIgcmFuZ2VMaXN0ID0gc2VsZWN0aW9uLnJhbmdlTGlzdDtcXG5cXHQgICAgICAgIHZhciByYW5nZXMgPSAoa2VlcE9yZGVyID8gc2VsZWN0aW9uIDogcmFuZ2VMaXN0KS5yYW5nZXM7XFxuXFx0ICAgICAgICB2YXIgcmVzdWx0O1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGNtZC5leGVjID8gY21kLmV4ZWModGhpcywgYXJncyB8fCB7fSkgOiBjbWQodGhpcywgYXJncyB8fCB7fSk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHZhciByZWcgPSBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnk7XFxuXFx0ICAgICAgICBzZWxlY3Rpb24uX2V2ZW50UmVnaXN0cnkgPSB7fTtcXG5cXG5cXHQgICAgICAgIHZhciB0bXBTZWwgPSBuZXcgU2VsZWN0aW9uKHNlc3Npb24pO1xcblxcdCAgICAgICAgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlID0gdHJ1ZTtcXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKCRieUxpbmVzKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiByYW5nZXNbaV0uc3RhcnQucm93ID09IHJhbmdlc1tpIC0gMV0uZW5kLnJvdylcXG5cXHQgICAgICAgICAgICAgICAgICAgIGktLTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdG1wU2VsLmZyb21PcmllbnRlZFJhbmdlKHJhbmdlc1tpXSk7XFxuXFx0ICAgICAgICAgICAgdG1wU2VsLmluZGV4ID0gaTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlc3Npb24uc2VsZWN0aW9uID0gdG1wU2VsO1xcblxcdCAgICAgICAgICAgIHZhciBjbWRSZXN1bHQgPSBjbWQuZXhlYyA/IGNtZC5leGVjKHRoaXMsIGFyZ3MgfHwge30pIDogY21kKHRoaXMsIGFyZ3MgfHwge30pO1xcblxcdCAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIGNtZFJlc3VsdCAhPT0gdW5kZWZpbmVkKVxcblxcdCAgICAgICAgICAgICAgICByZXN1bHQgPSBjbWRSZXN1bHQ7XFxuXFx0ICAgICAgICAgICAgdG1wU2VsLnRvT3JpZW50ZWRSYW5nZShyYW5nZXNbaV0pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdG1wU2VsLmRldGFjaCgpO1xcblxcblxcdCAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZXNzaW9uLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcXG5cXHQgICAgICAgIHRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSA9IGZhbHNlO1xcblxcdCAgICAgICAgc2VsZWN0aW9uLl9ldmVudFJlZ2lzdHJ5ID0gcmVnO1xcblxcdCAgICAgICAgc2VsZWN0aW9uLm1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMoKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIGFuaW0gPSB0aGlzLnJlbmRlcmVyLiRzY3JvbGxBbmltYXRpb247XFxuXFx0ICAgICAgICB0aGlzLm9uQ3Vyc29yQ2hhbmdlKCk7XFxuXFx0ICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XFxuXFx0ICAgICAgICBpZiAoYW5pbSAmJiBhbmltLmZyb20gPT0gYW5pbS50bylcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFuaW1hdGVTY3JvbGxpbmcoYW5pbS5mcm9tKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5leGl0TXVsdGlTZWxlY3RNb2RlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgfHwgdGhpcy5pblZpcnR1YWxTZWxlY3Rpb25Nb2RlKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHRoaXMubXVsdGlTZWxlY3QudG9TaW5nbGVSYW5nZSgpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgdmFyIHRleHQgPSBcXFwiXFxcIjtcXG5cXHQgICAgICAgIGlmICh0aGlzLmluTXVsdGlTZWxlY3RNb2RlICYmICF0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5tdWx0aVNlbGVjdC5yYW5nZUxpc3QucmFuZ2VzO1xcblxcdCAgICAgICAgICAgIHZhciBidWYgPSBbXTtcXG5cXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgICAgICBidWYucHVzaCh0aGlzLnNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlc1tpXSkpO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICB2YXIgbmwgPSB0aGlzLnNlc3Npb24uZ2V0RG9jdW1lbnQoKS5nZXROZXdMaW5lQ2hhcmFjdGVyKCk7XFxuXFx0ICAgICAgICAgICAgdGV4dCA9IGJ1Zi5qb2luKG5sKTtcXG5cXHQgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gKGJ1Zi5sZW5ndGggLSAxKSAqIG5sLmxlbmd0aClcXG5cXHQgICAgICAgICAgICAgICAgdGV4dCA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgfSBlbHNlIGlmICghdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgdGV4dCA9IHRoaXMuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UodGhpcy5nZXRTZWxlY3Rpb25SYW5nZSgpKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHJldHVybiB0ZXh0O1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uKGUsIGFuY2hvcikge1xcblxcdCAgICAgICAgaWYgKHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgJiYgIXRoaXMuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xcblxcdCAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMubXVsdGlTZWxlY3QucmFuZ2VzWzBdO1xcblxcdCAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0LmlzRW1wdHkoKSAmJiBhbmNob3IgPT0gdGhpcy5tdWx0aVNlbGVjdC5hbmNob3IpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICB2YXIgcG9zID0gYW5jaG9yID09IHRoaXMubXVsdGlTZWxlY3QuYW5jaG9yXFxuXFx0ICAgICAgICAgICAgICAgID8gcmFuZ2UuY3Vyc29yID09IHJhbmdlLnN0YXJ0ID8gcmFuZ2UuZW5kIDogcmFuZ2Uuc3RhcnRcXG5cXHQgICAgICAgICAgICAgICAgOiByYW5nZS5jdXJzb3I7XFxuXFx0ICAgICAgICAgICAgaWYgKCFpc1NhbWVQb2ludChwb3MsIGFuY2hvcikpXFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3QudG9TaW5nbGVSYW5nZSh0aGlzLm11bHRpU2VsZWN0LnRvT3JpZW50ZWRSYW5nZSgpKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5vblBhc3RlID0gZnVuY3Rpb24odGV4dCkge1xcblxcdCAgICAgICAgaWYgKHRoaXMuJHJlYWRPbmx5KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXG5cXHQgICAgICAgIHZhciBlID0ge3RleHQ6IHRleHR9O1xcblxcdCAgICAgICAgdGhpcy5fc2lnbmFsKFxcXCJwYXN0ZVxcXCIsIGUpO1xcblxcdCAgICAgICAgdGV4dCA9IGUudGV4dDtcXG5cXHQgICAgICAgIGlmICghdGhpcy5pbk11bHRpU2VsZWN0TW9kZSB8fCB0aGlzLmluVmlydHVhbFNlbGVjdGlvbk1vZGUpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHRleHQpO1xcblxcblxcdCAgICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxcXHJcXFxcbnxcXFxccnxcXFxcbi8pO1xcblxcdCAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZXM7XFxuXFxuXFx0ICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gcmFuZ2VzLmxlbmd0aCB8fCBsaW5lcy5sZW5ndGggPCAyIHx8ICFsaW5lc1sxXSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5leGVjKFxcXCJpbnNlcnRzdHJpbmdcXFwiLCB0aGlzLCB0ZXh0KTtcXG5cXG5cXHQgICAgICAgIGZvciAodmFyIGkgPSByYW5nZXMubGVuZ3RoOyBpLS07KSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xcblxcdCAgICAgICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpKVxcblxcdCAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcXG5cXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uaW5zZXJ0KHJhbmdlLnN0YXJ0LCBsaW5lc1tpXSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZmluZEFsbCA9IGZ1bmN0aW9uKG5lZWRsZSwgb3B0aW9ucywgYWRkaXRpdmUpIHtcXG5cXHQgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdCAgICAgICAgb3B0aW9ucy5uZWVkbGUgPSBuZWVkbGUgfHwgb3B0aW9ucy5uZWVkbGU7XFxuXFx0ICAgICAgICBpZiAob3B0aW9ucy5uZWVkbGUgPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWxlY3Rpb24uaXNFbXB0eSgpXFxuXFx0ICAgICAgICAgICAgICAgID8gdGhpcy5zZWxlY3Rpb24uZ2V0V29yZFJhbmdlKClcXG5cXHQgICAgICAgICAgICAgICAgOiB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIG9wdGlvbnMubmVlZGxlID0gdGhpcy5zZXNzaW9uLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICB9ICAgIFxcblxcdCAgICAgICAgdGhpcy4kc2VhcmNoLnNldChvcHRpb25zKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuJHNlYXJjaC5maW5kQWxsKHRoaXMuc2Vzc2lvbik7XFxuXFx0ICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIDA7XFxuXFxuXFx0ICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyArPSAxO1xcblxcdCAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMubXVsdGlTZWxlY3Q7XFxuXFxuXFx0ICAgICAgICBpZiAoIWFkZGl0aXZlKVxcblxcdCAgICAgICAgICAgIHNlbGVjdGlvbi50b1NpbmdsZVJhbmdlKHJhbmdlc1swXSk7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gcmFuZ2VzLmxlbmd0aDsgaS0tOyApXFxuXFx0ICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlc1tpXSwgdHJ1ZSk7XFxuXFx0ICAgICAgICBpZiAocmFuZ2UgJiYgc2VsZWN0aW9uLnJhbmdlTGlzdC5yYW5nZUF0UG9pbnQocmFuZ2Uuc3RhcnQpKVxcblxcdCAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSwgdHJ1ZSk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHRoaXMuJGJsb2NrU2Nyb2xsaW5nIC09IDE7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gcmFuZ2VzLmxlbmd0aDtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5zZWxlY3RNb3JlTGluZXMgPSBmdW5jdGlvbihkaXIsIHNraXApIHtcXG5cXHQgICAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsZWN0aW9uLnRvT3JpZW50ZWRSYW5nZSgpO1xcblxcdCAgICAgICAgdmFyIGlzQmFja3dhcmRzID0gcmFuZ2UuY3Vyc29yID09IHJhbmdlLmVuZDtcXG5cXG5cXHQgICAgICAgIHZhciBzY3JlZW5MZWFkID0gdGhpcy5zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbihyYW5nZS5jdXJzb3IpO1xcblxcdCAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLiRkZXNpcmVkQ29sdW1uKVxcblxcdCAgICAgICAgICAgIHNjcmVlbkxlYWQuY29sdW1uID0gdGhpcy5zZWxlY3Rpb24uJGRlc2lyZWRDb2x1bW47XFxuXFxuXFx0ICAgICAgICB2YXIgbGVhZCA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuTGVhZC5yb3cgKyBkaXIsIHNjcmVlbkxlYWQuY29sdW1uKTtcXG5cXG5cXHQgICAgICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHNjcmVlbkFuY2hvciA9IHRoaXMuc2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24oaXNCYWNrd2FyZHMgPyByYW5nZS5lbmQgOiByYW5nZS5zdGFydCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuc2Vzc2lvbi5zY3JlZW5Ub0RvY3VtZW50UG9zaXRpb24oc2NyZWVuQW5jaG9yLnJvdyArIGRpciwgc2NyZWVuQW5jaG9yLmNvbHVtbik7XFxuXFx0ICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgIHZhciBhbmNob3IgPSBsZWFkO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKGlzQmFja3dhcmRzKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhsZWFkLCBhbmNob3IpO1xcblxcdCAgICAgICAgICAgIG5ld1JhbmdlLmN1cnNvciA9IG5ld1JhbmdlLnN0YXJ0O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgbmV3UmFuZ2UgPSBSYW5nZS5mcm9tUG9pbnRzKGFuY2hvciwgbGVhZCk7XFxuXFx0ICAgICAgICAgICAgbmV3UmFuZ2UuY3Vyc29yID0gbmV3UmFuZ2UuZW5kO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgbmV3UmFuZ2UuZGVzaXJlZENvbHVtbiA9IHNjcmVlbkxlYWQuY29sdW1uO1xcblxcdCAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5pbk11bHRpU2VsZWN0TW9kZSkge1xcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHNraXApXFxuXFx0ICAgICAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9IHJhbmdlLmN1cnNvcjtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHRoaXMuc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcXG5cXHQgICAgICAgIGlmICh0b1JlbW92ZSlcXG5cXHQgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zdWJzdHJhY3RQb2ludCh0b1JlbW92ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMudHJhbnNwb3NlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uKGRpcikge1xcblxcdCAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XFxuXFx0ICAgICAgICB2YXIgc2VsID0gc2Vzc2lvbi5tdWx0aVNlbGVjdDtcXG5cXHQgICAgICAgIHZhciBhbGwgPSBzZWwucmFuZ2VzO1xcblxcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTsgKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gYWxsW2ldO1xcblxcdCAgICAgICAgICAgIGlmIChyYW5nZS5pc0VtcHR5KCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHNlc3Npb24uZ2V0V29yZFJhbmdlKHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2Uuc3RhcnQuY29sdW1uKTtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gdG1wLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQuY29sdW1uID0gdG1wLnN0YXJ0LmNvbHVtbjtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IHRtcC5lbmQucm93O1xcblxcdCAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uID0gdG1wLmVuZC5jb2x1bW47XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgc2VsLm1lcmdlT3ZlcmxhcHBpbmdSYW5nZXMoKTtcXG5cXG5cXHQgICAgICAgIHZhciB3b3JkcyA9IFtdO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IGFsbC5sZW5ndGg7IGktLTsgKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gYWxsW2ldO1xcblxcdCAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQoc2Vzc2lvbi5nZXRUZXh0UmFuZ2UocmFuZ2UpKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIGlmIChkaXIgPCAwKVxcblxcdCAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQod29yZHMucG9wKCkpO1xcblxcdCAgICAgICAgZWxzZVxcblxcdCAgICAgICAgICAgIHdvcmRzLnB1c2god29yZHMuc2hpZnQoKSk7XFxuXFxuXFx0ICAgICAgICBmb3IgKHZhciBpID0gYWxsLmxlbmd0aDsgaS0tOyApIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSBhbGxbaV07XFxuXFx0ICAgICAgICAgICAgdmFyIHRtcCA9IHJhbmdlLmNsb25lKCk7XFxuXFx0ICAgICAgICAgICAgc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCB3b3Jkc1tpXSk7XFxuXFx0ICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93ID0gdG1wLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gPSB0bXAuc3RhcnQuY29sdW1uO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNlbGVjdE1vcmUgPSBmdW5jdGlvbihkaXIsIHNraXAsIHN0b3BBdEZpcnN0KSB7XFxuXFx0ICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcXG5cXHQgICAgICAgIHZhciBzZWwgPSBzZXNzaW9uLm11bHRpU2VsZWN0O1xcblxcblxcdCAgICAgICAgdmFyIHJhbmdlID0gc2VsLnRvT3JpZW50ZWRSYW5nZSgpO1xcblxcdCAgICAgICAgaWYgKHJhbmdlLmlzRW1wdHkoKSkge1xcblxcdCAgICAgICAgICAgIHJhbmdlID0gc2Vzc2lvbi5nZXRXb3JkUmFuZ2UocmFuZ2Uuc3RhcnQucm93LCByYW5nZS5zdGFydC5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgIHJhbmdlLmN1cnNvciA9IGRpciA9PSAtMSA/IHJhbmdlLnN0YXJ0IDogcmFuZ2UuZW5kO1xcblxcdCAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3QuYWRkUmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgICAgIGlmIChzdG9wQXRGaXJzdClcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdmFyIG5lZWRsZSA9IHNlc3Npb24uZ2V0VGV4dFJhbmdlKHJhbmdlKTtcXG5cXG5cXHQgICAgICAgIHZhciBuZXdSYW5nZSA9IGZpbmQoc2Vzc2lvbiwgbmVlZGxlLCBkaXIpO1xcblxcdCAgICAgICAgaWYgKG5ld1JhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgbmV3UmFuZ2UuY3Vyc29yID0gZGlyID09IC0xID8gbmV3UmFuZ2Uuc3RhcnQgOiBuZXdSYW5nZS5lbmQ7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kYmxvY2tTY3JvbGxpbmcgKz0gMTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24udW5mb2xkKG5ld1JhbmdlKTtcXG5cXHQgICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0LmFkZFJhbmdlKG5ld1JhbmdlKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiRibG9ja1Njcm9sbGluZyAtPSAxO1xcblxcdCAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcobnVsbCwgMC41KTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChza2lwKVxcblxcdCAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3Quc3Vic3RyYWN0UG9pbnQocmFuZ2UuY3Vyc29yKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5hbGlnbkN1cnNvcnMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xcblxcdCAgICAgICAgdmFyIHNlbCA9IHNlc3Npb24ubXVsdGlTZWxlY3Q7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2VzID0gc2VsLnJhbmdlcztcXG5cXHQgICAgICAgIHZhciByb3cgPSAtMTtcXG5cXHQgICAgICAgIHZhciBzYW1lUm93UmFuZ2VzID0gcmFuZ2VzLmZpbHRlcihmdW5jdGlvbihyKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHIuY3Vyc29yLnJvdyA9PSByb3cpXFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcdCAgICAgICAgICAgIHJvdyA9IHIuY3Vyc29yLnJvdztcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgc2FtZVJvd1Jhbmdlcy5sZW5ndGggPT0gcmFuZ2VzLmxlbmd0aCAtIDEpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHZhciBmciA9IHJhbmdlLnN0YXJ0LnJvdywgbHIgPSByYW5nZS5lbmQucm93O1xcblxcdCAgICAgICAgICAgIHZhciBndWVzc1JhbmdlID0gZnIgPT0gbHI7XFxuXFx0ICAgICAgICAgICAgaWYgKGd1ZXNzUmFuZ2UpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMuc2Vzc2lvbi5nZXRMZW5ndGgoKTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGxpbmU7XFxuXFx0ICAgICAgICAgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGxpbmUgPSB0aGlzLnNlc3Npb24uZ2V0TGluZShscik7XFxuXFx0ICAgICAgICAgICAgICAgIH0gd2hpbGUgKC9bPTpdLy50ZXN0KGxpbmUpICYmICsrbHIgPCBtYXgpO1xcblxcdCAgICAgICAgICAgICAgICBkbyB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBsaW5lID0gdGhpcy5zZXNzaW9uLmdldExpbmUoZnIpO1xcblxcdCAgICAgICAgICAgICAgICB9IHdoaWxlICgvWz06XS8udGVzdChsaW5lKSAmJiAtLWZyID4gMCk7XFxuXFx0ICAgICAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgICAgICBpZiAoZnIgPCAwKSBmciA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChsciA+PSBtYXgpIGxyID0gbWF4IC0gMTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5zZXNzaW9uLmRvYy5yZW1vdmVMaW5lcyhmciwgbHIpO1xcblxcdCAgICAgICAgICAgIGxpbmVzID0gdGhpcy4kcmVBbGlnblRleHQobGluZXMsIGd1ZXNzUmFuZ2UpO1xcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5kb2MuaW5zZXJ0KHtyb3c6IGZyLCBjb2x1bW46IDB9LCBsaW5lcy5qb2luKFxcXCJcXFxcblxcXCIpICsgXFxcIlxcXFxuXFxcIik7XFxuXFx0ICAgICAgICAgICAgaWYgKCFndWVzc1JhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbHVtbiA9IDA7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgc2FtZVJvd1Jhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcXG5cXHQgICAgICAgICAgICAgICAgc2VsLnN1YnN0cmFjdFBvaW50KHIuY3Vyc29yKTtcXG5cXHQgICAgICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgICAgICB2YXIgbWF4Q29sID0gMDtcXG5cXHQgICAgICAgICAgICB2YXIgbWluU3BhY2UgPSBJbmZpbml0eTtcXG5cXHQgICAgICAgICAgICB2YXIgc3BhY2VPZmZzZXRzID0gcmFuZ2VzLm1hcChmdW5jdGlvbihyKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBwID0gci5jdXJzb3I7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHAucm93KTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHNwYWNlT2Zmc2V0ID0gbGluZS5zdWJzdHIocC5jb2x1bW4pLnNlYXJjaCgvXFxcXFMvZyk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzcGFjZU9mZnNldCA9PSAtMSlcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNwYWNlT2Zmc2V0ID0gMDtcXG5cXG5cXHQgICAgICAgICAgICAgICAgaWYgKHAuY29sdW1uID4gbWF4Q29sKVxcblxcdCAgICAgICAgICAgICAgICAgICAgbWF4Q29sID0gcC5jb2x1bW47XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzcGFjZU9mZnNldCA8IG1pblNwYWNlKVxcblxcdCAgICAgICAgICAgICAgICAgICAgbWluU3BhY2UgPSBzcGFjZU9mZnNldDtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNwYWNlT2Zmc2V0O1xcblxcdCAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIHAgPSByLmN1cnNvcjtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGwgPSBtYXhDb2wgLSBwLmNvbHVtbjtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGQgPSBzcGFjZU9mZnNldHNbaV0gLSBtaW5TcGFjZTtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKGwgPiBkKVxcblxcdCAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5pbnNlcnQocCwgbGFuZy5zdHJpbmdSZXBlYXQoXFxcIiBcXFwiLCBsIC0gZCkpO1xcblxcdCAgICAgICAgICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZShuZXcgUmFuZ2UocC5yb3csIHAuY29sdW1uLCBwLnJvdywgcC5jb2x1bW4gLSBsICsgZCkpO1xcblxcblxcdCAgICAgICAgICAgICAgICByLnN0YXJ0LmNvbHVtbiA9IHIuZW5kLmNvbHVtbiA9IG1heENvbDtcXG5cXHQgICAgICAgICAgICAgICAgci5zdGFydC5yb3cgPSByLmVuZC5yb3cgPSBwLnJvdztcXG5cXHQgICAgICAgICAgICAgICAgci5jdXJzb3IgPSByLmVuZDtcXG5cXHQgICAgICAgICAgICB9KTtcXG5cXHQgICAgICAgICAgICBzZWwuZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2VzWzBdKTtcXG5cXHQgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUN1cnNvcigpO1xcblxcdCAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQmFja01hcmtlcnMoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kcmVBbGlnblRleHQgPSBmdW5jdGlvbihsaW5lcywgZm9yY2VMZWZ0KSB7XFxuXFx0ICAgICAgICB2YXIgaXNMZWZ0QWxpZ25lZCA9IHRydWUsIGlzUmlnaHRBbGlnbmVkID0gdHJ1ZTtcXG5cXHQgICAgICAgIHZhciBzdGFydFcsIHRleHRXLCBlbmRXO1xcblxcblxcdCAgICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbihsaW5lKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC8oXFxcXHMqKSguKj8pKFxcXFxzKikoWz06XS4qKS8pO1xcblxcdCAgICAgICAgICAgIGlmICghbSlcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtsaW5lXTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoc3RhcnRXID09IG51bGwpIHtcXG5cXHQgICAgICAgICAgICAgICAgc3RhcnRXID0gbVsxXS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgIHRleHRXID0gbVsyXS5sZW5ndGg7XFxuXFx0ICAgICAgICAgICAgICAgIGVuZFcgPSBtWzNdLmxlbmd0aDtcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIG07XFxuXFx0ICAgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICAgIGlmIChzdGFydFcgKyB0ZXh0VyArIGVuZFcgIT0gbVsxXS5sZW5ndGggKyBtWzJdLmxlbmd0aCArIG1bM10ubGVuZ3RoKVxcblxcdCAgICAgICAgICAgICAgICBpc1JpZ2h0QWxpZ25lZCA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgIGlmIChzdGFydFcgIT0gbVsxXS5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgICAgIGlzTGVmdEFsaWduZWQgPSBmYWxzZTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoc3RhcnRXID4gbVsxXS5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgICAgIHN0YXJ0VyA9IG1bMV0ubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIGlmICh0ZXh0VyA8IG1bMl0ubGVuZ3RoKVxcblxcdCAgICAgICAgICAgICAgICB0ZXh0VyA9IG1bMl0ubGVuZ3RoO1xcblxcdCAgICAgICAgICAgIGlmIChlbmRXID4gbVszXS5sZW5ndGgpXFxuXFx0ICAgICAgICAgICAgICAgIGVuZFcgPSBtWzNdLmxlbmd0aDtcXG5cXG5cXHQgICAgICAgICAgICByZXR1cm4gbTtcXG5cXHQgICAgICAgIH0pLm1hcChmb3JjZUxlZnQgPyBhbGlnbkxlZnQgOlxcblxcdCAgICAgICAgICAgIGlzTGVmdEFsaWduZWQgPyBpc1JpZ2h0QWxpZ25lZCA/IGFsaWduUmlnaHQgOiBhbGlnbkxlZnQgOiB1bkFsaWduKTtcXG5cXG5cXHQgICAgICAgIGZ1bmN0aW9uIHNwYWNlcyhuKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIGxhbmcuc3RyaW5nUmVwZWF0KFxcXCIgXFxcIiwgbik7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBmdW5jdGlvbiBhbGlnbkxlZnQobSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiAhbVsyXSA/IG1bMF0gOiBzcGFjZXMoc3RhcnRXKSArIG1bMl1cXG5cXHQgICAgICAgICAgICAgICAgKyBzcGFjZXModGV4dFcgLSBtWzJdLmxlbmd0aCArIGVuZFcpXFxuXFx0ICAgICAgICAgICAgICAgICsgbVs0XS5yZXBsYWNlKC9eKFs9Ol0pXFxcXHMrLywgXFxcIiQxIFxcXCIpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgZnVuY3Rpb24gYWxpZ25SaWdodChtKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuICFtWzJdID8gbVswXSA6IHNwYWNlcyhzdGFydFcgKyB0ZXh0VyAtIG1bMl0ubGVuZ3RoKSArIG1bMl1cXG5cXHQgICAgICAgICAgICAgICAgKyBzcGFjZXMoZW5kVywgXFxcIiBcXFwiKVxcblxcdCAgICAgICAgICAgICAgICArIG1bNF0ucmVwbGFjZSgvXihbPTpdKVxcXFxzKy8sIFxcXCIkMSBcXFwiKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGZ1bmN0aW9uIHVuQWxpZ24obSkge1xcblxcdCAgICAgICAgICAgIHJldHVybiAhbVsyXSA/IG1bMF0gOiBzcGFjZXMoc3RhcnRXKSArIG1bMl1cXG5cXHQgICAgICAgICAgICAgICAgKyBzcGFjZXMoZW5kVylcXG5cXHQgICAgICAgICAgICAgICAgKyBtWzRdLnJlcGxhY2UoL14oWz06XSlcXFxccysvLCBcXFwiJDEgXFxcIik7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0fSkuY2FsbChFZGl0b3IucHJvdG90eXBlKTtcXG5cXG5cXG5cXHRmdW5jdGlvbiBpc1NhbWVQb2ludChwMSwgcDIpIHtcXG5cXHQgICAgcmV0dXJuIHAxLnJvdyA9PSBwMi5yb3cgJiYgcDEuY29sdW1uID09IHAyLmNvbHVtbjtcXG5cXHR9XFxuXFx0ZXhwb3J0cy5vblNlc3Npb25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgIHZhciBzZXNzaW9uID0gZS5zZXNzaW9uO1xcblxcdCAgICBpZiAoc2Vzc2lvbiAmJiAhc2Vzc2lvbi5tdWx0aVNlbGVjdCkge1xcblxcdCAgICAgICAgc2Vzc2lvbi4kc2VsZWN0aW9uTWFya2VycyA9IFtdO1xcblxcdCAgICAgICAgc2Vzc2lvbi5zZWxlY3Rpb24uJGluaXRSYW5nZUxpc3QoKTtcXG5cXHQgICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3QgPSBzZXNzaW9uLnNlbGVjdGlvbjtcXG5cXHQgICAgfVxcblxcdCAgICB0aGlzLm11bHRpU2VsZWN0ID0gc2Vzc2lvbiAmJiBzZXNzaW9uLm11bHRpU2VsZWN0O1xcblxcblxcdCAgICB2YXIgb2xkU2Vzc2lvbiA9IGUub2xkU2Vzc2lvbjtcXG5cXHQgICAgaWYgKG9sZFNlc3Npb24pIHtcXG5cXHQgICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3Qub2ZmKFxcXCJhZGRSYW5nZVxcXCIsIHRoaXMuJG9uQWRkUmFuZ2UpO1xcblxcdCAgICAgICAgb2xkU2Vzc2lvbi5tdWx0aVNlbGVjdC5vZmYoXFxcInJlbW92ZVJhbmdlXFxcIiwgdGhpcy4kb25SZW1vdmVSYW5nZSk7XFxuXFx0ICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0Lm9mZihcXFwibXVsdGlTZWxlY3RcXFwiLCB0aGlzLiRvbk11bHRpU2VsZWN0KTtcXG5cXHQgICAgICAgIG9sZFNlc3Npb24ubXVsdGlTZWxlY3Qub2ZmKFxcXCJzaW5nbGVTZWxlY3RcXFwiLCB0aGlzLiRvblNpbmdsZVNlbGVjdCk7XFxuXFx0ICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0LmxlYWQub2ZmKFxcXCJjaGFuZ2VcXFwiLCAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XFxuXFx0ICAgICAgICBvbGRTZXNzaW9uLm11bHRpU2VsZWN0LmFuY2hvci5vZmYoXFxcImNoYW5nZVxcXCIsICB0aGlzLiRjaGVja011bHRpc2VsZWN0Q2hhbmdlKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAoc2Vzc2lvbikge1xcblxcdCAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcXFwiYWRkUmFuZ2VcXFwiLCB0aGlzLiRvbkFkZFJhbmdlKTtcXG5cXHQgICAgICAgIHNlc3Npb24ubXVsdGlTZWxlY3Qub24oXFxcInJlbW92ZVJhbmdlXFxcIiwgdGhpcy4kb25SZW1vdmVSYW5nZSk7XFxuXFx0ICAgICAgICBzZXNzaW9uLm11bHRpU2VsZWN0Lm9uKFxcXCJtdWx0aVNlbGVjdFxcXCIsIHRoaXMuJG9uTXVsdGlTZWxlY3QpO1xcblxcdCAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5vbihcXFwic2luZ2xlU2VsZWN0XFxcIiwgdGhpcy4kb25TaW5nbGVTZWxlY3QpO1xcblxcdCAgICAgICAgc2Vzc2lvbi5tdWx0aVNlbGVjdC5sZWFkLm9uKFxcXCJjaGFuZ2VcXFwiLCAgdGhpcy4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSk7XFxuXFx0ICAgICAgICBzZXNzaW9uLm11bHRpU2VsZWN0LmFuY2hvci5vbihcXFwiY2hhbmdlXFxcIiwgIHRoaXMuJGNoZWNrTXVsdGlzZWxlY3RDaGFuZ2UpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChzZXNzaW9uICYmIHRoaXMuaW5NdWx0aVNlbGVjdE1vZGUgIT0gc2Vzc2lvbi5zZWxlY3Rpb24uaW5NdWx0aVNlbGVjdE1vZGUpIHtcXG5cXHQgICAgICAgIGlmIChzZXNzaW9uLnNlbGVjdGlvbi5pbk11bHRpU2VsZWN0TW9kZSlcXG5cXHQgICAgICAgICAgICB0aGlzLiRvbk11bHRpU2VsZWN0KCk7XFxuXFx0ICAgICAgICBlbHNlXFxuXFx0ICAgICAgICAgICAgdGhpcy4kb25TaW5nbGVTZWxlY3QoKTtcXG5cXHQgICAgfVxcblxcdH07XFxuXFx0ZnVuY3Rpb24gTXVsdGlTZWxlY3QoZWRpdG9yKSB7XFxuXFx0ICAgIGlmIChlZGl0b3IuJG11bHRpc2VsZWN0T25TZXNzaW9uQ2hhbmdlKVxcblxcdCAgICAgICAgcmV0dXJuO1xcblxcdCAgICBlZGl0b3IuJG9uQWRkUmFuZ2UgPSBlZGl0b3IuJG9uQWRkUmFuZ2UuYmluZChlZGl0b3IpO1xcblxcdCAgICBlZGl0b3IuJG9uUmVtb3ZlUmFuZ2UgPSBlZGl0b3IuJG9uUmVtb3ZlUmFuZ2UuYmluZChlZGl0b3IpO1xcblxcdCAgICBlZGl0b3IuJG9uTXVsdGlTZWxlY3QgPSBlZGl0b3IuJG9uTXVsdGlTZWxlY3QuYmluZChlZGl0b3IpO1xcblxcdCAgICBlZGl0b3IuJG9uU2luZ2xlU2VsZWN0ID0gZWRpdG9yLiRvblNpbmdsZVNlbGVjdC5iaW5kKGVkaXRvcik7XFxuXFx0ICAgIGVkaXRvci4kbXVsdGlzZWxlY3RPblNlc3Npb25DaGFuZ2UgPSBleHBvcnRzLm9uU2Vzc2lvbkNoYW5nZS5iaW5kKGVkaXRvcik7XFxuXFx0ICAgIGVkaXRvci4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZSA9IGVkaXRvci4kY2hlY2tNdWx0aXNlbGVjdENoYW5nZS5iaW5kKGVkaXRvcik7XFxuXFxuXFx0ICAgIGVkaXRvci4kbXVsdGlzZWxlY3RPblNlc3Npb25DaGFuZ2UoZWRpdG9yKTtcXG5cXHQgICAgZWRpdG9yLm9uKFxcXCJjaGFuZ2VTZXNzaW9uXFxcIiwgZWRpdG9yLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSk7XFxuXFxuXFx0ICAgIGVkaXRvci5vbihcXFwibW91c2Vkb3duXFxcIiwgb25Nb3VzZURvd24pO1xcblxcdCAgICBlZGl0b3IuY29tbWFuZHMuYWRkQ29tbWFuZHMoY29tbWFuZHMuZGVmYXVsdENvbW1hbmRzKTtcXG5cXG5cXHQgICAgYWRkQWx0Q3Vyc29yTGlzdGVuZXJzKGVkaXRvcik7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGFkZEFsdEN1cnNvckxpc3RlbmVycyhlZGl0b3Ipe1xcblxcdCAgICB2YXIgZWwgPSBlZGl0b3IudGV4dElucHV0LmdldEVsZW1lbnQoKTtcXG5cXHQgICAgdmFyIGFsdEN1cnNvciA9IGZhbHNlO1xcblxcdCAgICBldmVudC5hZGRMaXN0ZW5lcihlbCwgXFxcImtleWRvd25cXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICBpZiAoZS5rZXlDb2RlID09IDE4ICYmICEoZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5KSkge1xcblxcdCAgICAgICAgICAgIGlmICghYWx0Q3Vyc29yKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5zZXRNb3VzZUN1cnNvcihcXFwiY3Jvc3NoYWlyXFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgIGFsdEN1cnNvciA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSBlbHNlIGlmIChhbHRDdXJzb3IpIHtcXG5cXHQgICAgICAgICAgICByZXNldCgpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFxcXCJrZXl1cFxcXCIsIHJlc2V0KTtcXG5cXHQgICAgZXZlbnQuYWRkTGlzdGVuZXIoZWwsIFxcXCJibHVyXFxcIiwgcmVzZXQpO1xcblxcdCAgICBmdW5jdGlvbiByZXNldChlKSB7XFxuXFx0ICAgICAgICBpZiAoYWx0Q3Vyc29yKSB7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNldE1vdXNlQ3Vyc29yKFxcXCJcXFwiKTtcXG5cXHQgICAgICAgICAgICBhbHRDdXJzb3IgPSBmYWxzZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfVxcblxcdH1cXG5cXG5cXHRleHBvcnRzLk11bHRpU2VsZWN0ID0gTXVsdGlTZWxlY3Q7XFxuXFxuXFxuXFx0YWNlcXVpcmUoXFxcIi4vY29uZmlnXFxcIikuZGVmaW5lT3B0aW9ucyhFZGl0b3IucHJvdG90eXBlLCBcXFwiZWRpdG9yXFxcIiwge1xcblxcdCAgICBlbmFibGVNdWx0aXNlbGVjdDoge1xcblxcdCAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcXG5cXHQgICAgICAgICAgICBNdWx0aVNlbGVjdCh0aGlzKTtcXG5cXHQgICAgICAgICAgICBpZiAodmFsKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMub24oXFxcImNoYW5nZVNlc3Npb25cXFwiLCB0aGlzLiRtdWx0aXNlbGVjdE9uU2Vzc2lvbkNoYW5nZSk7XFxuXFx0ICAgICAgICAgICAgICAgIHRoaXMub24oXFxcIm1vdXNlZG93blxcXCIsIG9uTW91c2VEb3duKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgICAgICAgICB0aGlzLm9mZihcXFwiY2hhbmdlU2Vzc2lvblxcXCIsIHRoaXMuJG11bHRpc2VsZWN0T25TZXNzaW9uQ2hhbmdlKTtcXG5cXHQgICAgICAgICAgICAgICAgdGhpcy5vZmYoXFxcIm1vdXNlZG93blxcXCIsIG9uTW91c2VEb3duKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9LFxcblxcdCAgICAgICAgdmFsdWU6IHRydWVcXG5cXHQgICAgfVxcblxcdH0pO1xcblxcblxcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3JhbmdlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4uLy4uL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFxuXFx0dmFyIEZvbGRNb2RlID0gZXhwb3J0cy5Gb2xkTW9kZSA9IGZ1bmN0aW9uKCkge307XFxuXFxuXFx0KGZ1bmN0aW9uKCkge1xcblxcblxcdCAgICB0aGlzLmZvbGRpbmdTdGFydE1hcmtlciA9IG51bGw7XFxuXFx0ICAgIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIgPSBudWxsO1xcblxcdCAgICB0aGlzLmdldEZvbGRXaWRnZXQgPSBmdW5jdGlvbihzZXNzaW9uLCBmb2xkU3R5bGUsIHJvdykge1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KTtcXG5cXHQgICAgICAgIGlmICh0aGlzLmZvbGRpbmdTdGFydE1hcmtlci50ZXN0KGxpbmUpKVxcblxcdCAgICAgICAgICAgIHJldHVybiBcXFwic3RhcnRcXFwiO1xcblxcdCAgICAgICAgaWYgKGZvbGRTdHlsZSA9PSBcXFwibWFya2JlZ2luZW5kXFxcIlxcblxcdCAgICAgICAgICAgICAgICAmJiB0aGlzLmZvbGRpbmdTdG9wTWFya2VyXFxuXFx0ICAgICAgICAgICAgICAgICYmIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIudGVzdChsaW5lKSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gXFxcImVuZFxcXCI7XFxuXFx0ICAgICAgICByZXR1cm4gXFxcIlxcXCI7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlID0gZnVuY3Rpb24oc2Vzc2lvbiwgZm9sZFN0eWxlLCByb3cpIHtcXG5cXHQgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmluZGVudGF0aW9uQmxvY2sgPSBmdW5jdGlvbihzZXNzaW9uLCByb3csIGNvbHVtbikge1xcblxcdCAgICAgICAgdmFyIHJlID0gL1xcXFxTLztcXG5cXHQgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XFxuXFx0ICAgICAgICB2YXIgc3RhcnRMZXZlbCA9IGxpbmUuc2VhcmNoKHJlKTtcXG5cXHQgICAgICAgIGlmIChzdGFydExldmVsID09IC0xKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHZhciBzdGFydENvbHVtbiA9IGNvbHVtbiB8fCBsaW5lLmxlbmd0aDtcXG5cXHQgICAgICAgIHZhciBtYXhSb3cgPSBzZXNzaW9uLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgdmFyIHN0YXJ0Um93ID0gcm93O1xcblxcdCAgICAgICAgdmFyIGVuZFJvdyA9IHJvdztcXG5cXG5cXHQgICAgICAgIHdoaWxlICgrK3JvdyA8IG1heFJvdykge1xcblxcdCAgICAgICAgICAgIHZhciBsZXZlbCA9IHNlc3Npb24uZ2V0TGluZShyb3cpLnNlYXJjaChyZSk7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKGxldmVsID09IC0xKVxcblxcdCAgICAgICAgICAgICAgICBjb250aW51ZTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAobGV2ZWwgPD0gc3RhcnRMZXZlbClcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuXFx0ICAgICAgICAgICAgZW5kUm93ID0gcm93O1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKGVuZFJvdyA+IHN0YXJ0Um93KSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGVuZENvbHVtbiA9IHNlc3Npb24uZ2V0TGluZShlbmRSb3cpLmxlbmd0aDtcXG5cXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgZW5kUm93LCBlbmRDb2x1bW4pO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLm9wZW5pbmdCcmFja2V0QmxvY2sgPSBmdW5jdGlvbihzZXNzaW9uLCBicmFja2V0LCByb3csIGNvbHVtbiwgdHlwZVJlKSB7XFxuXFx0ICAgICAgICB2YXIgc3RhcnQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1uICsgMX07XFxuXFx0ICAgICAgICB2YXIgZW5kID0gc2Vzc2lvbi4kZmluZENsb3NpbmdCcmFja2V0KGJyYWNrZXQsIHN0YXJ0LCB0eXBlUmUpO1xcblxcdCAgICAgICAgaWYgKCFlbmQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdmFyIGZ3ID0gc2Vzc2lvbi5mb2xkV2lkZ2V0c1tlbmQucm93XTtcXG5cXHQgICAgICAgIGlmIChmdyA9PSBudWxsKVxcblxcdCAgICAgICAgICAgIGZ3ID0gc2Vzc2lvbi5nZXRGb2xkV2lkZ2V0KGVuZC5yb3cpO1xcblxcblxcdCAgICAgICAgaWYgKGZ3ID09IFxcXCJzdGFydFxcXCIgJiYgZW5kLnJvdyA+IHN0YXJ0LnJvdykge1xcblxcdCAgICAgICAgICAgIGVuZC5yb3cgLS07XFxuXFx0ICAgICAgICAgICAgZW5kLmNvbHVtbiA9IHNlc3Npb24uZ2V0TGluZShlbmQucm93KS5sZW5ndGg7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydCwgZW5kKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jbG9zaW5nQnJhY2tldEJsb2NrID0gZnVuY3Rpb24oc2Vzc2lvbiwgYnJhY2tldCwgcm93LCBjb2x1bW4sIHR5cGVSZSkge1xcblxcdCAgICAgICAgdmFyIGVuZCA9IHtyb3c6IHJvdywgY29sdW1uOiBjb2x1bW59O1xcblxcdCAgICAgICAgdmFyIHN0YXJ0ID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KGJyYWNrZXQsIGVuZCk7XFxuXFxuXFx0ICAgICAgICBpZiAoIXN0YXJ0KVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgICAgIHN0YXJ0LmNvbHVtbisrO1xcblxcdCAgICAgICAgZW5kLmNvbHVtbi0tO1xcblxcblxcdCAgICAgICAgcmV0dXJuICBSYW5nZS5mcm9tUG9pbnRzKHN0YXJ0LCBlbmQpO1xcblxcdCAgICB9O1xcblxcdH0pLmNhbGwoRm9sZE1vZGUucHJvdG90eXBlKTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvdGhlbWUvdGV4dG1hdGVcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL2RvbVxcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMuaXNEYXJrID0gZmFsc2U7XFxuXFx0ZXhwb3J0cy5jc3NDbGFzcyA9IFxcXCJhY2UtdG1cXFwiO1xcblxcdGV4cG9ydHMuY3NzVGV4dCA9IFxcXCIuYWNlLXRtIC5hY2VfZ3V0dGVyIHtcXFxcXFxuXFx0YmFja2dyb3VuZDogI2YwZjBmMDtcXFxcXFxuXFx0Y29sb3I6ICMzMzM7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX3ByaW50LW1hcmdpbiB7XFxcXFxcblxcdHdpZHRoOiAxcHg7XFxcXFxcblxcdGJhY2tncm91bmQ6ICNlOGU4ZTg7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX2ZvbGQge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjNkI3MkU2O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0ge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRkZGO1xcXFxcXG5cXHRjb2xvcjogYmxhY2s7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX2N1cnNvciB7XFxcXFxcblxcdGNvbG9yOiBibGFjaztcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfaW52aXNpYmxlIHtcXFxcXFxuXFx0Y29sb3I6IHJnYigxOTEsIDE5MSwgMTkxKTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2Vfc3RvcmFnZSxcXFxcXFxuXFx0LmFjZS10bSAuYWNlX2tleXdvcmQge1xcXFxcXG5cXHRjb2xvcjogYmx1ZTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfY29uc3RhbnQge1xcXFxcXG5cXHRjb2xvcjogcmdiKDE5NywgNiwgMTEpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9jb25zdGFudC5hY2VfYnVpbGRpbiB7XFxcXFxcblxcdGNvbG9yOiByZ2IoODgsIDcyLCAyNDYpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9jb25zdGFudC5hY2VfbGFuZ3VhZ2Uge1xcXFxcXG5cXHRjb2xvcjogcmdiKDg4LCA5MiwgMjQ2KTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfY29uc3RhbnQuYWNlX2xpYnJhcnkge1xcXFxcXG5cXHRjb2xvcjogcmdiKDYsIDE1MCwgMTQpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9pbnZhbGlkIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDAsIDAsIDAuMSk7XFxcXFxcblxcdGNvbG9yOiByZWQ7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX3N1cHBvcnQuYWNlX2Z1bmN0aW9uIHtcXFxcXFxuXFx0Y29sb3I6IHJnYig2MCwgNzYsIDExNCk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX3N1cHBvcnQuYWNlX2NvbnN0YW50IHtcXFxcXFxuXFx0Y29sb3I6IHJnYig2LCAxNTAsIDE0KTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2Vfc3VwcG9ydC5hY2VfdHlwZSxcXFxcXFxuXFx0LmFjZS10bSAuYWNlX3N1cHBvcnQuYWNlX2NsYXNzIHtcXFxcXFxuXFx0Y29sb3I6IHJnYigxMDksIDEyMSwgMjIyKTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2Vfa2V5d29yZC5hY2Vfb3BlcmF0b3Ige1xcXFxcXG5cXHRjb2xvcjogcmdiKDEwNCwgMTE4LCAxMzUpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9zdHJpbmcge1xcXFxcXG5cXHRjb2xvcjogcmdiKDMsIDEwNiwgNyk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX2NvbW1lbnQge1xcXFxcXG5cXHRjb2xvcjogcmdiKDc2LCAxMzYsIDEwNyk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX2NvbW1lbnQuYWNlX2RvYyB7XFxcXFxcblxcdGNvbG9yOiByZ2IoMCwgMTAyLCAyNTUpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9jb21tZW50LmFjZV9kb2MuYWNlX3RhZyB7XFxcXFxcblxcdGNvbG9yOiByZ2IoMTI4LCAxNTksIDE5MSk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX2NvbnN0YW50LmFjZV9udW1lcmljIHtcXFxcXFxuXFx0Y29sb3I6IHJnYigwLCAwLCAyMDUpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV92YXJpYWJsZSB7XFxcXFxcblxcdGNvbG9yOiByZ2IoNDksIDEzMiwgMTQ5KTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfeG1sLXBlIHtcXFxcXFxuXFx0Y29sb3I6IHJnYigxMDQsIDEwNCwgOTEpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9lbnRpdHkuYWNlX25hbWUuYWNlX2Z1bmN0aW9uIHtcXFxcXFxuXFx0Y29sb3I6ICMwMDAwQTI7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX2hlYWRpbmcge1xcXFxcXG5cXHRjb2xvcjogcmdiKDEyLCA3LCAyNTUpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9saXN0IHtcXFxcXFxuXFx0Y29sb3I6cmdiKDE4NSwgNiwgMTQ0KTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfbWV0YS5hY2VfdGFnIHtcXFxcXFxuXFx0Y29sb3I6cmdiKDAsIDIyLCAxNDIpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9zdHJpbmcuYWNlX3JlZ2V4IHtcXFxcXFxuXFx0Y29sb3I6IHJnYigyNTUsIDAsIDApXFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX3NlbGVjdGlvbiB7XFxcXFxcblxcdGJhY2tncm91bmQ6IHJnYigxODEsIDIxMywgMjU1KTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtLmFjZV9tdWx0aXNlbGVjdCAuYWNlX3NlbGVjdGlvbi5hY2Vfc3RhcnQge1xcXFxcXG5cXHRib3gtc2hhZG93OiAwIDAgM3B4IDBweCB3aGl0ZTtcXFxcXFxuXFx0Ym9yZGVyLXJhZGl1czogMnB4O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9tYXJrZXItbGF5ZXIgLmFjZV9zdGVwIHtcXFxcXFxuXFx0YmFja2dyb3VuZDogcmdiKDI1MiwgMjU1LCAwKTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc3RhY2sge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiByZ2IoMTY0LCAyMjksIDEwMSk7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZS10bSAuYWNlX21hcmtlci1sYXllciAuYWNlX2JyYWNrZXQge1xcXFxcXG5cXHRtYXJnaW46IC0xcHggMCAwIC0xcHg7XFxcXFxcblxcdGJvcmRlcjogMXB4IHNvbGlkIHJnYigxOTIsIDE5MiwgMTkyKTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2VfYWN0aXZlLWxpbmUge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMDcpO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9ndXR0ZXItYWN0aXZlLWxpbmUge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yIDogI2RjZGNkYztcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlLXRtIC5hY2VfbWFya2VyLWxheWVyIC5hY2Vfc2VsZWN0ZWQtd29yZCB7XFxcXFxcblxcdGJhY2tncm91bmQ6IHJnYigyNTAsIDI1MCwgMjU1KTtcXFxcXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgcmdiKDIwMCwgMjAwLCAyNTApO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2UtdG0gLmFjZV9pbmRlbnQtZ3VpZGUge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiB1cmwoXFxcXFxcXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUNDQVlBQUFDWmdiWW5BQUFBRTBsRVFWUUltV1A0Ly8vL2Y0YkxseS8vQndBbVZnZDEvdzExL2dBQUFBQkpSVTVFcmtKZ2dnPT1cXFxcXFxcIikgcmlnaHQgcmVwZWF0LXk7XFxcXFxcblxcdH1cXFxcXFxuXFx0XFxcIjtcXG5cXG5cXHR2YXIgZG9tID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9kb21cXFwiKTtcXG5cXHRkb20uaW1wb3J0Q3NzU3RyaW5nKGV4cG9ydHMuY3NzVGV4dCwgZXhwb3J0cy5jc3NDbGFzcyk7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2xpbmVfd2lkZ2V0c1xcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvcmFuZ2VcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4vbGliL29vcFxcXCIpO1xcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi9saWIvZG9tXFxcIik7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4vcmFuZ2VcXFwiKS5SYW5nZTtcXG5cXG5cXG5cXHRmdW5jdGlvbiBMaW5lV2lkZ2V0cyhzZXNzaW9uKSB7XFxuXFx0ICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XFxuXFx0ICAgIHRoaXMuc2Vzc2lvbi53aWRnZXRNYW5hZ2VyID0gdGhpcztcXG5cXHQgICAgdGhpcy5zZXNzaW9uLmdldFJvd0xlbmd0aCA9IHRoaXMuZ2V0Um93TGVuZ3RoO1xcblxcdCAgICB0aGlzLnNlc3Npb24uJGdldFdpZGdldFNjcmVlbkxlbmd0aCA9IHRoaXMuJGdldFdpZGdldFNjcmVlbkxlbmd0aDtcXG5cXHQgICAgdGhpcy51cGRhdGVPbkNoYW5nZSA9IHRoaXMudXBkYXRlT25DaGFuZ2UuYmluZCh0aGlzKTtcXG5cXHQgICAgdGhpcy5yZW5kZXJXaWRnZXRzID0gdGhpcy5yZW5kZXJXaWRnZXRzLmJpbmQodGhpcyk7XFxuXFx0ICAgIHRoaXMubWVhc3VyZVdpZGdldHMgPSB0aGlzLm1lYXN1cmVXaWRnZXRzLmJpbmQodGhpcyk7XFxuXFx0ICAgIHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHMgPSBbXTtcXG5cXHQgICAgdGhpcy4kb25DaGFuZ2VFZGl0b3IgPSB0aGlzLiRvbkNoYW5nZUVkaXRvci5iaW5kKHRoaXMpO1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5zZXNzaW9uLm9uKFxcXCJjaGFuZ2VcXFwiLCB0aGlzLnVwZGF0ZU9uQ2hhbmdlKTtcXG5cXHQgICAgdGhpcy5zZXNzaW9uLm9uKFxcXCJjaGFuZ2VFZGl0b3JcXFwiLCB0aGlzLiRvbkNoYW5nZUVkaXRvcik7XFxuXFx0fVxcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXHQgICAgdGhpcy5nZXRSb3dMZW5ndGggPSBmdW5jdGlvbihyb3cpIHtcXG5cXHQgICAgICAgIHZhciBoO1xcblxcdCAgICAgICAgaWYgKHRoaXMubGluZVdpZGdldHMpXFxuXFx0ICAgICAgICAgICAgaCA9IHRoaXMubGluZVdpZGdldHNbcm93XSAmJiB0aGlzLmxpbmVXaWRnZXRzW3Jvd10ucm93Q291bnQgfHwgMDtcXG5cXHQgICAgICAgIGVsc2UgXFxuXFx0ICAgICAgICAgICAgaCA9IDA7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuJHVzZVdyYXBNb2RlIHx8ICF0aGlzLiR3cmFwRGF0YVtyb3ddKSB7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIDEgKyBoO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gdGhpcy4kd3JhcERhdGFbcm93XS5sZW5ndGggKyAxICsgaDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy4kZ2V0V2lkZ2V0U2NyZWVuTGVuZ3RoID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgc2NyZWVuUm93cyA9IDA7XFxuXFx0ICAgICAgICB0aGlzLmxpbmVXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24odyl7XFxuXFx0ICAgICAgICAgICAgaWYgKHcgJiYgdy5yb3dDb3VudClcXG5cXHQgICAgICAgICAgICAgICAgc2NyZWVuUm93cyArPXcucm93Q291bnQ7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHJldHVybiBzY3JlZW5Sb3dzO1xcblxcdCAgICB9OyAgICBcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJG9uQ2hhbmdlRWRpdG9yID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdGhpcy5hdHRhY2goZS5lZGl0b3IpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmF0dGFjaCA9IGZ1bmN0aW9uKGVkaXRvcikge1xcblxcdCAgICAgICAgaWYgKGVkaXRvciAgJiYgZWRpdG9yLndpZGdldE1hbmFnZXIgJiYgZWRpdG9yLndpZGdldE1hbmFnZXIgIT0gdGhpcylcXG5cXHQgICAgICAgICAgICBlZGl0b3Iud2lkZ2V0TWFuYWdlci5kZXRhY2goKTtcXG5cXG5cXHQgICAgICAgIGlmICh0aGlzLmVkaXRvciA9PSBlZGl0b3IpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdGhpcy5kZXRhY2goKTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICBpZiAoZWRpdG9yKSB7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLndpZGdldE1hbmFnZXIgPSB0aGlzO1xcblxcdCAgICAgICAgICAgIGVkaXRvci5yZW5kZXJlci5vbihcXFwiYmVmb3JlUmVuZGVyXFxcIiwgdGhpcy5tZWFzdXJlV2lkZ2V0cyk7XFxuXFx0ICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLm9uKFxcXCJhZnRlclJlbmRlclxcXCIsIHRoaXMucmVuZGVyV2lkZ2V0cyk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xcblxcdCAgICAgICAgaWYgKCFlZGl0b3IpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XFxuXFx0ICAgICAgICBlZGl0b3Iud2lkZ2V0TWFuYWdlciA9IG51bGw7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGVkaXRvci5yZW5kZXJlci5vZmYoXFxcImJlZm9yZVJlbmRlclxcXCIsIHRoaXMubWVhc3VyZVdpZGdldHMpO1xcblxcdCAgICAgICAgZWRpdG9yLnJlbmRlcmVyLm9mZihcXFwiYWZ0ZXJSZW5kZXJcXFwiLCB0aGlzLnJlbmRlcldpZGdldHMpO1xcblxcdCAgICAgICAgdmFyIGxpbmVXaWRnZXRzID0gdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzO1xcblxcdCAgICAgICAgbGluZVdpZGdldHMgJiYgbGluZVdpZGdldHMuZm9yRWFjaChmdW5jdGlvbih3KSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHcgJiYgdy5lbCAmJiB3LmVsLnBhcmVudE5vZGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgdy5faW5Eb2N1bWVudCA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgICAgICB3LmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQody5lbCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMudXBkYXRlT25DaGFuZ2UgPSBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XFxuXFx0ICAgICAgICBpZiAoIWxpbmVXaWRnZXRzKSByZXR1cm47XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICB2YXIgZGVsdGEgPSBlLmRhdGE7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSBkZWx0YS5yYW5nZTtcXG5cXHQgICAgICAgIHZhciBzdGFydFJvdyA9IHJhbmdlLnN0YXJ0LnJvdztcXG5cXHQgICAgICAgIHZhciBsZW4gPSByYW5nZS5lbmQucm93IC0gc3RhcnRSb3c7XFxuXFxuXFx0ICAgICAgICBpZiAobGVuID09PSAwKSB7XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKGRlbHRhLmFjdGlvbiA9PSBcXFwicmVtb3ZlVGV4dFxcXCIgfHwgZGVsdGEuYWN0aW9uID09IFxcXCJyZW1vdmVMaW5lc1xcXCIpIHtcXG5cXHQgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGxpbmVXaWRnZXRzLnNwbGljZShzdGFydFJvdyArIDEsIGxlbik7XFxuXFx0ICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcXG5cXHQgICAgICAgICAgICAgICAgdyAmJiB0aGlzLnJlbW92ZUxpbmVXaWRnZXQodyk7XFxuXFx0ICAgICAgICAgICAgfSwgdGhpcyk7XFxuXFx0ICAgICAgICAgICAgdGhpcy4kdXBkYXRlUm93cygpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xcblxcdCAgICAgICAgICAgIGFyZ3MudW5zaGlmdChzdGFydFJvdywgMCk7XFxuXFx0ICAgICAgICAgICAgbGluZVdpZGdldHMuc3BsaWNlLmFwcGx5KGxpbmVXaWRnZXRzLCBhcmdzKTtcXG5cXHQgICAgICAgICAgICB0aGlzLiR1cGRhdGVSb3dzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLiR1cGRhdGVSb3dzID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XFxuXFx0ICAgICAgICBpZiAoIWxpbmVXaWRnZXRzKSByZXR1cm47XFxuXFx0ICAgICAgICB2YXIgbm9XaWRnZXRzID0gdHJ1ZTtcXG5cXHQgICAgICAgIGxpbmVXaWRnZXRzLmZvckVhY2goZnVuY3Rpb24odywgaSkge1xcblxcdCAgICAgICAgICAgIGlmICh3KSB7XFxuXFx0ICAgICAgICAgICAgICAgIG5vV2lkZ2V0cyA9IGZhbHNlO1xcblxcdCAgICAgICAgICAgICAgICB3LnJvdyA9IGk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICBpZiAobm9XaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cyA9IG51bGw7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYWRkTGluZVdpZGdldCA9IGZ1bmN0aW9uKHcpIHtcXG5cXHQgICAgICAgIGlmICghdGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0cyA9IG5ldyBBcnJheSh0aGlzLnNlc3Npb24uZ2V0TGVuZ3RoKCkpO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24ubGluZVdpZGdldHNbdy5yb3ddID0gdztcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5lZGl0b3IucmVuZGVyZXI7XFxuXFx0ICAgICAgICBpZiAody5odG1sICYmICF3LmVsKSB7XFxuXFx0ICAgICAgICAgICAgdy5lbCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgICAgICAgICB3LmVsLmlubmVySFRNTCA9IHcuaHRtbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh3LmVsKSB7XFxuXFx0ICAgICAgICAgICAgZG9tLmFkZENzc0NsYXNzKHcuZWwsIFxcXCJhY2VfbGluZVdpZGdldENvbnRhaW5lclxcXCIpO1xcblxcdCAgICAgICAgICAgIHcuZWwuc3R5bGUucG9zaXRpb24gPSBcXFwiYWJzb2x1dGVcXFwiO1xcblxcdCAgICAgICAgICAgIHcuZWwuc3R5bGUuekluZGV4ID0gNTtcXG5cXHQgICAgICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQody5lbCk7XFxuXFx0ICAgICAgICAgICAgdy5faW5Eb2N1bWVudCA9IHRydWU7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmICghdy5jb3Zlckd1dHRlcikge1xcblxcdCAgICAgICAgICAgIHcuZWwuc3R5bGUuekluZGV4ID0gMztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICghdy5waXhlbEhlaWdodCkge1xcblxcdCAgICAgICAgICAgIHcucGl4ZWxIZWlnaHQgPSB3LmVsLm9mZnNldEhlaWdodDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmICh3LnJvd0NvdW50ID09IG51bGwpXFxuXFx0ICAgICAgICAgICAgdy5yb3dDb3VudCA9IHcucGl4ZWxIZWlnaHQgLyByZW5kZXJlci5sYXllckNvbmZpZy5saW5lSGVpZ2h0O1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uX2VtaXQoXFxcImNoYW5nZUZvbGRcXFwiLCB7ZGF0YTp7c3RhcnQ6e3Jvdzogdy5yb3d9fX0pO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLiR1cGRhdGVSb3dzKCk7XFxuXFx0ICAgICAgICB0aGlzLnJlbmRlcldpZGdldHMobnVsbCwgcmVuZGVyZXIpO1xcblxcdCAgICAgICAgcmV0dXJuIHc7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLnJlbW92ZUxpbmVXaWRnZXQgPSBmdW5jdGlvbih3KSB7XFxuXFx0ICAgICAgICB3Ll9pbkRvY3VtZW50ID0gZmFsc2U7XFxuXFx0ICAgICAgICBpZiAody5lbCAmJiB3LmVsLnBhcmVudE5vZGUpXFxuXFx0ICAgICAgICAgICAgdy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHcuZWwpO1xcblxcdCAgICAgICAgaWYgKHcuZWRpdG9yICYmIHcuZWRpdG9yLmRlc3Ryb3kpIHRyeSB7XFxuXFx0ICAgICAgICAgICAgdy5lZGl0b3IuZGVzdHJveSgpO1xcblxcdCAgICAgICAgfSBjYXRjaChlKXt9XFxuXFx0ICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmxpbmVXaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5saW5lV2lkZ2V0c1t3LnJvd10gPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uX2VtaXQoXFxcImNoYW5nZUZvbGRcXFwiLCB7ZGF0YTp7c3RhcnQ6e3Jvdzogdy5yb3d9fX0pO1xcblxcdCAgICAgICAgdGhpcy4kdXBkYXRlUm93cygpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdGhpcy5vbldpZGdldENoYW5nZWQgPSBmdW5jdGlvbih3KSB7XFxuXFx0ICAgICAgICB0aGlzLnNlc3Npb24uX2NoYW5nZWRXaWRnZXRzLnB1c2godyk7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5yZW5kZXJlci51cGRhdGVGdWxsKCk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLm1lYXN1cmVXaWRnZXRzID0gZnVuY3Rpb24oZSwgcmVuZGVyZXIpIHtcXG5cXHQgICAgICAgIHZhciBjaGFuZ2VkV2lkZ2V0cyA9IHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHM7XFxuXFx0ICAgICAgICB2YXIgY29uZmlnID0gcmVuZGVyZXIubGF5ZXJDb25maWc7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIGlmICghY2hhbmdlZFdpZGdldHMgfHwgIWNoYW5nZWRXaWRnZXRzLmxlbmd0aCkgcmV0dXJuO1xcblxcdCAgICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkV2lkZ2V0cy5sZW5ndGg7IGkrKykge1xcblxcdCAgICAgICAgICAgIHZhciB3ID0gY2hhbmdlZFdpZGdldHNbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKCF3Ll9pbkRvY3VtZW50KSB7XFxuXFx0ICAgICAgICAgICAgICAgIHcuX2luRG9jdW1lbnQgPSB0cnVlO1xcblxcdCAgICAgICAgICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQody5lbCk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIHcuaCA9IHcuZWwub2Zmc2V0SGVpZ2h0O1xcblxcdCAgICAgICAgICAgIFxcblxcdCAgICAgICAgICAgIGlmICghdy5maXhlZFdpZHRoKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHcudyA9IHcuZWwub2Zmc2V0V2lkdGg7XFxuXFx0ICAgICAgICAgICAgICAgIHcuc2NyZWVuV2lkdGggPSBNYXRoLmNlaWwody53IC8gY29uZmlnLmNoYXJhY3RlcldpZHRoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gdy5oIC8gY29uZmlnLmxpbmVIZWlnaHQ7XFxuXFx0ICAgICAgICAgICAgaWYgKHcuY292ZXJMaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJvd0NvdW50IC09IHRoaXMuc2Vzc2lvbi5nZXRSb3dMaW5lQ291bnQody5yb3cpO1xcblxcdCAgICAgICAgICAgICAgICBpZiAocm93Q291bnQgPCAwKVxcblxcdCAgICAgICAgICAgICAgICAgICAgcm93Q291bnQgPSAwO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBpZiAody5yb3dDb3VudCAhPSByb3dDb3VudCkge1xcblxcdCAgICAgICAgICAgICAgICB3LnJvd0NvdW50ID0gcm93Q291bnQ7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICh3LnJvdyA8IG1pbilcXG5cXHQgICAgICAgICAgICAgICAgICAgIG1pbiA9IHcucm93O1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIGlmIChtaW4gIT0gSW5maW5pdHkpIHtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24uX2VtaXQoXFxcImNoYW5nZUZvbGRcXFwiLCB7ZGF0YTp7c3RhcnQ6e3JvdzogbWlufX19KTtcXG5cXHQgICAgICAgICAgICB0aGlzLnNlc3Npb24ubGluZVdpZGdldFdpZHRoID0gbnVsbDtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICAgIHRoaXMuc2Vzc2lvbi5fY2hhbmdlZFdpZGdldHMgPSBbXTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMucmVuZGVyV2lkZ2V0cyA9IGZ1bmN0aW9uKGUsIHJlbmRlcmVyKSB7XFxuXFx0ICAgICAgICB2YXIgY29uZmlnID0gcmVuZGVyZXIubGF5ZXJDb25maWc7XFxuXFx0ICAgICAgICB2YXIgbGluZVdpZGdldHMgPSB0aGlzLnNlc3Npb24ubGluZVdpZGdldHM7XFxuXFx0ICAgICAgICBpZiAoIWxpbmVXaWRnZXRzKVxcblxcdCAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgIHZhciBmaXJzdCA9IE1hdGgubWluKHRoaXMuZmlyc3RSb3csIGNvbmZpZy5maXJzdFJvdyk7XFxuXFx0ICAgICAgICB2YXIgbGFzdCA9IE1hdGgubWF4KHRoaXMubGFzdFJvdywgY29uZmlnLmxhc3RSb3csIGxpbmVXaWRnZXRzLmxlbmd0aCk7XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHdoaWxlIChmaXJzdCA+IDAgJiYgIWxpbmVXaWRnZXRzW2ZpcnN0XSlcXG5cXHQgICAgICAgICAgICBmaXJzdC0tO1xcblxcdCAgICAgICAgXFxuXFx0ICAgICAgICB0aGlzLmZpcnN0Um93ID0gY29uZmlnLmZpcnN0Um93O1xcblxcdCAgICAgICAgdGhpcy5sYXN0Um93ID0gY29uZmlnLmxhc3RSb3c7XFxuXFxuXFx0ICAgICAgICByZW5kZXJlci4kY3Vyc29yTGF5ZXIuY29uZmlnID0gY29uZmlnO1xcblxcdCAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xcblxcdCAgICAgICAgICAgIHZhciB3ID0gbGluZVdpZGdldHNbaV07XFxuXFx0ICAgICAgICAgICAgaWYgKCF3IHx8ICF3LmVsKSBjb250aW51ZTtcXG5cXG5cXHQgICAgICAgICAgICBpZiAoIXcuX2luRG9jdW1lbnQpIHtcXG5cXHQgICAgICAgICAgICAgICAgdy5faW5Eb2N1bWVudCA9IHRydWU7XFxuXFx0ICAgICAgICAgICAgICAgIHJlbmRlcmVyLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh3LmVsKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdmFyIHRvcCA9IHJlbmRlcmVyLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKHtyb3c6IGksIGNvbHVtbjowfSwgdHJ1ZSkudG9wO1xcblxcdCAgICAgICAgICAgIGlmICghdy5jb3ZlckxpbmUpXFxuXFx0ICAgICAgICAgICAgICAgIHRvcCArPSBjb25maWcubGluZUhlaWdodCAqIHRoaXMuc2Vzc2lvbi5nZXRSb3dMaW5lQ291bnQody5yb3cpO1xcblxcdCAgICAgICAgICAgIHcuZWwuc3R5bGUudG9wID0gdG9wIC0gY29uZmlnLm9mZnNldCArIFxcXCJweFxcXCI7XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgdmFyIGxlZnQgPSB3LmNvdmVyR3V0dGVyID8gMCA6IHJlbmRlcmVyLmd1dHRlcldpZHRoO1xcblxcdCAgICAgICAgICAgIGlmICghdy5maXhlZFdpZHRoKVxcblxcdCAgICAgICAgICAgICAgICBsZWZ0IC09IHJlbmRlcmVyLnNjcm9sbExlZnQ7XFxuXFx0ICAgICAgICAgICAgdy5lbC5zdHlsZS5sZWZ0ID0gbGVmdCArIFxcXCJweFxcXCI7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKHcuZml4ZWRXaWR0aCkge1xcblxcdCAgICAgICAgICAgICAgICB3LmVsLnN0eWxlLnJpZ2h0ID0gcmVuZGVyZXIuc2Nyb2xsQmFyLmdldFdpZHRoKCkgKyBcXFwicHhcXFwiO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHcuZWwuc3R5bGUucmlnaHQgPSBcXFwiXFxcIjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdH0pLmNhbGwoTGluZVdpZGdldHMucHJvdG90eXBlKTtcXG5cXG5cXG5cXHRleHBvcnRzLkxpbmVXaWRnZXRzID0gTGluZVdpZGdldHM7XFxuXFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL2V4dC9lcnJvcl9tYXJrZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGluZV93aWRnZXRzXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvcmFuZ2VcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHR2YXIgTGluZVdpZGdldHMgPSBhY2VxdWlyZShcXFwiLi4vbGluZV93aWRnZXRzXFxcIikuTGluZVdpZGdldHM7XFxuXFx0dmFyIGRvbSA9IGFjZXF1aXJlKFxcXCIuLi9saWIvZG9tXFxcIik7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4uL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFxuXFx0ZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFycmF5LCBuZWVkbGUsIGNvbXBhcmF0b3IpIHtcXG5cXHQgICAgdmFyIGZpcnN0ID0gMDtcXG5cXHQgICAgdmFyIGxhc3QgPSBhcnJheS5sZW5ndGggLSAxO1xcblxcblxcdCAgICB3aGlsZSAoZmlyc3QgPD0gbGFzdCkge1xcblxcdCAgICAgICAgdmFyIG1pZCA9IChmaXJzdCArIGxhc3QpID4+IDE7XFxuXFx0ICAgICAgICB2YXIgYyA9IGNvbXBhcmF0b3IobmVlZGxlLCBhcnJheVttaWRdKTtcXG5cXHQgICAgICAgIGlmIChjID4gMClcXG5cXHQgICAgICAgICAgICBmaXJzdCA9IG1pZCArIDE7XFxuXFx0ICAgICAgICBlbHNlIGlmIChjIDwgMClcXG5cXHQgICAgICAgICAgICBsYXN0ID0gbWlkIC0gMTtcXG5cXHQgICAgICAgIGVsc2VcXG5cXHQgICAgICAgICAgICByZXR1cm4gbWlkO1xcblxcdCAgICB9XFxuXFx0ICAgIHJldHVybiAtKGZpcnN0ICsgMSk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGZpbmRBbm5vdGF0aW9ucyhzZXNzaW9uLCByb3csIGRpcikge1xcblxcdCAgICB2YXIgYW5ub3RhdGlvbnMgPSBzZXNzaW9uLmdldEFubm90YXRpb25zKCkuc29ydChSYW5nZS5jb21wYXJlUG9pbnRzKTtcXG5cXHQgICAgaWYgKCFhbm5vdGF0aW9ucy5sZW5ndGgpXFxuXFx0ICAgICAgICByZXR1cm47XFxuXFx0ICAgIFxcblxcdCAgICB2YXIgaSA9IGJpbmFyeVNlYXJjaChhbm5vdGF0aW9ucywge3Jvdzogcm93LCBjb2x1bW46IC0xfSwgUmFuZ2UuY29tcGFyZVBvaW50cyk7XFxuXFx0ICAgIGlmIChpIDwgMClcXG5cXHQgICAgICAgIGkgPSAtaSAtIDE7XFxuXFx0ICAgIFxcblxcdCAgICBpZiAoaSA+PSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxKVxcblxcdCAgICAgICAgaSA9IGRpciA+IDAgPyAwIDogYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcXG5cXHQgICAgZWxzZSBpZiAoaSA9PT0gMCAmJiBkaXIgPCAwKVxcblxcdCAgICAgICAgaSA9IGFubm90YXRpb25zLmxlbmd0aCAtIDE7XFxuXFx0ICAgIFxcblxcdCAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xcblxcdCAgICBpZiAoIWFubm90YXRpb24gfHwgIWRpcilcXG5cXHQgICAgICAgIHJldHVybjtcXG5cXG5cXHQgICAgaWYgKGFubm90YXRpb24ucm93ID09PSByb3cpIHtcXG5cXHQgICAgICAgIGRvIHtcXG5cXHQgICAgICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaSArPSBkaXJdO1xcblxcdCAgICAgICAgfSB3aGlsZSAoYW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9uLnJvdyA9PT0gcm93KTtcXG5cXHQgICAgICAgIGlmICghYW5ub3RhdGlvbilcXG5cXHQgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnMuc2xpY2UoKTtcXG5cXHQgICAgfVxcblxcdCAgICBcXG5cXHQgICAgXFxuXFx0ICAgIHZhciBtYXRjaGVkID0gW107XFxuXFx0ICAgIHJvdyA9IGFubm90YXRpb24ucm93O1xcblxcdCAgICBkbyB7XFxuXFx0ICAgICAgICBtYXRjaGVkW2RpciA8IDAgPyBcXFwidW5zaGlmdFxcXCIgOiBcXFwicHVzaFxcXCJdKGFubm90YXRpb24pO1xcblxcdCAgICAgICAgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2kgKz0gZGlyXTtcXG5cXHQgICAgfSB3aGlsZSAoYW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9uLnJvdyA9PSByb3cpO1xcblxcdCAgICByZXR1cm4gbWF0Y2hlZC5sZW5ndGggJiYgbWF0Y2hlZDtcXG5cXHR9XFxuXFxuXFx0ZXhwb3J0cy5zaG93RXJyb3JNYXJrZXIgPSBmdW5jdGlvbihlZGl0b3IsIGRpcikge1xcblxcdCAgICB2YXIgc2Vzc2lvbiA9IGVkaXRvci5zZXNzaW9uO1xcblxcdCAgICBpZiAoIXNlc3Npb24ud2lkZ2V0TWFuYWdlcikge1xcblxcdCAgICAgICAgc2Vzc2lvbi53aWRnZXRNYW5hZ2VyID0gbmV3IExpbmVXaWRnZXRzKHNlc3Npb24pO1xcblxcdCAgICAgICAgc2Vzc2lvbi53aWRnZXRNYW5hZ2VyLmF0dGFjaChlZGl0b3IpO1xcblxcdCAgICB9XFxuXFx0ICAgIFxcblxcdCAgICB2YXIgcG9zID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XFxuXFx0ICAgIHZhciByb3cgPSBwb3Mucm93O1xcblxcdCAgICB2YXIgb2xkV2lkZ2V0ID0gc2Vzc2lvbi5saW5lV2lkZ2V0cyAmJiBzZXNzaW9uLmxpbmVXaWRnZXRzW3Jvd107XFxuXFx0ICAgIGlmIChvbGRXaWRnZXQpIHtcXG5cXHQgICAgICAgIG9sZFdpZGdldC5kZXN0cm95KCk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICByb3cgLT0gZGlyO1xcblxcdCAgICB9XFxuXFx0ICAgIHZhciBhbm5vdGF0aW9ucyA9IGZpbmRBbm5vdGF0aW9ucyhzZXNzaW9uLCByb3csIGRpcik7XFxuXFx0ICAgIHZhciBndXR0ZXJBbm5vO1xcblxcdCAgICBpZiAoYW5ub3RhdGlvbnMpIHtcXG5cXHQgICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbMF07XFxuXFx0ICAgICAgICBwb3MuY29sdW1uID0gKGFubm90YXRpb24ucG9zICYmIHR5cGVvZiBhbm5vdGF0aW9uLmNvbHVtbiAhPSBcXFwibnVtYmVyXFxcIlxcblxcdCAgICAgICAgICAgID8gYW5ub3RhdGlvbi5wb3Muc2NcXG5cXHQgICAgICAgICAgICA6IGFubm90YXRpb24uY29sdW1uKSB8fCAwO1xcblxcdCAgICAgICAgcG9zLnJvdyA9IGFubm90YXRpb24ucm93O1xcblxcdCAgICAgICAgZ3V0dGVyQW5ubyA9IGVkaXRvci5yZW5kZXJlci4kZ3V0dGVyTGF5ZXIuJGFubm90YXRpb25zW3Bvcy5yb3ddO1xcblxcdCAgICB9IGVsc2UgaWYgKG9sZFdpZGdldCkge1xcblxcdCAgICAgICAgcmV0dXJuO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgZ3V0dGVyQW5ubyA9IHtcXG5cXHQgICAgICAgICAgICB0ZXh0OiBbXFxcIkxvb2tzIGdvb2QhXFxcIl0sXFxuXFx0ICAgICAgICAgICAgY2xhc3NOYW1lOiBcXFwiYWNlX29rXFxcIlxcblxcdCAgICAgICAgfTtcXG5cXHQgICAgfVxcblxcdCAgICBlZGl0b3Iuc2Vzc2lvbi51bmZvbGQocG9zLnJvdyk7XFxuXFx0ICAgIGVkaXRvci5zZWxlY3Rpb24ubW92ZVRvUG9zaXRpb24ocG9zKTtcXG5cXHQgICAgXFxuXFx0ICAgIHZhciB3ID0ge1xcblxcdCAgICAgICAgcm93OiBwb3Mucm93LCBcXG5cXHQgICAgICAgIGZpeGVkV2lkdGg6IHRydWUsXFxuXFx0ICAgICAgICBjb3Zlckd1dHRlcjogdHJ1ZSxcXG5cXHQgICAgICAgIGVsOiBkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIilcXG5cXHQgICAgfTtcXG5cXHQgICAgdmFyIGVsID0gdy5lbC5hcHBlbmRDaGlsZChkb20uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO1xcblxcdCAgICB2YXIgYXJyb3cgPSB3LmVsLmFwcGVuZENoaWxkKGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7XFxuXFx0ICAgIGFycm93LmNsYXNzTmFtZSA9IFxcXCJlcnJvcl93aWRnZXRfYXJyb3cgXFxcIiArIGd1dHRlckFubm8uY2xhc3NOYW1lO1xcblxcdCAgICBcXG5cXHQgICAgdmFyIGxlZnQgPSBlZGl0b3IucmVuZGVyZXIuJGN1cnNvckxheWVyXFxuXFx0ICAgICAgICAuZ2V0UGl4ZWxQb3NpdGlvbihwb3MpLmxlZnQ7XFxuXFx0ICAgIGFycm93LnN0eWxlLmxlZnQgPSBsZWZ0ICsgZWRpdG9yLnJlbmRlcmVyLmd1dHRlcldpZHRoIC0gNSArIFxcXCJweFxcXCI7XFxuXFx0ICAgIFxcblxcdCAgICB3LmVsLmNsYXNzTmFtZSA9IFxcXCJlcnJvcl93aWRnZXRfd3JhcHBlclxcXCI7XFxuXFx0ICAgIGVsLmNsYXNzTmFtZSA9IFxcXCJlcnJvcl93aWRnZXQgXFxcIiArIGd1dHRlckFubm8uY2xhc3NOYW1lO1xcblxcdCAgICBlbC5pbm5lckhUTUwgPSBndXR0ZXJBbm5vLnRleHQuam9pbihcXFwiPGJyPlxcXCIpO1xcblxcdCAgICBcXG5cXHQgICAgZWwuYXBwZW5kQ2hpbGQoZG9tLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKTtcXG5cXHQgICAgXFxuXFx0ICAgIHZhciBrYiA9IGZ1bmN0aW9uKF8sIGhhc2hJZCwga2V5U3RyaW5nKSB7XFxuXFx0ICAgICAgICBpZiAoaGFzaElkID09PSAwICYmIChrZXlTdHJpbmcgPT09IFxcXCJlc2NcXFwiIHx8IGtleVN0cmluZyA9PT0gXFxcInJldHVyblxcXCIpKSB7XFxuXFx0ICAgICAgICAgICAgdy5kZXN0cm95KCk7XFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHtjb21tYW5kOiBcXFwibnVsbFxcXCJ9O1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgdy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoZWRpdG9yLiRtb3VzZUhhbmRsZXIuaXNNb3VzZVByZXNzZWQpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcdCAgICAgICAgZWRpdG9yLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKGtiKTtcXG5cXHQgICAgICAgIHNlc3Npb24ud2lkZ2V0TWFuYWdlci5yZW1vdmVMaW5lV2lkZ2V0KHcpO1xcblxcdCAgICAgICAgZWRpdG9yLm9mZihcXFwiY2hhbmdlU2VsZWN0aW9uXFxcIiwgdy5kZXN0cm95KTtcXG5cXHQgICAgICAgIGVkaXRvci5vZmYoXFxcImNoYW5nZVNlc3Npb25cXFwiLCB3LmRlc3Ryb3kpO1xcblxcdCAgICAgICAgZWRpdG9yLm9mZihcXFwibW91c2V1cFxcXCIsIHcuZGVzdHJveSk7XFxuXFx0ICAgICAgICBlZGl0b3Iub2ZmKFxcXCJjaGFuZ2VcXFwiLCB3LmRlc3Ryb3kpO1xcblxcdCAgICB9O1xcblxcdCAgICBcXG5cXHQgICAgZWRpdG9yLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKGtiKTtcXG5cXHQgICAgZWRpdG9yLm9uKFxcXCJjaGFuZ2VTZWxlY3Rpb25cXFwiLCB3LmRlc3Ryb3kpO1xcblxcdCAgICBlZGl0b3Iub24oXFxcImNoYW5nZVNlc3Npb25cXFwiLCB3LmRlc3Ryb3kpO1xcblxcdCAgICBlZGl0b3Iub24oXFxcIm1vdXNldXBcXFwiLCB3LmRlc3Ryb3kpO1xcblxcdCAgICBlZGl0b3Iub24oXFxcImNoYW5nZVxcXCIsIHcuZGVzdHJveSk7XFxuXFx0ICAgIFxcblxcdCAgICBlZGl0b3Iuc2Vzc2lvbi53aWRnZXRNYW5hZ2VyLmFkZExpbmVXaWRnZXQodyk7XFxuXFx0ICAgIFxcblxcdCAgICB3LmVsLm9ubW91c2Vkb3duID0gZWRpdG9yLmZvY3VzLmJpbmQoZWRpdG9yKTtcXG5cXHQgICAgXFxuXFx0ICAgIGVkaXRvci5yZW5kZXJlci5zY3JvbGxDdXJzb3JJbnRvVmlldyhudWxsLCAwLjUsIHtib3R0b206IHcuZWwub2Zmc2V0SGVpZ2h0fSk7XFxuXFx0fTtcXG5cXG5cXG5cXHRkb20uaW1wb3J0Q3NzU3RyaW5nKFxcXCJcXFxcXFxuXFx0ICAgIC5lcnJvcl93aWRnZXRfd3JhcHBlciB7XFxcXFxcblxcdCAgICAgICAgYmFja2dyb3VuZDogaW5oZXJpdDtcXFxcXFxuXFx0ICAgICAgICBjb2xvcjogaW5oZXJpdDtcXFxcXFxuXFx0ICAgICAgICBib3JkZXI6bm9uZVxcXFxcXG5cXHQgICAgfVxcXFxcXG5cXHQgICAgLmVycm9yX3dpZGdldCB7XFxcXFxcblxcdCAgICAgICAgYm9yZGVyLXRvcDogc29saWQgMnB4O1xcXFxcXG5cXHQgICAgICAgIGJvcmRlci1ib3R0b206IHNvbGlkIDJweDtcXFxcXFxuXFx0ICAgICAgICBtYXJnaW46IDVweCAwO1xcXFxcXG5cXHQgICAgICAgIHBhZGRpbmc6IDEwcHggNDBweDtcXFxcXFxuXFx0ICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxcXFxcblxcdCAgICB9XFxcXFxcblxcdCAgICAuZXJyb3Jfd2lkZ2V0LmFjZV9lcnJvciwgLmVycm9yX3dpZGdldF9hcnJvdy5hY2VfZXJyb3J7XFxcXFxcblxcdCAgICAgICAgYm9yZGVyLWNvbG9yOiAjZmY1YTVhXFxcXFxcblxcdCAgICB9XFxcXFxcblxcdCAgICAuZXJyb3Jfd2lkZ2V0LmFjZV93YXJuaW5nLCAuZXJyb3Jfd2lkZ2V0X2Fycm93LmFjZV93YXJuaW5ne1xcXFxcXG5cXHQgICAgICAgIGJvcmRlci1jb2xvcjogI0YxRDgxN1xcXFxcXG5cXHQgICAgfVxcXFxcXG5cXHQgICAgLmVycm9yX3dpZGdldC5hY2VfaW5mbywgLmVycm9yX3dpZGdldF9hcnJvdy5hY2VfaW5mb3tcXFxcXFxuXFx0ICAgICAgICBib3JkZXItY29sb3I6ICM1YTVhNWFcXFxcXFxuXFx0ICAgIH1cXFxcXFxuXFx0ICAgIC5lcnJvcl93aWRnZXQuYWNlX29rLCAuZXJyb3Jfd2lkZ2V0X2Fycm93LmFjZV9va3tcXFxcXFxuXFx0ICAgICAgICBib3JkZXItY29sb3I6ICM1YWFhNWFcXFxcXFxuXFx0ICAgIH1cXFxcXFxuXFx0ICAgIC5lcnJvcl93aWRnZXRfYXJyb3cge1xcXFxcXG5cXHQgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcXFxuXFx0ICAgICAgICBib3JkZXI6IHNvbGlkIDVweDtcXFxcXFxuXFx0ICAgICAgICBib3JkZXItdG9wLWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxcXFxcblxcdCAgICAgICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudCFpbXBvcnRhbnQ7XFxcXFxcblxcdCAgICAgICAgYm9yZGVyLWxlZnQtY29sb3I6IHRyYW5zcGFyZW50IWltcG9ydGFudDtcXFxcXFxuXFx0ICAgICAgICB0b3A6IC01cHg7XFxcXFxcblxcdCAgICB9XFxcXFxcblxcdFxcXCIsIFxcXCJcXFwiKTtcXG5cXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvYWNlXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9maXhvbGRicm93c2Vyc1xcXCIsXFxcImFjZS9saWIvZG9tXFxcIixcXFwiYWNlL2xpYi9ldmVudFxcXCIsXFxcImFjZS9lZGl0b3JcXFwiLFxcXCJhY2UvZWRpdF9zZXNzaW9uXFxcIixcXFwiYWNlL3VuZG9tYW5hZ2VyXFxcIixcXFwiYWNlL3ZpcnR1YWxfcmVuZGVyZXJcXFwiLFxcXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcXFwiLFxcXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXFxcIixcXFwiYWNlL3BsYWNlaG9sZGVyXFxcIixcXFwiYWNlL211bHRpX3NlbGVjdFxcXCIsXFxcImFjZS9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXFxcIixcXFwiYWNlL3RoZW1lL3RleHRtYXRlXFxcIixcXFwiYWNlL2V4dC9lcnJvcl9tYXJrZXJcXFwiLFxcXCJhY2UvY29uZmlnXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0YWNlcXVpcmUoXFxcIi4vbGliL2ZpeG9sZGJyb3dzZXJzXFxcIik7XFxuXFxuXFx0dmFyIGRvbSA9IGFjZXF1aXJlKFxcXCIuL2xpYi9kb21cXFwiKTtcXG5cXHR2YXIgZXZlbnQgPSBhY2VxdWlyZShcXFwiLi9saWIvZXZlbnRcXFwiKTtcXG5cXG5cXHR2YXIgRWRpdG9yID0gYWNlcXVpcmUoXFxcIi4vZWRpdG9yXFxcIikuRWRpdG9yO1xcblxcdHZhciBFZGl0U2Vzc2lvbiA9IGFjZXF1aXJlKFxcXCIuL2VkaXRfc2Vzc2lvblxcXCIpLkVkaXRTZXNzaW9uO1xcblxcdHZhciBVbmRvTWFuYWdlciA9IGFjZXF1aXJlKFxcXCIuL3VuZG9tYW5hZ2VyXFxcIikuVW5kb01hbmFnZXI7XFxuXFx0dmFyIFJlbmRlcmVyID0gYWNlcXVpcmUoXFxcIi4vdmlydHVhbF9yZW5kZXJlclxcXCIpLlZpcnR1YWxSZW5kZXJlcjtcXG5cXHRhY2VxdWlyZShcXFwiLi93b3JrZXIvd29ya2VyX2NsaWVudFxcXCIpO1xcblxcdGFjZXF1aXJlKFxcXCIuL2tleWJvYXJkL2hhc2hfaGFuZGxlclxcXCIpO1xcblxcdGFjZXF1aXJlKFxcXCIuL3BsYWNlaG9sZGVyXFxcIik7XFxuXFx0YWNlcXVpcmUoXFxcIi4vbXVsdGlfc2VsZWN0XFxcIik7XFxuXFx0YWNlcXVpcmUoXFxcIi4vbW9kZS9mb2xkaW5nL2ZvbGRfbW9kZVxcXCIpO1xcblxcdGFjZXF1aXJlKFxcXCIuL3RoZW1lL3RleHRtYXRlXFxcIik7XFxuXFx0YWNlcXVpcmUoXFxcIi4vZXh0L2Vycm9yX21hcmtlclxcXCIpO1xcblxcblxcdGV4cG9ydHMuY29uZmlnID0gYWNlcXVpcmUoXFxcIi4vY29uZmlnXFxcIik7XFxuXFx0ZXhwb3J0cy5hY2VxdWlyZSA9IGFjZXF1aXJlO1xcblxcdGV4cG9ydHMuZWRpdCA9IGZ1bmN0aW9uKGVsKSB7XFxuXFx0ICAgIGlmICh0eXBlb2YoZWwpID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0ICAgICAgICB2YXIgX2lkID0gZWw7XFxuXFx0ICAgICAgICBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF9pZCk7XFxuXFx0ICAgICAgICBpZiAoIWVsKVxcblxcdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiYWNlLmVkaXQgY2FuJ3QgZmluZCBkaXYgI1xcXCIgKyBfaWQpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChlbCAmJiBlbC5lbnYgJiYgZWwuZW52LmVkaXRvciBpbnN0YW5jZW9mIEVkaXRvcilcXG5cXHQgICAgICAgIHJldHVybiBlbC5lbnYuZWRpdG9yO1xcblxcblxcdCAgICB2YXIgdmFsdWUgPSBcXFwiXFxcIjtcXG5cXHQgICAgaWYgKGVsICYmIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZWwudGFnTmFtZSkpIHtcXG5cXHQgICAgICAgIHZhciBvbGROb2RlID0gZWw7XFxuXFx0ICAgICAgICB2YWx1ZSA9IG9sZE5vZGUudmFsdWU7XFxuXFx0ICAgICAgICBlbCA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJwcmVcXFwiKTtcXG5cXHQgICAgICAgIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWwsIG9sZE5vZGUpO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgdmFsdWUgPSBkb20uZ2V0SW5uZXJUZXh0KGVsKTtcXG5cXHQgICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIHZhciBkb2MgPSBleHBvcnRzLmNyZWF0ZUVkaXRTZXNzaW9uKHZhbHVlKTtcXG5cXG5cXHQgICAgdmFyIGVkaXRvciA9IG5ldyBFZGl0b3IobmV3IFJlbmRlcmVyKGVsKSk7XFxuXFx0ICAgIGVkaXRvci5zZXRTZXNzaW9uKGRvYyk7XFxuXFxuXFx0ICAgIHZhciBlbnYgPSB7XFxuXFx0ICAgICAgICBkb2N1bWVudDogZG9jLFxcblxcdCAgICAgICAgZWRpdG9yOiBlZGl0b3IsXFxuXFx0ICAgICAgICBvblJlc2l6ZTogZWRpdG9yLnJlc2l6ZS5iaW5kKGVkaXRvciwgbnVsbClcXG5cXHQgICAgfTtcXG5cXHQgICAgaWYgKG9sZE5vZGUpIGVudi50ZXh0YXJlYSA9IG9sZE5vZGU7XFxuXFx0ICAgIGV2ZW50LmFkZExpc3RlbmVyKHdpbmRvdywgXFxcInJlc2l6ZVxcXCIsIGVudi5vblJlc2l6ZSk7XFxuXFx0ICAgIGVkaXRvci5vbihcXFwiZGVzdHJveVxcXCIsIGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIod2luZG93LCBcXFwicmVzaXplXFxcIiwgZW52Lm9uUmVzaXplKTtcXG5cXHQgICAgICAgIGVudi5lZGl0b3IuY29udGFpbmVyLmVudiA9IG51bGw7IC8vIHByZXZlbnQgbWVtb3J5IGxlYWsgb24gb2xkIGllXFxuXFx0ICAgIH0pO1xcblxcdCAgICBlZGl0b3IuY29udGFpbmVyLmVudiA9IGVkaXRvci5lbnYgPSBlbnY7XFxuXFx0ICAgIHJldHVybiBlZGl0b3I7XFxuXFx0fTtcXG5cXHRleHBvcnRzLmNyZWF0ZUVkaXRTZXNzaW9uID0gZnVuY3Rpb24odGV4dCwgbW9kZSkge1xcblxcdCAgICB2YXIgZG9jID0gbmV3IEVkaXRTZXNzaW9uKHRleHQsIG1vZGUpO1xcblxcdCAgICBkb2Muc2V0VW5kb01hbmFnZXIobmV3IFVuZG9NYW5hZ2VyKCkpO1xcblxcdCAgICByZXR1cm4gZG9jO1xcblxcdH1cXG5cXHRleHBvcnRzLkVkaXRTZXNzaW9uID0gRWRpdFNlc3Npb247XFxuXFx0ZXhwb3J0cy5VbmRvTWFuYWdlciA9IFVuZG9NYW5hZ2VyO1xcblxcdH0pO1xcblxcdCAgICAgICAgICAgIChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICAgICAgYWNlLmFjZXF1aXJlKFtcXFwiYWNlL2FjZVxcXCJdLCBmdW5jdGlvbihhKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBhICYmIGEuY29uZmlnLmluaXQodHJ1ZSk7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5hY2UpXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFjZSA9IGE7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkgaWYgKGEuaGFzT3duUHJvcGVydHkoa2V5KSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWNlW2tleV0gPSBhW2tleV07XFxuXFx0ICAgICAgICAgICAgICAgIH0pO1xcblxcdCAgICAgICAgICAgIH0pKCk7XFxuXFx0ICAgICAgICBcXG5cXHRtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5hY2UuYWNlcXVpcmUoXFxcImFjZS9hY2VcXFwiKTtcXG5cXG4vKioqLyB9LFxcbi8qIDE1ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL21vZGUvanNvbl9oaWdobGlnaHRfcnVsZXNcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9tb2RlL3RleHRfaGlnaGxpZ2h0X3J1bGVzXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIFRleHRIaWdobGlnaHRSdWxlcyA9IGFjZXF1aXJlKFxcXCIuL3RleHRfaGlnaGxpZ2h0X3J1bGVzXFxcIikuVGV4dEhpZ2hsaWdodFJ1bGVzO1xcblxcblxcdHZhciBKc29uSGlnaGxpZ2h0UnVsZXMgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgdGhpcy4kcnVsZXMgPSB7XFxuXFx0ICAgICAgICBcXFwic3RhcnRcXFwiIDogW1xcblxcdCAgICAgICAgICAgIHtcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW4gOiBcXFwidmFyaWFibGVcXFwiLCAvLyBzaW5nbGUgbGluZVxcblxcdCAgICAgICAgICAgICAgICByZWdleCA6ICdbXFxcIl0oPzooPzpcXFxcXFxcXFxcXFxcXFxcLil8KD86W15cXFwiXFxcXFxcXFxcXFxcXFxcXF0pKSo/W1xcXCJdXFxcXFxcXFxzKig/PTopJ1xcblxcdCAgICAgICAgICAgIH0sIHtcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW4gOiBcXFwic3RyaW5nXFxcIiwgLy8gc2luZ2xlIGxpbmVcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiAnXFxcIicsXFxuXFx0ICAgICAgICAgICAgICAgIG5leHQgIDogXFxcInN0cmluZ1xcXCJcXG5cXHQgICAgICAgICAgICB9LCB7XFxuXFx0ICAgICAgICAgICAgICAgIHRva2VuIDogXFxcImNvbnN0YW50Lm51bWVyaWNcXFwiLCAvLyBoZXhcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiBcXFwiMFt4WF1bMC05YS1mQS1GXStcXFxcXFxcXGJcXFwiXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJjb25zdGFudC5udW1lcmljXFxcIiwgLy8gZmxvYXRcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiBcXFwiWystXT9cXFxcXFxcXGQrKD86KD86XFxcXFxcXFwuXFxcXFxcXFxkKik/KD86W2VFXVsrLV0/XFxcXFxcXFxkKyk/KT9cXFxcXFxcXGJcXFwiXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJjb25zdGFudC5sYW5ndWFnZS5ib29sZWFuXFxcIixcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiBcXFwiKD86dHJ1ZXxmYWxzZSlcXFxcXFxcXGJcXFwiXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJpbnZhbGlkLmlsbGVnYWxcXFwiLCAvLyBzaW5nbGUgcXVvdGVkIHN0cmluZ3MgYXJlIG5vdCBhbGxvd2VkXFxuXFx0ICAgICAgICAgICAgICAgIHJlZ2V4IDogXFxcIlsnXSg/Oig/OlxcXFxcXFxcXFxcXFxcXFwuKXwoPzpbXidcXFxcXFxcXFxcXFxcXFxcXSkpKj9bJ11cXFwiXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJpbnZhbGlkLmlsbGVnYWxcXFwiLCAvLyBjb21tZW50cyBhcmUgbm90IGFsbG93ZWRcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiBcXFwiXFxcXFxcXFwvXFxcXFxcXFwvLiokXFxcIlxcblxcdCAgICAgICAgICAgIH0sIHtcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW4gOiBcXFwicGFyZW4ubHBhcmVuXFxcIixcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiBcXFwiW1soe11cXFwiXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJwYXJlbi5ycGFyZW5cXFwiLFxcblxcdCAgICAgICAgICAgICAgICByZWdleCA6IFxcXCJbXFxcXFxcXFxdKX1dXFxcIlxcblxcdCAgICAgICAgICAgIH0sIHtcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW4gOiBcXFwidGV4dFxcXCIsXFxuXFx0ICAgICAgICAgICAgICAgIHJlZ2V4IDogXFxcIlxcXFxcXFxccytcXFwiXFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgXSxcXG5cXHQgICAgICAgIFxcXCJzdHJpbmdcXFwiIDogW1xcblxcdCAgICAgICAgICAgIHtcXG5cXHQgICAgICAgICAgICAgICAgdG9rZW4gOiBcXFwiY29uc3RhbnQubGFuZ3VhZ2UuZXNjYXBlXFxcIixcXG5cXHQgICAgICAgICAgICAgICAgcmVnZXggOiAvXFxcXFxcXFwoPzp4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fFtcXFwiXFxcXFxcXFxcXFxcL2JmbnJ0XSkvXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJzdHJpbmdcXFwiLFxcblxcdCAgICAgICAgICAgICAgICByZWdleCA6ICdbXlxcXCJcXFxcXFxcXFxcXFxcXFxcXSsnXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJzdHJpbmdcXFwiLFxcblxcdCAgICAgICAgICAgICAgICByZWdleCA6ICdcXFwiJyxcXG5cXHQgICAgICAgICAgICAgICAgbmV4dCAgOiBcXFwic3RhcnRcXFwiXFxuXFx0ICAgICAgICAgICAgfSwge1xcblxcdCAgICAgICAgICAgICAgICB0b2tlbiA6IFxcXCJzdHJpbmdcXFwiLFxcblxcdCAgICAgICAgICAgICAgICByZWdleCA6IFxcXCJcXFwiLFxcblxcdCAgICAgICAgICAgICAgICBuZXh0ICA6IFxcXCJzdGFydFxcXCJcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICBdXFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdH07XFxuXFxuXFx0b29wLmluaGVyaXRzKEpzb25IaWdobGlnaHRSdWxlcywgVGV4dEhpZ2hsaWdodFJ1bGVzKTtcXG5cXG5cXHRleHBvcnRzLkpzb25IaWdobGlnaHRSdWxlcyA9IEpzb25IaWdobGlnaHRSdWxlcztcXG5cXHR9KTtcXG5cXG5cXHRhY2UuZGVmaW5lKFxcXCJhY2UvbW9kZS9tYXRjaGluZ19icmFjZV9vdXRkZW50XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL3JhbmdlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4uL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFxuXFx0dmFyIE1hdGNoaW5nQnJhY2VPdXRkZW50ID0gZnVuY3Rpb24oKSB7fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIHRoaXMuY2hlY2tPdXRkZW50ID0gZnVuY3Rpb24obGluZSwgaW5wdXQpIHtcXG5cXHQgICAgICAgIGlmICghIC9eXFxcXHMrJC8udGVzdChsaW5lKSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFxuXFx0ICAgICAgICByZXR1cm4gL15cXFxccypcXFxcfS8udGVzdChpbnB1dCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuYXV0b091dGRlbnQgPSBmdW5jdGlvbihkb2MsIHJvdykge1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSBkb2MuZ2V0TGluZShyb3cpO1xcblxcdCAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaCgvXihcXFxccypcXFxcfSkvKTtcXG5cXG5cXHQgICAgICAgIGlmICghbWF0Y2gpIHJldHVybiAwO1xcblxcblxcdCAgICAgICAgdmFyIGNvbHVtbiA9IG1hdGNoWzFdLmxlbmd0aDtcXG5cXHQgICAgICAgIHZhciBvcGVuQnJhY2VQb3MgPSBkb2MuZmluZE1hdGNoaW5nQnJhY2tldCh7cm93OiByb3csIGNvbHVtbjogY29sdW1ufSk7XFxuXFxuXFx0ICAgICAgICBpZiAoIW9wZW5CcmFjZVBvcyB8fCBvcGVuQnJhY2VQb3Mucm93ID09IHJvdykgcmV0dXJuIDA7XFxuXFxuXFx0ICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy4kZ2V0SW5kZW50KGRvYy5nZXRMaW5lKG9wZW5CcmFjZVBvcy5yb3cpKTtcXG5cXHQgICAgICAgIGRvYy5yZXBsYWNlKG5ldyBSYW5nZShyb3csIDAsIHJvdywgY29sdW1uLTEpLCBpbmRlbnQpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRnZXRJbmRlbnQgPSBmdW5jdGlvbihsaW5lKSB7XFxuXFx0ICAgICAgICByZXR1cm4gbGluZS5tYXRjaCgvXlxcXFxzKi8pWzBdO1xcblxcdCAgICB9O1xcblxcblxcdH0pLmNhbGwoTWF0Y2hpbmdCcmFjZU91dGRlbnQucHJvdG90eXBlKTtcXG5cXG5cXHRleHBvcnRzLk1hdGNoaW5nQnJhY2VPdXRkZW50ID0gTWF0Y2hpbmdCcmFjZU91dGRlbnQ7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL21vZGUvYmVoYXZpb3VyL2NzdHlsZVxcXCIsW1xcXCJyZXF1aXJlXFxcIixcXFwiZXhwb3J0c1xcXCIsXFxcIm1vZHVsZVxcXCIsXFxcImFjZS9saWIvb29wXFxcIixcXFwiYWNlL21vZGUvYmVoYXZpb3VyXFxcIixcXFwiYWNlL3Rva2VuX2l0ZXJhdG9yXFxcIixcXFwiYWNlL2xpYi9sYW5nXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuLi8uLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIEJlaGF2aW91ciA9IGFjZXF1aXJlKFxcXCIuLi9iZWhhdmlvdXJcXFwiKS5CZWhhdmlvdXI7XFxuXFx0dmFyIFRva2VuSXRlcmF0b3IgPSBhY2VxdWlyZShcXFwiLi4vLi4vdG9rZW5faXRlcmF0b3JcXFwiKS5Ub2tlbkl0ZXJhdG9yO1xcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uLy4uL2xpYi9sYW5nXFxcIik7XFxuXFxuXFx0dmFyIFNBRkVfSU5TRVJUX0lOX1RPS0VOUyA9XFxuXFx0ICAgIFtcXFwidGV4dFxcXCIsIFxcXCJwYXJlbi5ycGFyZW5cXFwiLCBcXFwicHVuY3R1YXRpb24ub3BlcmF0b3JcXFwiXTtcXG5cXHR2YXIgU0FGRV9JTlNFUlRfQkVGT1JFX1RPS0VOUyA9XFxuXFx0ICAgIFtcXFwidGV4dFxcXCIsIFxcXCJwYXJlbi5ycGFyZW5cXFwiLCBcXFwicHVuY3R1YXRpb24ub3BlcmF0b3JcXFwiLCBcXFwiY29tbWVudFxcXCJdO1xcblxcblxcdHZhciBjb250ZXh0O1xcblxcdHZhciBjb250ZXh0Q2FjaGUgPSB7fTtcXG5cXHR2YXIgaW5pdENvbnRleHQgPSBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgdmFyIGlkID0gLTE7XFxuXFx0ICAgIGlmIChlZGl0b3IubXVsdGlTZWxlY3QpIHtcXG5cXHQgICAgICAgIGlkID0gZWRpdG9yLnNlbGVjdGlvbi5pbmRleDtcXG5cXHQgICAgICAgIGlmIChjb250ZXh0Q2FjaGUucmFuZ2VDb3VudCAhPSBlZGl0b3IubXVsdGlTZWxlY3QucmFuZ2VDb3VudClcXG5cXHQgICAgICAgICAgICBjb250ZXh0Q2FjaGUgPSB7cmFuZ2VDb3VudDogZWRpdG9yLm11bHRpU2VsZWN0LnJhbmdlQ291bnR9O1xcblxcdCAgICB9XFxuXFx0ICAgIGlmIChjb250ZXh0Q2FjaGVbaWRdKVxcblxcdCAgICAgICAgcmV0dXJuIGNvbnRleHQgPSBjb250ZXh0Q2FjaGVbaWRdO1xcblxcdCAgICBjb250ZXh0ID0gY29udGV4dENhY2hlW2lkXSA9IHtcXG5cXHQgICAgICAgIGF1dG9JbnNlcnRlZEJyYWNrZXRzOiAwLFxcblxcdCAgICAgICAgYXV0b0luc2VydGVkUm93OiAtMSxcXG5cXHQgICAgICAgIGF1dG9JbnNlcnRlZExpbmVFbmQ6IFxcXCJcXFwiLFxcblxcdCAgICAgICAgbWF5YmVJbnNlcnRlZEJyYWNrZXRzOiAwLFxcblxcdCAgICAgICAgbWF5YmVJbnNlcnRlZFJvdzogLTEsXFxuXFx0ICAgICAgICBtYXliZUluc2VydGVkTGluZVN0YXJ0OiBcXFwiXFxcIixcXG5cXHQgICAgICAgIG1heWJlSW5zZXJ0ZWRMaW5lRW5kOiBcXFwiXFxcIlxcblxcdCAgICB9O1xcblxcdH07XFxuXFxuXFx0dmFyIENzdHlsZUJlaGF2aW91ciA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICB0aGlzLmFkZChcXFwiYnJhY2VzXFxcIiwgXFxcImluc2VydGlvblxcXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgdGV4dCkge1xcblxcdCAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgaWYgKHRleHQgPT0gJ3snKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XFxuXFx0ICAgICAgICAgICAgaWYgKHNlbGVjdGVkICE9PSBcXFwiXFxcIiAmJiBzZWxlY3RlZCAhPT0gXFxcIntcXFwiICYmIGVkaXRvci5nZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQoKSkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3snICsgc2VsZWN0ZWQgKyAnfScsXFxuXFx0ICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGZhbHNlXFxuXFx0ICAgICAgICAgICAgICAgIH07XFxuXFx0ICAgICAgICAgICAgfSBlbHNlIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uKGVkaXRvciwgc2Vzc2lvbikpIHtcXG5cXHQgICAgICAgICAgICAgICAgaWYgKC9bXFxcXF1cXFxcfVxcXFwpXS8udGVzdChsaW5lW2N1cnNvci5jb2x1bW5dKSB8fCBlZGl0b3IuaW5NdWx0aVNlbGVjdE1vZGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5yZWNvcmRBdXRvSW5zZXJ0KGVkaXRvciwgc2Vzc2lvbiwgXFxcIn1cXFwiKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3t9JyxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5yZWNvcmRNYXliZUluc2VydChlZGl0b3IsIHNlc3Npb24sIFxcXCJ7XFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd7JyxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0gZWxzZSBpZiAodGV4dCA9PSAnfScpIHtcXG5cXHQgICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xcblxcdCAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XFxuXFx0ICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnfScpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KCd9Jywge2NvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEsIHJvdzogY3Vyc29yLnJvd30pO1xcblxcdCAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmcgIT09IG51bGwgJiYgQ3N0eWxlQmVoYXZpb3VyLmlzQXV0b0luc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUsIHRleHQpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0gZWxzZSBpZiAodGV4dCA9PSBcXFwiXFxcXG5cXFwiIHx8IHRleHQgPT0gXFxcIlxcXFxyXFxcXG5cXFwiKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgY2xvc2luZyA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgICAgIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNNYXliZUluc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNsb3NpbmcgPSBsYW5nLnN0cmluZ1JlcGVhdChcXFwifVxcXCIsIGNvbnRleHQubWF5YmVJbnNlcnRlZEJyYWNrZXRzKTtcXG5cXHQgICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLmNsZWFyTWF5YmVJbnNlcnRlZENsb3NpbmcoKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcXG5cXHQgICAgICAgICAgICBpZiAocmlnaHRDaGFyID09PSAnfScpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5CcmFjZVBvcyA9IHNlc3Npb24uZmluZE1hdGNoaW5nQnJhY2tldCh7cm93OiBjdXJzb3Iucm93LCBjb2x1bW46IGN1cnNvci5jb2x1bW4rMX0sICd9Jyk7XFxuXFx0ICAgICAgICAgICAgICAgIGlmICghb3BlbkJyYWNlUG9zKVxcblxcdCAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbmV4dF9pbmRlbnQgPSB0aGlzLiRnZXRJbmRlbnQoc2Vzc2lvbi5nZXRMaW5lKG9wZW5CcmFjZVBvcy5yb3cpKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NpbmcpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG5leHRfaW5kZW50ID0gdGhpcy4kZ2V0SW5kZW50KGxpbmUpO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5jbGVhck1heWJlSW5zZXJ0ZWRDbG9zaW5nKCk7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybjtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgdmFyIGluZGVudCA9IG5leHRfaW5kZW50ICsgc2Vzc2lvbi5nZXRUYWJTdHJpbmcoKTtcXG5cXG5cXHQgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICB0ZXh0OiAnXFxcXG4nICsgaW5kZW50ICsgJ1xcXFxuJyArIG5leHRfaW5kZW50ICsgY2xvc2luZyxcXG5cXHQgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgaW5kZW50Lmxlbmd0aCwgMSwgaW5kZW50Lmxlbmd0aF1cXG5cXHQgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIuY2xlYXJNYXliZUluc2VydGVkQ2xvc2luZygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy5hZGQoXFxcImJyYWNlc1xcXCIsIFxcXCJkZWxldGlvblxcXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcXG5cXHQgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgc2VsZWN0ZWQgPT0gJ3snKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KTtcXG5cXHQgICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcocmFuZ2UuZW5kLmNvbHVtbiwgcmFuZ2UuZW5kLmNvbHVtbiArIDEpO1xcblxcdCAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gJ30nKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZEJyYWNrZXRzLS07XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy5hZGQoXFxcInBhcmVuc1xcXCIsIFxcXCJpbnNlcnRpb25cXFwiLCBmdW5jdGlvbihzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcXG5cXHQgICAgICAgIGlmICh0ZXh0ID09ICcoJykge1xcblxcdCAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShzZWxlY3Rpb24pO1xcblxcdCAgICAgICAgICAgIGlmIChzZWxlY3RlZCAhPT0gXFxcIlxcXCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnKCcgKyBzZWxlY3RlZCArICcpJyxcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZmFsc2VcXG5cXHQgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKENzdHlsZUJlaGF2aW91ci5pc1NhbmVJbnNlcnRpb24oZWRpdG9yLCBzZXNzaW9uKSkge1xcblxcdCAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFxcXCIpXFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnKCknLFxcblxcdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cXG5cXHQgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHRleHQgPT0gJyknKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XFxuXFx0ICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnKScpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KCcpJywge2NvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEsIHJvdzogY3Vyc29yLnJvd30pO1xcblxcdCAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmcgIT09IG51bGwgJiYgQ3N0eWxlQmVoYXZpb3VyLmlzQXV0b0luc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUsIHRleHQpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSk7XFxuXFxuXFx0ICAgIHRoaXMuYWRkKFxcXCJwYXJlbnNcXFwiLCBcXFwiZGVsZXRpb25cXFwiLCBmdW5jdGlvbihzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHJhbmdlKSB7XFxuXFx0ICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xcblxcdCAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpICYmIHNlbGVjdGVkID09ICcoJykge1xcblxcdCAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XFxuXFx0ICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiArIDEsIHJhbmdlLnN0YXJ0LmNvbHVtbiArIDIpO1xcblxcdCAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gJyknKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSk7XFxuXFxuXFx0ICAgIHRoaXMuYWRkKFxcXCJicmFja2V0c1xcXCIsIFxcXCJpbnNlcnRpb25cXFwiLCBmdW5jdGlvbihzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcXG5cXHQgICAgICAgIGlmICh0ZXh0ID09ICdbJykge1xcblxcdCAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XFxuXFx0ICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShzZWxlY3Rpb24pO1xcblxcdCAgICAgICAgICAgIGlmIChzZWxlY3RlZCAhPT0gXFxcIlxcXCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnWycgKyBzZWxlY3RlZCArICddJyxcXG5cXHQgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZmFsc2VcXG5cXHQgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKENzdHlsZUJlaGF2aW91ci5pc1NhbmVJbnNlcnRpb24oZWRpdG9yLCBzZXNzaW9uKSkge1xcblxcdCAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFxcXCJdXFxcIik7XFxuXFx0ICAgICAgICAgICAgICAgIHJldHVybiB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnW10nLFxcblxcdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cXG5cXHQgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9IGVsc2UgaWYgKHRleHQgPT0gJ10nKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XFxuXFx0ICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XFxuXFx0ICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnXScpIHtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KCddJywge2NvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEsIHJvdzogY3Vyc29yLnJvd30pO1xcblxcdCAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmcgIT09IG51bGwgJiYgQ3N0eWxlQmVoYXZpb3VyLmlzQXV0b0luc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUsIHRleHQpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSk7XFxuXFxuXFx0ICAgIHRoaXMuYWRkKFxcXCJicmFja2V0c1xcXCIsIFxcXCJkZWxldGlvblxcXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcXG5cXHQgICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShyYW5nZSk7XFxuXFx0ICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgc2VsZWN0ZWQgPT0gJ1snKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KTtcXG5cXHQgICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQuY29sdW1uICsgMSwgcmFuZ2Uuc3RhcnQuY29sdW1uICsgMik7XFxuXFx0ICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnXScpIHtcXG5cXHQgICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbisrO1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy5hZGQoXFxcInN0cmluZ19kcXVvdGVzXFxcIiwgXFxcImluc2VydGlvblxcXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgdGV4dCkge1xcblxcdCAgICAgICAgaWYgKHRleHQgPT0gJ1xcXCInIHx8IHRleHQgPT0gXFxcIidcXFwiKSB7XFxuXFx0ICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcXG5cXHQgICAgICAgICAgICB2YXIgcXVvdGUgPSB0ZXh0O1xcblxcdCAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcXG5cXHQgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2Uoc2VsZWN0aW9uKTtcXG5cXHQgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFxcXCJcXFwiICYmIHNlbGVjdGVkICE9PSBcXFwiJ1xcXCIgJiYgc2VsZWN0ZWQgIT0gJ1xcXCInICYmIGVkaXRvci5nZXRXcmFwQmVoYXZpb3Vyc0VuYWJsZWQoKSkge1xcblxcdCAgICAgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdGV4dDogcXVvdGUgKyBzZWxlY3RlZCArIHF1b3RlLFxcblxcdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBmYWxzZVxcblxcdCAgICAgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcXG5cXHQgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgbGVmdENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLTEsIGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICAgICAgICAgICAgICBpZiAobGVmdENoYXIgPT0gJ1xcXFxcXFxcJykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuXFx0ICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHNlc3Npb24uZ2V0VG9rZW5zKHNlbGVjdGlvbi5zdGFydC5yb3cpO1xcblxcdCAgICAgICAgICAgICAgICB2YXIgY29sID0gMCwgdG9rZW47XFxuXFx0ICAgICAgICAgICAgICAgIHZhciBxdW90ZXBvcyA9IC0xOyAvLyBUcmFjayB3aGV0aGVyIHdlJ3JlIGluc2lkZSBhbiBvcGVuIHF1b3RlLlxcblxcblxcdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbeF07XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PSBcXFwic3RyaW5nXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICBxdW90ZXBvcyA9IC0xO1xcblxcdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxdW90ZXBvcyA8IDApIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgcXVvdGVwb3MgPSB0b2tlbi52YWx1ZS5pbmRleE9mKHF1b3RlKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmICgodG9rZW4udmFsdWUubGVuZ3RoICsgY29sKSA+IHNlbGVjdGlvbi5zdGFydC5jb2x1bW4pIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICAgICAgICAgIGNvbCArPSB0b2tlbnNbeF0udmFsdWUubGVuZ3RoO1xcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgICAgIGlmICghdG9rZW4gfHwgKHF1b3RlcG9zIDwgMCAmJiB0b2tlbi50eXBlICE9PSBcXFwiY29tbWVudFxcXCIgJiYgKHRva2VuLnR5cGUgIT09IFxcXCJzdHJpbmdcXFwiIHx8ICgoc2VsZWN0aW9uLnN0YXJ0LmNvbHVtbiAhPT0gdG9rZW4udmFsdWUubGVuZ3RoK2NvbC0xKSAmJiB0b2tlbi52YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHRva2VuLnZhbHVlLmxlbmd0aC0xKSkpKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBpZiAoIUNzdHlsZUJlaGF2aW91ci5pc1NhbmVJbnNlcnRpb24oZWRpdG9yLCBzZXNzaW9uKSlcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuXFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHF1b3RlICsgcXVvdGUsXFxuXFx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwxXVxcblxcdCAgICAgICAgICAgICAgICAgICAgfTtcXG5cXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdCAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gcXVvdGUpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcblxcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cXG5cXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xcblxcdCAgICAgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICB9KTtcXG5cXG5cXHQgICAgdGhpcy5hZGQoXFxcInN0cmluZ19kcXVvdGVzXFxcIiwgXFxcImRlbGV0aW9uXFxcIiwgZnVuY3Rpb24oc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCByYW5nZSkge1xcblxcdCAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKTtcXG5cXHQgICAgICAgIGlmICghcmFuZ2UuaXNNdWx0aUxpbmUoKSAmJiAoc2VsZWN0ZWQgPT0gJ1xcXCInIHx8IHNlbGVjdGVkID09IFxcXCInXFxcIikpIHtcXG5cXHQgICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xcblxcdCAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xcblxcdCAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4gKyAxLCByYW5nZS5zdGFydC5jb2x1bW4gKyAyKTtcXG5cXHQgICAgICAgICAgICBpZiAocmlnaHRDaGFyID09IHNlbGVjdGVkKSB7XFxuXFx0ICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSk7XFxuXFxuXFx0fTtcXG5cXG5cXHQgICAgXFxuXFx0Q3N0eWxlQmVoYXZpb3VyLmlzU2FuZUluc2VydGlvbiA9IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbikge1xcblxcdCAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XFxuXFx0ICAgIHZhciBpdGVyYXRvciA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICBpZiAoIXRoaXMuJG1hdGNoVG9rZW5UeXBlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpIHx8IFxcXCJ0ZXh0XFxcIiwgU0FGRV9JTlNFUlRfSU5fVE9LRU5TKSkge1xcblxcdCAgICAgICAgdmFyIGl0ZXJhdG9yMiA9IG5ldyBUb2tlbkl0ZXJhdG9yKHNlc3Npb24sIGN1cnNvci5yb3csIGN1cnNvci5jb2x1bW4gKyAxKTtcXG5cXHQgICAgICAgIGlmICghdGhpcy4kbWF0Y2hUb2tlblR5cGUoaXRlcmF0b3IyLmdldEN1cnJlbnRUb2tlbigpIHx8IFxcXCJ0ZXh0XFxcIiwgU0FGRV9JTlNFUlRfSU5fVE9LRU5TKSlcXG5cXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH1cXG5cXHQgICAgaXRlcmF0b3Iuc3RlcEZvcndhcmQoKTtcXG5cXHQgICAgcmV0dXJuIGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlblJvdygpICE9PSBjdXJzb3Iucm93IHx8XFxuXFx0ICAgICAgICB0aGlzLiRtYXRjaFRva2VuVHlwZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKSB8fCBcXFwidGV4dFxcXCIsIFNBRkVfSU5TRVJUX0JFRk9SRV9UT0tFTlMpO1xcblxcdH07XFxuXFxuXFx0Q3N0eWxlQmVoYXZpb3VyLiRtYXRjaFRva2VuVHlwZSA9IGZ1bmN0aW9uKHRva2VuLCB0eXBlcykge1xcblxcdCAgICByZXR1cm4gdHlwZXMuaW5kZXhPZih0b2tlbi50eXBlIHx8IHRva2VuKSA+IC0xO1xcblxcdH07XFxuXFxuXFx0Q3N0eWxlQmVoYXZpb3VyLnJlY29yZEF1dG9JbnNlcnQgPSBmdW5jdGlvbihlZGl0b3IsIHNlc3Npb24sIGJyYWNrZXQpIHtcXG5cXHQgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xcblxcdCAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XFxuXFx0ICAgIGlmICghdGhpcy5pc0F1dG9JbnNlcnRlZENsb3NpbmcoY3Vyc29yLCBsaW5lLCBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmRbMF0pKVxcblxcdCAgICAgICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cyA9IDA7XFxuXFx0ICAgIGNvbnRleHQuYXV0b0luc2VydGVkUm93ID0gY3Vyc29yLnJvdztcXG5cXHQgICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kID0gYnJhY2tldCArIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICBjb250ZXh0LmF1dG9JbnNlcnRlZEJyYWNrZXRzKys7XFxuXFx0fTtcXG5cXG5cXHRDc3R5bGVCZWhhdmlvdXIucmVjb3JkTWF5YmVJbnNlcnQgPSBmdW5jdGlvbihlZGl0b3IsIHNlc3Npb24sIGJyYWNrZXQpIHtcXG5cXHQgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xcblxcdCAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XFxuXFx0ICAgIGlmICghdGhpcy5pc01heWJlSW5zZXJ0ZWRDbG9zaW5nKGN1cnNvciwgbGluZSkpXFxuXFx0ICAgICAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cyA9IDA7XFxuXFx0ICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZFJvdyA9IGN1cnNvci5yb3c7XFxuXFx0ICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZExpbmVTdGFydCA9IGxpbmUuc3Vic3RyKDAsIGN1cnNvci5jb2x1bW4pICsgYnJhY2tldDtcXG5cXHQgICAgY29udGV4dC5tYXliZUluc2VydGVkTGluZUVuZCA9IGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pO1xcblxcdCAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cysrO1xcblxcdH07XFxuXFxuXFx0Q3N0eWxlQmVoYXZpb3VyLmlzQXV0b0luc2VydGVkQ2xvc2luZyA9IGZ1bmN0aW9uKGN1cnNvciwgbGluZSwgYnJhY2tldCkge1xcblxcdCAgICByZXR1cm4gY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cyA+IDAgJiZcXG5cXHQgICAgICAgIGN1cnNvci5yb3cgPT09IGNvbnRleHQuYXV0b0luc2VydGVkUm93ICYmXFxuXFx0ICAgICAgICBicmFja2V0ID09PSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmRbMF0gJiZcXG5cXHQgICAgICAgIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pID09PSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQ7XFxuXFx0fTtcXG5cXG5cXHRDc3R5bGVCZWhhdmlvdXIuaXNNYXliZUluc2VydGVkQ2xvc2luZyA9IGZ1bmN0aW9uKGN1cnNvciwgbGluZSkge1xcblxcdCAgICByZXR1cm4gY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMgPiAwICYmXFxuXFx0ICAgICAgICBjdXJzb3Iucm93ID09PSBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRSb3cgJiZcXG5cXHQgICAgICAgIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pID09PSBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lRW5kICYmXFxuXFx0ICAgICAgICBsaW5lLnN1YnN0cigwLCBjdXJzb3IuY29sdW1uKSA9PSBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lU3RhcnQ7XFxuXFx0fTtcXG5cXG5cXHRDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQgPSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQuc3Vic3RyKDEpO1xcblxcdCAgICBjb250ZXh0LmF1dG9JbnNlcnRlZEJyYWNrZXRzLS07XFxuXFx0fTtcXG5cXG5cXHRDc3R5bGVCZWhhdmlvdXIuY2xlYXJNYXliZUluc2VydGVkQ2xvc2luZyA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICBpZiAoY29udGV4dCkge1xcblxcdCAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMgPSAwO1xcblxcdCAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkUm93ID0gLTE7XFxuXFx0ICAgIH1cXG5cXHR9O1xcblxcblxcblxcblxcdG9vcC5pbmhlcml0cyhDc3R5bGVCZWhhdmlvdXIsIEJlaGF2aW91cik7XFxuXFxuXFx0ZXhwb3J0cy5Dc3R5bGVCZWhhdmlvdXIgPSBDc3R5bGVCZWhhdmlvdXI7XFxuXFx0fSk7XFxuXFxuXFx0YWNlLmRlZmluZShcXFwiYWNlL21vZGUvZm9sZGluZy9jc3R5bGVcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9yYW5nZVxcXCIsXFxcImFjZS9tb2RlL2ZvbGRpbmcvZm9sZF9tb2RlXFxcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0dmFyIG9vcCA9IGFjZXF1aXJlKFxcXCIuLi8uLi9saWIvb29wXFxcIik7XFxuXFx0dmFyIFJhbmdlID0gYWNlcXVpcmUoXFxcIi4uLy4uL3JhbmdlXFxcIikuUmFuZ2U7XFxuXFx0dmFyIEJhc2VGb2xkTW9kZSA9IGFjZXF1aXJlKFxcXCIuL2ZvbGRfbW9kZVxcXCIpLkZvbGRNb2RlO1xcblxcblxcdHZhciBGb2xkTW9kZSA9IGV4cG9ydHMuRm9sZE1vZGUgPSBmdW5jdGlvbihjb21tZW50UmVnZXgpIHtcXG5cXHQgICAgaWYgKGNvbW1lbnRSZWdleCkge1xcblxcdCAgICAgICAgdGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIgPSBuZXcgUmVnRXhwKFxcblxcdCAgICAgICAgICAgIHRoaXMuZm9sZGluZ1N0YXJ0TWFya2VyLnNvdXJjZS5yZXBsYWNlKC9cXFxcfFtefF0qPyQvLCBcXFwifFxcXCIgKyBjb21tZW50UmVnZXguc3RhcnQpXFxuXFx0ICAgICAgICApO1xcblxcdCAgICAgICAgdGhpcy5mb2xkaW5nU3RvcE1hcmtlciA9IG5ldyBSZWdFeHAoXFxuXFx0ICAgICAgICAgICAgdGhpcy5mb2xkaW5nU3RvcE1hcmtlci5zb3VyY2UucmVwbGFjZSgvXFxcXHxbXnxdKj8kLywgXFxcInxcXFwiICsgY29tbWVudFJlZ2V4LmVuZClcXG5cXHQgICAgICAgICk7XFxuXFx0ICAgIH1cXG5cXHR9O1xcblxcdG9vcC5pbmhlcml0cyhGb2xkTW9kZSwgQmFzZUZvbGRNb2RlKTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFxuXFx0ICAgIHRoaXMuZm9sZGluZ1N0YXJ0TWFya2VyID0gLyhcXFxce3xcXFxcWylbXlxcXFx9XFxcXF1dKiR8XlxcXFxzKihcXFxcL1xcXFwqKS87XFxuXFx0ICAgIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIgPSAvXlteXFxcXFtcXFxce10qKFxcXFx9fFxcXFxdKXxeW1xcXFxzXFxcXCpdKihcXFxcKlxcXFwvKS87XFxuXFxuXFx0ICAgIHRoaXMuZ2V0Rm9sZFdpZGdldFJhbmdlID0gZnVuY3Rpb24oc2Vzc2lvbiwgZm9sZFN0eWxlLCByb3csIGZvcmNlTXVsdGlsaW5lKSB7XFxuXFx0ICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpO1xcblxcdCAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmZvbGRpbmdTdGFydE1hcmtlcik7XFxuXFx0ICAgICAgICBpZiAobWF0Y2gpIHtcXG5cXHQgICAgICAgICAgICB2YXIgaSA9IG1hdGNoLmluZGV4O1xcblxcblxcdCAgICAgICAgICAgIGlmIChtYXRjaFsxXSlcXG5cXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbmluZ0JyYWNrZXRCbG9jayhzZXNzaW9uLCBtYXRjaFsxXSwgcm93LCBpKTtcXG5cXHQgICAgICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgdmFyIHJhbmdlID0gc2Vzc2lvbi5nZXRDb21tZW50Rm9sZFJhbmdlKHJvdywgaSArIG1hdGNoWzBdLmxlbmd0aCwgMSk7XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgaWYgKHJhbmdlICYmICFyYW5nZS5pc011bHRpTGluZSgpKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChmb3JjZU11bHRpbGluZSkge1xcblxcdCAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFNlY3Rpb25SYW5nZShzZXNzaW9uLCByb3cpO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvbGRTdHlsZSAhPSBcXFwiYWxsXFxcIilcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbnVsbDtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgaWYgKGZvbGRTdHlsZSA9PT0gXFxcIm1hcmtiZWdpblxcXCIpXFxuXFx0ICAgICAgICAgICAgcmV0dXJuO1xcblxcblxcdCAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmZvbGRpbmdTdG9wTWFya2VyKTtcXG5cXHQgICAgICAgIGlmIChtYXRjaCkge1xcblxcdCAgICAgICAgICAgIHZhciBpID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XFxuXFxuXFx0ICAgICAgICAgICAgaWYgKG1hdGNoWzFdKVxcblxcdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zaW5nQnJhY2tldEJsb2NrKHNlc3Npb24sIG1hdGNoWzFdLCByb3csIGkpO1xcblxcblxcdCAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLmdldENvbW1lbnRGb2xkUmFuZ2Uocm93LCBpLCAtMSk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIFxcblxcdCAgICB0aGlzLmdldFNlY3Rpb25SYW5nZSA9IGZ1bmN0aW9uKHNlc3Npb24sIHJvdykge1xcblxcdCAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KTtcXG5cXHQgICAgICAgIHZhciBzdGFydEluZGVudCA9IGxpbmUuc2VhcmNoKC9cXFxcUy8pO1xcblxcdCAgICAgICAgdmFyIHN0YXJ0Um93ID0gcm93O1xcblxcdCAgICAgICAgdmFyIHN0YXJ0Q29sdW1uID0gbGluZS5sZW5ndGg7XFxuXFx0ICAgICAgICByb3cgPSByb3cgKyAxO1xcblxcdCAgICAgICAgdmFyIGVuZFJvdyA9IHJvdztcXG5cXHQgICAgICAgIHZhciBtYXhSb3cgPSBzZXNzaW9uLmdldExlbmd0aCgpO1xcblxcdCAgICAgICAgd2hpbGUgKCsrcm93IDwgbWF4Um93KSB7XFxuXFx0ICAgICAgICAgICAgbGluZSA9IHNlc3Npb24uZ2V0TGluZShyb3cpO1xcblxcdCAgICAgICAgICAgIHZhciBpbmRlbnQgPSBsaW5lLnNlYXJjaCgvXFxcXFMvKTtcXG5cXHQgICAgICAgICAgICBpZiAoaW5kZW50ID09PSAtMSlcXG5cXHQgICAgICAgICAgICAgICAgY29udGludWU7XFxuXFx0ICAgICAgICAgICAgaWYgIChzdGFydEluZGVudCA+IGluZGVudClcXG5cXHQgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgICAgICAgdmFyIHN1YlJhbmdlID0gdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2Uoc2Vzc2lvbiwgXFxcImFsbFxcXCIsIHJvdyk7XFxuXFx0ICAgICAgICAgICAgXFxuXFx0ICAgICAgICAgICAgaWYgKHN1YlJhbmdlKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGlmIChzdWJSYW5nZS5zdGFydC5yb3cgPD0gc3RhcnRSb3cpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1YlJhbmdlLmlzTXVsdGlMaW5lKCkpIHtcXG5cXHQgICAgICAgICAgICAgICAgICAgIHJvdyA9IHN1YlJhbmdlLmVuZC5yb3c7XFxuXFx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbmRlbnQgPT0gaW5kZW50KSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXHQgICAgICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgICAgICBlbmRSb3cgPSByb3c7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgICBcXG5cXHQgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBlbmRSb3csIHNlc3Npb24uZ2V0TGluZShlbmRSb3cpLmxlbmd0aCk7XFxuXFx0ICAgIH07XFxuXFxuXFx0fSkuY2FsbChGb2xkTW9kZS5wcm90b3R5cGUpO1xcblxcblxcdH0pO1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9tb2RlL2pzb25cXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9tb2RlL3RleHRcXFwiLFxcXCJhY2UvbW9kZS9qc29uX2hpZ2hsaWdodF9ydWxlc1xcXCIsXFxcImFjZS9tb2RlL21hdGNoaW5nX2JyYWNlX291dGRlbnRcXFwiLFxcXCJhY2UvbW9kZS9iZWhhdmlvdXIvY3N0eWxlXFxcIixcXFwiYWNlL21vZGUvZm9sZGluZy9jc3R5bGVcXFwiLFxcXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcXFwiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHR2YXIgb29wID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9vb3BcXFwiKTtcXG5cXHR2YXIgVGV4dE1vZGUgPSBhY2VxdWlyZShcXFwiLi90ZXh0XFxcIikuTW9kZTtcXG5cXHR2YXIgSGlnaGxpZ2h0UnVsZXMgPSBhY2VxdWlyZShcXFwiLi9qc29uX2hpZ2hsaWdodF9ydWxlc1xcXCIpLkpzb25IaWdobGlnaHRSdWxlcztcXG5cXHR2YXIgTWF0Y2hpbmdCcmFjZU91dGRlbnQgPSBhY2VxdWlyZShcXFwiLi9tYXRjaGluZ19icmFjZV9vdXRkZW50XFxcIikuTWF0Y2hpbmdCcmFjZU91dGRlbnQ7XFxuXFx0dmFyIENzdHlsZUJlaGF2aW91ciA9IGFjZXF1aXJlKFxcXCIuL2JlaGF2aW91ci9jc3R5bGVcXFwiKS5Dc3R5bGVCZWhhdmlvdXI7XFxuXFx0dmFyIENTdHlsZUZvbGRNb2RlID0gYWNlcXVpcmUoXFxcIi4vZm9sZGluZy9jc3R5bGVcXFwiKS5Gb2xkTW9kZTtcXG5cXHR2YXIgV29ya2VyQ2xpZW50ID0gYWNlcXVpcmUoXFxcIi4uL3dvcmtlci93b3JrZXJfY2xpZW50XFxcIikuV29ya2VyQ2xpZW50O1xcblxcblxcdHZhciBNb2RlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuSGlnaGxpZ2h0UnVsZXMgPSBIaWdobGlnaHRSdWxlcztcXG5cXHQgICAgdGhpcy4kb3V0ZGVudCA9IG5ldyBNYXRjaGluZ0JyYWNlT3V0ZGVudCgpO1xcblxcdCAgICB0aGlzLiRiZWhhdmlvdXIgPSBuZXcgQ3N0eWxlQmVoYXZpb3VyKCk7XFxuXFx0ICAgIHRoaXMuZm9sZGluZ1J1bGVzID0gbmV3IENTdHlsZUZvbGRNb2RlKCk7XFxuXFx0fTtcXG5cXHRvb3AuaW5oZXJpdHMoTW9kZSwgVGV4dE1vZGUpO1xcblxcblxcdChmdW5jdGlvbigpIHtcXG5cXG5cXHQgICAgdGhpcy5nZXROZXh0TGluZUluZGVudCA9IGZ1bmN0aW9uKHN0YXRlLCBsaW5lLCB0YWIpIHtcXG5cXHQgICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLiRnZXRJbmRlbnQobGluZSk7XFxuXFxuXFx0ICAgICAgICBpZiAoc3RhdGUgPT0gXFxcInN0YXJ0XFxcIikge1xcblxcdCAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2goL14uKltcXFxce1xcXFwoXFxcXFtdXFxcXHMqJC8pO1xcblxcdCAgICAgICAgICAgIGlmIChtYXRjaCkge1xcblxcdCAgICAgICAgICAgICAgICBpbmRlbnQgKz0gdGFiO1xcblxcdCAgICAgICAgICAgIH1cXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHJldHVybiBpbmRlbnQ7XFxuXFx0ICAgIH07XFxuXFxuXFx0ICAgIHRoaXMuY2hlY2tPdXRkZW50ID0gZnVuY3Rpb24oc3RhdGUsIGxpbmUsIGlucHV0KSB7XFxuXFx0ICAgICAgICByZXR1cm4gdGhpcy4kb3V0ZGVudC5jaGVja091dGRlbnQobGluZSwgaW5wdXQpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmF1dG9PdXRkZW50ID0gZnVuY3Rpb24oc3RhdGUsIGRvYywgcm93KSB7XFxuXFx0ICAgICAgICB0aGlzLiRvdXRkZW50LmF1dG9PdXRkZW50KGRvYywgcm93KTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbihzZXNzaW9uKSB7XFxuXFx0ICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlckNsaWVudChbXFxcImFjZVxcXCJdLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSwgXFxcIkpzb25Xb3JrZXJcXFwiKTtcXG5cXHQgICAgICAgIHdvcmtlci5hdHRhY2hUb0RvY3VtZW50KHNlc3Npb24uZ2V0RG9jdW1lbnQoKSk7XFxuXFxuXFx0ICAgICAgICB3b3JrZXIub24oXFxcImVycm9yXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIHNlc3Npb24uc2V0QW5ub3RhdGlvbnMoW2UuZGF0YV0pO1xcblxcdCAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICB3b3JrZXIub24oXFxcIm9rXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgc2Vzc2lvbi5jbGVhckFubm90YXRpb25zKCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIHJldHVybiB3b3JrZXI7XFxuXFx0ICAgIH07XFxuXFxuXFxuXFx0ICAgIHRoaXMuJGlkID0gXFxcImFjZS9tb2RlL2pzb25cXFwiO1xcblxcdH0pLmNhbGwoTW9kZS5wcm90b3R5cGUpO1xcblxcblxcdGV4cG9ydHMuTW9kZSA9IE1vZGU7XFxuXFx0fSk7XFxuXFxuXFxuLyoqKi8gfSxcXG4vKiAxNiAqL1xcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdGFjZS5kZWZpbmUoXFxcImFjZS9leHQvc2VhcmNoYm94XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9kb21cXFwiLFxcXCJhY2UvbGliL2xhbmdcXFwiLFxcXCJhY2UvbGliL2V2ZW50XFxcIixcXFwiYWNlL2tleWJvYXJkL2hhc2hfaGFuZGxlclxcXCIsXFxcImFjZS9saWIva2V5c1xcXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdHZhciBkb20gPSBhY2VxdWlyZShcXFwiLi4vbGliL2RvbVxcXCIpO1xcblxcdHZhciBsYW5nID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9sYW5nXFxcIik7XFxuXFx0dmFyIGV2ZW50ID0gYWNlcXVpcmUoXFxcIi4uL2xpYi9ldmVudFxcXCIpO1xcblxcdHZhciBzZWFyY2hib3hDc3MgPSBcXFwiXFxcXFxcblxcdC5hY2Vfc2VhcmNoIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2RkZDtcXFxcXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgI2NiY2JjYjtcXFxcXFxuXFx0Ym9yZGVyLXRvcDogMCBub25lO1xcXFxcXG5cXHRtYXgtd2lkdGg6IDMyNXB4O1xcXFxcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcXFxcXG5cXHRtYXJnaW46IDA7XFxcXFxcblxcdHBhZGRpbmc6IDRweDtcXFxcXFxuXFx0cGFkZGluZy1yaWdodDogNnB4O1xcXFxcXG5cXHRwYWRkaW5nLWJvdHRvbTogMDtcXFxcXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcXFxcXG5cXHR0b3A6IDBweDtcXFxcXFxuXFx0ei1pbmRleDogOTk7XFxcXFxcblxcdHdoaXRlLXNwYWNlOiBub3JtYWw7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9zZWFyY2gubGVmdCB7XFxcXFxcblxcdGJvcmRlci1sZWZ0OiAwIG5vbmU7XFxcXFxcblxcdGJvcmRlci1yYWRpdXM6IDBweCAwcHggNXB4IDBweDtcXFxcXFxuXFx0bGVmdDogMDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3NlYXJjaC5yaWdodCB7XFxcXFxcblxcdGJvcmRlci1yYWRpdXM6IDBweCAwcHggMHB4IDVweDtcXFxcXFxuXFx0Ym9yZGVyLXJpZ2h0OiAwIG5vbmU7XFxcXFxcblxcdHJpZ2h0OiAwO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoX2Zvcm0sIC5hY2VfcmVwbGFjZV9mb3JtIHtcXFxcXFxuXFx0Ym9yZGVyLXJhZGl1czogM3B4O1xcXFxcXG5cXHRib3JkZXI6IDFweCBzb2xpZCAjY2JjYmNiO1xcXFxcXG5cXHRmbG9hdDogbGVmdDtcXFxcXFxuXFx0bWFyZ2luLWJvdHRvbTogNHB4O1xcXFxcXG5cXHRvdmVyZmxvdzogaGlkZGVuO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoX2Zvcm0uYWNlX25vbWF0Y2gge1xcXFxcXG5cXHRvdXRsaW5lOiAxcHggc29saWQgcmVkO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoX2ZpZWxkIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxcXFxcblxcdGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNjYmNiY2I7XFxcXFxcblxcdGJvcmRlcjogMCBub25lO1xcXFxcXG5cXHQtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcXFxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0ZmxvYXQ6IGxlZnQ7XFxcXFxcblxcdGhlaWdodDogMjJweDtcXFxcXFxuXFx0b3V0bGluZTogMDtcXFxcXFxuXFx0cGFkZGluZzogMCA3cHg7XFxcXFxcblxcdHdpZHRoOiAyMTRweDtcXFxcXFxuXFx0bWFyZ2luOiAwO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoYnRuLFxcXFxcXG5cXHQuYWNlX3JlcGxhY2VidG4ge1xcXFxcXG5cXHRiYWNrZ3JvdW5kOiAjZmZmO1xcXFxcXG5cXHRib3JkZXI6IDAgbm9uZTtcXFxcXFxuXFx0Ym9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZGNkY2RjO1xcXFxcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxcXFxcblxcdGZsb2F0OiBsZWZ0O1xcXFxcXG5cXHRoZWlnaHQ6IDIycHg7XFxcXFxcblxcdG1hcmdpbjogMDtcXFxcXFxuXFx0cGFkZGluZzogMDtcXFxcXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoYnRuOmxhc3QtY2hpbGQsXFxcXFxcblxcdC5hY2VfcmVwbGFjZWJ0bjpsYXN0LWNoaWxkIHtcXFxcXFxuXFx0Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDNweDtcXFxcXFxuXFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDNweDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3NlYXJjaGJ0bjpkaXNhYmxlZCB7XFxcXFxcblxcdGJhY2tncm91bmQ6IG5vbmU7XFxcXFxcblxcdGN1cnNvcjogZGVmYXVsdDtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3NlYXJjaGJ0biB7XFxcXFxcblxcdGJhY2tncm91bmQtcG9zaXRpb246IDUwJSA1MCU7XFxcXFxcblxcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxcXFxcblxcdHdpZHRoOiAyN3B4O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoYnRuLnByZXYge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBZ0FBQUFGQ0FZQUFBQjRrYTFWQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFERkpSRUZVZU5waVNVMU5aVUFDLzZFMEkweUFDWXNrQ3BzSml5U0tJaVkwU1VaazQwRnlURWdDakdnS3dUUkFnQUVBUUpVSVBDRStxZmtBQUFBQVNVVk9SSzVDWUlJPSk7ICAgIFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoYnRuLm5leHQge1xcXFxcXG5cXHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBZ0FBQUFGQ0FZQUFBQjRrYTFWQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFEUkpSRUZVZU5waVRFMU5aUUNDLzBETXlJQUt3R0pNVUFZREVvM00vcytFcHZNL21rS3dDUXhZakllTE1hRUxvTE1CQWd3QVU3VUpPYlRLc3ZBQUFBQUFTVVZPUks1Q1lJST0pOyAgICBcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3NlYXJjaGJ0bl9jbG9zZSB7XFxcXFxcblxcdGJhY2tncm91bmQ6IHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQWNDQVlBQUFCUlZvNUJBQUFBWjBsRVFWUjQydTJTVVFyQU1BaER2YXpuOE9qWkJpbENrWVZWeGlpczhINENUMFZyQUpiNFdIVDNDNXhVMmEySVFaWEpqaVFJUk1ka0VvSjVRMnlNcXBmRElvK1hZNGs2aCtZWE95S3FUSWo1UkVheGxvTkFkMHhpS21BdHNUSHFXOHNSMlc1ZjdnQ3U1bldGVXBWalp3QUFBQUJKUlU1RXJrSmdnZz09KSBuby1yZXBlYXQgNTAlIDA7XFxcXFxcblxcdGJvcmRlci1yYWRpdXM6IDUwJTtcXFxcXFxuXFx0Ym9yZGVyOiAwIG5vbmU7XFxcXFxcblxcdGNvbG9yOiAjNjU2NTY1O1xcXFxcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxcXFxcblxcdGZsb2F0OiByaWdodDtcXFxcXFxuXFx0Zm9udDogMTZweC8xNnB4IEFyaWFsO1xcXFxcXG5cXHRoZWlnaHQ6IDE0cHg7XFxcXFxcblxcdG1hcmdpbjogNXB4IDFweCA5cHggNXB4O1xcXFxcXG5cXHRwYWRkaW5nOiAwO1xcXFxcXG5cXHR0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXFxcblxcdHdpZHRoOiAxNHB4O1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoYnRuX2Nsb3NlOmhvdmVyIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogIzY1NjU2NTtcXFxcXFxuXFx0YmFja2dyb3VuZC1wb3NpdGlvbjogNTAlIDEwMCU7XFxcXFxcblxcdGNvbG9yOiB3aGl0ZTtcXFxcXFxuXFx0fVxcXFxcXG5cXHQuYWNlX3JlcGxhY2VidG4ucHJldiB7XFxcXFxcblxcdHdpZHRoOiA1NHB4XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9yZXBsYWNlYnRuLm5leHQge1xcXFxcXG5cXHR3aWR0aDogMjdweFxcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfYnV0dG9uIHtcXFxcXFxuXFx0bWFyZ2luLWxlZnQ6IDJweDtcXFxcXFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcXFxcXG5cXHQtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcXFxcXG5cXHQtbW96LXVzZXItc2VsZWN0OiBub25lO1xcXFxcXG5cXHQtby11c2VyLXNlbGVjdDogbm9uZTtcXFxcXFxuXFx0LW1zLXVzZXItc2VsZWN0OiBub25lO1xcXFxcXG5cXHR1c2VyLXNlbGVjdDogbm9uZTtcXFxcXFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXFxcXFxuXFx0b3BhY2l0eTogMC43O1xcXFxcXG5cXHRib3JkZXI6IDFweCBzb2xpZCByZ2JhKDEwMCwxMDAsMTAwLDAuMjMpO1xcXFxcXG5cXHRwYWRkaW5nOiAxcHg7XFxcXFxcblxcdC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDtcXFxcXFxuXFx0Ym94LXNpemluZzogICAgYm9yZGVyLWJveDtcXFxcXFxuXFx0Y29sb3I6IGJsYWNrO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfYnV0dG9uOmhvdmVyIHtcXFxcXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXFxcXFxuXFx0b3BhY2l0eToxO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2VfYnV0dG9uOmFjdGl2ZSB7XFxcXFxcblxcdGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxcXFxcblxcdH1cXFxcXFxuXFx0LmFjZV9idXR0b24uY2hlY2tlZCB7XFxcXFxcblxcdGJvcmRlci1jb2xvcjogIzMzOTlmZjtcXFxcXFxuXFx0b3BhY2l0eToxO1xcXFxcXG5cXHR9XFxcXFxcblxcdC5hY2Vfc2VhcmNoX29wdGlvbnN7XFxcXFxcblxcdG1hcmdpbi1ib3R0b206IDNweDtcXFxcXFxuXFx0dGV4dC1hbGlnbjogcmlnaHQ7XFxcXFxcblxcdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdC1vLXVzZXItc2VsZWN0OiBub25lO1xcXFxcXG5cXHQtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXFxcblxcdHVzZXItc2VsZWN0OiBub25lO1xcXFxcXG5cXHR9XFxcIjtcXG5cXHR2YXIgSGFzaEhhbmRsZXIgPSBhY2VxdWlyZShcXFwiLi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXFxcIikuSGFzaEhhbmRsZXI7XFxuXFx0dmFyIGtleVV0aWwgPSBhY2VxdWlyZShcXFwiLi4vbGliL2tleXNcXFwiKTtcXG5cXG5cXHRkb20uaW1wb3J0Q3NzU3RyaW5nKHNlYXJjaGJveENzcywgXFxcImFjZV9zZWFyY2hib3hcXFwiKTtcXG5cXG5cXHR2YXIgaHRtbCA9ICc8ZGl2IGNsYXNzPVxcXCJhY2Vfc2VhcmNoIHJpZ2h0XFxcIj5cXFxcXFxuXFx0ICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBhY3Rpb249XFxcImhpZGVcXFwiIGNsYXNzPVxcXCJhY2Vfc2VhcmNoYnRuX2Nsb3NlXFxcIj48L2J1dHRvbj5cXFxcXFxuXFx0ICAgIDxkaXYgY2xhc3M9XFxcImFjZV9zZWFyY2hfZm9ybVxcXCI+XFxcXFxcblxcdCAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJhY2Vfc2VhcmNoX2ZpZWxkXFxcIiBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoIGZvclxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPjwvaW5wdXQ+XFxcXFxcblxcdCAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGFjdGlvbj1cXFwiZmluZE5leHRcXFwiIGNsYXNzPVxcXCJhY2Vfc2VhcmNoYnRuIG5leHRcXFwiPjwvYnV0dG9uPlxcXFxcXG5cXHQgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBhY3Rpb249XFxcImZpbmRQcmV2XFxcIiBjbGFzcz1cXFwiYWNlX3NlYXJjaGJ0biBwcmV2XFxcIj48L2J1dHRvbj5cXFxcXFxuXFx0ICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgYWN0aW9uPVxcXCJmaW5kQWxsXFxcIiBjbGFzcz1cXFwiYWNlX3NlYXJjaGJ0blxcXCIgdGl0bGU9XFxcIkFsdC1FbnRlclxcXCI+QWxsPC9idXR0b24+XFxcXFxcblxcdCAgICA8L2Rpdj5cXFxcXFxuXFx0ICAgIDxkaXYgY2xhc3M9XFxcImFjZV9yZXBsYWNlX2Zvcm1cXFwiPlxcXFxcXG5cXHQgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiYWNlX3NlYXJjaF9maWVsZFxcXCIgcGxhY2Vob2xkZXI9XFxcIlJlcGxhY2Ugd2l0aFxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPjwvaW5wdXQ+XFxcXFxcblxcdCAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGFjdGlvbj1cXFwicmVwbGFjZUFuZEZpbmROZXh0XFxcIiBjbGFzcz1cXFwiYWNlX3JlcGxhY2VidG5cXFwiPlJlcGxhY2U8L2J1dHRvbj5cXFxcXFxuXFx0ICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgYWN0aW9uPVxcXCJyZXBsYWNlQWxsXFxcIiBjbGFzcz1cXFwiYWNlX3JlcGxhY2VidG5cXFwiPkFsbDwvYnV0dG9uPlxcXFxcXG5cXHQgICAgPC9kaXY+XFxcXFxcblxcdCAgICA8ZGl2IGNsYXNzPVxcXCJhY2Vfc2VhcmNoX29wdGlvbnNcXFwiPlxcXFxcXG5cXHQgICAgICAgIDxzcGFuIGFjdGlvbj1cXFwidG9nZ2xlUmVnZXhwTW9kZVxcXCIgY2xhc3M9XFxcImFjZV9idXR0b25cXFwiIHRpdGxlPVxcXCJSZWdFeHAgU2VhcmNoXFxcIj4uKjwvc3Bhbj5cXFxcXFxuXFx0ICAgICAgICA8c3BhbiBhY3Rpb249XFxcInRvZ2dsZUNhc2VTZW5zaXRpdmVcXFwiIGNsYXNzPVxcXCJhY2VfYnV0dG9uXFxcIiB0aXRsZT1cXFwiQ2FzZVNlbnNpdGl2ZSBTZWFyY2hcXFwiPkFhPC9zcGFuPlxcXFxcXG5cXHQgICAgICAgIDxzcGFuIGFjdGlvbj1cXFwidG9nZ2xlV2hvbGVXb3Jkc1xcXCIgY2xhc3M9XFxcImFjZV9idXR0b25cXFwiIHRpdGxlPVxcXCJXaG9sZSBXb3JkIFNlYXJjaFxcXCI+XFxcXFxcXFxiPC9zcGFuPlxcXFxcXG5cXHQgICAgPC9kaXY+XFxcXFxcblxcdDwvZGl2PicucmVwbGFjZSgvPlxcXFxzKy9nLCBcXFwiPlxcXCIpO1xcblxcblxcdHZhciBTZWFyY2hCb3ggPSBmdW5jdGlvbihlZGl0b3IsIHJhbmdlLCBzaG93UmVwbGFjZUZvcm0pIHtcXG5cXHQgICAgdmFyIGRpdiA9IGRvbS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXHQgICAgZGl2LmlubmVySFRNTCA9IGh0bWw7XFxuXFx0ICAgIHRoaXMuZWxlbWVudCA9IGRpdi5maXJzdENoaWxkO1xcblxcblxcdCAgICB0aGlzLiRpbml0KCk7XFxuXFx0ICAgIHRoaXMuc2V0RWRpdG9yKGVkaXRvcik7XFxuXFx0fTtcXG5cXG5cXHQoZnVuY3Rpb24oKSB7XFxuXFx0ICAgIHRoaXMuc2V0RWRpdG9yID0gZnVuY3Rpb24oZWRpdG9yKSB7XFxuXFx0ICAgICAgICBlZGl0b3Iuc2VhcmNoQm94ID0gdGhpcztcXG5cXHQgICAgICAgIGVkaXRvci5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLiRpbml0RWxlbWVudHMgPSBmdW5jdGlvbihzYikge1xcblxcdCAgICAgICAgdGhpcy5zZWFyY2hCb3ggPSBzYi5xdWVyeVNlbGVjdG9yKFxcXCIuYWNlX3NlYXJjaF9mb3JtXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLnJlcGxhY2VCb3ggPSBzYi5xdWVyeVNlbGVjdG9yKFxcXCIuYWNlX3JlcGxhY2VfZm9ybVxcXCIpO1xcblxcdCAgICAgICAgdGhpcy5zZWFyY2hPcHRpb25zID0gc2IucXVlcnlTZWxlY3RvcihcXFwiLmFjZV9zZWFyY2hfb3B0aW9uc1xcXCIpO1xcblxcdCAgICAgICAgdGhpcy5yZWdFeHBPcHRpb24gPSBzYi5xdWVyeVNlbGVjdG9yKFxcXCJbYWN0aW9uPXRvZ2dsZVJlZ2V4cE1vZGVdXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmVPcHRpb24gPSBzYi5xdWVyeVNlbGVjdG9yKFxcXCJbYWN0aW9uPXRvZ2dsZUNhc2VTZW5zaXRpdmVdXFxcIik7XFxuXFx0ICAgICAgICB0aGlzLndob2xlV29yZE9wdGlvbiA9IHNiLnF1ZXJ5U2VsZWN0b3IoXFxcIlthY3Rpb249dG9nZ2xlV2hvbGVXb3Jkc11cXFwiKTtcXG5cXHQgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQgPSB0aGlzLnNlYXJjaEJveC5xdWVyeVNlbGVjdG9yKFxcXCIuYWNlX3NlYXJjaF9maWVsZFxcXCIpO1xcblxcdCAgICAgICAgdGhpcy5yZXBsYWNlSW5wdXQgPSB0aGlzLnJlcGxhY2VCb3gucXVlcnlTZWxlY3RvcihcXFwiLmFjZV9zZWFyY2hfZmllbGRcXFwiKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgXFxuXFx0ICAgIHRoaXMuJGluaXQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBzYiA9IHRoaXMuZWxlbWVudDtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdGhpcy4kaW5pdEVsZW1lbnRzKHNiKTtcXG5cXHQgICAgICAgIFxcblxcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHNiLCBcXFwibW91c2Vkb3duXFxcIiwgZnVuY3Rpb24oZSkge1xcblxcdCAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcXG5cXHQgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlSW5wdXQuZm9jdXMoKTtcXG5cXHQgICAgICAgICAgICB9LCAwKTtcXG5cXHQgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHNiLCBcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbihlKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIHQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XFxuXFx0ICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHQuZ2V0QXR0cmlidXRlKFxcXCJhY3Rpb25cXFwiKTtcXG5cXHQgICAgICAgICAgICBpZiAoYWN0aW9uICYmIF90aGlzW2FjdGlvbl0pXFxuXFx0ICAgICAgICAgICAgICAgIF90aGlzW2FjdGlvbl0oKTtcXG5cXHQgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy4kc2VhcmNoQmFyS2IuY29tbWFuZHNbYWN0aW9uXSlcXG5cXHQgICAgICAgICAgICAgICAgX3RoaXMuJHNlYXJjaEJhcktiLmNvbW1hbmRzW2FjdGlvbl0uZXhlYyhfdGhpcyk7XFxuXFx0ICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xcblxcdCAgICAgICAgfSk7XFxuXFxuXFx0ICAgICAgICBldmVudC5hZGRDb21tYW5kS2V5TGlzdGVuZXIoc2IsIGZ1bmN0aW9uKGUsIGhhc2hJZCwga2V5Q29kZSkge1xcblxcdCAgICAgICAgICAgIHZhciBrZXlTdHJpbmcgPSBrZXlVdGlsLmtleUNvZGVUb1N0cmluZyhrZXlDb2RlKTtcXG5cXHQgICAgICAgICAgICB2YXIgY29tbWFuZCA9IF90aGlzLiRzZWFyY2hCYXJLYi5maW5kS2V5Q29tbWFuZChoYXNoSWQsIGtleVN0cmluZyk7XFxuXFx0ICAgICAgICAgICAgaWYgKGNvbW1hbmQgJiYgY29tbWFuZC5leGVjKSB7XFxuXFx0ICAgICAgICAgICAgICAgIGNvbW1hbmQuZXhlYyhfdGhpcyk7XFxuXFx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BFdmVudChlKTtcXG5cXHQgICAgICAgICAgICB9XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIHRoaXMuJG9uQ2hhbmdlID0gbGFuZy5kZWxheWVkQ2FsbChmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBfdGhpcy5maW5kKGZhbHNlLCBmYWxzZSk7XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMuc2VhcmNoSW5wdXQsIFxcXCJpbnB1dFxcXCIsIGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIF90aGlzLiRvbkNoYW5nZS5zY2hlZHVsZSgyMCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMuc2VhcmNoSW5wdXQsIFxcXCJmb2N1c1xcXCIsIGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgICAgIF90aGlzLmFjdGl2ZUlucHV0ID0gX3RoaXMuc2VhcmNoSW5wdXQ7XFxuXFx0ICAgICAgICAgICAgX3RoaXMuc2VhcmNoSW5wdXQudmFsdWUgJiYgX3RoaXMuaGlnaGxpZ2h0KCk7XFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIGV2ZW50LmFkZExpc3RlbmVyKHRoaXMucmVwbGFjZUlucHV0LCBcXFwiZm9jdXNcXFwiLCBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgICAgICBfdGhpcy5hY3RpdmVJbnB1dCA9IF90aGlzLnJlcGxhY2VJbnB1dDtcXG5cXHQgICAgICAgICAgICBfdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSAmJiBfdGhpcy5oaWdobGlnaHQoKTtcXG5cXHQgICAgICAgIH0pO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLiRjbG9zZVNlYXJjaEJhcktiID0gbmV3IEhhc2hIYW5kbGVyKFt7XFxuXFx0ICAgICAgICBiaW5kS2V5OiBcXFwiRXNjXFxcIixcXG5cXHQgICAgICAgIG5hbWU6IFxcXCJjbG9zZVNlYXJjaEJhclxcXCIsXFxuXFx0ICAgICAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IpIHtcXG5cXHQgICAgICAgICAgICBlZGl0b3Iuc2VhcmNoQm94LmhpZGUoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfV0pO1xcblxcdCAgICB0aGlzLiRzZWFyY2hCYXJLYiA9IG5ldyBIYXNoSGFuZGxlcigpO1xcblxcdCAgICB0aGlzLiRzZWFyY2hCYXJLYi5iaW5kS2V5cyh7XFxuXFx0ICAgICAgICBcXFwiQ3RybC1mfENvbW1hbmQtZnxDdHJsLUh8Q29tbWFuZC1PcHRpb24tRlxcXCI6IGZ1bmN0aW9uKHNiKSB7XFxuXFx0ICAgICAgICAgICAgdmFyIGlzUmVwbGFjZSA9IHNiLmlzUmVwbGFjZSA9ICFzYi5pc1JlcGxhY2U7XFxuXFx0ICAgICAgICAgICAgc2IucmVwbGFjZUJveC5zdHlsZS5kaXNwbGF5ID0gaXNSZXBsYWNlID8gXFxcIlxcXCIgOiBcXFwibm9uZVxcXCI7XFxuXFx0ICAgICAgICAgICAgc2JbaXNSZXBsYWNlID8gXFxcInJlcGxhY2VJbnB1dFxcXCIgOiBcXFwic2VhcmNoSW5wdXRcXFwiXS5mb2N1cygpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIFxcXCJDdHJsLUd8Q29tbWFuZC1HXFxcIjogZnVuY3Rpb24oc2IpIHtcXG5cXHQgICAgICAgICAgICBzYi5maW5kTmV4dCgpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIFxcXCJDdHJsLVNoaWZ0LUd8Q29tbWFuZC1TaGlmdC1HXFxcIjogZnVuY3Rpb24oc2IpIHtcXG5cXHQgICAgICAgICAgICBzYi5maW5kUHJldigpO1xcblxcdCAgICAgICAgfSxcXG5cXHQgICAgICAgIFxcXCJlc2NcXFwiOiBmdW5jdGlvbihzYikge1xcblxcdCAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNiLmhpZGUoKTt9KTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBcXFwiUmV0dXJuXFxcIjogZnVuY3Rpb24oc2IpIHtcXG5cXHQgICAgICAgICAgICBpZiAoc2IuYWN0aXZlSW5wdXQgPT0gc2IucmVwbGFjZUlucHV0KVxcblxcdCAgICAgICAgICAgICAgICBzYi5yZXBsYWNlKCk7XFxuXFx0ICAgICAgICAgICAgc2IuZmluZE5leHQoKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBcXFwiU2hpZnQtUmV0dXJuXFxcIjogZnVuY3Rpb24oc2IpIHtcXG5cXHQgICAgICAgICAgICBpZiAoc2IuYWN0aXZlSW5wdXQgPT0gc2IucmVwbGFjZUlucHV0KVxcblxcdCAgICAgICAgICAgICAgICBzYi5yZXBsYWNlKCk7XFxuXFx0ICAgICAgICAgICAgc2IuZmluZFByZXYoKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBcXFwiQWx0LVJldHVyblxcXCI6IGZ1bmN0aW9uKHNiKSB7XFxuXFx0ICAgICAgICAgICAgaWYgKHNiLmFjdGl2ZUlucHV0ID09IHNiLnJlcGxhY2VJbnB1dClcXG5cXHQgICAgICAgICAgICAgICAgc2IucmVwbGFjZUFsbCgpO1xcblxcdCAgICAgICAgICAgIHNiLmZpbmRBbGwoKTtcXG5cXHQgICAgICAgIH0sXFxuXFx0ICAgICAgICBcXFwiVGFiXFxcIjogZnVuY3Rpb24oc2IpIHtcXG5cXHQgICAgICAgICAgICAoc2IuYWN0aXZlSW5wdXQgPT0gc2IucmVwbGFjZUlucHV0ID8gc2Iuc2VhcmNoSW5wdXQgOiBzYi5yZXBsYWNlSW5wdXQpLmZvY3VzKCk7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH0pO1xcblxcblxcdCAgICB0aGlzLiRzZWFyY2hCYXJLYi5hZGRDb21tYW5kcyhbe1xcblxcdCAgICAgICAgbmFtZTogXFxcInRvZ2dsZVJlZ2V4cE1vZGVcXFwiLFxcblxcdCAgICAgICAgYmluZEtleToge3dpbjogXFxcIkFsdC1SfEFsdC0vXFxcIiwgbWFjOiBcXFwiQ3RybC1BbHQtUnxDdHJsLUFsdC0vXFxcIn0sXFxuXFx0ICAgICAgICBleGVjOiBmdW5jdGlvbihzYikge1xcblxcdCAgICAgICAgICAgIHNiLnJlZ0V4cE9wdGlvbi5jaGVja2VkID0gIXNiLnJlZ0V4cE9wdGlvbi5jaGVja2VkO1xcblxcdCAgICAgICAgICAgIHNiLiRzeW5jT3B0aW9ucygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9LCB7XFxuXFx0ICAgICAgICBuYW1lOiBcXFwidG9nZ2xlQ2FzZVNlbnNpdGl2ZVxcXCIsXFxuXFx0ICAgICAgICBiaW5kS2V5OiB7d2luOiBcXFwiQWx0LUN8QWx0LUlcXFwiLCBtYWM6IFxcXCJDdHJsLUFsdC1SfEN0cmwtQWx0LUlcXFwifSxcXG5cXHQgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKHNiKSB7XFxuXFx0ICAgICAgICAgICAgc2IuY2FzZVNlbnNpdGl2ZU9wdGlvbi5jaGVja2VkID0gIXNiLmNhc2VTZW5zaXRpdmVPcHRpb24uY2hlY2tlZDtcXG5cXHQgICAgICAgICAgICBzYi4kc3luY09wdGlvbnMoKTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgfSwge1xcblxcdCAgICAgICAgbmFtZTogXFxcInRvZ2dsZVdob2xlV29yZHNcXFwiLFxcblxcdCAgICAgICAgYmluZEtleToge3dpbjogXFxcIkFsdC1CfEFsdC1XXFxcIiwgbWFjOiBcXFwiQ3RybC1BbHQtQnxDdHJsLUFsdC1XXFxcIn0sXFxuXFx0ICAgICAgICBleGVjOiBmdW5jdGlvbihzYikge1xcblxcdCAgICAgICAgICAgIHNiLndob2xlV29yZE9wdGlvbi5jaGVja2VkID0gIXNiLndob2xlV29yZE9wdGlvbi5jaGVja2VkO1xcblxcdCAgICAgICAgICAgIHNiLiRzeW5jT3B0aW9ucygpO1xcblxcdCAgICAgICAgfVxcblxcdCAgICB9XSk7XFxuXFxuXFx0ICAgIHRoaXMuJHN5bmNPcHRpb25zID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy5yZWdFeHBPcHRpb24sIFxcXCJjaGVja2VkXFxcIiwgdGhpcy5yZWdFeHBPcHRpb24uY2hlY2tlZCk7XFxuXFx0ICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy53aG9sZVdvcmRPcHRpb24sIFxcXCJjaGVja2VkXFxcIiwgdGhpcy53aG9sZVdvcmRPcHRpb24uY2hlY2tlZCk7XFxuXFx0ICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy5jYXNlU2Vuc2l0aXZlT3B0aW9uLCBcXFwiY2hlY2tlZFxcXCIsIHRoaXMuY2FzZVNlbnNpdGl2ZU9wdGlvbi5jaGVja2VkKTtcXG5cXHQgICAgICAgIHRoaXMuZmluZChmYWxzZSwgZmFsc2UpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmhpZ2hsaWdodCA9IGZ1bmN0aW9uKHJlKSB7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci5zZXNzaW9uLmhpZ2hsaWdodChyZSB8fCB0aGlzLmVkaXRvci4kc2VhcmNoLiRvcHRpb25zLnJlKTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLnJlbmRlcmVyLnVwZGF0ZUJhY2tNYXJrZXJzKClcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5maW5kID0gZnVuY3Rpb24oc2tpcEN1cnJlbnQsIGJhY2t3YXJkcykge1xcblxcdCAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5lZGl0b3IuZmluZCh0aGlzLnNlYXJjaElucHV0LnZhbHVlLCB7XFxuXFx0ICAgICAgICAgICAgc2tpcEN1cnJlbnQ6IHNraXBDdXJyZW50LFxcblxcdCAgICAgICAgICAgIGJhY2t3YXJkczogYmFja3dhcmRzLFxcblxcdCAgICAgICAgICAgIHdyYXA6IHRydWUsXFxuXFx0ICAgICAgICAgICAgcmVnRXhwOiB0aGlzLnJlZ0V4cE9wdGlvbi5jaGVja2VkLFxcblxcdCAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZVNlbnNpdGl2ZU9wdGlvbi5jaGVja2VkLFxcblxcdCAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53aG9sZVdvcmRPcHRpb24uY2hlY2tlZFxcblxcdCAgICAgICAgfSk7XFxuXFx0ICAgICAgICB2YXIgbm9NYXRjaCA9ICFyYW5nZSAmJiB0aGlzLnNlYXJjaElucHV0LnZhbHVlO1xcblxcdCAgICAgICAgZG9tLnNldENzc0NsYXNzKHRoaXMuc2VhcmNoQm94LCBcXFwiYWNlX25vbWF0Y2hcXFwiLCBub01hdGNoKTtcXG5cXHQgICAgICAgIHRoaXMuZWRpdG9yLl9lbWl0KFxcXCJmaW5kU2VhcmNoQm94XFxcIiwgeyBtYXRjaDogIW5vTWF0Y2ggfSk7XFxuXFx0ICAgICAgICB0aGlzLmhpZ2hsaWdodCgpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmZpbmROZXh0ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLmZpbmQodHJ1ZSwgZmFsc2UpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLmZpbmRQcmV2ID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICB0aGlzLmZpbmQodHJ1ZSwgdHJ1ZSk7XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMuZmluZEFsbCA9IGZ1bmN0aW9uKCl7XFxuXFx0ICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmVkaXRvci5maW5kQWxsKHRoaXMuc2VhcmNoSW5wdXQudmFsdWUsIHtcXG5cXHQgICAgICAgICAgICByZWdFeHA6IHRoaXMucmVnRXhwT3B0aW9uLmNoZWNrZWQsXFxuXFx0ICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogdGhpcy5jYXNlU2Vuc2l0aXZlT3B0aW9uLmNoZWNrZWQsXFxuXFx0ICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndob2xlV29yZE9wdGlvbi5jaGVja2VkXFxuXFx0ICAgICAgICB9KTtcXG5cXHQgICAgICAgIHZhciBub01hdGNoID0gIXJhbmdlICYmIHRoaXMuc2VhcmNoSW5wdXQudmFsdWU7XFxuXFx0ICAgICAgICBkb20uc2V0Q3NzQ2xhc3ModGhpcy5zZWFyY2hCb3gsIFxcXCJhY2Vfbm9tYXRjaFxcXCIsIG5vTWF0Y2gpO1xcblxcdCAgICAgICAgdGhpcy5lZGl0b3IuX2VtaXQoXFxcImZpbmRTZWFyY2hCb3hcXFwiLCB7IG1hdGNoOiAhbm9NYXRjaCB9KTtcXG5cXHQgICAgICAgIHRoaXMuaGlnaGxpZ2h0KCk7XFxuXFx0ICAgICAgICB0aGlzLmhpZGUoKTtcXG5cXHQgICAgfTtcXG5cXHQgICAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmdldFJlYWRPbmx5KCkpXFxuXFx0ICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZSh0aGlzLnJlcGxhY2VJbnB1dC52YWx1ZSk7XFxuXFx0ICAgIH07ICAgIFxcblxcdCAgICB0aGlzLnJlcGxhY2VBbmRGaW5kTmV4dCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5nZXRSZWFkT25seSgpKSB7XFxuXFx0ICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZSh0aGlzLnJlcGxhY2VJbnB1dC52YWx1ZSk7XFxuXFx0ICAgICAgICAgICAgdGhpcy5maW5kTmV4dCgpXFxuXFx0ICAgICAgICB9XFxuXFx0ICAgIH07XFxuXFx0ICAgIHRoaXMucmVwbGFjZUFsbCA9IGZ1bmN0aW9uKCkge1xcblxcdCAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5nZXRSZWFkT25seSgpKVxcblxcdCAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VBbGwodGhpcy5yZXBsYWNlSW5wdXQudmFsdWUpO1xcblxcdCAgICB9O1xcblxcblxcdCAgICB0aGlzLmhpZGUgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcblxcdCAgICAgICAgdGhpcy5lZGl0b3Iua2V5QmluZGluZy5yZW1vdmVLZXlib2FyZEhhbmRsZXIodGhpcy4kY2xvc2VTZWFyY2hCYXJLYik7XFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci5mb2N1cygpO1xcblxcdCAgICB9O1xcblxcdCAgICB0aGlzLnNob3cgPSBmdW5jdGlvbih2YWx1ZSwgaXNSZXBsYWNlKSB7XFxuXFx0ICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcblxcdCAgICAgICAgdGhpcy5yZXBsYWNlQm94LnN0eWxlLmRpc3BsYXkgPSBpc1JlcGxhY2UgPyBcXFwiXFxcIiA6IFxcXCJub25lXFxcIjtcXG5cXG5cXHQgICAgICAgIHRoaXMuaXNSZXBsYWNlID0gaXNSZXBsYWNlO1xcblxcblxcdCAgICAgICAgaWYgKHZhbHVlKVxcblxcdCAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSB2YWx1ZTtcXG5cXHQgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcXG5cXHQgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuc2VsZWN0KCk7XFxuXFxuXFx0ICAgICAgICB0aGlzLmVkaXRvci5rZXlCaW5kaW5nLmFkZEtleWJvYXJkSGFuZGxlcih0aGlzLiRjbG9zZVNlYXJjaEJhcktiKTtcXG5cXHQgICAgfTtcXG5cXG5cXHQgICAgdGhpcy5pc0ZvY3VzZWQgPSBmdW5jdGlvbigpIHtcXG5cXHQgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFx0ICAgICAgICByZXR1cm4gZWwgPT0gdGhpcy5zZWFyY2hJbnB1dCB8fCBlbCA9PSB0aGlzLnJlcGxhY2VJbnB1dDtcXG5cXHQgICAgfVxcblxcdH0pLmNhbGwoU2VhcmNoQm94LnByb3RvdHlwZSk7XFxuXFxuXFx0ZXhwb3J0cy5TZWFyY2hCb3ggPSBTZWFyY2hCb3g7XFxuXFxuXFx0ZXhwb3J0cy5TZWFyY2ggPSBmdW5jdGlvbihlZGl0b3IsIGlzUmVwbGFjZSkge1xcblxcdCAgICB2YXIgc2IgPSBlZGl0b3Iuc2VhcmNoQm94IHx8IG5ldyBTZWFyY2hCb3goZWRpdG9yKTtcXG5cXHQgICAgc2Iuc2hvdyhlZGl0b3Iuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UoKSwgaXNSZXBsYWNlKTtcXG5cXHR9O1xcblxcblxcdH0pO1xcblxcdCAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XFxuXFx0ICAgICAgICAgICAgICAgICAgICBhY2UuYWNlcXVpcmUoW1xcXCJhY2UvZXh0L3NlYXJjaGJveFxcXCJdLCBmdW5jdGlvbigpIHt9KTtcXG5cXHQgICAgICAgICAgICAgICAgfSkoKTtcXG5cXHQgICAgICAgICAgICBcXG5cXG4vKioqLyB9LFxcbi8qIDE3ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMuaWQgPSAnYWNlL21vZGUvanNvbl93b3JrZXInO1xcblxcdG1vZHVsZS5leHBvcnRzLnNyYyA9IFxcXCJcXFxcXFxcIm5vIHVzZSBzdHJpY3RcXFxcXFxcIjsoZnVuY3Rpb24od2luZG93KXtpZih2b2lkIDA9PT13aW5kb3cud2luZG93fHwhd2luZG93LmRvY3VtZW50KXt3aW5kb3cuY29uc29sZT1mdW5jdGlvbigpe3ZhciBtc2dzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtwb3N0TWVzc2FnZSh7dHlwZTpcXFxcXFxcImxvZ1xcXFxcXFwiLGRhdGE6bXNnc30pfSx3aW5kb3cuY29uc29sZS5lcnJvcj13aW5kb3cuY29uc29sZS53YXJuPXdpbmRvdy5jb25zb2xlLmxvZz13aW5kb3cuY29uc29sZS50cmFjZT13aW5kb3cuY29uc29sZSx3aW5kb3cud2luZG93PXdpbmRvdyx3aW5kb3cuYWNlPXdpbmRvdyx3aW5kb3cub25lcnJvcj1mdW5jdGlvbihtZXNzYWdlLGZpbGUsbGluZSxjb2wsZXJyKXtwb3N0TWVzc2FnZSh7dHlwZTpcXFxcXFxcImVycm9yXFxcXFxcXCIsZGF0YTp7bWVzc2FnZTptZXNzYWdlLGZpbGU6ZmlsZSxsaW5lOmxpbmUsY29sOmNvbCxzdGFjazplcnIuc3RhY2t9fSl9LHdpbmRvdy5ub3JtYWxpemVNb2R1bGU9ZnVuY3Rpb24ocGFyZW50SWQsbW9kdWxlTmFtZSl7aWYoLTEhPT1tb2R1bGVOYW1lLmluZGV4T2YoXFxcXFxcXCIhXFxcXFxcXCIpKXt2YXIgY2h1bmtzPW1vZHVsZU5hbWUuc3BsaXQoXFxcXFxcXCIhXFxcXFxcXCIpO3JldHVybiB3aW5kb3cubm9ybWFsaXplTW9kdWxlKHBhcmVudElkLGNodW5rc1swXSkrXFxcXFxcXCIhXFxcXFxcXCIrd2luZG93Lm5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCxjaHVua3NbMV0pfWlmKFxcXFxcXFwiLlxcXFxcXFwiPT1tb2R1bGVOYW1lLmNoYXJBdCgwKSl7dmFyIGJhc2U9cGFyZW50SWQuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpLnNsaWNlKDAsLTEpLmpvaW4oXFxcXFxcXCIvXFxcXFxcXCIpO2Zvcihtb2R1bGVOYW1lPShiYXNlP2Jhc2UrXFxcXFxcXCIvXFxcXFxcXCI6XFxcXFxcXCJcXFxcXFxcIikrbW9kdWxlTmFtZTstMSE9PW1vZHVsZU5hbWUuaW5kZXhPZihcXFxcXFxcIi5cXFxcXFxcIikmJnByZXZpb3VzIT1tb2R1bGVOYW1lOyl7dmFyIHByZXZpb3VzPW1vZHVsZU5hbWU7bW9kdWxlTmFtZT1tb2R1bGVOYW1lLnJlcGxhY2UoL15cXFxcXFxcXC5cXFxcXFxcXC8vLFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UoL1xcXFxcXFxcL1xcXFxcXFxcLlxcXFxcXFxcLy8sXFxcXFxcXCIvXFxcXFxcXCIpLnJlcGxhY2UoL1teXFxcXFxcXFwvXStcXFxcXFxcXC9cXFxcXFxcXC5cXFxcXFxcXC5cXFxcXFxcXC8vLFxcXFxcXFwiXFxcXFxcXCIpfX1yZXR1cm4gbW9kdWxlTmFtZX0sd2luZG93LmFjZXF1aXJlPWZ1bmN0aW9uKHBhcmVudElkLGlkKXtpZihpZHx8KGlkPXBhcmVudElkLHBhcmVudElkPW51bGwpLCFpZC5jaGFyQXQpdGhyb3cgRXJyb3IoXFxcXFxcXCJ3b3JrZXIuanMgYWNlcXVpcmUoKSBhY2NlcHRzIG9ubHkgKHBhcmVudElkLCBpZCkgYXMgYXJndW1lbnRzXFxcXFxcXCIpO2lkPXdpbmRvdy5ub3JtYWxpemVNb2R1bGUocGFyZW50SWQsaWQpO3ZhciBtb2R1bGU9d2luZG93LmFjZXF1aXJlLm1vZHVsZXNbaWRdO2lmKG1vZHVsZSlyZXR1cm4gbW9kdWxlLmluaXRpYWxpemVkfHwobW9kdWxlLmluaXRpYWxpemVkPSEwLG1vZHVsZS5leHBvcnRzPW1vZHVsZS5mYWN0b3J5KCkuZXhwb3J0cyksbW9kdWxlLmV4cG9ydHM7dmFyIGNodW5rcz1pZC5zcGxpdChcXFxcXFxcIi9cXFxcXFxcIik7aWYoIXdpbmRvdy5hY2VxdWlyZS50bG5zKXJldHVybiBjb25zb2xlLmxvZyhcXFxcXFxcInVuYWJsZSB0byBsb2FkIFxcXFxcXFwiK2lkKTtjaHVua3NbMF09d2luZG93LmFjZXF1aXJlLnRsbnNbY2h1bmtzWzBdXXx8Y2h1bmtzWzBdO3ZhciBwYXRoPWNodW5rcy5qb2luKFxcXFxcXFwiL1xcXFxcXFwiKStcXFxcXFxcIi5qc1xcXFxcXFwiO3JldHVybiB3aW5kb3cuYWNlcXVpcmUuaWQ9aWQsaW1wb3J0U2NyaXB0cyhwYXRoKSx3aW5kb3cuYWNlcXVpcmUocGFyZW50SWQsaWQpfSx3aW5kb3cuYWNlcXVpcmUubW9kdWxlcz17fSx3aW5kb3cuYWNlcXVpcmUudGxucz17fSx3aW5kb3cuZGVmaW5lPWZ1bmN0aW9uKGlkLGRlcHMsZmFjdG9yeSl7aWYoMj09YXJndW1lbnRzLmxlbmd0aD8oZmFjdG9yeT1kZXBzLFxcXFxcXFwic3RyaW5nXFxcXFxcXCIhPXR5cGVvZiBpZCYmKGRlcHM9aWQsaWQ9d2luZG93LmFjZXF1aXJlLmlkKSk6MT09YXJndW1lbnRzLmxlbmd0aCYmKGZhY3Rvcnk9aWQsZGVwcz1bXSxpZD13aW5kb3cuYWNlcXVpcmUuaWQpLFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIiE9dHlwZW9mIGZhY3RvcnkpcmV0dXJuIHdpbmRvdy5hY2VxdWlyZS5tb2R1bGVzW2lkXT17ZXhwb3J0czpmYWN0b3J5LGluaXRpYWxpemVkOiEwfSx2b2lkIDA7ZGVwcy5sZW5ndGh8fChkZXBzPVtcXFxcXFxcInJlcXVpcmVcXFxcXFxcIixcXFxcXFxcImV4cG9ydHNcXFxcXFxcIixcXFxcXFxcIm1vZHVsZVxcXFxcXFwiXSk7dmFyIHJlcT1mdW5jdGlvbihjaGlsZElkKXtyZXR1cm4gd2luZG93LmFjZXF1aXJlKGlkLGNoaWxkSWQpfTt3aW5kb3cuYWNlcXVpcmUubW9kdWxlc1tpZF09e2V4cG9ydHM6e30sZmFjdG9yeTpmdW5jdGlvbigpe3ZhciBtb2R1bGU9dGhpcyxyZXR1cm5FeHBvcnRzPWZhY3RvcnkuYXBwbHkodGhpcyxkZXBzLm1hcChmdW5jdGlvbihkZXApe3N3aXRjaChkZXApe2Nhc2VcXFxcXFxcInJlcXVpcmVcXFxcXFxcIjpyZXR1cm4gcmVxO2Nhc2VcXFxcXFxcImV4cG9ydHNcXFxcXFxcIjpyZXR1cm4gbW9kdWxlLmV4cG9ydHM7Y2FzZVxcXFxcXFwibW9kdWxlXFxcXFxcXCI6cmV0dXJuIG1vZHVsZTtkZWZhdWx0OnJldHVybiByZXEoZGVwKX19KSk7cmV0dXJuIHJldHVybkV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cz1yZXR1cm5FeHBvcnRzKSxtb2R1bGV9fX0sd2luZG93LmRlZmluZS5hbWQ9e30sd2luZG93LmluaXRCYXNlVXJscz1mdW5jdGlvbiBpbml0QmFzZVVybHModG9wTGV2ZWxOYW1lc3BhY2VzKXthY2VxdWlyZS50bG5zPXRvcExldmVsTmFtZXNwYWNlc30sd2luZG93LmluaXRTZW5kZXI9ZnVuY3Rpb24gaW5pdFNlbmRlcigpe3ZhciBFdmVudEVtaXR0ZXI9d2luZG93LmFjZXF1aXJlKFxcXFxcXFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXFxcXFxcXCIpLkV2ZW50RW1pdHRlcixvb3A9d2luZG93LmFjZXF1aXJlKFxcXFxcXFwiYWNlL2xpYi9vb3BcXFxcXFxcIiksU2VuZGVyPWZ1bmN0aW9uKCl7fTtyZXR1cm4gZnVuY3Rpb24oKXtvb3AuaW1wbGVtZW50KHRoaXMsRXZlbnRFbWl0dGVyKSx0aGlzLmNhbGxiYWNrPWZ1bmN0aW9uKGRhdGEsY2FsbGJhY2tJZCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XFxcXFxcXCJjYWxsXFxcXFxcXCIsaWQ6Y2FsbGJhY2tJZCxkYXRhOmRhdGF9KX0sdGhpcy5lbWl0PWZ1bmN0aW9uKG5hbWUsZGF0YSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XFxcXFxcXCJldmVudFxcXFxcXFwiLG5hbWU6bmFtZSxkYXRhOmRhdGF9KX19LmNhbGwoU2VuZGVyLnByb3RvdHlwZSksbmV3IFNlbmRlcn07dmFyIG1haW49d2luZG93Lm1haW49bnVsbCxzZW5kZXI9d2luZG93LnNlbmRlcj1udWxsO3dpbmRvdy5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7dmFyIG1zZz1lLmRhdGE7aWYobXNnLmNvbW1hbmQpe2lmKCFtYWluW21zZy5jb21tYW5kXSl0aHJvdyBFcnJvcihcXFxcXFxcIlVua25vd24gY29tbWFuZDpcXFxcXFxcIittc2cuY29tbWFuZCk7bWFpblttc2cuY29tbWFuZF0uYXBwbHkobWFpbixtc2cuYXJncyl9ZWxzZSBpZihtc2cuaW5pdCl7aW5pdEJhc2VVcmxzKG1zZy50bG5zKSxhY2VxdWlyZShcXFxcXFxcImFjZS9saWIvZXM1LXNoaW1cXFxcXFxcIiksc2VuZGVyPXdpbmRvdy5zZW5kZXI9aW5pdFNlbmRlcigpO3ZhciBjbGF6ej1hY2VxdWlyZShtc2cubW9kdWxlKVttc2cuY2xhc3NuYW1lXTttYWluPXdpbmRvdy5tYWluPW5ldyBjbGF6eihzZW5kZXIpfWVsc2UgbXNnLmV2ZW50JiZzZW5kZXImJnNlbmRlci5fc2lnbmFsKG1zZy5ldmVudCxtc2cuZGF0YSl9fX0pKHRoaXMpLGFjZS5kZWZpbmUoXFxcXFxcXCJhY2UvbGliL29vcFxcXFxcXFwiLFtcXFxcXFxcInJlcXVpcmVcXFxcXFxcIixcXFxcXFxcImV4cG9ydHNcXFxcXFxcIixcXFxcXFxcIm1vZHVsZVxcXFxcXFwiXSxmdW5jdGlvbihhY2VxdWlyZSxleHBvcnRzKXtcXFxcXFxcInVzZSBzdHJpY3RcXFxcXFxcIjtleHBvcnRzLmluaGVyaXRzPWZ1bmN0aW9uKGN0b3Isc3VwZXJDdG9yKXtjdG9yLnN1cGVyXz1zdXBlckN0b3IsY3Rvci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6Y3RvcixlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KX0sZXhwb3J0cy5taXhpbj1mdW5jdGlvbihvYmosbWl4aW4pe2Zvcih2YXIga2V5IGluIG1peGluKW9ialtrZXldPW1peGluW2tleV07cmV0dXJuIG9ian0sZXhwb3J0cy5pbXBsZW1lbnQ9ZnVuY3Rpb24ocHJvdG8sbWl4aW4pe2V4cG9ydHMubWl4aW4ocHJvdG8sbWl4aW4pfX0pLGFjZS5kZWZpbmUoXFxcXFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFxcXFxcIixbXFxcXFxcXCJyZXF1aXJlXFxcXFxcXCIsXFxcXFxcXCJleHBvcnRzXFxcXFxcXCIsXFxcXFxcXCJtb2R1bGVcXFxcXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcXFxcXCJ1c2Ugc3RyaWN0XFxcXFxcXCI7dmFyIEV2ZW50RW1pdHRlcj17fSxzdG9wUHJvcGFnYXRpb249ZnVuY3Rpb24oKXt0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH0scHJldmVudERlZmF1bHQ9ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITB9O0V2ZW50RW1pdHRlci5fZW1pdD1FdmVudEVtaXR0ZXIuX2Rpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24oZXZlbnROYW1lLGUpe3RoaXMuX2V2ZW50UmVnaXN0cnl8fCh0aGlzLl9ldmVudFJlZ2lzdHJ5PXt9KSx0aGlzLl9kZWZhdWx0SGFuZGxlcnN8fCh0aGlzLl9kZWZhdWx0SGFuZGxlcnM9e30pO3ZhciBsaXN0ZW5lcnM9dGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdfHxbXSxkZWZhdWx0SGFuZGxlcj10aGlzLl9kZWZhdWx0SGFuZGxlcnNbZXZlbnROYW1lXTtpZihsaXN0ZW5lcnMubGVuZ3RofHxkZWZhdWx0SGFuZGxlcil7XFxcXFxcXCJvYmplY3RcXFxcXFxcIj09dHlwZW9mIGUmJmV8fChlPXt9KSxlLnR5cGV8fChlLnR5cGU9ZXZlbnROYW1lKSxlLnN0b3BQcm9wYWdhdGlvbnx8KGUuc3RvcFByb3BhZ2F0aW9uPXN0b3BQcm9wYWdhdGlvbiksZS5wcmV2ZW50RGVmYXVsdHx8KGUucHJldmVudERlZmF1bHQ9cHJldmVudERlZmF1bHQpLGxpc3RlbmVycz1saXN0ZW5lcnMuc2xpY2UoKTtmb3IodmFyIGk9MDtsaXN0ZW5lcnMubGVuZ3RoPmkmJihsaXN0ZW5lcnNbaV0oZSx0aGlzKSwhZS5wcm9wYWdhdGlvblN0b3BwZWQpO2krKyk7cmV0dXJuIGRlZmF1bHRIYW5kbGVyJiYhZS5kZWZhdWx0UHJldmVudGVkP2RlZmF1bHRIYW5kbGVyKGUsdGhpcyk6dm9pZCAwfX0sRXZlbnRFbWl0dGVyLl9zaWduYWw9ZnVuY3Rpb24oZXZlbnROYW1lLGUpe3ZhciBsaXN0ZW5lcnM9KHRoaXMuX2V2ZW50UmVnaXN0cnl8fHt9KVtldmVudE5hbWVdO2lmKGxpc3RlbmVycyl7bGlzdGVuZXJzPWxpc3RlbmVycy5zbGljZSgpO2Zvcih2YXIgaT0wO2xpc3RlbmVycy5sZW5ndGg+aTtpKyspbGlzdGVuZXJzW2ldKGUsdGhpcyl9fSxFdmVudEVtaXR0ZXIub25jZT1mdW5jdGlvbihldmVudE5hbWUsY2FsbGJhY2spe3ZhciBfc2VsZj10aGlzO2NhbGxiYWNrJiZ0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLGZ1bmN0aW9uIG5ld0NhbGxiYWNrKCl7X3NlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsbmV3Q2FsbGJhY2spLGNhbGxiYWNrLmFwcGx5KG51bGwsYXJndW1lbnRzKX0pfSxFdmVudEVtaXR0ZXIuc2V0RGVmYXVsdEhhbmRsZXI9ZnVuY3Rpb24oZXZlbnROYW1lLGNhbGxiYWNrKXt2YXIgaGFuZGxlcnM9dGhpcy5fZGVmYXVsdEhhbmRsZXJzO2lmKGhhbmRsZXJzfHwoaGFuZGxlcnM9dGhpcy5fZGVmYXVsdEhhbmRsZXJzPXtfZGlzYWJsZWRfOnt9fSksaGFuZGxlcnNbZXZlbnROYW1lXSl7dmFyIG9sZD1oYW5kbGVyc1tldmVudE5hbWVdLGRpc2FibGVkPWhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXTtkaXNhYmxlZHx8KGhhbmRsZXJzLl9kaXNhYmxlZF9bZXZlbnROYW1lXT1kaXNhYmxlZD1bXSksZGlzYWJsZWQucHVzaChvbGQpO3ZhciBpPWRpc2FibGVkLmluZGV4T2YoY2FsbGJhY2spOy0xIT1pJiZkaXNhYmxlZC5zcGxpY2UoaSwxKX1oYW5kbGVyc1tldmVudE5hbWVdPWNhbGxiYWNrfSxFdmVudEVtaXR0ZXIucmVtb3ZlRGVmYXVsdEhhbmRsZXI9ZnVuY3Rpb24oZXZlbnROYW1lLGNhbGxiYWNrKXt2YXIgaGFuZGxlcnM9dGhpcy5fZGVmYXVsdEhhbmRsZXJzO2lmKGhhbmRsZXJzKXt2YXIgZGlzYWJsZWQ9aGFuZGxlcnMuX2Rpc2FibGVkX1tldmVudE5hbWVdO2lmKGhhbmRsZXJzW2V2ZW50TmFtZV09PWNhbGxiYWNrKWhhbmRsZXJzW2V2ZW50TmFtZV0sZGlzYWJsZWQmJnRoaXMuc2V0RGVmYXVsdEhhbmRsZXIoZXZlbnROYW1lLGRpc2FibGVkLnBvcCgpKTtlbHNlIGlmKGRpc2FibGVkKXt2YXIgaT1kaXNhYmxlZC5pbmRleE9mKGNhbGxiYWNrKTstMSE9aSYmZGlzYWJsZWQuc3BsaWNlKGksMSl9fX0sRXZlbnRFbWl0dGVyLm9uPUV2ZW50RW1pdHRlci5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGV2ZW50TmFtZSxjYWxsYmFjayxjYXB0dXJpbmcpe3RoaXMuX2V2ZW50UmVnaXN0cnk9dGhpcy5fZXZlbnRSZWdpc3RyeXx8e307dmFyIGxpc3RlbmVycz10aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV07cmV0dXJuIGxpc3RlbmVyc3x8KGxpc3RlbmVycz10aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV09W10pLC0xPT1saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjaykmJmxpc3RlbmVyc1tjYXB0dXJpbmc/XFxcXFxcXCJ1bnNoaWZ0XFxcXFxcXCI6XFxcXFxcXCJwdXNoXFxcXFxcXCJdKGNhbGxiYWNrKSxjYWxsYmFja30sRXZlbnRFbWl0dGVyLm9mZj1FdmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXI9RXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZXZlbnROYW1lLGNhbGxiYWNrKXt0aGlzLl9ldmVudFJlZ2lzdHJ5PXRoaXMuX2V2ZW50UmVnaXN0cnl8fHt9O3ZhciBsaXN0ZW5lcnM9dGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdO2lmKGxpc3RlbmVycyl7dmFyIGluZGV4PWxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTstMSE9PWluZGV4JiZsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LDEpfX0sRXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbihldmVudE5hbWUpe3RoaXMuX2V2ZW50UmVnaXN0cnkmJih0aGlzLl9ldmVudFJlZ2lzdHJ5W2V2ZW50TmFtZV09W10pfSxleHBvcnRzLkV2ZW50RW1pdHRlcj1FdmVudEVtaXR0ZXJ9KSxhY2UuZGVmaW5lKFxcXFxcXFwiYWNlL3JhbmdlXFxcXFxcXCIsW1xcXFxcXFwicmVxdWlyZVxcXFxcXFwiLFxcXFxcXFwiZXhwb3J0c1xcXFxcXFwiLFxcXFxcXFwibW9kdWxlXFxcXFxcXCJdLGZ1bmN0aW9uKGFjZXF1aXJlLGV4cG9ydHMpe1xcXFxcXFwidXNlIHN0cmljdFxcXFxcXFwiO3ZhciBjb21wYXJlUG9pbnRzPWZ1bmN0aW9uKHAxLHAyKXtyZXR1cm4gcDEucm93LXAyLnJvd3x8cDEuY29sdW1uLXAyLmNvbHVtbn0sUmFuZ2U9ZnVuY3Rpb24oc3RhcnRSb3csc3RhcnRDb2x1bW4sZW5kUm93LGVuZENvbHVtbil7dGhpcy5zdGFydD17cm93OnN0YXJ0Um93LGNvbHVtbjpzdGFydENvbHVtbn0sdGhpcy5lbmQ9e3JvdzplbmRSb3csY29sdW1uOmVuZENvbHVtbn19OyhmdW5jdGlvbigpe3RoaXMuaXNFcXVhbD1mdW5jdGlvbihyYW5nZSl7cmV0dXJuIHRoaXMuc3RhcnQucm93PT09cmFuZ2Uuc3RhcnQucm93JiZ0aGlzLmVuZC5yb3c9PT1yYW5nZS5lbmQucm93JiZ0aGlzLnN0YXJ0LmNvbHVtbj09PXJhbmdlLnN0YXJ0LmNvbHVtbiYmdGhpcy5lbmQuY29sdW1uPT09cmFuZ2UuZW5kLmNvbHVtbn0sdGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblxcXFxcXFwiUmFuZ2U6IFtcXFxcXFxcIit0aGlzLnN0YXJ0LnJvdytcXFxcXFxcIi9cXFxcXFxcIit0aGlzLnN0YXJ0LmNvbHVtbitcXFxcXFxcIl0gLT4gW1xcXFxcXFwiK3RoaXMuZW5kLnJvdytcXFxcXFxcIi9cXFxcXFxcIit0aGlzLmVuZC5jb2x1bW4rXFxcXFxcXCJdXFxcXFxcXCJ9LHRoaXMuY29udGFpbnM9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIDA9PXRoaXMuY29tcGFyZShyb3csY29sdW1uKX0sdGhpcy5jb21wYXJlUmFuZ2U9ZnVuY3Rpb24ocmFuZ2Upe3ZhciBjbXAsZW5kPXJhbmdlLmVuZCxzdGFydD1yYW5nZS5zdGFydDtyZXR1cm4gY21wPXRoaXMuY29tcGFyZShlbmQucm93LGVuZC5jb2x1bW4pLDE9PWNtcD8oY21wPXRoaXMuY29tcGFyZShzdGFydC5yb3csc3RhcnQuY29sdW1uKSwxPT1jbXA/MjowPT1jbXA/MTowKTotMT09Y21wPy0yOihjbXA9dGhpcy5jb21wYXJlKHN0YXJ0LnJvdyxzdGFydC5jb2x1bW4pLC0xPT1jbXA/LTE6MT09Y21wPzQyOjApfSx0aGlzLmNvbXBhcmVQb2ludD1mdW5jdGlvbihwKXtyZXR1cm4gdGhpcy5jb21wYXJlKHAucm93LHAuY29sdW1uKX0sdGhpcy5jb250YWluc1JhbmdlPWZ1bmN0aW9uKHJhbmdlKXtyZXR1cm4gMD09dGhpcy5jb21wYXJlUG9pbnQocmFuZ2Uuc3RhcnQpJiYwPT10aGlzLmNvbXBhcmVQb2ludChyYW5nZS5lbmQpfSx0aGlzLmludGVyc2VjdHM9ZnVuY3Rpb24ocmFuZ2Upe3ZhciBjbXA9dGhpcy5jb21wYXJlUmFuZ2UocmFuZ2UpO3JldHVybi0xPT1jbXB8fDA9PWNtcHx8MT09Y21wfSx0aGlzLmlzRW5kPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiB0aGlzLmVuZC5yb3c9PXJvdyYmdGhpcy5lbmQuY29sdW1uPT1jb2x1bW59LHRoaXMuaXNTdGFydD1mdW5jdGlvbihyb3csY29sdW1uKXtyZXR1cm4gdGhpcy5zdGFydC5yb3c9PXJvdyYmdGhpcy5zdGFydC5jb2x1bW49PWNvbHVtbn0sdGhpcy5zZXRTdGFydD1mdW5jdGlvbihyb3csY29sdW1uKXtcXFxcXFxcIm9iamVjdFxcXFxcXFwiPT10eXBlb2Ygcm93Pyh0aGlzLnN0YXJ0LmNvbHVtbj1yb3cuY29sdW1uLHRoaXMuc3RhcnQucm93PXJvdy5yb3cpOih0aGlzLnN0YXJ0LnJvdz1yb3csdGhpcy5zdGFydC5jb2x1bW49Y29sdW1uKX0sdGhpcy5zZXRFbmQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7XFxcXFxcXCJvYmplY3RcXFxcXFxcIj09dHlwZW9mIHJvdz8odGhpcy5lbmQuY29sdW1uPXJvdy5jb2x1bW4sdGhpcy5lbmQucm93PXJvdy5yb3cpOih0aGlzLmVuZC5yb3c9cm93LHRoaXMuZW5kLmNvbHVtbj1jb2x1bW4pfSx0aGlzLmluc2lkZT1mdW5jdGlvbihyb3csY29sdW1uKXtyZXR1cm4gMD09dGhpcy5jb21wYXJlKHJvdyxjb2x1bW4pP3RoaXMuaXNFbmQocm93LGNvbHVtbil8fHRoaXMuaXNTdGFydChyb3csY29sdW1uKT8hMTohMDohMX0sdGhpcy5pbnNpZGVTdGFydD1mdW5jdGlvbihyb3csY29sdW1uKXtyZXR1cm4gMD09dGhpcy5jb21wYXJlKHJvdyxjb2x1bW4pP3RoaXMuaXNFbmQocm93LGNvbHVtbik/ITE6ITA6ITF9LHRoaXMuaW5zaWRlRW5kPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiAwPT10aGlzLmNvbXBhcmUocm93LGNvbHVtbik/dGhpcy5pc1N0YXJ0KHJvdyxjb2x1bW4pPyExOiEwOiExfSx0aGlzLmNvbXBhcmU9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIHRoaXMuaXNNdWx0aUxpbmUoKXx8cm93IT09dGhpcy5zdGFydC5yb3c/dGhpcy5zdGFydC5yb3c+cm93Py0xOnJvdz50aGlzLmVuZC5yb3c/MTp0aGlzLnN0YXJ0LnJvdz09PXJvdz9jb2x1bW4+PXRoaXMuc3RhcnQuY29sdW1uPzA6LTE6dGhpcy5lbmQucm93PT09cm93P3RoaXMuZW5kLmNvbHVtbj49Y29sdW1uPzA6MTowOnRoaXMuc3RhcnQuY29sdW1uPmNvbHVtbj8tMTpjb2x1bW4+dGhpcy5lbmQuY29sdW1uPzE6MH0sdGhpcy5jb21wYXJlU3RhcnQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIHRoaXMuc3RhcnQucm93PT1yb3cmJnRoaXMuc3RhcnQuY29sdW1uPT1jb2x1bW4/LTE6dGhpcy5jb21wYXJlKHJvdyxjb2x1bW4pfSx0aGlzLmNvbXBhcmVFbmQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIHRoaXMuZW5kLnJvdz09cm93JiZ0aGlzLmVuZC5jb2x1bW49PWNvbHVtbj8xOnRoaXMuY29tcGFyZShyb3csY29sdW1uKX0sdGhpcy5jb21wYXJlSW5zaWRlPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiB0aGlzLmVuZC5yb3c9PXJvdyYmdGhpcy5lbmQuY29sdW1uPT1jb2x1bW4/MTp0aGlzLnN0YXJ0LnJvdz09cm93JiZ0aGlzLnN0YXJ0LmNvbHVtbj09Y29sdW1uPy0xOnRoaXMuY29tcGFyZShyb3csY29sdW1uKX0sdGhpcy5jbGlwUm93cz1mdW5jdGlvbihmaXJzdFJvdyxsYXN0Um93KXtpZih0aGlzLmVuZC5yb3c+bGFzdFJvdyl2YXIgZW5kPXtyb3c6bGFzdFJvdysxLGNvbHVtbjowfTtlbHNlIGlmKGZpcnN0Um93PnRoaXMuZW5kLnJvdyl2YXIgZW5kPXtyb3c6Zmlyc3RSb3csY29sdW1uOjB9O2lmKHRoaXMuc3RhcnQucm93Pmxhc3RSb3cpdmFyIHN0YXJ0PXtyb3c6bGFzdFJvdysxLGNvbHVtbjowfTtlbHNlIGlmKGZpcnN0Um93PnRoaXMuc3RhcnQucm93KXZhciBzdGFydD17cm93OmZpcnN0Um93LGNvbHVtbjowfTtyZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydHx8dGhpcy5zdGFydCxlbmR8fHRoaXMuZW5kKX0sdGhpcy5leHRlbmQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7dmFyIGNtcD10aGlzLmNvbXBhcmUocm93LGNvbHVtbik7aWYoMD09Y21wKXJldHVybiB0aGlzO2lmKC0xPT1jbXApdmFyIHN0YXJ0PXtyb3c6cm93LGNvbHVtbjpjb2x1bW59O2Vsc2UgdmFyIGVuZD17cm93OnJvdyxjb2x1bW46Y29sdW1ufTtyZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhzdGFydHx8dGhpcy5zdGFydCxlbmR8fHRoaXMuZW5kKX0sdGhpcy5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnQucm93PT09dGhpcy5lbmQucm93JiZ0aGlzLnN0YXJ0LmNvbHVtbj09PXRoaXMuZW5kLmNvbHVtbn0sdGhpcy5pc011bHRpTGluZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0LnJvdyE9PXRoaXMuZW5kLnJvd30sdGhpcy5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBSYW5nZS5mcm9tUG9pbnRzKHRoaXMuc3RhcnQsdGhpcy5lbmQpfSx0aGlzLmNvbGxhcHNlUm93cz1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLmVuZC5jb2x1bW4/bmV3IFJhbmdlKHRoaXMuc3RhcnQucm93LDAsTWF0aC5tYXgodGhpcy5zdGFydC5yb3csdGhpcy5lbmQucm93LTEpLDApOm5ldyBSYW5nZSh0aGlzLnN0YXJ0LnJvdywwLHRoaXMuZW5kLnJvdywwKX0sdGhpcy50b1NjcmVlblJhbmdlPWZ1bmN0aW9uKHNlc3Npb24pe3ZhciBzY3JlZW5Qb3NTdGFydD1zZXNzaW9uLmRvY3VtZW50VG9TY3JlZW5Qb3NpdGlvbih0aGlzLnN0YXJ0KSxzY3JlZW5Qb3NFbmQ9c2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5lbmQpO3JldHVybiBuZXcgUmFuZ2Uoc2NyZWVuUG9zU3RhcnQucm93LHNjcmVlblBvc1N0YXJ0LmNvbHVtbixzY3JlZW5Qb3NFbmQucm93LHNjcmVlblBvc0VuZC5jb2x1bW4pfSx0aGlzLm1vdmVCeT1mdW5jdGlvbihyb3csY29sdW1uKXt0aGlzLnN0YXJ0LnJvdys9cm93LHRoaXMuc3RhcnQuY29sdW1uKz1jb2x1bW4sdGhpcy5lbmQucm93Kz1yb3csdGhpcy5lbmQuY29sdW1uKz1jb2x1bW59fSkuY2FsbChSYW5nZS5wcm90b3R5cGUpLFJhbmdlLmZyb21Qb2ludHM9ZnVuY3Rpb24oc3RhcnQsZW5kKXtyZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LnJvdyxzdGFydC5jb2x1bW4sZW5kLnJvdyxlbmQuY29sdW1uKX0sUmFuZ2UuY29tcGFyZVBvaW50cz1jb21wYXJlUG9pbnRzLFJhbmdlLmNvbXBhcmVQb2ludHM9ZnVuY3Rpb24ocDEscDIpe3JldHVybiBwMS5yb3ctcDIucm93fHxwMS5jb2x1bW4tcDIuY29sdW1ufSxleHBvcnRzLlJhbmdlPVJhbmdlfSksYWNlLmRlZmluZShcXFxcXFxcImFjZS9hbmNob3JcXFxcXFxcIixbXFxcXFxcXCJyZXF1aXJlXFxcXFxcXCIsXFxcXFxcXCJleHBvcnRzXFxcXFxcXCIsXFxcXFxcXCJtb2R1bGVcXFxcXFxcIixcXFxcXFxcImFjZS9saWIvb29wXFxcXFxcXCIsXFxcXFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFxcXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcXFxcXCJ1c2Ugc3RyaWN0XFxcXFxcXCI7dmFyIG9vcD1hY2VxdWlyZShcXFxcXFxcIi4vbGliL29vcFxcXFxcXFwiKSxFdmVudEVtaXR0ZXI9YWNlcXVpcmUoXFxcXFxcXCIuL2xpYi9ldmVudF9lbWl0dGVyXFxcXFxcXCIpLkV2ZW50RW1pdHRlcixBbmNob3I9ZXhwb3J0cy5BbmNob3I9ZnVuY3Rpb24oZG9jLHJvdyxjb2x1bW4pe3RoaXMuJG9uQ2hhbmdlPXRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSx0aGlzLmF0dGFjaChkb2MpLGNvbHVtbj09PXZvaWQgMD90aGlzLnNldFBvc2l0aW9uKHJvdy5yb3cscm93LmNvbHVtbik6dGhpcy5zZXRQb3NpdGlvbihyb3csY29sdW1uKX07KGZ1bmN0aW9uKCl7b29wLmltcGxlbWVudCh0aGlzLEV2ZW50RW1pdHRlciksdGhpcy5nZXRQb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KHRoaXMucm93LHRoaXMuY29sdW1uKX0sdGhpcy5nZXREb2N1bWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRvY3VtZW50fSx0aGlzLiRpbnNlcnRSaWdodD0hMSx0aGlzLm9uQ2hhbmdlPWZ1bmN0aW9uKGUpe3ZhciBkZWx0YT1lLmRhdGEscmFuZ2U9ZGVsdGEucmFuZ2U7aWYoIShyYW5nZS5zdGFydC5yb3c9PXJhbmdlLmVuZC5yb3cmJnJhbmdlLnN0YXJ0LnJvdyE9dGhpcy5yb3d8fHJhbmdlLnN0YXJ0LnJvdz50aGlzLnJvd3x8cmFuZ2Uuc3RhcnQucm93PT10aGlzLnJvdyYmcmFuZ2Uuc3RhcnQuY29sdW1uPnRoaXMuY29sdW1uKSl7dmFyIHJvdz10aGlzLnJvdyxjb2x1bW49dGhpcy5jb2x1bW4sc3RhcnQ9cmFuZ2Uuc3RhcnQsZW5kPXJhbmdlLmVuZDtcXFxcXFxcImluc2VydFRleHRcXFxcXFxcIj09PWRlbHRhLmFjdGlvbj9zdGFydC5yb3c9PT1yb3cmJmNvbHVtbj49c3RhcnQuY29sdW1uP3N0YXJ0LmNvbHVtbj09PWNvbHVtbiYmdGhpcy4kaW5zZXJ0UmlnaHR8fChzdGFydC5yb3c9PT1lbmQucm93P2NvbHVtbis9ZW5kLmNvbHVtbi1zdGFydC5jb2x1bW46KGNvbHVtbi09c3RhcnQuY29sdW1uLHJvdys9ZW5kLnJvdy1zdGFydC5yb3cpKTpzdGFydC5yb3chPT1lbmQucm93JiZyb3c+c3RhcnQucm93JiYocm93Kz1lbmQucm93LXN0YXJ0LnJvdyk6XFxcXFxcXCJpbnNlcnRMaW5lc1xcXFxcXFwiPT09ZGVsdGEuYWN0aW9uP3N0YXJ0LnJvdz09PXJvdyYmMD09PWNvbHVtbiYmdGhpcy4kaW5zZXJ0UmlnaHR8fHJvdz49c3RhcnQucm93JiYocm93Kz1lbmQucm93LXN0YXJ0LnJvdyk6XFxcXFxcXCJyZW1vdmVUZXh0XFxcXFxcXCI9PT1kZWx0YS5hY3Rpb24/c3RhcnQucm93PT09cm93JiZjb2x1bW4+c3RhcnQuY29sdW1uP2NvbHVtbj1lbmQuY29sdW1uPj1jb2x1bW4/c3RhcnQuY29sdW1uOk1hdGgubWF4KDAsY29sdW1uLShlbmQuY29sdW1uLXN0YXJ0LmNvbHVtbikpOnN0YXJ0LnJvdyE9PWVuZC5yb3cmJnJvdz5zdGFydC5yb3c/KGVuZC5yb3c9PT1yb3cmJihjb2x1bW49TWF0aC5tYXgoMCxjb2x1bW4tZW5kLmNvbHVtbikrc3RhcnQuY29sdW1uKSxyb3ctPWVuZC5yb3ctc3RhcnQucm93KTplbmQucm93PT09cm93JiYocm93LT1lbmQucm93LXN0YXJ0LnJvdyxjb2x1bW49TWF0aC5tYXgoMCxjb2x1bW4tZW5kLmNvbHVtbikrc3RhcnQuY29sdW1uKTpcXFxcXFxcInJlbW92ZUxpbmVzXFxcXFxcXCI9PWRlbHRhLmFjdGlvbiYmcm93Pj1zdGFydC5yb3cmJihyb3c+PWVuZC5yb3c/cm93LT1lbmQucm93LXN0YXJ0LnJvdzoocm93PXN0YXJ0LnJvdyxjb2x1bW49MCkpLHRoaXMuc2V0UG9zaXRpb24ocm93LGNvbHVtbiwhMCl9fSx0aGlzLnNldFBvc2l0aW9uPWZ1bmN0aW9uKHJvdyxjb2x1bW4sbm9DbGlwKXt2YXIgcG9zO2lmKHBvcz1ub0NsaXA/e3Jvdzpyb3csY29sdW1uOmNvbHVtbn06dGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudChyb3csY29sdW1uKSx0aGlzLnJvdyE9cG9zLnJvd3x8dGhpcy5jb2x1bW4hPXBvcy5jb2x1bW4pe3ZhciBvbGQ9e3Jvdzp0aGlzLnJvdyxjb2x1bW46dGhpcy5jb2x1bW59O3RoaXMucm93PXBvcy5yb3csdGhpcy5jb2x1bW49cG9zLmNvbHVtbix0aGlzLl9zaWduYWwoXFxcXFxcXCJjaGFuZ2VcXFxcXFxcIix7b2xkOm9sZCx2YWx1ZTpwb3N9KX19LHRoaXMuZGV0YWNoPWZ1bmN0aW9uKCl7dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXFxcXFwiY2hhbmdlXFxcXFxcXCIsdGhpcy4kb25DaGFuZ2UpfSx0aGlzLmF0dGFjaD1mdW5jdGlvbihkb2Mpe3RoaXMuZG9jdW1lbnQ9ZG9jfHx0aGlzLmRvY3VtZW50LHRoaXMuZG9jdW1lbnQub24oXFxcXFxcXCJjaGFuZ2VcXFxcXFxcIix0aGlzLiRvbkNoYW5nZSl9LHRoaXMuJGNsaXBQb3NpdGlvblRvRG9jdW1lbnQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7dmFyIHBvcz17fTtyZXR1cm4gcm93Pj10aGlzLmRvY3VtZW50LmdldExlbmd0aCgpPyhwb3Mucm93PU1hdGgubWF4KDAsdGhpcy5kb2N1bWVudC5nZXRMZW5ndGgoKS0xKSxwb3MuY29sdW1uPXRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGgpOjA+cm93Pyhwb3Mucm93PTAscG9zLmNvbHVtbj0wKToocG9zLnJvdz1yb3cscG9zLmNvbHVtbj1NYXRoLm1pbih0aGlzLmRvY3VtZW50LmdldExpbmUocG9zLnJvdykubGVuZ3RoLE1hdGgubWF4KDAsY29sdW1uKSkpLDA+Y29sdW1uJiYocG9zLmNvbHVtbj0wKSxwb3N9fSkuY2FsbChBbmNob3IucHJvdG90eXBlKX0pLGFjZS5kZWZpbmUoXFxcXFxcXCJhY2UvZG9jdW1lbnRcXFxcXFxcIixbXFxcXFxcXCJyZXF1aXJlXFxcXFxcXCIsXFxcXFxcXCJleHBvcnRzXFxcXFxcXCIsXFxcXFxcXCJtb2R1bGVcXFxcXFxcIixcXFxcXFxcImFjZS9saWIvb29wXFxcXFxcXCIsXFxcXFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFxcXFxcIixcXFxcXFxcImFjZS9yYW5nZVxcXFxcXFwiLFxcXFxcXFwiYWNlL2FuY2hvclxcXFxcXFwiXSxmdW5jdGlvbihhY2VxdWlyZSxleHBvcnRzKXtcXFxcXFxcInVzZSBzdHJpY3RcXFxcXFxcIjt2YXIgb29wPWFjZXF1aXJlKFxcXFxcXFwiLi9saWIvb29wXFxcXFxcXCIpLEV2ZW50RW1pdHRlcj1hY2VxdWlyZShcXFxcXFxcIi4vbGliL2V2ZW50X2VtaXR0ZXJcXFxcXFxcIikuRXZlbnRFbWl0dGVyLFJhbmdlPWFjZXF1aXJlKFxcXFxcXFwiLi9yYW5nZVxcXFxcXFwiKS5SYW5nZSxBbmNob3I9YWNlcXVpcmUoXFxcXFxcXCIuL2FuY2hvclxcXFxcXFwiKS5BbmNob3IsRG9jdW1lbnQ9ZnVuY3Rpb24odGV4dCl7dGhpcy4kbGluZXM9W10sMD09PXRleHQubGVuZ3RoP3RoaXMuJGxpbmVzPVtcXFxcXFxcIlxcXFxcXFwiXTpBcnJheS5pc0FycmF5KHRleHQpP3RoaXMuX2luc2VydExpbmVzKDAsdGV4dCk6dGhpcy5pbnNlcnQoe3JvdzowLGNvbHVtbjowfSx0ZXh0KX07KGZ1bmN0aW9uKCl7b29wLmltcGxlbWVudCh0aGlzLEV2ZW50RW1pdHRlciksdGhpcy5zZXRWYWx1ZT1mdW5jdGlvbih0ZXh0KXt2YXIgbGVuPXRoaXMuZ2V0TGVuZ3RoKCk7dGhpcy5yZW1vdmUobmV3IFJhbmdlKDAsMCxsZW4sdGhpcy5nZXRMaW5lKGxlbi0xKS5sZW5ndGgpKSx0aGlzLmluc2VydCh7cm93OjAsY29sdW1uOjB9LHRleHQpfSx0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0QWxsTGluZXMoKS5qb2luKHRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpKX0sdGhpcy5jcmVhdGVBbmNob3I9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIG5ldyBBbmNob3IodGhpcyxyb3csY29sdW1uKX0sdGhpcy4kc3BsaXQ9MD09PVxcXFxcXFwiYWFhXFxcXFxcXCIuc3BsaXQoL2EvKS5sZW5ndGg/ZnVuY3Rpb24odGV4dCl7cmV0dXJuIHRleHQucmVwbGFjZSgvXFxcXFxcXFxyXFxcXFxcXFxufFxcXFxcXFxcci9nLFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpLnNwbGl0KFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpfTpmdW5jdGlvbih0ZXh0KXtyZXR1cm4gdGV4dC5zcGxpdCgvXFxcXFxcXFxyXFxcXFxcXFxufFxcXFxcXFxccnxcXFxcXFxcXG4vKX0sdGhpcy4kZGV0ZWN0TmV3TGluZT1mdW5jdGlvbih0ZXh0KXt2YXIgbWF0Y2g9dGV4dC5tYXRjaCgvXi4qPyhcXFxcXFxcXHJcXFxcXFxcXG58XFxcXFxcXFxyfFxcXFxcXFxcbikvbSk7dGhpcy4kYXV0b05ld0xpbmU9bWF0Y2g/bWF0Y2hbMV06XFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIix0aGlzLl9zaWduYWwoXFxcXFxcXCJjaGFuZ2VOZXdMaW5lTW9kZVxcXFxcXFwiKX0sdGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuJG5ld0xpbmVNb2RlKXtjYXNlXFxcXFxcXCJ3aW5kb3dzXFxcXFxcXCI6cmV0dXJuXFxcXFxcXCJcXFxcXFxcXHJcXFxcXFxcXG5cXFxcXFxcIjtjYXNlXFxcXFxcXCJ1bml4XFxcXFxcXCI6cmV0dXJuXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIjtkZWZhdWx0OnJldHVybiB0aGlzLiRhdXRvTmV3TGluZXx8XFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIn19LHRoaXMuJGF1dG9OZXdMaW5lPVxcXFxcXFwiXFxcXFxcXCIsdGhpcy4kbmV3TGluZU1vZGU9XFxcXFxcXCJhdXRvXFxcXFxcXCIsdGhpcy5zZXROZXdMaW5lTW9kZT1mdW5jdGlvbihuZXdMaW5lTW9kZSl7dGhpcy4kbmV3TGluZU1vZGUhPT1uZXdMaW5lTW9kZSYmKHRoaXMuJG5ld0xpbmVNb2RlPW5ld0xpbmVNb2RlLHRoaXMuX3NpZ25hbChcXFxcXFxcImNoYW5nZU5ld0xpbmVNb2RlXFxcXFxcXCIpKX0sdGhpcy5nZXROZXdMaW5lTW9kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRuZXdMaW5lTW9kZX0sdGhpcy5pc05ld0xpbmU9ZnVuY3Rpb24odGV4dCl7cmV0dXJuXFxcXFxcXCJcXFxcXFxcXHJcXFxcXFxcXG5cXFxcXFxcIj09dGV4dHx8XFxcXFxcXCJcXFxcXFxcXHJcXFxcXFxcIj09dGV4dHx8XFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIj09dGV4dH0sdGhpcy5nZXRMaW5lPWZ1bmN0aW9uKHJvdyl7cmV0dXJuIHRoaXMuJGxpbmVzW3Jvd118fFxcXFxcXFwiXFxcXFxcXCJ9LHRoaXMuZ2V0TGluZXM9ZnVuY3Rpb24oZmlyc3RSb3csbGFzdFJvdyl7cmV0dXJuIHRoaXMuJGxpbmVzLnNsaWNlKGZpcnN0Um93LGxhc3RSb3crMSl9LHRoaXMuZ2V0QWxsTGluZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRMaW5lcygwLHRoaXMuZ2V0TGVuZ3RoKCkpfSx0aGlzLmdldExlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRsaW5lcy5sZW5ndGh9LHRoaXMuZ2V0VGV4dFJhbmdlPWZ1bmN0aW9uKHJhbmdlKXtpZihyYW5nZS5zdGFydC5yb3c9PXJhbmdlLmVuZC5yb3cpcmV0dXJuIHRoaXMuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4scmFuZ2UuZW5kLmNvbHVtbik7dmFyIGxpbmVzPXRoaXMuZ2V0TGluZXMocmFuZ2Uuc3RhcnQucm93LHJhbmdlLmVuZC5yb3cpO2xpbmVzWzBdPShsaW5lc1swXXx8XFxcXFxcXCJcXFxcXFxcIikuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbik7dmFyIGw9bGluZXMubGVuZ3RoLTE7cmV0dXJuIHJhbmdlLmVuZC5yb3ctcmFuZ2Uuc3RhcnQucm93PT1sJiYobGluZXNbbF09bGluZXNbbF0uc3Vic3RyaW5nKDAscmFuZ2UuZW5kLmNvbHVtbikpLGxpbmVzLmpvaW4odGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkpfSx0aGlzLiRjbGlwUG9zaXRpb249ZnVuY3Rpb24ocG9zaXRpb24pe3ZhciBsZW5ndGg9dGhpcy5nZXRMZW5ndGgoKTtyZXR1cm4gcG9zaXRpb24ucm93Pj1sZW5ndGg/KHBvc2l0aW9uLnJvdz1NYXRoLm1heCgwLGxlbmd0aC0xKSxwb3NpdGlvbi5jb2x1bW49dGhpcy5nZXRMaW5lKGxlbmd0aC0xKS5sZW5ndGgpOjA+cG9zaXRpb24ucm93JiYocG9zaXRpb24ucm93PTApLHBvc2l0aW9ufSx0aGlzLmluc2VydD1mdW5jdGlvbihwb3NpdGlvbix0ZXh0KXtpZighdGV4dHx8MD09PXRleHQubGVuZ3RoKXJldHVybiBwb3NpdGlvbjtwb3NpdGlvbj10aGlzLiRjbGlwUG9zaXRpb24ocG9zaXRpb24pLDE+PXRoaXMuZ2V0TGVuZ3RoKCkmJnRoaXMuJGRldGVjdE5ld0xpbmUodGV4dCk7dmFyIGxpbmVzPXRoaXMuJHNwbGl0KHRleHQpLGZpcnN0TGluZT1saW5lcy5zcGxpY2UoMCwxKVswXSxsYXN0TGluZT0wPT1saW5lcy5sZW5ndGg/bnVsbDpsaW5lcy5zcGxpY2UobGluZXMubGVuZ3RoLTEsMSlbMF07cmV0dXJuIHBvc2l0aW9uPXRoaXMuaW5zZXJ0SW5MaW5lKHBvc2l0aW9uLGZpcnN0TGluZSksbnVsbCE9PWxhc3RMaW5lJiYocG9zaXRpb249dGhpcy5pbnNlcnROZXdMaW5lKHBvc2l0aW9uKSxwb3NpdGlvbj10aGlzLl9pbnNlcnRMaW5lcyhwb3NpdGlvbi5yb3csbGluZXMpLHBvc2l0aW9uPXRoaXMuaW5zZXJ0SW5MaW5lKHBvc2l0aW9uLGxhc3RMaW5lfHxcXFxcXFxcIlxcXFxcXFwiKSkscG9zaXRpb259LHRoaXMuaW5zZXJ0TGluZXM9ZnVuY3Rpb24ocm93LGxpbmVzKXtyZXR1cm4gcm93Pj10aGlzLmdldExlbmd0aCgpP3RoaXMuaW5zZXJ0KHtyb3c6cm93LGNvbHVtbjowfSxcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiK2xpbmVzLmpvaW4oXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIikpOnRoaXMuX2luc2VydExpbmVzKE1hdGgubWF4KHJvdywwKSxsaW5lcyl9LHRoaXMuX2luc2VydExpbmVzPWZ1bmN0aW9uKHJvdyxsaW5lcyl7aWYoMD09bGluZXMubGVuZ3RoKXJldHVybntyb3c6cm93LGNvbHVtbjowfTtmb3IoO2xpbmVzLmxlbmd0aD42MTQ0MDspe3ZhciBlbmQ9dGhpcy5faW5zZXJ0TGluZXMocm93LGxpbmVzLnNsaWNlKDAsNjE0NDApKTtsaW5lcz1saW5lcy5zbGljZSg2MTQ0MCkscm93PWVuZC5yb3d9dmFyIGFyZ3M9W3JvdywwXTthcmdzLnB1c2guYXBwbHkoYXJncyxsaW5lcyksdGhpcy4kbGluZXMuc3BsaWNlLmFwcGx5KHRoaXMuJGxpbmVzLGFyZ3MpO3ZhciByYW5nZT1uZXcgUmFuZ2Uocm93LDAscm93K2xpbmVzLmxlbmd0aCwwKSxkZWx0YT17YWN0aW9uOlxcXFxcXFwiaW5zZXJ0TGluZXNcXFxcXFxcIixyYW5nZTpyYW5nZSxsaW5lczpsaW5lc307cmV0dXJuIHRoaXMuX3NpZ25hbChcXFxcXFxcImNoYW5nZVxcXFxcXFwiLHtkYXRhOmRlbHRhfSkscmFuZ2UuZW5kfSx0aGlzLmluc2VydE5ld0xpbmU9ZnVuY3Rpb24ocG9zaXRpb24pe3Bvc2l0aW9uPXRoaXMuJGNsaXBQb3NpdGlvbihwb3NpdGlvbik7dmFyIGxpbmU9dGhpcy4kbGluZXNbcG9zaXRpb24ucm93XXx8XFxcXFxcXCJcXFxcXFxcIjt0aGlzLiRsaW5lc1twb3NpdGlvbi5yb3ddPWxpbmUuc3Vic3RyaW5nKDAscG9zaXRpb24uY29sdW1uKSx0aGlzLiRsaW5lcy5zcGxpY2UocG9zaXRpb24ucm93KzEsMCxsaW5lLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4sbGluZS5sZW5ndGgpKTt2YXIgZW5kPXtyb3c6cG9zaXRpb24ucm93KzEsY29sdW1uOjB9LGRlbHRhPXthY3Rpb246XFxcXFxcXCJpbnNlcnRUZXh0XFxcXFxcXCIscmFuZ2U6UmFuZ2UuZnJvbVBvaW50cyhwb3NpdGlvbixlbmQpLHRleHQ6dGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCl9O3JldHVybiB0aGlzLl9zaWduYWwoXFxcXFxcXCJjaGFuZ2VcXFxcXFxcIix7ZGF0YTpkZWx0YX0pLGVuZH0sdGhpcy5pbnNlcnRJbkxpbmU9ZnVuY3Rpb24ocG9zaXRpb24sdGV4dCl7aWYoMD09dGV4dC5sZW5ndGgpcmV0dXJuIHBvc2l0aW9uO3ZhciBsaW5lPXRoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd118fFxcXFxcXFwiXFxcXFxcXCI7dGhpcy4kbGluZXNbcG9zaXRpb24ucm93XT1saW5lLnN1YnN0cmluZygwLHBvc2l0aW9uLmNvbHVtbikrdGV4dCtsaW5lLnN1YnN0cmluZyhwb3NpdGlvbi5jb2x1bW4pO3ZhciBlbmQ9e3Jvdzpwb3NpdGlvbi5yb3csY29sdW1uOnBvc2l0aW9uLmNvbHVtbit0ZXh0Lmxlbmd0aH0sZGVsdGE9e2FjdGlvbjpcXFxcXFxcImluc2VydFRleHRcXFxcXFxcIixyYW5nZTpSYW5nZS5mcm9tUG9pbnRzKHBvc2l0aW9uLGVuZCksdGV4dDp0ZXh0fTtyZXR1cm4gdGhpcy5fc2lnbmFsKFxcXFxcXFwiY2hhbmdlXFxcXFxcXCIse2RhdGE6ZGVsdGF9KSxlbmR9LHRoaXMucmVtb3ZlPWZ1bmN0aW9uKHJhbmdlKXtpZihyYW5nZSBpbnN0YW5jZW9mIFJhbmdlfHwocmFuZ2U9UmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCxyYW5nZS5lbmQpKSxyYW5nZS5zdGFydD10aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2Uuc3RhcnQpLHJhbmdlLmVuZD10aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2UuZW5kKSxyYW5nZS5pc0VtcHR5KCkpcmV0dXJuIHJhbmdlLnN0YXJ0O3ZhciBmaXJzdFJvdz1yYW5nZS5zdGFydC5yb3csbGFzdFJvdz1yYW5nZS5lbmQucm93O2lmKHJhbmdlLmlzTXVsdGlMaW5lKCkpe3ZhciBmaXJzdEZ1bGxSb3c9MD09cmFuZ2Uuc3RhcnQuY29sdW1uP2ZpcnN0Um93OmZpcnN0Um93KzEsbGFzdEZ1bGxSb3c9bGFzdFJvdy0xO3JhbmdlLmVuZC5jb2x1bW4+MCYmdGhpcy5yZW1vdmVJbkxpbmUobGFzdFJvdywwLHJhbmdlLmVuZC5jb2x1bW4pLGxhc3RGdWxsUm93Pj1maXJzdEZ1bGxSb3cmJnRoaXMuX3JlbW92ZUxpbmVzKGZpcnN0RnVsbFJvdyxsYXN0RnVsbFJvdyksZmlyc3RGdWxsUm93IT1maXJzdFJvdyYmKHRoaXMucmVtb3ZlSW5MaW5lKGZpcnN0Um93LHJhbmdlLnN0YXJ0LmNvbHVtbix0aGlzLmdldExpbmUoZmlyc3RSb3cpLmxlbmd0aCksdGhpcy5yZW1vdmVOZXdMaW5lKHJhbmdlLnN0YXJ0LnJvdykpfWVsc2UgdGhpcy5yZW1vdmVJbkxpbmUoZmlyc3RSb3cscmFuZ2Uuc3RhcnQuY29sdW1uLHJhbmdlLmVuZC5jb2x1bW4pO3JldHVybiByYW5nZS5zdGFydH0sdGhpcy5yZW1vdmVJbkxpbmU9ZnVuY3Rpb24ocm93LHN0YXJ0Q29sdW1uLGVuZENvbHVtbil7aWYoc3RhcnRDb2x1bW4hPWVuZENvbHVtbil7dmFyIHJhbmdlPW5ldyBSYW5nZShyb3csc3RhcnRDb2x1bW4scm93LGVuZENvbHVtbiksbGluZT10aGlzLmdldExpbmUocm93KSxyZW1vdmVkPWxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uLGVuZENvbHVtbiksbmV3TGluZT1saW5lLnN1YnN0cmluZygwLHN0YXJ0Q29sdW1uKStsaW5lLnN1YnN0cmluZyhlbmRDb2x1bW4sbGluZS5sZW5ndGgpO3RoaXMuJGxpbmVzLnNwbGljZShyb3csMSxuZXdMaW5lKTt2YXIgZGVsdGE9e2FjdGlvbjpcXFxcXFxcInJlbW92ZVRleHRcXFxcXFxcIixyYW5nZTpyYW5nZSx0ZXh0OnJlbW92ZWR9O3JldHVybiB0aGlzLl9zaWduYWwoXFxcXFxcXCJjaGFuZ2VcXFxcXFxcIix7ZGF0YTpkZWx0YX0pLHJhbmdlLnN0YXJ0fX0sdGhpcy5yZW1vdmVMaW5lcz1mdW5jdGlvbihmaXJzdFJvdyxsYXN0Um93KXtyZXR1cm4gMD5maXJzdFJvd3x8bGFzdFJvdz49dGhpcy5nZXRMZW5ndGgoKT90aGlzLnJlbW92ZShuZXcgUmFuZ2UoZmlyc3RSb3csMCxsYXN0Um93KzEsMCkpOnRoaXMuX3JlbW92ZUxpbmVzKGZpcnN0Um93LGxhc3RSb3cpfSx0aGlzLl9yZW1vdmVMaW5lcz1mdW5jdGlvbihmaXJzdFJvdyxsYXN0Um93KXt2YXIgcmFuZ2U9bmV3IFJhbmdlKGZpcnN0Um93LDAsbGFzdFJvdysxLDApLHJlbW92ZWQ9dGhpcy4kbGluZXMuc3BsaWNlKGZpcnN0Um93LGxhc3RSb3ctZmlyc3RSb3crMSksZGVsdGE9e2FjdGlvbjpcXFxcXFxcInJlbW92ZUxpbmVzXFxcXFxcXCIscmFuZ2U6cmFuZ2Usbmw6dGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCksbGluZXM6cmVtb3ZlZH07cmV0dXJuIHRoaXMuX3NpZ25hbChcXFxcXFxcImNoYW5nZVxcXFxcXFwiLHtkYXRhOmRlbHRhfSkscmVtb3ZlZH0sdGhpcy5yZW1vdmVOZXdMaW5lPWZ1bmN0aW9uKHJvdyl7dmFyIGZpcnN0TGluZT10aGlzLmdldExpbmUocm93KSxzZWNvbmRMaW5lPXRoaXMuZ2V0TGluZShyb3crMSkscmFuZ2U9bmV3IFJhbmdlKHJvdyxmaXJzdExpbmUubGVuZ3RoLHJvdysxLDApLGxpbmU9Zmlyc3RMaW5lK3NlY29uZExpbmU7dGhpcy4kbGluZXMuc3BsaWNlKHJvdywyLGxpbmUpO3ZhciBkZWx0YT17YWN0aW9uOlxcXFxcXFwicmVtb3ZlVGV4dFxcXFxcXFwiLHJhbmdlOnJhbmdlLHRleHQ6dGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCl9O3RoaXMuX3NpZ25hbChcXFxcXFxcImNoYW5nZVxcXFxcXFwiLHtkYXRhOmRlbHRhfSl9LHRoaXMucmVwbGFjZT1mdW5jdGlvbihyYW5nZSx0ZXh0KXtpZihyYW5nZSBpbnN0YW5jZW9mIFJhbmdlfHwocmFuZ2U9UmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCxyYW5nZS5lbmQpKSwwPT10ZXh0Lmxlbmd0aCYmcmFuZ2UuaXNFbXB0eSgpKXJldHVybiByYW5nZS5zdGFydDtpZih0ZXh0PT10aGlzLmdldFRleHRSYW5nZShyYW5nZSkpcmV0dXJuIHJhbmdlLmVuZDtpZih0aGlzLnJlbW92ZShyYW5nZSksdGV4dCl2YXIgZW5kPXRoaXMuaW5zZXJ0KHJhbmdlLnN0YXJ0LHRleHQpO2Vsc2UgZW5kPXJhbmdlLnN0YXJ0O3JldHVybiBlbmR9LHRoaXMuYXBwbHlEZWx0YXM9ZnVuY3Rpb24oZGVsdGFzKXtmb3IodmFyIGk9MDtkZWx0YXMubGVuZ3RoPmk7aSsrKXt2YXIgZGVsdGE9ZGVsdGFzW2ldLHJhbmdlPVJhbmdlLmZyb21Qb2ludHMoZGVsdGEucmFuZ2Uuc3RhcnQsZGVsdGEucmFuZ2UuZW5kKTtcXFxcXFxcImluc2VydExpbmVzXFxcXFxcXCI9PWRlbHRhLmFjdGlvbj90aGlzLmluc2VydExpbmVzKHJhbmdlLnN0YXJ0LnJvdyxkZWx0YS5saW5lcyk6XFxcXFxcXCJpbnNlcnRUZXh0XFxcXFxcXCI9PWRlbHRhLmFjdGlvbj90aGlzLmluc2VydChyYW5nZS5zdGFydCxkZWx0YS50ZXh0KTpcXFxcXFxcInJlbW92ZUxpbmVzXFxcXFxcXCI9PWRlbHRhLmFjdGlvbj90aGlzLl9yZW1vdmVMaW5lcyhyYW5nZS5zdGFydC5yb3cscmFuZ2UuZW5kLnJvdy0xKTpcXFxcXFxcInJlbW92ZVRleHRcXFxcXFxcIj09ZGVsdGEuYWN0aW9uJiZ0aGlzLnJlbW92ZShyYW5nZSl9fSx0aGlzLnJldmVydERlbHRhcz1mdW5jdGlvbihkZWx0YXMpe2Zvcih2YXIgaT1kZWx0YXMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBkZWx0YT1kZWx0YXNbaV0scmFuZ2U9UmFuZ2UuZnJvbVBvaW50cyhkZWx0YS5yYW5nZS5zdGFydCxkZWx0YS5yYW5nZS5lbmQpO1xcXFxcXFwiaW5zZXJ0TGluZXNcXFxcXFxcIj09ZGVsdGEuYWN0aW9uP3RoaXMuX3JlbW92ZUxpbmVzKHJhbmdlLnN0YXJ0LnJvdyxyYW5nZS5lbmQucm93LTEpOlxcXFxcXFwiaW5zZXJ0VGV4dFxcXFxcXFwiPT1kZWx0YS5hY3Rpb24/dGhpcy5yZW1vdmUocmFuZ2UpOlxcXFxcXFwicmVtb3ZlTGluZXNcXFxcXFxcIj09ZGVsdGEuYWN0aW9uP3RoaXMuX2luc2VydExpbmVzKHJhbmdlLnN0YXJ0LnJvdyxkZWx0YS5saW5lcyk6XFxcXFxcXCJyZW1vdmVUZXh0XFxcXFxcXCI9PWRlbHRhLmFjdGlvbiYmdGhpcy5pbnNlcnQocmFuZ2Uuc3RhcnQsZGVsdGEudGV4dCl9fSx0aGlzLmluZGV4VG9Qb3NpdGlvbj1mdW5jdGlvbihpbmRleCxzdGFydFJvdyl7Zm9yKHZhciBsaW5lcz10aGlzLiRsaW5lc3x8dGhpcy5nZXRBbGxMaW5lcygpLG5ld2xpbmVMZW5ndGg9dGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoLGk9c3RhcnRSb3d8fDAsbD1saW5lcy5sZW5ndGg7bD5pO2krKylpZihpbmRleC09bGluZXNbaV0ubGVuZ3RoK25ld2xpbmVMZW5ndGgsMD5pbmRleClyZXR1cm57cm93OmksY29sdW1uOmluZGV4K2xpbmVzW2ldLmxlbmd0aCtuZXdsaW5lTGVuZ3RofTtyZXR1cm57cm93OmwtMSxjb2x1bW46bGluZXNbbC0xXS5sZW5ndGh9fSx0aGlzLnBvc2l0aW9uVG9JbmRleD1mdW5jdGlvbihwb3Msc3RhcnRSb3cpe2Zvcih2YXIgbGluZXM9dGhpcy4kbGluZXN8fHRoaXMuZ2V0QWxsTGluZXMoKSxuZXdsaW5lTGVuZ3RoPXRoaXMuZ2V0TmV3TGluZUNoYXJhY3RlcigpLmxlbmd0aCxpbmRleD0wLHJvdz1NYXRoLm1pbihwb3Mucm93LGxpbmVzLmxlbmd0aCksaT1zdGFydFJvd3x8MDtyb3c+aTsrK2kpaW5kZXgrPWxpbmVzW2ldLmxlbmd0aCtuZXdsaW5lTGVuZ3RoO3JldHVybiBpbmRleCtwb3MuY29sdW1ufX0pLmNhbGwoRG9jdW1lbnQucHJvdG90eXBlKSxleHBvcnRzLkRvY3VtZW50PURvY3VtZW50fSksYWNlLmRlZmluZShcXFxcXFxcImFjZS9saWIvbGFuZ1xcXFxcXFwiLFtcXFxcXFxcInJlcXVpcmVcXFxcXFxcIixcXFxcXFxcImV4cG9ydHNcXFxcXFxcIixcXFxcXFxcIm1vZHVsZVxcXFxcXFwiXSxmdW5jdGlvbihhY2VxdWlyZSxleHBvcnRzKXtcXFxcXFxcInVzZSBzdHJpY3RcXFxcXFxcIjtleHBvcnRzLmxhc3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIGFbYS5sZW5ndGgtMV19LGV4cG9ydHMuc3RyaW5nUmV2ZXJzZT1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcuc3BsaXQoXFxcXFxcXCJcXFxcXFxcIikucmV2ZXJzZSgpLmpvaW4oXFxcXFxcXCJcXFxcXFxcIil9LGV4cG9ydHMuc3RyaW5nUmVwZWF0PWZ1bmN0aW9uKHN0cmluZyxjb3VudCl7Zm9yKHZhciByZXN1bHQ9XFxcXFxcXCJcXFxcXFxcIjtjb3VudD4wOykxJmNvdW50JiYocmVzdWx0Kz1zdHJpbmcpLChjb3VudD4+PTEpJiYoc3RyaW5nKz1zdHJpbmcpO3JldHVybiByZXN1bHR9O3ZhciB0cmltQmVnaW5SZWdleHA9L15cXFxcXFxcXHNcXFxcXFxcXHMqLyx0cmltRW5kUmVnZXhwPS9cXFxcXFxcXHNcXFxcXFxcXHMqJC87ZXhwb3J0cy5zdHJpbmdUcmltTGVmdD1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsXFxcXFxcXCJcXFxcXFxcIil9LGV4cG9ydHMuc3RyaW5nVHJpbVJpZ2h0PWZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIHN0cmluZy5yZXBsYWNlKHRyaW1FbmRSZWdleHAsXFxcXFxcXCJcXFxcXFxcIil9LGV4cG9ydHMuY29weU9iamVjdD1mdW5jdGlvbihvYmope3ZhciBjb3B5PXt9O2Zvcih2YXIga2V5IGluIG9iailjb3B5W2tleV09b2JqW2tleV07cmV0dXJuIGNvcHl9LGV4cG9ydHMuY29weUFycmF5PWZ1bmN0aW9uKGFycmF5KXtmb3IodmFyIGNvcHk9W10saT0wLGw9YXJyYXkubGVuZ3RoO2w+aTtpKyspY29weVtpXT1hcnJheVtpXSYmXFxcXFxcXCJvYmplY3RcXFxcXFxcIj09dHlwZW9mIGFycmF5W2ldP3RoaXMuY29weU9iamVjdChhcnJheVtpXSk6YXJyYXlbaV07cmV0dXJuIGNvcHl9LGV4cG9ydHMuZGVlcENvcHk9ZnVuY3Rpb24ob2JqKXtpZihcXFxcXFxcIm9iamVjdFxcXFxcXFwiIT10eXBlb2Ygb2JqfHwhb2JqKXJldHVybiBvYmo7dmFyIGNvbnM9b2JqLmNvbnN0cnVjdG9yO2lmKGNvbnM9PT1SZWdFeHApcmV0dXJuIG9iajt2YXIgY29weT1jb25zKCk7Zm9yKHZhciBrZXkgaW4gb2JqKWNvcHlba2V5XT1cXFxcXFxcIm9iamVjdFxcXFxcXFwiPT10eXBlb2Ygb2JqW2tleV0/ZXhwb3J0cy5kZWVwQ29weShvYmpba2V5XSk6b2JqW2tleV07cmV0dXJuIGNvcHl9LGV4cG9ydHMuYXJyYXlUb01hcD1mdW5jdGlvbihhcnIpe2Zvcih2YXIgbWFwPXt9LGk9MDthcnIubGVuZ3RoPmk7aSsrKW1hcFthcnJbaV1dPTE7cmV0dXJuIG1hcH0sZXhwb3J0cy5jcmVhdGVNYXA9ZnVuY3Rpb24ocHJvcHMpe3ZhciBtYXA9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IodmFyIGkgaW4gcHJvcHMpbWFwW2ldPXByb3BzW2ldO3JldHVybiBtYXB9LGV4cG9ydHMuYXJyYXlSZW1vdmU9ZnVuY3Rpb24oYXJyYXksdmFsdWUpe2Zvcih2YXIgaT0wO2FycmF5Lmxlbmd0aD49aTtpKyspdmFsdWU9PT1hcnJheVtpXSYmYXJyYXkuc3BsaWNlKGksMSl9LGV4cG9ydHMuZXNjYXBlUmVnRXhwPWZ1bmN0aW9uKHN0cil7cmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4qKz9eJHt9KCl8W1xcXFxcXFxcXVxcXFxcXFxcL1xcXFxcXFxcXFxcXFxcXFxdKS9nLFxcXFxcXFwiXFxcXFxcXFxcXFxcXFxcXCQxXFxcXFxcXCIpfSxleHBvcnRzLmVzY2FwZUhUTUw9ZnVuY3Rpb24oc3RyKXtyZXR1cm4gc3RyLnJlcGxhY2UoLyYvZyxcXFxcXFxcIiYjMzg7XFxcXFxcXCIpLnJlcGxhY2UoL1xcXFxcXFwiL2csXFxcXFxcXCImIzM0O1xcXFxcXFwiKS5yZXBsYWNlKC8nL2csXFxcXFxcXCImIzM5O1xcXFxcXFwiKS5yZXBsYWNlKC88L2csXFxcXFxcXCImIzYwO1xcXFxcXFwiKX0sZXhwb3J0cy5nZXRNYXRjaE9mZnNldHM9ZnVuY3Rpb24oc3RyaW5nLHJlZ0V4cCl7dmFyIG1hdGNoZXM9W107cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ0V4cCxmdW5jdGlvbihzdHIpe21hdGNoZXMucHVzaCh7b2Zmc2V0OmFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTJdLGxlbmd0aDpzdHIubGVuZ3RofSl9KSxtYXRjaGVzfSxleHBvcnRzLmRlZmVycmVkQ2FsbD1mdW5jdGlvbihmY24pe3ZhciB0aW1lcj1udWxsLGNhbGxiYWNrPWZ1bmN0aW9uKCl7dGltZXI9bnVsbCxmY24oKX0sZGVmZXJyZWQ9ZnVuY3Rpb24odGltZW91dCl7cmV0dXJuIGRlZmVycmVkLmNhbmNlbCgpLHRpbWVyPXNldFRpbWVvdXQoY2FsbGJhY2ssdGltZW91dHx8MCksZGVmZXJyZWR9O3JldHVybiBkZWZlcnJlZC5zY2hlZHVsZT1kZWZlcnJlZCxkZWZlcnJlZC5jYWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FuY2VsKCksZmNuKCksZGVmZXJyZWR9LGRlZmVycmVkLmNhbmNlbD1mdW5jdGlvbigpe3JldHVybiBjbGVhclRpbWVvdXQodGltZXIpLHRpbWVyPW51bGwsZGVmZXJyZWR9LGRlZmVycmVkLmlzUGVuZGluZz1mdW5jdGlvbigpe3JldHVybiB0aW1lcn0sZGVmZXJyZWR9LGV4cG9ydHMuZGVsYXllZENhbGw9ZnVuY3Rpb24oZmNuLGRlZmF1bHRUaW1lb3V0KXt2YXIgdGltZXI9bnVsbCxjYWxsYmFjaz1mdW5jdGlvbigpe3RpbWVyPW51bGwsZmNuKCl9LF9zZWxmPWZ1bmN0aW9uKHRpbWVvdXQpe251bGw9PXRpbWVyJiYodGltZXI9c2V0VGltZW91dChjYWxsYmFjayx0aW1lb3V0fHxkZWZhdWx0VGltZW91dCkpfTtyZXR1cm4gX3NlbGYuZGVsYXk9ZnVuY3Rpb24odGltZW91dCl7dGltZXImJmNsZWFyVGltZW91dCh0aW1lciksdGltZXI9c2V0VGltZW91dChjYWxsYmFjayx0aW1lb3V0fHxkZWZhdWx0VGltZW91dCl9LF9zZWxmLnNjaGVkdWxlPV9zZWxmLF9zZWxmLmNhbGw9ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbCgpLGZjbigpfSxfc2VsZi5jYW5jZWw9ZnVuY3Rpb24oKXt0aW1lciYmY2xlYXJUaW1lb3V0KHRpbWVyKSx0aW1lcj1udWxsfSxfc2VsZi5pc1BlbmRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGltZXJ9LF9zZWxmfX0pLGFjZS5kZWZpbmUoXFxcXFxcXCJhY2Uvd29ya2VyL21pcnJvclxcXFxcXFwiLFtcXFxcXFxcInJlcXVpcmVcXFxcXFxcIixcXFxcXFxcImV4cG9ydHNcXFxcXFxcIixcXFxcXFxcIm1vZHVsZVxcXFxcXFwiLFxcXFxcXFwiYWNlL2RvY3VtZW50XFxcXFxcXCIsXFxcXFxcXCJhY2UvbGliL2xhbmdcXFxcXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcXFxcXCJ1c2Ugc3RyaWN0XFxcXFxcXCI7dmFyIERvY3VtZW50PWFjZXF1aXJlKFxcXFxcXFwiLi4vZG9jdW1lbnRcXFxcXFxcIikuRG9jdW1lbnQsbGFuZz1hY2VxdWlyZShcXFxcXFxcIi4uL2xpYi9sYW5nXFxcXFxcXCIpLE1pcnJvcj1leHBvcnRzLk1pcnJvcj1mdW5jdGlvbihzZW5kZXIpe3RoaXMuc2VuZGVyPXNlbmRlcjt2YXIgZG9jPXRoaXMuZG9jPW5ldyBEb2N1bWVudChcXFxcXFxcIlxcXFxcXFwiKSxkZWZlcnJlZFVwZGF0ZT10aGlzLmRlZmVycmVkVXBkYXRlPWxhbmcuZGVsYXllZENhbGwodGhpcy5vblVwZGF0ZS5iaW5kKHRoaXMpKSxfc2VsZj10aGlzO3NlbmRlci5vbihcXFxcXFxcImNoYW5nZVxcXFxcXFwiLGZ1bmN0aW9uKGUpe3JldHVybiBkb2MuYXBwbHlEZWx0YXMoZS5kYXRhKSxfc2VsZi4kdGltZW91dD9kZWZlcnJlZFVwZGF0ZS5zY2hlZHVsZShfc2VsZi4kdGltZW91dCk6KF9zZWxmLm9uVXBkYXRlKCksdm9pZCAwKX0pfTsoZnVuY3Rpb24oKXt0aGlzLiR0aW1lb3V0PTUwMCx0aGlzLnNldFRpbWVvdXQ9ZnVuY3Rpb24odGltZW91dCl7dGhpcy4kdGltZW91dD10aW1lb3V0fSx0aGlzLnNldFZhbHVlPWZ1bmN0aW9uKHZhbHVlKXt0aGlzLmRvYy5zZXRWYWx1ZSh2YWx1ZSksdGhpcy5kZWZlcnJlZFVwZGF0ZS5zY2hlZHVsZSh0aGlzLiR0aW1lb3V0KX0sdGhpcy5nZXRWYWx1ZT1mdW5jdGlvbihjYWxsYmFja0lkKXt0aGlzLnNlbmRlci5jYWxsYmFjayh0aGlzLmRvYy5nZXRWYWx1ZSgpLGNhbGxiYWNrSWQpfSx0aGlzLm9uVXBkYXRlPWZ1bmN0aW9uKCl7fSx0aGlzLmlzUGVuZGluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlZmVycmVkVXBkYXRlLmlzUGVuZGluZygpfX0pLmNhbGwoTWlycm9yLnByb3RvdHlwZSl9KSxhY2UuZGVmaW5lKFxcXFxcXFwiYWNlL21vZGUvanNvbi9qc29uX3BhcnNlXFxcXFxcXCIsW1xcXFxcXFwicmVxdWlyZVxcXFxcXFwiLFxcXFxcXFwiZXhwb3J0c1xcXFxcXFwiLFxcXFxcXFwibW9kdWxlXFxcXFxcXCJdLGZ1bmN0aW9uKCl7XFxcXFxcXCJ1c2Ugc3RyaWN0XFxcXFxcXCI7dmFyIGF0LGNoLHRleHQsdmFsdWUsZXNjYXBlZT17J1xcXFxcXFwiJzonXFxcXFxcXCInLFxcXFxcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiLFxcXFxcXFwiL1xcXFxcXFwiOlxcXFxcXFwiL1xcXFxcXFwiLGI6XFxcXFxcXCJcXFxcXFxcXGJcXFxcXFxcIixmOlxcXFxcXFwiXFxcXFxcXFxmXFxcXFxcXCIsbjpcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiLHI6XFxcXFxcXCJcXFxcXFxcXHJcXFxcXFxcIix0OlxcXFxcXFwiXFxcXHRcXFxcXFxcIn0sZXJyb3I9ZnVuY3Rpb24obSl7dGhyb3d7bmFtZTpcXFxcXFxcIlN5bnRheEVycm9yXFxcXFxcXCIsbWVzc2FnZTptLGF0OmF0LHRleHQ6dGV4dH19LG5leHQ9ZnVuY3Rpb24oYyl7cmV0dXJuIGMmJmMhPT1jaCYmZXJyb3IoXFxcXFxcXCJFeHBlY3RlZCAnXFxcXFxcXCIrYytcXFxcXFxcIicgaW5zdGVhZCBvZiAnXFxcXFxcXCIrY2grXFxcXFxcXCInXFxcXFxcXCIpLGNoPXRleHQuY2hhckF0KGF0KSxhdCs9MSxjaH0sbnVtYmVyPWZ1bmN0aW9uKCl7dmFyIG51bWJlcixzdHJpbmc9XFxcXFxcXCJcXFxcXFxcIjtmb3IoXFxcXFxcXCItXFxcXFxcXCI9PT1jaCYmKHN0cmluZz1cXFxcXFxcIi1cXFxcXFxcIixuZXh0KFxcXFxcXFwiLVxcXFxcXFwiKSk7Y2g+PVxcXFxcXFwiMFxcXFxcXFwiJiZcXFxcXFxcIjlcXFxcXFxcIj49Y2g7KXN0cmluZys9Y2gsbmV4dCgpO2lmKFxcXFxcXFwiLlxcXFxcXFwiPT09Y2gpZm9yKHN0cmluZys9XFxcXFxcXCIuXFxcXFxcXCI7bmV4dCgpJiZjaD49XFxcXFxcXCIwXFxcXFxcXCImJlxcXFxcXFwiOVxcXFxcXFwiPj1jaDspc3RyaW5nKz1jaDtpZihcXFxcXFxcImVcXFxcXFxcIj09PWNofHxcXFxcXFxcIkVcXFxcXFxcIj09PWNoKWZvcihzdHJpbmcrPWNoLG5leHQoKSwoXFxcXFxcXCItXFxcXFxcXCI9PT1jaHx8XFxcXFxcXCIrXFxcXFxcXCI9PT1jaCkmJihzdHJpbmcrPWNoLG5leHQoKSk7Y2g+PVxcXFxcXFwiMFxcXFxcXFwiJiZcXFxcXFxcIjlcXFxcXFxcIj49Y2g7KXN0cmluZys9Y2gsbmV4dCgpO3JldHVybiBudW1iZXI9K3N0cmluZyxpc05hTihudW1iZXIpPyhlcnJvcihcXFxcXFxcIkJhZCBudW1iZXJcXFxcXFxcIiksdm9pZCAwKTpudW1iZXJ9LHN0cmluZz1mdW5jdGlvbigpe3ZhciBoZXgsaSx1ZmZmZixzdHJpbmc9XFxcXFxcXCJcXFxcXFxcIjtpZignXFxcXFxcXCInPT09Y2gpZm9yKDtuZXh0KCk7KXtpZignXFxcXFxcXCInPT09Y2gpcmV0dXJuIG5leHQoKSxzdHJpbmc7aWYoXFxcXFxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCI9PT1jaClpZihuZXh0KCksXFxcXFxcXCJ1XFxcXFxcXCI9PT1jaCl7Zm9yKHVmZmZmPTAsaT0wOzQ+aSYmKGhleD1wYXJzZUludChuZXh0KCksMTYpLGlzRmluaXRlKGhleCkpO2krPTEpdWZmZmY9MTYqdWZmZmYraGV4O3N0cmluZys9U3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZil9ZWxzZXtpZihcXFxcXFxcInN0cmluZ1xcXFxcXFwiIT10eXBlb2YgZXNjYXBlZVtjaF0pYnJlYWs7c3RyaW5nKz1lc2NhcGVlW2NoXX1lbHNlIHN0cmluZys9Y2h9ZXJyb3IoXFxcXFxcXCJCYWQgc3RyaW5nXFxcXFxcXCIpfSx3aGl0ZT1mdW5jdGlvbigpe2Zvcig7Y2gmJlxcXFxcXFwiIFxcXFxcXFwiPj1jaDspbmV4dCgpfSx3b3JkPWZ1bmN0aW9uKCl7c3dpdGNoKGNoKXtjYXNlXFxcXFxcXCJ0XFxcXFxcXCI6cmV0dXJuIG5leHQoXFxcXFxcXCJ0XFxcXFxcXCIpLG5leHQoXFxcXFxcXCJyXFxcXFxcXCIpLG5leHQoXFxcXFxcXCJ1XFxcXFxcXCIpLG5leHQoXFxcXFxcXCJlXFxcXFxcXCIpLCEwO2Nhc2VcXFxcXFxcImZcXFxcXFxcIjpyZXR1cm4gbmV4dChcXFxcXFxcImZcXFxcXFxcIiksbmV4dChcXFxcXFxcImFcXFxcXFxcIiksbmV4dChcXFxcXFxcImxcXFxcXFxcIiksbmV4dChcXFxcXFxcInNcXFxcXFxcIiksbmV4dChcXFxcXFxcImVcXFxcXFxcIiksITE7Y2FzZVxcXFxcXFwiblxcXFxcXFwiOnJldHVybiBuZXh0KFxcXFxcXFwiblxcXFxcXFwiKSxuZXh0KFxcXFxcXFwidVxcXFxcXFwiKSxuZXh0KFxcXFxcXFwibFxcXFxcXFwiKSxuZXh0KFxcXFxcXFwibFxcXFxcXFwiKSxudWxsfWVycm9yKFxcXFxcXFwiVW5leHBlY3RlZCAnXFxcXFxcXCIrY2grXFxcXFxcXCInXFxcXFxcXCIpfSxhcnJheT1mdW5jdGlvbigpe3ZhciBhcnJheT1bXTtpZihcXFxcXFxcIltcXFxcXFxcIj09PWNoKXtpZihuZXh0KFxcXFxcXFwiW1xcXFxcXFwiKSx3aGl0ZSgpLFxcXFxcXFwiXVxcXFxcXFwiPT09Y2gpcmV0dXJuIG5leHQoXFxcXFxcXCJdXFxcXFxcXCIpLGFycmF5O2Zvcig7Y2g7KXtpZihhcnJheS5wdXNoKHZhbHVlKCkpLHdoaXRlKCksXFxcXFxcXCJdXFxcXFxcXCI9PT1jaClyZXR1cm4gbmV4dChcXFxcXFxcIl1cXFxcXFxcIiksYXJyYXk7bmV4dChcXFxcXFxcIixcXFxcXFxcIiksd2hpdGUoKX19ZXJyb3IoXFxcXFxcXCJCYWQgYXJyYXlcXFxcXFxcIil9LG9iamVjdD1mdW5jdGlvbigpe3ZhciBrZXksb2JqZWN0PXt9O2lmKFxcXFxcXFwie1xcXFxcXFwiPT09Y2gpe2lmKG5leHQoXFxcXFxcXCJ7XFxcXFxcXCIpLHdoaXRlKCksXFxcXFxcXCJ9XFxcXFxcXCI9PT1jaClyZXR1cm4gbmV4dChcXFxcXFxcIn1cXFxcXFxcIiksb2JqZWN0O2Zvcig7Y2g7KXtpZihrZXk9c3RyaW5nKCksd2hpdGUoKSxuZXh0KFxcXFxcXFwiOlxcXFxcXFwiKSxPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qsa2V5KSYmZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXFxcXFxcXCInK2tleSsnXFxcXFxcXCInKSxvYmplY3Rba2V5XT12YWx1ZSgpLHdoaXRlKCksXFxcXFxcXCJ9XFxcXFxcXCI9PT1jaClyZXR1cm4gbmV4dChcXFxcXFxcIn1cXFxcXFxcIiksb2JqZWN0O25leHQoXFxcXFxcXCIsXFxcXFxcXCIpLHdoaXRlKCl9fWVycm9yKFxcXFxcXFwiQmFkIG9iamVjdFxcXFxcXFwiKX07cmV0dXJuIHZhbHVlPWZ1bmN0aW9uKCl7c3dpdGNoKHdoaXRlKCksY2gpe2Nhc2VcXFxcXFxcIntcXFxcXFxcIjpyZXR1cm4gb2JqZWN0KCk7Y2FzZVxcXFxcXFwiW1xcXFxcXFwiOnJldHVybiBhcnJheSgpO2Nhc2UnXFxcXFxcXCInOnJldHVybiBzdHJpbmcoKTtjYXNlXFxcXFxcXCItXFxcXFxcXCI6cmV0dXJuIG51bWJlcigpO2RlZmF1bHQ6cmV0dXJuIGNoPj1cXFxcXFxcIjBcXFxcXFxcIiYmXFxcXFxcXCI5XFxcXFxcXCI+PWNoP251bWJlcigpOndvcmQoKX19LGZ1bmN0aW9uKHNvdXJjZSxyZXZpdmVyKXt2YXIgcmVzdWx0O3JldHVybiB0ZXh0PXNvdXJjZSxhdD0wLGNoPVxcXFxcXFwiIFxcXFxcXFwiLHJlc3VsdD12YWx1ZSgpLHdoaXRlKCksY2gmJmVycm9yKFxcXFxcXFwiU3ludGF4IGVycm9yXFxcXFxcXCIpLFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIj09dHlwZW9mIHJldml2ZXI/ZnVuY3Rpb24gd2Fsayhob2xkZXIsa2V5KXt2YXIgayx2LHZhbHVlPWhvbGRlcltrZXldO2lmKHZhbHVlJiZcXFxcXFxcIm9iamVjdFxcXFxcXFwiPT10eXBlb2YgdmFsdWUpZm9yKGsgaW4gdmFsdWUpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsaykmJih2PXdhbGsodmFsdWUsayksdm9pZCAwIT09dj92YWx1ZVtrXT12OmRlbGV0ZSB2YWx1ZVtrXSk7cmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsa2V5LHZhbHVlKX0oe1xcXFxcXFwiXFxcXFxcXCI6cmVzdWx0fSxcXFxcXFxcIlxcXFxcXFwiKTpyZXN1bHR9fSksYWNlLmRlZmluZShcXFxcXFxcImFjZS9tb2RlL2pzb25fd29ya2VyXFxcXFxcXCIsW1xcXFxcXFwicmVxdWlyZVxcXFxcXFwiLFxcXFxcXFwiZXhwb3J0c1xcXFxcXFwiLFxcXFxcXFwibW9kdWxlXFxcXFxcXCIsXFxcXFxcXCJhY2UvbGliL29vcFxcXFxcXFwiLFxcXFxcXFwiYWNlL3dvcmtlci9taXJyb3JcXFxcXFxcIixcXFxcXFxcImFjZS9tb2RlL2pzb24vanNvbl9wYXJzZVxcXFxcXFwiXSxmdW5jdGlvbihhY2VxdWlyZSxleHBvcnRzKXtcXFxcXFxcInVzZSBzdHJpY3RcXFxcXFxcIjt2YXIgb29wPWFjZXF1aXJlKFxcXFxcXFwiLi4vbGliL29vcFxcXFxcXFwiKSxNaXJyb3I9YWNlcXVpcmUoXFxcXFxcXCIuLi93b3JrZXIvbWlycm9yXFxcXFxcXCIpLk1pcnJvcixwYXJzZT1hY2VxdWlyZShcXFxcXFxcIi4vanNvbi9qc29uX3BhcnNlXFxcXFxcXCIpLEpzb25Xb3JrZXI9ZXhwb3J0cy5Kc29uV29ya2VyPWZ1bmN0aW9uKHNlbmRlcil7TWlycm9yLmNhbGwodGhpcyxzZW5kZXIpLHRoaXMuc2V0VGltZW91dCgyMDApfTtvb3AuaW5oZXJpdHMoSnNvbldvcmtlcixNaXJyb3IpLGZ1bmN0aW9uKCl7dGhpcy5vblVwZGF0ZT1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLmRvYy5nZXRWYWx1ZSgpO3RyeXt2YWx1ZSYmcGFyc2UodmFsdWUpfWNhdGNoKGUpe3ZhciBwb3M9dGhpcy5kb2MuaW5kZXhUb1Bvc2l0aW9uKGUuYXQtMSk7cmV0dXJuIHRoaXMuc2VuZGVyLmVtaXQoXFxcXFxcXCJlcnJvclxcXFxcXFwiLHtyb3c6cG9zLnJvdyxjb2x1bW46cG9zLmNvbHVtbix0ZXh0OmUubWVzc2FnZSx0eXBlOlxcXFxcXFwiZXJyb3JcXFxcXFxcIn0pLHZvaWQgMH10aGlzLnNlbmRlci5lbWl0KFxcXFxcXFwib2tcXFxcXFxcIil9fS5jYWxsKEpzb25Xb3JrZXIucHJvdG90eXBlKX0pLGFjZS5kZWZpbmUoXFxcXFxcXCJhY2UvbGliL2VzNS1zaGltXFxcXFxcXCIsW1xcXFxcXFwicmVxdWlyZVxcXFxcXFwiLFxcXFxcXFwiZXhwb3J0c1xcXFxcXFwiLFxcXFxcXFwibW9kdWxlXFxcXFxcXCJdLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gRW1wdHkoKXt9ZnVuY3Rpb24gZG9lc0RlZmluZVByb3BlcnR5V29yayhvYmplY3Qpe3RyeXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCxcXFxcXFxcInNlbnRpbmVsXFxcXFxcXCIse30pLFxcXFxcXFwic2VudGluZWxcXFxcXFxcImluIG9iamVjdH1jYXRjaChleGNlcHRpb24pe319ZnVuY3Rpb24gdG9JbnRlZ2VyKG4pe3JldHVybiBuPStuLG4hPT1uP249MDowIT09biYmbiE9PTEvMCYmbiE9PS0oMS8wKSYmKG49KG4+MHx8LTEpKk1hdGguZmxvb3IoTWF0aC5hYnMobikpKSxufUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHwoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24odGhhdCl7dmFyIHRhcmdldD10aGlzO2lmKFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIiE9dHlwZW9mIHRhcmdldCl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXFxcXFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcXFxcXFxcIit0YXJnZXQpO3ZhciBhcmdzPXNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGJvdW5kPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIGJvdW5kKXt2YXIgcmVzdWx0PXRhcmdldC5hcHBseSh0aGlzLGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO3JldHVybiBPYmplY3QocmVzdWx0KT09PXJlc3VsdD9yZXN1bHQ6dGhpc31yZXR1cm4gdGFyZ2V0LmFwcGx5KHRoYXQsYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSl9O3JldHVybiB0YXJnZXQucHJvdG90eXBlJiYoRW1wdHkucHJvdG90eXBlPXRhcmdldC5wcm90b3R5cGUsYm91bmQucHJvdG90eXBlPW5ldyBFbXB0eSxFbXB0eS5wcm90b3R5cGU9bnVsbCksYm91bmR9KTt2YXIgZGVmaW5lR2V0dGVyLGRlZmluZVNldHRlcixsb29rdXBHZXR0ZXIsbG9va3VwU2V0dGVyLHN1cHBvcnRzQWNjZXNzb3JzLGNhbGw9RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwscHJvdG90eXBlT2ZBcnJheT1BcnJheS5wcm90b3R5cGUscHJvdG90eXBlT2ZPYmplY3Q9T2JqZWN0LnByb3RvdHlwZSxzbGljZT1wcm90b3R5cGVPZkFycmF5LnNsaWNlLF90b1N0cmluZz1jYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QudG9TdHJpbmcpLG93bnM9Y2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtpZigoc3VwcG9ydHNBY2Nlc3NvcnM9b3ducyhwcm90b3R5cGVPZk9iamVjdCxcXFxcXFxcIl9fZGVmaW5lR2V0dGVyX19cXFxcXFxcIikpJiYoZGVmaW5lR2V0dGVyPWNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZUdldHRlcl9fKSxkZWZpbmVTZXR0ZXI9Y2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18pLGxvb2t1cEdldHRlcj1jYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBHZXR0ZXJfXyksbG9va3VwU2V0dGVyPWNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2xvb2t1cFNldHRlcl9fKSksMiE9WzEsMl0uc3BsaWNlKDApLmxlbmd0aClpZihmdW5jdGlvbigpe2Z1bmN0aW9uIG1ha2VBcnJheShsKXt2YXIgYT1BcnJheShsKzIpO3JldHVybiBhWzBdPWFbMV09MCxhfXZhciBsZW5ndGhCZWZvcmUsYXJyYXk9W107cmV0dXJuIGFycmF5LnNwbGljZS5hcHBseShhcnJheSxtYWtlQXJyYXkoMjApKSxhcnJheS5zcGxpY2UuYXBwbHkoYXJyYXksbWFrZUFycmF5KDI2KSksbGVuZ3RoQmVmb3JlPWFycmF5Lmxlbmd0aCxhcnJheS5zcGxpY2UoNSwwLFxcXFxcXFwiWFhYXFxcXFxcXCIpLGxlbmd0aEJlZm9yZSsxPT1hcnJheS5sZW5ndGgsbGVuZ3RoQmVmb3JlKzE9PWFycmF5Lmxlbmd0aD8hMDp2b2lkIDB9KCkpe3ZhciBhcnJheV9zcGxpY2U9QXJyYXkucHJvdG90eXBlLnNwbGljZTtBcnJheS5wcm90b3R5cGUuc3BsaWNlPWZ1bmN0aW9uKHN0YXJ0LGRlbGV0ZUNvdW50KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD9hcnJheV9zcGxpY2UuYXBwbHkodGhpcyxbdm9pZCAwPT09c3RhcnQ/MDpzdGFydCx2b2lkIDA9PT1kZWxldGVDb3VudD90aGlzLmxlbmd0aC1zdGFydDpkZWxldGVDb3VudF0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLDIpKSk6W119fWVsc2UgQXJyYXkucHJvdG90eXBlLnNwbGljZT1mdW5jdGlvbihwb3MscmVtb3ZlQ291bnQpe3ZhciBsZW5ndGg9dGhpcy5sZW5ndGg7cG9zPjA/cG9zPmxlbmd0aCYmKHBvcz1sZW5ndGgpOnZvaWQgMD09cG9zP3Bvcz0wOjA+cG9zJiYocG9zPU1hdGgubWF4KGxlbmd0aCtwb3MsMCkpLGxlbmd0aD5wb3MrcmVtb3ZlQ291bnR8fChyZW1vdmVDb3VudD1sZW5ndGgtcG9zKTt2YXIgcmVtb3ZlZD10aGlzLnNsaWNlKHBvcyxwb3MrcmVtb3ZlQ291bnQpLGluc2VydD1zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxhZGQ9aW5zZXJ0Lmxlbmd0aDtpZihwb3M9PT1sZW5ndGgpYWRkJiZ0aGlzLnB1c2guYXBwbHkodGhpcyxpbnNlcnQpO2Vsc2V7dmFyIHJlbW92ZT1NYXRoLm1pbihyZW1vdmVDb3VudCxsZW5ndGgtcG9zKSx0YWlsT2xkUG9zPXBvcytyZW1vdmUsdGFpbE5ld1Bvcz10YWlsT2xkUG9zK2FkZC1yZW1vdmUsdGFpbENvdW50PWxlbmd0aC10YWlsT2xkUG9zLGxlbmd0aEFmdGVyUmVtb3ZlPWxlbmd0aC1yZW1vdmU7aWYodGFpbE9sZFBvcz50YWlsTmV3UG9zKWZvcih2YXIgaT0wO3RhaWxDb3VudD5pOysraSl0aGlzW3RhaWxOZXdQb3MraV09dGhpc1t0YWlsT2xkUG9zK2ldO2Vsc2UgaWYodGFpbE5ld1Bvcz50YWlsT2xkUG9zKWZvcihpPXRhaWxDb3VudDtpLS07KXRoaXNbdGFpbE5ld1BvcytpXT10aGlzW3RhaWxPbGRQb3MraV07aWYoYWRkJiZwb3M9PT1sZW5ndGhBZnRlclJlbW92ZSl0aGlzLmxlbmd0aD1sZW5ndGhBZnRlclJlbW92ZSx0aGlzLnB1c2guYXBwbHkodGhpcyxpbnNlcnQpO2Vsc2UgZm9yKHRoaXMubGVuZ3RoPWxlbmd0aEFmdGVyUmVtb3ZlK2FkZCxpPTA7YWRkPmk7KytpKXRoaXNbcG9zK2ldPWluc2VydFtpXX1yZXR1cm4gcmVtb3ZlZH07QXJyYXkuaXNBcnJheXx8KEFycmF5LmlzQXJyYXk9ZnVuY3Rpb24ob2JqKXtyZXR1cm5cXFxcXFxcIltvYmplY3QgQXJyYXldXFxcXFxcXCI9PV90b1N0cmluZyhvYmopfSk7dmFyIGJveGVkU3RyaW5nPU9iamVjdChcXFxcXFxcImFcXFxcXFxcIiksc3BsaXRTdHJpbmc9XFxcXFxcXCJhXFxcXFxcXCIhPWJveGVkU3RyaW5nWzBdfHwhKDAgaW4gYm94ZWRTdHJpbmcpO2lmKEFycmF5LnByb3RvdHlwZS5mb3JFYWNofHwoQXJyYXkucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oZnVuKXt2YXIgb2JqZWN0PXRvT2JqZWN0KHRoaXMpLHNlbGY9c3BsaXRTdHJpbmcmJlxcXFxcXFwiW29iamVjdCBTdHJpbmddXFxcXFxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXFxcXFwiXFxcXFxcXCIpOm9iamVjdCx0aGlzcD1hcmd1bWVudHNbMV0saT0tMSxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wO2lmKFxcXFxcXFwiW29iamVjdCBGdW5jdGlvbl1cXFxcXFxcIiE9X3RvU3RyaW5nKGZ1bikpdGhyb3cgbmV3IFR5cGVFcnJvcjtcXFxcbmZvcig7bGVuZ3RoPisraTspaSBpbiBzZWxmJiZmdW4uY2FsbCh0aGlzcCxzZWxmW2ldLGksb2JqZWN0KX0pLEFycmF5LnByb3RvdHlwZS5tYXB8fChBcnJheS5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKGZ1bil7dmFyIG9iamVjdD10b09iamVjdCh0aGlzKSxzZWxmPXNwbGl0U3RyaW5nJiZcXFxcXFxcIltvYmplY3QgU3RyaW5nXVxcXFxcXFwiPT1fdG9TdHJpbmcodGhpcyk/dGhpcy5zcGxpdChcXFxcXFxcIlxcXFxcXFwiKTpvYmplY3QsbGVuZ3RoPXNlbGYubGVuZ3RoPj4+MCxyZXN1bHQ9QXJyYXkobGVuZ3RoKSx0aGlzcD1hcmd1bWVudHNbMV07aWYoXFxcXFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXFxcXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bitcXFxcXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXFxcXFwiKTtmb3IodmFyIGk9MDtsZW5ndGg+aTtpKyspaSBpbiBzZWxmJiYocmVzdWx0W2ldPWZ1bi5jYWxsKHRoaXNwLHNlbGZbaV0saSxvYmplY3QpKTtyZXR1cm4gcmVzdWx0fSksQXJyYXkucHJvdG90eXBlLmZpbHRlcnx8KEFycmF5LnByb3RvdHlwZS5maWx0ZXI9ZnVuY3Rpb24oZnVuKXt2YXIgdmFsdWUsb2JqZWN0PXRvT2JqZWN0KHRoaXMpLHNlbGY9c3BsaXRTdHJpbmcmJlxcXFxcXFwiW29iamVjdCBTdHJpbmddXFxcXFxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXFxcXFwiXFxcXFxcXCIpOm9iamVjdCxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wLHJlc3VsdD1bXSx0aGlzcD1hcmd1bWVudHNbMV07aWYoXFxcXFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXFxcXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bitcXFxcXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXFxcXFwiKTtmb3IodmFyIGk9MDtsZW5ndGg+aTtpKyspaSBpbiBzZWxmJiYodmFsdWU9c2VsZltpXSxmdW4uY2FsbCh0aGlzcCx2YWx1ZSxpLG9iamVjdCkmJnJlc3VsdC5wdXNoKHZhbHVlKSk7cmV0dXJuIHJlc3VsdH0pLEFycmF5LnByb3RvdHlwZS5ldmVyeXx8KEFycmF5LnByb3RvdHlwZS5ldmVyeT1mdW5jdGlvbihmdW4pe3ZhciBvYmplY3Q9dG9PYmplY3QodGhpcyksc2VsZj1zcGxpdFN0cmluZyYmXFxcXFxcXCJbb2JqZWN0IFN0cmluZ11cXFxcXFxcIj09X3RvU3RyaW5nKHRoaXMpP3RoaXMuc3BsaXQoXFxcXFxcXCJcXFxcXFxcIik6b2JqZWN0LGxlbmd0aD1zZWxmLmxlbmd0aD4+PjAsdGhpc3A9YXJndW1lbnRzWzFdO2lmKFxcXFxcXFwiW29iamVjdCBGdW5jdGlvbl1cXFxcXFxcIiE9X3RvU3RyaW5nKGZ1bikpdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4rXFxcXFxcXCIgaXMgbm90IGEgZnVuY3Rpb25cXFxcXFxcIik7Zm9yKHZhciBpPTA7bGVuZ3RoPmk7aSsrKWlmKGkgaW4gc2VsZiYmIWZ1bi5jYWxsKHRoaXNwLHNlbGZbaV0saSxvYmplY3QpKXJldHVybiExO3JldHVybiEwfSksQXJyYXkucHJvdG90eXBlLnNvbWV8fChBcnJheS5wcm90b3R5cGUuc29tZT1mdW5jdGlvbihmdW4pe3ZhciBvYmplY3Q9dG9PYmplY3QodGhpcyksc2VsZj1zcGxpdFN0cmluZyYmXFxcXFxcXCJbb2JqZWN0IFN0cmluZ11cXFxcXFxcIj09X3RvU3RyaW5nKHRoaXMpP3RoaXMuc3BsaXQoXFxcXFxcXCJcXFxcXFxcIik6b2JqZWN0LGxlbmd0aD1zZWxmLmxlbmd0aD4+PjAsdGhpc3A9YXJndW1lbnRzWzFdO2lmKFxcXFxcXFwiW29iamVjdCBGdW5jdGlvbl1cXFxcXFxcIiE9X3RvU3RyaW5nKGZ1bikpdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4rXFxcXFxcXCIgaXMgbm90IGEgZnVuY3Rpb25cXFxcXFxcIik7Zm9yKHZhciBpPTA7bGVuZ3RoPmk7aSsrKWlmKGkgaW4gc2VsZiYmZnVuLmNhbGwodGhpc3Asc2VsZltpXSxpLG9iamVjdCkpcmV0dXJuITA7cmV0dXJuITF9KSxBcnJheS5wcm90b3R5cGUucmVkdWNlfHwoQXJyYXkucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbihmdW4pe3ZhciBvYmplY3Q9dG9PYmplY3QodGhpcyksc2VsZj1zcGxpdFN0cmluZyYmXFxcXFxcXCJbb2JqZWN0IFN0cmluZ11cXFxcXFxcIj09X3RvU3RyaW5nKHRoaXMpP3RoaXMuc3BsaXQoXFxcXFxcXCJcXFxcXFxcIik6b2JqZWN0LGxlbmd0aD1zZWxmLmxlbmd0aD4+PjA7aWYoXFxcXFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXFxcXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bitcXFxcXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXFxcXFwiKTtpZighbGVuZ3RoJiYxPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXFxcXFxcXCIpO3ZhciByZXN1bHQsaT0wO2lmKGFyZ3VtZW50cy5sZW5ndGg+PTIpcmVzdWx0PWFyZ3VtZW50c1sxXTtlbHNlIGZvcig7Oyl7aWYoaSBpbiBzZWxmKXtyZXN1bHQ9c2VsZltpKytdO2JyZWFrfWlmKCsraT49bGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXFxcXFxcXCIpfWZvcig7bGVuZ3RoPmk7aSsrKWkgaW4gc2VsZiYmKHJlc3VsdD1mdW4uY2FsbCh2b2lkIDAscmVzdWx0LHNlbGZbaV0saSxvYmplY3QpKTtyZXR1cm4gcmVzdWx0fSksQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0fHwoQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0PWZ1bmN0aW9uKGZ1bil7dmFyIG9iamVjdD10b09iamVjdCh0aGlzKSxzZWxmPXNwbGl0U3RyaW5nJiZcXFxcXFxcIltvYmplY3QgU3RyaW5nXVxcXFxcXFwiPT1fdG9TdHJpbmcodGhpcyk/dGhpcy5zcGxpdChcXFxcXFxcIlxcXFxcXFwiKTpvYmplY3QsbGVuZ3RoPXNlbGYubGVuZ3RoPj4+MDtpZihcXFxcXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcXFxcXCIhPV90b1N0cmluZyhmdW4pKXRocm93IG5ldyBUeXBlRXJyb3IoZnVuK1xcXFxcXFwiIGlzIG5vdCBhIGZ1bmN0aW9uXFxcXFxcXCIpO2lmKCFsZW5ndGgmJjE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFxcXFxcInJlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXFxcXFwiKTt2YXIgcmVzdWx0LGk9bGVuZ3RoLTE7aWYoYXJndW1lbnRzLmxlbmd0aD49MilyZXN1bHQ9YXJndW1lbnRzWzFdO2Vsc2UgZm9yKDs7KXtpZihpIGluIHNlbGYpe3Jlc3VsdD1zZWxmW2ktLV07YnJlYWt9aWYoMD4tLWkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFxcXFxcInJlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXFxcXFwiKX1kbyBpIGluIHRoaXMmJihyZXN1bHQ9ZnVuLmNhbGwodm9pZCAwLHJlc3VsdCxzZWxmW2ldLGksb2JqZWN0KSk7d2hpbGUoaS0tKTtyZXR1cm4gcmVzdWx0fSksQXJyYXkucHJvdG90eXBlLmluZGV4T2YmJi0xPT1bMCwxXS5pbmRleE9mKDEsMil8fChBcnJheS5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbihzb3VnaHQpe3ZhciBzZWxmPXNwbGl0U3RyaW5nJiZcXFxcXFxcIltvYmplY3QgU3RyaW5nXVxcXFxcXFwiPT1fdG9TdHJpbmcodGhpcyk/dGhpcy5zcGxpdChcXFxcXFxcIlxcXFxcXFwiKTp0b09iamVjdCh0aGlzKSxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wO2lmKCFsZW5ndGgpcmV0dXJuLTE7dmFyIGk9MDtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYoaT10b0ludGVnZXIoYXJndW1lbnRzWzFdKSksaT1pPj0wP2k6TWF0aC5tYXgoMCxsZW5ndGgraSk7bGVuZ3RoPmk7aSsrKWlmKGkgaW4gc2VsZiYmc2VsZltpXT09PXNvdWdodClyZXR1cm4gaTtyZXR1cm4tMX0pLEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiYmLTE9PVswLDFdLmxhc3RJbmRleE9mKDAsLTMpfHwoQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uKHNvdWdodCl7dmFyIHNlbGY9c3BsaXRTdHJpbmcmJlxcXFxcXFwiW29iamVjdCBTdHJpbmddXFxcXFxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXFxcXFwiXFxcXFxcXCIpOnRvT2JqZWN0KHRoaXMpLGxlbmd0aD1zZWxmLmxlbmd0aD4+PjA7aWYoIWxlbmd0aClyZXR1cm4tMTt2YXIgaT1sZW5ndGgtMTtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYoaT1NYXRoLm1pbihpLHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKSksaT1pPj0wP2k6bGVuZ3RoLU1hdGguYWJzKGkpO2k+PTA7aS0tKWlmKGkgaW4gc2VsZiYmc291Z2h0PT09c2VsZltpXSlyZXR1cm4gaTtyZXR1cm4tMX0pLE9iamVjdC5nZXRQcm90b3R5cGVPZnx8KE9iamVjdC5nZXRQcm90b3R5cGVPZj1mdW5jdGlvbihvYmplY3Qpe3JldHVybiBvYmplY3QuX19wcm90b19ffHwob2JqZWN0LmNvbnN0cnVjdG9yP29iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6cHJvdG90eXBlT2ZPYmplY3QpfSksIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ipe3ZhciBFUlJfTk9OX09CSkVDVD1cXFxcXFxcIk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgY2FsbGVkIG9uIGEgbm9uLW9iamVjdDogXFxcXFxcXCI7T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj1mdW5jdGlvbihvYmplY3QscHJvcGVydHkpe2lmKFxcXFxcXFwib2JqZWN0XFxcXFxcXCIhPXR5cGVvZiBvYmplY3QmJlxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIiE9dHlwZW9mIG9iamVjdHx8bnVsbD09PW9iamVjdCl0aHJvdyBuZXcgVHlwZUVycm9yKEVSUl9OT05fT0JKRUNUK29iamVjdCk7aWYob3ducyhvYmplY3QscHJvcGVydHkpKXt2YXIgZGVzY3JpcHRvcixnZXR0ZXIsc2V0dGVyO2lmKGRlc2NyaXB0b3I9e2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSxzdXBwb3J0c0FjY2Vzc29ycyl7dmFyIHByb3RvdHlwZT1vYmplY3QuX19wcm90b19fO29iamVjdC5fX3Byb3RvX189cHJvdG90eXBlT2ZPYmplY3Q7dmFyIGdldHRlcj1sb29rdXBHZXR0ZXIob2JqZWN0LHByb3BlcnR5KSxzZXR0ZXI9bG9va3VwU2V0dGVyKG9iamVjdCxwcm9wZXJ0eSk7aWYob2JqZWN0Ll9fcHJvdG9fXz1wcm90b3R5cGUsZ2V0dGVyfHxzZXR0ZXIpcmV0dXJuIGdldHRlciYmKGRlc2NyaXB0b3IuZ2V0PWdldHRlciksc2V0dGVyJiYoZGVzY3JpcHRvci5zZXQ9c2V0dGVyKSxkZXNjcmlwdG9yfXJldHVybiBkZXNjcmlwdG9yLnZhbHVlPW9iamVjdFtwcm9wZXJ0eV0sZGVzY3JpcHRvcn19fWlmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzfHwoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM9ZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KX0pLCFPYmplY3QuY3JlYXRlKXt2YXIgY3JlYXRlRW1wdHk7Y3JlYXRlRW1wdHk9bnVsbD09PU9iamVjdC5wcm90b3R5cGUuX19wcm90b19fP2Z1bmN0aW9uKCl7cmV0dXJue19fcHJvdG9fXzpudWxsfX06ZnVuY3Rpb24oKXt2YXIgZW1wdHk9e307Zm9yKHZhciBpIGluIGVtcHR5KWVtcHR5W2ldPW51bGw7cmV0dXJuIGVtcHR5LmNvbnN0cnVjdG9yPWVtcHR5Lmhhc093blByb3BlcnR5PWVtcHR5LnByb3BlcnR5SXNFbnVtZXJhYmxlPWVtcHR5LmlzUHJvdG90eXBlT2Y9ZW1wdHkudG9Mb2NhbGVTdHJpbmc9ZW1wdHkudG9TdHJpbmc9ZW1wdHkudmFsdWVPZj1lbXB0eS5fX3Byb3RvX189bnVsbCxlbXB0eX0sT2JqZWN0LmNyZWF0ZT1mdW5jdGlvbihwcm90b3R5cGUscHJvcGVydGllcyl7dmFyIG9iamVjdDtpZihudWxsPT09cHJvdG90eXBlKW9iamVjdD1jcmVhdGVFbXB0eSgpO2Vsc2V7aWYoXFxcXFxcXCJvYmplY3RcXFxcXFxcIiE9dHlwZW9mIHByb3RvdHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXFxcXFwidHlwZW9mIHByb3RvdHlwZVtcXFxcXFxcIit0eXBlb2YgcHJvdG90eXBlK1xcXFxcXFwiXSAhPSAnb2JqZWN0J1xcXFxcXFwiKTt2YXIgVHlwZT1mdW5jdGlvbigpe307VHlwZS5wcm90b3R5cGU9cHJvdG90eXBlLG9iamVjdD1uZXcgVHlwZSxvYmplY3QuX19wcm90b19fPXByb3RvdHlwZX1yZXR1cm4gdm9pZCAwIT09cHJvcGVydGllcyYmT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LHByb3BlcnRpZXMpLG9iamVjdH19aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXt2YXIgZGVmaW5lUHJvcGVydHlXb3Jrc09uT2JqZWN0PWRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoe30pLGRlZmluZVByb3BlcnR5V29ya3NPbkRvbT1cXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiPT10eXBlb2YgZG9jdW1lbnR8fGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFxcXFxcImRpdlxcXFxcXFwiKSk7aWYoIWRlZmluZVByb3BlcnR5V29ya3NPbk9iamVjdHx8IWRlZmluZVByb3BlcnR5V29ya3NPbkRvbSl2YXIgZGVmaW5lUHJvcGVydHlGYWxsYmFjaz1PYmplY3QuZGVmaW5lUHJvcGVydHl9aWYoIU9iamVjdC5kZWZpbmVQcm9wZXJ0eXx8ZGVmaW5lUHJvcGVydHlGYWxsYmFjayl7dmFyIEVSUl9OT05fT0JKRUNUX0RFU0NSSVBUT1I9XFxcXFxcXCJQcm9wZXJ0eSBkZXNjcmlwdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogXFxcXFxcXCIsRVJSX05PTl9PQkpFQ1RfVEFSR0VUPVxcXFxcXFwiT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxlZCBvbiBub24tb2JqZWN0OiBcXFxcXFxcIixFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQ9XFxcXFxcXCJnZXR0ZXJzICYgc2V0dGVycyBjYW4gbm90IGJlIGRlZmluZWQgb24gdGhpcyBqYXZhc2NyaXB0IGVuZ2luZVxcXFxcXFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eT1mdW5jdGlvbihvYmplY3QscHJvcGVydHksZGVzY3JpcHRvcil7aWYoXFxcXFxcXCJvYmplY3RcXFxcXFxcIiE9dHlwZW9mIG9iamVjdCYmXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiIT10eXBlb2Ygb2JqZWN0fHxudWxsPT09b2JqZWN0KXRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfVEFSR0VUK29iamVjdCk7aWYoXFxcXFxcXCJvYmplY3RcXFxcXFxcIiE9dHlwZW9mIGRlc2NyaXB0b3ImJlxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIiE9dHlwZW9mIGRlc2NyaXB0b3J8fG51bGw9PT1kZXNjcmlwdG9yKXRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfREVTQ1JJUFRPUitkZXNjcmlwdG9yKTtpZihkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrKXRyeXtyZXR1cm4gZGVmaW5lUHJvcGVydHlGYWxsYmFjay5jYWxsKE9iamVjdCxvYmplY3QscHJvcGVydHksZGVzY3JpcHRvcil9Y2F0Y2goZXhjZXB0aW9uKXt9aWYob3ducyhkZXNjcmlwdG9yLFxcXFxcXFwidmFsdWVcXFxcXFxcIikpaWYoc3VwcG9ydHNBY2Nlc3NvcnMmJihsb29rdXBHZXR0ZXIob2JqZWN0LHByb3BlcnR5KXx8bG9va3VwU2V0dGVyKG9iamVjdCxwcm9wZXJ0eSkpKXt2YXIgcHJvdG90eXBlPW9iamVjdC5fX3Byb3RvX187b2JqZWN0Ll9fcHJvdG9fXz1wcm90b3R5cGVPZk9iamVjdCxkZWxldGUgb2JqZWN0W3Byb3BlcnR5XSxvYmplY3RbcHJvcGVydHldPWRlc2NyaXB0b3IudmFsdWUsb2JqZWN0Ll9fcHJvdG9fXz1wcm90b3R5cGV9ZWxzZSBvYmplY3RbcHJvcGVydHldPWRlc2NyaXB0b3IudmFsdWU7ZWxzZXtpZighc3VwcG9ydHNBY2Nlc3NvcnMpdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQpO293bnMoZGVzY3JpcHRvcixcXFxcXFxcImdldFxcXFxcXFwiKSYmZGVmaW5lR2V0dGVyKG9iamVjdCxwcm9wZXJ0eSxkZXNjcmlwdG9yLmdldCksb3ducyhkZXNjcmlwdG9yLFxcXFxcXFwic2V0XFxcXFxcXCIpJiZkZWZpbmVTZXR0ZXIob2JqZWN0LHByb3BlcnR5LGRlc2NyaXB0b3Iuc2V0KX1yZXR1cm4gb2JqZWN0fX1PYmplY3QuZGVmaW5lUHJvcGVydGllc3x8KE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzPWZ1bmN0aW9uKG9iamVjdCxwcm9wZXJ0aWVzKXtmb3IodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpb3ducyhwcm9wZXJ0aWVzLHByb3BlcnR5KSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCxwcm9wZXJ0eSxwcm9wZXJ0aWVzW3Byb3BlcnR5XSk7cmV0dXJuIG9iamVjdH0pLE9iamVjdC5zZWFsfHwoT2JqZWN0LnNlYWw9ZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gb2JqZWN0fSksT2JqZWN0LmZyZWV6ZXx8KE9iamVjdC5mcmVlemU9ZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gb2JqZWN0fSk7dHJ5e09iamVjdC5mcmVlemUoZnVuY3Rpb24oKXt9KX1jYXRjaChleGNlcHRpb24pe09iamVjdC5mcmVlemU9ZnVuY3Rpb24oZnJlZXplT2JqZWN0KXtyZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm5cXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCI9PXR5cGVvZiBvYmplY3Q/b2JqZWN0OmZyZWV6ZU9iamVjdChvYmplY3QpfX0oT2JqZWN0LmZyZWV6ZSl9aWYoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zfHwoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zPWZ1bmN0aW9uKG9iamVjdCl7cmV0dXJuIG9iamVjdH0pLE9iamVjdC5pc1NlYWxlZHx8KE9iamVjdC5pc1NlYWxlZD1mdW5jdGlvbigpe3JldHVybiExfSksT2JqZWN0LmlzRnJvemVufHwoT2JqZWN0LmlzRnJvemVuPWZ1bmN0aW9uKCl7cmV0dXJuITF9KSxPYmplY3QuaXNFeHRlbnNpYmxlfHwoT2JqZWN0LmlzRXh0ZW5zaWJsZT1mdW5jdGlvbihvYmplY3Qpe2lmKE9iamVjdChvYmplY3QpPT09b2JqZWN0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuYW1lPVxcXFxcXFwiXFxcXFxcXCI7b3ducyhvYmplY3QsbmFtZSk7KW5hbWUrPVxcXFxcXFwiP1xcXFxcXFwiO29iamVjdFtuYW1lXT0hMDt2YXIgcmV0dXJuVmFsdWU9b3ducyhvYmplY3QsbmFtZSk7cmV0dXJuIGRlbGV0ZSBvYmplY3RbbmFtZV0scmV0dXJuVmFsdWV9KSwhT2JqZWN0LmtleXMpe3ZhciBoYXNEb250RW51bUJ1Zz0hMCxkb250RW51bXM9W1xcXFxcXFwidG9TdHJpbmdcXFxcXFxcIixcXFxcXFxcInRvTG9jYWxlU3RyaW5nXFxcXFxcXCIsXFxcXFxcXCJ2YWx1ZU9mXFxcXFxcXCIsXFxcXFxcXCJoYXNPd25Qcm9wZXJ0eVxcXFxcXFwiLFxcXFxcXFwiaXNQcm90b3R5cGVPZlxcXFxcXFwiLFxcXFxcXFwicHJvcGVydHlJc0VudW1lcmFibGVcXFxcXFxcIixcXFxcXFxcImNvbnN0cnVjdG9yXFxcXFxcXCJdLGRvbnRFbnVtc0xlbmd0aD1kb250RW51bXMubGVuZ3RoO2Zvcih2YXIga2V5IGlue3RvU3RyaW5nOm51bGx9KWhhc0RvbnRFbnVtQnVnPSExO09iamVjdC5rZXlzPWZ1bmN0aW9uKG9iamVjdCl7aWYoXFxcXFxcXCJvYmplY3RcXFxcXFxcIiE9dHlwZW9mIG9iamVjdCYmXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiIT10eXBlb2Ygb2JqZWN0fHxudWxsPT09b2JqZWN0KXRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0XFxcXFxcXCIpO3ZhciBrZXlzPVtdO2Zvcih2YXIgbmFtZSBpbiBvYmplY3Qpb3ducyhvYmplY3QsbmFtZSkmJmtleXMucHVzaChuYW1lKTtpZihoYXNEb250RW51bUJ1Zylmb3IodmFyIGk9MCxpaT1kb250RW51bXNMZW5ndGg7aWk+aTtpKyspe3ZhciBkb250RW51bT1kb250RW51bXNbaV07b3ducyhvYmplY3QsZG9udEVudW0pJiZrZXlzLnB1c2goZG9udEVudW0pfXJldHVybiBrZXlzfX1EYXRlLm5vd3x8KERhdGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTt2YXIgd3M9XFxcXFxcXCJcXFxcdFxcXFxcXFxcblxcXFx1MDAwYlxcXFxcXFxcZlxcXFxcXFxcciDCoOGagOGgjuKAgOKAgeKAguKAg+KAhOKAheKAhuKAh+KAiOKAieKAiuKAr+KBn+OAgFxcXFxcXFxcdTIwMjhcXFxcXFxcXHUyMDI577u/XFxcXFxcXCI7aWYoIVN0cmluZy5wcm90b3R5cGUudHJpbXx8d3MudHJpbSgpKXt3cz1cXFxcXFxcIltcXFxcXFxcIit3cytcXFxcXFxcIl1cXFxcXFxcIjt2YXIgdHJpbUJlZ2luUmVnZXhwPVJlZ0V4cChcXFxcXFxcIl5cXFxcXFxcIit3cyt3cytcXFxcXFxcIipcXFxcXFxcIiksdHJpbUVuZFJlZ2V4cD1SZWdFeHAod3Mrd3MrXFxcXFxcXCIqJFxcXFxcXFwiKTtTdHJpbmcucHJvdG90eXBlLnRyaW09ZnVuY3Rpb24oKXtyZXR1cm4odGhpcytcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCxcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsXFxcXFxcXCJcXFxcXFxcIil9fXZhciB0b09iamVjdD1mdW5jdGlvbihvKXtpZihudWxsPT1vKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJjYW4ndCBjb252ZXJ0IFxcXFxcXFwiK28rXFxcXFxcXCIgdG8gb2JqZWN0XFxcXFxcXCIpO3JldHVybiBPYmplY3Qobyl9fSk7XFxcIjtcXG5cXG4vKioqLyB9LFxcbi8qIDE4ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcXFwiKTsgfTtcXG5cXG5cXG4vKioqLyB9LFxcbi8qIDE5ICovXFxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge21vZHVsZS5leHBvcnRzID0gZ2V0X2Jsb2IoKVxcblxcblxcdGZ1bmN0aW9uIGdldF9ibG9iKCkge1xcblxcdCAgaWYoZ2xvYmFsLkJsb2IpIHtcXG5cXHQgICAgdHJ5IHtcXG5cXHQgICAgICBuZXcgQmxvYihbJ2FzZGYnXSwge3R5cGU6ICd0ZXh0L3BsYWluJ30pXFxuXFx0ICAgICAgcmV0dXJuIEJsb2JcXG5cXHQgICAgfSBjYXRjaChlcnIpIHt9XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgQnVpbGRlciA9IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlciB8fFxcblxcdCAgICAgICAgICAgICAgICBnbG9iYWwuTW96QmxvYkJ1aWxkZXIgfHxcXG5cXHQgICAgICAgICAgICAgICAgZ2xvYmFsLk1TQmxvYkJ1aWxkZXJcXG5cXG5cXHQgIHJldHVybiBmdW5jdGlvbihwYXJ0cywgYmFnKSB7XFxuXFx0ICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXJcXG5cXHQgICAgICAsIGVuZGluZ3MgPSBiYWcuZW5kaW5nc1xcblxcdCAgICAgICwgdHlwZSA9IGJhZy50eXBlXFxuXFxuXFx0ICAgIGlmKGVuZGluZ3MpIGZvcih2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XFxuXFx0ICAgICAgYnVpbGRlci5hcHBlbmQocGFydHNbaV0sIGVuZGluZ3MpXFxuXFx0ICAgIH0gZWxzZSBmb3IodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcblxcdCAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnRzW2ldKVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldHVybiB0eXBlID8gYnVpbGRlci5nZXRCbG9iKHR5cGUpIDogYnVpbGRlci5nZXRCbG9iKClcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxcblxcbi8qKiovIH1cXG4vKioqKioqLyBdKVxcbn0pO1xcbjtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL2pzb25lZGl0b3IvZGlzdC9qc29uZWRpdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsInJlcXVpcmUoXCIhIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXIvYW5ndWxhci5taW4uanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci9hbmd1bGFyLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXG4gQW5ndWxhckpTIHYxLjQuMlxcbiAoYykgMjAxMC0yMDE1IEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xcbiBMaWNlbnNlOiBNSVRcXG4qL1xcbihmdW5jdGlvbihPLFUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIEooYil7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzWzBdLGM7Yz1cXFwiW1xcXCIrKGI/YitcXFwiOlxcXCI6XFxcIlxcXCIpK2ErXFxcIl0gaHR0cDovL2Vycm9ycy5hbmd1bGFyanMub3JnLzEuNC4yL1xcXCIrKGI/YitcXFwiL1xcXCI6XFxcIlxcXCIpK2E7Zm9yKGE9MTthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKXtjPWMrKDE9PWE/XFxcIj9cXFwiOlxcXCImXFxcIikrXFxcInBcXFwiKyhhLTEpK1xcXCI9XFxcIjt2YXIgZD1lbmNvZGVVUklDb21wb25lbnQsZTtlPWFyZ3VtZW50c1thXTtlPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlP2UudG9TdHJpbmcoKS5yZXBsYWNlKC8gXFxcXHtbXFxcXHNcXFxcU10qJC8sXFxcIlxcXCIpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9cXFwidW5kZWZpbmVkXFxcIjpcXFwic3RyaW5nXFxcIiE9dHlwZW9mIGU/SlNPTi5zdHJpbmdpZnkoZSk6ZTtjKz1kKGUpfXJldHVybiBFcnJvcihjKX19ZnVuY3Rpb24gRWEoYil7aWYobnVsbD09Ynx8V2EoYikpcmV0dXJuITE7dmFyIGE9XFxcImxlbmd0aFxcXCJpbiBPYmplY3QoYikmJmIubGVuZ3RoO1xcbnJldHVybiBiLm5vZGVUeXBlPT09cWEmJmE/ITA6TChiKXx8RyhiKXx8MD09PWF8fFxcXCJudW1iZXJcXFwiPT09dHlwZW9mIGEmJjA8YSYmYS0xIGluIGJ9ZnVuY3Rpb24gbShiLGEsYyl7dmFyIGQsZTtpZihiKWlmKHooYikpZm9yKGQgaW4gYilcXFwicHJvdG90eXBlXFxcIj09ZHx8XFxcImxlbmd0aFxcXCI9PWR8fFxcXCJuYW1lXFxcIj09ZHx8Yi5oYXNPd25Qcm9wZXJ0eSYmIWIuaGFzT3duUHJvcGVydHkoZCl8fGEuY2FsbChjLGJbZF0sZCxiKTtlbHNlIGlmKEcoYil8fEVhKGIpKXt2YXIgZj1cXFwib2JqZWN0XFxcIiE9PXR5cGVvZiBiO2Q9MDtmb3IoZT1iLmxlbmd0aDtkPGU7ZCsrKShmfHxkIGluIGIpJiZhLmNhbGwoYyxiW2RdLGQsYil9ZWxzZSBpZihiLmZvckVhY2gmJmIuZm9yRWFjaCE9PW0pYi5mb3JFYWNoKGEsYyxiKTtlbHNlIGlmKG5jKGIpKWZvcihkIGluIGIpYS5jYWxsKGMsYltkXSxkLGIpO2Vsc2UgaWYoXFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBiLmhhc093blByb3BlcnR5KWZvcihkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmXFxuYS5jYWxsKGMsYltkXSxkLGIpO2Vsc2UgZm9yKGQgaW4gYilYYS5jYWxsKGIsZCkmJmEuY2FsbChjLGJbZF0sZCxiKTtyZXR1cm4gYn1mdW5jdGlvbiBvYyhiLGEsYyl7Zm9yKHZhciBkPU9iamVjdC5rZXlzKGIpLnNvcnQoKSxlPTA7ZTxkLmxlbmd0aDtlKyspYS5jYWxsKGMsYltkW2VdXSxkW2VdKTtyZXR1cm4gZH1mdW5jdGlvbiBwYyhiKXtyZXR1cm4gZnVuY3Rpb24oYSxjKXtiKGMsYSl9fWZ1bmN0aW9uIFVkKCl7cmV0dXJuKytuYn1mdW5jdGlvbiBxYyhiLGEpe2E/Yi4kJGhhc2hLZXk9YTpkZWxldGUgYi4kJGhhc2hLZXl9ZnVuY3Rpb24gTmIoYixhLGMpe2Zvcih2YXIgZD1iLiQkaGFzaEtleSxlPTAsZj1hLmxlbmd0aDtlPGY7KytlKXt2YXIgZz1hW2VdO2lmKEgoZyl8fHooZykpZm9yKHZhciBoPU9iamVjdC5rZXlzKGcpLGw9MCxrPWgubGVuZ3RoO2w8aztsKyspe3ZhciBuPWhbbF0scj1nW25dO2MmJkgocik/YWEocik/YltuXT1uZXcgRGF0ZShyLnZhbHVlT2YoKSk6KEgoYltuXSl8fFxcbihiW25dPUcocik/W106e30pLE5iKGJbbl0sW3JdLCEwKSk6YltuXT1yfX1xYyhiLGQpO3JldHVybiBifWZ1bmN0aW9uIFAoYil7cmV0dXJuIE5iKGIsemEuY2FsbChhcmd1bWVudHMsMSksITEpfWZ1bmN0aW9uIFZkKGIpe3JldHVybiBOYihiLHphLmNhbGwoYXJndW1lbnRzLDEpLCEwKX1mdW5jdGlvbiBXKGIpe3JldHVybiBwYXJzZUludChiLDEwKX1mdW5jdGlvbiBPYihiLGEpe3JldHVybiBQKE9iamVjdC5jcmVhdGUoYiksYSl9ZnVuY3Rpb24gdigpe31mdW5jdGlvbiBZYShiKXtyZXR1cm4gYn1mdW5jdGlvbiByYShiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYn19ZnVuY3Rpb24gcmMoYil7cmV0dXJuIHooYi50b1N0cmluZykmJmIudG9TdHJpbmchPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nfWZ1bmN0aW9uIEEoYil7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PT10eXBlb2YgYn1mdW5jdGlvbiB3KGIpe3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIGJ9ZnVuY3Rpb24gSChiKXtyZXR1cm4gbnVsbCE9PVxcbmImJlxcXCJvYmplY3RcXFwiPT09dHlwZW9mIGJ9ZnVuY3Rpb24gbmMoYil7cmV0dXJuIG51bGwhPT1iJiZcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBiJiYhc2MoYil9ZnVuY3Rpb24gTChiKXtyZXR1cm5cXFwic3RyaW5nXFxcIj09PXR5cGVvZiBifWZ1bmN0aW9uIFYoYil7cmV0dXJuXFxcIm51bWJlclxcXCI9PT10eXBlb2YgYn1mdW5jdGlvbiBhYShiKXtyZXR1cm5cXFwiW29iamVjdCBEYXRlXVxcXCI9PT1zYS5jYWxsKGIpfWZ1bmN0aW9uIHooYil7cmV0dXJuXFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBifWZ1bmN0aW9uIFphKGIpe3JldHVyblxcXCJbb2JqZWN0IFJlZ0V4cF1cXFwiPT09c2EuY2FsbChiKX1mdW5jdGlvbiBXYShiKXtyZXR1cm4gYiYmYi53aW5kb3c9PT1ifWZ1bmN0aW9uICRhKGIpe3JldHVybiBiJiZiLiRldmFsQXN5bmMmJmIuJHdhdGNofWZ1bmN0aW9uIGFiKGIpe3JldHVyblxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBifWZ1bmN0aW9uIHRjKGIpe3JldHVybiEoIWJ8fCEoYi5ub2RlTmFtZXx8Yi5wcm9wJiZiLmF0dHImJmIuZmluZCkpfVxcbmZ1bmN0aW9uIFdkKGIpe3ZhciBhPXt9O2I9Yi5zcGxpdChcXFwiLFxcXCIpO3ZhciBjO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYVtiW2NdXT0hMDtyZXR1cm4gYX1mdW5jdGlvbiB0YShiKXtyZXR1cm4gTShiLm5vZGVOYW1lfHxiWzBdJiZiWzBdLm5vZGVOYW1lKX1mdW5jdGlvbiBiYihiLGEpe3ZhciBjPWIuaW5kZXhPZihhKTswPD1jJiZiLnNwbGljZShjLDEpO3JldHVybiBjfWZ1bmN0aW9uIGZhKGIsYSxjLGQpe2lmKFdhKGIpfHwkYShiKSl0aHJvdyBGYShcXFwiY3B3c1xcXCIpO2lmKHVjLnRlc3Qoc2EuY2FsbChhKSkpdGhyb3cgRmEoXFxcImNwdGFcXFwiKTtpZihhKXtpZihiPT09YSl0aHJvdyBGYShcXFwiY3BpXFxcIik7Yz1jfHxbXTtkPWR8fFtdO0goYikmJihjLnB1c2goYiksZC5wdXNoKGEpKTt2YXIgZTtpZihHKGIpKWZvcihlPWEubGVuZ3RoPTA7ZTxiLmxlbmd0aDtlKyspYS5wdXNoKGZhKGJbZV0sbnVsbCxjLGQpKTtlbHNle3ZhciBmPWEuJCRoYXNoS2V5O0coYSk/YS5sZW5ndGg9MDptKGEsZnVuY3Rpb24oYixcXG5jKXtkZWxldGUgYVtjXX0pO2lmKG5jKGIpKWZvcihlIGluIGIpYVtlXT1mYShiW2VdLG51bGwsYyxkKTtlbHNlIGlmKGImJlxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgYi5oYXNPd25Qcm9wZXJ0eSlmb3IoZSBpbiBiKWIuaGFzT3duUHJvcGVydHkoZSkmJihhW2VdPWZhKGJbZV0sbnVsbCxjLGQpKTtlbHNlIGZvcihlIGluIGIpWGEuY2FsbChiLGUpJiYoYVtlXT1mYShiW2VdLG51bGwsYyxkKSk7cWMoYSxmKX19ZWxzZSBpZihhPWIsSChiKSl7aWYoYyYmLTEhPT0oZj1jLmluZGV4T2YoYikpKXJldHVybiBkW2ZdO2lmKEcoYikpcmV0dXJuIGZhKGIsW10sYyxkKTtpZih1Yy50ZXN0KHNhLmNhbGwoYikpKWE9bmV3IGIuY29uc3RydWN0b3IoYik7ZWxzZSBpZihhYShiKSlhPW5ldyBEYXRlKGIuZ2V0VGltZSgpKTtlbHNlIGlmKFphKGIpKWE9bmV3IFJlZ0V4cChiLnNvdXJjZSxiLnRvU3RyaW5nKCkubWF0Y2goL1teXFxcXC9dKiQvKVswXSksYS5sYXN0SW5kZXg9Yi5sYXN0SW5kZXg7ZWxzZSByZXR1cm4gZT1cXG5PYmplY3QuY3JlYXRlKHNjKGIpKSxmYShiLGUsYyxkKTtkJiYoYy5wdXNoKGIpLGQucHVzaChhKSl9cmV0dXJuIGF9ZnVuY3Rpb24gaWEoYixhKXtpZihHKGIpKXthPWF8fFtdO2Zvcih2YXIgYz0wLGQ9Yi5sZW5ndGg7YzxkO2MrKylhW2NdPWJbY119ZWxzZSBpZihIKGIpKWZvcihjIGluIGE9YXx8e30sYilpZihcXFwiJFxcXCIhPT1jLmNoYXJBdCgwKXx8XFxcIiRcXFwiIT09Yy5jaGFyQXQoMSkpYVtjXT1iW2NdO3JldHVybiBhfHxifWZ1bmN0aW9uIGthKGIsYSl7aWYoYj09PWEpcmV0dXJuITA7aWYobnVsbD09PWJ8fG51bGw9PT1hKXJldHVybiExO2lmKGIhPT1iJiZhIT09YSlyZXR1cm4hMDt2YXIgYz10eXBlb2YgYixkO2lmKGM9PXR5cGVvZiBhJiZcXFwib2JqZWN0XFxcIj09YylpZihHKGIpKXtpZighRyhhKSlyZXR1cm4hMTtpZigoYz1iLmxlbmd0aCk9PWEubGVuZ3RoKXtmb3IoZD0wO2Q8YztkKyspaWYoIWthKGJbZF0sYVtkXSkpcmV0dXJuITE7cmV0dXJuITB9fWVsc2V7aWYoYWEoYikpcmV0dXJuIGFhKGEpP1xcbmthKGIuZ2V0VGltZSgpLGEuZ2V0VGltZSgpKTohMTtpZihaYShiKSlyZXR1cm4gWmEoYSk/Yi50b1N0cmluZygpPT1hLnRvU3RyaW5nKCk6ITE7aWYoJGEoYil8fCRhKGEpfHxXYShiKXx8V2EoYSl8fEcoYSl8fGFhKGEpfHxaYShhKSlyZXR1cm4hMTtjPWdhKCk7Zm9yKGQgaW4gYilpZihcXFwiJFxcXCIhPT1kLmNoYXJBdCgwKSYmIXooYltkXSkpe2lmKCFrYShiW2RdLGFbZF0pKXJldHVybiExO2NbZF09ITB9Zm9yKGQgaW4gYSlpZighKGQgaW4gY3x8XFxcIiRcXFwiPT09ZC5jaGFyQXQoMCl8fGFbZF09PT10fHx6KGFbZF0pKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBjYihiLGEsYyl7cmV0dXJuIGIuY29uY2F0KHphLmNhbGwoYSxjKSl9ZnVuY3Rpb24gdmMoYixhKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGg/emEuY2FsbChhcmd1bWVudHMsMik6W107cmV0dXJuIXooYSl8fGEgaW5zdGFuY2VvZiBSZWdFeHA/YTpjLmxlbmd0aD9mdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP1xcbmEuYXBwbHkoYixjYihjLGFyZ3VtZW50cywwKSk6YS5hcHBseShiLGMpfTpmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP2EuYXBwbHkoYixhcmd1bWVudHMpOmEuY2FsbChiKX19ZnVuY3Rpb24gWGQoYixhKXt2YXIgYz1hO1xcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGImJlxcXCIkXFxcIj09PWIuY2hhckF0KDApJiZcXFwiJFxcXCI9PT1iLmNoYXJBdCgxKT9jPXQ6V2EoYSk/Yz1cXFwiJFdJTkRPV1xcXCI6YSYmVT09PWE/Yz1cXFwiJERPQ1VNRU5UXFxcIjokYShhKSYmKGM9XFxcIiRTQ09QRVxcXCIpO3JldHVybiBjfWZ1bmN0aW9uIGRiKGIsYSl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PT10eXBlb2YgYilyZXR1cm4gdDtWKGEpfHwoYT1hPzI6bnVsbCk7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGIsWGQsYSl9ZnVuY3Rpb24gd2MoYil7cmV0dXJuIEwoYik/SlNPTi5wYXJzZShiKTpifWZ1bmN0aW9uIHhjKGIsYSl7dmFyIGM9RGF0ZS5wYXJzZShcXFwiSmFuIDAxLCAxOTcwIDAwOjAwOjAwIFxcXCIrYikvNkU0O3JldHVybiBpc05hTihjKT9hOmN9ZnVuY3Rpb24gUGIoYixcXG5hLGMpe2M9Yz8tMToxO3ZhciBkPXhjKGEsYi5nZXRUaW1lem9uZU9mZnNldCgpKTthPWI7Yj1jKihkLWIuZ2V0VGltZXpvbmVPZmZzZXQoKSk7YT1uZXcgRGF0ZShhLmdldFRpbWUoKSk7YS5zZXRNaW51dGVzKGEuZ2V0TWludXRlcygpK2IpO3JldHVybiBhfWZ1bmN0aW9uIHVhKGIpe2I9eShiKS5jbG9uZSgpO3RyeXtiLmVtcHR5KCl9Y2F0Y2goYSl7fXZhciBjPXkoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGIpLmh0bWwoKTt0cnl7cmV0dXJuIGJbMF0ubm9kZVR5cGU9PT1OYT9NKGMpOmMubWF0Y2goL14oPFtePl0rPikvKVsxXS5yZXBsYWNlKC9ePChbXFxcXHdcXFxcLV0rKS8sZnVuY3Rpb24oYSxiKXtyZXR1cm5cXFwiPFxcXCIrTShiKX0pfWNhdGNoKGQpe3JldHVybiBNKGMpfX1mdW5jdGlvbiB5YyhiKXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChiKX1jYXRjaChhKXt9fWZ1bmN0aW9uIHpjKGIpe3ZhciBhPXt9LGMsZDttKChifHxcXFwiXFxcIikuc3BsaXQoXFxcIiZcXFwiKSxmdW5jdGlvbihiKXtiJiYoYz1iLnJlcGxhY2UoL1xcXFwrL2csXFxuXFxcIiUyMFxcXCIpLnNwbGl0KFxcXCI9XFxcIiksZD15YyhjWzBdKSx3KGQpJiYoYj13KGNbMV0pP3ljKGNbMV0pOiEwLFhhLmNhbGwoYSxkKT9HKGFbZF0pP2FbZF0ucHVzaChiKTphW2RdPVthW2RdLGJdOmFbZF09YikpfSk7cmV0dXJuIGF9ZnVuY3Rpb24gUWIoYil7dmFyIGE9W107bShiLGZ1bmN0aW9uKGIsZCl7RyhiKT9tKGIsZnVuY3Rpb24oYil7YS5wdXNoKG1hKGQsITApKyghMD09PWI/XFxcIlxcXCI6XFxcIj1cXFwiK21hKGIsITApKSl9KTphLnB1c2gobWEoZCwhMCkrKCEwPT09Yj9cXFwiXFxcIjpcXFwiPVxcXCIrbWEoYiwhMCkpKX0pO3JldHVybiBhLmxlbmd0aD9hLmpvaW4oXFxcIiZcXFwiKTpcXFwiXFxcIn1mdW5jdGlvbiBvYihiKXtyZXR1cm4gbWEoYiwhMCkucmVwbGFjZSgvJTI2L2dpLFxcXCImXFxcIikucmVwbGFjZSgvJTNEL2dpLFxcXCI9XFxcIikucmVwbGFjZSgvJTJCL2dpLFxcXCIrXFxcIil9ZnVuY3Rpb24gbWEoYixhKXtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGIpLnJlcGxhY2UoLyU0MC9naSxcXFwiQFxcXCIpLnJlcGxhY2UoLyUzQS9naSxcXFwiOlxcXCIpLnJlcGxhY2UoLyUyNC9nLFxcblxcXCIkXFxcIikucmVwbGFjZSgvJTJDL2dpLFxcXCIsXFxcIikucmVwbGFjZSgvJTNCL2dpLFxcXCI7XFxcIikucmVwbGFjZSgvJTIwL2csYT9cXFwiJTIwXFxcIjpcXFwiK1xcXCIpfWZ1bmN0aW9uIFlkKGIsYSl7dmFyIGMsZCxlPU9hLmxlbmd0aDtmb3IoZD0wO2Q8ZTsrK2QpaWYoYz1PYVtkXSthLEwoYz1iLmdldEF0dHJpYnV0ZShjKSkpcmV0dXJuIGM7cmV0dXJuIG51bGx9ZnVuY3Rpb24gWmQoYixhKXt2YXIgYyxkLGU9e307bShPYSxmdW5jdGlvbihhKXthKz1cXFwiYXBwXFxcIjshYyYmYi5oYXNBdHRyaWJ1dGUmJmIuaGFzQXR0cmlidXRlKGEpJiYoYz1iLGQ9Yi5nZXRBdHRyaWJ1dGUoYSkpfSk7bShPYSxmdW5jdGlvbihhKXthKz1cXFwiYXBwXFxcIjt2YXIgZTshYyYmKGU9Yi5xdWVyeVNlbGVjdG9yKFxcXCJbXFxcIithLnJlcGxhY2UoXFxcIjpcXFwiLFxcXCJcXFxcXFxcXDpcXFwiKStcXFwiXVxcXCIpKSYmKGM9ZSxkPWUuZ2V0QXR0cmlidXRlKGEpKX0pO2MmJihlLnN0cmljdERpPW51bGwhPT1ZZChjLFxcXCJzdHJpY3QtZGlcXFwiKSxhKGMsZD9bZF06W10sZSkpfWZ1bmN0aW9uIEFjKGIsYSxjKXtIKGMpfHxcXG4oYz17fSk7Yz1QKHtzdHJpY3REaTohMX0sYyk7dmFyIGQ9ZnVuY3Rpb24oKXtiPXkoYik7aWYoYi5pbmplY3RvcigpKXt2YXIgZD1iWzBdPT09VT9cXFwiZG9jdW1lbnRcXFwiOnVhKGIpO3Rocm93IEZhKFxcXCJidHN0cnBkXFxcIixkLnJlcGxhY2UoLzwvLFxcXCImbHQ7XFxcIikucmVwbGFjZSgvPi8sXFxcIiZndDtcXFwiKSk7fWE9YXx8W107YS51bnNoaWZ0KFtcXFwiJHByb3ZpZGVcXFwiLGZ1bmN0aW9uKGEpe2EudmFsdWUoXFxcIiRyb290RWxlbWVudFxcXCIsYil9XSk7Yy5kZWJ1Z0luZm9FbmFibGVkJiZhLnB1c2goW1xcXCIkY29tcGlsZVByb3ZpZGVyXFxcIixmdW5jdGlvbihhKXthLmRlYnVnSW5mb0VuYWJsZWQoITApfV0pO2EudW5zaGlmdChcXFwibmdcXFwiKTtkPWViKGEsYy5zdHJpY3REaSk7ZC5pbnZva2UoW1xcXCIkcm9vdFNjb3BlXFxcIixcXFwiJHJvb3RFbGVtZW50XFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkaW5qZWN0b3JcXFwiLGZ1bmN0aW9uKGEsYixjLGQpe2EuJGFwcGx5KGZ1bmN0aW9uKCl7Yi5kYXRhKFxcXCIkaW5qZWN0b3JcXFwiLGQpO2MoYikoYSl9KX1dKTtyZXR1cm4gZH0sZT1cXG4vXk5HX0VOQUJMRV9ERUJVR19JTkZPIS8sZj0vXk5HX0RFRkVSX0JPT1RTVFJBUCEvO08mJmUudGVzdChPLm5hbWUpJiYoYy5kZWJ1Z0luZm9FbmFibGVkPSEwLE8ubmFtZT1PLm5hbWUucmVwbGFjZShlLFxcXCJcXFwiKSk7aWYoTyYmIWYudGVzdChPLm5hbWUpKXJldHVybiBkKCk7Ty5uYW1lPU8ubmFtZS5yZXBsYWNlKGYsXFxcIlxcXCIpO2NhLnJlc3VtZUJvb3RzdHJhcD1mdW5jdGlvbihiKXttKGIsZnVuY3Rpb24oYil7YS5wdXNoKGIpfSk7cmV0dXJuIGQoKX07eihjYS5yZXN1bWVEZWZlcnJlZEJvb3RzdHJhcCkmJmNhLnJlc3VtZURlZmVycmVkQm9vdHN0cmFwKCl9ZnVuY3Rpb24gJGQoKXtPLm5hbWU9XFxcIk5HX0VOQUJMRV9ERUJVR19JTkZPIVxcXCIrTy5uYW1lO08ubG9jYXRpb24ucmVsb2FkKCl9ZnVuY3Rpb24gYWUoYil7Yj1jYS5lbGVtZW50KGIpLmluamVjdG9yKCk7aWYoIWIpdGhyb3cgRmEoXFxcInRlc3RcXFwiKTtyZXR1cm4gYi5nZXQoXFxcIiQkdGVzdGFiaWxpdHlcXFwiKX1mdW5jdGlvbiBCYyhiLGEpe2E9YXx8XFxuXFxcIl9cXFwiO3JldHVybiBiLnJlcGxhY2UoYmUsZnVuY3Rpb24oYixkKXtyZXR1cm4oZD9hOlxcXCJcXFwiKStiLnRvTG93ZXJDYXNlKCl9KX1mdW5jdGlvbiBjZSgpe3ZhciBiO2lmKCFDYyl7dmFyIGE9cGIoKTtsYT1PLmpRdWVyeTt3KGEpJiYobGE9bnVsbD09PWE/dDpPW2FdKTtsYSYmbGEuZm4ub24/KHk9bGEsUChsYS5mbix7c2NvcGU6UGEuc2NvcGUsaXNvbGF0ZVNjb3BlOlBhLmlzb2xhdGVTY29wZSxjb250cm9sbGVyOlBhLmNvbnRyb2xsZXIsaW5qZWN0b3I6UGEuaW5qZWN0b3IsaW5oZXJpdGVkRGF0YTpQYS5pbmhlcml0ZWREYXRhfSksYj1sYS5jbGVhbkRhdGEsbGEuY2xlYW5EYXRhPWZ1bmN0aW9uKGEpe3ZhciBkO2lmKFJiKVJiPSExO2Vsc2UgZm9yKHZhciBlPTAsZjtudWxsIT0oZj1hW2VdKTtlKyspKGQ9bGEuX2RhdGEoZixcXFwiZXZlbnRzXFxcIikpJiZkLiRkZXN0cm95JiZsYShmKS50cmlnZ2VySGFuZGxlcihcXFwiJGRlc3Ryb3lcXFwiKTtiKGEpfSk6eT1RO2NhLmVsZW1lbnQ9eTtDYz0hMH19ZnVuY3Rpb24gU2IoYixcXG5hLGMpe2lmKCFiKXRocm93IEZhKFxcXCJhcmVxXFxcIixhfHxcXFwiP1xcXCIsY3x8XFxcInJlcXVpcmVkXFxcIik7cmV0dXJuIGJ9ZnVuY3Rpb24gUWEoYixhLGMpe2MmJkcoYikmJihiPWJbYi5sZW5ndGgtMV0pO1NiKHooYiksYSxcXFwibm90IGEgZnVuY3Rpb24sIGdvdCBcXFwiKyhiJiZcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBiP2IuY29uc3RydWN0b3IubmFtZXx8XFxcIk9iamVjdFxcXCI6dHlwZW9mIGIpKTtyZXR1cm4gYn1mdW5jdGlvbiBSYShiLGEpe2lmKFxcXCJoYXNPd25Qcm9wZXJ0eVxcXCI9PT1iKXRocm93IEZhKFxcXCJiYWRuYW1lXFxcIixhKTt9ZnVuY3Rpb24gRGMoYixhLGMpe2lmKCFhKXJldHVybiBiO2E9YS5zcGxpdChcXFwiLlxcXCIpO2Zvcih2YXIgZCxlPWIsZj1hLmxlbmd0aCxnPTA7ZzxmO2crKylkPWFbZ10sYiYmKGI9KGU9YilbZF0pO3JldHVybiFjJiZ6KGIpP3ZjKGUsYik6Yn1mdW5jdGlvbiBxYihiKXt2YXIgYT1iWzBdO2I9YltiLmxlbmd0aC0xXTt2YXIgYz1bYV07ZG97YT1hLm5leHRTaWJsaW5nO2lmKCFhKWJyZWFrO2MucHVzaChhKX13aGlsZShhIT09XFxuYik7cmV0dXJuIHkoYyl9ZnVuY3Rpb24gZ2EoKXtyZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKX1mdW5jdGlvbiBkZShiKXtmdW5jdGlvbiBhKGEsYixjKXtyZXR1cm4gYVtiXXx8KGFbYl09YygpKX12YXIgYz1KKFxcXCIkaW5qZWN0b3JcXFwiKSxkPUooXFxcIm5nXFxcIik7Yj1hKGIsXFxcImFuZ3VsYXJcXFwiLE9iamVjdCk7Yi4kJG1pbkVycj1iLiQkbWluRXJyfHxKO3JldHVybiBhKGIsXFxcIm1vZHVsZVxcXCIsZnVuY3Rpb24oKXt2YXIgYj17fTtyZXR1cm4gZnVuY3Rpb24oZixnLGgpe2lmKFxcXCJoYXNPd25Qcm9wZXJ0eVxcXCI9PT1mKXRocm93IGQoXFxcImJhZG5hbWVcXFwiLFxcXCJtb2R1bGVcXFwiKTtnJiZiLmhhc093blByb3BlcnR5KGYpJiYoYltmXT1udWxsKTtyZXR1cm4gYShiLGYsZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGIsYyxlLGYpe2Z8fChmPWQpO3JldHVybiBmdW5jdGlvbigpe2ZbZXx8XFxcInB1c2hcXFwiXShbYixjLGFyZ3VtZW50c10pO3JldHVybiBDfX1mdW5jdGlvbiBiKGEsYyl7cmV0dXJuIGZ1bmN0aW9uKGIsZSl7ZSYmeihlKSYmXFxuKGUuJCRtb2R1bGVOYW1lPWYpO2QucHVzaChbYSxjLGFyZ3VtZW50c10pO3JldHVybiBDfX1pZighZyl0aHJvdyBjKFxcXCJub21vZFxcXCIsZik7dmFyIGQ9W10sZT1bXSxzPVtdLHg9YShcXFwiJGluamVjdG9yXFxcIixcXFwiaW52b2tlXFxcIixcXFwicHVzaFxcXCIsZSksQz17X2ludm9rZVF1ZXVlOmQsX2NvbmZpZ0Jsb2NrczplLF9ydW5CbG9ja3M6cyxyZXF1aXJlczpnLG5hbWU6Zixwcm92aWRlcjpiKFxcXCIkcHJvdmlkZVxcXCIsXFxcInByb3ZpZGVyXFxcIiksZmFjdG9yeTpiKFxcXCIkcHJvdmlkZVxcXCIsXFxcImZhY3RvcnlcXFwiKSxzZXJ2aWNlOmIoXFxcIiRwcm92aWRlXFxcIixcXFwic2VydmljZVxcXCIpLHZhbHVlOmEoXFxcIiRwcm92aWRlXFxcIixcXFwidmFsdWVcXFwiKSxjb25zdGFudDphKFxcXCIkcHJvdmlkZVxcXCIsXFxcImNvbnN0YW50XFxcIixcXFwidW5zaGlmdFxcXCIpLGRlY29yYXRvcjpiKFxcXCIkcHJvdmlkZVxcXCIsXFxcImRlY29yYXRvclxcXCIpLGFuaW1hdGlvbjpiKFxcXCIkYW5pbWF0ZVByb3ZpZGVyXFxcIixcXFwicmVnaXN0ZXJcXFwiKSxmaWx0ZXI6YihcXFwiJGZpbHRlclByb3ZpZGVyXFxcIixcXFwicmVnaXN0ZXJcXFwiKSxjb250cm9sbGVyOmIoXFxcIiRjb250cm9sbGVyUHJvdmlkZXJcXFwiLFxcblxcXCJyZWdpc3RlclxcXCIpLGRpcmVjdGl2ZTpiKFxcXCIkY29tcGlsZVByb3ZpZGVyXFxcIixcXFwiZGlyZWN0aXZlXFxcIiksY29uZmlnOngscnVuOmZ1bmN0aW9uKGEpe3MucHVzaChhKTtyZXR1cm4gdGhpc319O2gmJngoaCk7cmV0dXJuIEN9KX19KX1mdW5jdGlvbiBlZShiKXtQKGIse2Jvb3RzdHJhcDpBYyxjb3B5OmZhLGV4dGVuZDpQLG1lcmdlOlZkLGVxdWFsczprYSxlbGVtZW50OnksZm9yRWFjaDptLGluamVjdG9yOmViLG5vb3A6dixiaW5kOnZjLHRvSnNvbjpkYixmcm9tSnNvbjp3YyxpZGVudGl0eTpZYSxpc1VuZGVmaW5lZDpBLGlzRGVmaW5lZDp3LGlzU3RyaW5nOkwsaXNGdW5jdGlvbjp6LGlzT2JqZWN0OkgsaXNOdW1iZXI6Vixpc0VsZW1lbnQ6dGMsaXNBcnJheTpHLHZlcnNpb246ZmUsaXNEYXRlOmFhLGxvd2VyY2FzZTpNLHVwcGVyY2FzZTpyYixjYWxsYmFja3M6e2NvdW50ZXI6MH0sZ2V0VGVzdGFiaWxpdHk6YWUsJCRtaW5FcnI6SiwkJGNzcDpmYixyZWxvYWRXaXRoRGVidWdJbmZvOiRkfSk7XFxuZ2I9ZGUoTyk7dHJ5e2diKFxcXCJuZ0xvY2FsZVxcXCIpfWNhdGNoKGEpe2diKFxcXCJuZ0xvY2FsZVxcXCIsW10pLnByb3ZpZGVyKFxcXCIkbG9jYWxlXFxcIixnZSl9Z2IoXFxcIm5nXFxcIixbXFxcIm5nTG9jYWxlXFxcIl0sW1xcXCIkcHJvdmlkZVxcXCIsZnVuY3Rpb24oYSl7YS5wcm92aWRlcih7JCRzYW5pdGl6ZVVyaTpoZX0pO2EucHJvdmlkZXIoXFxcIiRjb21waWxlXFxcIixFYykuZGlyZWN0aXZlKHthOmllLGlucHV0OkZjLHRleHRhcmVhOkZjLGZvcm06amUsc2NyaXB0OmtlLHNlbGVjdDpsZSxzdHlsZTptZSxvcHRpb246bmUsbmdCaW5kOm9lLG5nQmluZEh0bWw6cGUsbmdCaW5kVGVtcGxhdGU6cWUsbmdDbGFzczpyZSxuZ0NsYXNzRXZlbjpzZSxuZ0NsYXNzT2RkOnRlLG5nQ2xvYWs6dWUsbmdDb250cm9sbGVyOnZlLG5nRm9ybTp3ZSxuZ0hpZGU6eGUsbmdJZjp5ZSxuZ0luY2x1ZGU6emUsbmdJbml0OkFlLG5nTm9uQmluZGFibGU6QmUsbmdQbHVyYWxpemU6Q2UsbmdSZXBlYXQ6RGUsbmdTaG93OkVlLG5nU3R5bGU6RmUsbmdTd2l0Y2g6R2UsXFxubmdTd2l0Y2hXaGVuOkhlLG5nU3dpdGNoRGVmYXVsdDpJZSxuZ09wdGlvbnM6SmUsbmdUcmFuc2NsdWRlOktlLG5nTW9kZWw6TGUsbmdMaXN0Ok1lLG5nQ2hhbmdlOk5lLHBhdHRlcm46R2MsbmdQYXR0ZXJuOkdjLHJlcXVpcmVkOkhjLG5nUmVxdWlyZWQ6SGMsbWlubGVuZ3RoOkljLG5nTWlubGVuZ3RoOkljLG1heGxlbmd0aDpKYyxuZ01heGxlbmd0aDpKYyxuZ1ZhbHVlOk9lLG5nTW9kZWxPcHRpb25zOlBlfSkuZGlyZWN0aXZlKHtuZ0luY2x1ZGU6UWV9KS5kaXJlY3RpdmUoc2IpLmRpcmVjdGl2ZShLYyk7YS5wcm92aWRlcih7JGFuY2hvclNjcm9sbDpSZSwkYW5pbWF0ZTpTZSwkJGFuaW1hdGVRdWV1ZTpUZSwkJEFuaW1hdGVSdW5uZXI6VWUsJGJyb3dzZXI6VmUsJGNhY2hlRmFjdG9yeTpXZSwkY29udHJvbGxlcjpYZSwkZG9jdW1lbnQ6WWUsJGV4Y2VwdGlvbkhhbmRsZXI6WmUsJGZpbHRlcjpMYywkaW50ZXJwb2xhdGU6JGUsJGludGVydmFsOmFmLCRodHRwOmJmLCRodHRwUGFyYW1TZXJpYWxpemVyOmNmLFxcbiRodHRwUGFyYW1TZXJpYWxpemVySlFMaWtlOmRmLCRodHRwQmFja2VuZDplZiwkbG9jYXRpb246ZmYsJGxvZzpnZiwkcGFyc2U6aGYsJHJvb3RTY29wZTpqZiwkcTprZiwkJHE6bGYsJHNjZTptZiwkc2NlRGVsZWdhdGU6bmYsJHNuaWZmZXI6b2YsJHRlbXBsYXRlQ2FjaGU6cGYsJHRlbXBsYXRlUmVxdWVzdDpxZiwkJHRlc3RhYmlsaXR5OnJmLCR0aW1lb3V0OnNmLCR3aW5kb3c6dGYsJCRyQUY6dWYsJCRhc3luY0NhbGxiYWNrOnZmLCQkanFMaXRlOndmLCQkSGFzaE1hcDp4ZiwkJGNvb2tpZVJlYWRlcjp5Zn0pfV0pfWZ1bmN0aW9uIGhiKGIpe3JldHVybiBiLnJlcGxhY2UoemYsZnVuY3Rpb24oYSxiLGQsZSl7cmV0dXJuIGU/ZC50b1VwcGVyQ2FzZSgpOmR9KS5yZXBsYWNlKEFmLFxcXCJNb3okMVxcXCIpfWZ1bmN0aW9uIE1jKGIpe2I9Yi5ub2RlVHlwZTtyZXR1cm4gYj09PXFhfHwhYnx8OT09PWJ9ZnVuY3Rpb24gTmMoYixhKXt2YXIgYyxkLGU9YS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuZj1bXTtpZihUYi50ZXN0KGIpKXtjPWN8fGUuYXBwZW5kQ2hpbGQoYS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7ZD0oQmYuZXhlYyhiKXx8W1xcXCJcXFwiLFxcXCJcXFwiXSlbMV0udG9Mb3dlckNhc2UoKTtkPW5hW2RdfHxuYS5fZGVmYXVsdDtjLmlubmVySFRNTD1kWzFdK2IucmVwbGFjZShDZixcXFwiPCQxPjwvJDI+XFxcIikrZFsyXTtmb3IoZD1kWzBdO2QtLTspYz1jLmxhc3RDaGlsZDtmPWNiKGYsYy5jaGlsZE5vZGVzKTtjPWUuZmlyc3RDaGlsZDtjLnRleHRDb250ZW50PVxcXCJcXFwifWVsc2UgZi5wdXNoKGEuY3JlYXRlVGV4dE5vZGUoYikpO2UudGV4dENvbnRlbnQ9XFxcIlxcXCI7ZS5pbm5lckhUTUw9XFxcIlxcXCI7bShmLGZ1bmN0aW9uKGEpe2UuYXBwZW5kQ2hpbGQoYSl9KTtyZXR1cm4gZX1mdW5jdGlvbiBRKGIpe2lmKGIgaW5zdGFuY2VvZiBRKXJldHVybiBiO3ZhciBhO0woYikmJihiPVIoYiksYT0hMCk7aWYoISh0aGlzIGluc3RhbmNlb2YgUSkpe2lmKGEmJlxcXCI8XFxcIiE9Yi5jaGFyQXQoMCkpdGhyb3cgVWIoXFxcIm5vc2VsXFxcIik7cmV0dXJuIG5ldyBRKGIpfWlmKGEpe2E9XFxuVTt2YXIgYztiPShjPURmLmV4ZWMoYikpP1thLmNyZWF0ZUVsZW1lbnQoY1sxXSldOihjPU5jKGIsYSkpP2MuY2hpbGROb2RlczpbXX1PYyh0aGlzLGIpfWZ1bmN0aW9uIFZiKGIpe3JldHVybiBiLmNsb25lTm9kZSghMCl9ZnVuY3Rpb24gdGIoYixhKXthfHx1YihiKTtpZihiLnF1ZXJ5U2VsZWN0b3JBbGwpZm9yKHZhciBjPWIucXVlcnlTZWxlY3RvckFsbChcXFwiKlxcXCIpLGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspdWIoY1tkXSl9ZnVuY3Rpb24gUGMoYixhLGMsZCl7aWYodyhkKSl0aHJvdyBVYihcXFwib2ZmYXJnc1xcXCIpO3ZhciBlPShkPXZiKGIpKSYmZC5ldmVudHMsZj1kJiZkLmhhbmRsZTtpZihmKWlmKGEpbShhLnNwbGl0KFxcXCIgXFxcIiksZnVuY3Rpb24oYSl7aWYodyhjKSl7dmFyIGQ9ZVthXTtiYihkfHxbXSxjKTtpZihkJiYwPGQubGVuZ3RoKXJldHVybn1iLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxmLCExKTtkZWxldGUgZVthXX0pO2Vsc2UgZm9yKGEgaW4gZSlcXFwiJGRlc3Ryb3lcXFwiIT09YSYmYi5yZW1vdmVFdmVudExpc3RlbmVyKGEsXFxuZiwhMSksZGVsZXRlIGVbYV19ZnVuY3Rpb24gdWIoYixhKXt2YXIgYz1iLm5nMzM5LGQ9YyYmaWJbY107ZCYmKGE/ZGVsZXRlIGQuZGF0YVthXTooZC5oYW5kbGUmJihkLmV2ZW50cy4kZGVzdHJveSYmZC5oYW5kbGUoe30sXFxcIiRkZXN0cm95XFxcIiksUGMoYikpLGRlbGV0ZSBpYltjXSxiLm5nMzM5PXQpKX1mdW5jdGlvbiB2YihiLGEpe3ZhciBjPWIubmczMzksYz1jJiZpYltjXTthJiYhYyYmKGIubmczMzk9Yz0rK0VmLGM9aWJbY109e2V2ZW50czp7fSxkYXRhOnt9LGhhbmRsZTp0fSk7cmV0dXJuIGN9ZnVuY3Rpb24gV2IoYixhLGMpe2lmKE1jKGIpKXt2YXIgZD13KGMpLGU9IWQmJmEmJiFIKGEpLGY9IWE7Yj0oYj12YihiLCFlKSkmJmIuZGF0YTtpZihkKWJbYV09YztlbHNle2lmKGYpcmV0dXJuIGI7aWYoZSlyZXR1cm4gYiYmYlthXTtQKGIsYSl9fX1mdW5jdGlvbiB3YihiLGEpe3JldHVybiBiLmdldEF0dHJpYnV0ZT8tMTwoXFxcIiBcXFwiKyhiLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKXx8XFxcIlxcXCIpK1xcblxcXCIgXFxcIikucmVwbGFjZSgvW1xcXFxuXFxcXHRdL2csXFxcIiBcXFwiKS5pbmRleE9mKFxcXCIgXFxcIithK1xcXCIgXFxcIik6ITF9ZnVuY3Rpb24geGIoYixhKXthJiZiLnNldEF0dHJpYnV0ZSYmbShhLnNwbGl0KFxcXCIgXFxcIiksZnVuY3Rpb24oYSl7Yi5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixSKChcXFwiIFxcXCIrKGIuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpfHxcXFwiXFxcIikrXFxcIiBcXFwiKS5yZXBsYWNlKC9bXFxcXG5cXFxcdF0vZyxcXFwiIFxcXCIpLnJlcGxhY2UoXFxcIiBcXFwiK1IoYSkrXFxcIiBcXFwiLFxcXCIgXFxcIikpKX0pfWZ1bmN0aW9uIHliKGIsYSl7aWYoYSYmYi5zZXRBdHRyaWJ1dGUpe3ZhciBjPShcXFwiIFxcXCIrKGIuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpfHxcXFwiXFxcIikrXFxcIiBcXFwiKS5yZXBsYWNlKC9bXFxcXG5cXFxcdF0vZyxcXFwiIFxcXCIpO20oYS5zcGxpdChcXFwiIFxcXCIpLGZ1bmN0aW9uKGEpe2E9UihhKTstMT09PWMuaW5kZXhPZihcXFwiIFxcXCIrYStcXFwiIFxcXCIpJiYoYys9YStcXFwiIFxcXCIpfSk7Yi5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixSKGMpKX19ZnVuY3Rpb24gT2MoYixhKXtpZihhKWlmKGEubm9kZVR5cGUpYltiLmxlbmd0aCsrXT1hO2Vsc2V7dmFyIGM9XFxuYS5sZW5ndGg7aWYoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgYyYmYS53aW5kb3chPT1hKXtpZihjKWZvcih2YXIgZD0wO2Q8YztkKyspYltiLmxlbmd0aCsrXT1hW2RdfWVsc2UgYltiLmxlbmd0aCsrXT1hfX1mdW5jdGlvbiBRYyhiLGEpe3JldHVybiB6YihiLFxcXCIkXFxcIisoYXx8XFxcIm5nQ29udHJvbGxlclxcXCIpK1xcXCJDb250cm9sbGVyXFxcIil9ZnVuY3Rpb24gemIoYixhLGMpezk9PWIubm9kZVR5cGUmJihiPWIuZG9jdW1lbnRFbGVtZW50KTtmb3IoYT1HKGEpP2E6W2FdO2I7KXtmb3IodmFyIGQ9MCxlPWEubGVuZ3RoO2Q8ZTtkKyspaWYoKGM9eS5kYXRhKGIsYVtkXSkpIT09dClyZXR1cm4gYztiPWIucGFyZW50Tm9kZXx8MTE9PT1iLm5vZGVUeXBlJiZiLmhvc3R9fWZ1bmN0aW9uIFJjKGIpe2Zvcih0YihiLCEwKTtiLmZpcnN0Q2hpbGQ7KWIucmVtb3ZlQ2hpbGQoYi5maXJzdENoaWxkKX1mdW5jdGlvbiBYYihiLGEpe2F8fHRiKGIpO3ZhciBjPWIucGFyZW50Tm9kZTtjJiZjLnJlbW92ZUNoaWxkKGIpfWZ1bmN0aW9uIEZmKGIsXFxuYSl7YT1hfHxPO2lmKFxcXCJjb21wbGV0ZVxcXCI9PT1hLmRvY3VtZW50LnJlYWR5U3RhdGUpYS5zZXRUaW1lb3V0KGIpO2Vsc2UgeShhKS5vbihcXFwibG9hZFxcXCIsYil9ZnVuY3Rpb24gU2MoYixhKXt2YXIgYz1BYlthLnRvTG93ZXJDYXNlKCldO3JldHVybiBjJiZUY1t0YShiKV0mJmN9ZnVuY3Rpb24gR2YoYixhKXt2YXIgYz1iLm5vZGVOYW1lO3JldHVybihcXFwiSU5QVVRcXFwiPT09Y3x8XFxcIlRFWFRBUkVBXFxcIj09PWMpJiZVY1thXX1mdW5jdGlvbiBIZihiLGEpe3ZhciBjPWZ1bmN0aW9uKGMsZSl7Yy5pc0RlZmF1bHRQcmV2ZW50ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0UHJldmVudGVkfTt2YXIgZj1hW2V8fGMudHlwZV0sZz1mP2YubGVuZ3RoOjA7aWYoZyl7aWYoQShjLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkpe3ZhciBoPWMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO2Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uPWZ1bmN0aW9uKCl7Yy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9XFxuITA7Yy5zdG9wUHJvcGFnYXRpb24mJmMuc3RvcFByb3BhZ2F0aW9uKCk7aCYmaC5jYWxsKGMpfX1jLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPWZ1bmN0aW9uKCl7cmV0dXJuITA9PT1jLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZH07MTxnJiYoZj1pYShmKSk7Zm9yKHZhciBsPTA7bDxnO2wrKyljLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCl8fGZbbF0uY2FsbChiLGMpfX07Yy5lbGVtPWI7cmV0dXJuIGN9ZnVuY3Rpb24gd2YoKXt0aGlzLiRnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gUChRLHtoYXNDbGFzczpmdW5jdGlvbihiLGEpe2IuYXR0ciYmKGI9YlswXSk7cmV0dXJuIHdiKGIsYSl9LGFkZENsYXNzOmZ1bmN0aW9uKGIsYSl7Yi5hdHRyJiYoYj1iWzBdKTtyZXR1cm4geWIoYixhKX0scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYixhKXtiLmF0dHImJihiPWJbMF0pO3JldHVybiB4YihiLGEpfX0pfX1mdW5jdGlvbiBHYShiLGEpe3ZhciBjPWImJmIuJCRoYXNoS2V5O1xcbmlmKGMpcmV0dXJuXFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBjJiYoYz1iLiQkaGFzaEtleSgpKSxjO2M9dHlwZW9mIGI7cmV0dXJuIGM9XFxcImZ1bmN0aW9uXFxcIj09Y3x8XFxcIm9iamVjdFxcXCI9PWMmJm51bGwhPT1iP2IuJCRoYXNoS2V5PWMrXFxcIjpcXFwiKyhhfHxVZCkoKTpjK1xcXCI6XFxcIitifWZ1bmN0aW9uIFNhKGIsYSl7aWYoYSl7dmFyIGM9MDt0aGlzLm5leHRVaWQ9ZnVuY3Rpb24oKXtyZXR1cm4rK2N9fW0oYix0aGlzLnB1dCx0aGlzKX1mdW5jdGlvbiBJZihiKXtyZXR1cm4oYj1iLnRvU3RyaW5nKCkucmVwbGFjZShWYyxcXFwiXFxcIikubWF0Y2goV2MpKT9cXFwiZnVuY3Rpb24oXFxcIisoYlsxXXx8XFxcIlxcXCIpLnJlcGxhY2UoL1tcXFxcc1xcXFxyXFxcXG5dKy8sXFxcIiBcXFwiKStcXFwiKVxcXCI6XFxcImZuXFxcIn1mdW5jdGlvbiBlYihiLGEpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7aWYoSChiKSltKGIscGMoYSkpO2Vsc2UgcmV0dXJuIGEoYixjKX19ZnVuY3Rpb24gZChhLGIpe1JhKGEsXFxcInNlcnZpY2VcXFwiKTtpZih6KGIpfHxHKGIpKWI9cy5pbnN0YW50aWF0ZShiKTtcXG5pZighYi4kZ2V0KXRocm93IEhhKFxcXCJwZ2V0XFxcIixhKTtyZXR1cm4gclthK1xcXCJQcm92aWRlclxcXCJdPWJ9ZnVuY3Rpb24gZShhLGIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBjPUMuaW52b2tlKGIsdGhpcyk7aWYoQShjKSl0aHJvdyBIYShcXFwidW5kZWZcXFwiLGEpO3JldHVybiBjfX1mdW5jdGlvbiBmKGEsYixjKXtyZXR1cm4gZChhLHskZ2V0OiExIT09Yz9lKGEsYik6Yn0pfWZ1bmN0aW9uIGcoYSl7dmFyIGI9W10sYzttKGEsZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZChhKXt2YXIgYixjO2I9MDtmb3IoYz1hLmxlbmd0aDtiPGM7YisrKXt2YXIgZT1hW2JdLGY9cy5nZXQoZVswXSk7ZltlWzFdXS5hcHBseShmLGVbMl0pfX1pZighbi5nZXQoYSkpe24ucHV0KGEsITApO3RyeXtMKGEpPyhjPWdiKGEpLGI9Yi5jb25jYXQoZyhjLnJlcXVpcmVzKSkuY29uY2F0KGMuX3J1bkJsb2NrcyksZChjLl9pbnZva2VRdWV1ZSksZChjLl9jb25maWdCbG9ja3MpKTp6KGEpP2IucHVzaChzLmludm9rZShhKSk6RyhhKT9cXG5iLnB1c2gocy5pbnZva2UoYSkpOlFhKGEsXFxcIm1vZHVsZVxcXCIpfWNhdGNoKGUpe3Rocm93IEcoYSkmJihhPWFbYS5sZW5ndGgtMV0pLGUubWVzc2FnZSYmZS5zdGFjayYmLTE9PWUuc3RhY2suaW5kZXhPZihlLm1lc3NhZ2UpJiYoZT1lLm1lc3NhZ2UrXFxcIlxcXFxuXFxcIitlLnN0YWNrKSxIYShcXFwibW9kdWxlcnJcXFwiLGEsZS5zdGFja3x8ZS5tZXNzYWdlfHxlKTt9fX0pO3JldHVybiBifWZ1bmN0aW9uIGgoYixjKXtmdW5jdGlvbiBkKGEsZSl7aWYoYi5oYXNPd25Qcm9wZXJ0eShhKSl7aWYoYlthXT09PWwpdGhyb3cgSGEoXFxcImNkZXBcXFwiLGErXFxcIiA8LSBcXFwiK2suam9pbihcXFwiIDwtIFxcXCIpKTtyZXR1cm4gYlthXX10cnl7cmV0dXJuIGsudW5zaGlmdChhKSxiW2FdPWwsYlthXT1jKGEsZSl9Y2F0Y2goZil7dGhyb3cgYlthXT09PWwmJmRlbGV0ZSBiW2FdLGY7fWZpbmFsbHl7ay5zaGlmdCgpfX1mdW5jdGlvbiBlKGIsYyxmLGcpe1xcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGYmJihnPWYsZj1udWxsKTt2YXIgaD1bXSxrPWViLiQkYW5ub3RhdGUoYixcXG5hLGcpLGwscyxuO3M9MDtmb3IobD1rLmxlbmd0aDtzPGw7cysrKXtuPWtbc107aWYoXFxcInN0cmluZ1xcXCIhPT10eXBlb2Ygbil0aHJvdyBIYShcXFwiaXRrblxcXCIsbik7aC5wdXNoKGYmJmYuaGFzT3duUHJvcGVydHkobik/ZltuXTpkKG4sZykpfUcoYikmJihiPWJbbF0pO3JldHVybiBiLmFwcGx5KGMsaCl9cmV0dXJue2ludm9rZTplLGluc3RhbnRpYXRlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1PYmplY3QuY3JlYXRlKChHKGEpP2FbYS5sZW5ndGgtMV06YSkucHJvdG90eXBlfHxudWxsKTthPWUoYSxkLGIsYyk7cmV0dXJuIEgoYSl8fHooYSk/YTpkfSxnZXQ6ZCxhbm5vdGF0ZTplYi4kJGFubm90YXRlLGhhczpmdW5jdGlvbihhKXtyZXR1cm4gci5oYXNPd25Qcm9wZXJ0eShhK1xcXCJQcm92aWRlclxcXCIpfHxiLmhhc093blByb3BlcnR5KGEpfX19YT0hMD09PWE7dmFyIGw9e30saz1bXSxuPW5ldyBTYShbXSwhMCkscj17JHByb3ZpZGU6e3Byb3ZpZGVyOmMoZCksZmFjdG9yeTpjKGYpLHNlcnZpY2U6YyhmdW5jdGlvbihhLFxcbmIpe3JldHVybiBmKGEsW1xcXCIkaW5qZWN0b3JcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmluc3RhbnRpYXRlKGIpfV0pfSksdmFsdWU6YyhmdW5jdGlvbihhLGIpe3JldHVybiBmKGEscmEoYiksITEpfSksY29uc3RhbnQ6YyhmdW5jdGlvbihhLGIpe1JhKGEsXFxcImNvbnN0YW50XFxcIik7clthXT1iO3hbYV09Yn0pLGRlY29yYXRvcjpmdW5jdGlvbihhLGIpe3ZhciBjPXMuZ2V0KGErXFxcIlByb3ZpZGVyXFxcIiksZD1jLiRnZXQ7Yy4kZ2V0PWZ1bmN0aW9uKCl7dmFyIGE9Qy5pbnZva2UoZCxjKTtyZXR1cm4gQy5pbnZva2UoYixudWxsLHskZGVsZWdhdGU6YX0pfX19fSxzPXIuJGluamVjdG9yPWgocixmdW5jdGlvbihhLGIpe2NhLmlzU3RyaW5nKGIpJiZrLnB1c2goYik7dGhyb3cgSGEoXFxcInVucHJcXFwiLGsuam9pbihcXFwiIDwtIFxcXCIpKTt9KSx4PXt9LEM9eC4kaW5qZWN0b3I9aCh4LGZ1bmN0aW9uKGEsYil7dmFyIGM9cy5nZXQoYStcXFwiUHJvdmlkZXJcXFwiLGIpO3JldHVybiBDLmludm9rZShjLiRnZXQsYyx0LGEpfSk7bShnKGIpLFxcbmZ1bmN0aW9uKGEpe2EmJkMuaW52b2tlKGEpfSk7cmV0dXJuIEN9ZnVuY3Rpb24gUmUoKXt2YXIgYj0hMDt0aGlzLmRpc2FibGVBdXRvU2Nyb2xsaW5nPWZ1bmN0aW9uKCl7Yj0hMX07dGhpcy4kZ2V0PVtcXFwiJHdpbmRvd1xcXCIsXFxcIiRsb2NhdGlvblxcXCIsXFxcIiRyb290U2NvcGVcXFwiLGZ1bmN0aW9uKGEsYyxkKXtmdW5jdGlvbiBlKGEpe3ZhciBiPW51bGw7QXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhLGZ1bmN0aW9uKGEpe2lmKFxcXCJhXFxcIj09PXRhKGEpKXJldHVybiBiPWEsITB9KTtyZXR1cm4gYn1mdW5jdGlvbiBmKGIpe2lmKGIpe2Iuc2Nyb2xsSW50b1ZpZXcoKTt2YXIgYztjPWcueU9mZnNldDt6KGMpP2M9YygpOnRjKGMpPyhjPWNbMF0sYz1cXFwiZml4ZWRcXFwiIT09YS5nZXRDb21wdXRlZFN0eWxlKGMpLnBvc2l0aW9uPzA6Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pOlYoYyl8fChjPTApO2MmJihiPWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wLGEuc2Nyb2xsQnkoMCxiLWMpKX1lbHNlIGEuc2Nyb2xsVG8oMCxcXG4wKX1mdW5jdGlvbiBnKGEpe2E9TChhKT9hOmMuaGFzaCgpO3ZhciBiO2E/KGI9aC5nZXRFbGVtZW50QnlJZChhKSk/ZihiKTooYj1lKGguZ2V0RWxlbWVudHNCeU5hbWUoYSkpKT9mKGIpOlxcXCJ0b3BcXFwiPT09YSYmZihudWxsKTpmKG51bGwpfXZhciBoPWEuZG9jdW1lbnQ7YiYmZC4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gYy5oYXNoKCl9LGZ1bmN0aW9uKGEsYil7YT09PWImJlxcXCJcXFwiPT09YXx8RmYoZnVuY3Rpb24oKXtkLiRldmFsQXN5bmMoZyl9KX0pO3JldHVybiBnfV19ZnVuY3Rpb24gamIoYixhKXtpZighYiYmIWEpcmV0dXJuXFxcIlxcXCI7aWYoIWIpcmV0dXJuIGE7aWYoIWEpcmV0dXJuIGI7RyhiKSYmKGI9Yi5qb2luKFxcXCIgXFxcIikpO0coYSkmJihhPWEuam9pbihcXFwiIFxcXCIpKTtyZXR1cm4gYitcXFwiIFxcXCIrYX1mdW5jdGlvbiBKZihiKXtMKGIpJiYoYj1iLnNwbGl0KFxcXCIgXFxcIikpO3ZhciBhPWdhKCk7bShiLGZ1bmN0aW9uKGIpe2IubGVuZ3RoJiYoYVtiXT0hMCl9KTtyZXR1cm4gYX1mdW5jdGlvbiBJYShiKXtyZXR1cm4gSChiKT9cXG5iOnt9fWZ1bmN0aW9uIHZmKCl7dGhpcy4kZ2V0PVtcXFwiJCRyQUZcXFwiLFxcXCIkdGltZW91dFxcXCIsZnVuY3Rpb24oYixhKXtyZXR1cm4gYi5zdXBwb3J0ZWQ/ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSl9OmZ1bmN0aW9uKGIpe3JldHVybiBhKGIsMCwhMSl9fV19ZnVuY3Rpb24gS2YoYixhLGMsZCl7ZnVuY3Rpb24gZShhKXt0cnl7YS5hcHBseShudWxsLHphLmNhbGwoYXJndW1lbnRzLDEpKX1maW5hbGx5e2lmKEMtLSwwPT09Qylmb3IoO0YubGVuZ3RoOyl0cnl7Ri5wb3AoKSgpfWNhdGNoKGIpe2MuZXJyb3IoYil9fX1mdW5jdGlvbiBmKCl7ZygpO2goKX1mdW5jdGlvbiBnKCl7YTp7dHJ5e3U9bi5zdGF0ZTticmVhayBhfWNhdGNoKGEpe311PXZvaWQgMH11PUEodSk/bnVsbDp1O2thKHUsRCkmJih1PUQpO0Q9dX1mdW5jdGlvbiBoKCl7aWYoSyE9PWwudXJsKCl8fHAhPT11KUs9bC51cmwoKSxwPXUsbShCLGZ1bmN0aW9uKGEpe2EobC51cmwoKSx1KX0pfXZhciBsPXRoaXMsaz1iLmxvY2F0aW9uLG49XFxuYi5oaXN0b3J5LHI9Yi5zZXRUaW1lb3V0LHM9Yi5jbGVhclRpbWVvdXQseD17fTtsLmlzTW9jaz0hMTt2YXIgQz0wLEY9W107bC4kJGNvbXBsZXRlT3V0c3RhbmRpbmdSZXF1ZXN0PWU7bC4kJGluY091dHN0YW5kaW5nUmVxdWVzdENvdW50PWZ1bmN0aW9uKCl7QysrfTtsLm5vdGlmeVdoZW5Ob091dHN0YW5kaW5nUmVxdWVzdHM9ZnVuY3Rpb24oYSl7MD09PUM/YSgpOkYucHVzaChhKX07dmFyIHUscCxLPWsuaHJlZixxPWEuZmluZChcXFwiYmFzZVxcXCIpLEk9bnVsbDtnKCk7cD11O2wudXJsPWZ1bmN0aW9uKGEsYyxlKXtBKGUpJiYoZT1udWxsKTtrIT09Yi5sb2NhdGlvbiYmKGs9Yi5sb2NhdGlvbik7biE9PWIuaGlzdG9yeSYmKG49Yi5oaXN0b3J5KTtpZihhKXt2YXIgZj1wPT09ZTtpZihLPT09YSYmKCFkLmhpc3Rvcnl8fGYpKXJldHVybiBsO3ZhciBoPUsmJkphKEspPT09SmEoYSk7Sz1hO3A9ZTtpZighZC5oaXN0b3J5fHxoJiZmKXtpZighaHx8SSlJPWE7Yz9rLnJlcGxhY2UoYSk6aD8oYz1cXG5rLGU9YS5pbmRleE9mKFxcXCIjXFxcIiksYT0tMT09PWU/XFxcIlxcXCI6YS5zdWJzdHIoZSksYy5oYXNoPWEpOmsuaHJlZj1hfWVsc2UgbltjP1xcXCJyZXBsYWNlU3RhdGVcXFwiOlxcXCJwdXNoU3RhdGVcXFwiXShlLFxcXCJcXFwiLGEpLGcoKSxwPXU7cmV0dXJuIGx9cmV0dXJuIEl8fGsuaHJlZi5yZXBsYWNlKC8lMjcvZyxcXFwiJ1xcXCIpfTtsLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHV9O3ZhciBCPVtdLE49ITEsRD1udWxsO2wub25VcmxDaGFuZ2U9ZnVuY3Rpb24oYSl7aWYoIU4pe2lmKGQuaGlzdG9yeSl5KGIpLm9uKFxcXCJwb3BzdGF0ZVxcXCIsZik7eShiKS5vbihcXFwiaGFzaGNoYW5nZVxcXCIsZik7Tj0hMH1CLnB1c2goYSk7cmV0dXJuIGF9O2wuJCRhcHBsaWNhdGlvbkRlc3Ryb3llZD1mdW5jdGlvbigpe3koYikub2ZmKFxcXCJoYXNoY2hhbmdlIHBvcHN0YXRlXFxcIixmKX07bC4kJGNoZWNrVXJsQ2hhbmdlPWg7bC5iYXNlSHJlZj1mdW5jdGlvbigpe3ZhciBhPXEuYXR0cihcXFwiaHJlZlxcXCIpO3JldHVybiBhP2EucmVwbGFjZSgvXihodHRwcz9cXFxcOik/XFxcXC9cXFxcL1teXFxcXC9dKi8sXFxuXFxcIlxcXCIpOlxcXCJcXFwifTtsLmRlZmVyPWZ1bmN0aW9uKGEsYil7dmFyIGM7QysrO2M9cihmdW5jdGlvbigpe2RlbGV0ZSB4W2NdO2UoYSl9LGJ8fDApO3hbY109ITA7cmV0dXJuIGN9O2wuZGVmZXIuY2FuY2VsPWZ1bmN0aW9uKGEpe3JldHVybiB4W2FdPyhkZWxldGUgeFthXSxzKGEpLGUodiksITApOiExfX1mdW5jdGlvbiBWZSgpe3RoaXMuJGdldD1bXFxcIiR3aW5kb3dcXFwiLFxcXCIkbG9nXFxcIixcXFwiJHNuaWZmZXJcXFwiLFxcXCIkZG9jdW1lbnRcXFwiLGZ1bmN0aW9uKGIsYSxjLGQpe3JldHVybiBuZXcgS2YoYixkLGEsYyl9XX1mdW5jdGlvbiBXZSgpe3RoaXMuJGdldD1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixkKXtmdW5jdGlvbiBlKGEpe2EhPXImJihzP3M9PWEmJihzPWEubik6cz1hLGYoYS5uLGEucCksZihhLHIpLHI9YSxyLm49bnVsbCl9ZnVuY3Rpb24gZihhLGIpe2EhPWImJihhJiYoYS5wPWIpLGImJihiLm49YSkpfWlmKGIgaW4gYSl0aHJvdyBKKFxcXCIkY2FjaGVGYWN0b3J5XFxcIikoXFxcImlpZFxcXCIsYik7dmFyIGc9MCxoPVAoe30sXFxuZCx7aWQ6Yn0pLGw9e30saz1kJiZkLmNhcGFjaXR5fHxOdW1iZXIuTUFYX1ZBTFVFLG49e30scj1udWxsLHM9bnVsbDtyZXR1cm4gYVtiXT17cHV0OmZ1bmN0aW9uKGEsYil7aWYoIUEoYikpe2lmKGs8TnVtYmVyLk1BWF9WQUxVRSl7dmFyIGM9blthXXx8KG5bYV09e2tleTphfSk7ZShjKX1hIGluIGx8fGcrKztsW2FdPWI7Zz5rJiZ0aGlzLnJlbW92ZShzLmtleSk7cmV0dXJuIGJ9fSxnZXQ6ZnVuY3Rpb24oYSl7aWYoazxOdW1iZXIuTUFYX1ZBTFVFKXt2YXIgYj1uW2FdO2lmKCFiKXJldHVybjtlKGIpfXJldHVybiBsW2FdfSxyZW1vdmU6ZnVuY3Rpb24oYSl7aWYoazxOdW1iZXIuTUFYX1ZBTFVFKXt2YXIgYj1uW2FdO2lmKCFiKXJldHVybjtiPT1yJiYocj1iLnApO2I9PXMmJihzPWIubik7ZihiLm4sYi5wKTtkZWxldGUgblthXX1kZWxldGUgbFthXTtnLS19LHJlbW92ZUFsbDpmdW5jdGlvbigpe2w9e307Zz0wO249e307cj1zPW51bGx9LGRlc3Ryb3k6ZnVuY3Rpb24oKXtuPWg9XFxubD1udWxsO2RlbGV0ZSBhW2JdfSxpbmZvOmZ1bmN0aW9uKCl7cmV0dXJuIFAoe30saCx7c2l6ZTpnfSl9fX12YXIgYT17fTtiLmluZm89ZnVuY3Rpb24oKXt2YXIgYj17fTttKGEsZnVuY3Rpb24oYSxlKXtiW2VdPWEuaW5mbygpfSk7cmV0dXJuIGJ9O2IuZ2V0PWZ1bmN0aW9uKGIpe3JldHVybiBhW2JdfTtyZXR1cm4gYn19ZnVuY3Rpb24gcGYoKXt0aGlzLiRnZXQ9W1xcXCIkY2FjaGVGYWN0b3J5XFxcIixmdW5jdGlvbihiKXtyZXR1cm4gYihcXFwidGVtcGxhdGVzXFxcIil9XX1mdW5jdGlvbiBFYyhiLGEpe2Z1bmN0aW9uIGMoYSxiLGMpe3ZhciBkPS9eXFxcXHMqKFtAJl18PShcXFxcKj8pKShcXFxcPz8pXFxcXHMqKFxcXFx3KilcXFxccyokLyxlPXt9O20oYSxmdW5jdGlvbihhLGYpe3ZhciBnPWEubWF0Y2goZCk7aWYoIWcpdGhyb3cgZWEoXFxcImlzY3BcXFwiLGIsZixhLGM/XFxcImNvbnRyb2xsZXIgYmluZGluZ3MgZGVmaW5pdGlvblxcXCI6XFxcImlzb2xhdGUgc2NvcGUgZGVmaW5pdGlvblxcXCIpO2VbZl09e21vZGU6Z1sxXVswXSxjb2xsZWN0aW9uOlxcXCIqXFxcIj09PVxcbmdbMl0sb3B0aW9uYWw6XFxcIj9cXFwiPT09Z1szXSxhdHRyTmFtZTpnWzRdfHxmfX0pO3JldHVybiBlfWZ1bmN0aW9uIGQoYSl7dmFyIGI9YS5jaGFyQXQoMCk7aWYoIWJ8fGIhPT1NKGIpKXRocm93IGVhKFxcXCJiYWRkaXJcXFwiLGEpO2lmKGEhPT1hLnRyaW0oKSl0aHJvdyBlYShcXFwiYmFkZGlyXFxcIixhKTt9dmFyIGU9e30sZj0vXlxcXFxzKmRpcmVjdGl2ZVxcXFw6XFxcXHMqKFtcXFxcd1xcXFwtXSspXFxcXHMrKC4qKSQvLGc9LygoW1xcXFx3XFxcXC1dKykoPzpcXFxcOihbXjtdKykpPzs/KS8saD1XZChcXFwibmdTcmMsbmdTcmNzZXQsc3JjLHNyY3NldFxcXCIpLGw9L14oPzooXFxcXF5cXFxcXj8pPyhcXFxcPyk/KFxcXFxeXFxcXF4/KT8pPy8saz0vXihvblthLXpdK3xmb3JtYWN0aW9uKSQvO3RoaXMuZGlyZWN0aXZlPWZ1bmN0aW9uIHMoYSxmKXtSYShhLFxcXCJkaXJlY3RpdmVcXFwiKTtMKGEpPyhkKGEpLFNiKGYsXFxcImRpcmVjdGl2ZUZhY3RvcnlcXFwiKSxlLmhhc093blByb3BlcnR5KGEpfHwoZVthXT1bXSxiLmZhY3RvcnkoYStcXFwiRGlyZWN0aXZlXFxcIixbXFxcIiRpbmplY3RvclxcXCIsXFxcIiRleGNlcHRpb25IYW5kbGVyXFxcIixcXG5mdW5jdGlvbihiLGQpe3ZhciBmPVtdO20oZVthXSxmdW5jdGlvbihlLGcpe3RyeXt2YXIgaD1iLmludm9rZShlKTt6KGgpP2g9e2NvbXBpbGU6cmEoaCl9OiFoLmNvbXBpbGUmJmgubGluayYmKGguY29tcGlsZT1yYShoLmxpbmspKTtoLnByaW9yaXR5PWgucHJpb3JpdHl8fDA7aC5pbmRleD1nO2gubmFtZT1oLm5hbWV8fGE7aC5yZXF1aXJlPWgucmVxdWlyZXx8aC5jb250cm9sbGVyJiZoLm5hbWU7aC5yZXN0cmljdD1oLnJlc3RyaWN0fHxcXFwiRUFcXFwiO3ZhciBrPWgsbD1oLHM9aC5uYW1lLG49e2lzb2xhdGVTY29wZTpudWxsLGJpbmRUb0NvbnRyb2xsZXI6bnVsbH07SChsLnNjb3BlKSYmKCEwPT09bC5iaW5kVG9Db250cm9sbGVyPyhuLmJpbmRUb0NvbnRyb2xsZXI9YyhsLnNjb3BlLHMsITApLG4uaXNvbGF0ZVNjb3BlPXt9KTpuLmlzb2xhdGVTY29wZT1jKGwuc2NvcGUscywhMSkpO0gobC5iaW5kVG9Db250cm9sbGVyKSYmKG4uYmluZFRvQ29udHJvbGxlcj1jKGwuYmluZFRvQ29udHJvbGxlcixcXG5zLCEwKSk7aWYoSChuLmJpbmRUb0NvbnRyb2xsZXIpKXt2YXIgQz1sLmNvbnRyb2xsZXIsJD1sLmNvbnRyb2xsZXJBcztpZighQyl0aHJvdyBlYShcXFwibm9jdHJsXFxcIixzKTt2YXIgaGE7YTppZigkJiZMKCQpKWhhPSQ7ZWxzZXtpZihMKEMpKXt2YXIgbT1YYy5leGVjKEMpO2lmKG0pe2hhPW1bM107YnJlYWsgYX19aGE9dm9pZCAwfWlmKCFoYSl0aHJvdyBlYShcXFwibm9pZGVudFxcXCIscyk7fXZhciBxPWsuJCRiaW5kaW5ncz1uO0gocS5pc29sYXRlU2NvcGUpJiYoaC4kJGlzb2xhdGVCaW5kaW5ncz1xLmlzb2xhdGVTY29wZSk7aC4kJG1vZHVsZU5hbWU9ZS4kJG1vZHVsZU5hbWU7Zi5wdXNoKGgpfWNhdGNoKHQpe2QodCl9fSk7cmV0dXJuIGZ9XSkpLGVbYV0ucHVzaChmKSk6bShhLHBjKHMpKTtyZXR1cm4gdGhpc307dGhpcy5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdD1mdW5jdGlvbihiKXtyZXR1cm4gdyhiKT8oYS5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdChiKSx0aGlzKTphLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KCl9O1xcbnRoaXMuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0PWZ1bmN0aW9uKGIpe3JldHVybiB3KGIpPyhhLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdChiKSx0aGlzKTphLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCgpfTt2YXIgbj0hMDt0aGlzLmRlYnVnSW5mb0VuYWJsZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHcoYSk/KG49YSx0aGlzKTpufTt0aGlzLiRnZXQ9W1xcXCIkaW5qZWN0b3JcXFwiLFxcXCIkaW50ZXJwb2xhdGVcXFwiLFxcXCIkZXhjZXB0aW9uSGFuZGxlclxcXCIsXFxcIiR0ZW1wbGF0ZVJlcXVlc3RcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkY29udHJvbGxlclxcXCIsXFxcIiRyb290U2NvcGVcXFwiLFxcXCIkZG9jdW1lbnRcXFwiLFxcXCIkc2NlXFxcIixcXFwiJGFuaW1hdGVcXFwiLFxcXCIkJHNhbml0aXplVXJpXFxcIixmdW5jdGlvbihhLGIsYyxkLHUscCxLLHEsSSxCLE4pe2Z1bmN0aW9uIEQoYSxiKXt0cnl7YS5hZGRDbGFzcyhiKX1jYXRjaChjKXt9fWZ1bmN0aW9uIFooYSxiLGMsZCxlKXthIGluc3RhbmNlb2YgeXx8KGE9eShhKSk7bShhLGZ1bmN0aW9uKGIsYyl7Yi5ub2RlVHlwZT09XFxuTmEmJmIubm9kZVZhbHVlLm1hdGNoKC9cXFxcUysvKSYmKGFbY109eShiKS53cmFwKFxcXCI8c3Bhbj48L3NwYW4+XFxcIikucGFyZW50KClbMF0pfSk7dmFyIGY9UyhhLGIsYSxjLGQsZSk7Wi4kJGFkZFNjb3BlQ2xhc3MoYSk7dmFyIGc9bnVsbDtyZXR1cm4gZnVuY3Rpb24oYixjLGQpe1NiKGIsXFxcInNjb3BlXFxcIik7ZD1kfHx7fTt2YXIgZT1kLnBhcmVudEJvdW5kVHJhbnNjbHVkZUZuLGg9ZC50cmFuc2NsdWRlQ29udHJvbGxlcnM7ZD1kLmZ1dHVyZVBhcmVudEVsZW1lbnQ7ZSYmZS4kJGJvdW5kVHJhbnNjbHVkZSYmKGU9ZS4kJGJvdW5kVHJhbnNjbHVkZSk7Z3x8KGc9KGQ9ZCYmZFswXSk/XFxcImZvcmVpZ25vYmplY3RcXFwiIT09dGEoZCkmJmQudG9TdHJpbmcoKS5tYXRjaCgvU1ZHLyk/XFxcInN2Z1xcXCI6XFxcImh0bWxcXFwiOlxcXCJodG1sXFxcIik7ZD1cXFwiaHRtbFxcXCIhPT1nP3koWWIoZyx5KFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChhKS5odG1sKCkpKTpjP1BhLmNsb25lLmNhbGwoYSk6YTtpZihoKWZvcih2YXIgayBpbiBoKWQuZGF0YShcXFwiJFxcXCIraytcXFwiQ29udHJvbGxlclxcXCIsXFxuaFtrXS5pbnN0YW5jZSk7Wi4kJGFkZFNjb3BlSW5mbyhkLGIpO2MmJmMoZCxiKTtmJiZmKGIsZCxkLGUpO3JldHVybiBkfX1mdW5jdGlvbiBTKGEsYixjLGQsZSxmKXtmdW5jdGlvbiBnKGEsYyxkLGUpe3ZhciBmLGssbCxzLG4sQixDO2lmKHApZm9yKEM9QXJyYXkoYy5sZW5ndGgpLHM9MDtzPGgubGVuZ3RoO3MrPTMpZj1oW3NdLENbZl09Y1tmXTtlbHNlIEM9YztzPTA7Zm9yKG49aC5sZW5ndGg7czxuOylpZihrPUNbaFtzKytdXSxjPWhbcysrXSxmPWhbcysrXSxjKXtpZihjLnNjb3BlKXtpZihsPWEuJG5ldygpLFouJCRhZGRTY29wZUluZm8oeShrKSxsKSxCPWMuJCRkZXN0cm95QmluZGluZ3MpYy4kJGRlc3Ryb3lCaW5kaW5ncz1udWxsLGwuJG9uKFxcXCIkZGVzdHJveWVkXFxcIixCKX1lbHNlIGw9YTtCPWMudHJhbnNjbHVkZU9uVGhpc0VsZW1lbnQ/JChhLGMudHJhbnNjbHVkZSxlKTohYy50ZW1wbGF0ZU9uVGhpc0VsZW1lbnQmJmU/ZTohZSYmYj8kKGEsYik6bnVsbDtjKGYsbCxrLGQsXFxuQixjKX1lbHNlIGYmJmYoYSxrLmNoaWxkTm9kZXMsdCxlKX1mb3IodmFyIGg9W10sayxsLHMsbixwLEI9MDtCPGEubGVuZ3RoO0IrKyl7az1uZXcgYWE7bD1oYShhW0JdLFtdLGssMD09PUI/ZDp0LGUpOyhmPWwubGVuZ3RoP0UobCxhW0JdLGssYixjLG51bGwsW10sW10sZik6bnVsbCkmJmYuc2NvcGUmJlouJCRhZGRTY29wZUNsYXNzKGsuJCRlbGVtZW50KTtrPWYmJmYudGVybWluYWx8fCEocz1hW0JdLmNoaWxkTm9kZXMpfHwhcy5sZW5ndGg/bnVsbDpTKHMsZj8oZi50cmFuc2NsdWRlT25UaGlzRWxlbWVudHx8IWYudGVtcGxhdGVPblRoaXNFbGVtZW50KSYmZi50cmFuc2NsdWRlOmIpO2lmKGZ8fGspaC5wdXNoKEIsZixrKSxuPSEwLHA9cHx8ZjtmPW51bGx9cmV0dXJuIG4/ZzpudWxsfWZ1bmN0aW9uICQoYSxiLGMpe3JldHVybiBmdW5jdGlvbihkLGUsZixnLGgpe2R8fChkPWEuJG5ldyghMSxoKSxkLiQkdHJhbnNjbHVkZWQ9ITApO3JldHVybiBiKGQsZSx7cGFyZW50Qm91bmRUcmFuc2NsdWRlRm46YyxcXG50cmFuc2NsdWRlQ29udHJvbGxlcnM6ZixmdXR1cmVQYXJlbnRFbGVtZW50Omd9KX19ZnVuY3Rpb24gaGEoYSxiLGMsZCxlKXt2YXIgaD1jLiRhdHRyLGs7c3dpdGNoKGEubm9kZVR5cGUpe2Nhc2UgcWE6dyhiLHdhKHRhKGEpKSxcXFwiRVxcXCIsZCxlKTtmb3IodmFyIGwscyxuLHA9YS5hdHRyaWJ1dGVzLEI9MCxDPXAmJnAubGVuZ3RoO0I8QztCKyspe3ZhciB4PSExLFM9ITE7bD1wW0JdO2s9bC5uYW1lO3M9UihsLnZhbHVlKTtsPXdhKGspO2lmKG49aWEudGVzdChsKSlrPWsucmVwbGFjZShaYyxcXFwiXFxcIikuc3Vic3RyKDgpLnJlcGxhY2UoL18oLikvZyxmdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9KTt2YXIgRj1sLnJlcGxhY2UoLyhTdGFydHxFbmQpJC8sXFxcIlxcXCIpO0EoRikmJmw9PT1GK1xcXCJTdGFydFxcXCImJih4PWssUz1rLnN1YnN0cigwLGsubGVuZ3RoLTUpK1xcXCJlbmRcXFwiLGs9ay5zdWJzdHIoMCxrLmxlbmd0aC02KSk7bD13YShrLnRvTG93ZXJDYXNlKCkpO2hbbF09aztpZihufHwhYy5oYXNPd25Qcm9wZXJ0eShsKSljW2xdPVxcbnMsU2MoYSxsKSYmKGNbbF09ITApO1YoYSxiLHMsbCxuKTt3KGIsbCxcXFwiQVxcXCIsZCxlLHgsUyl9YT1hLmNsYXNzTmFtZTtIKGEpJiYoYT1hLmFuaW1WYWwpO2lmKEwoYSkmJlxcXCJcXFwiIT09YSlmb3IoO2s9Zy5leGVjKGEpOylsPXdhKGtbMl0pLHcoYixsLFxcXCJDXFxcIixkLGUpJiYoY1tsXT1SKGtbM10pKSxhPWEuc3Vic3RyKGsuaW5kZXgra1swXS5sZW5ndGgpO2JyZWFrO2Nhc2UgTmE6aWYoMTE9PT1VYSlmb3IoO2EucGFyZW50Tm9kZSYmYS5uZXh0U2libGluZyYmYS5uZXh0U2libGluZy5ub2RlVHlwZT09PU5hOylhLm5vZGVWYWx1ZSs9YS5uZXh0U2libGluZy5ub2RlVmFsdWUsYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEubmV4dFNpYmxpbmcpO3hhKGIsYS5ub2RlVmFsdWUpO2JyZWFrO2Nhc2UgODp0cnl7aWYoaz1mLmV4ZWMoYS5ub2RlVmFsdWUpKWw9d2Eoa1sxXSksdyhiLGwsXFxcIk1cXFwiLGQsZSkmJihjW2xdPVIoa1syXSkpfWNhdGNoKCQpe319Yi5zb3J0KEFhKTtyZXR1cm4gYn1mdW5jdGlvbiB2YShhLFxcbmIsYyl7dmFyIGQ9W10sZT0wO2lmKGImJmEuaGFzQXR0cmlidXRlJiZhLmhhc0F0dHJpYnV0ZShiKSl7ZG97aWYoIWEpdGhyb3cgZWEoXFxcInV0ZXJkaXJcXFwiLGIsYyk7YS5ub2RlVHlwZT09cWEmJihhLmhhc0F0dHJpYnV0ZShiKSYmZSsrLGEuaGFzQXR0cmlidXRlKGMpJiZlLS0pO2QucHVzaChhKTthPWEubmV4dFNpYmxpbmd9d2hpbGUoMDxlKX1lbHNlIGQucHVzaChhKTtyZXR1cm4geShkKX1mdW5jdGlvbiBZYyhhLGIsYyl7cmV0dXJuIGZ1bmN0aW9uKGQsZSxmLGcsaCl7ZT12YShlWzBdLGIsYyk7cmV0dXJuIGEoZCxlLGYsZyxoKX19ZnVuY3Rpb24gRShhLGIsZCxlLGYsZyxoLGsscyl7ZnVuY3Rpb24gbihhLGIsYyxkKXtpZihhKXtjJiYoYT1ZYyhhLGMsZCkpO2EucmVxdWlyZT1FLnJlcXVpcmU7YS5kaXJlY3RpdmVOYW1lPXc7aWYodT09PUV8fEUuJCRpc29sYXRlU2NvcGUpYT1YKGEse2lzb2xhdGVTY29wZTohMH0pO2gucHVzaChhKX1pZihiKXtjJiYoYj1ZYyhiLGMsZCkpO2IucmVxdWlyZT1cXG5FLnJlcXVpcmU7Yi5kaXJlY3RpdmVOYW1lPXc7aWYodT09PUV8fEUuJCRpc29sYXRlU2NvcGUpYj1YKGIse2lzb2xhdGVTY29wZTohMH0pO2sucHVzaChiKX19ZnVuY3Rpb24gQihhLGIsYyxkKXt2YXIgZTtpZihMKGIpKXt2YXIgZj1iLm1hdGNoKGwpO2I9Yi5zdWJzdHJpbmcoZlswXS5sZW5ndGgpO3ZhciBnPWZbMV18fGZbM10sZj1cXFwiP1xcXCI9PT1mWzJdO1xcXCJeXlxcXCI9PT1nP2M9Yy5wYXJlbnQoKTplPShlPWQmJmRbYl0pJiZlLmluc3RhbmNlO2V8fChkPVxcXCIkXFxcIitiK1xcXCJDb250cm9sbGVyXFxcIixlPWc/Yy5pbmhlcml0ZWREYXRhKGQpOmMuZGF0YShkKSk7aWYoIWUmJiFmKXRocm93IGVhKFxcXCJjdHJlcVxcXCIsYixhKTt9ZWxzZSBpZihHKGIpKWZvcihlPVtdLGc9MCxmPWIubGVuZ3RoO2c8ZjtnKyspZVtnXT1CKGEsYltnXSxjLGQpO3JldHVybiBlfHxudWxsfWZ1bmN0aW9uIHgoYSxiLGMsZCxlLGYpe3ZhciBnPWdhKCksaDtmb3IoaCBpbiBkKXt2YXIgaz1kW2hdLGw9eyRzY29wZTprPT09dXx8ay4kJGlzb2xhdGVTY29wZT9cXG5lOmYsJGVsZW1lbnQ6YSwkYXR0cnM6YiwkdHJhbnNjbHVkZTpjfSxzPWsuY29udHJvbGxlcjtcXFwiQFxcXCI9PXMmJihzPWJbay5uYW1lXSk7bD1wKHMsbCwhMCxrLmNvbnRyb2xsZXJBcyk7Z1trLm5hbWVdPWw7cXx8YS5kYXRhKFxcXCIkXFxcIitrLm5hbWUrXFxcIkNvbnRyb2xsZXJcXFwiLGwuaW5zdGFuY2UpfXJldHVybiBnfWZ1bmN0aW9uIFMoYSxjLGUsZixnLGwpe2Z1bmN0aW9uIHMoYSxiLGMpe3ZhciBkOyRhKGEpfHwoYz1iLGI9YSxhPXQpO3EmJihkPW0pO2N8fChjPXE/amEucGFyZW50KCk6amEpO3JldHVybiBnKGEsYixkLGMsdmEpfXZhciBuLHAsQyxGLG0saGEsamE7Yj09PWU/KGY9ZCxqYT1kLiQkZWxlbWVudCk6KGphPXkoZSksZj1uZXcgYWEoamEsZCkpO3UmJihGPWMuJG5ldyghMCkpO2cmJihoYT1zLGhhLiQkYm91bmRUcmFuc2NsdWRlPWcpO04mJihtPXgoamEsZixoYSxOLEYsYykpO3UmJihaLiQkYWRkU2NvcGVJbmZvKGphLEYsITAsIShEJiYoRD09PXV8fEQ9PT11LiQkb3JpZ2luYWxEaXJlY3RpdmUpKSksXFxuWi4kJGFkZFNjb3BlQ2xhc3MoamEsITApLEYuJCRpc29sYXRlQmluZGluZ3M9dS4kJGlzb2xhdGVCaW5kaW5ncyxXKGMsZixGLEYuJCRpc29sYXRlQmluZGluZ3MsdSxGKSk7aWYobSl7dmFyIEs9dXx8JCxJO0smJm1bSy5uYW1lXSYmKHA9Sy4kJGJpbmRpbmdzLmJpbmRUb0NvbnRyb2xsZXIsKEM9bVtLLm5hbWVdKSYmQy5pZGVudGlmaWVyJiZwJiYoST1DLGwuJCRkZXN0cm95QmluZGluZ3M9VyhjLGYsQy5pbnN0YW5jZSxwLEspKSk7Zm9yKG4gaW4gbSl7Qz1tW25dO3ZhciBFPUMoKTtFIT09Qy5pbnN0YW5jZSYmKEMuaW5zdGFuY2U9RSxqYS5kYXRhKFxcXCIkXFxcIituK1xcXCJDb250cm9sbGVyXFxcIixFKSxDPT09SSYmKGwuJCRkZXN0cm95QmluZGluZ3MoKSxsLiQkZGVzdHJveUJpbmRpbmdzPVcoYyxmLEUscCxLKSkpfX1uPTA7Zm9yKGw9aC5sZW5ndGg7bjxsO24rKylwPWhbbl0sWShwLHAuaXNvbGF0ZVNjb3BlP0Y6YyxqYSxmLHAucmVxdWlyZSYmQihwLmRpcmVjdGl2ZU5hbWUscC5yZXF1aXJlLFxcbmphLG0pLGhhKTt2YXIgdmE9Yzt1JiYodS50ZW1wbGF0ZXx8bnVsbD09PXUudGVtcGxhdGVVcmwpJiYodmE9Rik7YSYmYSh2YSxlLmNoaWxkTm9kZXMsdCxnKTtmb3Iobj1rLmxlbmd0aC0xOzA8PW47bi0tKXA9a1tuXSxZKHAscC5pc29sYXRlU2NvcGU/RjpjLGphLGYscC5yZXF1aXJlJiZCKHAuZGlyZWN0aXZlTmFtZSxwLnJlcXVpcmUsamEsbSksaGEpfXM9c3x8e307Zm9yKHZhciBGPS1OdW1iZXIuTUFYX1ZBTFVFLCQ9cy5uZXdTY29wZURpcmVjdGl2ZSxOPXMuY29udHJvbGxlckRpcmVjdGl2ZXMsdT1zLm5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSxEPXMudGVtcGxhdGVEaXJlY3RpdmUsbT1zLm5vblRsYlRyYW5zY2x1ZGVEaXJlY3RpdmUsSz0hMSxJPSExLHE9cy5oYXNFbGVtZW50VHJhbnNjbHVkZURpcmVjdGl2ZSxiYT1kLiQkZWxlbWVudD15KGIpLEUsdyx2LEE9ZSxBYSx4YT0wLFRhPWEubGVuZ3RoO3hhPFRhO3hhKyspe0U9YVt4YV07dmFyIE09RS4kJHN0YXJ0LFA9RS4kJGVuZDtcXG5NJiYoYmE9dmEoYixNLFApKTt2PXQ7aWYoRj5FLnByaW9yaXR5KWJyZWFrO2lmKHY9RS5zY29wZSlFLnRlbXBsYXRlVXJsfHwoSCh2KT8oTyhcXFwibmV3L2lzb2xhdGVkIHNjb3BlXFxcIix1fHwkLEUsYmEpLHU9RSk6TyhcXFwibmV3L2lzb2xhdGVkIHNjb3BlXFxcIix1LEUsYmEpKSwkPSR8fEU7dz1FLm5hbWU7IUUudGVtcGxhdGVVcmwmJkUuY29udHJvbGxlciYmKHY9RS5jb250cm9sbGVyLE49Tnx8Z2EoKSxPKFxcXCInXFxcIit3K1xcXCInIGNvbnRyb2xsZXJcXFwiLE5bd10sRSxiYSksTlt3XT1FKTtpZih2PUUudHJhbnNjbHVkZSlLPSEwLEUuJCR0bGJ8fChPKFxcXCJ0cmFuc2NsdXNpb25cXFwiLG0sRSxiYSksbT1FKSxcXFwiZWxlbWVudFxcXCI9PXY/KHE9ITAsRj1FLnByaW9yaXR5LHY9YmEsYmE9ZC4kJGVsZW1lbnQ9eShVLmNyZWF0ZUNvbW1lbnQoXFxcIiBcXFwiK3crXFxcIjogXFxcIitkW3ddK1xcXCIgXFxcIikpLGI9YmFbMF0sVChmLHphLmNhbGwodiwwKSxiKSxBPVoodixlLEYsZyYmZy5uYW1lLHtub25UbGJUcmFuc2NsdWRlRGlyZWN0aXZlOm19KSk6KHY9XFxueShWYihiKSkuY29udGVudHMoKSxiYS5lbXB0eSgpLEE9Wih2LGUpKTtpZihFLnRlbXBsYXRlKWlmKEk9ITAsTyhcXFwidGVtcGxhdGVcXFwiLEQsRSxiYSksRD1FLHY9eihFLnRlbXBsYXRlKT9FLnRlbXBsYXRlKGJhLGQpOkUudGVtcGxhdGUsdj1mYSh2KSxFLnJlcGxhY2Upe2c9RTt2PVRiLnRlc3Qodik/JGMoWWIoRS50ZW1wbGF0ZU5hbWVzcGFjZSxSKHYpKSk6W107Yj12WzBdO2lmKDEhPXYubGVuZ3RofHxiLm5vZGVUeXBlIT09cWEpdGhyb3cgZWEoXFxcInRwbHJ0XFxcIix3LFxcXCJcXFwiKTtUKGYsYmEsYik7VGE9eyRhdHRyOnt9fTt2PWhhKGIsW10sVGEpO3ZhciBRPWEuc3BsaWNlKHhhKzEsYS5sZW5ndGgtKHhhKzEpKTt1JiZhZCh2KTthPWEuY29uY2F0KHYpLmNvbmNhdChRKTtKKGQsVGEpO1RhPWEubGVuZ3RofWVsc2UgYmEuaHRtbCh2KTtpZihFLnRlbXBsYXRlVXJsKUk9ITAsTyhcXFwidGVtcGxhdGVcXFwiLEQsRSxiYSksRD1FLEUucmVwbGFjZSYmKGc9RSksUz1NZihhLnNwbGljZSh4YSxhLmxlbmd0aC14YSksXFxuYmEsZCxmLEsmJkEsaCxrLHtjb250cm9sbGVyRGlyZWN0aXZlczpOLG5ld1Njb3BlRGlyZWN0aXZlOiQhPT1FJiYkLG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZTp1LHRlbXBsYXRlRGlyZWN0aXZlOkQsbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZTptfSksVGE9YS5sZW5ndGg7ZWxzZSBpZihFLmNvbXBpbGUpdHJ5e0FhPUUuY29tcGlsZShiYSxkLEEpLHooQWEpP24obnVsbCxBYSxNLFApOkFhJiZuKEFhLnByZSxBYS5wb3N0LE0sUCl9Y2F0Y2goTGYpe2MoTGYsdWEoYmEpKX1FLnRlcm1pbmFsJiYoUy50ZXJtaW5hbD0hMCxGPU1hdGgubWF4KEYsRS5wcmlvcml0eSkpfVMuc2NvcGU9JCYmITA9PT0kLnNjb3BlO1MudHJhbnNjbHVkZU9uVGhpc0VsZW1lbnQ9SztTLnRlbXBsYXRlT25UaGlzRWxlbWVudD1JO1MudHJhbnNjbHVkZT1BO3MuaGFzRWxlbWVudFRyYW5zY2x1ZGVEaXJlY3RpdmU9cTtyZXR1cm4gU31mdW5jdGlvbiBhZChhKXtmb3IodmFyIGI9MCxjPWEubGVuZ3RoO2I8YztiKyspYVtiXT1cXG5PYihhW2JdLHskJGlzb2xhdGVTY29wZTohMH0pfWZ1bmN0aW9uIHcoYixkLGYsZyxoLGssbCl7aWYoZD09PWgpcmV0dXJuIG51bGw7aD1udWxsO2lmKGUuaGFzT3duUHJvcGVydHkoZCkpe3ZhciBuO2Q9YS5nZXQoZCtcXFwiRGlyZWN0aXZlXFxcIik7Zm9yKHZhciBwPTAsQj1kLmxlbmd0aDtwPEI7cCsrKXRyeXtuPWRbcF0sKGc9PT10fHxnPm4ucHJpb3JpdHkpJiYtMSE9bi5yZXN0cmljdC5pbmRleE9mKGYpJiYoayYmKG49T2Iobix7JCRzdGFydDprLCQkZW5kOmx9KSksYi5wdXNoKG4pLGg9bil9Y2F0Y2goeCl7Yyh4KX19cmV0dXJuIGh9ZnVuY3Rpb24gQShiKXtpZihlLmhhc093blByb3BlcnR5KGIpKWZvcih2YXIgYz1hLmdldChiK1xcXCJEaXJlY3RpdmVcXFwiKSxkPTAsZj1jLmxlbmd0aDtkPGY7ZCsrKWlmKGI9Y1tkXSxiLm11bHRpRWxlbWVudClyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBKKGEsYil7dmFyIGM9Yi4kYXR0cixkPWEuJGF0dHIsZT1hLiQkZWxlbWVudDttKGEsZnVuY3Rpb24oZCxcXG5lKXtcXFwiJFxcXCIhPWUuY2hhckF0KDApJiYoYltlXSYmYltlXSE9PWQmJihkKz0oXFxcInN0eWxlXFxcIj09PWU/XFxcIjtcXFwiOlxcXCIgXFxcIikrYltlXSksYS4kc2V0KGUsZCwhMCxjW2VdKSl9KTttKGIsZnVuY3Rpb24oYixmKXtcXFwiY2xhc3NcXFwiPT1mPyhEKGUsYiksYVtcXFwiY2xhc3NcXFwiXT0oYVtcXFwiY2xhc3NcXFwiXT9hW1xcXCJjbGFzc1xcXCJdK1xcXCIgXFxcIjpcXFwiXFxcIikrYik6XFxcInN0eWxlXFxcIj09Zj8oZS5hdHRyKFxcXCJzdHlsZVxcXCIsZS5hdHRyKFxcXCJzdHlsZVxcXCIpK1xcXCI7XFxcIitiKSxhLnN0eWxlPShhLnN0eWxlP2Euc3R5bGUrXFxcIjtcXFwiOlxcXCJcXFwiKStiKTpcXFwiJFxcXCI9PWYuY2hhckF0KDApfHxhLmhhc093blByb3BlcnR5KGYpfHwoYVtmXT1iLGRbZl09Y1tmXSl9KX1mdW5jdGlvbiBNZihhLGIsYyxlLGYsZyxoLGspe3ZhciBsPVtdLHMsbixwPWJbMF0sQj1hLnNoaWZ0KCksQz1PYihCLHt0ZW1wbGF0ZVVybDpudWxsLHRyYW5zY2x1ZGU6bnVsbCxyZXBsYWNlOm51bGwsJCRvcmlnaW5hbERpcmVjdGl2ZTpCfSkseD16KEIudGVtcGxhdGVVcmwpP0IudGVtcGxhdGVVcmwoYixjKTpCLnRlbXBsYXRlVXJsLFxcbk49Qi50ZW1wbGF0ZU5hbWVzcGFjZTtiLmVtcHR5KCk7ZCh4KS50aGVuKGZ1bmN0aW9uKGQpe3ZhciBGLHU7ZD1mYShkKTtpZihCLnJlcGxhY2Upe2Q9VGIudGVzdChkKT8kYyhZYihOLFIoZCkpKTpbXTtGPWRbMF07aWYoMSE9ZC5sZW5ndGh8fEYubm9kZVR5cGUhPT1xYSl0aHJvdyBlYShcXFwidHBscnRcXFwiLEIubmFtZSx4KTtkPXskYXR0cjp7fX07VChlLGIsRik7dmFyIEs9aGEoRixbXSxkKTtIKEIuc2NvcGUpJiZhZChLKTthPUsuY29uY2F0KGEpO0ooYyxkKX1lbHNlIEY9cCxiLmh0bWwoZCk7YS51bnNoaWZ0KEMpO3M9RShhLEYsYyxmLGIsQixnLGgsayk7bShlLGZ1bmN0aW9uKGEsYyl7YT09RiYmKGVbY109YlswXSl9KTtmb3Iobj1TKGJbMF0uY2hpbGROb2RlcyxmKTtsLmxlbmd0aDspe2Q9bC5zaGlmdCgpO3U9bC5zaGlmdCgpO3ZhciBJPWwuc2hpZnQoKSx2YT1sLnNoaWZ0KCksSz1iWzBdO2lmKCFkLiQkZGVzdHJveWVkKXtpZih1IT09cCl7dmFyIFo9dS5jbGFzc05hbWU7ay5oYXNFbGVtZW50VHJhbnNjbHVkZURpcmVjdGl2ZSYmXFxuQi5yZXBsYWNlfHwoSz1WYihGKSk7VChJLHkodSksSyk7RCh5KEspLFopfXU9cy50cmFuc2NsdWRlT25UaGlzRWxlbWVudD8kKGQscy50cmFuc2NsdWRlLHZhKTp2YTtzKG4sZCxLLGUsdSxzKX19bD1udWxsfSk7cmV0dXJuIGZ1bmN0aW9uKGEsYixjLGQsZSl7YT1lO2IuJCRkZXN0cm95ZWR8fChsP2wucHVzaChiLGMsZCxhKToocy50cmFuc2NsdWRlT25UaGlzRWxlbWVudCYmKGE9JChiLHMudHJhbnNjbHVkZSxlKSkscyhuLGIsYyxkLGEscykpKX19ZnVuY3Rpb24gQWEoYSxiKXt2YXIgYz1iLnByaW9yaXR5LWEucHJpb3JpdHk7cmV0dXJuIDAhPT1jP2M6YS5uYW1lIT09Yi5uYW1lP2EubmFtZTxiLm5hbWU/LTE6MTphLmluZGV4LWIuaW5kZXh9ZnVuY3Rpb24gTyhhLGIsYyxkKXtmdW5jdGlvbiBlKGEpe3JldHVybiBhP1xcXCIgKG1vZHVsZTogXFxcIithK1xcXCIpXFxcIjpcXFwiXFxcIn1pZihiKXRocm93IGVhKFxcXCJtdWx0aWRpclxcXCIsYi5uYW1lLGUoYi4kJG1vZHVsZU5hbWUpLGMubmFtZSxlKGMuJCRtb2R1bGVOYW1lKSxcXG5hLHVhKGQpKTt9ZnVuY3Rpb24geGEoYSxjKXt2YXIgZD1iKGMsITApO2QmJmEucHVzaCh7cHJpb3JpdHk6MCxjb21waWxlOmZ1bmN0aW9uKGEpe2E9YS5wYXJlbnQoKTt2YXIgYj0hIWEubGVuZ3RoO2ImJlouJCRhZGRCaW5kaW5nQ2xhc3MoYSk7cmV0dXJuIGZ1bmN0aW9uKGEsYyl7dmFyIGU9Yy5wYXJlbnQoKTtifHxaLiQkYWRkQmluZGluZ0NsYXNzKGUpO1ouJCRhZGRCaW5kaW5nSW5mbyhlLGQuZXhwcmVzc2lvbnMpO2EuJHdhdGNoKGQsZnVuY3Rpb24oYSl7Y1swXS5ub2RlVmFsdWU9YX0pfX19KX1mdW5jdGlvbiBZYihhLGIpe2E9TShhfHxcXFwiaHRtbFxcXCIpO3N3aXRjaChhKXtjYXNlIFxcXCJzdmdcXFwiOmNhc2UgXFxcIm1hdGhcXFwiOnZhciBjPVUuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Yy5pbm5lckhUTUw9XFxcIjxcXFwiK2ErXFxcIj5cXFwiK2IrXFxcIjwvXFxcIithK1xcXCI+XFxcIjtyZXR1cm4gYy5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXM7ZGVmYXVsdDpyZXR1cm4gYn19ZnVuY3Rpb24gUShhLGIpe2lmKFxcXCJzcmNkb2NcXFwiPT1iKXJldHVybiBJLkhUTUw7XFxudmFyIGM9dGEoYSk7aWYoXFxcInhsaW5rSHJlZlxcXCI9PWJ8fFxcXCJmb3JtXFxcIj09YyYmXFxcImFjdGlvblxcXCI9PWJ8fFxcXCJpbWdcXFwiIT1jJiYoXFxcInNyY1xcXCI9PWJ8fFxcXCJuZ1NyY1xcXCI9PWIpKXJldHVybiBJLlJFU09VUkNFX1VSTH1mdW5jdGlvbiBWKGEsYyxkLGUsZil7dmFyIGc9UShhLGUpO2Y9aFtlXXx8Zjt2YXIgbD1iKGQsITAsZyxmKTtpZihsKXtpZihcXFwibXVsdGlwbGVcXFwiPT09ZSYmXFxcInNlbGVjdFxcXCI9PT10YShhKSl0aHJvdyBlYShcXFwic2VsbXVsdGlcXFwiLHVhKGEpKTtjLnB1c2goe3ByaW9yaXR5OjEwMCxjb21waWxlOmZ1bmN0aW9uKCl7cmV0dXJue3ByZTpmdW5jdGlvbihhLGMsaCl7Yz1oLiQkb2JzZXJ2ZXJzfHwoaC4kJG9ic2VydmVycz17fSk7aWYoay50ZXN0KGUpKXRocm93IGVhKFxcXCJub2RvbWV2ZW50c1xcXCIpO3ZhciBzPWhbZV07cyE9PWQmJihsPXMmJmIocywhMCxnLGYpLGQ9cyk7bCYmKGhbZV09bChhKSwoY1tlXXx8KGNbZV09W10pKS4kJGludGVyPSEwLChoLiQkb2JzZXJ2ZXJzJiZoLiQkb2JzZXJ2ZXJzW2VdLiQkc2NvcGV8fFxcbmEpLiR3YXRjaChsLGZ1bmN0aW9uKGEsYil7XFxcImNsYXNzXFxcIj09PWUmJmEhPWI/aC4kdXBkYXRlQ2xhc3MoYSxiKTpoLiRzZXQoZSxhKX0pKX19fX0pfX1mdW5jdGlvbiBUKGEsYixjKXt2YXIgZD1iWzBdLGU9Yi5sZW5ndGgsZj1kLnBhcmVudE5vZGUsZyxoO2lmKGEpZm9yKGc9MCxoPWEubGVuZ3RoO2c8aDtnKyspaWYoYVtnXT09ZCl7YVtnKytdPWM7aD1nK2UtMTtmb3IodmFyIGs9YS5sZW5ndGg7ZzxrO2crKyxoKyspaDxrP2FbZ109YVtoXTpkZWxldGUgYVtnXTthLmxlbmd0aC09ZS0xO2EuY29udGV4dD09PWQmJihhLmNvbnRleHQ9Yyk7YnJlYWt9ZiYmZi5yZXBsYWNlQ2hpbGQoYyxkKTthPVUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2EuYXBwZW5kQ2hpbGQoZCk7eS5oYXNEYXRhKGQpJiYoeShjKS5kYXRhKHkoZCkuZGF0YSgpKSxsYT8oUmI9ITAsbGEuY2xlYW5EYXRhKFtkXSkpOmRlbGV0ZSB5LmNhY2hlW2RbeS5leHBhbmRvXV0pO2Q9MTtmb3IoZT1iLmxlbmd0aDtkPGU7ZCsrKWY9XFxuYltkXSx5KGYpLnJlbW92ZSgpLGEuYXBwZW5kQ2hpbGQoZiksZGVsZXRlIGJbZF07YlswXT1jO2IubGVuZ3RoPTF9ZnVuY3Rpb24gWChhLGIpe3JldHVybiBQKGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxhLGIpfWZ1bmN0aW9uIFkoYSxiLGQsZSxmLGcpe3RyeXthKGIsZCxlLGYsZyl9Y2F0Y2goaCl7YyhoLHVhKGQpKX19ZnVuY3Rpb24gVyhhLGMsZCxlLGYsZyl7dmFyIGg7bShlLGZ1bmN0aW9uKGUsZyl7dmFyIGs9ZS5hdHRyTmFtZSxsPWUub3B0aW9uYWwscz1lLm1vZGUsbixwLEIsQztYYS5jYWxsKGMsayl8fChjW2tdPXQpO3N3aXRjaChzKXtjYXNlIFxcXCJAXFxcIjpjW2tdfHxsfHwoZFtnXT10KTtjLiRvYnNlcnZlKGssZnVuY3Rpb24oYSl7ZFtnXT1hfSk7Yy4kJG9ic2VydmVyc1trXS4kJHNjb3BlPWE7Y1trXSYmKGRbZ109YihjW2tdKShhKSk7YnJlYWs7Y2FzZSBcXFwiPVxcXCI6aWYobCYmIWNba10pYnJlYWs7cD11KGNba10pO0M9cC5saXRlcmFsP2thOmZ1bmN0aW9uKGEsXFxuYil7cmV0dXJuIGE9PT1ifHxhIT09YSYmYiE9PWJ9O0I9cC5hc3NpZ258fGZ1bmN0aW9uKCl7bj1kW2ddPXAoYSk7dGhyb3cgZWEoXFxcIm5vbmFzc2lnblxcXCIsY1trXSxmLm5hbWUpO307bj1kW2ddPXAoYSk7bD1mdW5jdGlvbihiKXtDKGIsZFtnXSl8fChDKGIsbik/QihhLGI9ZFtnXSk6ZFtnXT1iKTtyZXR1cm4gbj1ifTtsLiRzdGF0ZWZ1bD0hMDtsPWUuY29sbGVjdGlvbj9hLiR3YXRjaENvbGxlY3Rpb24oY1trXSxsKTphLiR3YXRjaCh1KGNba10sbCksbnVsbCxwLmxpdGVyYWwpO2g9aHx8W107aC5wdXNoKGwpO2JyZWFrO2Nhc2UgXFxcIiZcXFwiOnA9dShjW2tdKTtpZihwPT09diYmbClicmVhaztkW2ddPWZ1bmN0aW9uKGIpe3JldHVybiBwKGEsYil9fX0pO2U9aD9mdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9aC5sZW5ndGg7YTxiOysrYSloW2FdKCl9OnY7cmV0dXJuIGcmJmUhPT12PyhnLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGUpLHYpOmV9dmFyIGFhPWZ1bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9T2JqZWN0LmtleXMoYiksXFxuZCxlLGY7ZD0wO2ZvcihlPWMubGVuZ3RoO2Q8ZTtkKyspZj1jW2RdLHRoaXNbZl09YltmXX1lbHNlIHRoaXMuJGF0dHI9e307dGhpcy4kJGVsZW1lbnQ9YX07YWEucHJvdG90eXBlPXskbm9ybWFsaXplOndhLCRhZGRDbGFzczpmdW5jdGlvbihhKXthJiYwPGEubGVuZ3RoJiZCLmFkZENsYXNzKHRoaXMuJCRlbGVtZW50LGEpfSwkcmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYSl7YSYmMDxhLmxlbmd0aCYmQi5yZW1vdmVDbGFzcyh0aGlzLiQkZWxlbWVudCxhKX0sJHVwZGF0ZUNsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YmQoYSxiKTtjJiZjLmxlbmd0aCYmQi5hZGRDbGFzcyh0aGlzLiQkZWxlbWVudCxjKTsoYz1iZChiLGEpKSYmYy5sZW5ndGgmJkIucmVtb3ZlQ2xhc3ModGhpcy4kJGVsZW1lbnQsYyl9LCRzZXQ6ZnVuY3Rpb24oYSxiLGQsZSl7dmFyIGY9dGhpcy4kJGVsZW1lbnRbMF0sZz1TYyhmLGEpLGg9R2YoZixhKSxmPWE7Zz8odGhpcy4kJGVsZW1lbnQucHJvcChhLGIpLGU9Zyk6XFxuaCYmKHRoaXNbaF09YixmPWgpO3RoaXNbYV09YjtlP3RoaXMuJGF0dHJbYV09ZTooZT10aGlzLiRhdHRyW2FdKXx8KHRoaXMuJGF0dHJbYV09ZT1CYyhhLFxcXCItXFxcIikpO2c9dGEodGhpcy4kJGVsZW1lbnQpO2lmKFxcXCJhXFxcIj09PWcmJlxcXCJocmVmXFxcIj09PWF8fFxcXCJpbWdcXFwiPT09ZyYmXFxcInNyY1xcXCI9PT1hKXRoaXNbYV09Yj1OKGIsXFxcInNyY1xcXCI9PT1hKTtlbHNlIGlmKFxcXCJpbWdcXFwiPT09ZyYmXFxcInNyY3NldFxcXCI9PT1hKXtmb3IodmFyIGc9XFxcIlxcXCIsaD1SKGIpLGs9LyhcXFxccytcXFxcZCt4XFxcXHMqLHxcXFxccytcXFxcZCt3XFxcXHMqLHxcXFxccyssfCxcXFxccyspLyxrPS9cXFxccy8udGVzdChoKT9rOi8oLCkvLGg9aC5zcGxpdChrKSxrPU1hdGguZmxvb3IoaC5sZW5ndGgvMiksbD0wO2w8aztsKyspdmFyIHM9MipsLGc9ZytOKFIoaFtzXSksITApLGc9ZysoXFxcIiBcXFwiK1IoaFtzKzFdKSk7aD1SKGhbMipsXSkuc3BsaXQoL1xcXFxzLyk7Zys9TihSKGhbMF0pLCEwKTsyPT09aC5sZW5ndGgmJihnKz1cXFwiIFxcXCIrUihoWzFdKSk7dGhpc1thXT1iPWd9ITEhPT1kJiYobnVsbD09PWJ8fFxcbmI9PT10P3RoaXMuJCRlbGVtZW50LnJlbW92ZUF0dHIoZSk6dGhpcy4kJGVsZW1lbnQuYXR0cihlLGIpKTsoYT10aGlzLiQkb2JzZXJ2ZXJzKSYmbShhW2ZdLGZ1bmN0aW9uKGEpe3RyeXthKGIpfWNhdGNoKGQpe2MoZCl9fSl9LCRvYnNlcnZlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPWMuJCRvYnNlcnZlcnN8fChjLiQkb2JzZXJ2ZXJzPWdhKCkpLGU9ZFthXXx8KGRbYV09W10pO2UucHVzaChiKTtLLiRldmFsQXN5bmMoZnVuY3Rpb24oKXshZS4kJGludGVyJiZjLmhhc093blByb3BlcnR5KGEpJiZiKGNbYV0pfSk7cmV0dXJuIGZ1bmN0aW9uKCl7YmIoZSxiKX19fTt2YXIgY2E9Yi5zdGFydFN5bWJvbCgpLGRhPWIuZW5kU3ltYm9sKCksZmE9XFxcInt7XFxcIj09Y2F8fFxcXCJ9fVxcXCI9PWRhP1lhOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFx7XFxcXHsvZyxjYSkucmVwbGFjZSgvfX0vZyxkYSl9LGlhPS9ebmdBdHRyW0EtWl0vO1ouJCRhZGRCaW5kaW5nSW5mbz1uP2Z1bmN0aW9uKGEsYil7dmFyIGM9XFxuYS5kYXRhKFxcXCIkYmluZGluZ1xcXCIpfHxbXTtHKGIpP2M9Yy5jb25jYXQoYik6Yy5wdXNoKGIpO2EuZGF0YShcXFwiJGJpbmRpbmdcXFwiLGMpfTp2O1ouJCRhZGRCaW5kaW5nQ2xhc3M9bj9mdW5jdGlvbihhKXtEKGEsXFxcIm5nLWJpbmRpbmdcXFwiKX06djtaLiQkYWRkU2NvcGVJbmZvPW4/ZnVuY3Rpb24oYSxiLGMsZCl7YS5kYXRhKGM/ZD9cXFwiJGlzb2xhdGVTY29wZU5vVGVtcGxhdGVcXFwiOlxcXCIkaXNvbGF0ZVNjb3BlXFxcIjpcXFwiJHNjb3BlXFxcIixiKX06djtaLiQkYWRkU2NvcGVDbGFzcz1uP2Z1bmN0aW9uKGEsYil7RChhLGI/XFxcIm5nLWlzb2xhdGUtc2NvcGVcXFwiOlxcXCJuZy1zY29wZVxcXCIpfTp2O3JldHVybiBafV19ZnVuY3Rpb24gd2EoYil7cmV0dXJuIGhiKGIucmVwbGFjZShaYyxcXFwiXFxcIikpfWZ1bmN0aW9uIGJkKGIsYSl7dmFyIGM9XFxcIlxcXCIsZD1iLnNwbGl0KC9cXFxccysvKSxlPWEuc3BsaXQoL1xcXFxzKy8pLGY9MDthOmZvcig7ZjxkLmxlbmd0aDtmKyspe2Zvcih2YXIgZz1kW2ZdLGg9MDtoPGUubGVuZ3RoO2grKylpZihnPT1lW2hdKWNvbnRpbnVlIGE7XFxuYys9KDA8Yy5sZW5ndGg/XFxcIiBcXFwiOlxcXCJcXFwiKStnfXJldHVybiBjfWZ1bmN0aW9uICRjKGIpe2I9eShiKTt2YXIgYT1iLmxlbmd0aDtpZigxPj1hKXJldHVybiBiO2Zvcig7YS0tOyk4PT09YlthXS5ub2RlVHlwZSYmTmYuY2FsbChiLGEsMSk7cmV0dXJuIGJ9ZnVuY3Rpb24gWGUoKXt2YXIgYj17fSxhPSExO3RoaXMucmVnaXN0ZXI9ZnVuY3Rpb24oYSxkKXtSYShhLFxcXCJjb250cm9sbGVyXFxcIik7SChhKT9QKGIsYSk6YlthXT1kfTt0aGlzLmFsbG93R2xvYmFscz1mdW5jdGlvbigpe2E9ITB9O3RoaXMuJGdldD1bXFxcIiRpbmplY3RvclxcXCIsXFxcIiR3aW5kb3dcXFwiLGZ1bmN0aW9uKGMsZCl7ZnVuY3Rpb24gZShhLGIsYyxkKXtpZighYXx8IUgoYS4kc2NvcGUpKXRocm93IEooXFxcIiRjb250cm9sbGVyXFxcIikoXFxcIm5vc2NwXFxcIixkLGIpO2EuJHNjb3BlW2JdPWN9cmV0dXJuIGZ1bmN0aW9uKGYsZyxoLGwpe3ZhciBrLG4scjtoPSEwPT09aDtsJiZMKGwpJiYocj1sKTtpZihMKGYpKXtsPWYubWF0Y2goWGMpO2lmKCFsKXRocm93IE9mKFxcXCJjdHJsZm10XFxcIixcXG5mKTtuPWxbMV07cj1yfHxsWzNdO2Y9Yi5oYXNPd25Qcm9wZXJ0eShuKT9iW25dOkRjKGcuJHNjb3BlLG4sITApfHwoYT9EYyhkLG4sITApOnQpO1FhKGYsbiwhMCl9aWYoaClyZXR1cm4gaD0oRyhmKT9mW2YubGVuZ3RoLTFdOmYpLnByb3RvdHlwZSxrPU9iamVjdC5jcmVhdGUoaHx8bnVsbCksciYmZShnLHIsayxufHxmLm5hbWUpLFAoZnVuY3Rpb24oKXt2YXIgYT1jLmludm9rZShmLGssZyxuKTthIT09ayYmKEgoYSl8fHooYSkpJiYoaz1hLHImJmUoZyxyLGssbnx8Zi5uYW1lKSk7cmV0dXJuIGt9LHtpbnN0YW5jZTprLGlkZW50aWZpZXI6cn0pO2s9Yy5pbnN0YW50aWF0ZShmLGcsbik7ciYmZShnLHIsayxufHxmLm5hbWUpO3JldHVybiBrfX1dfWZ1bmN0aW9uIFllKCl7dGhpcy4kZ2V0PVtcXFwiJHdpbmRvd1xcXCIsZnVuY3Rpb24oYil7cmV0dXJuIHkoYi5kb2N1bWVudCl9XX1mdW5jdGlvbiBaZSgpe3RoaXMuJGdldD1bXFxcIiRsb2dcXFwiLGZ1bmN0aW9uKGIpe3JldHVybiBmdW5jdGlvbihhLGMpe2IuZXJyb3IuYXBwbHkoYixcXG5hcmd1bWVudHMpfX1dfWZ1bmN0aW9uIFpiKGIpe3JldHVybiBIKGIpP2FhKGIpP2IudG9JU09TdHJpbmcoKTpkYihiKTpifWZ1bmN0aW9uIGNmKCl7dGhpcy4kZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGIpe2lmKCFiKXJldHVyblxcXCJcXFwiO3ZhciBhPVtdO29jKGIsZnVuY3Rpb24oYixkKXtudWxsPT09Ynx8QShiKXx8KEcoYik/bShiLGZ1bmN0aW9uKGIsYyl7YS5wdXNoKG1hKGQpK1xcXCI9XFxcIittYShaYihiKSkpfSk6YS5wdXNoKG1hKGQpK1xcXCI9XFxcIittYShaYihiKSkpKX0pO3JldHVybiBhLmpvaW4oXFxcIiZcXFwiKX19fWZ1bmN0aW9uIGRmKCl7dGhpcy4kZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGEoYixlLGYpe251bGw9PT1ifHxBKGIpfHwoRyhiKT9tKGIsZnVuY3Rpb24oYil7YShiLGUrXFxcIltdXFxcIil9KTpIKGIpJiYhYWEoYik/b2MoYixmdW5jdGlvbihiLGMpe2EoYixlKyhmP1xcXCJcXFwiOlxcXCJbXFxcIikrYysoZj9cXFwiXFxcIjpcXFwiXVxcXCIpKX0pOmMucHVzaChtYShlKStcXFwiPVxcXCIrbWEoWmIoYikpKSl9XFxuaWYoIWIpcmV0dXJuXFxcIlxcXCI7dmFyIGM9W107YShiLFxcXCJcXFwiLCEwKTtyZXR1cm4gYy5qb2luKFxcXCImXFxcIil9fX1mdW5jdGlvbiAkYihiLGEpe2lmKEwoYikpe3ZhciBjPWIucmVwbGFjZShQZixcXFwiXFxcIikudHJpbSgpO2lmKGMpe3ZhciBkPWEoXFxcIkNvbnRlbnQtVHlwZVxcXCIpOyhkPWQmJjA9PT1kLmluZGV4T2YoY2QpKXx8KGQ9KGQ9Yy5tYXRjaChRZikpJiZSZltkWzBdXS50ZXN0KGMpKTtkJiYoYj13YyhjKSl9fXJldHVybiBifWZ1bmN0aW9uIGRkKGIpe3ZhciBhPWdhKCksYztMKGIpP20oYi5zcGxpdChcXFwiXFxcXG5cXFwiKSxmdW5jdGlvbihiKXtjPWIuaW5kZXhPZihcXFwiOlxcXCIpO3ZhciBlPU0oUihiLnN1YnN0cigwLGMpKSk7Yj1SKGIuc3Vic3RyKGMrMSkpO2UmJihhW2VdPWFbZV0/YVtlXStcXFwiLCBcXFwiK2I6Yil9KTpIKGIpJiZtKGIsZnVuY3Rpb24oYixjKXt2YXIgZj1NKGMpLGc9UihiKTtmJiYoYVtmXT1hW2ZdP2FbZl0rXFxcIiwgXFxcIitnOmcpfSk7cmV0dXJuIGF9ZnVuY3Rpb24gZWQoYil7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKGMpe2F8fFxcbihhPWRkKGIpKTtyZXR1cm4gYz8oYz1hW00oYyldLHZvaWQgMD09PWMmJihjPW51bGwpLGMpOmF9fWZ1bmN0aW9uIGZkKGIsYSxjLGQpe2lmKHooZCkpcmV0dXJuIGQoYixhLGMpO20oZCxmdW5jdGlvbihkKXtiPWQoYixhLGMpfSk7cmV0dXJuIGJ9ZnVuY3Rpb24gYmYoKXt2YXIgYj10aGlzLmRlZmF1bHRzPXt0cmFuc2Zvcm1SZXNwb25zZTpbJGJdLHRyYW5zZm9ybVJlcXVlc3Q6W2Z1bmN0aW9uKGEpe3JldHVybiBIKGEpJiZcXFwiW29iamVjdCBGaWxlXVxcXCIhPT1zYS5jYWxsKGEpJiZcXFwiW29iamVjdCBCbG9iXVxcXCIhPT1zYS5jYWxsKGEpJiZcXFwiW29iamVjdCBGb3JtRGF0YV1cXFwiIT09c2EuY2FsbChhKT9kYihhKTphfV0saGVhZGVyczp7Y29tbW9uOntBY2NlcHQ6XFxcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKlxcXCJ9LHBvc3Q6aWEoYWMpLHB1dDppYShhYykscGF0Y2g6aWEoYWMpfSx4c3JmQ29va2llTmFtZTpcXFwiWFNSRi1UT0tFTlxcXCIseHNyZkhlYWRlck5hbWU6XFxcIlgtWFNSRi1UT0tFTlxcXCIscGFyYW1TZXJpYWxpemVyOlxcXCIkaHR0cFBhcmFtU2VyaWFsaXplclxcXCJ9LFxcbmE9ITE7dGhpcy51c2VBcHBseUFzeW5jPWZ1bmN0aW9uKGIpe3JldHVybiB3KGIpPyhhPSEhYix0aGlzKTphfTt2YXIgYz10aGlzLmludGVyY2VwdG9ycz1bXTt0aGlzLiRnZXQ9W1xcXCIkaHR0cEJhY2tlbmRcXFwiLFxcXCIkJGNvb2tpZVJlYWRlclxcXCIsXFxcIiRjYWNoZUZhY3RvcnlcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixcXFwiJHFcXFwiLFxcXCIkaW5qZWN0b3JcXFwiLGZ1bmN0aW9uKGQsZSxmLGcsaCxsKXtmdW5jdGlvbiBrKGEpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9UCh7fSxhKTtiLmRhdGE9YS5kYXRhP2ZkKGEuZGF0YSxhLmhlYWRlcnMsYS5zdGF0dXMsZS50cmFuc2Zvcm1SZXNwb25zZSk6YS5kYXRhO2E9YS5zdGF0dXM7cmV0dXJuIDIwMDw9YSYmMzAwPmE/YjpoLnJlamVjdChiKX1mdW5jdGlvbiBkKGEsYil7dmFyIGMsZT17fTttKGEsZnVuY3Rpb24oYSxkKXt6KGEpPyhjPWEoYiksbnVsbCE9YyYmKGVbZF09YykpOmVbZF09YX0pO3JldHVybiBlfWlmKCFjYS5pc09iamVjdChhKSl0aHJvdyBKKFxcXCIkaHR0cFxcXCIpKFxcXCJiYWRyZXFcXFwiLFxcbmEpO3ZhciBlPVAoe21ldGhvZDpcXFwiZ2V0XFxcIix0cmFuc2Zvcm1SZXF1ZXN0OmIudHJhbnNmb3JtUmVxdWVzdCx0cmFuc2Zvcm1SZXNwb25zZTpiLnRyYW5zZm9ybVJlc3BvbnNlLHBhcmFtU2VyaWFsaXplcjpiLnBhcmFtU2VyaWFsaXplcn0sYSk7ZS5oZWFkZXJzPWZ1bmN0aW9uKGEpe3ZhciBjPWIuaGVhZGVycyxlPVAoe30sYS5oZWFkZXJzKSxmLGcsaCxjPVAoe30sYy5jb21tb24sY1tNKGEubWV0aG9kKV0pO2E6Zm9yKGYgaW4gYyl7Zz1NKGYpO2ZvcihoIGluIGUpaWYoTShoKT09PWcpY29udGludWUgYTtlW2ZdPWNbZl19cmV0dXJuIGQoZSxpYShhKSl9KGEpO2UubWV0aG9kPXJiKGUubWV0aG9kKTtlLnBhcmFtU2VyaWFsaXplcj1MKGUucGFyYW1TZXJpYWxpemVyKT9sLmdldChlLnBhcmFtU2VyaWFsaXplcik6ZS5wYXJhbVNlcmlhbGl6ZXI7dmFyIGY9W2Z1bmN0aW9uKGEpe3ZhciBkPWEuaGVhZGVycyxlPWZkKGEuZGF0YSxlZChkKSx0LGEudHJhbnNmb3JtUmVxdWVzdCk7QShlKSYmXFxubShkLGZ1bmN0aW9uKGEsYil7XFxcImNvbnRlbnQtdHlwZVxcXCI9PT1NKGIpJiZkZWxldGUgZFtiXX0pO0EoYS53aXRoQ3JlZGVudGlhbHMpJiYhQShiLndpdGhDcmVkZW50aWFscykmJihhLndpdGhDcmVkZW50aWFscz1iLndpdGhDcmVkZW50aWFscyk7cmV0dXJuIG4oYSxlKS50aGVuKGMsYyl9LHRdLGc9aC53aGVuKGUpO2ZvcihtKHgsZnVuY3Rpb24oYSl7KGEucmVxdWVzdHx8YS5yZXF1ZXN0RXJyb3IpJiZmLnVuc2hpZnQoYS5yZXF1ZXN0LGEucmVxdWVzdEVycm9yKTsoYS5yZXNwb25zZXx8YS5yZXNwb25zZUVycm9yKSYmZi5wdXNoKGEucmVzcG9uc2UsYS5yZXNwb25zZUVycm9yKX0pO2YubGVuZ3RoOyl7YT1mLnNoaWZ0KCk7dmFyIGs9Zi5zaGlmdCgpLGc9Zy50aGVuKGEsayl9Zy5zdWNjZXNzPWZ1bmN0aW9uKGEpe1FhKGEsXFxcImZuXFxcIik7Zy50aGVuKGZ1bmN0aW9uKGIpe2EoYi5kYXRhLGIuc3RhdHVzLGIuaGVhZGVycyxlKX0pO3JldHVybiBnfTtnLmVycm9yPWZ1bmN0aW9uKGEpe1FhKGEsXFxuXFxcImZuXFxcIik7Zy50aGVuKG51bGwsZnVuY3Rpb24oYil7YShiLmRhdGEsYi5zdGF0dXMsYi5oZWFkZXJzLGUpfSk7cmV0dXJuIGd9O3JldHVybiBnfWZ1bmN0aW9uIG4oYyxmKXtmdW5jdGlvbiBsKGIsYyxkLGUpe2Z1bmN0aW9uIGYoKXtuKGMsYixkLGUpfU4mJigyMDA8PWImJjMwMD5iP04ucHV0KFMsW2IsYyxkZChkKSxlXSk6Ti5yZW1vdmUoUykpO2E/Zy4kYXBwbHlBc3luYyhmKTooZigpLGcuJCRwaGFzZXx8Zy4kYXBwbHkoKSl9ZnVuY3Rpb24gbihhLGIsZCxlKXtiPU1hdGgubWF4KGIsMCk7KDIwMDw9YiYmMzAwPmI/SS5yZXNvbHZlOkkucmVqZWN0KSh7ZGF0YTphLHN0YXR1czpiLGhlYWRlcnM6ZWQoZCksY29uZmlnOmMsc3RhdHVzVGV4dDplfSl9ZnVuY3Rpb24geChhKXtuKGEuZGF0YSxhLnN0YXR1cyxpYShhLmhlYWRlcnMoKSksYS5zdGF0dXNUZXh0KX1mdW5jdGlvbiBtKCl7dmFyIGE9ay5wZW5kaW5nUmVxdWVzdHMuaW5kZXhPZihjKTstMSE9PWEmJmsucGVuZGluZ1JlcXVlc3RzLnNwbGljZShhLFxcbjEpfXZhciBJPWguZGVmZXIoKSxCPUkucHJvbWlzZSxOLEQscT1jLmhlYWRlcnMsUz1yKGMudXJsLGMucGFyYW1TZXJpYWxpemVyKGMucGFyYW1zKSk7ay5wZW5kaW5nUmVxdWVzdHMucHVzaChjKTtCLnRoZW4obSxtKTshYy5jYWNoZSYmIWIuY2FjaGV8fCExPT09Yy5jYWNoZXx8XFxcIkdFVFxcXCIhPT1jLm1ldGhvZCYmXFxcIkpTT05QXFxcIiE9PWMubWV0aG9kfHwoTj1IKGMuY2FjaGUpP2MuY2FjaGU6SChiLmNhY2hlKT9iLmNhY2hlOnMpO04mJihEPU4uZ2V0KFMpLHcoRCk/RCYmeihELnRoZW4pP0QudGhlbih4LHgpOkcoRCk/bihEWzFdLERbMF0saWEoRFsyXSksRFszXSk6bihELDIwMCx7fSxcXFwiT0tcXFwiKTpOLnB1dChTLEIpKTtBKEQpJiYoKEQ9Z2QoYy51cmwpP2UoKVtjLnhzcmZDb29raWVOYW1lfHxiLnhzcmZDb29raWVOYW1lXTp0KSYmKHFbYy54c3JmSGVhZGVyTmFtZXx8Yi54c3JmSGVhZGVyTmFtZV09RCksZChjLm1ldGhvZCxTLGYsbCxxLGMudGltZW91dCxjLndpdGhDcmVkZW50aWFscyxjLnJlc3BvbnNlVHlwZSkpO1xcbnJldHVybiBCfWZ1bmN0aW9uIHIoYSxiKXswPGIubGVuZ3RoJiYoYSs9KC0xPT1hLmluZGV4T2YoXFxcIj9cXFwiKT9cXFwiP1xcXCI6XFxcIiZcXFwiKStiKTtyZXR1cm4gYX12YXIgcz1mKFxcXCIkaHR0cFxcXCIpO2IucGFyYW1TZXJpYWxpemVyPUwoYi5wYXJhbVNlcmlhbGl6ZXIpP2wuZ2V0KGIucGFyYW1TZXJpYWxpemVyKTpiLnBhcmFtU2VyaWFsaXplcjt2YXIgeD1bXTttKGMsZnVuY3Rpb24oYSl7eC51bnNoaWZ0KEwoYSk/bC5nZXQoYSk6bC5pbnZva2UoYSkpfSk7ay5wZW5kaW5nUmVxdWVzdHM9W107KGZ1bmN0aW9uKGEpe20oYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2tbYV09ZnVuY3Rpb24oYixjKXtyZXR1cm4gayhQKHt9LGN8fHt9LHttZXRob2Q6YSx1cmw6Yn0pKX19KX0pKFxcXCJnZXRcXFwiLFxcXCJkZWxldGVcXFwiLFxcXCJoZWFkXFxcIixcXFwianNvbnBcXFwiKTsoZnVuY3Rpb24oYSl7bShhcmd1bWVudHMsZnVuY3Rpb24oYSl7a1thXT1mdW5jdGlvbihiLGMsZCl7cmV0dXJuIGsoUCh7fSxkfHx7fSx7bWV0aG9kOmEsdXJsOmIsZGF0YTpjfSkpfX0pfSkoXFxcInBvc3RcXFwiLFxcblxcXCJwdXRcXFwiLFxcXCJwYXRjaFxcXCIpO2suZGVmYXVsdHM9YjtyZXR1cm4ga31dfWZ1bmN0aW9uIFNmKCl7cmV0dXJuIG5ldyBPLlhNTEh0dHBSZXF1ZXN0fWZ1bmN0aW9uIGVmKCl7dGhpcy4kZ2V0PVtcXFwiJGJyb3dzZXJcXFwiLFxcXCIkd2luZG93XFxcIixcXFwiJGRvY3VtZW50XFxcIixmdW5jdGlvbihiLGEsYyl7cmV0dXJuIFRmKGIsU2YsYi5kZWZlcixhLmFuZ3VsYXIuY2FsbGJhY2tzLGNbMF0pfV19ZnVuY3Rpb24gVGYoYixhLGMsZCxlKXtmdW5jdGlvbiBmKGEsYixjKXt2YXIgZj1lLmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLG49bnVsbDtmLnR5cGU9XFxcInRleHQvamF2YXNjcmlwdFxcXCI7Zi5zcmM9YTtmLmFzeW5jPSEwO249ZnVuY3Rpb24oYSl7Zi5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIixuLCExKTtmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImVycm9yXFxcIixuLCExKTtlLmJvZHkucmVtb3ZlQ2hpbGQoZik7Zj1udWxsO3ZhciBnPS0xLHg9XFxcInVua25vd25cXFwiO2EmJihcXFwibG9hZFxcXCIhPT1hLnR5cGV8fGRbYl0uY2FsbGVkfHwoYT1cXG57dHlwZTpcXFwiZXJyb3JcXFwifSkseD1hLnR5cGUsZz1cXFwiZXJyb3JcXFwiPT09YS50eXBlPzQwNDoyMDApO2MmJmMoZyx4KX07Zi5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIixuLCExKTtmLmFkZEV2ZW50TGlzdGVuZXIoXFxcImVycm9yXFxcIixuLCExKTtlLmJvZHkuYXBwZW5kQ2hpbGQoZik7cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKGUsaCxsLGssbixyLHMseCl7ZnVuY3Rpb24gQygpe3AmJnAoKTtLJiZLLmFib3J0KCl9ZnVuY3Rpb24gRihhLGQsZSxmLGcpe0khPT10JiZjLmNhbmNlbChJKTtwPUs9bnVsbDthKGQsZSxmLGcpO2IuJCRjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdCh2KX1iLiQkaW5jT3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQoKTtoPWh8fGIudXJsKCk7aWYoXFxcImpzb25wXFxcIj09TShlKSl7dmFyIHU9XFxcIl9cXFwiKyhkLmNvdW50ZXIrKykudG9TdHJpbmcoMzYpO2RbdV09ZnVuY3Rpb24oYSl7ZFt1XS5kYXRhPWE7ZFt1XS5jYWxsZWQ9ITB9O3ZhciBwPWYoaC5yZXBsYWNlKFxcXCJKU09OX0NBTExCQUNLXFxcIixcXG5cXFwiYW5ndWxhci5jYWxsYmFja3MuXFxcIit1KSx1LGZ1bmN0aW9uKGEsYil7RihrLGEsZFt1XS5kYXRhLFxcXCJcXFwiLGIpO2RbdV09dn0pfWVsc2V7dmFyIEs9YSgpO0sub3BlbihlLGgsITApO20obixmdW5jdGlvbihhLGIpe3coYSkmJksuc2V0UmVxdWVzdEhlYWRlcihiLGEpfSk7Sy5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYT1LLnN0YXR1c1RleHR8fFxcXCJcXFwiLGI9XFxcInJlc3BvbnNlXFxcImluIEs/Sy5yZXNwb25zZTpLLnJlc3BvbnNlVGV4dCxjPTEyMjM9PT1LLnN0YXR1cz8yMDQ6Sy5zdGF0dXM7MD09PWMmJihjPWI/MjAwOlxcXCJmaWxlXFxcIj09QmEoaCkucHJvdG9jb2w/NDA0OjApO0YoayxjLGIsSy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSxhKX07ZT1mdW5jdGlvbigpe0YoaywtMSxudWxsLG51bGwsXFxcIlxcXCIpfTtLLm9uZXJyb3I9ZTtLLm9uYWJvcnQ9ZTtzJiYoSy53aXRoQ3JlZGVudGlhbHM9ITApO2lmKHgpdHJ5e0sucmVzcG9uc2VUeXBlPXh9Y2F0Y2gocSl7aWYoXFxcImpzb25cXFwiIT09eCl0aHJvdyBxO31LLnNlbmQobCl9aWYoMDxcXG5yKXZhciBJPWMoQyxyKTtlbHNlIHImJnooci50aGVuKSYmci50aGVuKEMpfX1mdW5jdGlvbiAkZSgpe3ZhciBiPVxcXCJ7e1xcXCIsYT1cXFwifX1cXFwiO3RoaXMuc3RhcnRTeW1ib2w9ZnVuY3Rpb24oYSl7cmV0dXJuIGE/KGI9YSx0aGlzKTpifTt0aGlzLmVuZFN5bWJvbD1mdW5jdGlvbihiKXtyZXR1cm4gYj8oYT1iLHRoaXMpOmF9O3RoaXMuJGdldD1bXFxcIiRwYXJzZVxcXCIsXFxcIiRleGNlcHRpb25IYW5kbGVyXFxcIixcXFwiJHNjZVxcXCIsZnVuY3Rpb24oYyxkLGUpe2Z1bmN0aW9uIGYoYSl7cmV0dXJuXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCIrYX1mdW5jdGlvbiBnKGMpe3JldHVybiBjLnJlcGxhY2UobixiKS5yZXBsYWNlKHIsYSl9ZnVuY3Rpb24gaChmLGgsbixyKXtmdW5jdGlvbiB1KGEpe3RyeXt2YXIgYj1hO2E9bj9lLmdldFRydXN0ZWQobixiKTplLnZhbHVlT2YoYik7dmFyIGM7aWYociYmIXcoYSkpYz1hO2Vsc2UgaWYobnVsbD09YSljPVxcXCJcXFwiO2Vsc2V7c3dpdGNoKHR5cGVvZiBhKXtjYXNlIFxcXCJzdHJpbmdcXFwiOmJyZWFrO2Nhc2UgXFxcIm51bWJlclxcXCI6YT1cXG5cXFwiXFxcIithO2JyZWFrO2RlZmF1bHQ6YT1kYihhKX1jPWF9cmV0dXJuIGN9Y2F0Y2goZyl7ZChLYS5pbnRlcnIoZixnKSl9fXI9ISFyO2Zvcih2YXIgcCxtLHE9MCxJPVtdLEI9W10sTj1mLmxlbmd0aCxEPVtdLHQ9W107cTxOOylpZigtMSE9KHA9Zi5pbmRleE9mKGIscSkpJiYtMSE9KG09Zi5pbmRleE9mKGEscCtsKSkpcSE9PXAmJkQucHVzaChnKGYuc3Vic3RyaW5nKHEscCkpKSxxPWYuc3Vic3RyaW5nKHArbCxtKSxJLnB1c2gocSksQi5wdXNoKGMocSx1KSkscT1tK2ssdC5wdXNoKEQubGVuZ3RoKSxELnB1c2goXFxcIlxcXCIpO2Vsc2V7cSE9PU4mJkQucHVzaChnKGYuc3Vic3RyaW5nKHEpKSk7YnJlYWt9biYmMTxELmxlbmd0aCYmS2EudGhyb3dOb2NvbmNhdChmKTtpZighaHx8SS5sZW5ndGgpe3ZhciBTPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9SS5sZW5ndGg7YjxjO2IrKyl7aWYociYmQShhW2JdKSlyZXR1cm47RFt0W2JdXT1hW2JdfXJldHVybiBELmpvaW4oXFxcIlxcXCIpfTtyZXR1cm4gUChmdW5jdGlvbihhKXt2YXIgYj1cXG4wLGM9SS5sZW5ndGgsZT1BcnJheShjKTt0cnl7Zm9yKDtiPGM7YisrKWVbYl09QltiXShhKTtyZXR1cm4gUyhlKX1jYXRjaChnKXtkKEthLmludGVycihmLGcpKX19LHtleHA6ZixleHByZXNzaW9uczpJLCQkd2F0Y2hEZWxlZ2F0ZTpmdW5jdGlvbihhLGIpe3ZhciBjO3JldHVybiBhLiR3YXRjaEdyb3VwKEIsZnVuY3Rpb24oZCxlKXt2YXIgZj1TKGQpO3ooYikmJmIuY2FsbCh0aGlzLGYsZCE9PWU/YzpmLGEpO2M9Zn0pfX0pfX12YXIgbD1iLmxlbmd0aCxrPWEubGVuZ3RoLG49bmV3IFJlZ0V4cChiLnJlcGxhY2UoLy4vZyxmKSxcXFwiZ1xcXCIpLHI9bmV3IFJlZ0V4cChhLnJlcGxhY2UoLy4vZyxmKSxcXFwiZ1xcXCIpO2guc3RhcnRTeW1ib2w9ZnVuY3Rpb24oKXtyZXR1cm4gYn07aC5lbmRTeW1ib2w9ZnVuY3Rpb24oKXtyZXR1cm4gYX07cmV0dXJuIGh9XX1mdW5jdGlvbiBhZigpe3RoaXMuJGdldD1bXFxcIiRyb290U2NvcGVcXFwiLFxcXCIkd2luZG93XFxcIixcXFwiJHFcXFwiLFxcXCIkJHFcXFwiLGZ1bmN0aW9uKGIsYSxjLGQpe2Z1bmN0aW9uIGUoZSxcXG5oLGwsayl7dmFyIG49NDxhcmd1bWVudHMubGVuZ3RoLHI9bj96YS5jYWxsKGFyZ3VtZW50cyw0KTpbXSxzPWEuc2V0SW50ZXJ2YWwseD1hLmNsZWFySW50ZXJ2YWwsQz0wLEY9dyhrKSYmIWssdT0oRj9kOmMpLmRlZmVyKCkscD11LnByb21pc2U7bD13KGwpP2w6MDtwLnRoZW4obnVsbCxudWxsLG4/ZnVuY3Rpb24oKXtlLmFwcGx5KG51bGwscil9OmUpO3AuJCRpbnRlcnZhbElkPXMoZnVuY3Rpb24oKXt1Lm5vdGlmeShDKyspOzA8bCYmQz49bCYmKHUucmVzb2x2ZShDKSx4KHAuJCRpbnRlcnZhbElkKSxkZWxldGUgZltwLiQkaW50ZXJ2YWxJZF0pO0Z8fGIuJGFwcGx5KCl9LGgpO2ZbcC4kJGludGVydmFsSWRdPXU7cmV0dXJuIHB9dmFyIGY9e307ZS5jYW5jZWw9ZnVuY3Rpb24oYil7cmV0dXJuIGImJmIuJCRpbnRlcnZhbElkIGluIGY/KGZbYi4kJGludGVydmFsSWRdLnJlamVjdChcXFwiY2FuY2VsZWRcXFwiKSxhLmNsZWFySW50ZXJ2YWwoYi4kJGludGVydmFsSWQpLGRlbGV0ZSBmW2IuJCRpbnRlcnZhbElkXSxcXG4hMCk6ITF9O3JldHVybiBlfV19ZnVuY3Rpb24gZ2UoKXt0aGlzLiRnZXQ9ZnVuY3Rpb24oKXtyZXR1cm57aWQ6XFxcImVuLXVzXFxcIixOVU1CRVJfRk9STUFUUzp7REVDSU1BTF9TRVA6XFxcIi5cXFwiLEdST1VQX1NFUDpcXFwiLFxcXCIsUEFUVEVSTlM6W3ttaW5JbnQ6MSxtaW5GcmFjOjAsbWF4RnJhYzozLHBvc1ByZTpcXFwiXFxcIixwb3NTdWY6XFxcIlxcXCIsbmVnUHJlOlxcXCItXFxcIixuZWdTdWY6XFxcIlxcXCIsZ1NpemU6MyxsZ1NpemU6M30se21pbkludDoxLG1pbkZyYWM6MixtYXhGcmFjOjIscG9zUHJlOlxcXCJcXFxcdTAwYTRcXFwiLHBvc1N1ZjpcXFwiXFxcIixuZWdQcmU6XFxcIihcXFxcdTAwYTRcXFwiLG5lZ1N1ZjpcXFwiKVxcXCIsZ1NpemU6MyxsZ1NpemU6M31dLENVUlJFTkNZX1NZTTpcXFwiJFxcXCJ9LERBVEVUSU1FX0ZPUk1BVFM6e01PTlRIOlxcXCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXFxcIi5zcGxpdChcXFwiIFxcXCIpLFNIT1JUTU9OVEg6XFxcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXFxcIi5zcGxpdChcXFwiIFxcXCIpLFxcbkRBWTpcXFwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcXFwiLnNwbGl0KFxcXCIgXFxcIiksU0hPUlREQVk6XFxcIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFxcXCIuc3BsaXQoXFxcIiBcXFwiKSxBTVBNUzpbXFxcIkFNXFxcIixcXFwiUE1cXFwiXSxtZWRpdW06XFxcIk1NTSBkLCB5IGg6bW06c3MgYVxcXCIsXFxcInNob3J0XFxcIjpcXFwiTS9kL3l5IGg6bW0gYVxcXCIsZnVsbERhdGU6XFxcIkVFRUUsIE1NTU0gZCwgeVxcXCIsbG9uZ0RhdGU6XFxcIk1NTU0gZCwgeVxcXCIsbWVkaXVtRGF0ZTpcXFwiTU1NIGQsIHlcXFwiLHNob3J0RGF0ZTpcXFwiTS9kL3l5XFxcIixtZWRpdW1UaW1lOlxcXCJoOm1tOnNzIGFcXFwiLHNob3J0VGltZTpcXFwiaDptbSBhXFxcIixFUkFOQU1FUzpbXFxcIkJlZm9yZSBDaHJpc3RcXFwiLFxcXCJBbm5vIERvbWluaVxcXCJdLEVSQVM6W1xcXCJCQ1xcXCIsXFxcIkFEXFxcIl19LHBsdXJhbENhdDpmdW5jdGlvbihiKXtyZXR1cm4gMT09PWI/XFxcIm9uZVxcXCI6XFxcIm90aGVyXFxcIn19fX1mdW5jdGlvbiBiYyhiKXtiPWIuc3BsaXQoXFxcIi9cXFwiKTtmb3IodmFyIGE9Yi5sZW5ndGg7YS0tOyliW2FdPW9iKGJbYV0pO1xcbnJldHVybiBiLmpvaW4oXFxcIi9cXFwiKX1mdW5jdGlvbiBoZChiLGEpe3ZhciBjPUJhKGIpO2EuJCRwcm90b2NvbD1jLnByb3RvY29sO2EuJCRob3N0PWMuaG9zdG5hbWU7YS4kJHBvcnQ9VyhjLnBvcnQpfHxVZltjLnByb3RvY29sXXx8bnVsbH1mdW5jdGlvbiBpZChiLGEpe3ZhciBjPVxcXCIvXFxcIiE9PWIuY2hhckF0KDApO2MmJihiPVxcXCIvXFxcIitiKTt2YXIgZD1CYShiKTthLiQkcGF0aD1kZWNvZGVVUklDb21wb25lbnQoYyYmXFxcIi9cXFwiPT09ZC5wYXRobmFtZS5jaGFyQXQoMCk/ZC5wYXRobmFtZS5zdWJzdHJpbmcoMSk6ZC5wYXRobmFtZSk7YS4kJHNlYXJjaD16YyhkLnNlYXJjaCk7YS4kJGhhc2g9ZGVjb2RlVVJJQ29tcG9uZW50KGQuaGFzaCk7YS4kJHBhdGgmJlxcXCIvXFxcIiE9YS4kJHBhdGguY2hhckF0KDApJiYoYS4kJHBhdGg9XFxcIi9cXFwiK2EuJCRwYXRoKX1mdW5jdGlvbiB5YShiLGEpe2lmKDA9PT1hLmluZGV4T2YoYikpcmV0dXJuIGEuc3Vic3RyKGIubGVuZ3RoKX1mdW5jdGlvbiBKYShiKXt2YXIgYT1iLmluZGV4T2YoXFxcIiNcXFwiKTtcXG5yZXR1cm4tMT09YT9iOmIuc3Vic3RyKDAsYSl9ZnVuY3Rpb24gQmIoYil7cmV0dXJuIGIucmVwbGFjZSgvKCMuKyl8IyQvLFxcXCIkMVxcXCIpfWZ1bmN0aW9uIGNjKGIpe3JldHVybiBiLnN1YnN0cigwLEphKGIpLmxhc3RJbmRleE9mKFxcXCIvXFxcIikrMSl9ZnVuY3Rpb24gZGMoYixhKXt0aGlzLiQkaHRtbDU9ITA7YT1hfHxcXFwiXFxcIjt2YXIgYz1jYyhiKTtoZChiLHRoaXMpO3RoaXMuJCRwYXJzZT1mdW5jdGlvbihhKXt2YXIgYj15YShjLGEpO2lmKCFMKGIpKXRocm93IENiKFxcXCJpcHRocHJmeFxcXCIsYSxjKTtpZChiLHRoaXMpO3RoaXMuJCRwYXRofHwodGhpcy4kJHBhdGg9XFxcIi9cXFwiKTt0aGlzLiQkY29tcG9zZSgpfTt0aGlzLiQkY29tcG9zZT1mdW5jdGlvbigpe3ZhciBhPVFiKHRoaXMuJCRzZWFyY2gpLGI9dGhpcy4kJGhhc2g/XFxcIiNcXFwiK29iKHRoaXMuJCRoYXNoKTpcXFwiXFxcIjt0aGlzLiQkdXJsPWJjKHRoaXMuJCRwYXRoKSsoYT9cXFwiP1xcXCIrYTpcXFwiXFxcIikrYjt0aGlzLiQkYWJzVXJsPWMrdGhpcy4kJHVybC5zdWJzdHIoMSl9O3RoaXMuJCRwYXJzZUxpbmtVcmw9XFxuZnVuY3Rpb24oZCxlKXtpZihlJiZcXFwiI1xcXCI9PT1lWzBdKXJldHVybiB0aGlzLmhhc2goZS5zbGljZSgxKSksITA7dmFyIGYsZzsoZj15YShiLGQpKSE9PXQ/KGc9ZixnPShmPXlhKGEsZikpIT09dD9jKyh5YShcXFwiL1xcXCIsZil8fGYpOmIrZyk6KGY9eWEoYyxkKSkhPT10P2c9YytmOmM9PWQrXFxcIi9cXFwiJiYoZz1jKTtnJiZ0aGlzLiQkcGFyc2UoZyk7cmV0dXJuISFnfX1mdW5jdGlvbiBlYyhiLGEpe3ZhciBjPWNjKGIpO2hkKGIsdGhpcyk7dGhpcy4kJHBhcnNlPWZ1bmN0aW9uKGQpe3ZhciBlPXlhKGIsZCl8fHlhKGMsZCksZjtBKGUpfHxcXFwiI1xcXCIhPT1lLmNoYXJBdCgwKT90aGlzLiQkaHRtbDU/Zj1lOihmPVxcXCJcXFwiLEEoZSkmJihiPWQsdGhpcy5yZXBsYWNlKCkpKTooZj15YShhLGUpLEEoZikmJihmPWUpKTtpZChmLHRoaXMpO2Q9dGhpcy4kJHBhdGg7dmFyIGU9YixnPS9eXFxcXC9bQS1aXTooXFxcXC8uKikvOzA9PT1mLmluZGV4T2YoZSkmJihmPWYucmVwbGFjZShlLFxcXCJcXFwiKSk7Zy5leGVjKGYpfHwoZD0oZj1nLmV4ZWMoZCkpP1xcbmZbMV06ZCk7dGhpcy4kJHBhdGg9ZDt0aGlzLiQkY29tcG9zZSgpfTt0aGlzLiQkY29tcG9zZT1mdW5jdGlvbigpe3ZhciBjPVFiKHRoaXMuJCRzZWFyY2gpLGU9dGhpcy4kJGhhc2g/XFxcIiNcXFwiK29iKHRoaXMuJCRoYXNoKTpcXFwiXFxcIjt0aGlzLiQkdXJsPWJjKHRoaXMuJCRwYXRoKSsoYz9cXFwiP1xcXCIrYzpcXFwiXFxcIikrZTt0aGlzLiQkYWJzVXJsPWIrKHRoaXMuJCR1cmw/YSt0aGlzLiQkdXJsOlxcXCJcXFwiKX07dGhpcy4kJHBhcnNlTGlua1VybD1mdW5jdGlvbihhLGMpe3JldHVybiBKYShiKT09SmEoYSk/KHRoaXMuJCRwYXJzZShhKSwhMCk6ITF9fWZ1bmN0aW9uIGpkKGIsYSl7dGhpcy4kJGh0bWw1PSEwO2VjLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYz1jYyhiKTt0aGlzLiQkcGFyc2VMaW5rVXJsPWZ1bmN0aW9uKGQsZSl7aWYoZSYmXFxcIiNcXFwiPT09ZVswXSlyZXR1cm4gdGhpcy5oYXNoKGUuc2xpY2UoMSkpLCEwO3ZhciBmLGc7Yj09SmEoZCk/Zj1kOihnPXlhKGMsZCkpP2Y9YithK2c6Yz09PWQrXFxcIi9cXFwiJiYoZj1cXG5jKTtmJiZ0aGlzLiQkcGFyc2UoZik7cmV0dXJuISFmfTt0aGlzLiQkY29tcG9zZT1mdW5jdGlvbigpe3ZhciBjPVFiKHRoaXMuJCRzZWFyY2gpLGU9dGhpcy4kJGhhc2g/XFxcIiNcXFwiK29iKHRoaXMuJCRoYXNoKTpcXFwiXFxcIjt0aGlzLiQkdXJsPWJjKHRoaXMuJCRwYXRoKSsoYz9cXFwiP1xcXCIrYzpcXFwiXFxcIikrZTt0aGlzLiQkYWJzVXJsPWIrYSt0aGlzLiQkdXJsfX1mdW5jdGlvbiBEYihiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tiXX19ZnVuY3Rpb24ga2QoYixhKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoQShjKSlyZXR1cm4gdGhpc1tiXTt0aGlzW2JdPWEoYyk7dGhpcy4kJGNvbXBvc2UoKTtyZXR1cm4gdGhpc319ZnVuY3Rpb24gZmYoKXt2YXIgYj1cXFwiXFxcIixhPXtlbmFibGVkOiExLHJlcXVpcmVCYXNlOiEwLHJld3JpdGVMaW5rczohMH07dGhpcy5oYXNoUHJlZml4PWZ1bmN0aW9uKGEpe3JldHVybiB3KGEpPyhiPWEsdGhpcyk6Yn07dGhpcy5odG1sNU1vZGU9ZnVuY3Rpb24oYil7cmV0dXJuIGFiKGIpP1xcbihhLmVuYWJsZWQ9Yix0aGlzKTpIKGIpPyhhYihiLmVuYWJsZWQpJiYoYS5lbmFibGVkPWIuZW5hYmxlZCksYWIoYi5yZXF1aXJlQmFzZSkmJihhLnJlcXVpcmVCYXNlPWIucmVxdWlyZUJhc2UpLGFiKGIucmV3cml0ZUxpbmtzKSYmKGEucmV3cml0ZUxpbmtzPWIucmV3cml0ZUxpbmtzKSx0aGlzKTphfTt0aGlzLiRnZXQ9W1xcXCIkcm9vdFNjb3BlXFxcIixcXFwiJGJyb3dzZXJcXFwiLFxcXCIkc25pZmZlclxcXCIsXFxcIiRyb290RWxlbWVudFxcXCIsXFxcIiR3aW5kb3dcXFwiLGZ1bmN0aW9uKGMsZCxlLGYsZyl7ZnVuY3Rpb24gaChhLGIsYyl7dmFyIGU9ay51cmwoKSxmPWsuJCRzdGF0ZTt0cnl7ZC51cmwoYSxiLGMpLGsuJCRzdGF0ZT1kLnN0YXRlKCl9Y2F0Y2goZyl7dGhyb3cgay51cmwoZSksay4kJHN0YXRlPWYsZzt9fWZ1bmN0aW9uIGwoYSxiKXtjLiRicm9hZGNhc3QoXFxcIiRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3NcXFwiLGsuYWJzVXJsKCksYSxrLiQkc3RhdGUsYil9dmFyIGssbjtuPWQuYmFzZUhyZWYoKTt2YXIgcj1kLnVybCgpLFxcbnM7aWYoYS5lbmFibGVkKXtpZighbiYmYS5yZXF1aXJlQmFzZSl0aHJvdyBDYihcXFwibm9iYXNlXFxcIik7cz1yLnN1YnN0cmluZygwLHIuaW5kZXhPZihcXFwiL1xcXCIsci5pbmRleE9mKFxcXCIvL1xcXCIpKzIpKSsobnx8XFxcIi9cXFwiKTtuPWUuaGlzdG9yeT9kYzpqZH1lbHNlIHM9SmEociksbj1lYztrPW5ldyBuKHMsXFxcIiNcXFwiK2IpO2suJCRwYXJzZUxpbmtVcmwocixyKTtrLiQkc3RhdGU9ZC5zdGF0ZSgpO3ZhciB4PS9eXFxcXHMqKGphdmFzY3JpcHR8bWFpbHRvKTovaTtmLm9uKFxcXCJjbGlja1xcXCIsZnVuY3Rpb24oYil7aWYoYS5yZXdyaXRlTGlua3MmJiFiLmN0cmxLZXkmJiFiLm1ldGFLZXkmJiFiLnNoaWZ0S2V5JiYyIT1iLndoaWNoJiYyIT1iLmJ1dHRvbil7Zm9yKHZhciBlPXkoYi50YXJnZXQpO1xcXCJhXFxcIiE9PXRhKGVbMF0pOylpZihlWzBdPT09ZlswXXx8IShlPWUucGFyZW50KCkpWzBdKXJldHVybjt2YXIgaD1lLnByb3AoXFxcImhyZWZcXFwiKSxsPWUuYXR0cihcXFwiaHJlZlxcXCIpfHxlLmF0dHIoXFxcInhsaW5rOmhyZWZcXFwiKTtIKGgpJiZcXFwiW29iamVjdCBTVkdBbmltYXRlZFN0cmluZ11cXFwiPT09XFxuaC50b1N0cmluZygpJiYoaD1CYShoLmFuaW1WYWwpLmhyZWYpO3gudGVzdChoKXx8IWh8fGUuYXR0cihcXFwidGFyZ2V0XFxcIil8fGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fCFrLiQkcGFyc2VMaW5rVXJsKGgsbCl8fChiLnByZXZlbnREZWZhdWx0KCksay5hYnNVcmwoKSE9ZC51cmwoKSYmKGMuJGFwcGx5KCksZy5hbmd1bGFyW1xcXCJmZi02ODQyMDgtcHJldmVudERlZmF1bHRcXFwiXT0hMCkpfX0pO0JiKGsuYWJzVXJsKCkpIT1CYihyKSYmZC51cmwoay5hYnNVcmwoKSwhMCk7dmFyIEM9ITA7ZC5vblVybENoYW5nZShmdW5jdGlvbihhLGIpe2MuJGV2YWxBc3luYyhmdW5jdGlvbigpe3ZhciBkPWsuYWJzVXJsKCksZT1rLiQkc3RhdGUsZjtrLiQkcGFyc2UoYSk7ay4kJHN0YXRlPWI7Zj1jLiRicm9hZGNhc3QoXFxcIiRsb2NhdGlvbkNoYW5nZVN0YXJ0XFxcIixhLGQsYixlKS5kZWZhdWx0UHJldmVudGVkO2suYWJzVXJsKCk9PT1hJiYoZj8oay4kJHBhcnNlKGQpLGsuJCRzdGF0ZT1lLGgoZCwhMSxlKSk6KEM9XFxuITEsbChkLGUpKSl9KTtjLiQkcGhhc2V8fGMuJGRpZ2VzdCgpfSk7Yy4kd2F0Y2goZnVuY3Rpb24oKXt2YXIgYT1CYihkLnVybCgpKSxiPUJiKGsuYWJzVXJsKCkpLGY9ZC5zdGF0ZSgpLGc9ay4kJHJlcGxhY2Usbj1hIT09Ynx8ay4kJGh0bWw1JiZlLmhpc3RvcnkmJmYhPT1rLiQkc3RhdGU7aWYoQ3x8bilDPSExLGMuJGV2YWxBc3luYyhmdW5jdGlvbigpe3ZhciBiPWsuYWJzVXJsKCksZD1jLiRicm9hZGNhc3QoXFxcIiRsb2NhdGlvbkNoYW5nZVN0YXJ0XFxcIixiLGEsay4kJHN0YXRlLGYpLmRlZmF1bHRQcmV2ZW50ZWQ7ay5hYnNVcmwoKT09PWImJihkPyhrLiQkcGFyc2UoYSksay4kJHN0YXRlPWYpOihuJiZoKGIsZyxmPT09ay4kJHN0YXRlP251bGw6ay4kJHN0YXRlKSxsKGEsZikpKX0pO2suJCRyZXBsYWNlPSExfSk7cmV0dXJuIGt9XX1mdW5jdGlvbiBnZigpe3ZhciBiPSEwLGE9dGhpczt0aGlzLmRlYnVnRW5hYmxlZD1mdW5jdGlvbihhKXtyZXR1cm4gdyhhKT8oYj1hLHRoaXMpOmJ9O1xcbnRoaXMuJGdldD1bXFxcIiR3aW5kb3dcXFwiLGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoYSl7YSBpbnN0YW5jZW9mIEVycm9yJiYoYS5zdGFjaz9hPWEubWVzc2FnZSYmLTE9PT1hLnN0YWNrLmluZGV4T2YoYS5tZXNzYWdlKT9cXFwiRXJyb3I6IFxcXCIrYS5tZXNzYWdlK1xcXCJcXFxcblxcXCIrYS5zdGFjazphLnN0YWNrOmEuc291cmNlVVJMJiYoYT1hLm1lc3NhZ2UrXFxcIlxcXFxuXFxcIithLnNvdXJjZVVSTCtcXFwiOlxcXCIrYS5saW5lKSk7cmV0dXJuIGF9ZnVuY3Rpb24gZShhKXt2YXIgYj1jLmNvbnNvbGV8fHt9LGU9YlthXXx8Yi5sb2d8fHY7YT0hMTt0cnl7YT0hIWUuYXBwbHl9Y2F0Y2gobCl7fXJldHVybiBhP2Z1bmN0aW9uKCl7dmFyIGE9W107bShhcmd1bWVudHMsZnVuY3Rpb24oYil7YS5wdXNoKGQoYikpfSk7cmV0dXJuIGUuYXBwbHkoYixhKX06ZnVuY3Rpb24oYSxiKXtlKGEsbnVsbD09Yj9cXFwiXFxcIjpiKX19cmV0dXJue2xvZzplKFxcXCJsb2dcXFwiKSxpbmZvOmUoXFxcImluZm9cXFwiKSx3YXJuOmUoXFxcIndhcm5cXFwiKSxlcnJvcjplKFxcXCJlcnJvclxcXCIpLGRlYnVnOmZ1bmN0aW9uKCl7dmFyIGM9XFxuZShcXFwiZGVidWdcXFwiKTtyZXR1cm4gZnVuY3Rpb24oKXtiJiZjLmFwcGx5KGEsYXJndW1lbnRzKX19KCl9fV19ZnVuY3Rpb24gQ2EoYixhKXtpZihcXFwiX19kZWZpbmVHZXR0ZXJfX1xcXCI9PT1ifHxcXFwiX19kZWZpbmVTZXR0ZXJfX1xcXCI9PT1ifHxcXFwiX19sb29rdXBHZXR0ZXJfX1xcXCI9PT1ifHxcXFwiX19sb29rdXBTZXR0ZXJfX1xcXCI9PT1ifHxcXFwiX19wcm90b19fXFxcIj09PWIpdGhyb3cgZGEoXFxcImlzZWNmbGRcXFwiLGEpO3JldHVybiBifWZ1bmN0aW9uIG9hKGIsYSl7aWYoYil7aWYoYi5jb25zdHJ1Y3Rvcj09PWIpdGhyb3cgZGEoXFxcImlzZWNmblxcXCIsYSk7aWYoYi53aW5kb3c9PT1iKXRocm93IGRhKFxcXCJpc2Vjd2luZG93XFxcIixhKTtpZihiLmNoaWxkcmVuJiYoYi5ub2RlTmFtZXx8Yi5wcm9wJiZiLmF0dHImJmIuZmluZCkpdGhyb3cgZGEoXFxcImlzZWNkb21cXFwiLGEpO2lmKGI9PT1PYmplY3QpdGhyb3cgZGEoXFxcImlzZWNvYmpcXFwiLGEpO31yZXR1cm4gYn1mdW5jdGlvbiBsZChiLGEpe2lmKGIpe2lmKGIuY29uc3RydWN0b3I9PT1iKXRocm93IGRhKFxcXCJpc2VjZm5cXFwiLFxcbmEpO2lmKGI9PT1WZnx8Yj09PVdmfHxiPT09WGYpdGhyb3cgZGEoXFxcImlzZWNmZlxcXCIsYSk7fX1mdW5jdGlvbiBZZihiLGEpe3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIGI/YjphfWZ1bmN0aW9uIG1kKGIsYSl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PT10eXBlb2YgYj9hOlxcXCJ1bmRlZmluZWRcXFwiPT09dHlwZW9mIGE/YjpiK2F9ZnVuY3Rpb24gVChiLGEpe3ZhciBjLGQ7c3dpdGNoKGIudHlwZSl7Y2FzZSBxLlByb2dyYW06Yz0hMDttKGIuYm9keSxmdW5jdGlvbihiKXtUKGIuZXhwcmVzc2lvbixhKTtjPWMmJmIuZXhwcmVzc2lvbi5jb25zdGFudH0pO2IuY29uc3RhbnQ9YzticmVhaztjYXNlIHEuTGl0ZXJhbDpiLmNvbnN0YW50PSEwO2IudG9XYXRjaD1bXTticmVhaztjYXNlIHEuVW5hcnlFeHByZXNzaW9uOlQoYi5hcmd1bWVudCxhKTtiLmNvbnN0YW50PWIuYXJndW1lbnQuY29uc3RhbnQ7Yi50b1dhdGNoPWIuYXJndW1lbnQudG9XYXRjaDticmVhaztjYXNlIHEuQmluYXJ5RXhwcmVzc2lvbjpUKGIubGVmdCxcXG5hKTtUKGIucmlnaHQsYSk7Yi5jb25zdGFudD1iLmxlZnQuY29uc3RhbnQmJmIucmlnaHQuY29uc3RhbnQ7Yi50b1dhdGNoPWIubGVmdC50b1dhdGNoLmNvbmNhdChiLnJpZ2h0LnRvV2F0Y2gpO2JyZWFrO2Nhc2UgcS5Mb2dpY2FsRXhwcmVzc2lvbjpUKGIubGVmdCxhKTtUKGIucmlnaHQsYSk7Yi5jb25zdGFudD1iLmxlZnQuY29uc3RhbnQmJmIucmlnaHQuY29uc3RhbnQ7Yi50b1dhdGNoPWIuY29uc3RhbnQ/W106W2JdO2JyZWFrO2Nhc2UgcS5Db25kaXRpb25hbEV4cHJlc3Npb246VChiLnRlc3QsYSk7VChiLmFsdGVybmF0ZSxhKTtUKGIuY29uc2VxdWVudCxhKTtiLmNvbnN0YW50PWIudGVzdC5jb25zdGFudCYmYi5hbHRlcm5hdGUuY29uc3RhbnQmJmIuY29uc2VxdWVudC5jb25zdGFudDtiLnRvV2F0Y2g9Yi5jb25zdGFudD9bXTpbYl07YnJlYWs7Y2FzZSBxLklkZW50aWZpZXI6Yi5jb25zdGFudD0hMTtiLnRvV2F0Y2g9W2JdO2JyZWFrO2Nhc2UgcS5NZW1iZXJFeHByZXNzaW9uOlQoYi5vYmplY3QsXFxuYSk7Yi5jb21wdXRlZCYmVChiLnByb3BlcnR5LGEpO2IuY29uc3RhbnQ9Yi5vYmplY3QuY29uc3RhbnQmJighYi5jb21wdXRlZHx8Yi5wcm9wZXJ0eS5jb25zdGFudCk7Yi50b1dhdGNoPVtiXTticmVhaztjYXNlIHEuQ2FsbEV4cHJlc3Npb246Yz1iLmZpbHRlcj8hYShiLmNhbGxlZS5uYW1lKS4kc3RhdGVmdWw6ITE7ZD1bXTttKGIuYXJndW1lbnRzLGZ1bmN0aW9uKGIpe1QoYixhKTtjPWMmJmIuY29uc3RhbnQ7Yi5jb25zdGFudHx8ZC5wdXNoLmFwcGx5KGQsYi50b1dhdGNoKX0pO2IuY29uc3RhbnQ9YztiLnRvV2F0Y2g9Yi5maWx0ZXImJiFhKGIuY2FsbGVlLm5hbWUpLiRzdGF0ZWZ1bD9kOltiXTticmVhaztjYXNlIHEuQXNzaWdubWVudEV4cHJlc3Npb246VChiLmxlZnQsYSk7VChiLnJpZ2h0LGEpO2IuY29uc3RhbnQ9Yi5sZWZ0LmNvbnN0YW50JiZiLnJpZ2h0LmNvbnN0YW50O2IudG9XYXRjaD1bYl07YnJlYWs7Y2FzZSBxLkFycmF5RXhwcmVzc2lvbjpjPSEwO2Q9W107bShiLmVsZW1lbnRzLFxcbmZ1bmN0aW9uKGIpe1QoYixhKTtjPWMmJmIuY29uc3RhbnQ7Yi5jb25zdGFudHx8ZC5wdXNoLmFwcGx5KGQsYi50b1dhdGNoKX0pO2IuY29uc3RhbnQ9YztiLnRvV2F0Y2g9ZDticmVhaztjYXNlIHEuT2JqZWN0RXhwcmVzc2lvbjpjPSEwO2Q9W107bShiLnByb3BlcnRpZXMsZnVuY3Rpb24oYil7VChiLnZhbHVlLGEpO2M9YyYmYi52YWx1ZS5jb25zdGFudDtiLnZhbHVlLmNvbnN0YW50fHxkLnB1c2guYXBwbHkoZCxiLnZhbHVlLnRvV2F0Y2gpfSk7Yi5jb25zdGFudD1jO2IudG9XYXRjaD1kO2JyZWFrO2Nhc2UgcS5UaGlzRXhwcmVzc2lvbjpiLmNvbnN0YW50PSExLGIudG9XYXRjaD1bXX19ZnVuY3Rpb24gbmQoYil7aWYoMT09Yi5sZW5ndGgpe2I9YlswXS5leHByZXNzaW9uO3ZhciBhPWIudG9XYXRjaDtyZXR1cm4gMSE9PWEubGVuZ3RoP2E6YVswXSE9PWI/YTp0fX1mdW5jdGlvbiBvZChiKXtyZXR1cm4gYi50eXBlPT09cS5JZGVudGlmaWVyfHxiLnR5cGU9PT1xLk1lbWJlckV4cHJlc3Npb259XFxuZnVuY3Rpb24gcGQoYil7aWYoMT09PWIuYm9keS5sZW5ndGgmJm9kKGIuYm9keVswXS5leHByZXNzaW9uKSlyZXR1cm57dHlwZTpxLkFzc2lnbm1lbnRFeHByZXNzaW9uLGxlZnQ6Yi5ib2R5WzBdLmV4cHJlc3Npb24scmlnaHQ6e3R5cGU6cS5OR1ZhbHVlUGFyYW1ldGVyfSxvcGVyYXRvcjpcXFwiPVxcXCJ9fWZ1bmN0aW9uIHFkKGIpe3JldHVybiAwPT09Yi5ib2R5Lmxlbmd0aHx8MT09PWIuYm9keS5sZW5ndGgmJihiLmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlPT09cS5MaXRlcmFsfHxiLmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlPT09cS5BcnJheUV4cHJlc3Npb258fGIuYm9keVswXS5leHByZXNzaW9uLnR5cGU9PT1xLk9iamVjdEV4cHJlc3Npb24pfWZ1bmN0aW9uIHJkKGIsYSl7dGhpcy5hc3RCdWlsZGVyPWI7dGhpcy4kZmlsdGVyPWF9ZnVuY3Rpb24gc2QoYixhKXt0aGlzLmFzdEJ1aWxkZXI9Yjt0aGlzLiRmaWx0ZXI9YX1mdW5jdGlvbiBFYihiLGEsYyxkKXtvYShiLGQpO2E9YS5zcGxpdChcXFwiLlxcXCIpO1xcbmZvcih2YXIgZSxmPTA7MTxhLmxlbmd0aDtmKyspe2U9Q2EoYS5zaGlmdCgpLGQpO3ZhciBnPW9hKGJbZV0sZCk7Z3x8KGc9e30sYltlXT1nKTtiPWd9ZT1DYShhLnNoaWZ0KCksZCk7b2EoYltlXSxkKTtyZXR1cm4gYltlXT1jfWZ1bmN0aW9uIEZiKGIpe3JldHVyblxcXCJjb25zdHJ1Y3RvclxcXCI9PWJ9ZnVuY3Rpb24gZmMoYil7cmV0dXJuIHooYi52YWx1ZU9mKT9iLnZhbHVlT2YoKTpaZi5jYWxsKGIpfWZ1bmN0aW9uIGhmKCl7dmFyIGI9Z2EoKSxhPWdhKCk7dGhpcy4kZ2V0PVtcXFwiJGZpbHRlclxcXCIsXFxcIiRzbmlmZmVyXFxcIixmdW5jdGlvbihjLGQpe2Z1bmN0aW9uIGUoYSxiKXtyZXR1cm4gbnVsbD09YXx8bnVsbD09Yj9hPT09YjpcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBhJiYoYT1mYyhhKSxcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBhKT8hMTphPT09Ynx8YSE9PWEmJmIhPT1ifWZ1bmN0aW9uIGYoYSxiLGMsZCxmKXt2YXIgZz1kLmlucHV0cyxoO2lmKDE9PT1nLmxlbmd0aCl7dmFyIGs9ZSxnPWdbMF07cmV0dXJuIGEuJHdhdGNoKGZ1bmN0aW9uKGEpe3ZhciBiPVxcbmcoYSk7ZShiLGspfHwoaD1kKGEsdCx0LFtiXSksaz1iJiZmYyhiKSk7cmV0dXJuIGh9LGIsYyxmKX1mb3IodmFyIGw9W10sbj1bXSxyPTAsbT1nLmxlbmd0aDtyPG07cisrKWxbcl09ZSxuW3JdPW51bGw7cmV0dXJuIGEuJHdhdGNoKGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0hMSxjPTAsZj1nLmxlbmd0aDtjPGY7YysrKXt2YXIgaz1nW2NdKGEpO2lmKGJ8fChiPSFlKGssbFtjXSkpKW5bY109ayxsW2NdPWsmJmZjKGspfWImJihoPWQoYSx0LHQsbikpO3JldHVybiBofSxiLGMsZil9ZnVuY3Rpb24gZyhhLGIsYyxkKXt2YXIgZSxmO3JldHVybiBlPWEuJHdhdGNoKGZ1bmN0aW9uKGEpe3JldHVybiBkKGEpfSxmdW5jdGlvbihhLGMsZCl7Zj1hO3ooYikmJmIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3coYSkmJmQuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCl7dyhmKSYmZSgpfSl9LGMpfWZ1bmN0aW9uIGgoYSxiLGMsZCl7ZnVuY3Rpb24gZShhKXt2YXIgYj0hMDttKGEsZnVuY3Rpb24oYSl7dyhhKXx8XFxuKGI9ITEpfSk7cmV0dXJuIGJ9dmFyIGYsZztyZXR1cm4gZj1hLiR3YXRjaChmdW5jdGlvbihhKXtyZXR1cm4gZChhKX0sZnVuY3Rpb24oYSxjLGQpe2c9YTt6KGIpJiZiLmNhbGwodGhpcyxhLGMsZCk7ZShhKSYmZC4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKXtlKGcpJiZmKCl9KX0sYyl9ZnVuY3Rpb24gbChhLGIsYyxkKXt2YXIgZTtyZXR1cm4gZT1hLiR3YXRjaChmdW5jdGlvbihhKXtyZXR1cm4gZChhKX0sZnVuY3Rpb24oYSxjLGQpe3ooYikmJmIuYXBwbHkodGhpcyxhcmd1bWVudHMpO2UoKX0sYyl9ZnVuY3Rpb24gayhhLGIpe2lmKCFiKXJldHVybiBhO3ZhciBjPWEuJCR3YXRjaERlbGVnYXRlLGM9YyE9PWgmJmMhPT1nP2Z1bmN0aW9uKGMsZCxlLGYpe2U9YShjLGQsZSxmKTtyZXR1cm4gYihlLGMsZCl9OmZ1bmN0aW9uKGMsZCxlLGYpe2U9YShjLGQsZSxmKTtjPWIoZSxjLGQpO3JldHVybiB3KGUpP2M6ZX07YS4kJHdhdGNoRGVsZWdhdGUmJmEuJCR3YXRjaERlbGVnYXRlIT09XFxuZj9jLiQkd2F0Y2hEZWxlZ2F0ZT1hLiQkd2F0Y2hEZWxlZ2F0ZTpiLiRzdGF0ZWZ1bHx8KGMuJCR3YXRjaERlbGVnYXRlPWYsYy5pbnB1dHM9YS5pbnB1dHM/YS5pbnB1dHM6W2FdKTtyZXR1cm4gY312YXIgbj17Y3NwOmQuY3NwLGV4cGVuc2l2ZUNoZWNrczohMX0scj17Y3NwOmQuY3NwLGV4cGVuc2l2ZUNoZWNrczohMH07cmV0dXJuIGZ1bmN0aW9uKGQsZSxDKXt2YXIgbSx1LHA7c3dpdGNoKHR5cGVvZiBkKXtjYXNlIFxcXCJzdHJpbmdcXFwiOnA9ZD1kLnRyaW0oKTt2YXIgcT1DP2E6YjttPXFbcF07bXx8KFxcXCI6XFxcIj09PWQuY2hhckF0KDApJiZcXFwiOlxcXCI9PT1kLmNoYXJBdCgxKSYmKHU9ITAsZD1kLnN1YnN0cmluZygyKSksQz1DP3I6bixtPW5ldyBnYyhDKSxtPShuZXcgaGMobSxjLEMpKS5wYXJzZShkKSxtLmNvbnN0YW50P20uJCR3YXRjaERlbGVnYXRlPWw6dT9tLiQkd2F0Y2hEZWxlZ2F0ZT1tLmxpdGVyYWw/aDpnOm0uaW5wdXRzJiYobS4kJHdhdGNoRGVsZWdhdGU9ZikscVtwXT1tKTtyZXR1cm4gayhtLFxcbmUpO2Nhc2UgXFxcImZ1bmN0aW9uXFxcIjpyZXR1cm4gayhkLGUpO2RlZmF1bHQ6cmV0dXJuIHZ9fX1dfWZ1bmN0aW9uIGtmKCl7dGhpcy4kZ2V0PVtcXFwiJHJvb3RTY29wZVxcXCIsXFxcIiRleGNlcHRpb25IYW5kbGVyXFxcIixmdW5jdGlvbihiLGEpe3JldHVybiB0ZChmdW5jdGlvbihhKXtiLiRldmFsQXN5bmMoYSl9LGEpfV19ZnVuY3Rpb24gbGYoKXt0aGlzLiRnZXQ9W1xcXCIkYnJvd3NlclxcXCIsXFxcIiRleGNlcHRpb25IYW5kbGVyXFxcIixmdW5jdGlvbihiLGEpe3JldHVybiB0ZChmdW5jdGlvbihhKXtiLmRlZmVyKGEpfSxhKX1dfWZ1bmN0aW9uIHRkKGIsYSl7ZnVuY3Rpb24gYyhhLGIsYyl7ZnVuY3Rpb24gZChiKXtyZXR1cm4gZnVuY3Rpb24oYyl7ZXx8KGU9ITAsYi5jYWxsKGEsYykpfX12YXIgZT0hMTtyZXR1cm5bZChiKSxkKGMpXX1mdW5jdGlvbiBkKCl7dGhpcy4kJHN0YXRlPXtzdGF0dXM6MH19ZnVuY3Rpb24gZShhLGIpe3JldHVybiBmdW5jdGlvbihjKXtiLmNhbGwoYSxjKX19ZnVuY3Rpb24gZihjKXshYy5wcm9jZXNzU2NoZWR1bGVkJiZcXG5jLnBlbmRpbmcmJihjLnByb2Nlc3NTY2hlZHVsZWQ9ITAsYihmdW5jdGlvbigpe3ZhciBiLGQsZTtlPWMucGVuZGluZztjLnByb2Nlc3NTY2hlZHVsZWQ9ITE7Yy5wZW5kaW5nPXQ7Zm9yKHZhciBmPTAsZz1lLmxlbmd0aDtmPGc7KytmKXtkPWVbZl1bMF07Yj1lW2ZdW2Muc3RhdHVzXTt0cnl7eihiKT9kLnJlc29sdmUoYihjLnZhbHVlKSk6MT09PWMuc3RhdHVzP2QucmVzb2x2ZShjLnZhbHVlKTpkLnJlamVjdChjLnZhbHVlKX1jYXRjaChoKXtkLnJlamVjdChoKSxhKGgpfX19KSl9ZnVuY3Rpb24gZygpe3RoaXMucHJvbWlzZT1uZXcgZDt0aGlzLnJlc29sdmU9ZSh0aGlzLHRoaXMucmVzb2x2ZSk7dGhpcy5yZWplY3Q9ZSh0aGlzLHRoaXMucmVqZWN0KTt0aGlzLm5vdGlmeT1lKHRoaXMsdGhpcy5ub3RpZnkpfXZhciBoPUooXFxcIiRxXFxcIixUeXBlRXJyb3IpO2QucHJvdG90eXBlPXt0aGVuOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1uZXcgZzt0aGlzLiQkc3RhdGUucGVuZGluZz10aGlzLiQkc3RhdGUucGVuZGluZ3x8XFxuW107dGhpcy4kJHN0YXRlLnBlbmRpbmcucHVzaChbZCxhLGIsY10pOzA8dGhpcy4kJHN0YXRlLnN0YXR1cyYmZih0aGlzLiQkc3RhdGUpO3JldHVybiBkLnByb21pc2V9LFxcXCJjYXRjaFxcXCI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGhlbihudWxsLGEpfSxcXFwiZmluYWxseVxcXCI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKGIpe3JldHVybiBrKGIsITAsYSl9LGZ1bmN0aW9uKGIpe3JldHVybiBrKGIsITEsYSl9LGIpfX07Zy5wcm90b3R5cGU9e3Jlc29sdmU6ZnVuY3Rpb24oYSl7dGhpcy5wcm9taXNlLiQkc3RhdGUuc3RhdHVzfHwoYT09PXRoaXMucHJvbWlzZT90aGlzLiQkcmVqZWN0KGgoXFxcInFjeWNsZVxcXCIsYSkpOnRoaXMuJCRyZXNvbHZlKGEpKX0sJCRyZXNvbHZlOmZ1bmN0aW9uKGIpe3ZhciBkLGU7ZT1jKHRoaXMsdGhpcy4kJHJlc29sdmUsdGhpcy4kJHJlamVjdCk7dHJ5e2lmKEgoYil8fHooYikpZD1iJiZiLnRoZW47eihkKT8odGhpcy5wcm9taXNlLiQkc3RhdGUuc3RhdHVzPVxcbi0xLGQuY2FsbChiLGVbMF0sZVsxXSx0aGlzLm5vdGlmeSkpOih0aGlzLnByb21pc2UuJCRzdGF0ZS52YWx1ZT1iLHRoaXMucHJvbWlzZS4kJHN0YXRlLnN0YXR1cz0xLGYodGhpcy5wcm9taXNlLiQkc3RhdGUpKX1jYXRjaChnKXtlWzFdKGcpLGEoZyl9fSxyZWplY3Q6ZnVuY3Rpb24oYSl7dGhpcy5wcm9taXNlLiQkc3RhdGUuc3RhdHVzfHx0aGlzLiQkcmVqZWN0KGEpfSwkJHJlamVjdDpmdW5jdGlvbihhKXt0aGlzLnByb21pc2UuJCRzdGF0ZS52YWx1ZT1hO3RoaXMucHJvbWlzZS4kJHN0YXRlLnN0YXR1cz0yO2YodGhpcy5wcm9taXNlLiQkc3RhdGUpfSxub3RpZnk6ZnVuY3Rpb24oYyl7dmFyIGQ9dGhpcy5wcm9taXNlLiQkc3RhdGUucGVuZGluZzswPj10aGlzLnByb21pc2UuJCRzdGF0ZS5zdGF0dXMmJmQmJmQubGVuZ3RoJiZiKGZ1bmN0aW9uKCl7Zm9yKHZhciBiLGUsZj0wLGc9ZC5sZW5ndGg7ZjxnO2YrKyl7ZT1kW2ZdWzBdO2I9ZFtmXVszXTt0cnl7ZS5ub3RpZnkoeihiKT9cXG5iKGMpOmMpfWNhdGNoKGgpe2EoaCl9fX0pfX07dmFyIGw9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgZztiP2MucmVzb2x2ZShhKTpjLnJlamVjdChhKTtyZXR1cm4gYy5wcm9taXNlfSxrPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1udWxsO3RyeXt6KGMpJiYoZD1jKCkpfWNhdGNoKGUpe3JldHVybiBsKGUsITEpfXJldHVybiBkJiZ6KGQudGhlbik/ZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGwoYSxiKX0sZnVuY3Rpb24oYSl7cmV0dXJuIGwoYSwhMSl9KTpsKGEsYil9LG49ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bmV3IGc7ZS5yZXNvbHZlKGEpO3JldHVybiBlLnByb21pc2UudGhlbihiLGMsZCl9LHI9ZnVuY3Rpb24geChhKXtpZigheihhKSl0aHJvdyBoKFxcXCJub3JzbHZyXFxcIixhKTtpZighKHRoaXMgaW5zdGFuY2VvZiB4KSlyZXR1cm4gbmV3IHgoYSk7dmFyIGI9bmV3IGc7YShmdW5jdGlvbihhKXtiLnJlc29sdmUoYSl9LGZ1bmN0aW9uKGEpe2IucmVqZWN0KGEpfSk7cmV0dXJuIGIucHJvbWlzZX07XFxuci5kZWZlcj1mdW5jdGlvbigpe3JldHVybiBuZXcgZ307ci5yZWplY3Q9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGc7Yi5yZWplY3QoYSk7cmV0dXJuIGIucHJvbWlzZX07ci53aGVuPW47ci5yZXNvbHZlPW47ci5hbGw9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGcsYz0wLGQ9RyhhKT9bXTp7fTttKGEsZnVuY3Rpb24oYSxlKXtjKys7bihhKS50aGVuKGZ1bmN0aW9uKGEpe2QuaGFzT3duUHJvcGVydHkoZSl8fChkW2VdPWEsLS1jfHxiLnJlc29sdmUoZCkpfSxmdW5jdGlvbihhKXtkLmhhc093blByb3BlcnR5KGUpfHxiLnJlamVjdChhKX0pfSk7MD09PWMmJmIucmVzb2x2ZShkKTtyZXR1cm4gYi5wcm9taXNlfTtyZXR1cm4gcn1mdW5jdGlvbiB1Zigpe3RoaXMuJGdldD1bXFxcIiR3aW5kb3dcXFwiLFxcXCIkdGltZW91dFxcXCIsZnVuY3Rpb24oYixhKXtmdW5jdGlvbiBjKCl7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDthKyspe3ZhciBiPW5bYV07YiYmKG5bYV09bnVsbCxiKCkpfWs9bi5sZW5ndGg9MH1mdW5jdGlvbiBkKGEpe3ZhciBiPVxcbm4ubGVuZ3RoO2srKztuLnB1c2goYSk7MD09PWImJihsPWgoYykpO3JldHVybiBmdW5jdGlvbigpezA8PWImJihiPW5bYl09bnVsbCwwPT09LS1rJiZsJiYobCgpLGw9bnVsbCxuLmxlbmd0aD0wKSl9fXZhciBlPWIucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxiLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSxmPWIuY2FuY2VsQW5pbWF0aW9uRnJhbWV8fGIud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fGIud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lLGc9ISFlLGg9Zz9mdW5jdGlvbihhKXt2YXIgYj1lKGEpO3JldHVybiBmdW5jdGlvbigpe2YoYil9fTpmdW5jdGlvbihiKXt2YXIgYz1hKGIsMTYuNjYsITEpO3JldHVybiBmdW5jdGlvbigpe2EuY2FuY2VsKGMpfX07ZC5zdXBwb3J0ZWQ9Zzt2YXIgbCxrPTAsbj1bXTtyZXR1cm4gZH1dfWZ1bmN0aW9uIGpmKCl7ZnVuY3Rpb24gYihhKXtmdW5jdGlvbiBiKCl7dGhpcy4kJHdhdGNoZXJzPXRoaXMuJCRuZXh0U2libGluZz1cXG50aGlzLiQkY2hpbGRIZWFkPXRoaXMuJCRjaGlsZFRhaWw9bnVsbDt0aGlzLiQkbGlzdGVuZXJzPXt9O3RoaXMuJCRsaXN0ZW5lckNvdW50PXt9O3RoaXMuJCR3YXRjaGVyc0NvdW50PTA7dGhpcy4kaWQ9KytuYjt0aGlzLiQkQ2hpbGRTY29wZT1udWxsfWIucHJvdG90eXBlPWE7cmV0dXJuIGJ9dmFyIGE9MTAsYz1KKFxcXCIkcm9vdFNjb3BlXFxcIiksZD1udWxsLGU9bnVsbDt0aGlzLmRpZ2VzdFR0bD1mdW5jdGlvbihiKXthcmd1bWVudHMubGVuZ3RoJiYoYT1iKTtyZXR1cm4gYX07dGhpcy4kZ2V0PVtcXFwiJGluamVjdG9yXFxcIixcXFwiJGV4Y2VwdGlvbkhhbmRsZXJcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkYnJvd3NlclxcXCIsZnVuY3Rpb24oZixnLGgsbCl7ZnVuY3Rpb24gayhhKXthLmN1cnJlbnRTY29wZS4kJGRlc3Ryb3llZD0hMH1mdW5jdGlvbiBuKCl7dGhpcy4kaWQ9KytuYjt0aGlzLiQkcGhhc2U9dGhpcy4kcGFyZW50PXRoaXMuJCR3YXRjaGVycz10aGlzLiQkbmV4dFNpYmxpbmc9dGhpcy4kJHByZXZTaWJsaW5nPXRoaXMuJCRjaGlsZEhlYWQ9XFxudGhpcy4kJGNoaWxkVGFpbD1udWxsO3RoaXMuJHJvb3Q9dGhpczt0aGlzLiQkZGVzdHJveWVkPSExO3RoaXMuJCRsaXN0ZW5lcnM9e307dGhpcy4kJGxpc3RlbmVyQ291bnQ9e307dGhpcy4kJHdhdGNoZXJzQ291bnQ9MDt0aGlzLiQkaXNvbGF0ZUJpbmRpbmdzPW51bGx9ZnVuY3Rpb24gcihhKXtpZihwLiQkcGhhc2UpdGhyb3cgYyhcXFwiaW5wcm9nXFxcIixwLiQkcGhhc2UpO3AuJCRwaGFzZT1hfWZ1bmN0aW9uIHMoYSxiKXtkbyBhLiQkd2F0Y2hlcnNDb3VudCs9Yjt3aGlsZShhPWEuJHBhcmVudCl9ZnVuY3Rpb24geChhLGIsYyl7ZG8gYS4kJGxpc3RlbmVyQ291bnRbY10tPWIsMD09PWEuJCRsaXN0ZW5lckNvdW50W2NdJiZkZWxldGUgYS4kJGxpc3RlbmVyQ291bnRbY107d2hpbGUoYT1hLiRwYXJlbnQpfWZ1bmN0aW9uIHEoKXt9ZnVuY3Rpb24gRigpe2Zvcig7SS5sZW5ndGg7KXRyeXtJLnNoaWZ0KCkoKX1jYXRjaChhKXtnKGEpfWU9bnVsbH1mdW5jdGlvbiB1KCl7bnVsbD09PWUmJihlPVxcbmwuZGVmZXIoZnVuY3Rpb24oKXtwLiRhcHBseShGKX0pKX1uLnByb3RvdHlwZT17Y29uc3RydWN0b3I6biwkbmV3OmZ1bmN0aW9uKGEsYyl7dmFyIGQ7Yz1jfHx0aGlzO2E/KGQ9bmV3IG4sZC4kcm9vdD10aGlzLiRyb290KToodGhpcy4kJENoaWxkU2NvcGV8fCh0aGlzLiQkQ2hpbGRTY29wZT1iKHRoaXMpKSxkPW5ldyB0aGlzLiQkQ2hpbGRTY29wZSk7ZC4kcGFyZW50PWM7ZC4kJHByZXZTaWJsaW5nPWMuJCRjaGlsZFRhaWw7Yy4kJGNoaWxkSGVhZD8oYy4kJGNoaWxkVGFpbC4kJG5leHRTaWJsaW5nPWQsYy4kJGNoaWxkVGFpbD1kKTpjLiQkY2hpbGRIZWFkPWMuJCRjaGlsZFRhaWw9ZDsoYXx8YyE9dGhpcykmJmQuJG9uKFxcXCIkZGVzdHJveVxcXCIsayk7cmV0dXJuIGR9LCR3YXRjaDpmdW5jdGlvbihhLGIsYyxlKXt2YXIgZj1oKGEpO2lmKGYuJCR3YXRjaERlbGVnYXRlKXJldHVybiBmLiQkd2F0Y2hEZWxlZ2F0ZSh0aGlzLGIsYyxmLGEpO3ZhciBnPXRoaXMsaz1nLiQkd2F0Y2hlcnMsbD1cXG57Zm46YixsYXN0OnEsZ2V0OmYsZXhwOmV8fGEsZXE6ISFjfTtkPW51bGw7eihiKXx8KGwuZm49dik7a3x8KGs9Zy4kJHdhdGNoZXJzPVtdKTtrLnVuc2hpZnQobCk7cyh0aGlzLDEpO3JldHVybiBmdW5jdGlvbigpezA8PWJiKGssbCkmJnMoZywtMSk7ZD1udWxsfX0sJHdhdGNoR3JvdXA6ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7aD0hMTtrPyhrPSExLGIoZSxlLGcpKTpiKGUsZCxnKX12YXIgZD1BcnJheShhLmxlbmd0aCksZT1BcnJheShhLmxlbmd0aCksZj1bXSxnPXRoaXMsaD0hMSxrPSEwO2lmKCFhLmxlbmd0aCl7dmFyIGw9ITA7Zy4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7bCYmYihlLGUsZyl9KTtyZXR1cm4gZnVuY3Rpb24oKXtsPSExfX1pZigxPT09YS5sZW5ndGgpcmV0dXJuIHRoaXMuJHdhdGNoKGFbMF0sZnVuY3Rpb24oYSxjLGYpe2VbMF09YTtkWzBdPWM7YihlLGE9PT1jP2U6ZCxmKX0pO20oYSxmdW5jdGlvbihhLGIpe3ZhciBrPWcuJHdhdGNoKGEsZnVuY3Rpb24oYSxcXG5mKXtlW2JdPWE7ZFtiXT1mO2h8fChoPSEwLGcuJGV2YWxBc3luYyhjKSl9KTtmLnB1c2goayl9KTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IoO2YubGVuZ3RoOylmLnNoaWZ0KCkoKX19LCR3YXRjaENvbGxlY3Rpb246ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2U9YTt2YXIgYixkLGcsaDtpZighQShlKSl7aWYoSChlKSlpZihFYShlKSlmb3IoZiE9PXImJihmPXIsbT1mLmxlbmd0aD0wLGwrKyksYT1lLmxlbmd0aCxtIT09YSYmKGwrKyxmLmxlbmd0aD1tPWEpLGI9MDtiPGE7YisrKWg9ZltiXSxnPWVbYl0sZD1oIT09aCYmZyE9PWcsZHx8aD09PWd8fChsKyssZltiXT1nKTtlbHNle2YhPT1zJiYoZj1zPXt9LG09MCxsKyspO2E9MDtmb3IoYiBpbiBlKWUuaGFzT3duUHJvcGVydHkoYikmJihhKyssZz1lW2JdLGg9ZltiXSxiIGluIGY/KGQ9aCE9PWgmJmchPT1nLGR8fGg9PT1nfHwobCsrLGZbYl09ZykpOihtKyssZltiXT1nLGwrKykpO2lmKG0+YSlmb3IoYiBpbiBsKyssZillLmhhc093blByb3BlcnR5KGIpfHxcXG4obS0tLGRlbGV0ZSBmW2JdKX1lbHNlIGYhPT1lJiYoZj1lLGwrKyk7cmV0dXJuIGx9fWMuJHN0YXRlZnVsPSEwO3ZhciBkPXRoaXMsZSxmLGcsaz0xPGIubGVuZ3RoLGw9MCxuPWgoYSxjKSxyPVtdLHM9e30scD0hMCxtPTA7cmV0dXJuIHRoaXMuJHdhdGNoKG4sZnVuY3Rpb24oKXtwPyhwPSExLGIoZSxlLGQpKTpiKGUsZyxkKTtpZihrKWlmKEgoZSkpaWYoRWEoZSkpe2c9QXJyYXkoZS5sZW5ndGgpO2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSsrKWdbYV09ZVthXX1lbHNlIGZvcihhIGluIGc9e30sZSlYYS5jYWxsKGUsYSkmJihnW2FdPWVbYV0pO2Vsc2UgZz1lfSl9LCRkaWdlc3Q6ZnVuY3Rpb24oKXt2YXIgYixmLGgsayxuLHMsbT1hLHgsdT1bXSxFLEk7cihcXFwiJGRpZ2VzdFxcXCIpO2wuJCRjaGVja1VybENoYW5nZSgpO3RoaXM9PT1wJiZudWxsIT09ZSYmKGwuZGVmZXIuY2FuY2VsKGUpLEYoKSk7ZD1udWxsO2Rve3M9ITE7Zm9yKHg9dGhpczt0Lmxlbmd0aDspe3RyeXtJPXQuc2hpZnQoKSxcXG5JLnNjb3BlLiRldmFsKEkuZXhwcmVzc2lvbixJLmxvY2Fscyl9Y2F0Y2godil7Zyh2KX1kPW51bGx9YTpkb3tpZihrPXguJCR3YXRjaGVycylmb3Iobj1rLmxlbmd0aDtuLS07KXRyeXtpZihiPWtbbl0paWYoKGY9Yi5nZXQoeCkpIT09KGg9Yi5sYXN0KSYmIShiLmVxP2thKGYsaCk6XFxcIm51bWJlclxcXCI9PT10eXBlb2YgZiYmXFxcIm51bWJlclxcXCI9PT10eXBlb2YgaCYmaXNOYU4oZikmJmlzTmFOKGgpKSlzPSEwLGQ9YixiLmxhc3Q9Yi5lcT9mYShmLG51bGwpOmYsYi5mbihmLGg9PT1xP2Y6aCx4KSw1Pm0mJihFPTQtbSx1W0VdfHwodVtFXT1bXSksdVtFXS5wdXNoKHttc2c6eihiLmV4cCk/XFxcImZuOiBcXFwiKyhiLmV4cC5uYW1lfHxiLmV4cC50b1N0cmluZygpKTpiLmV4cCxuZXdWYWw6ZixvbGRWYWw6aH0pKTtlbHNlIGlmKGI9PT1kKXtzPSExO2JyZWFrIGF9fWNhdGNoKEEpe2coQSl9aWYoIShrPXguJCR3YXRjaGVyc0NvdW50JiZ4LiQkY2hpbGRIZWFkfHx4IT09dGhpcyYmeC4kJG5leHRTaWJsaW5nKSlmb3IoO3ghPT1cXG50aGlzJiYhKGs9eC4kJG5leHRTaWJsaW5nKTspeD14LiRwYXJlbnR9d2hpbGUoeD1rKTtpZigoc3x8dC5sZW5ndGgpJiYhbS0tKXRocm93IHAuJCRwaGFzZT1udWxsLGMoXFxcImluZmRpZ1xcXCIsYSx1KTt9d2hpbGUoc3x8dC5sZW5ndGgpO2ZvcihwLiQkcGhhc2U9bnVsbDt3Lmxlbmd0aDspdHJ5e3cuc2hpZnQoKSgpfWNhdGNoKHkpe2coeSl9fSwkZGVzdHJveTpmdW5jdGlvbigpe2lmKCF0aGlzLiQkZGVzdHJveWVkKXt2YXIgYT10aGlzLiRwYXJlbnQ7dGhpcy4kYnJvYWRjYXN0KFxcXCIkZGVzdHJveVxcXCIpO3RoaXMuJCRkZXN0cm95ZWQ9ITA7dGhpcz09PXAmJmwuJCRhcHBsaWNhdGlvbkRlc3Ryb3llZCgpO3ModGhpcywtdGhpcy4kJHdhdGNoZXJzQ291bnQpO2Zvcih2YXIgYiBpbiB0aGlzLiQkbGlzdGVuZXJDb3VudCl4KHRoaXMsdGhpcy4kJGxpc3RlbmVyQ291bnRbYl0sYik7YSYmYS4kJGNoaWxkSGVhZD09dGhpcyYmKGEuJCRjaGlsZEhlYWQ9dGhpcy4kJG5leHRTaWJsaW5nKTthJiZhLiQkY2hpbGRUYWlsPT1cXG50aGlzJiYoYS4kJGNoaWxkVGFpbD10aGlzLiQkcHJldlNpYmxpbmcpO3RoaXMuJCRwcmV2U2libGluZyYmKHRoaXMuJCRwcmV2U2libGluZy4kJG5leHRTaWJsaW5nPXRoaXMuJCRuZXh0U2libGluZyk7dGhpcy4kJG5leHRTaWJsaW5nJiYodGhpcy4kJG5leHRTaWJsaW5nLiQkcHJldlNpYmxpbmc9dGhpcy4kJHByZXZTaWJsaW5nKTt0aGlzLiRkZXN0cm95PXRoaXMuJGRpZ2VzdD10aGlzLiRhcHBseT10aGlzLiRldmFsQXN5bmM9dGhpcy4kYXBwbHlBc3luYz12O3RoaXMuJG9uPXRoaXMuJHdhdGNoPXRoaXMuJHdhdGNoR3JvdXA9ZnVuY3Rpb24oKXtyZXR1cm4gdn07dGhpcy4kJGxpc3RlbmVycz17fTt0aGlzLiRwYXJlbnQ9dGhpcy4kJG5leHRTaWJsaW5nPXRoaXMuJCRwcmV2U2libGluZz10aGlzLiQkY2hpbGRIZWFkPXRoaXMuJCRjaGlsZFRhaWw9dGhpcy4kcm9vdD10aGlzLiQkd2F0Y2hlcnM9bnVsbH19LCRldmFsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGgoYSkodGhpcyxiKX0sXFxuJGV2YWxBc3luYzpmdW5jdGlvbihhLGIpe3AuJCRwaGFzZXx8dC5sZW5ndGh8fGwuZGVmZXIoZnVuY3Rpb24oKXt0Lmxlbmd0aCYmcC4kZGlnZXN0KCl9KTt0LnB1c2goe3Njb3BlOnRoaXMsZXhwcmVzc2lvbjphLGxvY2FsczpifSl9LCQkcG9zdERpZ2VzdDpmdW5jdGlvbihhKXt3LnB1c2goYSl9LCRhcHBseTpmdW5jdGlvbihhKXt0cnl7cmV0dXJuIHIoXFxcIiRhcHBseVxcXCIpLHRoaXMuJGV2YWwoYSl9Y2F0Y2goYil7ZyhiKX1maW5hbGx5e3AuJCRwaGFzZT1udWxsO3RyeXtwLiRkaWdlc3QoKX1jYXRjaChjKXt0aHJvdyBnKGMpLGM7fX19LCRhcHBseUFzeW5jOmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtjLiRldmFsKGEpfXZhciBjPXRoaXM7YSYmSS5wdXNoKGIpO3UoKX0sJG9uOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy4kJGxpc3RlbmVyc1thXTtjfHwodGhpcy4kJGxpc3RlbmVyc1thXT1jPVtdKTtjLnB1c2goYik7dmFyIGQ9dGhpcztkbyBkLiQkbGlzdGVuZXJDb3VudFthXXx8XFxuKGQuJCRsaXN0ZW5lckNvdW50W2FdPTApLGQuJCRsaXN0ZW5lckNvdW50W2FdKys7d2hpbGUoZD1kLiRwYXJlbnQpO3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGQ9Yy5pbmRleE9mKGIpOy0xIT09ZCYmKGNbZF09bnVsbCx4KGUsMSxhKSl9fSwkZW1pdDpmdW5jdGlvbihhLGIpe3ZhciBjPVtdLGQsZT10aGlzLGY9ITEsaD17bmFtZTphLHRhcmdldFNjb3BlOmUsc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7Zj0hMH0scHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXtoLmRlZmF1bHRQcmV2ZW50ZWQ9ITB9LGRlZmF1bHRQcmV2ZW50ZWQ6ITF9LGs9Y2IoW2hdLGFyZ3VtZW50cywxKSxsLG47ZG97ZD1lLiQkbGlzdGVuZXJzW2FdfHxjO2guY3VycmVudFNjb3BlPWU7bD0wO2ZvcihuPWQubGVuZ3RoO2w8bjtsKyspaWYoZFtsXSl0cnl7ZFtsXS5hcHBseShudWxsLGspfWNhdGNoKHIpe2cocil9ZWxzZSBkLnNwbGljZShsLDEpLGwtLSxuLS07aWYoZilyZXR1cm4gaC5jdXJyZW50U2NvcGU9XFxubnVsbCxoO2U9ZS4kcGFyZW50fXdoaWxlKGUpO2guY3VycmVudFNjb3BlPW51bGw7cmV0dXJuIGh9LCRicm9hZGNhc3Q6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9dGhpcyxlPXtuYW1lOmEsdGFyZ2V0U2NvcGU6dGhpcyxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe2UuZGVmYXVsdFByZXZlbnRlZD0hMH0sZGVmYXVsdFByZXZlbnRlZDohMX07aWYoIXRoaXMuJCRsaXN0ZW5lckNvdW50W2FdKXJldHVybiBlO2Zvcih2YXIgZj1jYihbZV0sYXJndW1lbnRzLDEpLGgsaztjPWQ7KXtlLmN1cnJlbnRTY29wZT1jO2Q9Yy4kJGxpc3RlbmVyc1thXXx8W107aD0wO2ZvcihrPWQubGVuZ3RoO2g8aztoKyspaWYoZFtoXSl0cnl7ZFtoXS5hcHBseShudWxsLGYpfWNhdGNoKGwpe2cobCl9ZWxzZSBkLnNwbGljZShoLDEpLGgtLSxrLS07aWYoIShkPWMuJCRsaXN0ZW5lckNvdW50W2FdJiZjLiQkY2hpbGRIZWFkfHxjIT09dGhpcyYmYy4kJG5leHRTaWJsaW5nKSlmb3IoO2MhPT10aGlzJiYhKGQ9XFxuYy4kJG5leHRTaWJsaW5nKTspYz1jLiRwYXJlbnR9ZS5jdXJyZW50U2NvcGU9bnVsbDtyZXR1cm4gZX19O3ZhciBwPW5ldyBuLHQ9cC4kJGFzeW5jUXVldWU9W10sdz1wLiQkcG9zdERpZ2VzdFF1ZXVlPVtdLEk9cC4kJGFwcGx5QXN5bmNRdWV1ZT1bXTtyZXR1cm4gcH1dfWZ1bmN0aW9uIGhlKCl7dmFyIGI9L15cXFxccyooaHR0cHM/fGZ0cHxtYWlsdG98dGVsfGZpbGUpOi8sYT0vXlxcXFxzKigoaHR0cHM/fGZ0cHxmaWxlfGJsb2IpOnxkYXRhOmltYWdlXFxcXC8pLzt0aGlzLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0PWZ1bmN0aW9uKGEpe3JldHVybiB3KGEpPyhiPWEsdGhpcyk6Yn07dGhpcy5pbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3Q9ZnVuY3Rpb24oYil7cmV0dXJuIHcoYik/KGE9Yix0aGlzKTphfTt0aGlzLiRnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oYyxkKXt2YXIgZT1kP2E6YixmO2Y9QmEoYykuaHJlZjtyZXR1cm5cXFwiXFxcIj09PWZ8fGYubWF0Y2goZSk/YzpcXFwidW5zYWZlOlxcXCIrXFxuZn19fWZ1bmN0aW9uICRmKGIpe2lmKFxcXCJzZWxmXFxcIj09PWIpcmV0dXJuIGI7aWYoTChiKSl7aWYoLTE8Yi5pbmRleE9mKFxcXCIqKipcXFwiKSl0aHJvdyBEYShcXFwiaXdjYXJkXFxcIixiKTtiPXVkKGIpLnJlcGxhY2UoXFxcIlxcXFxcXFxcKlxcXFxcXFxcKlxcXCIsXFxcIi4qXFxcIikucmVwbGFjZShcXFwiXFxcXFxcXFwqXFxcIixcXFwiW146Ly4/JjtdKlxcXCIpO3JldHVybiBuZXcgUmVnRXhwKFxcXCJeXFxcIitiK1xcXCIkXFxcIil9aWYoWmEoYikpcmV0dXJuIG5ldyBSZWdFeHAoXFxcIl5cXFwiK2Iuc291cmNlK1xcXCIkXFxcIik7dGhyb3cgRGEoXFxcImltYXRjaGVyXFxcIik7fWZ1bmN0aW9uIHZkKGIpe3ZhciBhPVtdO3coYikmJm0oYixmdW5jdGlvbihiKXthLnB1c2goJGYoYikpfSk7cmV0dXJuIGF9ZnVuY3Rpb24gbmYoKXt0aGlzLlNDRV9DT05URVhUUz1wYTt2YXIgYj1bXFxcInNlbGZcXFwiXSxhPVtdO3RoaXMucmVzb3VyY2VVcmxXaGl0ZWxpc3Q9ZnVuY3Rpb24oYSl7YXJndW1lbnRzLmxlbmd0aCYmKGI9dmQoYSkpO3JldHVybiBifTt0aGlzLnJlc291cmNlVXJsQmxhY2tsaXN0PWZ1bmN0aW9uKGIpe2FyZ3VtZW50cy5sZW5ndGgmJlxcbihhPXZkKGIpKTtyZXR1cm4gYX07dGhpcy4kZ2V0PVtcXFwiJGluamVjdG9yXFxcIixmdW5jdGlvbihjKXtmdW5jdGlvbiBkKGEsYil7cmV0dXJuXFxcInNlbGZcXFwiPT09YT9nZChiKTohIWEuZXhlYyhiLmhyZWYpfWZ1bmN0aW9uIGUoYSl7dmFyIGI9ZnVuY3Rpb24oYSl7dGhpcy4kJHVud3JhcFRydXN0ZWRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiBhfX07YSYmKGIucHJvdG90eXBlPW5ldyBhKTtiLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJCR1bndyYXBUcnVzdGVkVmFsdWUoKX07Yi5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kJHVud3JhcFRydXN0ZWRWYWx1ZSgpLnRvU3RyaW5nKCl9O3JldHVybiBifXZhciBmPWZ1bmN0aW9uKGEpe3Rocm93IERhKFxcXCJ1bnNhZmVcXFwiKTt9O2MuaGFzKFxcXCIkc2FuaXRpemVcXFwiKSYmKGY9Yy5nZXQoXFxcIiRzYW5pdGl6ZVxcXCIpKTt2YXIgZz1lKCksaD17fTtoW3BhLkhUTUxdPWUoZyk7aFtwYS5DU1NdPWUoZyk7aFtwYS5VUkxdPVxcbmUoZyk7aFtwYS5KU109ZShnKTtoW3BhLlJFU09VUkNFX1VSTF09ZShoW3BhLlVSTF0pO3JldHVybnt0cnVzdEFzOmZ1bmN0aW9uKGEsYil7dmFyIGM9aC5oYXNPd25Qcm9wZXJ0eShhKT9oW2FdOm51bGw7aWYoIWMpdGhyb3cgRGEoXFxcImljb250ZXh0XFxcIixhLGIpO2lmKG51bGw9PT1ifHxiPT09dHx8XFxcIlxcXCI9PT1iKXJldHVybiBiO2lmKFxcXCJzdHJpbmdcXFwiIT09dHlwZW9mIGIpdGhyb3cgRGEoXFxcIml0eXBlXFxcIixhKTtyZXR1cm4gbmV3IGMoYil9LGdldFRydXN0ZWQ6ZnVuY3Rpb24oYyxlKXtpZihudWxsPT09ZXx8ZT09PXR8fFxcXCJcXFwiPT09ZSlyZXR1cm4gZTt2YXIgZz1oLmhhc093blByb3BlcnR5KGMpP2hbY106bnVsbDtpZihnJiZlIGluc3RhbmNlb2YgZylyZXR1cm4gZS4kJHVud3JhcFRydXN0ZWRWYWx1ZSgpO2lmKGM9PT1wYS5SRVNPVVJDRV9VUkwpe3ZhciBnPUJhKGUudG9TdHJpbmcoKSkscixzLG09ITE7cj0wO2ZvcihzPWIubGVuZ3RoO3I8cztyKyspaWYoZChiW3JdLGcpKXttPSEwO2JyZWFrfWlmKG0pZm9yKHI9XFxuMCxzPWEubGVuZ3RoO3I8cztyKyspaWYoZChhW3JdLGcpKXttPSExO2JyZWFrfWlmKG0pcmV0dXJuIGU7dGhyb3cgRGEoXFxcImluc2VjdXJsXFxcIixlLnRvU3RyaW5nKCkpO31pZihjPT09cGEuSFRNTClyZXR1cm4gZihlKTt0aHJvdyBEYShcXFwidW5zYWZlXFxcIik7fSx2YWx1ZU9mOmZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgZz9hLiQkdW53cmFwVHJ1c3RlZFZhbHVlKCk6YX19fV19ZnVuY3Rpb24gbWYoKXt2YXIgYj0hMDt0aGlzLmVuYWJsZWQ9ZnVuY3Rpb24oYSl7YXJndW1lbnRzLmxlbmd0aCYmKGI9ISFhKTtyZXR1cm4gYn07dGhpcy4kZ2V0PVtcXFwiJHBhcnNlXFxcIixcXFwiJHNjZURlbGVnYXRlXFxcIixmdW5jdGlvbihhLGMpe2lmKGImJjg+VWEpdGhyb3cgRGEoXFxcImllcXVpcmtzXFxcIik7dmFyIGQ9aWEocGEpO2QuaXNFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGJ9O2QudHJ1c3RBcz1jLnRydXN0QXM7ZC5nZXRUcnVzdGVkPWMuZ2V0VHJ1c3RlZDtkLnZhbHVlT2Y9Yy52YWx1ZU9mO2J8fChkLnRydXN0QXM9XFxuZC5nZXRUcnVzdGVkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGJ9LGQudmFsdWVPZj1ZYSk7ZC5wYXJzZUFzPWZ1bmN0aW9uKGIsYyl7dmFyIGU9YShjKTtyZXR1cm4gZS5saXRlcmFsJiZlLmNvbnN0YW50P2U6YShjLGZ1bmN0aW9uKGEpe3JldHVybiBkLmdldFRydXN0ZWQoYixhKX0pfTt2YXIgZT1kLnBhcnNlQXMsZj1kLmdldFRydXN0ZWQsZz1kLnRydXN0QXM7bShwYSxmdW5jdGlvbihhLGIpe3ZhciBjPU0oYik7ZFtoYihcXFwicGFyc2VfYXNfXFxcIitjKV09ZnVuY3Rpb24oYil7cmV0dXJuIGUoYSxiKX07ZFtoYihcXFwiZ2V0X3RydXN0ZWRfXFxcIitjKV09ZnVuY3Rpb24oYil7cmV0dXJuIGYoYSxiKX07ZFtoYihcXFwidHJ1c3RfYXNfXFxcIitjKV09ZnVuY3Rpb24oYil7cmV0dXJuIGcoYSxiKX19KTtyZXR1cm4gZH1dfWZ1bmN0aW9uIG9mKCl7dGhpcy4kZ2V0PVtcXFwiJHdpbmRvd1xcXCIsXFxcIiRkb2N1bWVudFxcXCIsZnVuY3Rpb24oYixhKXt2YXIgYz17fSxkPVcoKC9hbmRyb2lkIChcXFxcZCspLy5leGVjKE0oKGIubmF2aWdhdG9yfHxcXG57fSkudXNlckFnZW50KSl8fFtdKVsxXSksZT0vQm94ZWUvaS50ZXN0KChiLm5hdmlnYXRvcnx8e30pLnVzZXJBZ2VudCksZj1hWzBdfHx7fSxnLGg9L14oTW96fHdlYmtpdHxtcykoPz1bQS1aXSkvLGw9Zi5ib2R5JiZmLmJvZHkuc3R5bGUsaz0hMSxuPSExO2lmKGwpe2Zvcih2YXIgciBpbiBsKWlmKGs9aC5leGVjKHIpKXtnPWtbMF07Zz1nLnN1YnN0cigwLDEpLnRvVXBwZXJDYXNlKCkrZy5zdWJzdHIoMSk7YnJlYWt9Z3x8KGc9XFxcIldlYmtpdE9wYWNpdHlcXFwiaW4gbCYmXFxcIndlYmtpdFxcXCIpO2s9ISEoXFxcInRyYW5zaXRpb25cXFwiaW4gbHx8ZytcXFwiVHJhbnNpdGlvblxcXCJpbiBsKTtuPSEhKFxcXCJhbmltYXRpb25cXFwiaW4gbHx8ZytcXFwiQW5pbWF0aW9uXFxcImluIGwpOyFkfHxrJiZufHwoaz1MKGwud2Via2l0VHJhbnNpdGlvbiksbj1MKGwud2Via2l0QW5pbWF0aW9uKSl9cmV0dXJue2hpc3Rvcnk6ISghYi5oaXN0b3J5fHwhYi5oaXN0b3J5LnB1c2hTdGF0ZXx8ND5kfHxlKSxoYXNFdmVudDpmdW5jdGlvbihhKXtpZihcXFwiaW5wdXRcXFwiPT09XFxuYSYmMTE+PVVhKXJldHVybiExO2lmKEEoY1thXSkpe3ZhciBiPWYuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Y1thXT1cXFwib25cXFwiK2EgaW4gYn1yZXR1cm4gY1thXX0sY3NwOmZiKCksdmVuZG9yUHJlZml4OmcsdHJhbnNpdGlvbnM6ayxhbmltYXRpb25zOm4sYW5kcm9pZDpkfX1dfWZ1bmN0aW9uIHFmKCl7dGhpcy4kZ2V0PVtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLFxcXCIkaHR0cFxcXCIsXFxcIiRxXFxcIixcXFwiJHNjZVxcXCIsZnVuY3Rpb24oYixhLGMsZCl7ZnVuY3Rpb24gZShmLGcpe2UudG90YWxQZW5kaW5nUmVxdWVzdHMrKztMKGYpJiZiLmdldChmKXx8KGY9ZC5nZXRUcnVzdGVkUmVzb3VyY2VVcmwoZikpO3ZhciBoPWEuZGVmYXVsdHMmJmEuZGVmYXVsdHMudHJhbnNmb3JtUmVzcG9uc2U7RyhoKT9oPWguZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhIT09JGJ9KTpoPT09JGImJihoPW51bGwpO3JldHVybiBhLmdldChmLHtjYWNoZTpiLHRyYW5zZm9ybVJlc3BvbnNlOmh9KVtcXFwiZmluYWxseVxcXCJdKGZ1bmN0aW9uKCl7ZS50b3RhbFBlbmRpbmdSZXF1ZXN0cy0tfSkudGhlbihmdW5jdGlvbihhKXtiLnB1dChmLFxcbmEuZGF0YSk7cmV0dXJuIGEuZGF0YX0sZnVuY3Rpb24oYSl7aWYoIWcpdGhyb3cgZWEoXFxcInRwbG9hZFxcXCIsZixhLnN0YXR1cyxhLnN0YXR1c1RleHQpO3JldHVybiBjLnJlamVjdChhKX0pfWUudG90YWxQZW5kaW5nUmVxdWVzdHM9MDtyZXR1cm4gZX1dfWZ1bmN0aW9uIHJmKCl7dGhpcy4kZ2V0PVtcXFwiJHJvb3RTY29wZVxcXCIsXFxcIiRicm93c2VyXFxcIixcXFwiJGxvY2F0aW9uXFxcIixmdW5jdGlvbihiLGEsYyl7cmV0dXJue2ZpbmRCaW5kaW5nczpmdW5jdGlvbihhLGIsYyl7YT1hLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXFxcIm5nLWJpbmRpbmdcXFwiKTt2YXIgZz1bXTttKGEsZnVuY3Rpb24oYSl7dmFyIGQ9Y2EuZWxlbWVudChhKS5kYXRhKFxcXCIkYmluZGluZ1xcXCIpO2QmJm0oZCxmdW5jdGlvbihkKXtjPyhuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXHMpXFxcIit1ZChiKStcXFwiKFxcXFxcXFxcc3xcXFxcXFxcXHx8JClcXFwiKSkudGVzdChkKSYmZy5wdXNoKGEpOi0xIT1kLmluZGV4T2YoYikmJmcucHVzaChhKX0pfSk7cmV0dXJuIGd9LGZpbmRNb2RlbHM6ZnVuY3Rpb24oYSxcXG5iLGMpe2Zvcih2YXIgZz1bXFxcIm5nLVxcXCIsXFxcImRhdGEtbmctXFxcIixcXFwibmdcXFxcXFxcXDpcXFwiXSxoPTA7aDxnLmxlbmd0aDsrK2gpe3ZhciBsPWEucXVlcnlTZWxlY3RvckFsbChcXFwiW1xcXCIrZ1toXStcXFwibW9kZWxcXFwiKyhjP1xcXCI9XFxcIjpcXFwiKj1cXFwiKSsnXFxcIicrYisnXFxcIl0nKTtpZihsLmxlbmd0aClyZXR1cm4gbH19LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGMudXJsKCl9LHNldExvY2F0aW9uOmZ1bmN0aW9uKGEpe2EhPT1jLnVybCgpJiYoYy51cmwoYSksYi4kZGlnZXN0KCkpfSx3aGVuU3RhYmxlOmZ1bmN0aW9uKGIpe2Eubm90aWZ5V2hlbk5vT3V0c3RhbmRpbmdSZXF1ZXN0cyhiKX19fV19ZnVuY3Rpb24gc2YoKXt0aGlzLiRnZXQ9W1xcXCIkcm9vdFNjb3BlXFxcIixcXFwiJGJyb3dzZXJcXFwiLFxcXCIkcVxcXCIsXFxcIiQkcVxcXCIsXFxcIiRleGNlcHRpb25IYW5kbGVyXFxcIixmdW5jdGlvbihiLGEsYyxkLGUpe2Z1bmN0aW9uIGYoZixsLGspe3ooZil8fChrPWwsbD1mLGY9dik7dmFyIG49emEuY2FsbChhcmd1bWVudHMsMykscj13KGspJiYhayxzPShyP2Q6YykuZGVmZXIoKSxcXG5tPXMucHJvbWlzZSxxO3E9YS5kZWZlcihmdW5jdGlvbigpe3RyeXtzLnJlc29sdmUoZi5hcHBseShudWxsLG4pKX1jYXRjaChhKXtzLnJlamVjdChhKSxlKGEpfWZpbmFsbHl7ZGVsZXRlIGdbbS4kJHRpbWVvdXRJZF19cnx8Yi4kYXBwbHkoKX0sbCk7bS4kJHRpbWVvdXRJZD1xO2dbcV09cztyZXR1cm4gbX12YXIgZz17fTtmLmNhbmNlbD1mdW5jdGlvbihiKXtyZXR1cm4gYiYmYi4kJHRpbWVvdXRJZCBpbiBnPyhnW2IuJCR0aW1lb3V0SWRdLnJlamVjdChcXFwiY2FuY2VsZWRcXFwiKSxkZWxldGUgZ1tiLiQkdGltZW91dElkXSxhLmRlZmVyLmNhbmNlbChiLiQkdGltZW91dElkKSk6ITF9O3JldHVybiBmfV19ZnVuY3Rpb24gQmEoYil7VWEmJihYLnNldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIsYiksYj1YLmhyZWYpO1guc2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIixiKTtyZXR1cm57aHJlZjpYLmhyZWYscHJvdG9jb2w6WC5wcm90b2NvbD9YLnByb3RvY29sLnJlcGxhY2UoLzokLyxcXFwiXFxcIik6XFxcIlxcXCIsaG9zdDpYLmhvc3QsXFxuc2VhcmNoOlguc2VhcmNoP1guc2VhcmNoLnJlcGxhY2UoL15cXFxcPy8sXFxcIlxcXCIpOlxcXCJcXFwiLGhhc2g6WC5oYXNoP1guaGFzaC5yZXBsYWNlKC9eIy8sXFxcIlxcXCIpOlxcXCJcXFwiLGhvc3RuYW1lOlguaG9zdG5hbWUscG9ydDpYLnBvcnQscGF0aG5hbWU6XFxcIi9cXFwiPT09WC5wYXRobmFtZS5jaGFyQXQoMCk/WC5wYXRobmFtZTpcXFwiL1xcXCIrWC5wYXRobmFtZX19ZnVuY3Rpb24gZ2QoYil7Yj1MKGIpP0JhKGIpOmI7cmV0dXJuIGIucHJvdG9jb2w9PT13ZC5wcm90b2NvbCYmYi5ob3N0PT09d2QuaG9zdH1mdW5jdGlvbiB0Zigpe3RoaXMuJGdldD1yYShPKX1mdW5jdGlvbiB4ZChiKXtmdW5jdGlvbiBhKGEpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGEpfWNhdGNoKGIpe3JldHVybiBhfX12YXIgYz1iWzBdfHx7fSxkPXt9LGU9XFxcIlxcXCI7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGIsZyxoLGwsaztiPWMuY29va2llfHxcXFwiXFxcIjtpZihiIT09ZSlmb3IoZT1iLGI9ZS5zcGxpdChcXFwiOyBcXFwiKSxkPXt9LGg9MDtoPGIubGVuZ3RoO2grKylnPVxcbmJbaF0sbD1nLmluZGV4T2YoXFxcIj1cXFwiKSwwPGwmJihrPWEoZy5zdWJzdHJpbmcoMCxsKSksZFtrXT09PXQmJihkW2tdPWEoZy5zdWJzdHJpbmcobCsxKSkpKTtyZXR1cm4gZH19ZnVuY3Rpb24geWYoKXt0aGlzLiRnZXQ9eGR9ZnVuY3Rpb24gTGMoYil7ZnVuY3Rpb24gYShjLGQpe2lmKEgoYykpe3ZhciBlPXt9O20oYyxmdW5jdGlvbihiLGMpe2VbY109YShjLGIpfSk7cmV0dXJuIGV9cmV0dXJuIGIuZmFjdG9yeShjK1xcXCJGaWx0ZXJcXFwiLGQpfXRoaXMucmVnaXN0ZXI9YTt0aGlzLiRnZXQ9W1xcXCIkaW5qZWN0b3JcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYS5nZXQoYitcXFwiRmlsdGVyXFxcIil9fV07YShcXFwiY3VycmVuY3lcXFwiLHlkKTthKFxcXCJkYXRlXFxcIix6ZCk7YShcXFwiZmlsdGVyXFxcIixhZyk7YShcXFwianNvblxcXCIsYmcpO2EoXFxcImxpbWl0VG9cXFwiLGNnKTthKFxcXCJsb3dlcmNhc2VcXFwiLGRnKTthKFxcXCJudW1iZXJcXFwiLEFkKTthKFxcXCJvcmRlckJ5XFxcIixCZCk7YShcXFwidXBwZXJjYXNlXFxcIixlZyl9ZnVuY3Rpb24gYWcoKXtyZXR1cm4gZnVuY3Rpb24oYixcXG5hLGMpe2lmKCFFYShiKSl7aWYobnVsbD09YilyZXR1cm4gYjt0aHJvdyBKKFxcXCJmaWx0ZXJcXFwiKShcXFwibm90YXJyYXlcXFwiLGIpO312YXIgZDtzd2l0Y2goaWMoYSkpe2Nhc2UgXFxcImZ1bmN0aW9uXFxcIjpicmVhaztjYXNlIFxcXCJib29sZWFuXFxcIjpjYXNlIFxcXCJudWxsXFxcIjpjYXNlIFxcXCJudW1iZXJcXFwiOmNhc2UgXFxcInN0cmluZ1xcXCI6ZD0hMDtjYXNlIFxcXCJvYmplY3RcXFwiOmE9ZmcoYSxjLGQpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIGJ9cmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChiLGEpfX1mdW5jdGlvbiBmZyhiLGEsYyl7dmFyIGQ9SChiKSYmXFxcIiRcXFwiaW4gYjshMD09PWE/YT1rYTp6KGEpfHwoYT1mdW5jdGlvbihhLGIpe2lmKEEoYSkpcmV0dXJuITE7aWYobnVsbD09PWF8fG51bGw9PT1iKXJldHVybiBhPT09YjtpZihIKGIpfHxIKGEpJiYhcmMoYSkpcmV0dXJuITE7YT1NKFxcXCJcXFwiK2EpO2I9TShcXFwiXFxcIitiKTtyZXR1cm4tMSE9PWEuaW5kZXhPZihiKX0pO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZCYmIUgoZSk/TGEoZSxcXG5iLiQsYSwhMSk6TGEoZSxiLGEsYyl9fWZ1bmN0aW9uIExhKGIsYSxjLGQsZSl7dmFyIGY9aWMoYiksZz1pYyhhKTtpZihcXFwic3RyaW5nXFxcIj09PWcmJlxcXCIhXFxcIj09PWEuY2hhckF0KDApKXJldHVybiFMYShiLGEuc3Vic3RyaW5nKDEpLGMsZCk7aWYoRyhiKSlyZXR1cm4gYi5zb21lKGZ1bmN0aW9uKGIpe3JldHVybiBMYShiLGEsYyxkKX0pO3N3aXRjaChmKXtjYXNlIFxcXCJvYmplY3RcXFwiOnZhciBoO2lmKGQpe2ZvcihoIGluIGIpaWYoXFxcIiRcXFwiIT09aC5jaGFyQXQoMCkmJkxhKGJbaF0sYSxjLCEwKSlyZXR1cm4hMDtyZXR1cm4gZT8hMTpMYShiLGEsYywhMSl9aWYoXFxcIm9iamVjdFxcXCI9PT1nKXtmb3IoaCBpbiBhKWlmKGU9YVtoXSwheihlKSYmIUEoZSkmJihmPVxcXCIkXFxcIj09PWgsIUxhKGY/YjpiW2hdLGUsYyxmLGYpKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gYyhiLGEpO2Nhc2UgXFxcImZ1bmN0aW9uXFxcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiBjKGIsYSl9fWZ1bmN0aW9uIGljKGIpe3JldHVybiBudWxsPT09XFxuYj9cXFwibnVsbFxcXCI6dHlwZW9mIGJ9ZnVuY3Rpb24geWQoYil7dmFyIGE9Yi5OVU1CRVJfRk9STUFUUztyZXR1cm4gZnVuY3Rpb24oYixkLGUpe0EoZCkmJihkPWEuQ1VSUkVOQ1lfU1lNKTtBKGUpJiYoZT1hLlBBVFRFUk5TWzFdLm1heEZyYWMpO3JldHVybiBudWxsPT1iP2I6Q2QoYixhLlBBVFRFUk5TWzFdLGEuR1JPVVBfU0VQLGEuREVDSU1BTF9TRVAsZSkucmVwbGFjZSgvXFxcXHUwMEE0L2csZCl9fWZ1bmN0aW9uIEFkKGIpe3ZhciBhPWIuTlVNQkVSX0ZPUk1BVFM7cmV0dXJuIGZ1bmN0aW9uKGIsZCl7cmV0dXJuIG51bGw9PWI/YjpDZChiLGEuUEFUVEVSTlNbMF0sYS5HUk9VUF9TRVAsYS5ERUNJTUFMX1NFUCxkKX19ZnVuY3Rpb24gQ2QoYixhLGMsZCxlKXtpZihIKGIpKXJldHVyblxcXCJcXFwiO3ZhciBmPTA+YjtiPU1hdGguYWJzKGIpO3ZhciBnPUluZmluaXR5PT09YjtpZighZyYmIWlzRmluaXRlKGIpKXJldHVyblxcXCJcXFwiO3ZhciBoPWIrXFxcIlxcXCIsbD1cXFwiXFxcIixrPSExLG49W107ZyYmKGw9XFxcIlxcXFx1MjIxZVxcXCIpO1xcbmlmKCFnJiYtMSE9PWguaW5kZXhPZihcXFwiZVxcXCIpKXt2YXIgcj1oLm1hdGNoKC8oW1xcXFxkXFxcXC5dKyllKC0/KShcXFxcZCspLyk7ciYmXFxcIi1cXFwiPT1yWzJdJiZyWzNdPmUrMT9iPTA6KGw9aCxrPSEwKX1pZihnfHxrKTA8ZSYmMT5iJiYobD1iLnRvRml4ZWQoZSksYj1wYXJzZUZsb2F0KGwpKTtlbHNle2c9KGguc3BsaXQoRGQpWzFdfHxcXFwiXFxcIikubGVuZ3RoO0EoZSkmJihlPU1hdGgubWluKE1hdGgubWF4KGEubWluRnJhYyxnKSxhLm1heEZyYWMpKTtiPSsoTWF0aC5yb3VuZCgrKGIudG9TdHJpbmcoKStcXFwiZVxcXCIrZSkpLnRvU3RyaW5nKCkrXFxcImVcXFwiKy1lKTt2YXIgZz0oXFxcIlxcXCIrYikuc3BsaXQoRGQpLGg9Z1swXSxnPWdbMV18fFxcXCJcXFwiLHI9MCxzPWEubGdTaXplLG09YS5nU2l6ZTtpZihoLmxlbmd0aD49cyttKWZvcihyPWgubGVuZ3RoLXMsaz0wO2s8cjtrKyspMD09PShyLWspJW0mJjAhPT1rJiYobCs9YyksbCs9aC5jaGFyQXQoayk7Zm9yKGs9cjtrPGgubGVuZ3RoO2srKykwPT09KGgubGVuZ3RoLWspJXMmJjAhPT1rJiZcXG4obCs9YyksbCs9aC5jaGFyQXQoayk7Zm9yKDtnLmxlbmd0aDxlOylnKz1cXFwiMFxcXCI7ZSYmXFxcIjBcXFwiIT09ZSYmKGwrPWQrZy5zdWJzdHIoMCxlKSl9MD09PWImJihmPSExKTtuLnB1c2goZj9hLm5lZ1ByZTphLnBvc1ByZSxsLGY/YS5uZWdTdWY6YS5wb3NTdWYpO3JldHVybiBuLmpvaW4oXFxcIlxcXCIpfWZ1bmN0aW9uIEdiKGIsYSxjKXt2YXIgZD1cXFwiXFxcIjswPmImJihkPVxcXCItXFxcIixiPS1iKTtmb3IoYj1cXFwiXFxcIitiO2IubGVuZ3RoPGE7KWI9XFxcIjBcXFwiK2I7YyYmKGI9Yi5zdWJzdHIoYi5sZW5ndGgtYSkpO3JldHVybiBkK2J9ZnVuY3Rpb24gWShiLGEsYyxkKXtjPWN8fDA7cmV0dXJuIGZ1bmN0aW9uKGUpe2U9ZVtcXFwiZ2V0XFxcIitiXSgpO2lmKDA8Y3x8ZT4tYyllKz1jOzA9PT1lJiYtMTI9PWMmJihlPTEyKTtyZXR1cm4gR2IoZSxhLGQpfX1mdW5jdGlvbiBIYihiLGEpe3JldHVybiBmdW5jdGlvbihjLGQpe3ZhciBlPWNbXFxcImdldFxcXCIrYl0oKSxmPXJiKGE/XFxcIlNIT1JUXFxcIitiOmIpO3JldHVybiBkW2ZdW2VdfX1mdW5jdGlvbiBFZChiKXt2YXIgYT1cXG4obmV3IERhdGUoYiwwLDEpKS5nZXREYXkoKTtyZXR1cm4gbmV3IERhdGUoYiwwLCg0Pj1hPzU6MTIpLWEpfWZ1bmN0aW9uIEZkKGIpe3JldHVybiBmdW5jdGlvbihhKXt2YXIgYz1FZChhLmdldEZ1bGxZZWFyKCkpO2E9K25ldyBEYXRlKGEuZ2V0RnVsbFllYXIoKSxhLmdldE1vbnRoKCksYS5nZXREYXRlKCkrKDQtYS5nZXREYXkoKSkpLStjO2E9MStNYXRoLnJvdW5kKGEvNjA0OEU1KTtyZXR1cm4gR2IoYSxiKX19ZnVuY3Rpb24gamMoYixhKXtyZXR1cm4gMD49Yi5nZXRGdWxsWWVhcigpP2EuRVJBU1swXTphLkVSQVNbMV19ZnVuY3Rpb24gemQoYil7ZnVuY3Rpb24gYShhKXt2YXIgYjtpZihiPWEubWF0Y2goYykpe2E9bmV3IERhdGUoMCk7dmFyIGY9MCxnPTAsaD1iWzhdP2Euc2V0VVRDRnVsbFllYXI6YS5zZXRGdWxsWWVhcixsPWJbOF0/YS5zZXRVVENIb3VyczphLnNldEhvdXJzO2JbOV0mJihmPVcoYls5XStiWzEwXSksZz1XKGJbOV0rYlsxMV0pKTtoLmNhbGwoYSxXKGJbMV0pLFxcblcoYlsyXSktMSxXKGJbM10pKTtmPVcoYls0XXx8MCktZjtnPVcoYls1XXx8MCktZztoPVcoYls2XXx8MCk7Yj1NYXRoLnJvdW5kKDFFMypwYXJzZUZsb2F0KFxcXCIwLlxcXCIrKGJbN118fDApKSk7bC5jYWxsKGEsZixnLGgsYil9cmV0dXJuIGF9dmFyIGM9L14oXFxcXGR7NH0pLT8oXFxcXGRcXFxcZCktPyhcXFxcZFxcXFxkKSg/OlQoXFxcXGRcXFxcZCkoPzo6PyhcXFxcZFxcXFxkKSg/Ojo/KFxcXFxkXFxcXGQpKD86XFxcXC4oXFxcXGQrKSk/KT8pPyhafChbKy1dKShcXFxcZFxcXFxkKTo/KFxcXFxkXFxcXGQpKT8pPyQvO3JldHVybiBmdW5jdGlvbihjLGUsZil7dmFyIGc9XFxcIlxcXCIsaD1bXSxsLGs7ZT1lfHxcXFwibWVkaXVtRGF0ZVxcXCI7ZT1iLkRBVEVUSU1FX0ZPUk1BVFNbZV18fGU7TChjKSYmKGM9Z2cudGVzdChjKT9XKGMpOmEoYykpO1YoYykmJihjPW5ldyBEYXRlKGMpKTtpZighYWEoYyl8fCFpc0Zpbml0ZShjLmdldFRpbWUoKSkpcmV0dXJuIGM7Zm9yKDtlOykoaz1oZy5leGVjKGUpKT8oaD1jYihoLGssMSksZT1oLnBvcCgpKTooaC5wdXNoKGUpLGU9bnVsbCk7dmFyIG49Yy5nZXRUaW1lem9uZU9mZnNldCgpO1xcbmYmJihuPXhjKGYsYy5nZXRUaW1lem9uZU9mZnNldCgpKSxjPVBiKGMsZiwhMCkpO20oaCxmdW5jdGlvbihhKXtsPWlnW2FdO2crPWw/bChjLGIuREFURVRJTUVfRk9STUFUUyxuKTphLnJlcGxhY2UoLyheJ3wnJCkvZyxcXFwiXFxcIikucmVwbGFjZSgvJycvZyxcXFwiJ1xcXCIpfSk7cmV0dXJuIGd9fWZ1bmN0aW9uIGJnKCl7cmV0dXJuIGZ1bmN0aW9uKGIsYSl7QShhKSYmKGE9Mik7cmV0dXJuIGRiKGIsYSl9fWZ1bmN0aW9uIGNnKCl7cmV0dXJuIGZ1bmN0aW9uKGIsYSxjKXthPUluZmluaXR5PT09TWF0aC5hYnMoTnVtYmVyKGEpKT9OdW1iZXIoYSk6VyhhKTtpZihpc05hTihhKSlyZXR1cm4gYjtWKGIpJiYoYj1iLnRvU3RyaW5nKCkpO2lmKCFHKGIpJiYhTChiKSlyZXR1cm4gYjtjPSFjfHxpc05hTihjKT8wOlcoYyk7Yz0wPmMmJmM+PS1iLmxlbmd0aD9iLmxlbmd0aCtjOmM7cmV0dXJuIDA8PWE/Yi5zbGljZShjLGMrYSk6MD09PWM/Yi5zbGljZShhLGIubGVuZ3RoKTpiLnNsaWNlKE1hdGgubWF4KDAsXFxuYythKSxjKX19ZnVuY3Rpb24gQmQoYil7ZnVuY3Rpb24gYShhLGMpe2M9Yz8tMToxO3JldHVybiBhLm1hcChmdW5jdGlvbihhKXt2YXIgZD0xLGg9WWE7aWYoeihhKSloPWE7ZWxzZSBpZihMKGEpKXtpZihcXFwiK1xcXCI9PWEuY2hhckF0KDApfHxcXFwiLVxcXCI9PWEuY2hhckF0KDApKWQ9XFxcIi1cXFwiPT1hLmNoYXJBdCgwKT8tMToxLGE9YS5zdWJzdHJpbmcoMSk7aWYoXFxcIlxcXCIhPT1hJiYoaD1iKGEpLGguY29uc3RhbnQpKXZhciBsPWgoKSxoPWZ1bmN0aW9uKGEpe3JldHVybiBhW2xdfX1yZXR1cm57Z2V0OmgsZGVzY2VuZGluZzpkKmN9fSl9ZnVuY3Rpb24gYyhhKXtzd2l0Y2godHlwZW9mIGEpe2Nhc2UgXFxcIm51bWJlclxcXCI6Y2FzZSBcXFwiYm9vbGVhblxcXCI6Y2FzZSBcXFwic3RyaW5nXFxcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1yZXR1cm4gZnVuY3Rpb24oYixlLGYpe2lmKCFFYShiKSlyZXR1cm4gYjtHKGUpfHwoZT1bZV0pOzA9PT1lLmxlbmd0aCYmKGU9W1xcXCIrXFxcIl0pO3ZhciBnPWEoZSxmKTtiPUFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChiLFxcbmZ1bmN0aW9uKGEsYil7cmV0dXJue3ZhbHVlOmEscHJlZGljYXRlVmFsdWVzOmcubWFwKGZ1bmN0aW9uKGQpe3ZhciBlPWQuZ2V0KGEpO2Q9dHlwZW9mIGU7aWYobnVsbD09PWUpZD1cXFwic3RyaW5nXFxcIixlPVxcXCJudWxsXFxcIjtlbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT09ZCllPWUudG9Mb3dlckNhc2UoKTtlbHNlIGlmKFxcXCJvYmplY3RcXFwiPT09ZClhOntpZihcXFwiZnVuY3Rpb25cXFwiPT09dHlwZW9mIGUudmFsdWVPZiYmKGU9ZS52YWx1ZU9mKCksYyhlKSkpYnJlYWsgYTtpZihyYyhlKSYmKGU9ZS50b1N0cmluZygpLGMoZSkpKWJyZWFrIGE7ZT1ifXJldHVybnt2YWx1ZTplLHR5cGU6ZH19KX19KTtiLnNvcnQoZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MCxkPTAsZT1nLmxlbmd0aDtkPGU7KytkKXt2YXIgYz1hLnByZWRpY2F0ZVZhbHVlc1tkXSxmPWIucHJlZGljYXRlVmFsdWVzW2RdLG09MDtjLnR5cGU9PT1mLnR5cGU/Yy52YWx1ZSE9PWYudmFsdWUmJihtPWMudmFsdWU8Zi52YWx1ZT8tMToxKTptPWMudHlwZTxmLnR5cGU/XFxuLTE6MTtpZihjPW0qZ1tkXS5kZXNjZW5kaW5nKWJyZWFrfXJldHVybiBjfSk7cmV0dXJuIGI9Yi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWV9KX19ZnVuY3Rpb24gTWEoYil7eihiKSYmKGI9e2xpbms6Yn0pO2IucmVzdHJpY3Q9Yi5yZXN0cmljdHx8XFxcIkFDXFxcIjtyZXR1cm4gcmEoYil9ZnVuY3Rpb24gR2QoYixhLGMsZCxlKXt2YXIgZj10aGlzLGc9W10saD1mLiQkcGFyZW50Rm9ybT1iLnBhcmVudCgpLmNvbnRyb2xsZXIoXFxcImZvcm1cXFwiKXx8SWI7Zi4kZXJyb3I9e307Zi4kJHN1Y2Nlc3M9e307Zi4kcGVuZGluZz10O2YuJG5hbWU9ZShhLm5hbWV8fGEubmdGb3JtfHxcXFwiXFxcIikoYyk7Zi4kZGlydHk9ITE7Zi4kcHJpc3RpbmU9ITA7Zi4kdmFsaWQ9ITA7Zi4kaW52YWxpZD0hMTtmLiRzdWJtaXR0ZWQ9ITE7aC4kYWRkQ29udHJvbChmKTtmLiRyb2xsYmFja1ZpZXdWYWx1ZT1mdW5jdGlvbigpe20oZyxmdW5jdGlvbihhKXthLiRyb2xsYmFja1ZpZXdWYWx1ZSgpfSl9O2YuJGNvbW1pdFZpZXdWYWx1ZT1cXG5mdW5jdGlvbigpe20oZyxmdW5jdGlvbihhKXthLiRjb21taXRWaWV3VmFsdWUoKX0pfTtmLiRhZGRDb250cm9sPWZ1bmN0aW9uKGEpe1JhKGEuJG5hbWUsXFxcImlucHV0XFxcIik7Zy5wdXNoKGEpO2EuJG5hbWUmJihmW2EuJG5hbWVdPWEpfTtmLiQkcmVuYW1lQ29udHJvbD1mdW5jdGlvbihhLGIpe3ZhciBjPWEuJG5hbWU7ZltjXT09PWEmJmRlbGV0ZSBmW2NdO2ZbYl09YTthLiRuYW1lPWJ9O2YuJHJlbW92ZUNvbnRyb2w9ZnVuY3Rpb24oYSl7YS4kbmFtZSYmZlthLiRuYW1lXT09PWEmJmRlbGV0ZSBmW2EuJG5hbWVdO20oZi4kcGVuZGluZyxmdW5jdGlvbihiLGMpe2YuJHNldFZhbGlkaXR5KGMsbnVsbCxhKX0pO20oZi4kZXJyb3IsZnVuY3Rpb24oYixjKXtmLiRzZXRWYWxpZGl0eShjLG51bGwsYSl9KTttKGYuJCRzdWNjZXNzLGZ1bmN0aW9uKGIsYyl7Zi4kc2V0VmFsaWRpdHkoYyxudWxsLGEpfSk7YmIoZyxhKX07SGQoe2N0cmw6dGhpcywkZWxlbWVudDpiLHNldDpmdW5jdGlvbihhLGIsXFxuYyl7dmFyIGQ9YVtiXTtkPy0xPT09ZC5pbmRleE9mKGMpJiZkLnB1c2goYyk6YVtiXT1bY119LHVuc2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hW2JdO2QmJihiYihkLGMpLDA9PT1kLmxlbmd0aCYmZGVsZXRlIGFbYl0pfSxwYXJlbnRGb3JtOmgsJGFuaW1hdGU6ZH0pO2YuJHNldERpcnR5PWZ1bmN0aW9uKCl7ZC5yZW1vdmVDbGFzcyhiLFZhKTtkLmFkZENsYXNzKGIsSmIpO2YuJGRpcnR5PSEwO2YuJHByaXN0aW5lPSExO2guJHNldERpcnR5KCl9O2YuJHNldFByaXN0aW5lPWZ1bmN0aW9uKCl7ZC5zZXRDbGFzcyhiLFZhLEpiK1xcXCIgbmctc3VibWl0dGVkXFxcIik7Zi4kZGlydHk9ITE7Zi4kcHJpc3RpbmU9ITA7Zi4kc3VibWl0dGVkPSExO20oZyxmdW5jdGlvbihhKXthLiRzZXRQcmlzdGluZSgpfSl9O2YuJHNldFVudG91Y2hlZD1mdW5jdGlvbigpe20oZyxmdW5jdGlvbihhKXthLiRzZXRVbnRvdWNoZWQoKX0pfTtmLiRzZXRTdWJtaXR0ZWQ9ZnVuY3Rpb24oKXtkLmFkZENsYXNzKGIsXFxuXFxcIm5nLXN1Ym1pdHRlZFxcXCIpO2YuJHN1Ym1pdHRlZD0hMDtoLiRzZXRTdWJtaXR0ZWQoKX19ZnVuY3Rpb24ga2MoYil7Yi4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGEpe3JldHVybiBiLiRpc0VtcHR5KGEpP2E6YS50b1N0cmluZygpfSl9ZnVuY3Rpb24ga2IoYixhLGMsZCxlLGYpe3ZhciBnPU0oYVswXS50eXBlKTtpZighZS5hbmRyb2lkKXt2YXIgaD0hMTthLm9uKFxcXCJjb21wb3NpdGlvbnN0YXJ0XFxcIixmdW5jdGlvbihhKXtoPSEwfSk7YS5vbihcXFwiY29tcG9zaXRpb25lbmRcXFwiLGZ1bmN0aW9uKCl7aD0hMTtsKCl9KX12YXIgbD1mdW5jdGlvbihiKXtrJiYoZi5kZWZlci5jYW5jZWwoayksaz1udWxsKTtpZighaCl7dmFyIGU9YS52YWwoKTtiPWImJmIudHlwZTtcXFwicGFzc3dvcmRcXFwiPT09Z3x8Yy5uZ1RyaW0mJlxcXCJmYWxzZVxcXCI9PT1jLm5nVHJpbXx8KGU9UihlKSk7KGQuJHZpZXdWYWx1ZSE9PWV8fFxcXCJcXFwiPT09ZSYmZC4kJGhhc05hdGl2ZVZhbGlkYXRvcnMpJiZkLiRzZXRWaWV3VmFsdWUoZSxiKX19O1xcbmlmKGUuaGFzRXZlbnQoXFxcImlucHV0XFxcIikpYS5vbihcXFwiaW5wdXRcXFwiLGwpO2Vsc2V7dmFyIGssbj1mdW5jdGlvbihhLGIsYyl7a3x8KGs9Zi5kZWZlcihmdW5jdGlvbigpe2s9bnVsbDtiJiZiLnZhbHVlPT09Y3x8bChhKX0pKX07YS5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYSl7dmFyIGI9YS5rZXlDb2RlOzkxPT09Ynx8MTU8YiYmMTk+Ynx8Mzc8PWImJjQwPj1ifHxuKGEsdGhpcyx0aGlzLnZhbHVlKX0pO2lmKGUuaGFzRXZlbnQoXFxcInBhc3RlXFxcIikpYS5vbihcXFwicGFzdGUgY3V0XFxcIixuKX1hLm9uKFxcXCJjaGFuZ2VcXFwiLGwpO2QuJHJlbmRlcj1mdW5jdGlvbigpe2EudmFsKGQuJGlzRW1wdHkoZC4kdmlld1ZhbHVlKT9cXFwiXFxcIjpkLiR2aWV3VmFsdWUpfX1mdW5jdGlvbiBLYihiLGEpe3JldHVybiBmdW5jdGlvbihjLGQpe3ZhciBlLGY7aWYoYWEoYykpcmV0dXJuIGM7aWYoTChjKSl7J1xcXCInPT1jLmNoYXJBdCgwKSYmJ1xcXCInPT1jLmNoYXJBdChjLmxlbmd0aC0xKSYmKGM9Yy5zdWJzdHJpbmcoMSxjLmxlbmd0aC0xKSk7XFxuaWYoamcudGVzdChjKSlyZXR1cm4gbmV3IERhdGUoYyk7Yi5sYXN0SW5kZXg9MDtpZihlPWIuZXhlYyhjKSlyZXR1cm4gZS5zaGlmdCgpLGY9ZD97eXl5eTpkLmdldEZ1bGxZZWFyKCksTU06ZC5nZXRNb250aCgpKzEsZGQ6ZC5nZXREYXRlKCksSEg6ZC5nZXRIb3VycygpLG1tOmQuZ2V0TWludXRlcygpLHNzOmQuZ2V0U2Vjb25kcygpLHNzczpkLmdldE1pbGxpc2Vjb25kcygpLzFFM306e3l5eXk6MTk3MCxNTToxLGRkOjEsSEg6MCxtbTowLHNzOjAsc3NzOjB9LG0oZSxmdW5jdGlvbihiLGMpe2M8YS5sZW5ndGgmJihmW2FbY11dPStiKX0pLG5ldyBEYXRlKGYueXl5eSxmLk1NLTEsZi5kZCxmLkhILGYubW0sZi5zc3x8MCwxRTMqZi5zc3N8fDApfXJldHVybiBOYU59fWZ1bmN0aW9uIGxiKGIsYSxjLGQpe3JldHVybiBmdW5jdGlvbihlLGYsZyxoLGwsayxuKXtmdW5jdGlvbiByKGEpe3JldHVybiBhJiYhKGEuZ2V0VGltZSYmYS5nZXRUaW1lKCkhPT1hLmdldFRpbWUoKSl9ZnVuY3Rpb24gcyhhKXtyZXR1cm4gdyhhKT9cXG5hYShhKT9hOmMoYSk6dH1JZChlLGYsZyxoKTtrYihlLGYsZyxoLGwsayk7dmFyIG09aCYmaC4kb3B0aW9ucyYmaC4kb3B0aW9ucy50aW1lem9uZSxxO2guJCRwYXJzZXJOYW1lPWI7aC4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKGIpe3JldHVybiBoLiRpc0VtcHR5KGIpP251bGw6YS50ZXN0KGIpPyhiPWMoYixxKSxtJiYoYj1QYihiLG0pKSxiKTp0fSk7aC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGEpe2lmKGEmJiFhYShhKSl0aHJvdyBMYihcXFwiZGF0ZWZtdFxcXCIsYSk7aWYocihhKSlyZXR1cm4ocT1hKSYmbSYmKHE9UGIocSxtLCEwKSksbihcXFwiZGF0ZVxcXCIpKGEsZCxtKTtxPW51bGw7cmV0dXJuXFxcIlxcXCJ9KTtpZih3KGcubWluKXx8Zy5uZ01pbil7dmFyIEY7aC4kdmFsaWRhdG9ycy5taW49ZnVuY3Rpb24oYSl7cmV0dXJuIXIoYSl8fEEoRil8fGMoYSk+PUZ9O2cuJG9ic2VydmUoXFxcIm1pblxcXCIsZnVuY3Rpb24oYSl7Rj1zKGEpO2guJHZhbGlkYXRlKCl9KX1pZih3KGcubWF4KXx8Zy5uZ01heCl7dmFyIHU7XFxuaC4kdmFsaWRhdG9ycy5tYXg9ZnVuY3Rpb24oYSl7cmV0dXJuIXIoYSl8fEEodSl8fGMoYSk8PXV9O2cuJG9ic2VydmUoXFxcIm1heFxcXCIsZnVuY3Rpb24oYSl7dT1zKGEpO2guJHZhbGlkYXRlKCl9KX19fWZ1bmN0aW9uIElkKGIsYSxjLGQpeyhkLiQkaGFzTmF0aXZlVmFsaWRhdG9ycz1IKGFbMF0udmFsaWRpdHkpKSYmZC4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKGIpe3ZhciBjPWEucHJvcChcXFwidmFsaWRpdHlcXFwiKXx8e307cmV0dXJuIGMuYmFkSW5wdXQmJiFjLnR5cGVNaXNtYXRjaD90OmJ9KX1mdW5jdGlvbiBKZChiLGEsYyxkLGUpe2lmKHcoZCkpe2I9YihkKTtpZighYi5jb25zdGFudCl0aHJvdyBKKFxcXCJuZ01vZGVsXFxcIikoXFxcImNvbnN0ZXhwclxcXCIsYyxkKTtyZXR1cm4gYihhKX1yZXR1cm4gZX1mdW5jdGlvbiBsYyhiLGEpe2I9XFxcIm5nQ2xhc3NcXFwiK2I7cmV0dXJuW1xcXCIkYW5pbWF0ZVxcXCIsZnVuY3Rpb24oYyl7ZnVuY3Rpb24gZChhLGIpe3ZhciBjPVtdLGQ9MDthOmZvcig7ZDxhLmxlbmd0aDtkKyspe2Zvcih2YXIgZT1cXG5hW2RdLG49MDtuPGIubGVuZ3RoO24rKylpZihlPT1iW25dKWNvbnRpbnVlIGE7Yy5wdXNoKGUpfXJldHVybiBjfWZ1bmN0aW9uIGUoYSl7dmFyIGI9W107cmV0dXJuIEcoYSk/KG0oYSxmdW5jdGlvbihhKXtiPWIuY29uY2F0KGUoYSkpfSksYik6TChhKT9hLnNwbGl0KFxcXCIgXFxcIik6SChhKT8obShhLGZ1bmN0aW9uKGEsYyl7YSYmKGI9Yi5jb25jYXQoYy5zcGxpdChcXFwiIFxcXCIpKSl9KSxiKTphfXJldHVybntyZXN0cmljdDpcXFwiQUNcXFwiLGxpbms6ZnVuY3Rpb24oZixnLGgpe2Z1bmN0aW9uIGwoYSxiKXt2YXIgYz1nLmRhdGEoXFxcIiRjbGFzc0NvdW50c1xcXCIpfHxnYSgpLGQ9W107bShhLGZ1bmN0aW9uKGEpe2lmKDA8Ynx8Y1thXSljW2FdPShjW2FdfHwwKStiLGNbYV09PT0rKDA8YikmJmQucHVzaChhKX0pO2cuZGF0YShcXFwiJGNsYXNzQ291bnRzXFxcIixjKTtyZXR1cm4gZC5qb2luKFxcXCIgXFxcIil9ZnVuY3Rpb24gayhiKXtpZighMD09PWF8fGYuJGluZGV4JTI9PT1hKXt2YXIgaz1lKGJ8fFtdKTtpZighbil7dmFyIG09XFxubChrLDEpO2guJGFkZENsYXNzKG0pfWVsc2UgaWYoIWthKGIsbikpe3ZhciBxPWUobiksbT1kKGsscSksaz1kKHEsayksbT1sKG0sMSksaz1sKGssLTEpO20mJm0ubGVuZ3RoJiZjLmFkZENsYXNzKGcsbSk7ayYmay5sZW5ndGgmJmMucmVtb3ZlQ2xhc3MoZyxrKX19bj1pYShiKX12YXIgbjtmLiR3YXRjaChoW2JdLGssITApO2guJG9ic2VydmUoXFxcImNsYXNzXFxcIixmdW5jdGlvbihhKXtrKGYuJGV2YWwoaFtiXSkpfSk7XFxcIm5nQ2xhc3NcXFwiIT09YiYmZi4kd2F0Y2goXFxcIiRpbmRleFxcXCIsZnVuY3Rpb24oYyxkKXt2YXIgZz1jJjE7aWYoZyE9PShkJjEpKXt2YXIgaz1lKGYuJGV2YWwoaFtiXSkpO2c9PT1hPyhnPWwoaywxKSxoLiRhZGRDbGFzcyhnKSk6KGc9bChrLC0xKSxoLiRyZW1vdmVDbGFzcyhnKSl9fSl9fX1dfWZ1bmN0aW9uIEhkKGIpe2Z1bmN0aW9uIGEoYSxiKXtiJiYhZlthXT8oay5hZGRDbGFzcyhlLGEpLGZbYV09ITApOiFiJiZmW2FdJiYoay5yZW1vdmVDbGFzcyhlLGEpLGZbYV09ITEpfVxcbmZ1bmN0aW9uIGMoYixjKXtiPWI/XFxcIi1cXFwiK0JjKGIsXFxcIi1cXFwiKTpcXFwiXFxcIjthKG1iK2IsITA9PT1jKTthKEtkK2IsITE9PT1jKX12YXIgZD1iLmN0cmwsZT1iLiRlbGVtZW50LGY9e30sZz1iLnNldCxoPWIudW5zZXQsbD1iLnBhcmVudEZvcm0saz1iLiRhbmltYXRlO2ZbS2RdPSEoZlttYl09ZS5oYXNDbGFzcyhtYikpO2QuJHNldFZhbGlkaXR5PWZ1bmN0aW9uKGIsZSxmKXtlPT09dD8oZC4kcGVuZGluZ3x8KGQuJHBlbmRpbmc9e30pLGcoZC4kcGVuZGluZyxiLGYpKTooZC4kcGVuZGluZyYmaChkLiRwZW5kaW5nLGIsZiksTGQoZC4kcGVuZGluZykmJihkLiRwZW5kaW5nPXQpKTthYihlKT9lPyhoKGQuJGVycm9yLGIsZiksZyhkLiQkc3VjY2VzcyxiLGYpKTooZyhkLiRlcnJvcixiLGYpLGgoZC4kJHN1Y2Nlc3MsYixmKSk6KGgoZC4kZXJyb3IsYixmKSxoKGQuJCRzdWNjZXNzLGIsZikpO2QuJHBlbmRpbmc/KGEoTWQsITApLGQuJHZhbGlkPWQuJGludmFsaWQ9dCxjKFxcXCJcXFwiLG51bGwpKTooYShNZCxcXG4hMSksZC4kdmFsaWQ9TGQoZC4kZXJyb3IpLGQuJGludmFsaWQ9IWQuJHZhbGlkLGMoXFxcIlxcXCIsZC4kdmFsaWQpKTtlPWQuJHBlbmRpbmcmJmQuJHBlbmRpbmdbYl0/dDpkLiRlcnJvcltiXT8hMTpkLiQkc3VjY2Vzc1tiXT8hMDpudWxsO2MoYixlKTtsLiRzZXRWYWxpZGl0eShiLGUsZCl9fWZ1bmN0aW9uIExkKGIpe2lmKGIpZm9yKHZhciBhIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShhKSlyZXR1cm4hMTtyZXR1cm4hMH12YXIga2c9L15cXFxcLyguKylcXFxcLyhbYS16XSopJC8sTT1mdW5jdGlvbihiKXtyZXR1cm4gTChiKT9iLnRvTG93ZXJDYXNlKCk6Yn0sWGE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxyYj1mdW5jdGlvbihiKXtyZXR1cm4gTChiKT9iLnRvVXBwZXJDYXNlKCk6Yn0sVWEseSxsYSx6YT1bXS5zbGljZSxOZj1bXS5zcGxpY2UsbGc9W10ucHVzaCxzYT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLHNjPU9iamVjdC5nZXRQcm90b3R5cGVPZixGYT1KKFxcXCJuZ1xcXCIpLGNhPVxcbk8uYW5ndWxhcnx8KE8uYW5ndWxhcj17fSksZ2IsbmI9MDtVYT1VLmRvY3VtZW50TW9kZTt2LiRpbmplY3Q9W107WWEuJGluamVjdD1bXTt2YXIgRz1BcnJheS5pc0FycmF5LHVjPS9eXFxcXFtvYmplY3QgKFVpbnQ4KENsYW1wZWQpPyl8KFVpbnQxNil8KFVpbnQzMil8KEludDgpfChJbnQxNil8KEludDMyKXwoRmxvYXQoMzIpfCg2NCkpQXJyYXlcXFxcXSQvLFI9ZnVuY3Rpb24oYil7cmV0dXJuIEwoYik/Yi50cmltKCk6Yn0sdWQ9ZnVuY3Rpb24oYil7cmV0dXJuIGIucmVwbGFjZSgvKFstKClcXFxcW1xcXFxde30rPyouJFxcXFxefCw6IzwhXFxcXFxcXFxdKS9nLFxcXCJcXFxcXFxcXCQxXFxcIikucmVwbGFjZSgvXFxcXHgwOC9nLFxcXCJcXFxcXFxcXHgwOFxcXCIpfSxmYj1mdW5jdGlvbigpe2lmKHcoZmIuaXNBY3RpdmVfKSlyZXR1cm4gZmIuaXNBY3RpdmVfO3ZhciBiPSEoIVUucXVlcnlTZWxlY3RvcihcXFwiW25nLWNzcF1cXFwiKSYmIVUucXVlcnlTZWxlY3RvcihcXFwiW2RhdGEtbmctY3NwXVxcXCIpKTtpZighYil0cnl7bmV3IEZ1bmN0aW9uKFxcXCJcXFwiKX1jYXRjaChhKXtiPSEwfXJldHVybiBmYi5pc0FjdGl2ZV89XFxuYn0scGI9ZnVuY3Rpb24oKXtpZih3KHBiLm5hbWVfKSlyZXR1cm4gcGIubmFtZV87dmFyIGIsYSxjPU9hLmxlbmd0aCxkLGU7Zm9yKGE9MDthPGM7KythKWlmKGQ9T2FbYV0sYj1VLnF1ZXJ5U2VsZWN0b3IoXFxcIltcXFwiK2QucmVwbGFjZShcXFwiOlxcXCIsXFxcIlxcXFxcXFxcOlxcXCIpK1xcXCJqcV1cXFwiKSl7ZT1iLmdldEF0dHJpYnV0ZShkK1xcXCJqcVxcXCIpO2JyZWFrfXJldHVybiBwYi5uYW1lXz1lfSxPYT1bXFxcIm5nLVxcXCIsXFxcImRhdGEtbmctXFxcIixcXFwibmc6XFxcIixcXFwieC1uZy1cXFwiXSxiZT0vW0EtWl0vZyxDYz0hMSxSYixxYT0xLE5hPTMsZmU9e2Z1bGw6XFxcIjEuNC4yXFxcIixtYWpvcjoxLG1pbm9yOjQsZG90OjIsY29kZU5hbWU6XFxcIm5lYnVsYXItcmVhZGp1c3RtZW50XFxcIn07US5leHBhbmRvPVxcXCJuZzMzOVxcXCI7dmFyIGliPVEuY2FjaGU9e30sRWY9MTtRLl9kYXRhPWZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLmNhY2hlW2JbdGhpcy5leHBhbmRvXV18fHt9fTt2YXIgemY9LyhbXFxcXDpcXFxcLVxcXFxfXSsoLikpL2csQWY9L15tb3ooW0EtWl0pLyxtZz17bW91c2VsZWF2ZTpcXFwibW91c2VvdXRcXFwiLFxcbm1vdXNlZW50ZXI6XFxcIm1vdXNlb3ZlclxcXCJ9LFViPUooXFxcImpxTGl0ZVxcXCIpLERmPS9ePChcXFxcdyspXFxcXHMqXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC8sVGI9Lzx8JiM/XFxcXHcrOy8sQmY9LzwoW1xcXFx3Ol0rKS8sQ2Y9LzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Ol0rKVtePl0qKVxcXFwvPi9naSxuYT17b3B0aW9uOlsxLCc8c2VsZWN0IG11bHRpcGxlPVxcXCJtdWx0aXBsZVxcXCI+JyxcXFwiPC9zZWxlY3Q+XFxcIl0sdGhlYWQ6WzEsXFxcIjx0YWJsZT5cXFwiLFxcXCI8L3RhYmxlPlxcXCJdLGNvbDpbMixcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLFxcXCI8L2NvbGdyb3VwPjwvdGFibGU+XFxcIl0sdHI6WzIsXFxcIjx0YWJsZT48dGJvZHk+XFxcIixcXFwiPC90Ym9keT48L3RhYmxlPlxcXCJdLHRkOlszLFxcXCI8dGFibGU+PHRib2R5Pjx0cj5cXFwiLFxcXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cXFwiXSxfZGVmYXVsdDpbMCxcXFwiXFxcIixcXFwiXFxcIl19O25hLm9wdGdyb3VwPW5hLm9wdGlvbjtuYS50Ym9keT1uYS50Zm9vdD1uYS5jb2xncm91cD1uYS5jYXB0aW9uPW5hLnRoZWFkO1xcbm5hLnRoPW5hLnRkO3ZhciBQYT1RLnByb3RvdHlwZT17cmVhZHk6ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYSgpe2N8fChjPSEwLGIoKSl9dmFyIGM9ITE7XFxcImNvbXBsZXRlXFxcIj09PVUucmVhZHlTdGF0ZT9zZXRUaW1lb3V0KGEpOih0aGlzLm9uKFxcXCJET01Db250ZW50TG9hZGVkXFxcIixhKSxRKE8pLm9uKFxcXCJsb2FkXFxcIixhKSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIGI9W107bSh0aGlzLGZ1bmN0aW9uKGEpe2IucHVzaChcXFwiXFxcIithKX0pO3JldHVyblxcXCJbXFxcIitiLmpvaW4oXFxcIiwgXFxcIikrXFxcIl1cXFwifSxlcTpmdW5jdGlvbihiKXtyZXR1cm4gMDw9Yj95KHRoaXNbYl0pOnkodGhpc1t0aGlzLmxlbmd0aCtiXSl9LGxlbmd0aDowLHB1c2g6bGcsc29ydDpbXS5zb3J0LHNwbGljZTpbXS5zcGxpY2V9LEFiPXt9O20oXFxcIm11bHRpcGxlIHNlbGVjdGVkIGNoZWNrZWQgZGlzYWJsZWQgcmVhZE9ubHkgcmVxdWlyZWQgb3BlblxcXCIuc3BsaXQoXFxcIiBcXFwiKSxmdW5jdGlvbihiKXtBYltNKGIpXT1ifSk7dmFyIFRjPXt9O20oXFxcImlucHV0IHNlbGVjdCBvcHRpb24gdGV4dGFyZWEgYnV0dG9uIGZvcm0gZGV0YWlsc1xcXCIuc3BsaXQoXFxcIiBcXFwiKSxcXG5mdW5jdGlvbihiKXtUY1tiXT0hMH0pO3ZhciBVYz17bmdNaW5sZW5ndGg6XFxcIm1pbmxlbmd0aFxcXCIsbmdNYXhsZW5ndGg6XFxcIm1heGxlbmd0aFxcXCIsbmdNaW46XFxcIm1pblxcXCIsbmdNYXg6XFxcIm1heFxcXCIsbmdQYXR0ZXJuOlxcXCJwYXR0ZXJuXFxcIn07bSh7ZGF0YTpXYixyZW1vdmVEYXRhOnViLGhhc0RhdGE6ZnVuY3Rpb24oYil7Zm9yKHZhciBhIGluIGliW2IubmczMzldKXJldHVybiEwO3JldHVybiExfX0sZnVuY3Rpb24oYixhKXtRW2FdPWJ9KTttKHtkYXRhOldiLGluaGVyaXRlZERhdGE6emIsc2NvcGU6ZnVuY3Rpb24oYil7cmV0dXJuIHkuZGF0YShiLFxcXCIkc2NvcGVcXFwiKXx8emIoYi5wYXJlbnROb2RlfHxiLFtcXFwiJGlzb2xhdGVTY29wZVxcXCIsXFxcIiRzY29wZVxcXCJdKX0saXNvbGF0ZVNjb3BlOmZ1bmN0aW9uKGIpe3JldHVybiB5LmRhdGEoYixcXFwiJGlzb2xhdGVTY29wZVxcXCIpfHx5LmRhdGEoYixcXFwiJGlzb2xhdGVTY29wZU5vVGVtcGxhdGVcXFwiKX0sY29udHJvbGxlcjpRYyxpbmplY3RvcjpmdW5jdGlvbihiKXtyZXR1cm4gemIoYixcXG5cXFwiJGluamVjdG9yXFxcIil9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYixhKXtiLnJlbW92ZUF0dHJpYnV0ZShhKX0saGFzQ2xhc3M6d2IsY3NzOmZ1bmN0aW9uKGIsYSxjKXthPWhiKGEpO2lmKHcoYykpYi5zdHlsZVthXT1jO2Vsc2UgcmV0dXJuIGIuc3R5bGVbYV19LGF0dHI6ZnVuY3Rpb24oYixhLGMpe3ZhciBkPWIubm9kZVR5cGU7aWYoZCE9PU5hJiYyIT09ZCYmOCE9PWQpaWYoZD1NKGEpLEFiW2RdKWlmKHcoYykpYz8oYlthXT0hMCxiLnNldEF0dHJpYnV0ZShhLGQpKTooYlthXT0hMSxiLnJlbW92ZUF0dHJpYnV0ZShkKSk7ZWxzZSByZXR1cm4gYlthXXx8KGIuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oYSl8fHYpLnNwZWNpZmllZD9kOnQ7ZWxzZSBpZih3KGMpKWIuc2V0QXR0cmlidXRlKGEsYyk7ZWxzZSBpZihiLmdldEF0dHJpYnV0ZSlyZXR1cm4gYj1iLmdldEF0dHJpYnV0ZShhLDIpLG51bGw9PT1iP3Q6Yn0scHJvcDpmdW5jdGlvbihiLGEsYyl7aWYodyhjKSliW2FdPWM7ZWxzZSByZXR1cm4gYlthXX0sXFxudGV4dDpmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxiKXtpZihBKGIpKXt2YXIgZD1hLm5vZGVUeXBlO3JldHVybiBkPT09cWF8fGQ9PT1OYT9hLnRleHRDb250ZW50OlxcXCJcXFwifWEudGV4dENvbnRlbnQ9Yn1iLiRkdj1cXFwiXFxcIjtyZXR1cm4gYn0oKSx2YWw6ZnVuY3Rpb24oYixhKXtpZihBKGEpKXtpZihiLm11bHRpcGxlJiZcXFwic2VsZWN0XFxcIj09PXRhKGIpKXt2YXIgYz1bXTttKGIub3B0aW9ucyxmdW5jdGlvbihhKXthLnNlbGVjdGVkJiZjLnB1c2goYS52YWx1ZXx8YS50ZXh0KX0pO3JldHVybiAwPT09Yy5sZW5ndGg/bnVsbDpjfXJldHVybiBiLnZhbHVlfWIudmFsdWU9YX0saHRtbDpmdW5jdGlvbihiLGEpe2lmKEEoYSkpcmV0dXJuIGIuaW5uZXJIVE1MO3RiKGIsITApO2IuaW5uZXJIVE1MPWF9LGVtcHR5OlJjfSxmdW5jdGlvbihiLGEpe1EucHJvdG90eXBlW2FdPWZ1bmN0aW9uKGEsZCl7dmFyIGUsZixnPXRoaXMubGVuZ3RoO2lmKGIhPT1SYyYmKDI9PWIubGVuZ3RoJiZiIT09d2ImJmIhPT1RYz9cXG5hOmQpPT09dCl7aWYoSChhKSl7Zm9yKGU9MDtlPGc7ZSsrKWlmKGI9PT1XYiliKHRoaXNbZV0sYSk7ZWxzZSBmb3IoZiBpbiBhKWIodGhpc1tlXSxmLGFbZl0pO3JldHVybiB0aGlzfWU9Yi4kZHY7Zz1lPT09dD9NYXRoLm1pbihnLDEpOmc7Zm9yKGY9MDtmPGc7ZisrKXt2YXIgaD1iKHRoaXNbZl0sYSxkKTtlPWU/ZStoOmh9cmV0dXJuIGV9Zm9yKGU9MDtlPGc7ZSsrKWIodGhpc1tlXSxhLGQpO3JldHVybiB0aGlzfX0pO20oe3JlbW92ZURhdGE6dWIsb246ZnVuY3Rpb24gYShjLGQsZSxmKXtpZih3KGYpKXRocm93IFViKFxcXCJvbmFyZ3NcXFwiKTtpZihNYyhjKSl7dmFyIGc9dmIoYywhMCk7Zj1nLmV2ZW50czt2YXIgaD1nLmhhbmRsZTtofHwoaD1nLmhhbmRsZT1IZihjLGYpKTtmb3IodmFyIGc9MDw9ZC5pbmRleE9mKFxcXCIgXFxcIik/ZC5zcGxpdChcXFwiIFxcXCIpOltkXSxsPWcubGVuZ3RoO2wtLTspe2Q9Z1tsXTt2YXIgaz1mW2RdO2t8fChmW2RdPVtdLFxcXCJtb3VzZWVudGVyXFxcIj09PWR8fFxcXCJtb3VzZWxlYXZlXFxcIj09PVxcbmQ/YShjLG1nW2RdLGZ1bmN0aW9uKGEpe3ZhciBjPWEucmVsYXRlZFRhcmdldDtjJiYoYz09PXRoaXN8fHRoaXMuY29udGFpbnMoYykpfHxoKGEsZCl9KTpcXFwiJGRlc3Ryb3lcXFwiIT09ZCYmYy5hZGRFdmVudExpc3RlbmVyKGQsaCwhMSksaz1mW2RdKTtrLnB1c2goZSl9fX0sb2ZmOlBjLG9uZTpmdW5jdGlvbihhLGMsZCl7YT15KGEpO2Eub24oYyxmdW5jdGlvbiBmKCl7YS5vZmYoYyxkKTthLm9mZihjLGYpfSk7YS5vbihjLGQpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbihhLGMpe3ZhciBkLGU9YS5wYXJlbnROb2RlO3RiKGEpO20obmV3IFEoYyksZnVuY3Rpb24oYyl7ZD9lLmluc2VydEJlZm9yZShjLGQubmV4dFNpYmxpbmcpOmUucmVwbGFjZUNoaWxkKGMsYSk7ZD1jfSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGEpe3ZhciBjPVtdO20oYS5jaGlsZE5vZGVzLGZ1bmN0aW9uKGEpe2Eubm9kZVR5cGU9PT1xYSYmYy5wdXNoKGEpfSk7cmV0dXJuIGN9LGNvbnRlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRlbnREb2N1bWVudHx8XFxuYS5jaGlsZE5vZGVzfHxbXX0sYXBwZW5kOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9YS5ub2RlVHlwZTtpZihkPT09cWF8fDExPT09ZCl7Yz1uZXcgUShjKTtmb3IodmFyIGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspYS5hcHBlbmRDaGlsZChjW2RdKX19LHByZXBlbmQ6ZnVuY3Rpb24oYSxjKXtpZihhLm5vZGVUeXBlPT09cWEpe3ZhciBkPWEuZmlyc3RDaGlsZDttKG5ldyBRKGMpLGZ1bmN0aW9uKGMpe2EuaW5zZXJ0QmVmb3JlKGMsZCl9KX19LHdyYXA6ZnVuY3Rpb24oYSxjKXtjPXkoYykuZXEoMCkuY2xvbmUoKVswXTt2YXIgZD1hLnBhcmVudE5vZGU7ZCYmZC5yZXBsYWNlQ2hpbGQoYyxhKTtjLmFwcGVuZENoaWxkKGEpfSxyZW1vdmU6WGIsZGV0YWNoOmZ1bmN0aW9uKGEpe1hiKGEsITApfSxhZnRlcjpmdW5jdGlvbihhLGMpe3ZhciBkPWEsZT1hLnBhcmVudE5vZGU7Yz1uZXcgUShjKTtmb3IodmFyIGY9MCxnPWMubGVuZ3RoO2Y8ZztmKyspe3ZhciBoPWNbZl07ZS5pbnNlcnRCZWZvcmUoaCxcXG5kLm5leHRTaWJsaW5nKTtkPWh9fSxhZGRDbGFzczp5YixyZW1vdmVDbGFzczp4Yix0b2dnbGVDbGFzczpmdW5jdGlvbihhLGMsZCl7YyYmbShjLnNwbGl0KFxcXCIgXFxcIiksZnVuY3Rpb24oYyl7dmFyIGY9ZDtBKGYpJiYoZj0hd2IoYSxjKSk7KGY/eWI6eGIpKGEsYyl9KX0scGFyZW50OmZ1bmN0aW9uKGEpe3JldHVybihhPWEucGFyZW50Tm9kZSkmJjExIT09YS5ub2RlVHlwZT9hOm51bGx9LG5leHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubmV4dEVsZW1lbnRTaWJsaW5nfSxmaW5kOmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWU/YS5nZXRFbGVtZW50c0J5VGFnTmFtZShjKTpbXX0sY2xvbmU6VmIsdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGYsZz1jLnR5cGV8fGMsaD12YihhKTtpZihoPShoPWgmJmguZXZlbnRzKSYmaFtnXSllPXtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMH0saXNEZWZhdWx0UHJldmVudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITA9PT1cXG50aGlzLmRlZmF1bHRQcmV2ZW50ZWR9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3RoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPSEwfSxpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpmdW5jdGlvbigpe3JldHVybiEwPT09dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWR9LHN0b3BQcm9wYWdhdGlvbjp2LHR5cGU6Zyx0YXJnZXQ6YX0sYy50eXBlJiYoZT1QKGUsYykpLGM9aWEoaCksZj1kP1tlXS5jb25jYXQoZCk6W2VdLG0oYyxmdW5jdGlvbihjKXtlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCl8fGMuYXBwbHkoYSxmKX0pfX0sZnVuY3Rpb24oYSxjKXtRLnByb3RvdHlwZVtjXT1mdW5jdGlvbihjLGUsZil7Zm9yKHZhciBnLGg9MCxsPXRoaXMubGVuZ3RoO2g8bDtoKyspQShnKT8oZz1hKHRoaXNbaF0sYyxlLGYpLHcoZykmJihnPXkoZykpKTpPYyhnLGEodGhpc1toXSxjLGUsZikpO3JldHVybiB3KGcpP2c6dGhpc307US5wcm90b3R5cGUuYmluZD1cXG5RLnByb3RvdHlwZS5vbjtRLnByb3RvdHlwZS51bmJpbmQ9US5wcm90b3R5cGUub2ZmfSk7U2EucHJvdG90eXBlPXtwdXQ6ZnVuY3Rpb24oYSxjKXt0aGlzW0dhKGEsdGhpcy5uZXh0VWlkKV09Y30sZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzW0dhKGEsdGhpcy5uZXh0VWlkKV19LHJlbW92ZTpmdW5jdGlvbihhKXt2YXIgYz10aGlzW2E9R2EoYSx0aGlzLm5leHRVaWQpXTtkZWxldGUgdGhpc1thXTtyZXR1cm4gY319O3ZhciB4Zj1bZnVuY3Rpb24oKXt0aGlzLiRnZXQ9W2Z1bmN0aW9uKCl7cmV0dXJuIFNhfV19XSxXYz0vXmZ1bmN0aW9uXFxcXHMqW15cXFxcKF0qXFxcXChcXFxccyooW15cXFxcKV0qKVxcXFwpL20sbmc9LywvLG9nPS9eXFxcXHMqKF8/KShcXFxcUys/KVxcXFwxXFxcXHMqJC8sVmM9LygoXFxcXC9cXFxcLy4qJCl8KFxcXFwvXFxcXCpbXFxcXHNcXFxcU10qP1xcXFwqXFxcXC8pKS9tZyxIYT1KKFxcXCIkaW5qZWN0b3JcXFwiKTtlYi4kJGFubm90YXRlPWZ1bmN0aW9uKGEsYyxkKXt2YXIgZTtpZihcXFwiZnVuY3Rpb25cXFwiPT09dHlwZW9mIGEpe2lmKCEoZT1hLiRpbmplY3QpKXtlPVxcbltdO2lmKGEubGVuZ3RoKXtpZihjKXRocm93IEwoZCkmJmR8fChkPWEubmFtZXx8SWYoYSkpLEhhKFxcXCJzdHJpY3RkaVxcXCIsZCk7Yz1hLnRvU3RyaW5nKCkucmVwbGFjZShWYyxcXFwiXFxcIik7Yz1jLm1hdGNoKFdjKTttKGNbMV0uc3BsaXQobmcpLGZ1bmN0aW9uKGEpe2EucmVwbGFjZShvZyxmdW5jdGlvbihhLGMsZCl7ZS5wdXNoKGQpfSl9KX1hLiRpbmplY3Q9ZX19ZWxzZSBHKGEpPyhjPWEubGVuZ3RoLTEsUWEoYVtjXSxcXFwiZm5cXFwiKSxlPWEuc2xpY2UoMCxjKSk6UWEoYSxcXFwiZm5cXFwiLCEwKTtyZXR1cm4gZX07dmFyIE5kPUooXFxcIiRhbmltYXRlXFxcIiksVWU9ZnVuY3Rpb24oKXt0aGlzLiRnZXQ9W1xcXCIkcVxcXCIsXFxcIiQkckFGXFxcIixmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGQoKXt9ZC5hbGw9djtkLmNoYWluPXY7ZC5wcm90b3R5cGU9e2VuZDp2LGNhbmNlbDp2LHJlc3VtZTp2LHBhdXNlOnYsY29tcGxldGU6dix0aGVuOmZ1bmN0aW9uKGQsZil7cmV0dXJuIGEoZnVuY3Rpb24oYSl7YyhmdW5jdGlvbigpe2EoKX0pfSkudGhlbihkLFxcbmYpfX07cmV0dXJuIGR9XX0sVGU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgU2EsYz1bXTt0aGlzLiRnZXQ9W1xcXCIkJEFuaW1hdGVSdW5uZXJcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixmdW5jdGlvbihkLGUpe2Z1bmN0aW9uIGYoZCxmLGwpe3ZhciBrPWEuZ2V0KGQpO2t8fChhLnB1dChkLGs9e30pLGMucHVzaChkKSk7ZiYmbShmLnNwbGl0KFxcXCIgXFxcIiksZnVuY3Rpb24oYSl7YSYmKGtbYV09ITApfSk7bCYmbShsLnNwbGl0KFxcXCIgXFxcIiksZnVuY3Rpb24oYSl7YSYmKGtbYV09ITEpfSk7MTxjLmxlbmd0aHx8ZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKXttKGMsZnVuY3Rpb24oYyl7dmFyIGQ9YS5nZXQoYyk7aWYoZCl7dmFyIGU9SmYoYy5hdHRyKFxcXCJjbGFzc1xcXCIpKSxmPVxcXCJcXFwiLGc9XFxcIlxcXCI7bShkLGZ1bmN0aW9uKGEsYyl7YSE9PSEhZVtjXSYmKGE/Zis9KGYubGVuZ3RoP1xcXCIgXFxcIjpcXFwiXFxcIikrYzpnKz0oZy5sZW5ndGg/XFxcIiBcXFwiOlxcXCJcXFwiKStjKX0pO20oYyxmdW5jdGlvbihhKXtmJiZ5YihhLGYpO2cmJnhiKGEsZyl9KTthLnJlbW92ZShjKX19KTtcXG5jLmxlbmd0aD0wfSl9cmV0dXJue2VuYWJsZWQ6dixvbjp2LG9mZjp2LHBpbjp2LHB1c2g6ZnVuY3Rpb24oYSxjLGUsayl7ayYmaygpO2U9ZXx8e307ZS5mcm9tJiZhLmNzcyhlLmZyb20pO2UudG8mJmEuY3NzKGUudG8pOyhlLmFkZENsYXNzfHxlLnJlbW92ZUNsYXNzKSYmZihhLGUuYWRkQ2xhc3MsZS5yZW1vdmVDbGFzcyk7cmV0dXJuIG5ldyBkfX19XX0sU2U9W1xcXCIkcHJvdmlkZVxcXCIsZnVuY3Rpb24oYSl7dmFyIGM9dGhpczt0aGlzLiQkcmVnaXN0ZXJlZEFuaW1hdGlvbnM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLnJlZ2lzdGVyPWZ1bmN0aW9uKGQsZSl7aWYoZCYmXFxcIi5cXFwiIT09ZC5jaGFyQXQoMCkpdGhyb3cgTmQoXFxcIm5vdGNzZWxcXFwiLGQpO3ZhciBmPWQrXFxcIi1hbmltYXRpb25cXFwiO2MuJCRyZWdpc3RlcmVkQW5pbWF0aW9uc1tkLnN1YnN0cigxKV09ZjthLmZhY3RvcnkoZixlKX07dGhpcy5jbGFzc05hbWVGaWx0ZXI9ZnVuY3Rpb24oYSl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJih0aGlzLiQkY2xhc3NOYW1lRmlsdGVyPVxcbmEgaW5zdGFuY2VvZiBSZWdFeHA/YTpudWxsKSYmLyhcXFxccyt8XFxcXC8pbmctYW5pbWF0ZShcXFxccyt8XFxcXC8pLy50ZXN0KHRoaXMuJCRjbGFzc05hbWVGaWx0ZXIudG9TdHJpbmcoKSkpdGhyb3cgTmQoXFxcIm5vbmdjbHNcXFwiLFxcXCJuZy1hbmltYXRlXFxcIik7cmV0dXJuIHRoaXMuJCRjbGFzc05hbWVGaWx0ZXJ9O3RoaXMuJGdldD1bXFxcIiQkYW5pbWF0ZVF1ZXVlXFxcIixmdW5jdGlvbihhKXtmdW5jdGlvbiBjKGEsZCxlKXtpZihlKXt2YXIgbDthOntmb3IobD0wO2w8ZS5sZW5ndGg7bCsrKXt2YXIgaz1lW2xdO2lmKDE9PT1rLm5vZGVUeXBlKXtsPWs7YnJlYWsgYX19bD12b2lkIDB9IWx8fGwucGFyZW50Tm9kZXx8bC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nfHwoZT1udWxsKX1lP2UuYWZ0ZXIoYSk6ZC5wcmVwZW5kKGEpfXJldHVybntvbjphLm9uLG9mZjphLm9mZixwaW46YS5waW4sZW5hYmxlZDphLmVuYWJsZWQsY2FuY2VsOmZ1bmN0aW9uKGEpe2EuZW5kJiZhLmVuZCgpfSxlbnRlcjpmdW5jdGlvbihmLGcsaCxsKXtnPVxcbmcmJnkoZyk7aD1oJiZ5KGgpO2c9Z3x8aC5wYXJlbnQoKTtjKGYsZyxoKTtyZXR1cm4gYS5wdXNoKGYsXFxcImVudGVyXFxcIixJYShsKSl9LG1vdmU6ZnVuY3Rpb24oZixnLGgsbCl7Zz1nJiZ5KGcpO2g9aCYmeShoKTtnPWd8fGgucGFyZW50KCk7YyhmLGcsaCk7cmV0dXJuIGEucHVzaChmLFxcXCJtb3ZlXFxcIixJYShsKSl9LGxlYXZlOmZ1bmN0aW9uKGMsZSl7cmV0dXJuIGEucHVzaChjLFxcXCJsZWF2ZVxcXCIsSWEoZSksZnVuY3Rpb24oKXtjLnJlbW92ZSgpfSl9LGFkZENsYXNzOmZ1bmN0aW9uKGMsZSxoKXtoPUlhKGgpO2guYWRkQ2xhc3M9amIoaC5hZGRjbGFzcyxlKTtyZXR1cm4gYS5wdXNoKGMsXFxcImFkZENsYXNzXFxcIixoKX0scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYyxlLGgpe2g9SWEoaCk7aC5yZW1vdmVDbGFzcz1qYihoLnJlbW92ZUNsYXNzLGUpO3JldHVybiBhLnB1c2goYyxcXFwicmVtb3ZlQ2xhc3NcXFwiLGgpfSxzZXRDbGFzczpmdW5jdGlvbihjLGUsaCxsKXtsPUlhKGwpO2wuYWRkQ2xhc3M9amIobC5hZGRDbGFzcyxcXG5lKTtsLnJlbW92ZUNsYXNzPWpiKGwucmVtb3ZlQ2xhc3MsaCk7cmV0dXJuIGEucHVzaChjLFxcXCJzZXRDbGFzc1xcXCIsbCl9LGFuaW1hdGU6ZnVuY3Rpb24oYyxlLGgsbCxrKXtrPUlhKGspO2suZnJvbT1rLmZyb20/UChrLmZyb20sZSk6ZTtrLnRvPWsudG8/UChrLnRvLGgpOmg7ay50ZW1wQ2xhc3Nlcz1qYihrLnRlbXBDbGFzc2VzLGx8fFxcXCJuZy1pbmxpbmUtYW5pbWF0ZVxcXCIpO3JldHVybiBhLnB1c2goYyxcXFwiYW5pbWF0ZVxcXCIsayl9fX1dfV0sZWE9SihcXFwiJGNvbXBpbGVcXFwiKTtFYy4kaW5qZWN0PVtcXFwiJHByb3ZpZGVcXFwiLFxcXCIkJHNhbml0aXplVXJpUHJvdmlkZXJcXFwiXTt2YXIgWmM9L14oKD86eHxkYXRhKVtcXFxcOlxcXFwtX10pL2ksT2Y9SihcXFwiJGNvbnRyb2xsZXJcXFwiKSxYYz0vXihcXFxcUyspKFxcXFxzK2FzXFxcXHMrKFxcXFx3KykpPyQvLGNkPVxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIixhYz17XFxcIkNvbnRlbnQtVHlwZVxcXCI6Y2QrXFxcIjtjaGFyc2V0PXV0Zi04XFxcIn0sUWY9L15cXFxcW3xeXFxcXHsoPyFcXFxceykvLFJmPXtcXFwiW1xcXCI6L10kLyxcXFwie1xcXCI6L30kL30sUGY9L15cXFxcKVxcXFxdXFxcXH0nLD9cXFxcbi8sXFxuS2E9Y2EuJGludGVycG9sYXRlTWluRXJyPUooXFxcIiRpbnRlcnBvbGF0ZVxcXCIpO0thLnRocm93Tm9jb25jYXQ9ZnVuY3Rpb24oYSl7dGhyb3cgS2EoXFxcIm5vY29uY2F0XFxcIixhKTt9O0thLmludGVycj1mdW5jdGlvbihhLGMpe3JldHVybiBLYShcXFwiaW50ZXJyXFxcIixhLGMudG9TdHJpbmcoKSl9O3ZhciBwZz0vXihbXlxcXFw/I10qKShcXFxcPyhbXiNdKikpPygjKC4qKSk/JC8sVWY9e2h0dHA6ODAsaHR0cHM6NDQzLGZ0cDoyMX0sQ2I9SihcXFwiJGxvY2F0aW9uXFxcIikscWc9eyQkaHRtbDU6ITEsJCRyZXBsYWNlOiExLGFic1VybDpEYihcXFwiJCRhYnNVcmxcXFwiKSx1cmw6ZnVuY3Rpb24oYSl7aWYoQShhKSlyZXR1cm4gdGhpcy4kJHVybDt2YXIgYz1wZy5leGVjKGEpOyhjWzFdfHxcXFwiXFxcIj09PWEpJiZ0aGlzLnBhdGgoZGVjb2RlVVJJQ29tcG9uZW50KGNbMV0pKTsoY1syXXx8Y1sxXXx8XFxcIlxcXCI9PT1hKSYmdGhpcy5zZWFyY2goY1szXXx8XFxcIlxcXCIpO3RoaXMuaGFzaChjWzVdfHxcXFwiXFxcIik7cmV0dXJuIHRoaXN9LHByb3RvY29sOkRiKFxcXCIkJHByb3RvY29sXFxcIiksXFxuaG9zdDpEYihcXFwiJCRob3N0XFxcIikscG9ydDpEYihcXFwiJCRwb3J0XFxcIikscGF0aDprZChcXFwiJCRwYXRoXFxcIixmdW5jdGlvbihhKXthPW51bGwhPT1hP2EudG9TdHJpbmcoKTpcXFwiXFxcIjtyZXR1cm5cXFwiL1xcXCI9PWEuY2hhckF0KDApP2E6XFxcIi9cXFwiK2F9KSxzZWFyY2g6ZnVuY3Rpb24oYSxjKXtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLiQkc2VhcmNoO2Nhc2UgMTppZihMKGEpfHxWKGEpKWE9YS50b1N0cmluZygpLHRoaXMuJCRzZWFyY2g9emMoYSk7ZWxzZSBpZihIKGEpKWE9ZmEoYSx7fSksbShhLGZ1bmN0aW9uKGMsZSl7bnVsbD09YyYmZGVsZXRlIGFbZV19KSx0aGlzLiQkc2VhcmNoPWE7ZWxzZSB0aHJvdyBDYihcXFwiaXNyY2hhcmdcXFwiKTticmVhaztkZWZhdWx0OkEoYyl8fG51bGw9PT1jP2RlbGV0ZSB0aGlzLiQkc2VhcmNoW2FdOnRoaXMuJCRzZWFyY2hbYV09Y310aGlzLiQkY29tcG9zZSgpO3JldHVybiB0aGlzfSxoYXNoOmtkKFxcXCIkJGhhc2hcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09XFxuYT9hLnRvU3RyaW5nKCk6XFxcIlxcXCJ9KSxyZXBsYWNlOmZ1bmN0aW9uKCl7dGhpcy4kJHJlcGxhY2U9ITA7cmV0dXJuIHRoaXN9fTttKFtqZCxlYyxkY10sZnVuY3Rpb24oYSl7YS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShxZyk7YS5wcm90b3R5cGUuc3RhdGU9ZnVuY3Rpb24oYyl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuJCRzdGF0ZTtpZihhIT09ZGN8fCF0aGlzLiQkaHRtbDUpdGhyb3cgQ2IoXFxcIm5vc3RhdGVcXFwiKTt0aGlzLiQkc3RhdGU9QShjKT9udWxsOmM7cmV0dXJuIHRoaXN9fSk7dmFyIGRhPUooXFxcIiRwYXJzZVxcXCIpLFZmPUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFdmPUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSxYZj1GdW5jdGlvbi5wcm90b3R5cGUuYmluZCxNYj1nYSgpO20oXFxcIisgLSAqIC8gJSA9PT0gIT09ID09ICE9IDwgPiA8PSA+PSAmJiB8fCAhID0gfFxcXCIuc3BsaXQoXFxcIiBcXFwiKSxmdW5jdGlvbihhKXtNYlthXT0hMH0pO3ZhciByZz17bjpcXFwiXFxcXG5cXFwiLGY6XFxcIlxcXFxmXFxcIixyOlxcXCJcXFxcclxcXCIsXFxudDpcXFwiXFxcXHRcXFwiLHY6XFxcIlxcXFx2XFxcIixcXFwiJ1xcXCI6XFxcIidcXFwiLCdcXFwiJzonXFxcIid9LGdjPWZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz1hfTtnYy5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmdjLGxleDpmdW5jdGlvbihhKXt0aGlzLnRleHQ9YTt0aGlzLmluZGV4PTA7Zm9yKHRoaXMudG9rZW5zPVtdO3RoaXMuaW5kZXg8dGhpcy50ZXh0Lmxlbmd0aDspaWYoYT10aGlzLnRleHQuY2hhckF0KHRoaXMuaW5kZXgpLCdcXFwiJz09PWF8fFxcXCInXFxcIj09PWEpdGhpcy5yZWFkU3RyaW5nKGEpO2Vsc2UgaWYodGhpcy5pc051bWJlcihhKXx8XFxcIi5cXFwiPT09YSYmdGhpcy5pc051bWJlcih0aGlzLnBlZWsoKSkpdGhpcy5yZWFkTnVtYmVyKCk7ZWxzZSBpZih0aGlzLmlzSWRlbnQoYSkpdGhpcy5yZWFkSWRlbnQoKTtlbHNlIGlmKHRoaXMuaXMoYSxcXFwiKCl7fVtdLiw7Oj9cXFwiKSl0aGlzLnRva2Vucy5wdXNoKHtpbmRleDp0aGlzLmluZGV4LHRleHQ6YX0pLHRoaXMuaW5kZXgrKztlbHNlIGlmKHRoaXMuaXNXaGl0ZXNwYWNlKGEpKXRoaXMuaW5kZXgrKztcXG5lbHNle3ZhciBjPWErdGhpcy5wZWVrKCksZD1jK3RoaXMucGVlaygyKSxlPU1iW2NdLGY9TWJbZF07TWJbYV18fGV8fGY/KGE9Zj9kOmU/YzphLHRoaXMudG9rZW5zLnB1c2goe2luZGV4OnRoaXMuaW5kZXgsdGV4dDphLG9wZXJhdG9yOiEwfSksdGhpcy5pbmRleCs9YS5sZW5ndGgpOnRoaXMudGhyb3dFcnJvcihcXFwiVW5leHBlY3RlZCBuZXh0IGNoYXJhY3RlciBcXFwiLHRoaXMuaW5kZXgsdGhpcy5pbmRleCsxKX1yZXR1cm4gdGhpcy50b2tlbnN9LGlzOmZ1bmN0aW9uKGEsYyl7cmV0dXJuLTEhPT1jLmluZGV4T2YoYSl9LHBlZWs6ZnVuY3Rpb24oYSl7YT1hfHwxO3JldHVybiB0aGlzLmluZGV4K2E8dGhpcy50ZXh0Lmxlbmd0aD90aGlzLnRleHQuY2hhckF0KHRoaXMuaW5kZXgrYSk6ITF9LGlzTnVtYmVyOmZ1bmN0aW9uKGEpe3JldHVyblxcXCIwXFxcIjw9YSYmXFxcIjlcXFwiPj1hJiZcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBhfSxpc1doaXRlc3BhY2U6ZnVuY3Rpb24oYSl7cmV0dXJuXFxcIiBcXFwiPT09YXx8XFxcIlxcXFxyXFxcIj09PWF8fFxcblxcXCJcXFxcdFxcXCI9PT1hfHxcXFwiXFxcXG5cXFwiPT09YXx8XFxcIlxcXFx2XFxcIj09PWF8fFxcXCJcXFxcdTAwYTBcXFwiPT09YX0saXNJZGVudDpmdW5jdGlvbihhKXtyZXR1cm5cXFwiYVxcXCI8PWEmJlxcXCJ6XFxcIj49YXx8XFxcIkFcXFwiPD1hJiZcXFwiWlxcXCI+PWF8fFxcXCJfXFxcIj09PWF8fFxcXCIkXFxcIj09PWF9LGlzRXhwT3BlcmF0b3I6ZnVuY3Rpb24oYSl7cmV0dXJuXFxcIi1cXFwiPT09YXx8XFxcIitcXFwiPT09YXx8dGhpcy5pc051bWJlcihhKX0sdGhyb3dFcnJvcjpmdW5jdGlvbihhLGMsZCl7ZD1kfHx0aGlzLmluZGV4O2M9dyhjKT9cXFwicyBcXFwiK2MrXFxcIi1cXFwiK3RoaXMuaW5kZXgrXFxcIiBbXFxcIit0aGlzLnRleHQuc3Vic3RyaW5nKGMsZCkrXFxcIl1cXFwiOlxcXCIgXFxcIitkO3Rocm93IGRhKFxcXCJsZXhlcnJcXFwiLGEsYyx0aGlzLnRleHQpO30scmVhZE51bWJlcjpmdW5jdGlvbigpe2Zvcih2YXIgYT1cXFwiXFxcIixjPXRoaXMuaW5kZXg7dGhpcy5pbmRleDx0aGlzLnRleHQubGVuZ3RoOyl7dmFyIGQ9TSh0aGlzLnRleHQuY2hhckF0KHRoaXMuaW5kZXgpKTtpZihcXFwiLlxcXCI9PWR8fHRoaXMuaXNOdW1iZXIoZCkpYSs9ZDtlbHNle3ZhciBlPXRoaXMucGVlaygpO1xcbmlmKFxcXCJlXFxcIj09ZCYmdGhpcy5pc0V4cE9wZXJhdG9yKGUpKWErPWQ7ZWxzZSBpZih0aGlzLmlzRXhwT3BlcmF0b3IoZCkmJmUmJnRoaXMuaXNOdW1iZXIoZSkmJlxcXCJlXFxcIj09YS5jaGFyQXQoYS5sZW5ndGgtMSkpYSs9ZDtlbHNlIGlmKCF0aGlzLmlzRXhwT3BlcmF0b3IoZCl8fGUmJnRoaXMuaXNOdW1iZXIoZSl8fFxcXCJlXFxcIiE9YS5jaGFyQXQoYS5sZW5ndGgtMSkpYnJlYWs7ZWxzZSB0aGlzLnRocm93RXJyb3IoXFxcIkludmFsaWQgZXhwb25lbnRcXFwiKX10aGlzLmluZGV4Kyt9dGhpcy50b2tlbnMucHVzaCh7aW5kZXg6Yyx0ZXh0OmEsY29uc3RhbnQ6ITAsdmFsdWU6TnVtYmVyKGEpfSl9LHJlYWRJZGVudDpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLmluZGV4O3RoaXMuaW5kZXg8dGhpcy50ZXh0Lmxlbmd0aDspe3ZhciBjPXRoaXMudGV4dC5jaGFyQXQodGhpcy5pbmRleCk7aWYoIXRoaXMuaXNJZGVudChjKSYmIXRoaXMuaXNOdW1iZXIoYykpYnJlYWs7dGhpcy5pbmRleCsrfXRoaXMudG9rZW5zLnB1c2goe2luZGV4OmEsXFxudGV4dDp0aGlzLnRleHQuc2xpY2UoYSx0aGlzLmluZGV4KSxpZGVudGlmaWVyOiEwfSl9LHJlYWRTdHJpbmc6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5pbmRleDt0aGlzLmluZGV4Kys7Zm9yKHZhciBkPVxcXCJcXFwiLGU9YSxmPSExO3RoaXMuaW5kZXg8dGhpcy50ZXh0Lmxlbmd0aDspe3ZhciBnPXRoaXMudGV4dC5jaGFyQXQodGhpcy5pbmRleCksZT1lK2c7aWYoZilcXFwidVxcXCI9PT1nPyhmPXRoaXMudGV4dC5zdWJzdHJpbmcodGhpcy5pbmRleCsxLHRoaXMuaW5kZXgrNSksZi5tYXRjaCgvW1xcXFxkYS1mXXs0fS9pKXx8dGhpcy50aHJvd0Vycm9yKFxcXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcXFxcXHVcXFwiK2YrXFxcIl1cXFwiKSx0aGlzLmluZGV4Kz00LGQrPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZiwxNikpKTpkKz1yZ1tnXXx8ZyxmPSExO2Vsc2UgaWYoXFxcIlxcXFxcXFxcXFxcIj09PWcpZj0hMDtlbHNle2lmKGc9PT1hKXt0aGlzLmluZGV4Kys7dGhpcy50b2tlbnMucHVzaCh7aW5kZXg6Yyx0ZXh0OmUsY29uc3RhbnQ6ITAsXFxudmFsdWU6ZH0pO3JldHVybn1kKz1nfXRoaXMuaW5kZXgrK310aGlzLnRocm93RXJyb3IoXFxcIlVudGVybWluYXRlZCBxdW90ZVxcXCIsYyl9fTt2YXIgcT1mdW5jdGlvbihhLGMpe3RoaXMubGV4ZXI9YTt0aGlzLm9wdGlvbnM9Y307cS5Qcm9ncmFtPVxcXCJQcm9ncmFtXFxcIjtxLkV4cHJlc3Npb25TdGF0ZW1lbnQ9XFxcIkV4cHJlc3Npb25TdGF0ZW1lbnRcXFwiO3EuQXNzaWdubWVudEV4cHJlc3Npb249XFxcIkFzc2lnbm1lbnRFeHByZXNzaW9uXFxcIjtxLkNvbmRpdGlvbmFsRXhwcmVzc2lvbj1cXFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXFxcIjtxLkxvZ2ljYWxFeHByZXNzaW9uPVxcXCJMb2dpY2FsRXhwcmVzc2lvblxcXCI7cS5CaW5hcnlFeHByZXNzaW9uPVxcXCJCaW5hcnlFeHByZXNzaW9uXFxcIjtxLlVuYXJ5RXhwcmVzc2lvbj1cXFwiVW5hcnlFeHByZXNzaW9uXFxcIjtxLkNhbGxFeHByZXNzaW9uPVxcXCJDYWxsRXhwcmVzc2lvblxcXCI7cS5NZW1iZXJFeHByZXNzaW9uPVxcXCJNZW1iZXJFeHByZXNzaW9uXFxcIjtxLklkZW50aWZpZXI9XFxcIklkZW50aWZpZXJcXFwiO3EuTGl0ZXJhbD1cXG5cXFwiTGl0ZXJhbFxcXCI7cS5BcnJheUV4cHJlc3Npb249XFxcIkFycmF5RXhwcmVzc2lvblxcXCI7cS5Qcm9wZXJ0eT1cXFwiUHJvcGVydHlcXFwiO3EuT2JqZWN0RXhwcmVzc2lvbj1cXFwiT2JqZWN0RXhwcmVzc2lvblxcXCI7cS5UaGlzRXhwcmVzc2lvbj1cXFwiVGhpc0V4cHJlc3Npb25cXFwiO3EuTkdWYWx1ZVBhcmFtZXRlcj1cXFwiTkdWYWx1ZVBhcmFtZXRlclxcXCI7cS5wcm90b3R5cGU9e2FzdDpmdW5jdGlvbihhKXt0aGlzLnRleHQ9YTt0aGlzLnRva2Vucz10aGlzLmxleGVyLmxleChhKTthPXRoaXMucHJvZ3JhbSgpOzAhPT10aGlzLnRva2Vucy5sZW5ndGgmJnRoaXMudGhyb3dFcnJvcihcXFwiaXMgYW4gdW5leHBlY3RlZCB0b2tlblxcXCIsdGhpcy50b2tlbnNbMF0pO3JldHVybiBhfSxwcm9ncmFtOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdOzspaWYoMDx0aGlzLnRva2Vucy5sZW5ndGgmJiF0aGlzLnBlZWsoXFxcIn1cXFwiLFxcXCIpXFxcIixcXFwiO1xcXCIsXFxcIl1cXFwiKSYmYS5wdXNoKHRoaXMuZXhwcmVzc2lvblN0YXRlbWVudCgpKSwhdGhpcy5leHBlY3QoXFxcIjtcXFwiKSlyZXR1cm57dHlwZTpxLlByb2dyYW0sXFxuYm9keTphfX0sZXhwcmVzc2lvblN0YXRlbWVudDpmdW5jdGlvbigpe3JldHVybnt0eXBlOnEuRXhwcmVzc2lvblN0YXRlbWVudCxleHByZXNzaW9uOnRoaXMuZmlsdGVyQ2hhaW4oKX19LGZpbHRlckNoYWluOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMuZXhwcmVzc2lvbigpO3RoaXMuZXhwZWN0KFxcXCJ8XFxcIik7KWE9dGhpcy5maWx0ZXIoYSk7cmV0dXJuIGF9LGV4cHJlc3Npb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc3NpZ25tZW50KCl9LGFzc2lnbm1lbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRlcm5hcnkoKTt0aGlzLmV4cGVjdChcXFwiPVxcXCIpJiYoYT17dHlwZTpxLkFzc2lnbm1lbnRFeHByZXNzaW9uLGxlZnQ6YSxyaWdodDp0aGlzLmFzc2lnbm1lbnQoKSxvcGVyYXRvcjpcXFwiPVxcXCJ9KTtyZXR1cm4gYX0sdGVybmFyeTpmdW5jdGlvbigpe3ZhciBhPXRoaXMubG9naWNhbE9SKCksYyxkO3JldHVybiB0aGlzLmV4cGVjdChcXFwiP1xcXCIpJiYoYz10aGlzLmV4cHJlc3Npb24oKSx0aGlzLmNvbnN1bWUoXFxcIjpcXFwiKSk/XFxuKGQ9dGhpcy5leHByZXNzaW9uKCkse3R5cGU6cS5Db25kaXRpb25hbEV4cHJlc3Npb24sdGVzdDphLGFsdGVybmF0ZTpjLGNvbnNlcXVlbnQ6ZH0pOmF9LGxvZ2ljYWxPUjpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLmxvZ2ljYWxBTkQoKTt0aGlzLmV4cGVjdChcXFwifHxcXFwiKTspYT17dHlwZTpxLkxvZ2ljYWxFeHByZXNzaW9uLG9wZXJhdG9yOlxcXCJ8fFxcXCIsbGVmdDphLHJpZ2h0OnRoaXMubG9naWNhbEFORCgpfTtyZXR1cm4gYX0sbG9naWNhbEFORDpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLmVxdWFsaXR5KCk7dGhpcy5leHBlY3QoXFxcIiYmXFxcIik7KWE9e3R5cGU6cS5Mb2dpY2FsRXhwcmVzc2lvbixvcGVyYXRvcjpcXFwiJiZcXFwiLGxlZnQ6YSxyaWdodDp0aGlzLmVxdWFsaXR5KCl9O3JldHVybiBhfSxlcXVhbGl0eTpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLnJlbGF0aW9uYWwoKSxjO2M9dGhpcy5leHBlY3QoXFxcIj09XFxcIixcXFwiIT1cXFwiLFxcXCI9PT1cXFwiLFxcXCIhPT1cXFwiKTspYT17dHlwZTpxLkJpbmFyeUV4cHJlc3Npb24sXFxub3BlcmF0b3I6Yy50ZXh0LGxlZnQ6YSxyaWdodDp0aGlzLnJlbGF0aW9uYWwoKX07cmV0dXJuIGF9LHJlbGF0aW9uYWw6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5hZGRpdGl2ZSgpLGM7Yz10aGlzLmV4cGVjdChcXFwiPFxcXCIsXFxcIj5cXFwiLFxcXCI8PVxcXCIsXFxcIj49XFxcIik7KWE9e3R5cGU6cS5CaW5hcnlFeHByZXNzaW9uLG9wZXJhdG9yOmMudGV4dCxsZWZ0OmEscmlnaHQ6dGhpcy5hZGRpdGl2ZSgpfTtyZXR1cm4gYX0sYWRkaXRpdmU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5tdWx0aXBsaWNhdGl2ZSgpLGM7Yz10aGlzLmV4cGVjdChcXFwiK1xcXCIsXFxcIi1cXFwiKTspYT17dHlwZTpxLkJpbmFyeUV4cHJlc3Npb24sb3BlcmF0b3I6Yy50ZXh0LGxlZnQ6YSxyaWdodDp0aGlzLm11bHRpcGxpY2F0aXZlKCl9O3JldHVybiBhfSxtdWx0aXBsaWNhdGl2ZTpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLnVuYXJ5KCksYztjPXRoaXMuZXhwZWN0KFxcXCIqXFxcIixcXFwiL1xcXCIsXFxcIiVcXFwiKTspYT17dHlwZTpxLkJpbmFyeUV4cHJlc3Npb24sb3BlcmF0b3I6Yy50ZXh0LFxcbmxlZnQ6YSxyaWdodDp0aGlzLnVuYXJ5KCl9O3JldHVybiBhfSx1bmFyeTpmdW5jdGlvbigpe3ZhciBhO3JldHVybihhPXRoaXMuZXhwZWN0KFxcXCIrXFxcIixcXFwiLVxcXCIsXFxcIiFcXFwiKSk/e3R5cGU6cS5VbmFyeUV4cHJlc3Npb24sb3BlcmF0b3I6YS50ZXh0LHByZWZpeDohMCxhcmd1bWVudDp0aGlzLnVuYXJ5KCl9OnRoaXMucHJpbWFyeSgpfSxwcmltYXJ5OmZ1bmN0aW9uKCl7dmFyIGE7dGhpcy5leHBlY3QoXFxcIihcXFwiKT8oYT10aGlzLmZpbHRlckNoYWluKCksdGhpcy5jb25zdW1lKFxcXCIpXFxcIikpOnRoaXMuZXhwZWN0KFxcXCJbXFxcIik/YT10aGlzLmFycmF5RGVjbGFyYXRpb24oKTp0aGlzLmV4cGVjdChcXFwie1xcXCIpP2E9dGhpcy5vYmplY3QoKTp0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eSh0aGlzLnBlZWsoKS50ZXh0KT9hPWZhKHRoaXMuY29uc3RhbnRzW3RoaXMuY29uc3VtZSgpLnRleHRdKTp0aGlzLnBlZWsoKS5pZGVudGlmaWVyP2E9dGhpcy5pZGVudGlmaWVyKCk6dGhpcy5wZWVrKCkuY29uc3RhbnQ/YT10aGlzLmNvbnN0YW50KCk6XFxudGhpcy50aHJvd0Vycm9yKFxcXCJub3QgYSBwcmltYXJ5IGV4cHJlc3Npb25cXFwiLHRoaXMucGVlaygpKTtmb3IodmFyIGM7Yz10aGlzLmV4cGVjdChcXFwiKFxcXCIsXFxcIltcXFwiLFxcXCIuXFxcIik7KVxcXCIoXFxcIj09PWMudGV4dD8oYT17dHlwZTpxLkNhbGxFeHByZXNzaW9uLGNhbGxlZTphLGFyZ3VtZW50czp0aGlzLnBhcnNlQXJndW1lbnRzKCl9LHRoaXMuY29uc3VtZShcXFwiKVxcXCIpKTpcXFwiW1xcXCI9PT1jLnRleHQ/KGE9e3R5cGU6cS5NZW1iZXJFeHByZXNzaW9uLG9iamVjdDphLHByb3BlcnR5OnRoaXMuZXhwcmVzc2lvbigpLGNvbXB1dGVkOiEwfSx0aGlzLmNvbnN1bWUoXFxcIl1cXFwiKSk6XFxcIi5cXFwiPT09Yy50ZXh0P2E9e3R5cGU6cS5NZW1iZXJFeHByZXNzaW9uLG9iamVjdDphLHByb3BlcnR5OnRoaXMuaWRlbnRpZmllcigpLGNvbXB1dGVkOiExfTp0aGlzLnRocm93RXJyb3IoXFxcIklNUE9TU0lCTEVcXFwiKTtyZXR1cm4gYX0sZmlsdGVyOmZ1bmN0aW9uKGEpe2E9W2FdO2Zvcih2YXIgYz17dHlwZTpxLkNhbGxFeHByZXNzaW9uLGNhbGxlZTp0aGlzLmlkZW50aWZpZXIoKSxcXG5hcmd1bWVudHM6YSxmaWx0ZXI6ITB9O3RoaXMuZXhwZWN0KFxcXCI6XFxcIik7KWEucHVzaCh0aGlzLmV4cHJlc3Npb24oKSk7cmV0dXJuIGN9LHBhcnNlQXJndW1lbnRzOmZ1bmN0aW9uKCl7dmFyIGE9W107aWYoXFxcIilcXFwiIT09dGhpcy5wZWVrVG9rZW4oKS50ZXh0KXtkbyBhLnB1c2godGhpcy5leHByZXNzaW9uKCkpO3doaWxlKHRoaXMuZXhwZWN0KFxcXCIsXFxcIikpfXJldHVybiBhfSxpZGVudGlmaWVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jb25zdW1lKCk7YS5pZGVudGlmaWVyfHx0aGlzLnRocm93RXJyb3IoXFxcImlzIG5vdCBhIHZhbGlkIGlkZW50aWZpZXJcXFwiLGEpO3JldHVybnt0eXBlOnEuSWRlbnRpZmllcixuYW1lOmEudGV4dH19LGNvbnN0YW50OmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cS5MaXRlcmFsLHZhbHVlOnRoaXMuY29uc3VtZSgpLnZhbHVlfX0sYXJyYXlEZWNsYXJhdGlvbjpmdW5jdGlvbigpe3ZhciBhPVtdO2lmKFxcXCJdXFxcIiE9PXRoaXMucGVla1Rva2VuKCkudGV4dCl7ZG97aWYodGhpcy5wZWVrKFxcXCJdXFxcIikpYnJlYWs7XFxuYS5wdXNoKHRoaXMuZXhwcmVzc2lvbigpKX13aGlsZSh0aGlzLmV4cGVjdChcXFwiLFxcXCIpKX10aGlzLmNvbnN1bWUoXFxcIl1cXFwiKTtyZXR1cm57dHlwZTpxLkFycmF5RXhwcmVzc2lvbixlbGVtZW50czphfX0sb2JqZWN0OmZ1bmN0aW9uKCl7dmFyIGE9W10sYztpZihcXFwifVxcXCIhPT10aGlzLnBlZWtUb2tlbigpLnRleHQpe2Rve2lmKHRoaXMucGVlayhcXFwifVxcXCIpKWJyZWFrO2M9e3R5cGU6cS5Qcm9wZXJ0eSxraW5kOlxcXCJpbml0XFxcIn07dGhpcy5wZWVrKCkuY29uc3RhbnQ/Yy5rZXk9dGhpcy5jb25zdGFudCgpOnRoaXMucGVlaygpLmlkZW50aWZpZXI/Yy5rZXk9dGhpcy5pZGVudGlmaWVyKCk6dGhpcy50aHJvd0Vycm9yKFxcXCJpbnZhbGlkIGtleVxcXCIsdGhpcy5wZWVrKCkpO3RoaXMuY29uc3VtZShcXFwiOlxcXCIpO2MudmFsdWU9dGhpcy5leHByZXNzaW9uKCk7YS5wdXNoKGMpfXdoaWxlKHRoaXMuZXhwZWN0KFxcXCIsXFxcIikpfXRoaXMuY29uc3VtZShcXFwifVxcXCIpO3JldHVybnt0eXBlOnEuT2JqZWN0RXhwcmVzc2lvbixwcm9wZXJ0aWVzOmF9fSxcXG50aHJvd0Vycm9yOmZ1bmN0aW9uKGEsYyl7dGhyb3cgZGEoXFxcInN5bnRheFxcXCIsYy50ZXh0LGEsYy5pbmRleCsxLHRoaXMudGV4dCx0aGlzLnRleHQuc3Vic3RyaW5nKGMuaW5kZXgpKTt9LGNvbnN1bWU6ZnVuY3Rpb24oYSl7aWYoMD09PXRoaXMudG9rZW5zLmxlbmd0aCl0aHJvdyBkYShcXFwidWVvZVxcXCIsdGhpcy50ZXh0KTt2YXIgYz10aGlzLmV4cGVjdChhKTtjfHx0aGlzLnRocm93RXJyb3IoXFxcImlzIHVuZXhwZWN0ZWQsIGV4cGVjdGluZyBbXFxcIithK1xcXCJdXFxcIix0aGlzLnBlZWsoKSk7cmV0dXJuIGN9LHBlZWtUb2tlbjpmdW5jdGlvbigpe2lmKDA9PT10aGlzLnRva2Vucy5sZW5ndGgpdGhyb3cgZGEoXFxcInVlb2VcXFwiLHRoaXMudGV4dCk7cmV0dXJuIHRoaXMudG9rZW5zWzBdfSxwZWVrOmZ1bmN0aW9uKGEsYyxkLGUpe3JldHVybiB0aGlzLnBlZWtBaGVhZCgwLGEsYyxkLGUpfSxwZWVrQWhlYWQ6ZnVuY3Rpb24oYSxjLGQsZSxmKXtpZih0aGlzLnRva2Vucy5sZW5ndGg+YSl7YT10aGlzLnRva2Vuc1thXTtcXG52YXIgZz1hLnRleHQ7aWYoZz09PWN8fGc9PT1kfHxnPT09ZXx8Zz09PWZ8fCEoY3x8ZHx8ZXx8ZikpcmV0dXJuIGF9cmV0dXJuITF9LGV4cGVjdDpmdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4oYT10aGlzLnBlZWsoYSxjLGQsZSkpPyh0aGlzLnRva2Vucy5zaGlmdCgpLGEpOiExfSxjb25zdGFudHM6e1xcXCJ0cnVlXFxcIjp7dHlwZTpxLkxpdGVyYWwsdmFsdWU6ITB9LFxcXCJmYWxzZVxcXCI6e3R5cGU6cS5MaXRlcmFsLHZhbHVlOiExfSxcXFwibnVsbFxcXCI6e3R5cGU6cS5MaXRlcmFsLHZhbHVlOm51bGx9LHVuZGVmaW5lZDp7dHlwZTpxLkxpdGVyYWwsdmFsdWU6dH0sXFxcInRoaXNcXFwiOnt0eXBlOnEuVGhpc0V4cHJlc3Npb259fX07cmQucHJvdG90eXBlPXtjb21waWxlOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9dGhpcyxlPXRoaXMuYXN0QnVpbGRlci5hc3QoYSk7dGhpcy5zdGF0ZT17bmV4dElkOjAsZmlsdGVyczp7fSxleHBlbnNpdmVDaGVja3M6Yyxmbjp7dmFyczpbXSxib2R5OltdLG93bjp7fX0sYXNzaWduOnt2YXJzOltdLFxcbmJvZHk6W10sb3duOnt9fSxpbnB1dHM6W119O1QoZSxkLiRmaWx0ZXIpO3ZhciBmPVxcXCJcXFwiLGc7dGhpcy5zdGFnZT1cXFwiYXNzaWduXFxcIjtpZihnPXBkKGUpKXRoaXMuc3RhdGUuY29tcHV0aW5nPVxcXCJhc3NpZ25cXFwiLGY9dGhpcy5uZXh0SWQoKSx0aGlzLnJlY3Vyc2UoZyxmKSxmPVxcXCJmbi5hc3NpZ249XFxcIit0aGlzLmdlbmVyYXRlRnVuY3Rpb24oXFxcImFzc2lnblxcXCIsXFxcInMsdixsXFxcIik7Zz1uZChlLmJvZHkpO2Quc3RhZ2U9XFxcImlucHV0c1xcXCI7bShnLGZ1bmN0aW9uKGEsYyl7dmFyIGU9XFxcImZuXFxcIitjO2Quc3RhdGVbZV09e3ZhcnM6W10sYm9keTpbXSxvd246e319O2Quc3RhdGUuY29tcHV0aW5nPWU7dmFyIGY9ZC5uZXh0SWQoKTtkLnJlY3Vyc2UoYSxmKTtkLnJldHVybl8oZik7ZC5zdGF0ZS5pbnB1dHMucHVzaChlKTthLndhdGNoSWQ9Y30pO3RoaXMuc3RhdGUuY29tcHV0aW5nPVxcXCJmblxcXCI7dGhpcy5zdGFnZT1cXFwibWFpblxcXCI7dGhpcy5yZWN1cnNlKGUpO2Y9J1xcXCInK3RoaXMuVVNFK1xcXCIgXFxcIit0aGlzLlNUUklDVCsnXFxcIjtcXFxcbicrdGhpcy5maWx0ZXJQcmVmaXgoKStcXG5cXFwidmFyIGZuPVxcXCIrdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uKFxcXCJmblxcXCIsXFxcInMsbCxhLGlcXFwiKStmK3RoaXMud2F0Y2hGbnMoKStcXFwicmV0dXJuIGZuO1xcXCI7Zj0obmV3IEZ1bmN0aW9uKFxcXCIkZmlsdGVyXFxcIixcXFwiZW5zdXJlU2FmZU1lbWJlck5hbWVcXFwiLFxcXCJlbnN1cmVTYWZlT2JqZWN0XFxcIixcXFwiZW5zdXJlU2FmZUZ1bmN0aW9uXFxcIixcXFwiaWZEZWZpbmVkXFxcIixcXFwicGx1c1xcXCIsXFxcInRleHRcXFwiLGYpKSh0aGlzLiRmaWx0ZXIsQ2Esb2EsbGQsWWYsbWQsYSk7dGhpcy5zdGF0ZT10aGlzLnN0YWdlPXQ7Zi5saXRlcmFsPXFkKGUpO2YuY29uc3RhbnQ9ZS5jb25zdGFudDtyZXR1cm4gZn0sVVNFOlxcXCJ1c2VcXFwiLFNUUklDVDpcXFwic3RyaWN0XFxcIix3YXRjaEZuczpmdW5jdGlvbigpe3ZhciBhPVtdLGM9dGhpcy5zdGF0ZS5pbnB1dHMsZD10aGlzO20oYyxmdW5jdGlvbihjKXthLnB1c2goXFxcInZhciBcXFwiK2MrXFxcIj1cXFwiK2QuZ2VuZXJhdGVGdW5jdGlvbihjLFxcXCJzXFxcIikpfSk7Yy5sZW5ndGgmJmEucHVzaChcXFwiZm4uaW5wdXRzPVtcXFwiK2Muam9pbihcXFwiLFxcXCIpK1xcXCJdO1xcXCIpO3JldHVybiBhLmpvaW4oXFxcIlxcXCIpfSxcXG5nZW5lcmF0ZUZ1bmN0aW9uOmZ1bmN0aW9uKGEsYyl7cmV0dXJuXFxcImZ1bmN0aW9uKFxcXCIrYytcXFwiKXtcXFwiK3RoaXMudmFyc1ByZWZpeChhKSt0aGlzLmJvZHkoYSkrXFxcIn07XFxcIn0sZmlsdGVyUHJlZml4OmZ1bmN0aW9uKCl7dmFyIGE9W10sYz10aGlzO20odGhpcy5zdGF0ZS5maWx0ZXJzLGZ1bmN0aW9uKGQsZSl7YS5wdXNoKGQrXFxcIj0kZmlsdGVyKFxcXCIrYy5lc2NhcGUoZSkrXFxcIilcXFwiKX0pO3JldHVybiBhLmxlbmd0aD9cXFwidmFyIFxcXCIrYS5qb2luKFxcXCIsXFxcIikrXFxcIjtcXFwiOlxcXCJcXFwifSx2YXJzUHJlZml4OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnN0YXRlW2FdLnZhcnMubGVuZ3RoP1xcXCJ2YXIgXFxcIit0aGlzLnN0YXRlW2FdLnZhcnMuam9pbihcXFwiLFxcXCIpK1xcXCI7XFxcIjpcXFwiXFxcIn0sYm9keTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zdGF0ZVthXS5ib2R5LmpvaW4oXFxcIlxcXCIpfSxyZWN1cnNlOmZ1bmN0aW9uKGEsYyxkLGUsZixnKXt2YXIgaCxsLGs9dGhpcyxuLHI7ZT1lfHx2O2lmKCFnJiZ3KGEud2F0Y2hJZCkpYz1jfHx0aGlzLm5leHRJZCgpLHRoaXMuaWZfKFxcXCJpXFxcIixcXG50aGlzLmxhenlBc3NpZ24oYyx0aGlzLmNvbXB1dGVkTWVtYmVyKFxcXCJpXFxcIixhLndhdGNoSWQpKSx0aGlzLmxhenlSZWN1cnNlKGEsYyxkLGUsZiwhMCkpO2Vsc2Ugc3dpdGNoKGEudHlwZSl7Y2FzZSBxLlByb2dyYW06bShhLmJvZHksZnVuY3Rpb24oYyxkKXtrLnJlY3Vyc2UoYy5leHByZXNzaW9uLHQsdCxmdW5jdGlvbihhKXtsPWF9KTtkIT09YS5ib2R5Lmxlbmd0aC0xP2suY3VycmVudCgpLmJvZHkucHVzaChsLFxcXCI7XFxcIik6ay5yZXR1cm5fKGwpfSk7YnJlYWs7Y2FzZSBxLkxpdGVyYWw6cj10aGlzLmVzY2FwZShhLnZhbHVlKTt0aGlzLmFzc2lnbihjLHIpO2Uocik7YnJlYWs7Y2FzZSBxLlVuYXJ5RXhwcmVzc2lvbjp0aGlzLnJlY3Vyc2UoYS5hcmd1bWVudCx0LHQsZnVuY3Rpb24oYSl7bD1hfSk7cj1hLm9wZXJhdG9yK1xcXCIoXFxcIit0aGlzLmlmRGVmaW5lZChsLDApK1xcXCIpXFxcIjt0aGlzLmFzc2lnbihjLHIpO2Uocik7YnJlYWs7Y2FzZSBxLkJpbmFyeUV4cHJlc3Npb246dGhpcy5yZWN1cnNlKGEubGVmdCxcXG50LHQsZnVuY3Rpb24oYSl7aD1hfSk7dGhpcy5yZWN1cnNlKGEucmlnaHQsdCx0LGZ1bmN0aW9uKGEpe2w9YX0pO3I9XFxcIitcXFwiPT09YS5vcGVyYXRvcj90aGlzLnBsdXMoaCxsKTpcXFwiLVxcXCI9PT1hLm9wZXJhdG9yP3RoaXMuaWZEZWZpbmVkKGgsMCkrYS5vcGVyYXRvcit0aGlzLmlmRGVmaW5lZChsLDApOlxcXCIoXFxcIitoK1xcXCIpXFxcIithLm9wZXJhdG9yK1xcXCIoXFxcIitsK1xcXCIpXFxcIjt0aGlzLmFzc2lnbihjLHIpO2Uocik7YnJlYWs7Y2FzZSBxLkxvZ2ljYWxFeHByZXNzaW9uOmM9Y3x8dGhpcy5uZXh0SWQoKTtrLnJlY3Vyc2UoYS5sZWZ0LGMpO2suaWZfKFxcXCImJlxcXCI9PT1hLm9wZXJhdG9yP2M6ay5ub3QoYyksay5sYXp5UmVjdXJzZShhLnJpZ2h0LGMpKTtlKGMpO2JyZWFrO2Nhc2UgcS5Db25kaXRpb25hbEV4cHJlc3Npb246Yz1jfHx0aGlzLm5leHRJZCgpO2sucmVjdXJzZShhLnRlc3QsYyk7ay5pZl8oYyxrLmxhenlSZWN1cnNlKGEuYWx0ZXJuYXRlLGMpLGsubGF6eVJlY3Vyc2UoYS5jb25zZXF1ZW50LGMpKTtlKGMpO1xcbmJyZWFrO2Nhc2UgcS5JZGVudGlmaWVyOmM9Y3x8dGhpcy5uZXh0SWQoKTtkJiYoZC5jb250ZXh0PVxcXCJpbnB1dHNcXFwiPT09ay5zdGFnZT9cXFwic1xcXCI6dGhpcy5hc3NpZ24odGhpcy5uZXh0SWQoKSx0aGlzLmdldEhhc093blByb3BlcnR5KFxcXCJsXFxcIixhLm5hbWUpK1xcXCI/bDpzXFxcIiksZC5jb21wdXRlZD0hMSxkLm5hbWU9YS5uYW1lKTtDYShhLm5hbWUpO2suaWZfKFxcXCJpbnB1dHNcXFwiPT09ay5zdGFnZXx8ay5ub3Qoay5nZXRIYXNPd25Qcm9wZXJ0eShcXFwibFxcXCIsYS5uYW1lKSksZnVuY3Rpb24oKXtrLmlmXyhcXFwiaW5wdXRzXFxcIj09PWsuc3RhZ2V8fFxcXCJzXFxcIixmdW5jdGlvbigpe2YmJjEhPT1mJiZrLmlmXyhrLm5vdChrLm5vbkNvbXB1dGVkTWVtYmVyKFxcXCJzXFxcIixhLm5hbWUpKSxrLmxhenlBc3NpZ24oay5ub25Db21wdXRlZE1lbWJlcihcXFwic1xcXCIsYS5uYW1lKSxcXFwie31cXFwiKSk7ay5hc3NpZ24oYyxrLm5vbkNvbXB1dGVkTWVtYmVyKFxcXCJzXFxcIixhLm5hbWUpKX0pfSxjJiZrLmxhenlBc3NpZ24oYyxrLm5vbkNvbXB1dGVkTWVtYmVyKFxcXCJsXFxcIixcXG5hLm5hbWUpKSk7KGsuc3RhdGUuZXhwZW5zaXZlQ2hlY2tzfHxGYihhLm5hbWUpKSYmay5hZGRFbnN1cmVTYWZlT2JqZWN0KGMpO2UoYyk7YnJlYWs7Y2FzZSBxLk1lbWJlckV4cHJlc3Npb246aD1kJiYoZC5jb250ZXh0PXRoaXMubmV4dElkKCkpfHx0aGlzLm5leHRJZCgpO2M9Y3x8dGhpcy5uZXh0SWQoKTtrLnJlY3Vyc2UoYS5vYmplY3QsaCx0LGZ1bmN0aW9uKCl7ay5pZl8oay5ub3ROdWxsKGgpLGZ1bmN0aW9uKCl7aWYoYS5jb21wdXRlZClsPWsubmV4dElkKCksay5yZWN1cnNlKGEucHJvcGVydHksbCksay5hZGRFbnN1cmVTYWZlTWVtYmVyTmFtZShsKSxmJiYxIT09ZiYmay5pZl8oay5ub3Qoay5jb21wdXRlZE1lbWJlcihoLGwpKSxrLmxhenlBc3NpZ24oay5jb21wdXRlZE1lbWJlcihoLGwpLFxcXCJ7fVxcXCIpKSxyPWsuZW5zdXJlU2FmZU9iamVjdChrLmNvbXB1dGVkTWVtYmVyKGgsbCkpLGsuYXNzaWduKGMsciksZCYmKGQuY29tcHV0ZWQ9ITAsZC5uYW1lPWwpO2Vsc2V7Q2EoYS5wcm9wZXJ0eS5uYW1lKTtcXG5mJiYxIT09ZiYmay5pZl8oay5ub3Qoay5ub25Db21wdXRlZE1lbWJlcihoLGEucHJvcGVydHkubmFtZSkpLGsubGF6eUFzc2lnbihrLm5vbkNvbXB1dGVkTWVtYmVyKGgsYS5wcm9wZXJ0eS5uYW1lKSxcXFwie31cXFwiKSk7cj1rLm5vbkNvbXB1dGVkTWVtYmVyKGgsYS5wcm9wZXJ0eS5uYW1lKTtpZihrLnN0YXRlLmV4cGVuc2l2ZUNoZWNrc3x8RmIoYS5wcm9wZXJ0eS5uYW1lKSlyPWsuZW5zdXJlU2FmZU9iamVjdChyKTtrLmFzc2lnbihjLHIpO2QmJihkLmNvbXB1dGVkPSExLGQubmFtZT1hLnByb3BlcnR5Lm5hbWUpfX0sZnVuY3Rpb24oKXtrLmFzc2lnbihjLFxcXCJ1bmRlZmluZWRcXFwiKX0pO2UoYyl9LCEhZik7YnJlYWs7Y2FzZSBxLkNhbGxFeHByZXNzaW9uOmM9Y3x8dGhpcy5uZXh0SWQoKTthLmZpbHRlcj8obD1rLmZpbHRlcihhLmNhbGxlZS5uYW1lKSxuPVtdLG0oYS5hcmd1bWVudHMsZnVuY3Rpb24oYSl7dmFyIGM9ay5uZXh0SWQoKTtrLnJlY3Vyc2UoYSxjKTtuLnB1c2goYyl9KSxyPWwrXFxuXFxcIihcXFwiK24uam9pbihcXFwiLFxcXCIpK1xcXCIpXFxcIixrLmFzc2lnbihjLHIpLGUoYykpOihsPWsubmV4dElkKCksaD17fSxuPVtdLGsucmVjdXJzZShhLmNhbGxlZSxsLGgsZnVuY3Rpb24oKXtrLmlmXyhrLm5vdE51bGwobCksZnVuY3Rpb24oKXtrLmFkZEVuc3VyZVNhZmVGdW5jdGlvbihsKTttKGEuYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2sucmVjdXJzZShhLGsubmV4dElkKCksdCxmdW5jdGlvbihhKXtuLnB1c2goay5lbnN1cmVTYWZlT2JqZWN0KGEpKX0pfSk7aC5uYW1lPyhrLnN0YXRlLmV4cGVuc2l2ZUNoZWNrc3x8ay5hZGRFbnN1cmVTYWZlT2JqZWN0KGguY29udGV4dCkscj1rLm1lbWJlcihoLmNvbnRleHQsaC5uYW1lLGguY29tcHV0ZWQpK1xcXCIoXFxcIituLmpvaW4oXFxcIixcXFwiKStcXFwiKVxcXCIpOnI9bCtcXFwiKFxcXCIrbi5qb2luKFxcXCIsXFxcIikrXFxcIilcXFwiO3I9ay5lbnN1cmVTYWZlT2JqZWN0KHIpO2suYXNzaWduKGMscil9LGZ1bmN0aW9uKCl7ay5hc3NpZ24oYyxcXFwidW5kZWZpbmVkXFxcIil9KTtlKGMpfSkpO2JyZWFrO2Nhc2UgcS5Bc3NpZ25tZW50RXhwcmVzc2lvbjpsPVxcbnRoaXMubmV4dElkKCk7aD17fTtpZighb2QoYS5sZWZ0KSl0aHJvdyBkYShcXFwibHZhbFxcXCIpO3RoaXMucmVjdXJzZShhLmxlZnQsdCxoLGZ1bmN0aW9uKCl7ay5pZl8oay5ub3ROdWxsKGguY29udGV4dCksZnVuY3Rpb24oKXtrLnJlY3Vyc2UoYS5yaWdodCxsKTtrLmFkZEVuc3VyZVNhZmVPYmplY3Qoay5tZW1iZXIoaC5jb250ZXh0LGgubmFtZSxoLmNvbXB1dGVkKSk7cj1rLm1lbWJlcihoLmNvbnRleHQsaC5uYW1lLGguY29tcHV0ZWQpK2Eub3BlcmF0b3IrbDtrLmFzc2lnbihjLHIpO2UoY3x8cil9KX0sMSk7YnJlYWs7Y2FzZSBxLkFycmF5RXhwcmVzc2lvbjpuPVtdO20oYS5lbGVtZW50cyxmdW5jdGlvbihhKXtrLnJlY3Vyc2UoYSxrLm5leHRJZCgpLHQsZnVuY3Rpb24oYSl7bi5wdXNoKGEpfSl9KTtyPVxcXCJbXFxcIituLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCI7dGhpcy5hc3NpZ24oYyxyKTtlKHIpO2JyZWFrO2Nhc2UgcS5PYmplY3RFeHByZXNzaW9uOm49W107bShhLnByb3BlcnRpZXMsZnVuY3Rpb24oYSl7ay5yZWN1cnNlKGEudmFsdWUsXFxuay5uZXh0SWQoKSx0LGZ1bmN0aW9uKGMpe24ucHVzaChrLmVzY2FwZShhLmtleS50eXBlPT09cS5JZGVudGlmaWVyP2Eua2V5Lm5hbWU6XFxcIlxcXCIrYS5rZXkudmFsdWUpK1xcXCI6XFxcIitjKX0pfSk7cj1cXFwie1xcXCIrbi5qb2luKFxcXCIsXFxcIikrXFxcIn1cXFwiO3RoaXMuYXNzaWduKGMscik7ZShyKTticmVhaztjYXNlIHEuVGhpc0V4cHJlc3Npb246dGhpcy5hc3NpZ24oYyxcXFwic1xcXCIpO2UoXFxcInNcXFwiKTticmVhaztjYXNlIHEuTkdWYWx1ZVBhcmFtZXRlcjp0aGlzLmFzc2lnbihjLFxcXCJ2XFxcIiksZShcXFwidlxcXCIpfX0sZ2V0SGFzT3duUHJvcGVydHk6ZnVuY3Rpb24oYSxjKXt2YXIgZD1hK1xcXCIuXFxcIitjLGU9dGhpcy5jdXJyZW50KCkub3duO2UuaGFzT3duUHJvcGVydHkoZCl8fChlW2RdPXRoaXMubmV4dElkKCExLGErXFxcIiYmKFxcXCIrdGhpcy5lc2NhcGUoYykrXFxcIiBpbiBcXFwiK2ErXFxcIilcXFwiKSk7cmV0dXJuIGVbZF19LGFzc2lnbjpmdW5jdGlvbihhLGMpe2lmKGEpcmV0dXJuIHRoaXMuY3VycmVudCgpLmJvZHkucHVzaChhLFxcXCI9XFxcIixjLFxcXCI7XFxcIiksYX0sZmlsdGVyOmZ1bmN0aW9uKGEpe3RoaXMuc3RhdGUuZmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhKXx8XFxuKHRoaXMuc3RhdGUuZmlsdGVyc1thXT10aGlzLm5leHRJZCghMCkpO3JldHVybiB0aGlzLnN0YXRlLmZpbHRlcnNbYV19LGlmRGVmaW5lZDpmdW5jdGlvbihhLGMpe3JldHVyblxcXCJpZkRlZmluZWQoXFxcIithK1xcXCIsXFxcIit0aGlzLmVzY2FwZShjKStcXFwiKVxcXCJ9LHBsdXM6ZnVuY3Rpb24oYSxjKXtyZXR1cm5cXFwicGx1cyhcXFwiK2ErXFxcIixcXFwiK2MrXFxcIilcXFwifSxyZXR1cm5fOmZ1bmN0aW9uKGEpe3RoaXMuY3VycmVudCgpLmJvZHkucHVzaChcXFwicmV0dXJuIFxcXCIsYSxcXFwiO1xcXCIpfSxpZl86ZnVuY3Rpb24oYSxjLGQpe2lmKCEwPT09YSljKCk7ZWxzZXt2YXIgZT10aGlzLmN1cnJlbnQoKS5ib2R5O2UucHVzaChcXFwiaWYoXFxcIixhLFxcXCIpe1xcXCIpO2MoKTtlLnB1c2goXFxcIn1cXFwiKTtkJiYoZS5wdXNoKFxcXCJlbHNle1xcXCIpLGQoKSxlLnB1c2goXFxcIn1cXFwiKSl9fSxub3Q6ZnVuY3Rpb24oYSl7cmV0dXJuXFxcIiEoXFxcIithK1xcXCIpXFxcIn0sbm90TnVsbDpmdW5jdGlvbihhKXtyZXR1cm4gYStcXFwiIT1udWxsXFxcIn0sbm9uQ29tcHV0ZWRNZW1iZXI6ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYStcXG5cXFwiLlxcXCIrY30sY29tcHV0ZWRNZW1iZXI6ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYStcXFwiW1xcXCIrYytcXFwiXVxcXCJ9LG1lbWJlcjpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGQ/dGhpcy5jb21wdXRlZE1lbWJlcihhLGMpOnRoaXMubm9uQ29tcHV0ZWRNZW1iZXIoYSxjKX0sYWRkRW5zdXJlU2FmZU9iamVjdDpmdW5jdGlvbihhKXt0aGlzLmN1cnJlbnQoKS5ib2R5LnB1c2godGhpcy5lbnN1cmVTYWZlT2JqZWN0KGEpLFxcXCI7XFxcIil9LGFkZEVuc3VyZVNhZmVNZW1iZXJOYW1lOmZ1bmN0aW9uKGEpe3RoaXMuY3VycmVudCgpLmJvZHkucHVzaCh0aGlzLmVuc3VyZVNhZmVNZW1iZXJOYW1lKGEpLFxcXCI7XFxcIil9LGFkZEVuc3VyZVNhZmVGdW5jdGlvbjpmdW5jdGlvbihhKXt0aGlzLmN1cnJlbnQoKS5ib2R5LnB1c2godGhpcy5lbnN1cmVTYWZlRnVuY3Rpb24oYSksXFxcIjtcXFwiKX0sZW5zdXJlU2FmZU9iamVjdDpmdW5jdGlvbihhKXtyZXR1cm5cXFwiZW5zdXJlU2FmZU9iamVjdChcXFwiK2ErXFxcIix0ZXh0KVxcXCJ9LGVuc3VyZVNhZmVNZW1iZXJOYW1lOmZ1bmN0aW9uKGEpe3JldHVyblxcXCJlbnN1cmVTYWZlTWVtYmVyTmFtZShcXFwiK1xcbmErXFxcIix0ZXh0KVxcXCJ9LGVuc3VyZVNhZmVGdW5jdGlvbjpmdW5jdGlvbihhKXtyZXR1cm5cXFwiZW5zdXJlU2FmZUZ1bmN0aW9uKFxcXCIrYStcXFwiLHRleHQpXFxcIn0sbGF6eVJlY3Vyc2U6ZnVuY3Rpb24oYSxjLGQsZSxmLGcpe3ZhciBoPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKCl7aC5yZWN1cnNlKGEsYyxkLGUsZixnKX19LGxhenlBc3NpZ246ZnVuY3Rpb24oYSxjKXt2YXIgZD10aGlzO3JldHVybiBmdW5jdGlvbigpe2QuYXNzaWduKGEsYyl9fSxzdHJpbmdFc2NhcGVSZWdleDovW14gYS16QS1aMC05XS9nLHN0cmluZ0VzY2FwZUZuOmZ1bmN0aW9uKGEpe3JldHVyblxcXCJcXFxcXFxcXHVcXFwiKyhcXFwiMDAwMFxcXCIrYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpfSxlc2NhcGU6ZnVuY3Rpb24oYSl7aWYoTChhKSlyZXR1cm5cXFwiJ1xcXCIrYS5yZXBsYWNlKHRoaXMuc3RyaW5nRXNjYXBlUmVnZXgsdGhpcy5zdHJpbmdFc2NhcGVGbikrXFxcIidcXFwiO2lmKFYoYSkpcmV0dXJuIGEudG9TdHJpbmcoKTtpZighMD09PWEpcmV0dXJuXFxcInRydWVcXFwiO1xcbmlmKCExPT09YSlyZXR1cm5cXFwiZmFsc2VcXFwiO2lmKG51bGw9PT1hKXJldHVyblxcXCJudWxsXFxcIjtpZihcXFwidW5kZWZpbmVkXFxcIj09PXR5cGVvZiBhKXJldHVyblxcXCJ1bmRlZmluZWRcXFwiO3Rocm93IGRhKFxcXCJlc2NcXFwiKTt9LG5leHRJZDpmdW5jdGlvbihhLGMpe3ZhciBkPVxcXCJ2XFxcIit0aGlzLnN0YXRlLm5leHRJZCsrO2F8fHRoaXMuY3VycmVudCgpLnZhcnMucHVzaChkKyhjP1xcXCI9XFxcIitjOlxcXCJcXFwiKSk7cmV0dXJuIGR9LGN1cnJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZVt0aGlzLnN0YXRlLmNvbXB1dGluZ119fTtzZC5wcm90b3R5cGU9e2NvbXBpbGU6ZnVuY3Rpb24oYSxjKXt2YXIgZD10aGlzLGU9dGhpcy5hc3RCdWlsZGVyLmFzdChhKTt0aGlzLmV4cHJlc3Npb249YTt0aGlzLmV4cGVuc2l2ZUNoZWNrcz1jO1QoZSxkLiRmaWx0ZXIpO3ZhciBmLGc7aWYoZj1wZChlKSlnPXRoaXMucmVjdXJzZShmKTtmPW5kKGUuYm9keSk7dmFyIGg7ZiYmKGg9W10sbShmLGZ1bmN0aW9uKGEsYyl7dmFyIGU9ZC5yZWN1cnNlKGEpO1xcbmEuaW5wdXQ9ZTtoLnB1c2goZSk7YS53YXRjaElkPWN9KSk7dmFyIGw9W107bShlLmJvZHksZnVuY3Rpb24oYSl7bC5wdXNoKGQucmVjdXJzZShhLmV4cHJlc3Npb24pKX0pO2Y9MD09PWUuYm9keS5sZW5ndGg/ZnVuY3Rpb24oKXt9OjE9PT1lLmJvZHkubGVuZ3RoP2xbMF06ZnVuY3Rpb24oYSxjKXt2YXIgZDttKGwsZnVuY3Rpb24oZSl7ZD1lKGEsYyl9KTtyZXR1cm4gZH07ZyYmKGYuYXNzaWduPWZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZyhhLGQsYyl9KTtoJiYoZi5pbnB1dHM9aCk7Zi5saXRlcmFsPXFkKGUpO2YuY29uc3RhbnQ9ZS5jb25zdGFudDtyZXR1cm4gZn0scmVjdXJzZTpmdW5jdGlvbihhLGMsZCl7dmFyIGUsZixnPXRoaXMsaDtpZihhLmlucHV0KXJldHVybiB0aGlzLmlucHV0cyhhLmlucHV0LGEud2F0Y2hJZCk7c3dpdGNoKGEudHlwZSl7Y2FzZSBxLkxpdGVyYWw6cmV0dXJuIHRoaXMudmFsdWUoYS52YWx1ZSxjKTtjYXNlIHEuVW5hcnlFeHByZXNzaW9uOnJldHVybiBmPVxcbnRoaXMucmVjdXJzZShhLmFyZ3VtZW50KSx0aGlzW1xcXCJ1bmFyeVxcXCIrYS5vcGVyYXRvcl0oZixjKTtjYXNlIHEuQmluYXJ5RXhwcmVzc2lvbjpyZXR1cm4gZT10aGlzLnJlY3Vyc2UoYS5sZWZ0KSxmPXRoaXMucmVjdXJzZShhLnJpZ2h0KSx0aGlzW1xcXCJiaW5hcnlcXFwiK2Eub3BlcmF0b3JdKGUsZixjKTtjYXNlIHEuTG9naWNhbEV4cHJlc3Npb246cmV0dXJuIGU9dGhpcy5yZWN1cnNlKGEubGVmdCksZj10aGlzLnJlY3Vyc2UoYS5yaWdodCksdGhpc1tcXFwiYmluYXJ5XFxcIithLm9wZXJhdG9yXShlLGYsYyk7Y2FzZSBxLkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpyZXR1cm4gdGhpc1tcXFwidGVybmFyeT86XFxcIl0odGhpcy5yZWN1cnNlKGEudGVzdCksdGhpcy5yZWN1cnNlKGEuYWx0ZXJuYXRlKSx0aGlzLnJlY3Vyc2UoYS5jb25zZXF1ZW50KSxjKTtjYXNlIHEuSWRlbnRpZmllcjpyZXR1cm4gQ2EoYS5uYW1lLGcuZXhwcmVzc2lvbiksZy5pZGVudGlmaWVyKGEubmFtZSxnLmV4cGVuc2l2ZUNoZWNrc3x8RmIoYS5uYW1lKSxcXG5jLGQsZy5leHByZXNzaW9uKTtjYXNlIHEuTWVtYmVyRXhwcmVzc2lvbjpyZXR1cm4gZT10aGlzLnJlY3Vyc2UoYS5vYmplY3QsITEsISFkKSxhLmNvbXB1dGVkfHwoQ2EoYS5wcm9wZXJ0eS5uYW1lLGcuZXhwcmVzc2lvbiksZj1hLnByb3BlcnR5Lm5hbWUpLGEuY29tcHV0ZWQmJihmPXRoaXMucmVjdXJzZShhLnByb3BlcnR5KSksYS5jb21wdXRlZD90aGlzLmNvbXB1dGVkTWVtYmVyKGUsZixjLGQsZy5leHByZXNzaW9uKTp0aGlzLm5vbkNvbXB1dGVkTWVtYmVyKGUsZixnLmV4cGVuc2l2ZUNoZWNrcyxjLGQsZy5leHByZXNzaW9uKTtjYXNlIHEuQ2FsbEV4cHJlc3Npb246cmV0dXJuIGg9W10sbShhLmFyZ3VtZW50cyxmdW5jdGlvbihhKXtoLnB1c2goZy5yZWN1cnNlKGEpKX0pLGEuZmlsdGVyJiYoZj10aGlzLiRmaWx0ZXIoYS5jYWxsZWUubmFtZSkpLGEuZmlsdGVyfHwoZj10aGlzLnJlY3Vyc2UoYS5jYWxsZWUsITApKSxhLmZpbHRlcj9mdW5jdGlvbihhLGQsZSxnKXtmb3IodmFyIG09XFxuW10scT0wO3E8aC5sZW5ndGg7KytxKW0ucHVzaChoW3FdKGEsZCxlLGcpKTthPWYuYXBwbHkodCxtLGcpO3JldHVybiBjP3tjb250ZXh0OnQsbmFtZTp0LHZhbHVlOmF9OmF9OmZ1bmN0aW9uKGEsZCxlLHIpe3ZhciBtPWYoYSxkLGUscikscTtpZihudWxsIT1tLnZhbHVlKXtvYShtLmNvbnRleHQsZy5leHByZXNzaW9uKTtsZChtLnZhbHVlLGcuZXhwcmVzc2lvbik7cT1bXTtmb3IodmFyIHQ9MDt0PGgubGVuZ3RoOysrdClxLnB1c2gob2EoaFt0XShhLGQsZSxyKSxnLmV4cHJlc3Npb24pKTtxPW9hKG0udmFsdWUuYXBwbHkobS5jb250ZXh0LHEpLGcuZXhwcmVzc2lvbil9cmV0dXJuIGM/e3ZhbHVlOnF9OnF9O2Nhc2UgcS5Bc3NpZ25tZW50RXhwcmVzc2lvbjpyZXR1cm4gZT10aGlzLnJlY3Vyc2UoYS5sZWZ0LCEwLDEpLGY9dGhpcy5yZWN1cnNlKGEucmlnaHQpLGZ1bmN0aW9uKGEsZCxoLHIpe3ZhciBtPWUoYSxkLGgscik7YT1mKGEsZCxoLHIpO29hKG0udmFsdWUsZy5leHByZXNzaW9uKTtcXG5tLmNvbnRleHRbbS5uYW1lXT1hO3JldHVybiBjP3t2YWx1ZTphfTphfTtjYXNlIHEuQXJyYXlFeHByZXNzaW9uOnJldHVybiBoPVtdLG0oYS5lbGVtZW50cyxmdW5jdGlvbihhKXtoLnB1c2goZy5yZWN1cnNlKGEpKX0pLGZ1bmN0aW9uKGEsZCxlLGYpe2Zvcih2YXIgZz1bXSxtPTA7bTxoLmxlbmd0aDsrK20pZy5wdXNoKGhbbV0oYSxkLGUsZikpO3JldHVybiBjP3t2YWx1ZTpnfTpnfTtjYXNlIHEuT2JqZWN0RXhwcmVzc2lvbjpyZXR1cm4gaD1bXSxtKGEucHJvcGVydGllcyxmdW5jdGlvbihhKXtoLnB1c2goe2tleTphLmtleS50eXBlPT09cS5JZGVudGlmaWVyP2Eua2V5Lm5hbWU6XFxcIlxcXCIrYS5rZXkudmFsdWUsdmFsdWU6Zy5yZWN1cnNlKGEudmFsdWUpfSl9KSxmdW5jdGlvbihhLGQsZSxmKXtmb3IodmFyIGc9e30sbT0wO208aC5sZW5ndGg7KyttKWdbaFttXS5rZXldPWhbbV0udmFsdWUoYSxkLGUsZik7cmV0dXJuIGM/e3ZhbHVlOmd9Omd9O2Nhc2UgcS5UaGlzRXhwcmVzc2lvbjpyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGM/XFxue3ZhbHVlOmF9OmF9O2Nhc2UgcS5OR1ZhbHVlUGFyYW1ldGVyOnJldHVybiBmdW5jdGlvbihhLGQsZSxmKXtyZXR1cm4gYz97dmFsdWU6ZX06ZX19fSxcXFwidW5hcnkrXFxcIjpmdW5jdGlvbihhLGMpe3JldHVybiBmdW5jdGlvbihkLGUsZixnKXtkPWEoZCxlLGYsZyk7ZD13KGQpPytkOjA7cmV0dXJuIGM/e3ZhbHVlOmR9OmR9fSxcXFwidW5hcnktXFxcIjpmdW5jdGlvbihhLGMpe3JldHVybiBmdW5jdGlvbihkLGUsZixnKXtkPWEoZCxlLGYsZyk7ZD13KGQpPy1kOjA7cmV0dXJuIGM/e3ZhbHVlOmR9OmR9fSxcXFwidW5hcnkhXFxcIjpmdW5jdGlvbihhLGMpe3JldHVybiBmdW5jdGlvbihkLGUsZixnKXtkPSFhKGQsZSxmLGcpO3JldHVybiBjP3t2YWx1ZTpkfTpkfX0sXFxcImJpbmFyeStcXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxmLGcsaCl7dmFyIGw9YShlLGYsZyxoKTtlPWMoZSxmLGcsaCk7bD1tZChsLGUpO3JldHVybiBkP3t2YWx1ZTpsfTpsfX0sXFxcImJpbmFyeS1cXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxcXG5mLGcsaCl7dmFyIGw9YShlLGYsZyxoKTtlPWMoZSxmLGcsaCk7bD0odyhsKT9sOjApLSh3KGUpP2U6MCk7cmV0dXJuIGQ/e3ZhbHVlOmx9Omx9fSxcXFwiYmluYXJ5KlxcXCI6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBmdW5jdGlvbihlLGYsZyxoKXtlPWEoZSxmLGcsaCkqYyhlLGYsZyxoKTtyZXR1cm4gZD97dmFsdWU6ZX06ZX19LFxcXCJiaW5hcnkvXFxcIjpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGZ1bmN0aW9uKGUsZixnLGgpe2U9YShlLGYsZyxoKS9jKGUsZixnLGgpO3JldHVybiBkP3t2YWx1ZTplfTplfX0sXFxcImJpbmFyeSVcXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxmLGcsaCl7ZT1hKGUsZixnLGgpJWMoZSxmLGcsaCk7cmV0dXJuIGQ/e3ZhbHVlOmV9OmV9fSxcXFwiYmluYXJ5PT09XFxcIjpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGZ1bmN0aW9uKGUsZixnLGgpe2U9YShlLGYsZyxoKT09PWMoZSxmLGcsaCk7cmV0dXJuIGQ/e3ZhbHVlOmV9OmV9fSxcXFwiYmluYXJ5IT09XFxcIjpmdW5jdGlvbihhLFxcbmMsZCl7cmV0dXJuIGZ1bmN0aW9uKGUsZixnLGgpe2U9YShlLGYsZyxoKSE9PWMoZSxmLGcsaCk7cmV0dXJuIGQ/e3ZhbHVlOmV9OmV9fSxcXFwiYmluYXJ5PT1cXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxmLGcsaCl7ZT1hKGUsZixnLGgpPT1jKGUsZixnLGgpO3JldHVybiBkP3t2YWx1ZTplfTplfX0sXFxcImJpbmFyeSE9XFxcIjpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGZ1bmN0aW9uKGUsZixnLGgpe2U9YShlLGYsZyxoKSE9YyhlLGYsZyxoKTtyZXR1cm4gZD97dmFsdWU6ZX06ZX19LFxcXCJiaW5hcnk8XFxcIjpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGZ1bmN0aW9uKGUsZixnLGgpe2U9YShlLGYsZyxoKTxjKGUsZixnLGgpO3JldHVybiBkP3t2YWx1ZTplfTplfX0sXFxcImJpbmFyeT5cXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxmLGcsaCl7ZT1hKGUsZixnLGgpPmMoZSxmLGcsaCk7cmV0dXJuIGQ/e3ZhbHVlOmV9OmV9fSxcXFwiYmluYXJ5PD1cXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxcXG5mLGcsaCl7ZT1hKGUsZixnLGgpPD1jKGUsZixnLGgpO3JldHVybiBkP3t2YWx1ZTplfTplfX0sXFxcImJpbmFyeT49XFxcIjpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGZ1bmN0aW9uKGUsZixnLGgpe2U9YShlLGYsZyxoKT49YyhlLGYsZyxoKTtyZXR1cm4gZD97dmFsdWU6ZX06ZX19LFxcXCJiaW5hcnkmJlxcXCI6ZnVuY3Rpb24oYSxjLGQpe3JldHVybiBmdW5jdGlvbihlLGYsZyxoKXtlPWEoZSxmLGcsaCkmJmMoZSxmLGcsaCk7cmV0dXJuIGQ/e3ZhbHVlOmV9OmV9fSxcXFwiYmluYXJ5fHxcXFwiOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZSxmLGcsaCl7ZT1hKGUsZixnLGgpfHxjKGUsZixnLGgpO3JldHVybiBkP3t2YWx1ZTplfTplfX0sXFxcInRlcm5hcnk/OlxcXCI6ZnVuY3Rpb24oYSxjLGQsZSl7cmV0dXJuIGZ1bmN0aW9uKGYsZyxoLGwpe2Y9YShmLGcsaCxsKT9jKGYsZyxoLGwpOmQoZixnLGgsbCk7cmV0dXJuIGU/e3ZhbHVlOmZ9OmZ9fSx2YWx1ZTpmdW5jdGlvbihhLGMpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBjP1xcbntjb250ZXh0OnQsbmFtZTp0LHZhbHVlOmF9OmF9fSxpZGVudGlmaWVyOmZ1bmN0aW9uKGEsYyxkLGUsZil7cmV0dXJuIGZ1bmN0aW9uKGcsaCxsLGspe2c9aCYmYSBpbiBoP2g6ZztlJiYxIT09ZSYmZyYmIWdbYV0mJihnW2FdPXt9KTtoPWc/Z1thXTp0O2MmJm9hKGgsZik7cmV0dXJuIGQ/e2NvbnRleHQ6ZyxuYW1lOmEsdmFsdWU6aH06aH19LGNvbXB1dGVkTWVtYmVyOmZ1bmN0aW9uKGEsYyxkLGUsZil7cmV0dXJuIGZ1bmN0aW9uKGcsaCxsLGspe3ZhciBuPWEoZyxoLGwsayksbSxzO251bGwhPW4mJihtPWMoZyxoLGwsayksQ2EobSxmKSxlJiYxIT09ZSYmbiYmIW5bbV0mJihuW21dPXt9KSxzPW5bbV0sb2EocyxmKSk7cmV0dXJuIGQ/e2NvbnRleHQ6bixuYW1lOm0sdmFsdWU6c306c319LG5vbkNvbXB1dGVkTWVtYmVyOmZ1bmN0aW9uKGEsYyxkLGUsZixnKXtyZXR1cm4gZnVuY3Rpb24oaCxsLGssbil7aD1hKGgsbCxrLG4pO2YmJjEhPT1mJiZoJiYhaFtjXSYmKGhbY109e30pO1xcbmw9bnVsbCE9aD9oW2NdOnQ7KGR8fEZiKGMpKSYmb2EobCxnKTtyZXR1cm4gZT97Y29udGV4dDpoLG5hbWU6Yyx2YWx1ZTpsfTpsfX0saW5wdXRzOmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGZ1bmN0aW9uKGQsZSxmLGcpe3JldHVybiBnP2dbY106YShkLGUsZil9fX07dmFyIGhjPWZ1bmN0aW9uKGEsYyxkKXt0aGlzLmxleGVyPWE7dGhpcy4kZmlsdGVyPWM7dGhpcy5vcHRpb25zPWQ7dGhpcy5hc3Q9bmV3IHEodGhpcy5sZXhlcik7dGhpcy5hc3RDb21waWxlcj1kLmNzcD9uZXcgc2QodGhpcy5hc3QsYyk6bmV3IHJkKHRoaXMuYXN0LGMpfTtoYy5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmhjLHBhcnNlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmFzdENvbXBpbGVyLmNvbXBpbGUoYSx0aGlzLm9wdGlvbnMuZXhwZW5zaXZlQ2hlY2tzKX19O2dhKCk7Z2EoKTt2YXIgWmY9T2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLERhPUooXFxcIiRzY2VcXFwiKSxwYT17SFRNTDpcXFwiaHRtbFxcXCIsQ1NTOlxcXCJjc3NcXFwiLFVSTDpcXFwidXJsXFxcIixcXG5SRVNPVVJDRV9VUkw6XFxcInJlc291cmNlVXJsXFxcIixKUzpcXFwianNcXFwifSxlYT1KKFxcXCIkY29tcGlsZVxcXCIpLFg9VS5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIiksd2Q9QmEoTy5sb2NhdGlvbi5ocmVmKTt4ZC4kaW5qZWN0PVtcXFwiJGRvY3VtZW50XFxcIl07TGMuJGluamVjdD1bXFxcIiRwcm92aWRlXFxcIl07eWQuJGluamVjdD1bXFxcIiRsb2NhbGVcXFwiXTtBZC4kaW5qZWN0PVtcXFwiJGxvY2FsZVxcXCJdO3ZhciBEZD1cXFwiLlxcXCIsaWc9e3l5eXk6WShcXFwiRnVsbFllYXJcXFwiLDQpLHl5OlkoXFxcIkZ1bGxZZWFyXFxcIiwyLDAsITApLHk6WShcXFwiRnVsbFllYXJcXFwiLDEpLE1NTU06SGIoXFxcIk1vbnRoXFxcIiksTU1NOkhiKFxcXCJNb250aFxcXCIsITApLE1NOlkoXFxcIk1vbnRoXFxcIiwyLDEpLE06WShcXFwiTW9udGhcXFwiLDEsMSksZGQ6WShcXFwiRGF0ZVxcXCIsMiksZDpZKFxcXCJEYXRlXFxcIiwxKSxISDpZKFxcXCJIb3Vyc1xcXCIsMiksSDpZKFxcXCJIb3Vyc1xcXCIsMSksaGg6WShcXFwiSG91cnNcXFwiLDIsLTEyKSxoOlkoXFxcIkhvdXJzXFxcIiwxLC0xMiksbW06WShcXFwiTWludXRlc1xcXCIsMiksbTpZKFxcXCJNaW51dGVzXFxcIiwxKSxzczpZKFxcXCJTZWNvbmRzXFxcIiwyKSxzOlkoXFxcIlNlY29uZHNcXFwiLFxcbjEpLHNzczpZKFxcXCJNaWxsaXNlY29uZHNcXFwiLDMpLEVFRUU6SGIoXFxcIkRheVxcXCIpLEVFRTpIYihcXFwiRGF5XFxcIiwhMCksYTpmdW5jdGlvbihhLGMpe3JldHVybiAxMj5hLmdldEhvdXJzKCk/Yy5BTVBNU1swXTpjLkFNUE1TWzFdfSxaOmZ1bmN0aW9uKGEsYyxkKXthPS0xKmQ7cmV0dXJuIGE9KDA8PWE/XFxcIitcXFwiOlxcXCJcXFwiKSsoR2IoTWF0aFswPGE/XFxcImZsb29yXFxcIjpcXFwiY2VpbFxcXCJdKGEvNjApLDIpK0diKE1hdGguYWJzKGElNjApLDIpKX0sd3c6RmQoMiksdzpGZCgxKSxHOmpjLEdHOmpjLEdHRzpqYyxHR0dHOmZ1bmN0aW9uKGEsYyl7cmV0dXJuIDA+PWEuZ2V0RnVsbFllYXIoKT9jLkVSQU5BTUVTWzBdOmMuRVJBTkFNRVNbMV19fSxoZz0vKCg/OlteeU1kSGhtc2FaRXdHJ10rKXwoPzonKD86W14nXXwnJykqJyl8KD86RSt8eSt8TSt8ZCt8SCt8aCt8bSt8cyt8YXxafEcrfHcrKSkoLiopLyxnZz0vXlxcXFwtP1xcXFxkKyQvO3pkLiRpbmplY3Q9W1xcXCIkbG9jYWxlXFxcIl07dmFyIGRnPXJhKE0pLGVnPXJhKHJiKTtCZC4kaW5qZWN0PVxcbltcXFwiJHBhcnNlXFxcIl07dmFyIGllPXJhKHtyZXN0cmljdDpcXFwiRVxcXCIsY29tcGlsZTpmdW5jdGlvbihhLGMpe2lmKCFjLmhyZWYmJiFjLnhsaW5rSHJlZilyZXR1cm4gZnVuY3Rpb24oYSxjKXtpZihcXFwiYVxcXCI9PT1jWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpe3ZhciBmPVxcXCJbb2JqZWN0IFNWR0FuaW1hdGVkU3RyaW5nXVxcXCI9PT1zYS5jYWxsKGMucHJvcChcXFwiaHJlZlxcXCIpKT9cXFwieGxpbms6aHJlZlxcXCI6XFxcImhyZWZcXFwiO2Mub24oXFxcImNsaWNrXFxcIixmdW5jdGlvbihhKXtjLmF0dHIoZil8fGEucHJldmVudERlZmF1bHQoKX0pfX19fSksc2I9e307bShBYixmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGQoYSxkLGYpe2EuJHdhdGNoKGZbZV0sZnVuY3Rpb24oYSl7Zi4kc2V0KGMsISFhKX0pfWlmKFxcXCJtdWx0aXBsZVxcXCIhPWEpe3ZhciBlPXdhKFxcXCJuZy1cXFwiK2MpLGY9ZDtcXFwiY2hlY2tlZFxcXCI9PT1hJiYoZj1mdW5jdGlvbihhLGMsZil7Zi5uZ01vZGVsIT09ZltlXSYmZChhLGMsZil9KTtzYltlXT1mdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsXFxucHJpb3JpdHk6MTAwLGxpbms6Zn19fX0pO20oVWMsZnVuY3Rpb24oYSxjKXtzYltjXT1mdW5jdGlvbigpe3JldHVybntwcmlvcml0eToxMDAsbGluazpmdW5jdGlvbihhLGUsZil7aWYoXFxcIm5nUGF0dGVyblxcXCI9PT1jJiZcXFwiL1xcXCI9PWYubmdQYXR0ZXJuLmNoYXJBdCgwKSYmKGU9Zi5uZ1BhdHRlcm4ubWF0Y2goa2cpKSl7Zi4kc2V0KFxcXCJuZ1BhdHRlcm5cXFwiLG5ldyBSZWdFeHAoZVsxXSxlWzJdKSk7cmV0dXJufWEuJHdhdGNoKGZbY10sZnVuY3Rpb24oYSl7Zi4kc2V0KGMsYSl9KX19fX0pO20oW1xcXCJzcmNcXFwiLFxcXCJzcmNzZXRcXFwiLFxcXCJocmVmXFxcIl0sZnVuY3Rpb24oYSl7dmFyIGM9d2EoXFxcIm5nLVxcXCIrYSk7c2JbY109ZnVuY3Rpb24oKXtyZXR1cm57cHJpb3JpdHk6OTksbGluazpmdW5jdGlvbihkLGUsZil7dmFyIGc9YSxoPWE7XFxcImhyZWZcXFwiPT09YSYmXFxcIltvYmplY3QgU1ZHQW5pbWF0ZWRTdHJpbmddXFxcIj09PXNhLmNhbGwoZS5wcm9wKFxcXCJocmVmXFxcIikpJiYoaD1cXFwieGxpbmtIcmVmXFxcIixmLiRhdHRyW2hdPVxcXCJ4bGluazpocmVmXFxcIixcXG5nPW51bGwpO2YuJG9ic2VydmUoYyxmdW5jdGlvbihjKXtjPyhmLiRzZXQoaCxjKSxVYSYmZyYmZS5wcm9wKGcsZltoXSkpOlxcXCJocmVmXFxcIj09PWEmJmYuJHNldChoLG51bGwpfSl9fX19KTt2YXIgSWI9eyRhZGRDb250cm9sOnYsJCRyZW5hbWVDb250cm9sOmZ1bmN0aW9uKGEsYyl7YS4kbmFtZT1jfSwkcmVtb3ZlQ29udHJvbDp2LCRzZXRWYWxpZGl0eTp2LCRzZXREaXJ0eTp2LCRzZXRQcmlzdGluZTp2LCRzZXRTdWJtaXR0ZWQ6dn07R2QuJGluamVjdD1bXFxcIiRlbGVtZW50XFxcIixcXFwiJGF0dHJzXFxcIixcXFwiJHNjb3BlXFxcIixcXFwiJGFuaW1hdGVcXFwiLFxcXCIkaW50ZXJwb2xhdGVcXFwiXTt2YXIgT2Q9ZnVuY3Rpb24oYSl7cmV0dXJuW1xcXCIkdGltZW91dFxcXCIsZnVuY3Rpb24oYyl7cmV0dXJue25hbWU6XFxcImZvcm1cXFwiLHJlc3RyaWN0OmE/XFxcIkVBQ1xcXCI6XFxcIkVcXFwiLGNvbnRyb2xsZXI6R2QsY29tcGlsZTpmdW5jdGlvbihkLGUpe2QuYWRkQ2xhc3MoVmEpLmFkZENsYXNzKG1iKTt2YXIgZj1lLm5hbWU/XFxcIm5hbWVcXFwiOmEmJmUubmdGb3JtP1xcXCJuZ0Zvcm1cXFwiOlxcbiExO3JldHVybntwcmU6ZnVuY3Rpb24oYSxkLGUsayl7aWYoIShcXFwiYWN0aW9uXFxcImluIGUpKXt2YXIgbj1mdW5jdGlvbihjKXthLiRhcHBseShmdW5jdGlvbigpe2suJGNvbW1pdFZpZXdWYWx1ZSgpO2suJHNldFN1Ym1pdHRlZCgpfSk7Yy5wcmV2ZW50RGVmYXVsdCgpfTtkWzBdLmFkZEV2ZW50TGlzdGVuZXIoXFxcInN1Ym1pdFxcXCIsbiwhMSk7ZC5vbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7YyhmdW5jdGlvbigpe2RbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwic3VibWl0XFxcIixuLCExKX0sMCwhMSl9KX12YXIgbT1rLiQkcGFyZW50Rm9ybTtmJiYoRWIoYSxrLiRuYW1lLGssay4kbmFtZSksZS4kb2JzZXJ2ZShmLGZ1bmN0aW9uKGMpe2suJG5hbWUhPT1jJiYoRWIoYSxrLiRuYW1lLHQsay4kbmFtZSksbS4kJHJlbmFtZUNvbnRyb2woayxjKSxFYihhLGsuJG5hbWUsayxrLiRuYW1lKSl9KSk7ZC5vbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7bS4kcmVtb3ZlQ29udHJvbChrKTtmJiZFYihhLGVbZl0sdCxcXG5rLiRuYW1lKTtQKGssSWIpfSl9fX19fV19LGplPU9kKCksd2U9T2QoITApLGpnPS9cXFxcZHs0fS1bMDFdXFxcXGQtWzAtM11cXFxcZFRbMC0yXVxcXFxkOlswLTVdXFxcXGQ6WzAtNV1cXFxcZFxcXFwuXFxcXGQrKFsrLV1bMC0yXVxcXFxkOlswLTVdXFxcXGR8WikvLHNnPS9eKGZ0cHxodHRwfGh0dHBzKTpcXFxcL1xcXFwvKFxcXFx3Kzp7MCwxfVxcXFx3KkApPyhcXFxcUyspKDpbMC05XSspPyhcXFxcL3xcXFxcLyhbXFxcXHcjITouPys9JiVAIVxcXFwtXFxcXC9dKSk/JC8sdGc9L15bYS16MC05ISMkJSYnKitcXFxcLz0/Xl9ge3x9fi4tXStAW2EtejAtOV0oW2EtejAtOS1dKlthLXowLTldKT8oXFxcXC5bYS16MC05XShbYS16MC05LV0qW2EtejAtOV0pPykqJC9pLHVnPS9eXFxcXHMqKFxcXFwtfFxcXFwrKT8oXFxcXGQrfChcXFxcZCooXFxcXC5cXFxcZCopKSkoW2VFXVsrLV0/XFxcXGQrKT9cXFxccyokLyxQZD0vXihcXFxcZHs0fSktKFxcXFxkezJ9KS0oXFxcXGR7Mn0pJC8sUWQ9L14oXFxcXGR7NH0pLShcXFxcZFxcXFxkKS0oXFxcXGRcXFxcZClUKFxcXFxkXFxcXGQpOihcXFxcZFxcXFxkKSg/OjooXFxcXGRcXFxcZCkoXFxcXC5cXFxcZHsxLDN9KT8pPyQvLG1jPS9eKFxcXFxkezR9KS1XKFxcXFxkXFxcXGQpJC8sUmQ9L14oXFxcXGR7NH0pLShcXFxcZFxcXFxkKSQvLFxcblNkPS9eKFxcXFxkXFxcXGQpOihcXFxcZFxcXFxkKSg/OjooXFxcXGRcXFxcZCkoXFxcXC5cXFxcZHsxLDN9KT8pPyQvLFRkPXt0ZXh0OmZ1bmN0aW9uKGEsYyxkLGUsZixnKXtrYihhLGMsZCxlLGYsZyk7a2MoZSl9LGRhdGU6bGIoXFxcImRhdGVcXFwiLFBkLEtiKFBkLFtcXFwieXl5eVxcXCIsXFxcIk1NXFxcIixcXFwiZGRcXFwiXSksXFxcInl5eXktTU0tZGRcXFwiKSxcXFwiZGF0ZXRpbWUtbG9jYWxcXFwiOmxiKFxcXCJkYXRldGltZWxvY2FsXFxcIixRZCxLYihRZCxcXFwieXl5eSBNTSBkZCBISCBtbSBzcyBzc3NcXFwiLnNwbGl0KFxcXCIgXFxcIikpLFxcXCJ5eXl5LU1NLWRkVEhIOm1tOnNzLnNzc1xcXCIpLHRpbWU6bGIoXFxcInRpbWVcXFwiLFNkLEtiKFNkLFtcXFwiSEhcXFwiLFxcXCJtbVxcXCIsXFxcInNzXFxcIixcXFwic3NzXFxcIl0pLFxcXCJISDptbTpzcy5zc3NcXFwiKSx3ZWVrOmxiKFxcXCJ3ZWVrXFxcIixtYyxmdW5jdGlvbihhLGMpe2lmKGFhKGEpKXJldHVybiBhO2lmKEwoYSkpe21jLmxhc3RJbmRleD0wO3ZhciBkPW1jLmV4ZWMoYSk7aWYoZCl7dmFyIGU9K2RbMV0sZj0rZFsyXSxnPWQ9MCxoPTAsbD0wLGs9RWQoZSksZj03KihmLTEpO2MmJihkPWMuZ2V0SG91cnMoKSxnPVxcbmMuZ2V0TWludXRlcygpLGg9Yy5nZXRTZWNvbmRzKCksbD1jLmdldE1pbGxpc2Vjb25kcygpKTtyZXR1cm4gbmV3IERhdGUoZSwwLGsuZ2V0RGF0ZSgpK2YsZCxnLGgsbCl9fXJldHVybiBOYU59LFxcXCJ5eXl5LVd3d1xcXCIpLG1vbnRoOmxiKFxcXCJtb250aFxcXCIsUmQsS2IoUmQsW1xcXCJ5eXl5XFxcIixcXFwiTU1cXFwiXSksXFxcInl5eXktTU1cXFwiKSxudW1iZXI6ZnVuY3Rpb24oYSxjLGQsZSxmLGcpe0lkKGEsYyxkLGUpO2tiKGEsYyxkLGUsZixnKTtlLiQkcGFyc2VyTmFtZT1cXFwibnVtYmVyXFxcIjtlLiRwYXJzZXJzLnB1c2goZnVuY3Rpb24oYSl7cmV0dXJuIGUuJGlzRW1wdHkoYSk/bnVsbDp1Zy50ZXN0KGEpP3BhcnNlRmxvYXQoYSk6dH0pO2UuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihhKXtpZighZS4kaXNFbXB0eShhKSl7aWYoIVYoYSkpdGhyb3cgTGIoXFxcIm51bWZtdFxcXCIsYSk7YT1hLnRvU3RyaW5nKCl9cmV0dXJuIGF9KTtpZih3KGQubWluKXx8ZC5uZ01pbil7dmFyIGg7ZS4kdmFsaWRhdG9ycy5taW49ZnVuY3Rpb24oYSl7cmV0dXJuIGUuJGlzRW1wdHkoYSl8fFxcbkEoaCl8fGE+PWh9O2QuJG9ic2VydmUoXFxcIm1pblxcXCIsZnVuY3Rpb24oYSl7dyhhKSYmIVYoYSkmJihhPXBhcnNlRmxvYXQoYSwxMCkpO2g9VihhKSYmIWlzTmFOKGEpP2E6dDtlLiR2YWxpZGF0ZSgpfSl9aWYodyhkLm1heCl8fGQubmdNYXgpe3ZhciBsO2UuJHZhbGlkYXRvcnMubWF4PWZ1bmN0aW9uKGEpe3JldHVybiBlLiRpc0VtcHR5KGEpfHxBKGwpfHxhPD1sfTtkLiRvYnNlcnZlKFxcXCJtYXhcXFwiLGZ1bmN0aW9uKGEpe3coYSkmJiFWKGEpJiYoYT1wYXJzZUZsb2F0KGEsMTApKTtsPVYoYSkmJiFpc05hTihhKT9hOnQ7ZS4kdmFsaWRhdGUoKX0pfX0sdXJsOmZ1bmN0aW9uKGEsYyxkLGUsZixnKXtrYihhLGMsZCxlLGYsZyk7a2MoZSk7ZS4kJHBhcnNlck5hbWU9XFxcInVybFxcXCI7ZS4kdmFsaWRhdG9ycy51cmw9ZnVuY3Rpb24oYSxjKXt2YXIgZD1hfHxjO3JldHVybiBlLiRpc0VtcHR5KGQpfHxzZy50ZXN0KGQpfX0sZW1haWw6ZnVuY3Rpb24oYSxjLGQsZSxmLGcpe2tiKGEsYyxkLGUsZixnKTtrYyhlKTtcXG5lLiQkcGFyc2VyTmFtZT1cXFwiZW1haWxcXFwiO2UuJHZhbGlkYXRvcnMuZW1haWw9ZnVuY3Rpb24oYSxjKXt2YXIgZD1hfHxjO3JldHVybiBlLiRpc0VtcHR5KGQpfHx0Zy50ZXN0KGQpfX0scmFkaW86ZnVuY3Rpb24oYSxjLGQsZSl7QShkLm5hbWUpJiZjLmF0dHIoXFxcIm5hbWVcXFwiLCsrbmIpO2Mub24oXFxcImNsaWNrXFxcIixmdW5jdGlvbihhKXtjWzBdLmNoZWNrZWQmJmUuJHNldFZpZXdWYWx1ZShkLnZhbHVlLGEmJmEudHlwZSl9KTtlLiRyZW5kZXI9ZnVuY3Rpb24oKXtjWzBdLmNoZWNrZWQ9ZC52YWx1ZT09ZS4kdmlld1ZhbHVlfTtkLiRvYnNlcnZlKFxcXCJ2YWx1ZVxcXCIsZS4kcmVuZGVyKX0sY2hlY2tib3g6ZnVuY3Rpb24oYSxjLGQsZSxmLGcsaCxsKXt2YXIgaz1KZChsLGEsXFxcIm5nVHJ1ZVZhbHVlXFxcIixkLm5nVHJ1ZVZhbHVlLCEwKSxuPUpkKGwsYSxcXFwibmdGYWxzZVZhbHVlXFxcIixkLm5nRmFsc2VWYWx1ZSwhMSk7Yy5vbihcXFwiY2xpY2tcXFwiLGZ1bmN0aW9uKGEpe2UuJHNldFZpZXdWYWx1ZShjWzBdLmNoZWNrZWQsYSYmXFxuYS50eXBlKX0pO2UuJHJlbmRlcj1mdW5jdGlvbigpe2NbMF0uY2hlY2tlZD1lLiR2aWV3VmFsdWV9O2UuJGlzRW1wdHk9ZnVuY3Rpb24oYSl7cmV0dXJuITE9PT1hfTtlLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24oYSl7cmV0dXJuIGthKGEsayl9KTtlLiRwYXJzZXJzLnB1c2goZnVuY3Rpb24oYSl7cmV0dXJuIGE/azpufSl9LGhpZGRlbjp2LGJ1dHRvbjp2LHN1Ym1pdDp2LHJlc2V0OnYsZmlsZTp2fSxGYz1bXFxcIiRicm93c2VyXFxcIixcXFwiJHNuaWZmZXJcXFwiLFxcXCIkZmlsdGVyXFxcIixcXFwiJHBhcnNlXFxcIixmdW5jdGlvbihhLGMsZCxlKXtyZXR1cm57cmVzdHJpY3Q6XFxcIkVcXFwiLHJlcXVpcmU6W1xcXCI/bmdNb2RlbFxcXCJdLGxpbms6e3ByZTpmdW5jdGlvbihmLGcsaCxsKXtsWzBdJiYoVGRbTShoLnR5cGUpXXx8VGQudGV4dCkoZixnLGgsbFswXSxjLGEsZCxlKX19fX1dLHZnPS9eKHRydWV8ZmFsc2V8XFxcXGQrKSQvLE9lPWZ1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixwcmlvcml0eToxMDAsY29tcGlsZTpmdW5jdGlvbihhLFxcbmMpe3JldHVybiB2Zy50ZXN0KGMubmdWYWx1ZSk/ZnVuY3Rpb24oYSxjLGYpe2YuJHNldChcXFwidmFsdWVcXFwiLGEuJGV2YWwoZi5uZ1ZhbHVlKSl9OmZ1bmN0aW9uKGEsYyxmKXthLiR3YXRjaChmLm5nVmFsdWUsZnVuY3Rpb24oYSl7Zi4kc2V0KFxcXCJ2YWx1ZVxcXCIsYSl9KX19fX0sb2U9W1xcXCIkY29tcGlsZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBQ1xcXCIsY29tcGlsZTpmdW5jdGlvbihjKXthLiQkYWRkQmluZGluZ0NsYXNzKGMpO3JldHVybiBmdW5jdGlvbihjLGUsZil7YS4kJGFkZEJpbmRpbmdJbmZvKGUsZi5uZ0JpbmQpO2U9ZVswXTtjLiR3YXRjaChmLm5nQmluZCxmdW5jdGlvbihhKXtlLnRleHRDb250ZW50PWE9PT10P1xcXCJcXFwiOmF9KX19fX1dLHFlPVtcXFwiJGludGVycG9sYXRlXFxcIixcXFwiJGNvbXBpbGVcXFwiLGZ1bmN0aW9uKGEsYyl7cmV0dXJue2NvbXBpbGU6ZnVuY3Rpb24oZCl7Yy4kJGFkZEJpbmRpbmdDbGFzcyhkKTtyZXR1cm4gZnVuY3Rpb24oZCxmLGcpe2Q9YShmLmF0dHIoZy4kYXR0ci5uZ0JpbmRUZW1wbGF0ZSkpO1xcbmMuJCRhZGRCaW5kaW5nSW5mbyhmLGQuZXhwcmVzc2lvbnMpO2Y9ZlswXTtnLiRvYnNlcnZlKFxcXCJuZ0JpbmRUZW1wbGF0ZVxcXCIsZnVuY3Rpb24oYSl7Zi50ZXh0Q29udGVudD1hPT09dD9cXFwiXFxcIjphfSl9fX19XSxwZT1bXFxcIiRzY2VcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkY29tcGlsZVxcXCIsZnVuY3Rpb24oYSxjLGQpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsY29tcGlsZTpmdW5jdGlvbihlLGYpe3ZhciBnPWMoZi5uZ0JpbmRIdG1sKSxoPWMoZi5uZ0JpbmRIdG1sLGZ1bmN0aW9uKGEpe3JldHVybihhfHxcXFwiXFxcIikudG9TdHJpbmcoKX0pO2QuJCRhZGRCaW5kaW5nQ2xhc3MoZSk7cmV0dXJuIGZ1bmN0aW9uKGMsZSxmKXtkLiQkYWRkQmluZGluZ0luZm8oZSxmLm5nQmluZEh0bWwpO2MuJHdhdGNoKGgsZnVuY3Rpb24oKXtlLmh0bWwoYS5nZXRUcnVzdGVkSHRtbChnKGMpKXx8XFxcIlxcXCIpfSl9fX19XSxOZT1yYSh7cmVzdHJpY3Q6XFxcIkFcXFwiLHJlcXVpcmU6XFxcIm5nTW9kZWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSl7ZS4kdmlld0NoYW5nZUxpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCl7YS4kZXZhbChkLm5nQ2hhbmdlKX0pfX0pLFxcbnJlPWxjKFxcXCJcXFwiLCEwKSx0ZT1sYyhcXFwiT2RkXFxcIiwwKSxzZT1sYyhcXFwiRXZlblxcXCIsMSksdWU9TWEoe2NvbXBpbGU6ZnVuY3Rpb24oYSxjKXtjLiRzZXQoXFxcIm5nQ2xvYWtcXFwiLHQpO2EucmVtb3ZlQ2xhc3MoXFxcIm5nLWNsb2FrXFxcIil9fSksdmU9W2Z1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixzY29wZTohMCxjb250cm9sbGVyOlxcXCJAXFxcIixwcmlvcml0eTo1MDB9fV0sS2M9e30sd2c9e2JsdXI6ITAsZm9jdXM6ITB9O20oXFxcImNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgbW91c2VlbnRlciBtb3VzZWxlYXZlIGtleWRvd24ga2V5dXAga2V5cHJlc3Mgc3VibWl0IGZvY3VzIGJsdXIgY29weSBjdXQgcGFzdGVcXFwiLnNwbGl0KFxcXCIgXFxcIiksZnVuY3Rpb24oYSl7dmFyIGM9d2EoXFxcIm5nLVxcXCIrYSk7S2NbY109W1xcXCIkcGFyc2VcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixmdW5jdGlvbihkLGUpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsY29tcGlsZTpmdW5jdGlvbihmLGcpe3ZhciBoPVxcbmQoZ1tjXSxudWxsLCEwKTtyZXR1cm4gZnVuY3Rpb24oYyxkKXtkLm9uKGEsZnVuY3Rpb24oZCl7dmFyIGY9ZnVuY3Rpb24oKXtoKGMseyRldmVudDpkfSl9O3dnW2FdJiZlLiQkcGhhc2U/Yy4kZXZhbEFzeW5jKGYpOmMuJGFwcGx5KGYpfSl9fX19XX0pO3ZhciB5ZT1bXFxcIiRhbmltYXRlXFxcIixmdW5jdGlvbihhKXtyZXR1cm57bXVsdGlFbGVtZW50OiEwLHRyYW5zY2x1ZGU6XFxcImVsZW1lbnRcXFwiLHByaW9yaXR5OjYwMCx0ZXJtaW5hbDohMCxyZXN0cmljdDpcXFwiQVxcXCIsJCR0bGI6ITAsbGluazpmdW5jdGlvbihjLGQsZSxmLGcpe3ZhciBoLGwsaztjLiR3YXRjaChlLm5nSWYsZnVuY3Rpb24oYyl7Yz9sfHxnKGZ1bmN0aW9uKGMsZil7bD1mO2NbYy5sZW5ndGgrK109VS5jcmVhdGVDb21tZW50KFxcXCIgZW5kIG5nSWY6IFxcXCIrZS5uZ0lmK1xcXCIgXFxcIik7aD17Y2xvbmU6Y307YS5lbnRlcihjLGQucGFyZW50KCksZCl9KTooayYmKGsucmVtb3ZlKCksaz1udWxsKSxsJiYobC4kZGVzdHJveSgpLGw9bnVsbCksaCYmKGs9XFxucWIoaC5jbG9uZSksYS5sZWF2ZShrKS50aGVuKGZ1bmN0aW9uKCl7az1udWxsfSksaD1udWxsKSl9KX19fV0semU9W1xcXCIkdGVtcGxhdGVSZXF1ZXN0XFxcIixcXFwiJGFuY2hvclNjcm9sbFxcXCIsXFxcIiRhbmltYXRlXFxcIixmdW5jdGlvbihhLGMsZCl7cmV0dXJue3Jlc3RyaWN0OlxcXCJFQ0FcXFwiLHByaW9yaXR5OjQwMCx0ZXJtaW5hbDohMCx0cmFuc2NsdWRlOlxcXCJlbGVtZW50XFxcIixjb250cm9sbGVyOmNhLm5vb3AsY29tcGlsZTpmdW5jdGlvbihlLGYpe3ZhciBnPWYubmdJbmNsdWRlfHxmLnNyYyxoPWYub25sb2FkfHxcXFwiXFxcIixsPWYuYXV0b3Njcm9sbDtyZXR1cm4gZnVuY3Rpb24oZSxmLG0scyxxKXt2YXIgdD0wLEYsdSxwLHY9ZnVuY3Rpb24oKXt1JiYodS5yZW1vdmUoKSx1PW51bGwpO0YmJihGLiRkZXN0cm95KCksRj1udWxsKTtwJiYoZC5sZWF2ZShwKS50aGVuKGZ1bmN0aW9uKCl7dT1udWxsfSksdT1wLHA9bnVsbCl9O2UuJHdhdGNoKGcsZnVuY3Rpb24oZyl7dmFyIG09ZnVuY3Rpb24oKXshdyhsKXx8bCYmIWUuJGV2YWwobCl8fFxcbmMoKX0scj0rK3Q7Zz8oYShnLCEwKS50aGVuKGZ1bmN0aW9uKGEpe2lmKHI9PT10KXt2YXIgYz1lLiRuZXcoKTtzLnRlbXBsYXRlPWE7YT1xKGMsZnVuY3Rpb24oYSl7digpO2QuZW50ZXIoYSxudWxsLGYpLnRoZW4obSl9KTtGPWM7cD1hO0YuJGVtaXQoXFxcIiRpbmNsdWRlQ29udGVudExvYWRlZFxcXCIsZyk7ZS4kZXZhbChoKX19LGZ1bmN0aW9uKCl7cj09PXQmJih2KCksZS4kZW1pdChcXFwiJGluY2x1ZGVDb250ZW50RXJyb3JcXFwiLGcpKX0pLGUuJGVtaXQoXFxcIiRpbmNsdWRlQ29udGVudFJlcXVlc3RlZFxcXCIsZykpOih2KCkscy50ZW1wbGF0ZT1udWxsKX0pfX19fV0sUWU9W1xcXCIkY29tcGlsZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Jlc3RyaWN0OlxcXCJFQ0FcXFwiLHByaW9yaXR5Oi00MDAscmVxdWlyZTpcXFwibmdJbmNsdWRlXFxcIixsaW5rOmZ1bmN0aW9uKGMsZCxlLGYpey9TVkcvLnRlc3QoZFswXS50b1N0cmluZygpKT8oZC5lbXB0eSgpLGEoTmMoZi50ZW1wbGF0ZSxVKS5jaGlsZE5vZGVzKShjLGZ1bmN0aW9uKGEpe2QuYXBwZW5kKGEpfSxcXG57ZnV0dXJlUGFyZW50RWxlbWVudDpkfSkpOihkLmh0bWwoZi50ZW1wbGF0ZSksYShkLmNvbnRlbnRzKCkpKGMpKX19fV0sQWU9TWEoe3ByaW9yaXR5OjQ1MCxjb21waWxlOmZ1bmN0aW9uKCl7cmV0dXJue3ByZTpmdW5jdGlvbihhLGMsZCl7YS4kZXZhbChkLm5nSW5pdCl9fX19KSxNZT1mdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIscHJpb3JpdHk6MTAwLHJlcXVpcmU6XFxcIm5nTW9kZWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSl7dmFyIGY9Yy5hdHRyKGQuJGF0dHIubmdMaXN0KXx8XFxcIiwgXFxcIixnPVxcXCJmYWxzZVxcXCIhPT1kLm5nVHJpbSxoPWc/UihmKTpmO2UuJHBhcnNlcnMucHVzaChmdW5jdGlvbihhKXtpZighQShhKSl7dmFyIGM9W107YSYmbShhLnNwbGl0KGgpLGZ1bmN0aW9uKGEpe2EmJmMucHVzaChnP1IoYSk6YSl9KTtyZXR1cm4gY319KTtlLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24oYSl7cmV0dXJuIEcoYSk/YS5qb2luKGYpOnR9KTtlLiRpc0VtcHR5PWZ1bmN0aW9uKGEpe3JldHVybiFhfHxcXG4hYS5sZW5ndGh9fX19LG1iPVxcXCJuZy12YWxpZFxcXCIsS2Q9XFxcIm5nLWludmFsaWRcXFwiLFZhPVxcXCJuZy1wcmlzdGluZVxcXCIsSmI9XFxcIm5nLWRpcnR5XFxcIixNZD1cXFwibmctcGVuZGluZ1xcXCIsTGI9bmV3IEooXFxcIm5nTW9kZWxcXFwiKSx4Zz1bXFxcIiRzY29wZVxcXCIsXFxcIiRleGNlcHRpb25IYW5kbGVyXFxcIixcXFwiJGF0dHJzXFxcIixcXFwiJGVsZW1lbnRcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkYW5pbWF0ZVxcXCIsXFxcIiR0aW1lb3V0XFxcIixcXFwiJHJvb3RTY29wZVxcXCIsXFxcIiRxXFxcIixcXFwiJGludGVycG9sYXRlXFxcIixmdW5jdGlvbihhLGMsZCxlLGYsZyxoLGwsayxuKXt0aGlzLiRtb2RlbFZhbHVlPXRoaXMuJHZpZXdWYWx1ZT1OdW1iZXIuTmFOO3RoaXMuJCRyYXdNb2RlbFZhbHVlPXQ7dGhpcy4kdmFsaWRhdG9ycz17fTt0aGlzLiRhc3luY1ZhbGlkYXRvcnM9e307dGhpcy4kcGFyc2Vycz1bXTt0aGlzLiRmb3JtYXR0ZXJzPVtdO3RoaXMuJHZpZXdDaGFuZ2VMaXN0ZW5lcnM9W107dGhpcy4kdW50b3VjaGVkPSEwO3RoaXMuJHRvdWNoZWQ9ITE7dGhpcy4kcHJpc3RpbmU9ITA7dGhpcy4kZGlydHk9XFxuITE7dGhpcy4kdmFsaWQ9ITA7dGhpcy4kaW52YWxpZD0hMTt0aGlzLiRlcnJvcj17fTt0aGlzLiQkc3VjY2Vzcz17fTt0aGlzLiRwZW5kaW5nPXQ7dGhpcy4kbmFtZT1uKGQubmFtZXx8XFxcIlxcXCIsITEpKGEpO3ZhciByPWYoZC5uZ01vZGVsKSxzPXIuYXNzaWduLHE9cixDPXMsRj1udWxsLHUscD10aGlzO3RoaXMuJCRzZXRPcHRpb25zPWZ1bmN0aW9uKGEpe2lmKChwLiRvcHRpb25zPWEpJiZhLmdldHRlclNldHRlcil7dmFyIGM9ZihkLm5nTW9kZWwrXFxcIigpXFxcIiksZz1mKGQubmdNb2RlbCtcXFwiKCQkJHApXFxcIik7cT1mdW5jdGlvbihhKXt2YXIgZD1yKGEpO3ooZCkmJihkPWMoYSkpO3JldHVybiBkfTtDPWZ1bmN0aW9uKGEsYyl7eihyKGEpKT9nKGEseyQkJHA6cC4kbW9kZWxWYWx1ZX0pOnMoYSxwLiRtb2RlbFZhbHVlKX19ZWxzZSBpZighci5hc3NpZ24pdGhyb3cgTGIoXFxcIm5vbmFzc2lnblxcXCIsZC5uZ01vZGVsLHVhKGUpKTt9O3RoaXMuJHJlbmRlcj12O3RoaXMuJGlzRW1wdHk9ZnVuY3Rpb24oYSl7cmV0dXJuIEEoYSl8fFxcblxcXCJcXFwiPT09YXx8bnVsbD09PWF8fGEhPT1hfTt2YXIgSz1lLmluaGVyaXRlZERhdGEoXFxcIiRmb3JtQ29udHJvbGxlclxcXCIpfHxJYix5PTA7SGQoe2N0cmw6dGhpcywkZWxlbWVudDplLHNldDpmdW5jdGlvbihhLGMpe2FbY109ITB9LHVuc2V0OmZ1bmN0aW9uKGEsYyl7ZGVsZXRlIGFbY119LHBhcmVudEZvcm06SywkYW5pbWF0ZTpnfSk7dGhpcy4kc2V0UHJpc3RpbmU9ZnVuY3Rpb24oKXtwLiRkaXJ0eT0hMTtwLiRwcmlzdGluZT0hMDtnLnJlbW92ZUNsYXNzKGUsSmIpO2cuYWRkQ2xhc3MoZSxWYSl9O3RoaXMuJHNldERpcnR5PWZ1bmN0aW9uKCl7cC4kZGlydHk9ITA7cC4kcHJpc3RpbmU9ITE7Zy5yZW1vdmVDbGFzcyhlLFZhKTtnLmFkZENsYXNzKGUsSmIpO0suJHNldERpcnR5KCl9O3RoaXMuJHNldFVudG91Y2hlZD1mdW5jdGlvbigpe3AuJHRvdWNoZWQ9ITE7cC4kdW50b3VjaGVkPSEwO2cuc2V0Q2xhc3MoZSxcXFwibmctdW50b3VjaGVkXFxcIixcXFwibmctdG91Y2hlZFxcXCIpfTt0aGlzLiRzZXRUb3VjaGVkPVxcbmZ1bmN0aW9uKCl7cC4kdG91Y2hlZD0hMDtwLiR1bnRvdWNoZWQ9ITE7Zy5zZXRDbGFzcyhlLFxcXCJuZy10b3VjaGVkXFxcIixcXFwibmctdW50b3VjaGVkXFxcIil9O3RoaXMuJHJvbGxiYWNrVmlld1ZhbHVlPWZ1bmN0aW9uKCl7aC5jYW5jZWwoRik7cC4kdmlld1ZhbHVlPXAuJCRsYXN0Q29tbWl0dGVkVmlld1ZhbHVlO3AuJHJlbmRlcigpfTt0aGlzLiR2YWxpZGF0ZT1mdW5jdGlvbigpe2lmKCFWKHAuJG1vZGVsVmFsdWUpfHwhaXNOYU4ocC4kbW9kZWxWYWx1ZSkpe3ZhciBhPXAuJCRyYXdNb2RlbFZhbHVlLGM9cC4kdmFsaWQsZD1wLiRtb2RlbFZhbHVlLGU9cC4kb3B0aW9ucyYmcC4kb3B0aW9ucy5hbGxvd0ludmFsaWQ7cC4kJHJ1blZhbGlkYXRvcnMoYSxwLiQkbGFzdENvbW1pdHRlZFZpZXdWYWx1ZSxmdW5jdGlvbihmKXtlfHxjPT09Znx8KHAuJG1vZGVsVmFsdWU9Zj9hOnQscC4kbW9kZWxWYWx1ZSE9PWQmJnAuJCR3cml0ZU1vZGVsVG9TY29wZSgpKX0pfX07dGhpcy4kJHJ1blZhbGlkYXRvcnM9XFxuZnVuY3Rpb24oYSxjLGQpe2Z1bmN0aW9uIGUoKXt2YXIgZD0hMDttKHAuJHZhbGlkYXRvcnMsZnVuY3Rpb24oZSxmKXt2YXIgaD1lKGEsYyk7ZD1kJiZoO2coZixoKX0pO3JldHVybiBkPyEwOihtKHAuJGFzeW5jVmFsaWRhdG9ycyxmdW5jdGlvbihhLGMpe2coYyxudWxsKX0pLCExKX1mdW5jdGlvbiBmKCl7dmFyIGQ9W10sZT0hMDttKHAuJGFzeW5jVmFsaWRhdG9ycyxmdW5jdGlvbihmLGgpe3ZhciBrPWYoYSxjKTtpZigha3x8IXooay50aGVuKSl0aHJvdyBMYihcXFwiJGFzeW5jVmFsaWRhdG9yc1xcXCIsayk7ZyhoLHQpO2QucHVzaChrLnRoZW4oZnVuY3Rpb24oKXtnKGgsITApfSxmdW5jdGlvbihhKXtlPSExO2coaCwhMSl9KSl9KTtkLmxlbmd0aD9rLmFsbChkKS50aGVuKGZ1bmN0aW9uKCl7aChlKX0sdik6aCghMCl9ZnVuY3Rpb24gZyhhLGMpe2w9PT15JiZwLiRzZXRWYWxpZGl0eShhLGMpfWZ1bmN0aW9uIGgoYSl7bD09PXkmJmQoYSl9eSsrO3ZhciBsPXk7KGZ1bmN0aW9uKCl7dmFyIGE9XFxucC4kJHBhcnNlck5hbWV8fFxcXCJwYXJzZVxcXCI7aWYodT09PXQpZyhhLG51bGwpO2Vsc2UgcmV0dXJuIHV8fChtKHAuJHZhbGlkYXRvcnMsZnVuY3Rpb24oYSxjKXtnKGMsbnVsbCl9KSxtKHAuJGFzeW5jVmFsaWRhdG9ycyxmdW5jdGlvbihhLGMpe2coYyxudWxsKX0pKSxnKGEsdSksdTtyZXR1cm4hMH0pKCk/ZSgpP2YoKTpoKCExKTpoKCExKX07dGhpcy4kY29tbWl0Vmlld1ZhbHVlPWZ1bmN0aW9uKCl7dmFyIGE9cC4kdmlld1ZhbHVlO2guY2FuY2VsKEYpO2lmKHAuJCRsYXN0Q29tbWl0dGVkVmlld1ZhbHVlIT09YXx8XFxcIlxcXCI9PT1hJiZwLiQkaGFzTmF0aXZlVmFsaWRhdG9ycylwLiQkbGFzdENvbW1pdHRlZFZpZXdWYWx1ZT1hLHAuJHByaXN0aW5lJiZ0aGlzLiRzZXREaXJ0eSgpLHRoaXMuJCRwYXJzZUFuZFZhbGlkYXRlKCl9O3RoaXMuJCRwYXJzZUFuZFZhbGlkYXRlPWZ1bmN0aW9uKCl7dmFyIGM9cC4kJGxhc3RDb21taXR0ZWRWaWV3VmFsdWU7aWYodT1BKGMpP3Q6ITApZm9yKHZhciBkPVxcbjA7ZDxwLiRwYXJzZXJzLmxlbmd0aDtkKyspaWYoYz1wLiRwYXJzZXJzW2RdKGMpLEEoYykpe3U9ITE7YnJlYWt9VihwLiRtb2RlbFZhbHVlKSYmaXNOYU4ocC4kbW9kZWxWYWx1ZSkmJihwLiRtb2RlbFZhbHVlPXEoYSkpO3ZhciBlPXAuJG1vZGVsVmFsdWUsZj1wLiRvcHRpb25zJiZwLiRvcHRpb25zLmFsbG93SW52YWxpZDtwLiQkcmF3TW9kZWxWYWx1ZT1jO2YmJihwLiRtb2RlbFZhbHVlPWMscC4kbW9kZWxWYWx1ZSE9PWUmJnAuJCR3cml0ZU1vZGVsVG9TY29wZSgpKTtwLiQkcnVuVmFsaWRhdG9ycyhjLHAuJCRsYXN0Q29tbWl0dGVkVmlld1ZhbHVlLGZ1bmN0aW9uKGEpe2Z8fChwLiRtb2RlbFZhbHVlPWE/Yzp0LHAuJG1vZGVsVmFsdWUhPT1lJiZwLiQkd3JpdGVNb2RlbFRvU2NvcGUoKSl9KX07dGhpcy4kJHdyaXRlTW9kZWxUb1Njb3BlPWZ1bmN0aW9uKCl7QyhhLHAuJG1vZGVsVmFsdWUpO20ocC4kdmlld0NoYW5nZUxpc3RlbmVycyxmdW5jdGlvbihhKXt0cnl7YSgpfWNhdGNoKGQpe2MoZCl9fSl9O1xcbnRoaXMuJHNldFZpZXdWYWx1ZT1mdW5jdGlvbihhLGMpe3AuJHZpZXdWYWx1ZT1hO3AuJG9wdGlvbnMmJiFwLiRvcHRpb25zLnVwZGF0ZU9uRGVmYXVsdHx8cC4kJGRlYm91bmNlVmlld1ZhbHVlQ29tbWl0KGMpfTt0aGlzLiQkZGVib3VuY2VWaWV3VmFsdWVDb21taXQ9ZnVuY3Rpb24oYyl7dmFyIGQ9MCxlPXAuJG9wdGlvbnM7ZSYmdyhlLmRlYm91bmNlKSYmKGU9ZS5kZWJvdW5jZSxWKGUpP2Q9ZTpWKGVbY10pP2Q9ZVtjXTpWKGVbXFxcImRlZmF1bHRcXFwiXSkmJihkPWVbXFxcImRlZmF1bHRcXFwiXSkpO2guY2FuY2VsKEYpO2Q/Rj1oKGZ1bmN0aW9uKCl7cC4kY29tbWl0Vmlld1ZhbHVlKCl9LGQpOmwuJCRwaGFzZT9wLiRjb21taXRWaWV3VmFsdWUoKTphLiRhcHBseShmdW5jdGlvbigpe3AuJGNvbW1pdFZpZXdWYWx1ZSgpfSl9O2EuJHdhdGNoKGZ1bmN0aW9uKCl7dmFyIGM9cShhKTtpZihjIT09cC4kbW9kZWxWYWx1ZSYmKHAuJG1vZGVsVmFsdWU9PT1wLiRtb2RlbFZhbHVlfHxjPT09Yykpe3AuJG1vZGVsVmFsdWU9XFxucC4kJHJhd01vZGVsVmFsdWU9Yzt1PXQ7Zm9yKHZhciBkPXAuJGZvcm1hdHRlcnMsZT1kLmxlbmd0aCxmPWM7ZS0tOylmPWRbZV0oZik7cC4kdmlld1ZhbHVlIT09ZiYmKHAuJHZpZXdWYWx1ZT1wLiQkbGFzdENvbW1pdHRlZFZpZXdWYWx1ZT1mLHAuJHJlbmRlcigpLHAuJCRydW5WYWxpZGF0b3JzKGMsZix2KSl9cmV0dXJuIGN9KX1dLExlPVtcXFwiJHJvb3RTY29wZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixyZXF1aXJlOltcXFwibmdNb2RlbFxcXCIsXFxcIl4/Zm9ybVxcXCIsXFxcIl4/bmdNb2RlbE9wdGlvbnNcXFwiXSxjb250cm9sbGVyOnhnLHByaW9yaXR5OjEsY29tcGlsZTpmdW5jdGlvbihjKXtjLmFkZENsYXNzKFZhKS5hZGRDbGFzcyhcXFwibmctdW50b3VjaGVkXFxcIikuYWRkQ2xhc3MobWIpO3JldHVybntwcmU6ZnVuY3Rpb24oYSxjLGYsZyl7dmFyIGg9Z1swXSxsPWdbMV18fEliO2guJCRzZXRPcHRpb25zKGdbMl0mJmdbMl0uJG9wdGlvbnMpO2wuJGFkZENvbnRyb2woaCk7Zi4kb2JzZXJ2ZShcXFwibmFtZVxcXCIsXFxuZnVuY3Rpb24oYSl7aC4kbmFtZSE9PWEmJmwuJCRyZW5hbWVDb250cm9sKGgsYSl9KTthLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7bC4kcmVtb3ZlQ29udHJvbChoKX0pfSxwb3N0OmZ1bmN0aW9uKGMsZSxmLGcpe3ZhciBoPWdbMF07aWYoaC4kb3B0aW9ucyYmaC4kb3B0aW9ucy51cGRhdGVPbillLm9uKGguJG9wdGlvbnMudXBkYXRlT24sZnVuY3Rpb24oYSl7aC4kJGRlYm91bmNlVmlld1ZhbHVlQ29tbWl0KGEmJmEudHlwZSl9KTtlLm9uKFxcXCJibHVyXFxcIixmdW5jdGlvbihlKXtoLiR0b3VjaGVkfHwoYS4kJHBoYXNlP2MuJGV2YWxBc3luYyhoLiRzZXRUb3VjaGVkKTpjLiRhcHBseShoLiRzZXRUb3VjaGVkKSl9KX19fX19XSx5Zz0vKFxcXFxzK3xeKWRlZmF1bHQoXFxcXHMrfCQpLyxQZT1mdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsY29udHJvbGxlcjpbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsZnVuY3Rpb24oYSxjKXt2YXIgZD10aGlzO3RoaXMuJG9wdGlvbnM9ZmEoYS4kZXZhbChjLm5nTW9kZWxPcHRpb25zKSk7XFxudGhpcy4kb3B0aW9ucy51cGRhdGVPbiE9PXQ/KHRoaXMuJG9wdGlvbnMudXBkYXRlT25EZWZhdWx0PSExLHRoaXMuJG9wdGlvbnMudXBkYXRlT249Uih0aGlzLiRvcHRpb25zLnVwZGF0ZU9uLnJlcGxhY2UoeWcsZnVuY3Rpb24oKXtkLiRvcHRpb25zLnVwZGF0ZU9uRGVmYXVsdD0hMDtyZXR1cm5cXFwiIFxcXCJ9KSkpOnRoaXMuJG9wdGlvbnMudXBkYXRlT25EZWZhdWx0PSEwfV19fSxCZT1NYSh7dGVybWluYWw6ITAscHJpb3JpdHk6MUUzfSksemc9SihcXFwibmdPcHRpb25zXFxcIiksQWc9L15cXFxccyooW1xcXFxzXFxcXFNdKz8pKD86XFxcXHMrYXNcXFxccysoW1xcXFxzXFxcXFNdKz8pKT8oPzpcXFxccytncm91cFxcXFxzK2J5XFxcXHMrKFtcXFxcc1xcXFxTXSs/KSk/KD86XFxcXHMrZGlzYWJsZVxcXFxzK3doZW5cXFxccysoW1xcXFxzXFxcXFNdKz8pKT9cXFxccytmb3JcXFxccysoPzooW1xcXFwkXFxcXHddW1xcXFwkXFxcXHddKil8KD86XFxcXChcXFxccyooW1xcXFwkXFxcXHddW1xcXFwkXFxcXHddKilcXFxccyosXFxcXHMqKFtcXFxcJFxcXFx3XVtcXFxcJFxcXFx3XSopXFxcXHMqXFxcXCkpKVxcXFxzK2luXFxcXHMrKFtcXFxcc1xcXFxTXSs/KSg/OlxcXFxzK3RyYWNrXFxcXHMrYnlcXFxccysoW1xcXFxzXFxcXFNdKz8pKT8kLyxcXG5KZT1bXFxcIiRjb21waWxlXFxcIixcXFwiJHBhcnNlXFxcIixmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGQoYSxkLGUpe2Z1bmN0aW9uIGYoYSxjLGQsZSxnKXt0aGlzLnNlbGVjdFZhbHVlPWE7dGhpcy52aWV3VmFsdWU9Yzt0aGlzLmxhYmVsPWQ7dGhpcy5ncm91cD1lO3RoaXMuZGlzYWJsZWQ9Z31mdW5jdGlvbiBuKGEpe3ZhciBjO2lmKCFxJiZFYShhKSljPWE7ZWxzZXtjPVtdO2Zvcih2YXIgZCBpbiBhKWEuaGFzT3duUHJvcGVydHkoZCkmJlxcXCIkXFxcIiE9PWQuY2hhckF0KDApJiZjLnB1c2goZCl9cmV0dXJuIGN9dmFyIG09YS5tYXRjaChBZyk7aWYoIW0pdGhyb3cgemcoXFxcImlleHBcXFwiLGEsdWEoZCkpO3ZhciBzPW1bNV18fG1bN10scT1tWzZdO2E9LyBhcyAvLnRlc3QobVswXSkmJm1bMV07dmFyIHQ9bVs5XTtkPWMobVsyXT9tWzFdOnMpO3ZhciB2PWEmJmMoYSl8fGQsdT10JiZjKHQpLHA9dD9mdW5jdGlvbihhLGMpe3JldHVybiB1KGUsYyl9OmZ1bmN0aW9uKGEpe3JldHVybiBHYShhKX0sdz1mdW5jdGlvbihhLFxcbmMpe3JldHVybiBwKGEseihhLGMpKX0seT1jKG1bMl18fG1bMV0pLEE9YyhtWzNdfHxcXFwiXFxcIiksQj1jKG1bNF18fFxcXCJcXFwiKSxOPWMobVs4XSksRD17fSx6PXE/ZnVuY3Rpb24oYSxjKXtEW3FdPWM7RFtzXT1hO3JldHVybiBEfTpmdW5jdGlvbihhKXtEW3NdPWE7cmV0dXJuIER9O3JldHVybnt0cmFja0J5OnQsZ2V0VHJhY2tCeVZhbHVlOncsZ2V0V2F0Y2hhYmxlczpjKE4sZnVuY3Rpb24oYSl7dmFyIGM9W107YT1hfHxbXTtmb3IodmFyIGQ9bihhKSxmPWQubGVuZ3RoLGc9MDtnPGY7ZysrKXt2YXIgaD1hPT09ZD9nOmRbZ10saz16KGFbaF0saCksaD1wKGFbaF0sayk7Yy5wdXNoKGgpO2lmKG1bMl18fG1bMV0paD15KGUsayksYy5wdXNoKGgpO21bNF0mJihrPUIoZSxrKSxjLnB1c2goaykpfXJldHVybiBjfSksZ2V0T3B0aW9uczpmdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxjPXt9LGQ9TihlKXx8W10sZz1uKGQpLGg9Zy5sZW5ndGgsbT0wO208aDttKyspe3ZhciByPWQ9PT1nP206Z1ttXSxzPVxcbnooZFtyXSxyKSxxPXYoZSxzKSxyPXAocSxzKSx1PXkoZSxzKSx4PUEoZSxzKSxzPUIoZSxzKSxxPW5ldyBmKHIscSx1LHgscyk7YS5wdXNoKHEpO2Nbcl09cX1yZXR1cm57aXRlbXM6YSxzZWxlY3RWYWx1ZU1hcDpjLGdldE9wdGlvbkZyb21WaWV3VmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIGNbdyhhKV19LGdldFZpZXdWYWx1ZUZyb21PcHRpb246ZnVuY3Rpb24oYSl7cmV0dXJuIHQ/Y2EuY29weShhLnZpZXdWYWx1ZSk6YS52aWV3VmFsdWV9fX19fXZhciBlPVUuY3JlYXRlRWxlbWVudChcXFwib3B0aW9uXFxcIiksZj1VLmNyZWF0ZUVsZW1lbnQoXFxcIm9wdGdyb3VwXFxcIik7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIix0ZXJtaW5hbDohMCxyZXF1aXJlOltcXFwic2VsZWN0XFxcIixcXFwiP25nTW9kZWxcXFwiXSxsaW5rOmZ1bmN0aW9uKGMsaCxsLGspe2Z1bmN0aW9uIG4oYSxjKXthLmVsZW1lbnQ9YztjLmRpc2FibGVkPWEuZGlzYWJsZWQ7YS52YWx1ZSE9PWMudmFsdWUmJihjLnZhbHVlPWEuc2VsZWN0VmFsdWUpO2EubGFiZWwhPT1cXG5jLmxhYmVsJiYoYy5sYWJlbD1hLmxhYmVsLGMudGV4dENvbnRlbnQ9YS5sYWJlbCl9ZnVuY3Rpb24gcihhLGMsZCxlKXtjJiZNKGMubm9kZU5hbWUpPT09ZD9kPWM6KGQ9ZS5jbG9uZU5vZGUoITEpLGM/YS5pbnNlcnRCZWZvcmUoZCxjKTphLmFwcGVuZENoaWxkKGQpKTtyZXR1cm4gZH1mdW5jdGlvbiBzKGEpe2Zvcih2YXIgYzthOyljPWEubmV4dFNpYmxpbmcsWGIoYSksYT1jfWZ1bmN0aW9uIHEoYSl7dmFyIGM9cCYmcFswXSxkPU4mJk5bMF07aWYoY3x8ZClmb3IoO2EmJihhPT09Y3x8YT09PWQpOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gdCgpe3ZhciBhPUQmJnUucmVhZFZhbHVlKCk7RD16LmdldE9wdGlvbnMoKTt2YXIgYz17fSxkPWhbMF0uZmlyc3RDaGlsZDtCJiZoLnByZXBlbmQocCk7ZD1xKGQpO0QuaXRlbXMuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgZyxrO2EuZ3JvdXA/KGc9Y1thLmdyb3VwXSxnfHwoZz1yKGhbMF0sZCxcXFwib3B0Z3JvdXBcXFwiLGYpLGQ9XFxuZy5uZXh0U2libGluZyxnLmxhYmVsPWEuZ3JvdXAsZz1jW2EuZ3JvdXBdPXtncm91cEVsZW1lbnQ6ZyxjdXJyZW50T3B0aW9uRWxlbWVudDpnLmZpcnN0Q2hpbGR9KSxrPXIoZy5ncm91cEVsZW1lbnQsZy5jdXJyZW50T3B0aW9uRWxlbWVudCxcXFwib3B0aW9uXFxcIixlKSxuKGEsayksZy5jdXJyZW50T3B0aW9uRWxlbWVudD1rLm5leHRTaWJsaW5nKTooaz1yKGhbMF0sZCxcXFwib3B0aW9uXFxcIixlKSxuKGEsayksZD1rLm5leHRTaWJsaW5nKX0pO09iamVjdC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oYSl7cyhjW2FdLmN1cnJlbnRPcHRpb25FbGVtZW50KX0pO3MoZCk7di4kcmVuZGVyKCk7aWYoIXYuJGlzRW1wdHkoYSkpe3ZhciBnPXUucmVhZFZhbHVlKCk7KHoudHJhY2tCeT9rYShhLGcpOmE9PT1nKXx8KHYuJHNldFZpZXdWYWx1ZShnKSx2LiRyZW5kZXIoKSl9fXZhciB2PWtbMV07aWYodil7dmFyIHU9a1swXTtrPWwubXVsdGlwbGU7Zm9yKHZhciBwLHc9MCxBPWguY2hpbGRyZW4oKSxJPUEubGVuZ3RoO3c8XFxuSTt3KyspaWYoXFxcIlxcXCI9PT1BW3ddLnZhbHVlKXtwPUEuZXEodyk7YnJlYWt9dmFyIEI9ISFwLE49eShlLmNsb25lTm9kZSghMSkpO04udmFsKFxcXCI/XFxcIik7dmFyIEQsej1kKGwubmdPcHRpb25zLGgsYyk7az8odi4kaXNFbXB0eT1mdW5jdGlvbihhKXtyZXR1cm4hYXx8MD09PWEubGVuZ3RofSx1LndyaXRlVmFsdWU9ZnVuY3Rpb24oYSl7RC5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuZWxlbWVudC5zZWxlY3RlZD0hMX0pO2EmJmEuZm9yRWFjaChmdW5jdGlvbihhKXsoYT1ELmdldE9wdGlvbkZyb21WaWV3VmFsdWUoYSkpJiYhYS5kaXNhYmxlZCYmKGEuZWxlbWVudC5zZWxlY3RlZD0hMCl9KX0sdS5yZWFkVmFsdWU9ZnVuY3Rpb24oKXt2YXIgYT1oLnZhbCgpfHxbXSxjPVtdO20oYSxmdW5jdGlvbihhKXthPUQuc2VsZWN0VmFsdWVNYXBbYV07YS5kaXNhYmxlZHx8Yy5wdXNoKEQuZ2V0Vmlld1ZhbHVlRnJvbU9wdGlvbihhKSl9KTtyZXR1cm4gY30sei50cmFja0J5JiZjLiR3YXRjaENvbGxlY3Rpb24oZnVuY3Rpb24oKXtpZihHKHYuJHZpZXdWYWx1ZSkpcmV0dXJuIHYuJHZpZXdWYWx1ZS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIHouZ2V0VHJhY2tCeVZhbHVlKGEpfSl9LFxcbmZ1bmN0aW9uKCl7di4kcmVuZGVyKCl9KSk6KHUud3JpdGVWYWx1ZT1mdW5jdGlvbihhKXt2YXIgYz1ELmdldE9wdGlvbkZyb21WaWV3VmFsdWUoYSk7YyYmIWMuZGlzYWJsZWQ/aFswXS52YWx1ZSE9PWMuc2VsZWN0VmFsdWUmJihOLnJlbW92ZSgpLEJ8fHAucmVtb3ZlKCksaFswXS52YWx1ZT1jLnNlbGVjdFZhbHVlLGMuZWxlbWVudC5zZWxlY3RlZD0hMCxjLmVsZW1lbnQuc2V0QXR0cmlidXRlKFxcXCJzZWxlY3RlZFxcXCIsXFxcInNlbGVjdGVkXFxcIikpOm51bGw9PT1hfHxCPyhOLnJlbW92ZSgpLEJ8fGgucHJlcGVuZChwKSxoLnZhbChcXFwiXFxcIikscC5wcm9wKFxcXCJzZWxlY3RlZFxcXCIsITApLHAuYXR0cihcXFwic2VsZWN0ZWRcXFwiLCEwKSk6KEJ8fHAucmVtb3ZlKCksaC5wcmVwZW5kKE4pLGgudmFsKFxcXCI/XFxcIiksTi5wcm9wKFxcXCJzZWxlY3RlZFxcXCIsITApLE4uYXR0cihcXFwic2VsZWN0ZWRcXFwiLCEwKSl9LHUucmVhZFZhbHVlPWZ1bmN0aW9uKCl7dmFyIGE9RC5zZWxlY3RWYWx1ZU1hcFtoLnZhbCgpXTtyZXR1cm4gYSYmIWEuZGlzYWJsZWQ/XFxuKEJ8fHAucmVtb3ZlKCksTi5yZW1vdmUoKSxELmdldFZpZXdWYWx1ZUZyb21PcHRpb24oYSkpOm51bGx9LHoudHJhY2tCeSYmYy4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gei5nZXRUcmFja0J5VmFsdWUodi4kdmlld1ZhbHVlKX0sZnVuY3Rpb24oKXt2LiRyZW5kZXIoKX0pKTtCPyhwLnJlbW92ZSgpLGEocCkoYykscC5yZW1vdmVDbGFzcyhcXFwibmctc2NvcGVcXFwiKSk6cD15KGUuY2xvbmVOb2RlKCExKSk7dCgpO2MuJHdhdGNoQ29sbGVjdGlvbih6LmdldFdhdGNoYWJsZXMsdCl9fX19XSxDZT1bXFxcIiRsb2NhbGVcXFwiLFxcXCIkaW50ZXJwb2xhdGVcXFwiLFxcXCIkbG9nXFxcIixmdW5jdGlvbihhLGMsZCl7dmFyIGU9L3t9L2csZj0vXndoZW4oTWludXMpPyguKykkLztyZXR1cm57bGluazpmdW5jdGlvbihnLGgsbCl7ZnVuY3Rpb24gayhhKXtoLnRleHQoYXx8XFxcIlxcXCIpfXZhciBuPWwuY291bnQscj1sLiRhdHRyLndoZW4mJmguYXR0cihsLiRhdHRyLndoZW4pLHM9bC5vZmZzZXR8fDAscT1nLiRldmFsKHIpfHx7fSx0PVxcbnt9LHc9Yy5zdGFydFN5bWJvbCgpLHU9Yy5lbmRTeW1ib2woKSxwPXcrbitcXFwiLVxcXCIrcyt1LHk9Y2Eubm9vcCx6O20obCxmdW5jdGlvbihhLGMpe3ZhciBkPWYuZXhlYyhjKTtkJiYoZD0oZFsxXT9cXFwiLVxcXCI6XFxcIlxcXCIpK00oZFsyXSkscVtkXT1oLmF0dHIobC4kYXR0cltjXSkpfSk7bShxLGZ1bmN0aW9uKGEsZCl7dFtkXT1jKGEucmVwbGFjZShlLHApKX0pO2cuJHdhdGNoKG4sZnVuY3Rpb24oYyl7dmFyIGU9cGFyc2VGbG9hdChjKSxmPWlzTmFOKGUpO2Z8fGUgaW4gcXx8KGU9YS5wbHVyYWxDYXQoZS1zKSk7ZT09PXp8fGYmJlYoeikmJmlzTmFOKHopfHwoeSgpLGY9dFtlXSxBKGYpPyhudWxsIT1jJiZkLmRlYnVnKFxcXCJuZ1BsdXJhbGl6ZTogbm8gcnVsZSBkZWZpbmVkIGZvciAnXFxcIitlK1xcXCInIGluIFxcXCIrcikseT12LGsoKSk6eT1nLiR3YXRjaChmLGspLHo9ZSl9KX19fV0sRGU9W1xcXCIkcGFyc2VcXFwiLFxcXCIkYW5pbWF0ZVxcXCIsZnVuY3Rpb24oYSxjKXt2YXIgZD1KKFxcXCJuZ1JlcGVhdFxcXCIpLGU9ZnVuY3Rpb24oYSxjLFxcbmQsZSxrLG0scil7YVtkXT1lO2smJihhW2tdPW0pO2EuJGluZGV4PWM7YS4kZmlyc3Q9MD09PWM7YS4kbGFzdD1jPT09ci0xO2EuJG1pZGRsZT0hKGEuJGZpcnN0fHxhLiRsYXN0KTthLiRvZGQ9IShhLiRldmVuPTA9PT0oYyYxKSl9O3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsbXVsdGlFbGVtZW50OiEwLHRyYW5zY2x1ZGU6XFxcImVsZW1lbnRcXFwiLHByaW9yaXR5OjFFMyx0ZXJtaW5hbDohMCwkJHRsYjohMCxjb21waWxlOmZ1bmN0aW9uKGYsZyl7dmFyIGg9Zy5uZ1JlcGVhdCxsPVUuY3JlYXRlQ29tbWVudChcXFwiIGVuZCBuZ1JlcGVhdDogXFxcIitoK1xcXCIgXFxcIiksaz1oLm1hdGNoKC9eXFxcXHMqKFtcXFxcc1xcXFxTXSs/KVxcXFxzK2luXFxcXHMrKFtcXFxcc1xcXFxTXSs/KSg/OlxcXFxzK2FzXFxcXHMrKFtcXFxcc1xcXFxTXSs/KSk/KD86XFxcXHMrdHJhY2tcXFxccytieVxcXFxzKyhbXFxcXHNcXFxcU10rPykpP1xcXFxzKiQvKTtpZighayl0aHJvdyBkKFxcXCJpZXhwXFxcIixoKTt2YXIgbj1rWzFdLHI9a1syXSxzPWtbM10scT1rWzRdLGs9bi5tYXRjaCgvXig/OihcXFxccypbXFxcXCRcXFxcd10rKXxcXFxcKFxcXFxzKihbXFxcXCRcXFxcd10rKVxcXFxzKixcXFxccyooW1xcXFwkXFxcXHddKylcXFxccypcXFxcKSkkLyk7XFxuaWYoIWspdGhyb3cgZChcXFwiaWlkZXhwXFxcIixuKTt2YXIgdj1rWzNdfHxrWzFdLHc9a1syXTtpZihzJiYoIS9eWyRhLXpBLVpfXVskYS16QS1aMC05X10qJC8udGVzdChzKXx8L14obnVsbHx1bmRlZmluZWR8dGhpc3xcXFxcJGluZGV4fFxcXFwkZmlyc3R8XFxcXCRtaWRkbGV8XFxcXCRsYXN0fFxcXFwkZXZlbnxcXFxcJG9kZHxcXFxcJHBhcmVudHxcXFxcJHJvb3R8XFxcXCRpZCkkLy50ZXN0KHMpKSl0aHJvdyBkKFxcXCJiYWRpZGVudFxcXCIscyk7dmFyIHUscCx6LEEsST17JGlkOkdhfTtxP3U9YShxKTooej1mdW5jdGlvbihhLGMpe3JldHVybiBHYShjKX0sQT1mdW5jdGlvbihhKXtyZXR1cm4gYX0pO3JldHVybiBmdW5jdGlvbihhLGYsZyxrLG4pe3UmJihwPWZ1bmN0aW9uKGMsZCxlKXt3JiYoSVt3XT1jKTtJW3ZdPWQ7SS4kaW5kZXg9ZTtyZXR1cm4gdShhLEkpfSk7dmFyIHE9Z2EoKTthLiR3YXRjaENvbGxlY3Rpb24ocixmdW5jdGlvbihnKXt2YXIgayxyLHU9ZlswXSx4LEQ9Z2EoKSxJLEgsTCxHLE0sSixPO3MmJihhW3NdPWcpO2lmKEVhKGcpKU09XFxuZyxyPXB8fHo7ZWxzZSBmb3IoTyBpbiByPXB8fEEsTT1bXSxnKWcuaGFzT3duUHJvcGVydHkoTykmJlxcXCIkXFxcIiE9PU8uY2hhckF0KDApJiZNLnB1c2goTyk7ST1NLmxlbmd0aDtPPUFycmF5KEkpO2ZvcihrPTA7azxJO2srKylpZihIPWc9PT1NP2s6TVtrXSxMPWdbSF0sRz1yKEgsTCxrKSxxW0ddKUo9cVtHXSxkZWxldGUgcVtHXSxEW0ddPUosT1trXT1KO2Vsc2V7aWYoRFtHXSl0aHJvdyBtKE8sZnVuY3Rpb24oYSl7YSYmYS5zY29wZSYmKHFbYS5pZF09YSl9KSxkKFxcXCJkdXBlc1xcXCIsaCxHLEwpO09ba109e2lkOkcsc2NvcGU6dCxjbG9uZTp0fTtEW0ddPSEwfWZvcih4IGluIHEpe0o9cVt4XTtHPXFiKEouY2xvbmUpO2MubGVhdmUoRyk7aWYoR1swXS5wYXJlbnROb2RlKWZvcihrPTAscj1HLmxlbmd0aDtrPHI7aysrKUdba10uJCROR19SRU1PVkVEPSEwO0ouc2NvcGUuJGRlc3Ryb3koKX1mb3Ioaz0wO2s8STtrKyspaWYoSD1nPT09TT9rOk1ba10sTD1nW0hdLEo9T1trXSxKLnNjb3BlKXt4PVxcbnU7ZG8geD14Lm5leHRTaWJsaW5nO3doaWxlKHgmJnguJCROR19SRU1PVkVEKTtKLmNsb25lWzBdIT14JiZjLm1vdmUocWIoSi5jbG9uZSksbnVsbCx5KHUpKTt1PUouY2xvbmVbSi5jbG9uZS5sZW5ndGgtMV07ZShKLnNjb3BlLGssdixMLHcsSCxJKX1lbHNlIG4oZnVuY3Rpb24oYSxkKXtKLnNjb3BlPWQ7dmFyIGY9bC5jbG9uZU5vZGUoITEpO2FbYS5sZW5ndGgrK109ZjtjLmVudGVyKGEsbnVsbCx5KHUpKTt1PWY7Si5jbG9uZT1hO0RbSi5pZF09SjtlKEouc2NvcGUsayx2LEwsdyxILEkpfSk7cT1EfSl9fX19XSxFZT1bXFxcIiRhbmltYXRlXFxcIixmdW5jdGlvbihhKXtyZXR1cm57cmVzdHJpY3Q6XFxcIkFcXFwiLG11bHRpRWxlbWVudDohMCxsaW5rOmZ1bmN0aW9uKGMsZCxlKXtjLiR3YXRjaChlLm5nU2hvdyxmdW5jdGlvbihjKXthW2M/XFxcInJlbW92ZUNsYXNzXFxcIjpcXFwiYWRkQ2xhc3NcXFwiXShkLFxcXCJuZy1oaWRlXFxcIix7dGVtcENsYXNzZXM6XFxcIm5nLWhpZGUtYW5pbWF0ZVxcXCJ9KX0pfX19XSx4ZT1bXFxcIiRhbmltYXRlXFxcIixcXG5mdW5jdGlvbihhKXtyZXR1cm57cmVzdHJpY3Q6XFxcIkFcXFwiLG11bHRpRWxlbWVudDohMCxsaW5rOmZ1bmN0aW9uKGMsZCxlKXtjLiR3YXRjaChlLm5nSGlkZSxmdW5jdGlvbihjKXthW2M/XFxcImFkZENsYXNzXFxcIjpcXFwicmVtb3ZlQ2xhc3NcXFwiXShkLFxcXCJuZy1oaWRlXFxcIix7dGVtcENsYXNzZXM6XFxcIm5nLWhpZGUtYW5pbWF0ZVxcXCJ9KX0pfX19XSxGZT1NYShmdW5jdGlvbihhLGMsZCl7YS4kd2F0Y2goZC5uZ1N0eWxlLGZ1bmN0aW9uKGEsZCl7ZCYmYSE9PWQmJm0oZCxmdW5jdGlvbihhLGQpe2MuY3NzKGQsXFxcIlxcXCIpfSk7YSYmYy5jc3MoYSl9LCEwKX0pLEdlPVtcXFwiJGFuaW1hdGVcXFwiLGZ1bmN0aW9uKGEpe3JldHVybntyZXF1aXJlOlxcXCJuZ1N3aXRjaFxcXCIsY29udHJvbGxlcjpbXFxcIiRzY29wZVxcXCIsZnVuY3Rpb24oKXt0aGlzLmNhc2VzPXt9fV0sbGluazpmdW5jdGlvbihjLGQsZSxmKXt2YXIgZz1bXSxoPVtdLGw9W10saz1bXSxuPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGZ1bmN0aW9uKCl7YS5zcGxpY2UoYywxKX19O2MuJHdhdGNoKGUubmdTd2l0Y2h8fFxcbmUub24sZnVuY3Rpb24oYyl7dmFyIGQsZTtkPTA7Zm9yKGU9bC5sZW5ndGg7ZDxlOysrZClhLmNhbmNlbChsW2RdKTtkPWwubGVuZ3RoPTA7Zm9yKGU9ay5sZW5ndGg7ZDxlOysrZCl7dmFyIHE9cWIoaFtkXS5jbG9uZSk7a1tkXS4kZGVzdHJveSgpOyhsW2RdPWEubGVhdmUocSkpLnRoZW4obihsLGQpKX1oLmxlbmd0aD0wO2subGVuZ3RoPTA7KGc9Zi5jYXNlc1tcXFwiIVxcXCIrY118fGYuY2FzZXNbXFxcIj9cXFwiXSkmJm0oZyxmdW5jdGlvbihjKXtjLnRyYW5zY2x1ZGUoZnVuY3Rpb24oZCxlKXtrLnB1c2goZSk7dmFyIGY9Yy5lbGVtZW50O2RbZC5sZW5ndGgrK109VS5jcmVhdGVDb21tZW50KFxcXCIgZW5kIG5nU3dpdGNoV2hlbjogXFxcIik7aC5wdXNoKHtjbG9uZTpkfSk7YS5lbnRlcihkLGYucGFyZW50KCksZil9KX0pfSl9fX1dLEhlPU1hKHt0cmFuc2NsdWRlOlxcXCJlbGVtZW50XFxcIixwcmlvcml0eToxMjAwLHJlcXVpcmU6XFxcIl5uZ1N3aXRjaFxcXCIsbXVsdGlFbGVtZW50OiEwLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSxcXG5mKXtlLmNhc2VzW1xcXCIhXFxcIitkLm5nU3dpdGNoV2hlbl09ZS5jYXNlc1tcXFwiIVxcXCIrZC5uZ1N3aXRjaFdoZW5dfHxbXTtlLmNhc2VzW1xcXCIhXFxcIitkLm5nU3dpdGNoV2hlbl0ucHVzaCh7dHJhbnNjbHVkZTpmLGVsZW1lbnQ6Y30pfX0pLEllPU1hKHt0cmFuc2NsdWRlOlxcXCJlbGVtZW50XFxcIixwcmlvcml0eToxMjAwLHJlcXVpcmU6XFxcIl5uZ1N3aXRjaFxcXCIsbXVsdGlFbGVtZW50OiEwLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSxmKXtlLmNhc2VzW1xcXCI/XFxcIl09ZS5jYXNlc1tcXFwiP1xcXCJdfHxbXTtlLmNhc2VzW1xcXCI/XFxcIl0ucHVzaCh7dHJhbnNjbHVkZTpmLGVsZW1lbnQ6Y30pfX0pLEtlPU1hKHtyZXN0cmljdDpcXFwiRUFDXFxcIixsaW5rOmZ1bmN0aW9uKGEsYyxkLGUsZil7aWYoIWYpdGhyb3cgSihcXFwibmdUcmFuc2NsdWRlXFxcIikoXFxcIm9ycGhhblxcXCIsdWEoYykpO2YoZnVuY3Rpb24oYSl7Yy5lbXB0eSgpO2MuYXBwZW5kKGEpfSl9fSksa2U9W1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Jlc3RyaWN0OlxcXCJFXFxcIix0ZXJtaW5hbDohMCxcXG5jb21waWxlOmZ1bmN0aW9uKGMsZCl7XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPT1kLnR5cGUmJmEucHV0KGQuaWQsY1swXS50ZXh0KX19fV0sQmc9eyRzZXRWaWV3VmFsdWU6diwkcmVuZGVyOnZ9LENnPVtcXFwiJGVsZW1lbnRcXFwiLFxcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLGZ1bmN0aW9uKGEsYyxkKXt2YXIgZT10aGlzLGY9bmV3IFNhO2UubmdNb2RlbEN0cmw9Qmc7ZS51bmtub3duT3B0aW9uPXkoVS5jcmVhdGVFbGVtZW50KFxcXCJvcHRpb25cXFwiKSk7ZS5yZW5kZXJVbmtub3duT3B0aW9uPWZ1bmN0aW9uKGMpe2M9XFxcIj8gXFxcIitHYShjKStcXFwiID9cXFwiO2UudW5rbm93bk9wdGlvbi52YWwoYyk7YS5wcmVwZW5kKGUudW5rbm93bk9wdGlvbik7YS52YWwoYyl9O2MuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtlLnJlbmRlclVua25vd25PcHRpb249dn0pO2UucmVtb3ZlVW5rbm93bk9wdGlvbj1mdW5jdGlvbigpe2UudW5rbm93bk9wdGlvbi5wYXJlbnQoKSYmZS51bmtub3duT3B0aW9uLnJlbW92ZSgpfTtlLnJlYWRWYWx1ZT1cXG5mdW5jdGlvbigpe2UucmVtb3ZlVW5rbm93bk9wdGlvbigpO3JldHVybiBhLnZhbCgpfTtlLndyaXRlVmFsdWU9ZnVuY3Rpb24oYyl7ZS5oYXNPcHRpb24oYyk/KGUucmVtb3ZlVW5rbm93bk9wdGlvbigpLGEudmFsKGMpLFxcXCJcXFwiPT09YyYmZS5lbXB0eU9wdGlvbi5wcm9wKFxcXCJzZWxlY3RlZFxcXCIsITApKTpudWxsPT1jJiZlLmVtcHR5T3B0aW9uPyhlLnJlbW92ZVVua25vd25PcHRpb24oKSxhLnZhbChcXFwiXFxcIikpOmUucmVuZGVyVW5rbm93bk9wdGlvbihjKX07ZS5hZGRPcHRpb249ZnVuY3Rpb24oYSxjKXtSYShhLCdcXFwib3B0aW9uIHZhbHVlXFxcIicpO1xcXCJcXFwiPT09YSYmKGUuZW1wdHlPcHRpb249Yyk7dmFyIGQ9Zi5nZXQoYSl8fDA7Zi5wdXQoYSxkKzEpfTtlLnJlbW92ZU9wdGlvbj1mdW5jdGlvbihhKXt2YXIgYz1mLmdldChhKTtjJiYoMT09PWM/KGYucmVtb3ZlKGEpLFxcXCJcXFwiPT09YSYmKGUuZW1wdHlPcHRpb249dCkpOmYucHV0KGEsYy0xKSl9O2UuaGFzT3B0aW9uPWZ1bmN0aW9uKGEpe3JldHVybiEhZi5nZXQoYSl9fV0sXFxubGU9ZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XFxcIkVcXFwiLHJlcXVpcmU6W1xcXCJzZWxlY3RcXFwiLFxcXCI/bmdNb2RlbFxcXCJdLGNvbnRyb2xsZXI6Q2csbGluazpmdW5jdGlvbihhLGMsZCxlKXt2YXIgZj1lWzFdO2lmKGYpe3ZhciBnPWVbMF07Zy5uZ01vZGVsQ3RybD1mO2YuJHJlbmRlcj1mdW5jdGlvbigpe2cud3JpdGVWYWx1ZShmLiR2aWV3VmFsdWUpfTtjLm9uKFxcXCJjaGFuZ2VcXFwiLGZ1bmN0aW9uKCl7YS4kYXBwbHkoZnVuY3Rpb24oKXtmLiRzZXRWaWV3VmFsdWUoZy5yZWFkVmFsdWUoKSl9KX0pO2lmKGQubXVsdGlwbGUpe2cucmVhZFZhbHVlPWZ1bmN0aW9uKCl7dmFyIGE9W107bShjLmZpbmQoXFxcIm9wdGlvblxcXCIpLGZ1bmN0aW9uKGMpe2Muc2VsZWN0ZWQmJmEucHVzaChjLnZhbHVlKX0pO3JldHVybiBhfTtnLndyaXRlVmFsdWU9ZnVuY3Rpb24oYSl7dmFyIGQ9bmV3IFNhKGEpO20oYy5maW5kKFxcXCJvcHRpb25cXFwiKSxmdW5jdGlvbihhKXthLnNlbGVjdGVkPXcoZC5nZXQoYS52YWx1ZSkpfSl9O3ZhciBoLFxcbmw9TmFOO2EuJHdhdGNoKGZ1bmN0aW9uKCl7bCE9PWYuJHZpZXdWYWx1ZXx8a2EoaCxmLiR2aWV3VmFsdWUpfHwoaD1pYShmLiR2aWV3VmFsdWUpLGYuJHJlbmRlcigpKTtsPWYuJHZpZXdWYWx1ZX0pO2YuJGlzRW1wdHk9ZnVuY3Rpb24oYSl7cmV0dXJuIWF8fDA9PT1hLmxlbmd0aH19fX19fSxuZT1bXFxcIiRpbnRlcnBvbGF0ZVxcXCIsZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYyhhKXthWzBdLmhhc0F0dHJpYnV0ZShcXFwic2VsZWN0ZWRcXFwiKSYmKGFbMF0uc2VsZWN0ZWQ9ITApfXJldHVybntyZXN0cmljdDpcXFwiRVxcXCIscHJpb3JpdHk6MTAwLGNvbXBpbGU6ZnVuY3Rpb24oZCxlKXtpZihBKGUudmFsdWUpKXt2YXIgZj1hKGQudGV4dCgpLCEwKTtmfHxlLiRzZXQoXFxcInZhbHVlXFxcIixkLnRleHQoKSl9cmV0dXJuIGZ1bmN0aW9uKGEsZCxlKXt2YXIgaz1kLnBhcmVudCgpLG09ay5kYXRhKFxcXCIkc2VsZWN0Q29udHJvbGxlclxcXCIpfHxrLnBhcmVudCgpLmRhdGEoXFxcIiRzZWxlY3RDb250cm9sbGVyXFxcIik7bSYmbS5uZ01vZGVsQ3RybCYmXFxuKGY/YS4kd2F0Y2goZixmdW5jdGlvbihhLGYpe2UuJHNldChcXFwidmFsdWVcXFwiLGEpO2YhPT1hJiZtLnJlbW92ZU9wdGlvbihmKTttLmFkZE9wdGlvbihhLGQpO20ubmdNb2RlbEN0cmwuJHJlbmRlcigpO2MoZCl9KToobS5hZGRPcHRpb24oZS52YWx1ZSxkKSxtLm5nTW9kZWxDdHJsLiRyZW5kZXIoKSxjKGQpKSxkLm9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXttLnJlbW92ZU9wdGlvbihlLnZhbHVlKTttLm5nTW9kZWxDdHJsLiRyZW5kZXIoKX0pKX19fX1dLG1lPXJhKHtyZXN0cmljdDpcXFwiRVxcXCIsdGVybWluYWw6ITF9KSxIYz1mdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIscmVxdWlyZTpcXFwiP25nTW9kZWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSl7ZSYmKGQucmVxdWlyZWQ9ITAsZS4kdmFsaWRhdG9ycy5yZXF1aXJlZD1mdW5jdGlvbihhLGMpe3JldHVybiFkLnJlcXVpcmVkfHwhZS4kaXNFbXB0eShjKX0sZC4kb2JzZXJ2ZShcXFwicmVxdWlyZWRcXFwiLGZ1bmN0aW9uKCl7ZS4kdmFsaWRhdGUoKX0pKX19fSxcXG5HYz1mdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIscmVxdWlyZTpcXFwiP25nTW9kZWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSl7aWYoZSl7dmFyIGYsZz1kLm5nUGF0dGVybnx8ZC5wYXR0ZXJuO2QuJG9ic2VydmUoXFxcInBhdHRlcm5cXFwiLGZ1bmN0aW9uKGEpe0woYSkmJjA8YS5sZW5ndGgmJihhPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2ErXFxcIiRcXFwiKSk7aWYoYSYmIWEudGVzdCl0aHJvdyBKKFxcXCJuZ1BhdHRlcm5cXFwiKShcXFwibm9yZWdleHBcXFwiLGcsYSx1YShjKSk7Zj1hfHx0O2UuJHZhbGlkYXRlKCl9KTtlLiR2YWxpZGF0b3JzLnBhdHRlcm49ZnVuY3Rpb24oYSl7cmV0dXJuIGUuJGlzRW1wdHkoYSl8fEEoZil8fGYudGVzdChhKX19fX19LEpjPWZ1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixyZXF1aXJlOlxcXCI/bmdNb2RlbFxcXCIsbGluazpmdW5jdGlvbihhLGMsZCxlKXtpZihlKXt2YXIgZj0tMTtkLiRvYnNlcnZlKFxcXCJtYXhsZW5ndGhcXFwiLGZ1bmN0aW9uKGEpe2E9VyhhKTtmPWlzTmFOKGEpPy0xOmE7ZS4kdmFsaWRhdGUoKX0pO1xcbmUuJHZhbGlkYXRvcnMubWF4bGVuZ3RoPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIDA+Znx8ZS4kaXNFbXB0eShjKXx8Yy5sZW5ndGg8PWZ9fX19fSxJYz1mdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIscmVxdWlyZTpcXFwiP25nTW9kZWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxjLGQsZSl7aWYoZSl7dmFyIGY9MDtkLiRvYnNlcnZlKFxcXCJtaW5sZW5ndGhcXFwiLGZ1bmN0aW9uKGEpe2Y9VyhhKXx8MDtlLiR2YWxpZGF0ZSgpfSk7ZS4kdmFsaWRhdG9ycy5taW5sZW5ndGg9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gZS4kaXNFbXB0eShjKXx8Yy5sZW5ndGg+PWZ9fX19fTtPLmFuZ3VsYXIuYm9vdHN0cmFwP2NvbnNvbGUubG9nKFxcXCJXQVJOSU5HOiBUcmllZCB0byBsb2FkIGFuZ3VsYXIgbW9yZSB0aGFuIG9uY2UuXFxcIik6KGNlKCksZWUoY2EpLHkoVSkucmVhZHkoZnVuY3Rpb24oKXtaZChVLEFjKX0pKX0pKHdpbmRvdyxkb2N1bWVudCk7IXdpbmRvdy5hbmd1bGFyLiQkY3NwKCkmJndpbmRvdy5hbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoXFxcImhlYWRcXFwiKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7W25nXFxcXFxcXFw6Y2xvYWtdLFtuZy1jbG9ha10sW2RhdGEtbmctY2xvYWtdLFt4LW5nLWNsb2FrXSwubmctY2xvYWssLngtbmctY2xvYWssLm5nLWhpZGU6bm90KC5uZy1oaWRlLWFuaW1hdGUpe2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50O31uZ1xcXFxcXFxcOmZvcm17ZGlzcGxheTpibG9jazt9Lm5nLWFuaW1hdGUtc2hpbXt2aXNpYmlsaXR5OmhpZGRlbjt9Lm5nLWFuY2hvcntwb3NpdGlvbjphYnNvbHV0ZTt9PC9zdHlsZT4nKTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmd1bGFyLm1pbi5qcy5tYXBcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXIvYW5ndWxhci5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwicmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1yb3V0ZS9hbmd1bGFyLXJvdXRlLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLXJvdXRlL2FuZ3VsYXItcm91dGUubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbiBBbmd1bGFySlMgdjEuMi4wXFxuIChjKSAyMDEwLTIwMTIgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXFxuIExpY2Vuc2U6IE1JVFxcbiovXFxuKGZ1bmN0aW9uKHQsYyxCKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gdyhzLHIsZyxhLGgpe3JldHVybntyZXN0cmljdDpcXFwiRUNBXFxcIix0ZXJtaW5hbDohMCxwcmlvcml0eTo0MDAsdHJhbnNjbHVkZTpcXFwiZWxlbWVudFxcXCIsY29tcGlsZTpmdW5jdGlvbihrLGQsQSl7cmV0dXJuIGZ1bmN0aW9uKHUsayxkKXtmdW5jdGlvbiB2KCl7bCYmKGwuJGRlc3Ryb3koKSxsPW51bGwpO20mJihoLmxlYXZlKG0pLG09bnVsbCl9ZnVuY3Rpb24geCgpe3ZhciBmPXMuY3VycmVudCYmcy5jdXJyZW50LmxvY2Fscyx5PWYmJmYuJHRlbXBsYXRlO2lmKHkpe3ZhciB6PXUuJG5ldygpO0EoeixmdW5jdGlvbihlKXtlLmh0bWwoeSk7aC5lbnRlcihlLG51bGwsbXx8ayxmdW5jdGlvbigpeyFjLmlzRGVmaW5lZChuKXx8biYmIXUuJGV2YWwobil8fHIoKX0pO3YoKTt2YXIgcD1nKGUuY29udGVudHMoKSkscT1zLmN1cnJlbnQ7bD1xLnNjb3BlPXo7bT1lO2lmKHEuY29udHJvbGxlcil7Zi4kc2NvcGU9bDt2YXIgZD1hKHEuY29udHJvbGxlcixcXG5mKTtxLmNvbnRyb2xsZXJBcyYmKGxbcS5jb250cm9sbGVyQXNdPWQpO2UuZGF0YShcXFwiJG5nQ29udHJvbGxlckNvbnRyb2xsZXJcXFwiLGQpO2UuY2hpbGRyZW4oKS5kYXRhKFxcXCIkbmdDb250cm9sbGVyQ29udHJvbGxlclxcXCIsZCl9cChsKTtsLiRlbWl0KFxcXCIkdmlld0NvbnRlbnRMb2FkZWRcXFwiKTtsLiRldmFsKGIpfSl9ZWxzZSB2KCl9dmFyIGwsbSxuPWQuYXV0b3Njcm9sbCxiPWQub25sb2FkfHxcXFwiXFxcIjt1LiRvbihcXFwiJHJvdXRlQ2hhbmdlU3VjY2Vzc1xcXCIseCk7eCgpfX19fXQ9Yy5tb2R1bGUoXFxcIm5nUm91dGVcXFwiLFtcXFwibmdcXFwiXSkucHJvdmlkZXIoXFxcIiRyb3V0ZVxcXCIsZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGEsaCl7cmV0dXJuIGMuZXh0ZW5kKG5ldyAoYy5leHRlbmQoZnVuY3Rpb24oKXt9LHtwcm90b3R5cGU6YX0pKSxoKX1mdW5jdGlvbiByKGEsYyl7dmFyIGs9Yy5jYXNlSW5zZW5zaXRpdmVNYXRjaCxkPXtvcmlnaW5hbFBhdGg6YSxyZWdleHA6YX0sZz1kLmtleXM9W107YT1hLnJlcGxhY2UoLyhbKCkuXSkvZyxcXG5cXFwiXFxcXFxcXFwkMVxcXCIpLnJlcGxhY2UoLyhcXFxcLyk/OihcXFxcdyspKFtcXFxcP3xcXFxcKl0pPy9nLGZ1bmN0aW9uKGEsYyxoLGQpe2E9XFxcIj9cXFwiPT09ZD9kOm51bGw7ZD1cXFwiKlxcXCI9PT1kP2Q6bnVsbDtnLnB1c2goe25hbWU6aCxvcHRpb25hbDohIWF9KTtjPWN8fFxcXCJcXFwiO3JldHVyblxcXCJcXFwiKyhhP1xcXCJcXFwiOmMpK1xcXCIoPzpcXFwiKyhhP2M6XFxcIlxcXCIpKyhkJiZcXFwiKC4rPylcXFwifHxcXFwiKFteL10rKVxcXCIpKyhhfHxcXFwiXFxcIikrXFxcIilcXFwiKyhhfHxcXFwiXFxcIil9KS5yZXBsYWNlKC8oW1xcXFwvJFxcXFwqXSkvZyxcXFwiXFxcXFxcXFwkMVxcXCIpO2QucmVnZXhwPVJlZ0V4cChcXFwiXlxcXCIrYStcXFwiJFxcXCIsaz9cXFwiaVxcXCI6XFxcIlxcXCIpO3JldHVybiBkfXZhciBnPXt9O3RoaXMud2hlbj1mdW5jdGlvbihhLGgpe2dbYV09Yy5leHRlbmQoe3JlbG9hZE9uU2VhcmNoOiEwfSxoLGEmJnIoYSxoKSk7aWYoYSl7dmFyIGs9XFxcIi9cXFwiPT1hW2EubGVuZ3RoLTFdP2Euc3Vic3RyKDAsYS5sZW5ndGgtMSk6YStcXFwiL1xcXCI7Z1trXT1jLmV4dGVuZCh7cmVkaXJlY3RUbzphfSxyKGssaCkpfXJldHVybiB0aGlzfTt0aGlzLm90aGVyd2lzZT1mdW5jdGlvbihhKXt0aGlzLndoZW4obnVsbCxcXG5hKTtyZXR1cm4gdGhpc307dGhpcy4kZ2V0PVtcXFwiJHJvb3RTY29wZVxcXCIsXFxcIiRsb2NhdGlvblxcXCIsXFxcIiRyb3V0ZVBhcmFtc1xcXCIsXFxcIiRxXFxcIixcXFwiJGluamVjdG9yXFxcIixcXFwiJGh0dHBcXFwiLFxcXCIkdGVtcGxhdGVDYWNoZVxcXCIsXFxcIiRzY2VcXFwiLGZ1bmN0aW9uKGEsaCxrLGQscix1LHQsdyl7ZnVuY3Rpb24gdigpe3ZhciBiPXgoKSxmPW4uY3VycmVudDtpZihiJiZmJiZiLiQkcm91dGU9PT1mLiQkcm91dGUmJmMuZXF1YWxzKGIucGF0aFBhcmFtcyxmLnBhdGhQYXJhbXMpJiYhYi5yZWxvYWRPblNlYXJjaCYmIW0pZi5wYXJhbXM9Yi5wYXJhbXMsYy5jb3B5KGYucGFyYW1zLGspLGEuJGJyb2FkY2FzdChcXFwiJHJvdXRlVXBkYXRlXFxcIixmKTtlbHNlIGlmKGJ8fGYpbT0hMSxhLiRicm9hZGNhc3QoXFxcIiRyb3V0ZUNoYW5nZVN0YXJ0XFxcIixiLGYpLChuLmN1cnJlbnQ9YikmJmIucmVkaXJlY3RUbyYmKGMuaXNTdHJpbmcoYi5yZWRpcmVjdFRvKT9oLnBhdGgobChiLnJlZGlyZWN0VG8sYi5wYXJhbXMpKS5zZWFyY2goYi5wYXJhbXMpLnJlcGxhY2UoKTpcXG5oLnVybChiLnJlZGlyZWN0VG8oYi5wYXRoUGFyYW1zLGgucGF0aCgpLGguc2VhcmNoKCkpKS5yZXBsYWNlKCkpLGQud2hlbihiKS50aGVuKGZ1bmN0aW9uKCl7aWYoYil7dmFyIGE9Yy5leHRlbmQoe30sYi5yZXNvbHZlKSxmLGU7Yy5mb3JFYWNoKGEsZnVuY3Rpb24oYixmKXthW2ZdPWMuaXNTdHJpbmcoYik/ci5nZXQoYik6ci5pbnZva2UoYil9KTtjLmlzRGVmaW5lZChmPWIudGVtcGxhdGUpP2MuaXNGdW5jdGlvbihmKSYmKGY9ZihiLnBhcmFtcykpOmMuaXNEZWZpbmVkKGU9Yi50ZW1wbGF0ZVVybCkmJihjLmlzRnVuY3Rpb24oZSkmJihlPWUoYi5wYXJhbXMpKSxlPXcuZ2V0VHJ1c3RlZFJlc291cmNlVXJsKGUpLGMuaXNEZWZpbmVkKGUpJiYoYi5sb2FkZWRUZW1wbGF0ZVVybD1lLGY9dS5nZXQoZSx7Y2FjaGU6dH0pLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGIuZGF0YX0pKSk7Yy5pc0RlZmluZWQoZikmJihhLiR0ZW1wbGF0ZT1mKTtyZXR1cm4gZC5hbGwoYSl9fSkudGhlbihmdW5jdGlvbihkKXtiPT1cXG5uLmN1cnJlbnQmJihiJiYoYi5sb2NhbHM9ZCxjLmNvcHkoYi5wYXJhbXMsaykpLGEuJGJyb2FkY2FzdChcXFwiJHJvdXRlQ2hhbmdlU3VjY2Vzc1xcXCIsYixmKSl9LGZ1bmN0aW9uKGMpe2I9PW4uY3VycmVudCYmYS4kYnJvYWRjYXN0KFxcXCIkcm91dGVDaGFuZ2VFcnJvclxcXCIsYixmLGMpfSl9ZnVuY3Rpb24geCgpe3ZhciBiLGE7Yy5mb3JFYWNoKGcsZnVuY3Rpb24oZCxsKXt2YXIgZTtpZihlPSFhKXt2YXIgcD1oLnBhdGgoKTtlPWQua2V5czt2YXIgcT17fTtpZihkLnJlZ2V4cClpZihwPWQucmVnZXhwLmV4ZWMocCkpe2Zvcih2YXIgZz0xLGs9cC5sZW5ndGg7ZzxrOysrZyl7dmFyIG09ZVtnLTFdLG49XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBwW2ddP2RlY29kZVVSSUNvbXBvbmVudChwW2ddKTpwW2ddO20mJm4mJihxW20ubmFtZV09bil9ZT1xfWVsc2UgZT1udWxsO2Vsc2UgZT1udWxsO2U9Yj1lfWUmJihhPXMoZCx7cGFyYW1zOmMuZXh0ZW5kKHt9LGguc2VhcmNoKCksYikscGF0aFBhcmFtczpifSksYS4kJHJvdXRlPVxcbmQpfSk7cmV0dXJuIGF8fGdbbnVsbF0mJnMoZ1tudWxsXSx7cGFyYW1zOnt9LHBhdGhQYXJhbXM6e319KX1mdW5jdGlvbiBsKGEsZCl7dmFyIGc9W107Yy5mb3JFYWNoKChhfHxcXFwiXFxcIikuc3BsaXQoXFxcIjpcXFwiKSxmdW5jdGlvbihhLGIpe2lmKDA9PT1iKWcucHVzaChhKTtlbHNle3ZhciBjPWEubWF0Y2goLyhcXFxcdyspKC4qKS8pLGg9Y1sxXTtnLnB1c2goZFtoXSk7Zy5wdXNoKGNbMl18fFxcXCJcXFwiKTtkZWxldGUgZFtoXX19KTtyZXR1cm4gZy5qb2luKFxcXCJcXFwiKX12YXIgbT0hMSxuPXtyb3V0ZXM6ZyxyZWxvYWQ6ZnVuY3Rpb24oKXttPSEwO2EuJGV2YWxBc3luYyh2KX19O2EuJG9uKFxcXCIkbG9jYXRpb25DaGFuZ2VTdWNjZXNzXFxcIix2KTtyZXR1cm4gbn1dfSk7dC5wcm92aWRlcihcXFwiJHJvdXRlUGFyYW1zXFxcIixmdW5jdGlvbigpe3RoaXMuJGdldD1mdW5jdGlvbigpe3JldHVybnt9fX0pO3QuZGlyZWN0aXZlKFxcXCJuZ1ZpZXdcXFwiLHcpO3cuJGluamVjdD1bXFxcIiRyb3V0ZVxcXCIsXFxcIiRhbmNob3JTY3JvbGxcXFwiLFxcXCIkY29tcGlsZVxcXCIsXFxcIiRjb250cm9sbGVyXFxcIixcXG5cXFwiJGFuaW1hdGVcXFwiXX0pKHdpbmRvdyx3aW5kb3cuYW5ndWxhcik7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW5ndWxhci1yb3V0ZS5taW4uanMubWFwXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLXJvdXRlL2FuZ3VsYXItcm91dGUubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsInJlcXVpcmUoXCIhIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItcmVzb3VyY2UvYW5ndWxhci1yZXNvdXJjZS5taW4uanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1yZXNvdXJjZS9hbmd1bGFyLXJlc291cmNlLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXG4gQW5ndWxhckpTIHYxLjMuMTVcXG4gKGMpIDIwMTAtMjAxNCBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcXG4gTGljZW5zZTogTUlUXFxuKi9cXG4oZnVuY3Rpb24oSSxkLEIpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBEKGYscSl7cT1xfHx7fTtkLmZvckVhY2gocSxmdW5jdGlvbihkLGgpe2RlbGV0ZSBxW2hdfSk7Zm9yKHZhciBoIGluIGYpIWYuaGFzT3duUHJvcGVydHkoaCl8fFxcXCIkXFxcIj09PWguY2hhckF0KDApJiZcXFwiJFxcXCI9PT1oLmNoYXJBdCgxKXx8KHFbaF09ZltoXSk7cmV0dXJuIHF9dmFyIHc9ZC4kJG1pbkVycihcXFwiJHJlc291cmNlXFxcIiksQz0vXihcXFxcLlthLXpBLVpfJF1bMC05YS16QS1aXyRdKikrJC87ZC5tb2R1bGUoXFxcIm5nUmVzb3VyY2VcXFwiLFtcXFwibmdcXFwiXSkucHJvdmlkZXIoXFxcIiRyZXNvdXJjZVxcXCIsZnVuY3Rpb24oKXt2YXIgZj10aGlzO3RoaXMuZGVmYXVsdHM9e3N0cmlwVHJhaWxpbmdTbGFzaGVzOiEwLGFjdGlvbnM6e2dldDp7bWV0aG9kOlxcXCJHRVRcXFwifSxzYXZlOnttZXRob2Q6XFxcIlBPU1RcXFwifSxxdWVyeTp7bWV0aG9kOlxcXCJHRVRcXFwiLGlzQXJyYXk6ITB9LHJlbW92ZTp7bWV0aG9kOlxcXCJERUxFVEVcXFwifSxcXFwiZGVsZXRlXFxcIjp7bWV0aG9kOlxcXCJERUxFVEVcXFwifX19O1xcbnRoaXMuJGdldD1bXFxcIiRodHRwXFxcIixcXFwiJHFcXFwiLGZ1bmN0aW9uKHEsaCl7ZnVuY3Rpb24gdChkLGcpe3RoaXMudGVtcGxhdGU9ZDt0aGlzLmRlZmF1bHRzPXMoe30sZi5kZWZhdWx0cyxnKTt0aGlzLnVybFBhcmFtcz17fX1mdW5jdGlvbiB2KHgsZyxsLG0pe2Z1bmN0aW9uIGMoYixrKXt2YXIgYz17fTtrPXMoe30sZyxrKTtyKGssZnVuY3Rpb24oYSxrKXt1KGEpJiYoYT1hKCkpO3ZhciBkO2lmKGEmJmEuY2hhckF0JiZcXFwiQFxcXCI9PWEuY2hhckF0KDApKXtkPWI7dmFyIGU9YS5zdWJzdHIoMSk7aWYobnVsbD09ZXx8XFxcIlxcXCI9PT1lfHxcXFwiaGFzT3duUHJvcGVydHlcXFwiPT09ZXx8IUMudGVzdChcXFwiLlxcXCIrZSkpdGhyb3cgdyhcXFwiYmFkbWVtYmVyXFxcIixlKTtmb3IodmFyIGU9ZS5zcGxpdChcXFwiLlxcXCIpLG49MCxnPWUubGVuZ3RoO248ZyYmZCE9PUI7bisrKXt2YXIgaD1lW25dO2Q9bnVsbCE9PWQ/ZFtoXTpCfX1lbHNlIGQ9YTtjW2tdPWR9KTtyZXR1cm4gY31mdW5jdGlvbiBGKGIpe3JldHVybiBiLnJlc291cmNlfWZ1bmN0aW9uIGUoYil7RChifHxcXG57fSx0aGlzKX12YXIgRz1uZXcgdCh4LG0pO2w9cyh7fSxmLmRlZmF1bHRzLmFjdGlvbnMsbCk7ZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7dmFyIGI9cyh7fSx0aGlzKTtkZWxldGUgYi4kcHJvbWlzZTtkZWxldGUgYi4kcmVzb2x2ZWQ7cmV0dXJuIGJ9O3IobCxmdW5jdGlvbihiLGspe3ZhciBnPS9eKFBPU1R8UFVUfFBBVENIKSQvaS50ZXN0KGIubWV0aG9kKTtlW2tdPWZ1bmN0aW9uKGEseSxtLHgpe3ZhciBuPXt9LGYsbCx6O3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDQ6ej14LGw9bTtjYXNlIDM6Y2FzZSAyOmlmKHUoeSkpe2lmKHUoYSkpe2w9YTt6PXk7YnJlYWt9bD15O3o9bX1lbHNle249YTtmPXk7bD1tO2JyZWFrfWNhc2UgMTp1KGEpP2w9YTpnP2Y9YTpuPWE7YnJlYWs7Y2FzZSAwOmJyZWFrO2RlZmF1bHQ6dGhyb3cgdyhcXFwiYmFkYXJnc1xcXCIsYXJndW1lbnRzLmxlbmd0aCk7fXZhciB0PXRoaXMgaW5zdGFuY2VvZiBlLHA9dD9mOmIuaXNBcnJheT9bXTpuZXcgZShmKSxcXG5BPXt9LHY9Yi5pbnRlcmNlcHRvciYmYi5pbnRlcmNlcHRvci5yZXNwb25zZXx8RixDPWIuaW50ZXJjZXB0b3ImJmIuaW50ZXJjZXB0b3IucmVzcG9uc2VFcnJvcnx8QjtyKGIsZnVuY3Rpb24oYixhKXtcXFwicGFyYW1zXFxcIiE9YSYmXFxcImlzQXJyYXlcXFwiIT1hJiZcXFwiaW50ZXJjZXB0b3JcXFwiIT1hJiYoQVthXT1IKGIpKX0pO2cmJihBLmRhdGE9Zik7Ry5zZXRVcmxQYXJhbXMoQSxzKHt9LGMoZixiLnBhcmFtc3x8e30pLG4pLGIudXJsKTtuPXEoQSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz1hLmRhdGEsZz1wLiRwcm9taXNlO2lmKGMpe2lmKGQuaXNBcnJheShjKSE9PSEhYi5pc0FycmF5KXRocm93IHcoXFxcImJhZGNmZ1xcXCIsayxiLmlzQXJyYXk/XFxcImFycmF5XFxcIjpcXFwib2JqZWN0XFxcIixkLmlzQXJyYXkoYyk/XFxcImFycmF5XFxcIjpcXFwib2JqZWN0XFxcIik7Yi5pc0FycmF5PyhwLmxlbmd0aD0wLHIoYyxmdW5jdGlvbihhKXtcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBhP3AucHVzaChuZXcgZShhKSk6cC5wdXNoKGEpfSkpOihEKGMscCkscC4kcHJvbWlzZT1cXG5nKX1wLiRyZXNvbHZlZD0hMDthLnJlc291cmNlPXA7cmV0dXJuIGF9LGZ1bmN0aW9uKGEpe3AuJHJlc29sdmVkPSEwOyh6fHxFKShhKTtyZXR1cm4gaC5yZWplY3QoYSl9KTtuPW4udGhlbihmdW5jdGlvbihhKXt2YXIgYj12KGEpOyhsfHxFKShiLGEuaGVhZGVycyk7cmV0dXJuIGJ9LEMpO3JldHVybiB0P246KHAuJHByb21pc2U9bixwLiRyZXNvbHZlZD0hMSxwKX07ZS5wcm90b3R5cGVbXFxcIiRcXFwiK2tdPWZ1bmN0aW9uKGEsYixjKXt1KGEpJiYoYz1iLGI9YSxhPXt9KTthPWVba10uY2FsbCh0aGlzLGEsdGhpcyxiLGMpO3JldHVybiBhLiRwcm9taXNlfHxhfX0pO2UuYmluZD1mdW5jdGlvbihiKXtyZXR1cm4gdih4LHMoe30sZyxiKSxsKX07cmV0dXJuIGV9dmFyIEU9ZC5ub29wLHI9ZC5mb3JFYWNoLHM9ZC5leHRlbmQsSD1kLmNvcHksdT1kLmlzRnVuY3Rpb247dC5wcm90b3R5cGU9e3NldFVybFBhcmFtczpmdW5jdGlvbihmLGcsbCl7dmFyIG09dGhpcyxjPWx8fG0udGVtcGxhdGUsaCxcXG5lLHE9bS51cmxQYXJhbXM9e307cihjLnNwbGl0KC9cXFxcVy8pLGZ1bmN0aW9uKGIpe2lmKFxcXCJoYXNPd25Qcm9wZXJ0eVxcXCI9PT1iKXRocm93IHcoXFxcImJhZG5hbWVcXFwiKTshL15cXFxcZCskLy50ZXN0KGIpJiZiJiYobmV3IFJlZ0V4cChcXFwiKF58W15cXFxcXFxcXFxcXFxcXFxcXSk6XFxcIitiK1xcXCIoXFxcXFxcXFxXfCQpXFxcIikpLnRlc3QoYykmJihxW2JdPSEwKX0pO2M9Yy5yZXBsYWNlKC9cXFxcXFxcXDovZyxcXFwiOlxcXCIpO2c9Z3x8e307cihtLnVybFBhcmFtcyxmdW5jdGlvbihiLGspe2g9Zy5oYXNPd25Qcm9wZXJ0eShrKT9nW2tdOm0uZGVmYXVsdHNba107ZC5pc0RlZmluZWQoaCkmJm51bGwhPT1oPyhlPWVuY29kZVVSSUNvbXBvbmVudChoKS5yZXBsYWNlKC8lNDAvZ2ksXFxcIkBcXFwiKS5yZXBsYWNlKC8lM0EvZ2ksXFxcIjpcXFwiKS5yZXBsYWNlKC8lMjQvZyxcXFwiJFxcXCIpLnJlcGxhY2UoLyUyQy9naSxcXFwiLFxcXCIpLnJlcGxhY2UoLyUyMC9nLFxcXCIlMjBcXFwiKS5yZXBsYWNlKC8lMjYvZ2ksXFxcIiZcXFwiKS5yZXBsYWNlKC8lM0QvZ2ksXFxcIj1cXFwiKS5yZXBsYWNlKC8lMkIvZ2ksXFxcIitcXFwiKSxjPWMucmVwbGFjZShuZXcgUmVnRXhwKFxcXCI6XFxcIitcXG5rK1xcXCIoXFxcXFxcXFxXfCQpXFxcIixcXFwiZ1xcXCIpLGZ1bmN0aW9uKGIsYSl7cmV0dXJuIGUrYX0pKTpjPWMucmVwbGFjZShuZXcgUmVnRXhwKFxcXCIoLz8pOlxcXCIraytcXFwiKFxcXFxcXFxcV3wkKVxcXCIsXFxcImdcXFwiKSxmdW5jdGlvbihiLGEsYyl7cmV0dXJuXFxcIi9cXFwiPT1jLmNoYXJBdCgwKT9jOmErY30pfSk7bS5kZWZhdWx0cy5zdHJpcFRyYWlsaW5nU2xhc2hlcyYmKGM9Yy5yZXBsYWNlKC9cXFxcLyskLyxcXFwiXFxcIil8fFxcXCIvXFxcIik7Yz1jLnJlcGxhY2UoL1xcXFwvXFxcXC4oPz1cXFxcdysoJHxcXFxcPykpLyxcXFwiLlxcXCIpO2YudXJsPWMucmVwbGFjZSgvXFxcXC9cXFxcXFxcXFxcXFwuLyxcXFwiLy5cXFwiKTtyKGcsZnVuY3Rpb24oYixjKXttLnVybFBhcmFtc1tjXXx8KGYucGFyYW1zPWYucGFyYW1zfHx7fSxmLnBhcmFtc1tjXT1iKX0pfX07cmV0dXJuIHZ9XX0pfSkod2luZG93LHdpbmRvdy5hbmd1bGFyKTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmd1bGFyLXJlc291cmNlLm1pbi5qcy5tYXBcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItcmVzb3VyY2UvYW5ndWxhci1yZXNvdXJjZS5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwicmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1ib290c3RyYXAvdWktYm9vdHN0cmFwLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWJvb3RzdHJhcC91aS1ib290c3RyYXAubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbiAqIGFuZ3VsYXItdWktYm9vdHN0cmFwXFxuICogaHR0cDovL2FuZ3VsYXItdWkuZ2l0aHViLmlvL2Jvb3RzdHJhcC9cXG5cXG4gKiBWZXJzaW9uOiAxLjEuMSAtIDIwMTYtMDEtMjVcXG4gKiBMaWNlbnNlOiBNSVRcXG4gKi9hbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwXFxcIixbXFxcInVpLmJvb3RzdHJhcC5jb2xsYXBzZVxcXCIsXFxcInVpLmJvb3RzdHJhcC5hY2NvcmRpb25cXFwiLFxcXCJ1aS5ib290c3RyYXAuYWxlcnRcXFwiLFxcXCJ1aS5ib290c3RyYXAuYnV0dG9uc1xcXCIsXFxcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFxcXCIsXFxcInVpLmJvb3RzdHJhcC5kYXRlcGFyc2VyXFxcIixcXFwidWkuYm9vdHN0cmFwLmlzQ2xhc3NcXFwiLFxcXCJ1aS5ib290c3RyYXAucG9zaXRpb25cXFwiLFxcXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclxcXCIsXFxcInVpLmJvb3RzdHJhcC5kZWJvdW5jZVxcXCIsXFxcInVpLmJvb3RzdHJhcC5kcm9wZG93blxcXCIsXFxcInVpLmJvb3RzdHJhcC5zdGFja2VkTWFwXFxcIixcXFwidWkuYm9vdHN0cmFwLm1vZGFsXFxcIixcXFwidWkuYm9vdHN0cmFwLnBhZ2luZ1xcXCIsXFxcInVpLmJvb3RzdHJhcC5wYWdlclxcXCIsXFxcInVpLmJvb3RzdHJhcC5wYWdpbmF0aW9uXFxcIixcXFwidWkuYm9vdHN0cmFwLnRvb2x0aXBcXFwiLFxcXCJ1aS5ib290c3RyYXAucG9wb3ZlclxcXCIsXFxcInVpLmJvb3RzdHJhcC5wcm9ncmVzc2JhclxcXCIsXFxcInVpLmJvb3RzdHJhcC5yYXRpbmdcXFwiLFxcXCJ1aS5ib290c3RyYXAudGFic1xcXCIsXFxcInVpLmJvb3RzdHJhcC50aW1lcGlja2VyXFxcIixcXFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFxcXCJdKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmNvbGxhcHNlXFxcIixbXSkuZGlyZWN0aXZlKFxcXCJ1aWJDb2xsYXBzZVxcXCIsW1xcXCIkYW5pbWF0ZVxcXCIsXFxcIiRxXFxcIixcXFwiJHBhcnNlXFxcIixcXFwiJGluamVjdG9yXFxcIixmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kLmhhcyhcXFwiJGFuaW1hdGVDc3NcXFwiKT9kLmdldChcXFwiJGFuaW1hdGVDc3NcXFwiKTpudWxsO3JldHVybntsaW5rOmZ1bmN0aW9uKGQsZixnKXtmdW5jdGlvbiBoKCl7Zi5oYXNDbGFzcyhcXFwiY29sbGFwc2VcXFwiKSYmZi5oYXNDbGFzcyhcXFwiaW5cXFwiKXx8Yi5yZXNvbHZlKGwoZCkpLnRoZW4oZnVuY3Rpb24oKXtmLnJlbW92ZUNsYXNzKFxcXCJjb2xsYXBzZVxcXCIpLmFkZENsYXNzKFxcXCJjb2xsYXBzaW5nXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITApLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMSksZT9lKGYse2FkZENsYXNzOlxcXCJpblxcXCIsZWFzaW5nOlxcXCJlYXNlXFxcIix0bzp7aGVpZ2h0OmZbMF0uc2Nyb2xsSGVpZ2h0K1xcXCJweFxcXCJ9fSkuc3RhcnQoKVtcXFwiZmluYWxseVxcXCJdKGkpOmEuYWRkQ2xhc3MoZixcXFwiaW5cXFwiLHt0bzp7aGVpZ2h0OmZbMF0uc2Nyb2xsSGVpZ2h0K1xcXCJweFxcXCJ9fSkudGhlbihpKX0pfWZ1bmN0aW9uIGkoKXtmLnJlbW92ZUNsYXNzKFxcXCJjb2xsYXBzaW5nXFxcIikuYWRkQ2xhc3MoXFxcImNvbGxhcHNlXFxcIikuY3NzKHtoZWlnaHQ6XFxcImF1dG9cXFwifSksbShkKX1mdW5jdGlvbiBqKCl7cmV0dXJuIGYuaGFzQ2xhc3MoXFxcImNvbGxhcHNlXFxcIil8fGYuaGFzQ2xhc3MoXFxcImluXFxcIik/dm9pZCBiLnJlc29sdmUobihkKSkudGhlbihmdW5jdGlvbigpe2YuY3NzKHtoZWlnaHQ6ZlswXS5zY3JvbGxIZWlnaHQrXFxcInB4XFxcIn0pLnJlbW92ZUNsYXNzKFxcXCJjb2xsYXBzZVxcXCIpLmFkZENsYXNzKFxcXCJjb2xsYXBzaW5nXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksZT9lKGYse3JlbW92ZUNsYXNzOlxcXCJpblxcXCIsdG86e2hlaWdodDpcXFwiMFxcXCJ9fSkuc3RhcnQoKVtcXFwiZmluYWxseVxcXCJdKGspOmEucmVtb3ZlQ2xhc3MoZixcXFwiaW5cXFwiLHt0bzp7aGVpZ2h0OlxcXCIwXFxcIn19KS50aGVuKGspfSk6aygpfWZ1bmN0aW9uIGsoKXtmLmNzcyh7aGVpZ2h0OlxcXCIwXFxcIn0pLGYucmVtb3ZlQ2xhc3MoXFxcImNvbGxhcHNpbmdcXFwiKS5hZGRDbGFzcyhcXFwiY29sbGFwc2VcXFwiKSxvKGQpfXZhciBsPWMoZy5leHBhbmRpbmcpLG09YyhnLmV4cGFuZGVkKSxuPWMoZy5jb2xsYXBzaW5nKSxvPWMoZy5jb2xsYXBzZWQpO2QuJGV2YWwoZy51aWJDb2xsYXBzZSl8fGYuYWRkQ2xhc3MoXFxcImluXFxcIikuYWRkQ2xhc3MoXFxcImNvbGxhcHNlXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITApLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMSkuY3NzKHtoZWlnaHQ6XFxcImF1dG9cXFwifSksZC4kd2F0Y2goZy51aWJDb2xsYXBzZSxmdW5jdGlvbihhKXthP2ooKTpoKCl9KX19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuYWNjb3JkaW9uXFxcIixbXFxcInVpLmJvb3RzdHJhcC5jb2xsYXBzZVxcXCJdKS5jb25zdGFudChcXFwidWliQWNjb3JkaW9uQ29uZmlnXFxcIix7Y2xvc2VPdGhlcnM6ITB9KS5jb250cm9sbGVyKFxcXCJVaWJBY2NvcmRpb25Db250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcInVpYkFjY29yZGlvbkNvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiLGMpe3RoaXMuZ3JvdXBzPVtdLHRoaXMuY2xvc2VPdGhlcnM9ZnVuY3Rpb24oZCl7dmFyIGU9YW5ndWxhci5pc0RlZmluZWQoYi5jbG9zZU90aGVycyk/YS4kZXZhbChiLmNsb3NlT3RoZXJzKTpjLmNsb3NlT3RoZXJzO2UmJmFuZ3VsYXIuZm9yRWFjaCh0aGlzLmdyb3VwcyxmdW5jdGlvbihhKXthIT09ZCYmKGEuaXNPcGVuPSExKX0pfSx0aGlzLmFkZEdyb3VwPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5ncm91cHMucHVzaChhKSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKGMpe2IucmVtb3ZlR3JvdXAoYSl9KX0sdGhpcy5yZW1vdmVHcm91cD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmdyb3Vwcy5pbmRleE9mKGEpOy0xIT09YiYmdGhpcy5ncm91cHMuc3BsaWNlKGIsMSl9fV0pLmRpcmVjdGl2ZShcXFwidWliQWNjb3JkaW9uXFxcIixmdW5jdGlvbigpe3JldHVybntjb250cm9sbGVyOlxcXCJVaWJBY2NvcmRpb25Db250cm9sbGVyXFxcIixjb250cm9sbGVyQXM6XFxcImFjY29yZGlvblxcXCIsdHJhbnNjbHVkZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFxcXCJ9fX0pLmRpcmVjdGl2ZShcXFwidWliQWNjb3JkaW9uR3JvdXBcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcXVpcmU6XFxcIl51aWJBY2NvcmRpb25cXFwiLHRyYW5zY2x1ZGU6ITAscmVwbGFjZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFxcXCJ9LHNjb3BlOntoZWFkaW5nOlxcXCJAXFxcIixpc09wZW46XFxcIj0/XFxcIixpc0Rpc2FibGVkOlxcXCI9P1xcXCJ9LGNvbnRyb2xsZXI6ZnVuY3Rpb24oKXt0aGlzLnNldEhlYWRpbmc9ZnVuY3Rpb24oYSl7dGhpcy5oZWFkaW5nPWF9fSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2QuYWRkR3JvdXAoYSksYS5vcGVuQ2xhc3M9Yy5vcGVuQ2xhc3N8fFxcXCJwYW5lbC1vcGVuXFxcIixhLnBhbmVsQ2xhc3M9Yy5wYW5lbENsYXNzfHxcXFwicGFuZWwtZGVmYXVsdFxcXCIsYS4kd2F0Y2goXFxcImlzT3BlblxcXCIsZnVuY3Rpb24oYyl7Yi50b2dnbGVDbGFzcyhhLm9wZW5DbGFzcywhIWMpLGMmJmQuY2xvc2VPdGhlcnMoYSl9KSxhLnRvZ2dsZU9wZW49ZnVuY3Rpb24oYil7YS5pc0Rpc2FibGVkfHxiJiYzMiE9PWIud2hpY2h8fChhLmlzT3Blbj0hYS5pc09wZW4pfX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJBY2NvcmRpb25IZWFkaW5nXFxcIixmdW5jdGlvbigpe3JldHVybnt0cmFuc2NsdWRlOiEwLHRlbXBsYXRlOlxcXCJcXFwiLHJlcGxhY2U6ITAscmVxdWlyZTpcXFwiXnVpYkFjY29yZGlvbkdyb3VwXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQsZSl7ZC5zZXRIZWFkaW5nKGUoYSxhbmd1bGFyLm5vb3ApKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJBY2NvcmRpb25UcmFuc2NsdWRlXFxcIixmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOlxcXCJedWliQWNjb3JkaW9uR3JvdXBcXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7YS4kd2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZFtjLnVpYkFjY29yZGlvblRyYW5zY2x1ZGVdfSxmdW5jdGlvbihhKXthJiYoYi5maW5kKFxcXCJzcGFuXFxcIikuaHRtbChcXFwiXFxcIiksYi5maW5kKFxcXCJzcGFuXFxcIikuYXBwZW5kKGEpKX0pfX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmFsZXJ0XFxcIixbXSkuY29udHJvbGxlcihcXFwiVWliQWxlcnRDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcIiRpbnRlcnBvbGF0ZVxcXCIsXFxcIiR0aW1lb3V0XFxcIixmdW5jdGlvbihhLGIsYyxkKXthLmNsb3NlYWJsZT0hIWIuY2xvc2U7dmFyIGU9YW5ndWxhci5pc0RlZmluZWQoYi5kaXNtaXNzT25UaW1lb3V0KT9jKGIuZGlzbWlzc09uVGltZW91dCkoYS4kcGFyZW50KTpudWxsO2UmJmQoZnVuY3Rpb24oKXthLmNsb3NlKCl9LHBhcnNlSW50KGUsMTApKX1dKS5kaXJlY3RpdmUoXFxcInVpYkFsZXJ0XFxcIixmdW5jdGlvbigpe3JldHVybntjb250cm9sbGVyOlxcXCJVaWJBbGVydENvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwiYWxlcnRcXFwiLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFxcXCJ9LHRyYW5zY2x1ZGU6ITAscmVwbGFjZTohMCxzY29wZTp7dHlwZTpcXFwiQFxcXCIsY2xvc2U6XFxcIiZcXFwifX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmJ1dHRvbnNcXFwiLFtdKS5jb25zdGFudChcXFwidWliQnV0dG9uQ29uZmlnXFxcIix7YWN0aXZlQ2xhc3M6XFxcImFjdGl2ZVxcXCIsdG9nZ2xlRXZlbnQ6XFxcImNsaWNrXFxcIn0pLmNvbnRyb2xsZXIoXFxcIlVpYkJ1dHRvbnNDb250cm9sbGVyXFxcIixbXFxcInVpYkJ1dHRvbkNvbmZpZ1xcXCIsZnVuY3Rpb24oYSl7dGhpcy5hY3RpdmVDbGFzcz1hLmFjdGl2ZUNsYXNzfHxcXFwiYWN0aXZlXFxcIix0aGlzLnRvZ2dsZUV2ZW50PWEudG9nZ2xlRXZlbnR8fFxcXCJjbGlja1xcXCJ9XSkuZGlyZWN0aXZlKFxcXCJ1aWJCdG5SYWRpb1xcXCIsW1xcXCIkcGFyc2VcXFwiLGZ1bmN0aW9uKGEpe3JldHVybntyZXF1aXJlOltcXFwidWliQnRuUmFkaW9cXFwiLFxcXCJuZ01vZGVsXFxcIl0sY29udHJvbGxlcjpcXFwiVWliQnV0dG9uc0NvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwiYnV0dG9uc1xcXCIsbGluazpmdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1lWzBdLGc9ZVsxXSxoPWEoZC51aWJVbmNoZWNrYWJsZSk7Yy5maW5kKFxcXCJpbnB1dFxcXCIpLmNzcyh7ZGlzcGxheTpcXFwibm9uZVxcXCJ9KSxnLiRyZW5kZXI9ZnVuY3Rpb24oKXtjLnRvZ2dsZUNsYXNzKGYuYWN0aXZlQ2xhc3MsYW5ndWxhci5lcXVhbHMoZy4kbW9kZWxWYWx1ZSxiLiRldmFsKGQudWliQnRuUmFkaW8pKSl9LGMub24oZi50b2dnbGVFdmVudCxmdW5jdGlvbigpe2lmKCFkLmRpc2FibGVkKXt2YXIgYT1jLmhhc0NsYXNzKGYuYWN0aXZlQ2xhc3MpOyghYXx8YW5ndWxhci5pc0RlZmluZWQoZC51bmNoZWNrYWJsZSkpJiZiLiRhcHBseShmdW5jdGlvbigpe2cuJHNldFZpZXdWYWx1ZShhP251bGw6Yi4kZXZhbChkLnVpYkJ0blJhZGlvKSksZy4kcmVuZGVyKCl9KX19KSxkLnVpYlVuY2hlY2thYmxlJiZiLiR3YXRjaChoLGZ1bmN0aW9uKGEpe2QuJHNldChcXFwidW5jaGVja2FibGVcXFwiLGE/XFxcIlxcXCI6bnVsbCl9KX19fV0pLmRpcmVjdGl2ZShcXFwidWliQnRuQ2hlY2tib3hcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcXVpcmU6W1xcXCJ1aWJCdG5DaGVja2JveFxcXCIsXFxcIm5nTW9kZWxcXFwiXSxjb250cm9sbGVyOlxcXCJVaWJCdXR0b25zQ29udHJvbGxlclxcXCIsY29udHJvbGxlckFzOlxcXCJidXR0b25cXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7ZnVuY3Rpb24gZSgpe3JldHVybiBnKGMuYnRuQ2hlY2tib3hUcnVlLCEwKX1mdW5jdGlvbiBmKCl7cmV0dXJuIGcoYy5idG5DaGVja2JveEZhbHNlLCExKX1mdW5jdGlvbiBnKGIsYyl7cmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKGIpP2EuJGV2YWwoYik6Y312YXIgaD1kWzBdLGk9ZFsxXTtiLmZpbmQoXFxcImlucHV0XFxcIikuY3NzKHtkaXNwbGF5OlxcXCJub25lXFxcIn0pLGkuJHJlbmRlcj1mdW5jdGlvbigpe2IudG9nZ2xlQ2xhc3MoaC5hY3RpdmVDbGFzcyxhbmd1bGFyLmVxdWFscyhpLiRtb2RlbFZhbHVlLGUoKSkpfSxiLm9uKGgudG9nZ2xlRXZlbnQsZnVuY3Rpb24oKXtjLmRpc2FibGVkfHxhLiRhcHBseShmdW5jdGlvbigpe2kuJHNldFZpZXdWYWx1ZShiLmhhc0NsYXNzKGguYWN0aXZlQ2xhc3MpP2YoKTplKCkpLGkuJHJlbmRlcigpfSl9KX19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFxcXCIsW10pLmNvbnRyb2xsZXIoXFxcIlVpYkNhcm91c2VsQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkZWxlbWVudFxcXCIsXFxcIiRpbnRlcnZhbFxcXCIsXFxcIiR0aW1lb3V0XFxcIixcXFwiJGFuaW1hdGVcXFwiLGZ1bmN0aW9uKGEsYixjLGQsZSl7ZnVuY3Rpb24gZigpe2Zvcig7cy5sZW5ndGg7KXMuc2hpZnQoKX1mdW5jdGlvbiBnKGEpe2lmKGFuZ3VsYXIuaXNVbmRlZmluZWQocFthXS5pbmRleCkpcmV0dXJuIHBbYV07Zm9yKHZhciBiPTAsYz1wLmxlbmd0aDtjPmI7KytiKWlmKHBbYl0uaW5kZXg9PT1hKXJldHVybiBwW2JdfWZ1bmN0aW9uIGgoYyxkLGcpe3R8fChhbmd1bGFyLmV4dGVuZChjLHtkaXJlY3Rpb246ZyxhY3RpdmU6ITB9KSxhbmd1bGFyLmV4dGVuZChvLmN1cnJlbnRTbGlkZXx8e30se2RpcmVjdGlvbjpnLGFjdGl2ZTohMX0pLGUuZW5hYmxlZChiKSYmIWEuJGN1cnJlbnRUcmFuc2l0aW9uJiZjLiRlbGVtZW50JiZvLnNsaWRlcy5sZW5ndGg+MSYmKGMuJGVsZW1lbnQuZGF0YShxLGMuZGlyZWN0aW9uKSxvLmN1cnJlbnRTbGlkZSYmby5jdXJyZW50U2xpZGUuJGVsZW1lbnQmJm8uY3VycmVudFNsaWRlLiRlbGVtZW50LmRhdGEocSxjLmRpcmVjdGlvbiksYS4kY3VycmVudFRyYW5zaXRpb249ITAsZS5vbihcXFwiYWRkQ2xhc3NcXFwiLGMuJGVsZW1lbnQsZnVuY3Rpb24oYixjKXtpZihcXFwiY2xvc2VcXFwiPT09YyYmKGEuJGN1cnJlbnRUcmFuc2l0aW9uPW51bGwsZS5vZmYoXFxcImFkZENsYXNzXFxcIixiKSxzLmxlbmd0aCkpe3ZhciBkPXMucG9wKCksZz1hLmluZGV4T2ZTbGlkZShkKSxpPWc+by5nZXRDdXJyZW50SW5kZXgoKT9cXFwibmV4dFxcXCI6XFxcInByZXZcXFwiO2YoKSxoKGQsZyxpKX19KSksby5jdXJyZW50U2xpZGU9YyxyPWQsaygpKX1mdW5jdGlvbiBpKCl7bSYmKGMuY2FuY2VsKG0pLG09bnVsbCl9ZnVuY3Rpb24gaihiKXtiLmxlbmd0aHx8KGEuJGN1cnJlbnRUcmFuc2l0aW9uPW51bGwsZigpKX1mdW5jdGlvbiBrKCl7aSgpO3ZhciBiPSthLmludGVydmFsOyFpc05hTihiKSYmYj4wJiYobT1jKGwsYikpfWZ1bmN0aW9uIGwoKXt2YXIgYj0rYS5pbnRlcnZhbDtuJiYhaXNOYU4oYikmJmI+MCYmcC5sZW5ndGg/YS5uZXh0KCk6YS5wYXVzZSgpfXZhciBtLG4sbz10aGlzLHA9by5zbGlkZXM9YS5zbGlkZXM9W10scT1cXFwidWliLXNsaWRlRGlyZWN0aW9uXFxcIixyPS0xLHM9W107by5jdXJyZW50U2xpZGU9bnVsbDt2YXIgdD0hMTtvLmFkZFNsaWRlPWZ1bmN0aW9uKGIsYyl7Yi4kZWxlbWVudD1jLHAucHVzaChiKSwxPT09cC5sZW5ndGh8fGIuYWN0aXZlPyhhLiRjdXJyZW50VHJhbnNpdGlvbiYmKGEuJGN1cnJlbnRUcmFuc2l0aW9uPW51bGwpLG8uc2VsZWN0KHBbcC5sZW5ndGgtMV0pLDE9PT1wLmxlbmd0aCYmYS5wbGF5KCkpOmIuYWN0aXZlPSExfSxvLmdldEN1cnJlbnRJbmRleD1mdW5jdGlvbigpe3JldHVybiBvLmN1cnJlbnRTbGlkZSYmYW5ndWxhci5pc0RlZmluZWQoby5jdXJyZW50U2xpZGUuaW5kZXgpPytvLmN1cnJlbnRTbGlkZS5pbmRleDpyfSxvLm5leHQ9YS5uZXh0PWZ1bmN0aW9uKCl7dmFyIGI9KG8uZ2V0Q3VycmVudEluZGV4KCkrMSklcC5sZW5ndGg7cmV0dXJuIDA9PT1iJiZhLm5vV3JhcCgpP3ZvaWQgYS5wYXVzZSgpOm8uc2VsZWN0KGcoYiksXFxcIm5leHRcXFwiKX0sby5wcmV2PWEucHJldj1mdW5jdGlvbigpe3ZhciBiPW8uZ2V0Q3VycmVudEluZGV4KCktMTwwP3AubGVuZ3RoLTE6by5nZXRDdXJyZW50SW5kZXgoKS0xO3JldHVybiBhLm5vV3JhcCgpJiZiPT09cC5sZW5ndGgtMT92b2lkIGEucGF1c2UoKTpvLnNlbGVjdChnKGIpLFxcXCJwcmV2XFxcIil9LG8ucmVtb3ZlU2xpZGU9ZnVuY3Rpb24oYSl7YW5ndWxhci5pc0RlZmluZWQoYS5pbmRleCkmJnAuc29ydChmdW5jdGlvbihhLGIpe3JldHVybithLmluZGV4PitiLmluZGV4fSk7dmFyIGI9cy5pbmRleE9mKGEpOy0xIT09YiYmcy5zcGxpY2UoYiwxKTt2YXIgYz1wLmluZGV4T2YoYSk7cC5zcGxpY2UoYywxKSxkKGZ1bmN0aW9uKCl7cC5sZW5ndGg+MCYmYS5hY3RpdmU/Yz49cC5sZW5ndGg/by5zZWxlY3QocFtjLTFdKTpvLnNlbGVjdChwW2NdKTpyPmMmJnItLX0pLDA9PT1wLmxlbmd0aCYmKG8uY3VycmVudFNsaWRlPW51bGwsZigpKX0sby5zZWxlY3Q9YS5zZWxlY3Q9ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmluZGV4T2ZTbGlkZShiKTt2b2lkIDA9PT1jJiYoYz1kPm8uZ2V0Q3VycmVudEluZGV4KCk/XFxcIm5leHRcXFwiOlxcXCJwcmV2XFxcIiksYiYmYiE9PW8uY3VycmVudFNsaWRlJiYhYS4kY3VycmVudFRyYW5zaXRpb24/aChiLGQsYyk6YiYmYiE9PW8uY3VycmVudFNsaWRlJiZhLiRjdXJyZW50VHJhbnNpdGlvbiYmKHMucHVzaChiKSxiLmFjdGl2ZT0hMSl9LGEuaW5kZXhPZlNsaWRlPWZ1bmN0aW9uKGEpe3JldHVybiBhbmd1bGFyLmlzRGVmaW5lZChhLmluZGV4KT8rYS5pbmRleDpwLmluZGV4T2YoYSl9LGEuaXNBY3RpdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIG8uY3VycmVudFNsaWRlPT09YX0sYS5wYXVzZT1mdW5jdGlvbigpe2Eubm9QYXVzZXx8KG49ITEsaSgpKX0sYS5wbGF5PWZ1bmN0aW9uKCl7bnx8KG49ITAsaygpKX0sYS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe3Q9ITAsaSgpfSksYS4kd2F0Y2goXFxcIm5vVHJhbnNpdGlvblxcXCIsZnVuY3Rpb24oYSl7ZS5lbmFibGVkKGIsIWEpfSksYS4kd2F0Y2goXFxcImludGVydmFsXFxcIixrKSxhLiR3YXRjaENvbGxlY3Rpb24oXFxcInNsaWRlc1xcXCIsail9XSkuZGlyZWN0aXZlKFxcXCJ1aWJDYXJvdXNlbFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57dHJhbnNjbHVkZTohMCxyZXBsYWNlOiEwLGNvbnRyb2xsZXI6XFxcIlVpYkNhcm91c2VsQ29udHJvbGxlclxcXCIsY29udHJvbGxlckFzOlxcXCJjYXJvdXNlbFxcXCIsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXFxcIn0sc2NvcGU6e2ludGVydmFsOlxcXCI9XFxcIixub1RyYW5zaXRpb246XFxcIj1cXFwiLG5vUGF1c2U6XFxcIj1cXFwiLG5vV3JhcDpcXFwiJlxcXCJ9fX0pLmRpcmVjdGl2ZShcXFwidWliU2xpZGVcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcXVpcmU6XFxcIl51aWJDYXJvdXNlbFxcXCIsdHJhbnNjbHVkZTohMCxyZXBsYWNlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFxcXCJ9LHNjb3BlOnthY3RpdmU6XFxcIj0/XFxcIixhY3R1YWw6XFxcIj0/XFxcIixpbmRleDpcXFwiPT9cXFwifSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2QuYWRkU2xpZGUoYSxiKSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7ZC5yZW1vdmVTbGlkZShhKX0pLGEuJHdhdGNoKFxcXCJhY3RpdmVcXFwiLGZ1bmN0aW9uKGIpe2ImJmQuc2VsZWN0KGEpfSl9fX0pLmFuaW1hdGlvbihcXFwiLml0ZW1cXFwiLFtcXFwiJGFuaW1hdGVDc3NcXFwiLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiLGMpe2EucmVtb3ZlQ2xhc3MoYiksYyYmYygpfXZhciBjPVxcXCJ1aWItc2xpZGVEaXJlY3Rpb25cXFwiO3JldHVybntiZWZvcmVBZGRDbGFzczpmdW5jdGlvbihkLGUsZil7aWYoXFxcImFjdGl2ZVxcXCI9PT1lKXt2YXIgZz0hMSxoPWQuZGF0YShjKSxpPVxcXCJuZXh0XFxcIj09PWg/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCIsaj1iLmJpbmQodGhpcyxkLGkrXFxcIiBcXFwiK2gsZik7cmV0dXJuIGQuYWRkQ2xhc3MoaCksYShkLHthZGRDbGFzczppfSkuc3RhcnQoKS5kb25lKGopLGZ1bmN0aW9uKCl7Zz0hMH19ZigpfSxiZWZvcmVSZW1vdmVDbGFzczpmdW5jdGlvbihkLGUsZil7aWYoXFxcImFjdGl2ZVxcXCI9PT1lKXt2YXIgZz0hMSxoPWQuZGF0YShjKSxpPVxcXCJuZXh0XFxcIj09PWg/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCIsaj1iLmJpbmQodGhpcyxkLGksZik7cmV0dXJuIGEoZCx7YWRkQ2xhc3M6aX0pLnN0YXJ0KCkuZG9uZShqKSxmdW5jdGlvbigpe2c9ITB9fWYoKX19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuZGF0ZXBhcnNlclxcXCIsW10pLnNlcnZpY2UoXFxcInVpYkRhdGVQYXJzZXJcXFwiLFtcXFwiJGxvZ1xcXCIsXFxcIiRsb2NhbGVcXFwiLFxcXCJvcmRlckJ5RmlsdGVyXFxcIixmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXt2YXIgYj1bXSxkPWEuc3BsaXQoXFxcIlxcXCIpLGU9YS5pbmRleE9mKFxcXCInXFxcIik7aWYoZT4tMSl7dmFyIGY9ITE7YT1hLnNwbGl0KFxcXCJcXFwiKTtmb3IodmFyIGc9ZTtnPGEubGVuZ3RoO2crKylmPyhcXFwiJ1xcXCI9PT1hW2ddJiYoZysxPGEubGVuZ3RoJiZcXFwiJ1xcXCI9PT1hW2crMV0/KGFbZysxXT1cXFwiJFxcXCIsZFtnKzFdPVxcXCJcXFwiKTooZFtnXT1cXFwiXFxcIixmPSExKSksYVtnXT1cXFwiJFxcXCIpOlxcXCInXFxcIj09PWFbZ10mJihhW2ddPVxcXCIkXFxcIixkW2ddPVxcXCJcXFwiLGY9ITApO2E9YS5qb2luKFxcXCJcXFwiKX1yZXR1cm4gYW5ndWxhci5mb3JFYWNoKG0sZnVuY3Rpb24oYyl7dmFyIGU9YS5pbmRleE9mKGMua2V5KTtpZihlPi0xKXthPWEuc3BsaXQoXFxcIlxcXCIpLGRbZV09XFxcIihcXFwiK2MucmVnZXgrXFxcIilcXFwiLGFbZV09XFxcIiRcXFwiO2Zvcih2YXIgZj1lKzEsZz1lK2Mua2V5Lmxlbmd0aDtnPmY7ZisrKWRbZl09XFxcIlxcXCIsYVtmXT1cXFwiJFxcXCI7YT1hLmpvaW4oXFxcIlxcXCIpLGIucHVzaCh7aW5kZXg6ZSxhcHBseTpjLmFwcGx5LG1hdGNoZXI6Yy5yZWdleH0pfX0pLHtyZWdleDpuZXcgUmVnRXhwKFxcXCJeXFxcIitkLmpvaW4oXFxcIlxcXCIpK1xcXCIkXFxcIiksbWFwOmMoYixcXFwiaW5kZXhcXFwiKX19ZnVuY3Rpb24gZShhLGIsYyl7cmV0dXJuIDE+Yz8hMToxPT09YiYmYz4yOD8yOT09PWMmJihhJTQ9PT0wJiZhJTEwMCE9PTB8fGElNDAwPT09MCk6Mz09PWJ8fDU9PT1ifHw4PT09Ynx8MTA9PT1iPzMxPmM6ITB9ZnVuY3Rpb24gZihhKXtyZXR1cm4gcGFyc2VJbnQoYSwxMCl9ZnVuY3Rpb24gZyhhLGIpe3JldHVybiBhJiZiP2soYSxiKTphfWZ1bmN0aW9uIGgoYSxiKXtyZXR1cm4gYSYmYj9rKGEsYiwhMCk6YX1mdW5jdGlvbiBpKGEsYil7dmFyIGM9RGF0ZS5wYXJzZShcXFwiSmFuIDAxLCAxOTcwIDAwOjAwOjAwIFxcXCIrYSkvNmU0O3JldHVybiBpc05hTihjKT9iOmN9ZnVuY3Rpb24gaihhLGIpe3JldHVybiBhPW5ldyBEYXRlKGEuZ2V0VGltZSgpKSxhLnNldE1pbnV0ZXMoYS5nZXRNaW51dGVzKCkrYiksYX1mdW5jdGlvbiBrKGEsYixjKXtjPWM/LTE6MTt2YXIgZD1pKGIsYS5nZXRUaW1lem9uZU9mZnNldCgpKTtyZXR1cm4gaihhLGMqKGQtYS5nZXRUaW1lem9uZU9mZnNldCgpKSl9dmFyIGwsbSxuPS9bXFxcXFxcXFxcXFxcXlxcXFwkXFxcXCpcXFxcK1xcXFw/XFxcXHxcXFxcW1xcXFxdXFxcXChcXFxcKVxcXFwuXFxcXHtcXFxcfV0vZzt0aGlzLmluaXQ9ZnVuY3Rpb24oKXtsPWIuaWQsdGhpcy5wYXJzZXJzPXt9LG09W3trZXk6XFxcInl5eXlcXFwiLHJlZ2V4OlxcXCJcXFxcXFxcXGR7NH1cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMueWVhcj0rYX19LHtrZXk6XFxcInl5XFxcIixyZWdleDpcXFwiXFxcXFxcXFxkezJ9XFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLnllYXI9K2ErMmUzfX0se2tleTpcXFwieVxcXCIscmVnZXg6XFxcIlxcXFxcXFxcZHsxLDR9XFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLnllYXI9K2F9fSx7a2V5OlxcXCJNIVxcXCIscmVnZXg6XFxcIjA/WzEtOV18MVswLTJdXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLm1vbnRoPWEtMX19LHtrZXk6XFxcIk1NTU1cXFwiLHJlZ2V4OmIuREFURVRJTUVfRk9STUFUUy5NT05USC5qb2luKFxcXCJ8XFxcIiksYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5tb250aD1iLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguaW5kZXhPZihhKX19LHtrZXk6XFxcIk1NTVxcXCIscmVnZXg6Yi5EQVRFVElNRV9GT1JNQVRTLlNIT1JUTU9OVEguam9pbihcXFwifFxcXCIpLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMubW9udGg9Yi5EQVRFVElNRV9GT1JNQVRTLlNIT1JUTU9OVEguaW5kZXhPZihhKX19LHtrZXk6XFxcIk1NXFxcIixyZWdleDpcXFwiMFsxLTldfDFbMC0yXVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5tb250aD1hLTF9fSx7a2V5OlxcXCJNXFxcIixyZWdleDpcXFwiWzEtOV18MVswLTJdXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLm1vbnRoPWEtMX19LHtrZXk6XFxcImQhXFxcIixyZWdleDpcXFwiWzAtMl0/WzAtOV17MX18M1swLTFdezF9XFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmRhdGU9K2F9fSx7a2V5OlxcXCJkZFxcXCIscmVnZXg6XFxcIlswLTJdWzAtOV17MX18M1swLTFdezF9XFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmRhdGU9K2F9fSx7a2V5OlxcXCJkXFxcIixyZWdleDpcXFwiWzEtMl0/WzAtOV17MX18M1swLTFdezF9XFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmRhdGU9K2F9fSx7a2V5OlxcXCJFRUVFXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuREFZLmpvaW4oXFxcInxcXFwiKX0se2tleTpcXFwiRUVFXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuU0hPUlREQVkuam9pbihcXFwifFxcXCIpfSx7a2V5OlxcXCJISFxcXCIscmVnZXg6XFxcIig/OjB8MSlbMC05XXwyWzAtM11cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMuaG91cnM9K2F9fSx7a2V5OlxcXCJoaFxcXCIscmVnZXg6XFxcIjBbMC05XXwxWzAtMl1cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMuaG91cnM9K2F9fSx7a2V5OlxcXCJIXFxcIixyZWdleDpcXFwiMT9bMC05XXwyWzAtM11cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMuaG91cnM9K2F9fSx7a2V5OlxcXCJoXFxcIixyZWdleDpcXFwiWzAtOV18MVswLTJdXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmhvdXJzPSthfX0se2tleTpcXFwibW1cXFwiLHJlZ2V4OlxcXCJbMC01XVswLTldXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLm1pbnV0ZXM9K2F9fSx7a2V5OlxcXCJtXFxcIixyZWdleDpcXFwiWzAtOV18WzEtNV1bMC05XVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5taW51dGVzPSthfX0se2tleTpcXFwic3NzXFxcIixyZWdleDpcXFwiWzAtOV1bMC05XVswLTldXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLm1pbGxpc2Vjb25kcz0rYX19LHtrZXk6XFxcInNzXFxcIixyZWdleDpcXFwiWzAtNV1bMC05XVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5zZWNvbmRzPSthfX0se2tleTpcXFwic1xcXCIscmVnZXg6XFxcIlswLTldfFsxLTVdWzAtOV1cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMuc2Vjb25kcz0rYX19LHtrZXk6XFxcImFcXFwiLHJlZ2V4OmIuREFURVRJTUVfRk9STUFUUy5BTVBNUy5qb2luKFxcXCJ8XFxcIiksYXBwbHk6ZnVuY3Rpb24oYSl7MTI9PT10aGlzLmhvdXJzJiYodGhpcy5ob3Vycz0wKSxcXFwiUE1cXFwiPT09YSYmKHRoaXMuaG91cnMrPTEyKX19LHtrZXk6XFxcIlpcXFwiLHJlZ2V4OlxcXCJbKy1dXFxcXFxcXFxkezR9XFxcIixhcHBseTpmdW5jdGlvbihhKXt2YXIgYj1hLm1hdGNoKC8oWystXSkoXFxcXGR7Mn0pKFxcXFxkezJ9KS8pLGM9YlsxXSxkPWJbMl0sZT1iWzNdO3RoaXMuaG91cnMrPWYoYytkKSx0aGlzLm1pbnV0ZXMrPWYoYytlKX19LHtrZXk6XFxcInd3XFxcIixyZWdleDpcXFwiWzAtNF1bMC05XXw1WzAtM11cXFwifSx7a2V5OlxcXCJ3XFxcIixyZWdleDpcXFwiWzAtOV18WzEtNF1bMC05XXw1WzAtM11cXFwifSx7a2V5OlxcXCJHR0dHXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuRVJBTkFNRVMuam9pbihcXFwifFxcXCIpLnJlcGxhY2UoL1xcXFxzL2csXFxcIlxcXFxcXFxcc1xcXCIpfSx7a2V5OlxcXCJHR0dcXFwiLHJlZ2V4OmIuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oXFxcInxcXFwiKX0se2tleTpcXFwiR0dcXFwiLHJlZ2V4OmIuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oXFxcInxcXFwiKX0se2tleTpcXFwiR1xcXCIscmVnZXg6Yi5EQVRFVElNRV9GT1JNQVRTLkVSQVMuam9pbihcXFwifFxcXCIpfV19LHRoaXMuaW5pdCgpLHRoaXMucGFyc2U9ZnVuY3Rpb24oYyxmLGcpe2lmKCFhbmd1bGFyLmlzU3RyaW5nKGMpfHwhZilyZXR1cm4gYztmPWIuREFURVRJTUVfRk9STUFUU1tmXXx8ZixmPWYucmVwbGFjZShuLFxcXCJcXFxcXFxcXCQmXFxcIiksYi5pZCE9PWwmJnRoaXMuaW5pdCgpLHRoaXMucGFyc2Vyc1tmXXx8KHRoaXMucGFyc2Vyc1tmXT1kKGYpKTt2YXIgaD10aGlzLnBhcnNlcnNbZl0saT1oLnJlZ2V4LGo9aC5tYXAsaz1jLm1hdGNoKGkpLG09ITE7aWYoayYmay5sZW5ndGgpe3ZhciBvLHA7YW5ndWxhci5pc0RhdGUoZykmJiFpc05hTihnLmdldFRpbWUoKSk/bz17eWVhcjpnLmdldEZ1bGxZZWFyKCksbW9udGg6Zy5nZXRNb250aCgpLGRhdGU6Zy5nZXREYXRlKCksaG91cnM6Zy5nZXRIb3VycygpLG1pbnV0ZXM6Zy5nZXRNaW51dGVzKCksc2Vjb25kczpnLmdldFNlY29uZHMoKSxtaWxsaXNlY29uZHM6Zy5nZXRNaWxsaXNlY29uZHMoKX06KGcmJmEud2FybihcXFwiZGF0ZXBhcnNlcjpcXFwiLFxcXCJiYXNlRGF0ZSBpcyBub3QgYSB2YWxpZCBkYXRlXFxcIiksbz17eWVhcjoxOTAwLG1vbnRoOjAsZGF0ZToxLGhvdXJzOjAsbWludXRlczowLHNlY29uZHM6MCxtaWxsaXNlY29uZHM6MH0pO2Zvcih2YXIgcT0xLHI9ay5sZW5ndGg7cj5xO3ErKyl7dmFyIHM9altxLTFdO1xcXCJaXFxcIj09PXMubWF0Y2hlciYmKG09ITApLHMuYXBwbHkmJnMuYXBwbHkuY2FsbChvLGtbcV0pfXZhciB0PW0/RGF0ZS5wcm90b3R5cGUuc2V0VVRDRnVsbFllYXI6RGF0ZS5wcm90b3R5cGUuc2V0RnVsbFllYXIsdT1tP0RhdGUucHJvdG90eXBlLnNldFVUQ0hvdXJzOkRhdGUucHJvdG90eXBlLnNldEhvdXJzO3JldHVybiBlKG8ueWVhcixvLm1vbnRoLG8uZGF0ZSkmJighYW5ndWxhci5pc0RhdGUoZyl8fGlzTmFOKGcuZ2V0VGltZSgpKXx8bT8ocD1uZXcgRGF0ZSgwKSx0LmNhbGwocCxvLnllYXIsby5tb250aCxvLmRhdGUpLHUuY2FsbChwLG8uaG91cnN8fDAsby5taW51dGVzfHwwLG8uc2Vjb25kc3x8MCxvLm1pbGxpc2Vjb25kc3x8MCkpOihwPW5ldyBEYXRlKGcpLHQuY2FsbChwLG8ueWVhcixvLm1vbnRoLG8uZGF0ZSksdS5jYWxsKHAsby5ob3VycyxvLm1pbnV0ZXMsby5zZWNvbmRzLG8ubWlsbGlzZWNvbmRzKSkpLHB9fSx0aGlzLnRvVGltZXpvbmU9Zyx0aGlzLmZyb21UaW1lem9uZT1oLHRoaXMudGltZXpvbmVUb09mZnNldD1pLHRoaXMuYWRkRGF0ZU1pbnV0ZXM9aix0aGlzLmNvbnZlcnRUaW1lem9uZVRvTG9jYWw9a31dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmlzQ2xhc3NcXFwiLFtdKS5kaXJlY3RpdmUoXFxcInVpYklzQ2xhc3NcXFwiLFtcXFwiJGFuaW1hdGVcXFwiLGZ1bmN0aW9uKGEpe3ZhciBiPS9eXFxcXHMqKFtcXFxcc1xcXFxTXSs/KVxcXFxzK29uXFxcXHMrKFtcXFxcc1xcXFxTXSs/KVxcXFxzKiQvLGM9L15cXFxccyooW1xcXFxzXFxcXFNdKz8pXFxcXHMrZm9yXFxcXHMrKFtcXFxcc1xcXFxTXSs/KVxcXFxzKiQvO3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsY29tcGlsZTpmdW5jdGlvbihkLGUpe2Z1bmN0aW9uIGYoYSxiLGMpe2kucHVzaChhKSxqLnB1c2goe3Njb3BlOmEsZWxlbWVudDpifSksby5mb3JFYWNoKGZ1bmN0aW9uKGIsYyl7ZyhiLGEpfSksYS4kb24oXFxcIiRkZXN0cm95XFxcIixoKX1mdW5jdGlvbiBnKGIsZCl7dmFyIGU9Yi5tYXRjaChjKSxmPWQuJGV2YWwoZVsxXSksZz1lWzJdLGg9a1tiXTtpZighaCl7dmFyIGk9ZnVuY3Rpb24oYil7dmFyIGM9bnVsbDtqLnNvbWUoZnVuY3Rpb24oYSl7dmFyIGQ9YS5zY29wZS4kZXZhbChtKTtyZXR1cm4gZD09PWI/KGM9YSwhMCk6dm9pZCAwfSksaC5sYXN0QWN0aXZhdGVkIT09YyYmKGgubGFzdEFjdGl2YXRlZCYmYS5yZW1vdmVDbGFzcyhoLmxhc3RBY3RpdmF0ZWQuZWxlbWVudCxmKSxjJiZhLmFkZENsYXNzKGMuZWxlbWVudCxmKSxoLmxhc3RBY3RpdmF0ZWQ9Yyl9O2tbYl09aD17bGFzdEFjdGl2YXRlZDpudWxsLHNjb3BlOmQsd2F0Y2hGbjppLGNvbXBhcmVXaXRoRXhwOmcsd2F0Y2hlcjpkLiR3YXRjaChnLGkpfX1oLndhdGNoRm4oZC4kZXZhbChnKSl9ZnVuY3Rpb24gaChhKXt2YXIgYj1hLnRhcmdldFNjb3BlLGM9aS5pbmRleE9mKGIpO2lmKGkuc3BsaWNlKGMsMSksai5zcGxpY2UoYywxKSxpLmxlbmd0aCl7dmFyIGQ9aVswXTthbmd1bGFyLmZvckVhY2goayxmdW5jdGlvbihhKXthLnNjb3BlPT09YiYmKGEud2F0Y2hlcj1kLiR3YXRjaChhLmNvbXBhcmVXaXRoRXhwLGEud2F0Y2hGbiksYS5zY29wZT1kKX0pfWVsc2Ugaz17fX12YXIgaT1bXSxqPVtdLGs9e30sbD1lLnVpYklzQ2xhc3MubWF0Y2goYiksbT1sWzJdLG49bFsxXSxvPW4uc3BsaXQoXFxcIixcXFwiKTtyZXR1cm4gZn19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAucG9zaXRpb25cXFwiLFtdKS5mYWN0b3J5KFxcXCIkdWliUG9zaXRpb25cXFwiLFtcXFwiJGRvY3VtZW50XFxcIixcXFwiJHdpbmRvd1xcXCIsZnVuY3Rpb24oYSxiKXt2YXIgYyxkPXtub3JtYWw6LyhhdXRvfHNjcm9sbCkvLGhpZGRlbjovKGF1dG98c2Nyb2xsfGhpZGRlbikvfSxlPXthdXRvOi9cXFxccz9hdXRvP1xcXFxzPy9pLHByaW1hcnk6L14odG9wfGJvdHRvbXxsZWZ0fHJpZ2h0KSQvLHNlY29uZGFyeTovXih0b3B8Ym90dG9tfGxlZnR8cmlnaHR8Y2VudGVyKSQvLHZlcnRpY2FsOi9eKHRvcHxib3R0b20pJC99O3JldHVybntnZXRSYXdOb2RlOmZ1bmN0aW9uKGEpe3JldHVybiBhWzBdfHxhfSxwYXJzZVN0eWxlOmZ1bmN0aW9uKGEpe3JldHVybiBhPXBhcnNlRmxvYXQoYSksaXNGaW5pdGUoYSk/YTowfSxvZmZzZXRQYXJlbnQ6ZnVuY3Rpb24oYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm5cXFwic3RhdGljXFxcIj09PShiLmdldENvbXB1dGVkU3R5bGUoYSkucG9zaXRpb258fFxcXCJzdGF0aWNcXFwiKX1jPXRoaXMuZ2V0UmF3Tm9kZShjKTtmb3IodmFyIGU9Yy5vZmZzZXRQYXJlbnR8fGFbMF0uZG9jdW1lbnRFbGVtZW50O2UmJmUhPT1hWzBdLmRvY3VtZW50RWxlbWVudCYmZChlKTspZT1lLm9mZnNldFBhcmVudDtyZXR1cm4gZXx8YVswXS5kb2N1bWVudEVsZW1lbnR9LHNjcm9sbGJhcldpZHRoOmZ1bmN0aW9uKCl7aWYoYW5ndWxhci5pc1VuZGVmaW5lZChjKSl7dmFyIGI9YW5ndWxhci5lbGVtZW50KCc8ZGl2IHN0eWxlPVxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogLTk5OTlweDsgd2lkdGg6IDUwcHg7IGhlaWdodDogNTBweDsgb3ZlcmZsb3c6IHNjcm9sbDtcXFwiPjwvZGl2PicpO2EuZmluZChcXFwiYm9keVxcXCIpLmFwcGVuZChiKSxjPWJbMF0ub2Zmc2V0V2lkdGgtYlswXS5jbGllbnRXaWR0aCxjPWlzRmluaXRlKGMpP2M6MCxiLnJlbW92ZSgpfXJldHVybiBjfSxzY3JvbGxQYXJlbnQ6ZnVuY3Rpb24oYyxlKXtjPXRoaXMuZ2V0UmF3Tm9kZShjKTt2YXIgZj1lP2QuaGlkZGVuOmQubm9ybWFsLGc9YVswXS5kb2N1bWVudEVsZW1lbnQsaD1iLmdldENvbXB1dGVkU3R5bGUoYyksaT1cXFwiYWJzb2x1dGVcXFwiPT09aC5wb3NpdGlvbixqPWMucGFyZW50RWxlbWVudHx8ZztpZihqPT09Z3x8XFxcImZpeGVkXFxcIj09PWgucG9zaXRpb24pcmV0dXJuIGc7Zm9yKDtqLnBhcmVudEVsZW1lbnQmJmohPT1nOyl7dmFyIGs9Yi5nZXRDb21wdXRlZFN0eWxlKGopO2lmKGkmJlxcXCJzdGF0aWNcXFwiIT09ay5wb3NpdGlvbiYmKGk9ITEpLCFpJiZmLnRlc3Qoay5vdmVyZmxvdytrLm92ZXJmbG93WStrLm92ZXJmbG93WCkpYnJlYWs7aj1qLnBhcmVudEVsZW1lbnR9cmV0dXJuIGp9LHBvc2l0aW9uOmZ1bmN0aW9uKGMsZCl7Yz10aGlzLmdldFJhd05vZGUoYyk7dmFyIGU9dGhpcy5vZmZzZXQoYyk7aWYoZCl7dmFyIGY9Yi5nZXRDb21wdXRlZFN0eWxlKGMpO2UudG9wLT10aGlzLnBhcnNlU3R5bGUoZi5tYXJnaW5Ub3ApLGUubGVmdC09dGhpcy5wYXJzZVN0eWxlKGYubWFyZ2luTGVmdCl9dmFyIGc9dGhpcy5vZmZzZXRQYXJlbnQoYyksaD17dG9wOjAsbGVmdDowfTtyZXR1cm4gZyE9PWFbMF0uZG9jdW1lbnRFbGVtZW50JiYoaD10aGlzLm9mZnNldChnKSxoLnRvcCs9Zy5jbGllbnRUb3AtZy5zY3JvbGxUb3AsaC5sZWZ0Kz1nLmNsaWVudExlZnQtZy5zY3JvbGxMZWZ0KSx7d2lkdGg6TWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGUud2lkdGgpP2Uud2lkdGg6Yy5vZmZzZXRXaWR0aCksaGVpZ2h0Ok1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihlLmhlaWdodCk/ZS5oZWlnaHQ6Yy5vZmZzZXRIZWlnaHQpLHRvcDpNYXRoLnJvdW5kKGUudG9wLWgudG9wKSxsZWZ0Ok1hdGgucm91bmQoZS5sZWZ0LWgubGVmdCl9fSxvZmZzZXQ6ZnVuY3Rpb24oYyl7Yz10aGlzLmdldFJhd05vZGUoYyk7dmFyIGQ9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57d2lkdGg6TWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGQud2lkdGgpP2Qud2lkdGg6Yy5vZmZzZXRXaWR0aCksaGVpZ2h0Ok1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihkLmhlaWdodCk/ZC5oZWlnaHQ6Yy5vZmZzZXRIZWlnaHQpLHRvcDpNYXRoLnJvdW5kKGQudG9wKyhiLnBhZ2VZT2Zmc2V0fHxhWzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApKSxsZWZ0Ok1hdGgucm91bmQoZC5sZWZ0KyhiLnBhZ2VYT2Zmc2V0fHxhWzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KSl9fSx2aWV3cG9ydE9mZnNldDpmdW5jdGlvbihjLGQsZSl7Yz10aGlzLmdldFJhd05vZGUoYyksZT1lIT09ITE/ITA6ITE7dmFyIGY9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxnPXt0b3A6MCxsZWZ0OjAsYm90dG9tOjAscmlnaHQ6MH0saD1kP2FbMF0uZG9jdW1lbnRFbGVtZW50OnRoaXMuc2Nyb2xsUGFyZW50KGMpLGk9aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZihnLnRvcD1pLnRvcCtoLmNsaWVudFRvcCxnLmxlZnQ9aS5sZWZ0K2guY2xpZW50TGVmdCxoPT09YVswXS5kb2N1bWVudEVsZW1lbnQmJihnLnRvcCs9Yi5wYWdlWU9mZnNldCxnLmxlZnQrPWIucGFnZVhPZmZzZXQpLGcuYm90dG9tPWcudG9wK2guY2xpZW50SGVpZ2h0LGcucmlnaHQ9Zy5sZWZ0K2guY2xpZW50V2lkdGgsZSl7dmFyIGo9Yi5nZXRDb21wdXRlZFN0eWxlKGgpO2cudG9wKz10aGlzLnBhcnNlU3R5bGUoai5wYWRkaW5nVG9wKSxnLmJvdHRvbS09dGhpcy5wYXJzZVN0eWxlKGoucGFkZGluZ0JvdHRvbSksZy5sZWZ0Kz10aGlzLnBhcnNlU3R5bGUoai5wYWRkaW5nTGVmdCksZy5yaWdodC09dGhpcy5wYXJzZVN0eWxlKGoucGFkZGluZ1JpZ2h0KX1yZXR1cm57dG9wOk1hdGgucm91bmQoZi50b3AtZy50b3ApLGJvdHRvbTpNYXRoLnJvdW5kKGcuYm90dG9tLWYuYm90dG9tKSxsZWZ0Ok1hdGgucm91bmQoZi5sZWZ0LWcubGVmdCkscmlnaHQ6TWF0aC5yb3VuZChnLnJpZ2h0LWYucmlnaHQpfX0scGFyc2VQbGFjZW1lbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9ZS5hdXRvLnRlc3QoYSk7cmV0dXJuIGImJihhPWEucmVwbGFjZShlLmF1dG8sXFxcIlxcXCIpKSxhPWEuc3BsaXQoXFxcIi1cXFwiKSxhWzBdPWFbMF18fFxcXCJ0b3BcXFwiLGUucHJpbWFyeS50ZXN0KGFbMF0pfHwoYVswXT1cXFwidG9wXFxcIiksYVsxXT1hWzFdfHxcXFwiY2VudGVyXFxcIixlLnNlY29uZGFyeS50ZXN0KGFbMV0pfHwoYVsxXT1cXFwiY2VudGVyXFxcIiksYj9hWzJdPSEwOmFbMl09ITEsYX0scG9zaXRpb25FbGVtZW50czpmdW5jdGlvbihhLGMsZCxmKXthPXRoaXMuZ2V0UmF3Tm9kZShhKSxjPXRoaXMuZ2V0UmF3Tm9kZShjKTt2YXIgZz1hbmd1bGFyLmlzRGVmaW5lZChjLm9mZnNldFdpZHRoKT9jLm9mZnNldFdpZHRoOmMucHJvcChcXFwib2Zmc2V0V2lkdGhcXFwiKSxoPWFuZ3VsYXIuaXNEZWZpbmVkKGMub2Zmc2V0SGVpZ2h0KT9jLm9mZnNldEhlaWdodDpjLnByb3AoXFxcIm9mZnNldEhlaWdodFxcXCIpO2Q9dGhpcy5wYXJzZVBsYWNlbWVudChkKTt2YXIgaT1mP3RoaXMub2Zmc2V0KGEpOnRoaXMucG9zaXRpb24oYSksaj17dG9wOjAsbGVmdDowLHBsYWNlbWVudDpcXFwiXFxcIn07aWYoZFsyXSl7dmFyIGs9dGhpcy52aWV3cG9ydE9mZnNldChhKSxsPWIuZ2V0Q29tcHV0ZWRTdHlsZShjKSxtPXt3aWR0aDpnK01hdGgucm91bmQoTWF0aC5hYnModGhpcy5wYXJzZVN0eWxlKGwubWFyZ2luTGVmdCkrdGhpcy5wYXJzZVN0eWxlKGwubWFyZ2luUmlnaHQpKSksaGVpZ2h0OmgrTWF0aC5yb3VuZChNYXRoLmFicyh0aGlzLnBhcnNlU3R5bGUobC5tYXJnaW5Ub3ApK3RoaXMucGFyc2VTdHlsZShsLm1hcmdpbkJvdHRvbSkpKX07aWYoZFswXT1cXFwidG9wXFxcIj09PWRbMF0mJm0uaGVpZ2h0PmsudG9wJiZtLmhlaWdodDw9ay5ib3R0b20/XFxcImJvdHRvbVxcXCI6XFxcImJvdHRvbVxcXCI9PT1kWzBdJiZtLmhlaWdodD5rLmJvdHRvbSYmbS5oZWlnaHQ8PWsudG9wP1xcXCJ0b3BcXFwiOlxcXCJsZWZ0XFxcIj09PWRbMF0mJm0ud2lkdGg+ay5sZWZ0JiZtLndpZHRoPD1rLnJpZ2h0P1xcXCJyaWdodFxcXCI6XFxcInJpZ2h0XFxcIj09PWRbMF0mJm0ud2lkdGg+ay5yaWdodCYmbS53aWR0aDw9ay5sZWZ0P1xcXCJsZWZ0XFxcIjpkWzBdLGRbMV09XFxcInRvcFxcXCI9PT1kWzFdJiZtLmhlaWdodC1pLmhlaWdodD5rLmJvdHRvbSYmbS5oZWlnaHQtaS5oZWlnaHQ8PWsudG9wP1xcXCJib3R0b21cXFwiOlxcXCJib3R0b21cXFwiPT09ZFsxXSYmbS5oZWlnaHQtaS5oZWlnaHQ+ay50b3AmJm0uaGVpZ2h0LWkuaGVpZ2h0PD1rLmJvdHRvbT9cXFwidG9wXFxcIjpcXFwibGVmdFxcXCI9PT1kWzFdJiZtLndpZHRoLWkud2lkdGg+ay5yaWdodCYmbS53aWR0aC1pLndpZHRoPD1rLmxlZnQ/XFxcInJpZ2h0XFxcIjpcXFwicmlnaHRcXFwiPT09ZFsxXSYmbS53aWR0aC1pLndpZHRoPmsubGVmdCYmbS53aWR0aC1pLndpZHRoPD1rLnJpZ2h0P1xcXCJsZWZ0XFxcIjpkWzFdLFxcXCJjZW50ZXJcXFwiPT09ZFsxXSlpZihlLnZlcnRpY2FsLnRlc3QoZFswXSkpe3ZhciBuPWkud2lkdGgvMi1nLzI7ay5sZWZ0K248MCYmbS53aWR0aC1pLndpZHRoPD1rLnJpZ2h0P2RbMV09XFxcImxlZnRcXFwiOmsucmlnaHQrbjwwJiZtLndpZHRoLWkud2lkdGg8PWsubGVmdCYmKGRbMV09XFxcInJpZ2h0XFxcIil9ZWxzZXt2YXIgbz1pLmhlaWdodC8yLW0uaGVpZ2h0LzI7ay50b3ArbzwwJiZtLmhlaWdodC1pLmhlaWdodDw9ay5ib3R0b20/ZFsxXT1cXFwidG9wXFxcIjprLmJvdHRvbStvPDAmJm0uaGVpZ2h0LWkuaGVpZ2h0PD1rLnRvcCYmKGRbMV09XFxcImJvdHRvbVxcXCIpfX1zd2l0Y2goZFswXSl7Y2FzZVxcXCJ0b3BcXFwiOmoudG9wPWkudG9wLWg7YnJlYWs7Y2FzZVxcXCJib3R0b21cXFwiOmoudG9wPWkudG9wK2kuaGVpZ2h0O2JyZWFrO2Nhc2VcXFwibGVmdFxcXCI6ai5sZWZ0PWkubGVmdC1nO2JyZWFrO2Nhc2VcXFwicmlnaHRcXFwiOmoubGVmdD1pLmxlZnQraS53aWR0aH1zd2l0Y2goZFsxXSl7Y2FzZVxcXCJ0b3BcXFwiOmoudG9wPWkudG9wO2JyZWFrO2Nhc2VcXFwiYm90dG9tXFxcIjpqLnRvcD1pLnRvcCtpLmhlaWdodC1oO2JyZWFrO2Nhc2VcXFwibGVmdFxcXCI6ai5sZWZ0PWkubGVmdDticmVhaztjYXNlXFxcInJpZ2h0XFxcIjpqLmxlZnQ9aS5sZWZ0K2kud2lkdGgtZzticmVhaztjYXNlXFxcImNlbnRlclxcXCI6ZS52ZXJ0aWNhbC50ZXN0KGRbMF0pP2oubGVmdD1pLmxlZnQraS53aWR0aC8yLWcvMjpqLnRvcD1pLnRvcCtpLmhlaWdodC8yLWgvMn1yZXR1cm4gai50b3A9TWF0aC5yb3VuZChqLnRvcCksai5sZWZ0PU1hdGgucm91bmQoai5sZWZ0KSxqLnBsYWNlbWVudD1cXFwiY2VudGVyXFxcIj09PWRbMV0/ZFswXTpkWzBdK1xcXCItXFxcIitkWzFdLGp9LHBvc2l0aW9uQXJyb3c6ZnVuY3Rpb24oYSxjKXthPXRoaXMuZ2V0UmF3Tm9kZShhKTt2YXIgZD1hLnF1ZXJ5U2VsZWN0b3IoXFxcIi50b29sdGlwLWlubmVyLCAucG9wb3Zlci1pbm5lclxcXCIpO2lmKGQpe3ZhciBmPWFuZ3VsYXIuZWxlbWVudChkKS5oYXNDbGFzcyhcXFwidG9vbHRpcC1pbm5lclxcXCIpLGc9Zj9hLnF1ZXJ5U2VsZWN0b3IoXFxcIi50b29sdGlwLWFycm93XFxcIik6YS5xdWVyeVNlbGVjdG9yKFxcXCIuYXJyb3dcXFwiKTtpZihnKXtpZihjPXRoaXMucGFyc2VQbGFjZW1lbnQoYyksXFxcImNlbnRlclxcXCI9PT1jWzFdKXJldHVybiB2b2lkIGFuZ3VsYXIuZWxlbWVudChnKS5jc3Moe3RvcDpcXFwiXFxcIixib3R0b206XFxcIlxcXCIscmlnaHQ6XFxcIlxcXCIsbGVmdDpcXFwiXFxcIixtYXJnaW46XFxcIlxcXCJ9KTt2YXIgaD1cXFwiYm9yZGVyLVxcXCIrY1swXStcXFwiLXdpZHRoXFxcIixpPWIuZ2V0Q29tcHV0ZWRTdHlsZShnKVtoXSxqPVxcXCJib3JkZXItXFxcIjtqKz1lLnZlcnRpY2FsLnRlc3QoY1swXSk/Y1swXStcXFwiLVxcXCIrY1sxXTpjWzFdK1xcXCItXFxcIitjWzBdLGorPVxcXCItcmFkaXVzXFxcIjt2YXIgaz1iLmdldENvbXB1dGVkU3R5bGUoZj9kOmEpW2pdLGw9e3RvcDpcXFwiYXV0b1xcXCIsYm90dG9tOlxcXCJhdXRvXFxcIixsZWZ0OlxcXCJhdXRvXFxcIixyaWdodDpcXFwiYXV0b1xcXCIsbWFyZ2luOjB9O3N3aXRjaChjWzBdKXtjYXNlXFxcInRvcFxcXCI6bC5ib3R0b209Zj9cXFwiMFxcXCI6XFxcIi1cXFwiK2k7YnJlYWs7Y2FzZVxcXCJib3R0b21cXFwiOmwudG9wPWY/XFxcIjBcXFwiOlxcXCItXFxcIitpO2JyZWFrO2Nhc2VcXFwibGVmdFxcXCI6bC5yaWdodD1mP1xcXCIwXFxcIjpcXFwiLVxcXCIraTticmVhaztjYXNlXFxcInJpZ2h0XFxcIjpsLmxlZnQ9Zj9cXFwiMFxcXCI6XFxcIi1cXFwiK2l9bFtjWzFdXT1rLGFuZ3VsYXIuZWxlbWVudChnKS5jc3MobCl9fX19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclxcXCIsW1xcXCJ1aS5ib290c3RyYXAuZGF0ZXBhcnNlclxcXCIsXFxcInVpLmJvb3RzdHJhcC5pc0NsYXNzXFxcIixcXFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXFxcIl0pLnZhbHVlKFxcXCIkZGF0ZXBpY2tlclN1cHByZXNzRXJyb3JcXFwiLCExKS5jb25zdGFudChcXFwidWliRGF0ZXBpY2tlckNvbmZpZ1xcXCIse2RhdGVwaWNrZXJNb2RlOlxcXCJkYXlcXFwiLGZvcm1hdERheTpcXFwiZGRcXFwiLGZvcm1hdE1vbnRoOlxcXCJNTU1NXFxcIixmb3JtYXRZZWFyOlxcXCJ5eXl5XFxcIixmb3JtYXREYXlIZWFkZXI6XFxcIkVFRVxcXCIsZm9ybWF0RGF5VGl0bGU6XFxcIk1NTU0geXl5eVxcXCIsZm9ybWF0TW9udGhUaXRsZTpcXFwieXl5eVxcXCIsbWF4RGF0ZTpudWxsLG1heE1vZGU6XFxcInllYXJcXFwiLG1pbkRhdGU6bnVsbCxtaW5Nb2RlOlxcXCJkYXlcXFwiLG5nTW9kZWxPcHRpb25zOnt9LHNob3J0Y3V0UHJvcGFnYXRpb246ITEsc2hvd1dlZWtzOiEwLHllYXJDb2x1bW5zOjUseWVhclJvd3M6NH0pLmNvbnRyb2xsZXIoXFxcIlVpYkRhdGVwaWNrZXJDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcIiRwYXJzZVxcXCIsXFxcIiRpbnRlcnBvbGF0ZVxcXCIsXFxcIiRsb2NhbGVcXFwiLFxcXCIkbG9nXFxcIixcXFwiZGF0ZUZpbHRlclxcXCIsXFxcInVpYkRhdGVwaWNrZXJDb25maWdcXFwiLFxcXCIkZGF0ZXBpY2tlclN1cHByZXNzRXJyb3JcXFwiLFxcXCJ1aWJEYXRlUGFyc2VyXFxcIixmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSxqKXt2YXIgaz10aGlzLGw9eyRzZXRWaWV3VmFsdWU6YW5ndWxhci5ub29wfSxtPXt9LG49W107dGhpcy5tb2Rlcz1bXFxcImRheVxcXCIsXFxcIm1vbnRoXFxcIixcXFwieWVhclxcXCJdLGFuZ3VsYXIuZm9yRWFjaChbXFxcImZvcm1hdERheVxcXCIsXFxcImZvcm1hdE1vbnRoXFxcIixcXFwiZm9ybWF0WWVhclxcXCIsXFxcImZvcm1hdERheUhlYWRlclxcXCIsXFxcImZvcm1hdERheVRpdGxlXFxcIixcXFwiZm9ybWF0TW9udGhUaXRsZVxcXCJdLGZ1bmN0aW9uKGMpe2tbY109YW5ndWxhci5pc0RlZmluZWQoYltjXSk/ZChiW2NdKShhLiRwYXJlbnQpOmhbY119KSxhbmd1bGFyLmZvckVhY2goW1xcXCJzaG93V2Vla3NcXFwiLFxcXCJ5ZWFyUm93c1xcXCIsXFxcInllYXJDb2x1bW5zXFxcIixcXFwic2hvcnRjdXRQcm9wYWdhdGlvblxcXCJdLGZ1bmN0aW9uKGMpe2tbY109YW5ndWxhci5pc0RlZmluZWQoYltjXSk/YS4kcGFyZW50LiRldmFsKGJbY10pOmhbY119KSxhbmd1bGFyLmlzRGVmaW5lZChiLnN0YXJ0aW5nRGF5KT9rLnN0YXJ0aW5nRGF5PWEuJHBhcmVudC4kZXZhbChiLnN0YXJ0aW5nRGF5KTphbmd1bGFyLmlzTnVtYmVyKGguc3RhcnRpbmdEYXkpP2suc3RhcnRpbmdEYXk9aC5zdGFydGluZ0RheTprLnN0YXJ0aW5nRGF5PShlLkRBVEVUSU1FX0ZPUk1BVFMuRklSU1REQVlPRldFRUsrOCklNyxhbmd1bGFyLmZvckVhY2goW1xcXCJtaW5EYXRlXFxcIixcXFwibWF4RGF0ZVxcXCJdLGZ1bmN0aW9uKGMpe2JbY10/bi5wdXNoKGEuJHBhcmVudC4kd2F0Y2goYltjXSxmdW5jdGlvbihhKXtrW2NdPWE/YW5ndWxhci5pc0RhdGUoYSk/ai5mcm9tVGltZXpvbmUobmV3IERhdGUoYSksbS50aW1lem9uZSk6bmV3IERhdGUoZyhhLFxcXCJtZWRpdW1cXFwiKSk6bnVsbCxrLnJlZnJlc2hWaWV3KCl9KSk6a1tjXT1oW2NdP2ouZnJvbVRpbWV6b25lKG5ldyBEYXRlKGhbY10pLG0udGltZXpvbmUpOm51bGx9KSxhbmd1bGFyLmZvckVhY2goW1xcXCJtaW5Nb2RlXFxcIixcXFwibWF4TW9kZVxcXCJdLGZ1bmN0aW9uKGMpe2JbY10/bi5wdXNoKGEuJHBhcmVudC4kd2F0Y2goYltjXSxmdW5jdGlvbihkKXtrW2NdPWFbY109YW5ndWxhci5pc0RlZmluZWQoZCk/ZDpiW2NdLChcXFwibWluTW9kZVxcXCI9PT1jJiZrLm1vZGVzLmluZGV4T2YoYS5kYXRlcGlja2VyTW9kZSk8ay5tb2Rlcy5pbmRleE9mKGtbY10pfHxcXFwibWF4TW9kZVxcXCI9PT1jJiZrLm1vZGVzLmluZGV4T2YoYS5kYXRlcGlja2VyTW9kZSk+ay5tb2Rlcy5pbmRleE9mKGtbY10pKSYmKGEuZGF0ZXBpY2tlck1vZGU9a1tjXSl9KSk6a1tjXT1hW2NdPWhbY118fG51bGx9KSxhLmRhdGVwaWNrZXJNb2RlPWEuZGF0ZXBpY2tlck1vZGV8fGguZGF0ZXBpY2tlck1vZGUsYS51bmlxdWVJZD1cXFwiZGF0ZXBpY2tlci1cXFwiK2EuJGlkK1xcXCItXFxcIitNYXRoLmZsb29yKDFlNCpNYXRoLnJhbmRvbSgpKSxhbmd1bGFyLmlzRGVmaW5lZChiLmluaXREYXRlKT8odGhpcy5hY3RpdmVEYXRlPWouZnJvbVRpbWV6b25lKGEuJHBhcmVudC4kZXZhbChiLmluaXREYXRlKSxtLnRpbWV6b25lKXx8bmV3IERhdGUsbi5wdXNoKGEuJHBhcmVudC4kd2F0Y2goYi5pbml0RGF0ZSxmdW5jdGlvbihhKXthJiYobC4kaXNFbXB0eShsLiRtb2RlbFZhbHVlKXx8bC4kaW52YWxpZCkmJihrLmFjdGl2ZURhdGU9ai5mcm9tVGltZXpvbmUoYSxtLnRpbWV6b25lKSxrLnJlZnJlc2hWaWV3KCkpfSkpKTp0aGlzLmFjdGl2ZURhdGU9bmV3IERhdGUsYS5kaXNhYmxlZD1hbmd1bGFyLmlzRGVmaW5lZChiLmRpc2FibGVkKXx8ITEsYW5ndWxhci5pc0RlZmluZWQoYi5uZ0Rpc2FibGVkKSYmbi5wdXNoKGEuJHBhcmVudC4kd2F0Y2goYi5uZ0Rpc2FibGVkLGZ1bmN0aW9uKGIpe2EuZGlzYWJsZWQ9YixrLnJlZnJlc2hWaWV3KCl9KSksYS5pc0FjdGl2ZT1mdW5jdGlvbihiKXtyZXR1cm4gMD09PWsuY29tcGFyZShiLmRhdGUsay5hY3RpdmVEYXRlKT8oYS5hY3RpdmVEYXRlSWQ9Yi51aWQsITApOiExfSx0aGlzLmluaXQ9ZnVuY3Rpb24oYSl7bD1hLG09YS4kb3B0aW9uc3x8aC5uZ01vZGVsT3B0aW9ucyxsLiRtb2RlbFZhbHVlJiYodGhpcy5hY3RpdmVEYXRlPWwuJG1vZGVsVmFsdWUpLGwuJHJlbmRlcj1mdW5jdGlvbigpe2sucmVuZGVyKCl9fSx0aGlzLnJlbmRlcj1mdW5jdGlvbigpe2lmKGwuJHZpZXdWYWx1ZSl7dmFyIGE9bmV3IERhdGUobC4kdmlld1ZhbHVlKSxiPSFpc05hTihhKTtiP3RoaXMuYWN0aXZlRGF0ZT1qLmZyb21UaW1lem9uZShhLG0udGltZXpvbmUpOml8fGYuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcXFwibmctbW9kZWxcXFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCcpfXRoaXMucmVmcmVzaFZpZXcoKX0sdGhpcy5yZWZyZXNoVmlldz1mdW5jdGlvbigpe2lmKHRoaXMuZWxlbWVudCl7YS5zZWxlY3RlZER0PW51bGwsdGhpcy5fcmVmcmVzaFZpZXcoKSxhLmFjdGl2ZUR0JiYoYS5hY3RpdmVEYXRlSWQ9YS5hY3RpdmVEdC51aWQpO3ZhciBiPWwuJHZpZXdWYWx1ZT9uZXcgRGF0ZShsLiR2aWV3VmFsdWUpOm51bGw7Yj1qLmZyb21UaW1lem9uZShiLG0udGltZXpvbmUpLGwuJHNldFZhbGlkaXR5KFxcXCJkYXRlRGlzYWJsZWRcXFwiLCFifHx0aGlzLmVsZW1lbnQmJiF0aGlzLmlzRGlzYWJsZWQoYikpfX0sdGhpcy5jcmVhdGVEYXRlT2JqZWN0PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9bC4kdmlld1ZhbHVlP25ldyBEYXRlKGwuJHZpZXdWYWx1ZSk6bnVsbDtkPWouZnJvbVRpbWV6b25lKGQsbS50aW1lem9uZSk7dmFyIGU9e2RhdGU6YixsYWJlbDpnKGIsYy5yZXBsYWNlKC9kIS8sXFxcImRkXFxcIikpLnJlcGxhY2UoL00hLyxcXFwiTU1cXFwiKSxzZWxlY3RlZDpkJiYwPT09dGhpcy5jb21wYXJlKGIsZCksZGlzYWJsZWQ6dGhpcy5pc0Rpc2FibGVkKGIpLGN1cnJlbnQ6MD09PXRoaXMuY29tcGFyZShiLG5ldyBEYXRlKSxjdXN0b21DbGFzczp0aGlzLmN1c3RvbUNsYXNzKGIpfHxudWxsfTtyZXR1cm4gZCYmMD09PXRoaXMuY29tcGFyZShiLGQpJiYoYS5zZWxlY3RlZER0PWUpLGsuYWN0aXZlRGF0ZSYmMD09PXRoaXMuY29tcGFyZShlLmRhdGUsay5hY3RpdmVEYXRlKSYmKGEuYWN0aXZlRHQ9ZSksZX0sdGhpcy5pc0Rpc2FibGVkPWZ1bmN0aW9uKGMpe3JldHVybiBhLmRpc2FibGVkfHx0aGlzLm1pbkRhdGUmJnRoaXMuY29tcGFyZShjLHRoaXMubWluRGF0ZSk8MHx8dGhpcy5tYXhEYXRlJiZ0aGlzLmNvbXBhcmUoYyx0aGlzLm1heERhdGUpPjB8fGIuZGF0ZURpc2FibGVkJiZhLmRhdGVEaXNhYmxlZCh7ZGF0ZTpjLG1vZGU6YS5kYXRlcGlja2VyTW9kZX0pfSx0aGlzLmN1c3RvbUNsYXNzPWZ1bmN0aW9uKGIpe3JldHVybiBhLmN1c3RvbUNsYXNzKHtkYXRlOmIsbW9kZTphLmRhdGVwaWNrZXJNb2RlfSl9LHRoaXMuc3BsaXQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W107YS5sZW5ndGg+MDspYy5wdXNoKGEuc3BsaWNlKDAsYikpO3JldHVybiBjfSxhLnNlbGVjdD1mdW5jdGlvbihiKXtpZihhLmRhdGVwaWNrZXJNb2RlPT09ay5taW5Nb2RlKXt2YXIgYz1sLiR2aWV3VmFsdWU/ai5mcm9tVGltZXpvbmUobmV3IERhdGUobC4kdmlld1ZhbHVlKSxtLnRpbWV6b25lKTpuZXcgRGF0ZSgwLDAsMCwwLDAsMCwwKTtjLnNldEZ1bGxZZWFyKGIuZ2V0RnVsbFllYXIoKSxiLmdldE1vbnRoKCksYi5nZXREYXRlKCkpLGM9ai50b1RpbWV6b25lKGMsbS50aW1lem9uZSksbC4kc2V0Vmlld1ZhbHVlKGMpLGwuJHJlbmRlcigpfWVsc2Ugay5hY3RpdmVEYXRlPWIsYS5kYXRlcGlja2VyTW9kZT1rLm1vZGVzW2subW9kZXMuaW5kZXhPZihhLmRhdGVwaWNrZXJNb2RlKS0xXX0sYS5tb3ZlPWZ1bmN0aW9uKGEpe3ZhciBiPWsuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpK2EqKGsuc3RlcC55ZWFyc3x8MCksYz1rLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSthKihrLnN0ZXAubW9udGhzfHwwKTtrLmFjdGl2ZURhdGUuc2V0RnVsbFllYXIoYixjLDEpLGsucmVmcmVzaFZpZXcoKX0sYS50b2dnbGVNb2RlPWZ1bmN0aW9uKGIpe2I9Ynx8MSxhLmRhdGVwaWNrZXJNb2RlPT09ay5tYXhNb2RlJiYxPT09Ynx8YS5kYXRlcGlja2VyTW9kZT09PWsubWluTW9kZSYmLTE9PT1ifHwoYS5kYXRlcGlja2VyTW9kZT1rLm1vZGVzW2subW9kZXMuaW5kZXhPZihhLmRhdGVwaWNrZXJNb2RlKStiXSl9LGEua2V5cz17MTM6XFxcImVudGVyXFxcIiwzMjpcXFwic3BhY2VcXFwiLDMzOlxcXCJwYWdldXBcXFwiLDM0OlxcXCJwYWdlZG93blxcXCIsMzU6XFxcImVuZFxcXCIsMzY6XFxcImhvbWVcXFwiLDM3OlxcXCJsZWZ0XFxcIiwzODpcXFwidXBcXFwiLDM5OlxcXCJyaWdodFxcXCIsNDA6XFxcImRvd25cXFwifTt2YXIgbz1mdW5jdGlvbigpe2suZWxlbWVudFswXS5mb2N1cygpfTthLiRvbihcXFwidWliOmRhdGVwaWNrZXIuZm9jdXNcXFwiLG8pLGEua2V5ZG93bj1mdW5jdGlvbihiKXt2YXIgYz1hLmtleXNbYi53aGljaF07aWYoYyYmIWIuc2hpZnRLZXkmJiFiLmFsdEtleSYmIWEuZGlzYWJsZWQpaWYoYi5wcmV2ZW50RGVmYXVsdCgpLGsuc2hvcnRjdXRQcm9wYWdhdGlvbnx8Yi5zdG9wUHJvcGFnYXRpb24oKSxcXFwiZW50ZXJcXFwiPT09Y3x8XFxcInNwYWNlXFxcIj09PWMpe2lmKGsuaXNEaXNhYmxlZChrLmFjdGl2ZURhdGUpKXJldHVybjthLnNlbGVjdChrLmFjdGl2ZURhdGUpfWVsc2UhYi5jdHJsS2V5fHxcXFwidXBcXFwiIT09YyYmXFxcImRvd25cXFwiIT09Yz8oay5oYW5kbGVLZXlEb3duKGMsYiksay5yZWZyZXNoVmlldygpKTphLnRvZ2dsZU1vZGUoXFxcInVwXFxcIj09PWM/MTotMSl9LGEuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtmb3IoO24ubGVuZ3RoOyluLnNoaWZ0KCkoKX0pfV0pLmNvbnRyb2xsZXIoXFxcIlVpYkRheXBpY2tlckNvbnRyb2xsZXJcXFwiLFtcXFwiJHNjb3BlXFxcIixcXFwiJGVsZW1lbnRcXFwiLFxcXCJkYXRlRmlsdGVyXFxcIixmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhLGIpe3JldHVybiAxIT09Ynx8YSU0IT09MHx8YSUxMDA9PT0wJiZhJTQwMCE9PTA/ZltiXToyOX1mdW5jdGlvbiBlKGEpe3ZhciBiPW5ldyBEYXRlKGEpO2Iuc2V0RGF0ZShiLmdldERhdGUoKSs0LShiLmdldERheSgpfHw3KSk7dmFyIGM9Yi5nZXRUaW1lKCk7cmV0dXJuIGIuc2V0TW9udGgoMCksYi5zZXREYXRlKDEpLE1hdGguZmxvb3IoTWF0aC5yb3VuZCgoYy1iKS84NjRlNSkvNykrMX12YXIgZj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO3RoaXMuc3RlcD17bW9udGhzOjF9LHRoaXMuZWxlbWVudD1iLHRoaXMuaW5pdD1mdW5jdGlvbihiKXthbmd1bGFyLmV4dGVuZChiLHRoaXMpLGEuc2hvd1dlZWtzPWIuc2hvd1dlZWtzLGIucmVmcmVzaFZpZXcoKX0sdGhpcy5nZXREYXRlcz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkPW5ldyBBcnJheShiKSxlPW5ldyBEYXRlKGEpLGY9MDtiPmY7KWM9bmV3IERhdGUoZSksZFtmKytdPWMsZS5zZXREYXRlKGUuZ2V0RGF0ZSgpKzEpO3JldHVybiBkfSx0aGlzLl9yZWZyZXNoVmlldz1mdW5jdGlvbigpe3ZhciBiPXRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLGQ9dGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCksZj1uZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpO2Yuc2V0RnVsbFllYXIoYixkLDEpO3ZhciBnPXRoaXMuc3RhcnRpbmdEYXktZi5nZXREYXkoKSxoPWc+MD83LWc6LWcsaT1uZXcgRGF0ZShmKTtoPjAmJmkuc2V0RGF0ZSgtaCsxKTtmb3IodmFyIGo9dGhpcy5nZXREYXRlcyhpLDQyKSxrPTA7NDI+aztrKyspaltrXT1hbmd1bGFyLmV4dGVuZCh0aGlzLmNyZWF0ZURhdGVPYmplY3QoaltrXSx0aGlzLmZvcm1hdERheSkse3NlY29uZGFyeTpqW2tdLmdldE1vbnRoKCkhPT1kLHVpZDphLnVuaXF1ZUlkK1xcXCItXFxcIitrfSk7YS5sYWJlbHM9bmV3IEFycmF5KDcpO2Zvcih2YXIgbD0wOzc+bDtsKyspYS5sYWJlbHNbbF09e2FiYnI6YyhqW2xdLmRhdGUsdGhpcy5mb3JtYXREYXlIZWFkZXIpLGZ1bGw6YyhqW2xdLmRhdGUsXFxcIkVFRUVcXFwiKX07aWYoYS50aXRsZT1jKHRoaXMuYWN0aXZlRGF0ZSx0aGlzLmZvcm1hdERheVRpdGxlKSxhLnJvd3M9dGhpcy5zcGxpdChqLDcpLGEuc2hvd1dlZWtzKXthLndlZWtOdW1iZXJzPVtdO2Zvcih2YXIgbT0oMTEtdGhpcy5zdGFydGluZ0RheSklNyxuPWEucm93cy5sZW5ndGgsbz0wO24+bztvKyspYS53ZWVrTnVtYmVycy5wdXNoKGUoYS5yb3dzW29dW21dLmRhdGUpKX19LHRoaXMuY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBEYXRlKGEuZ2V0RnVsbFllYXIoKSxhLmdldE1vbnRoKCksYS5nZXREYXRlKCkpLGQ9bmV3IERhdGUoYi5nZXRGdWxsWWVhcigpLGIuZ2V0TW9udGgoKSxiLmdldERhdGUoKSk7cmV0dXJuIGMuc2V0RnVsbFllYXIoYS5nZXRGdWxsWWVhcigpKSxkLnNldEZ1bGxZZWFyKGIuZ2V0RnVsbFllYXIoKSksYy1kfSx0aGlzLmhhbmRsZUtleURvd249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFjdGl2ZURhdGUuZ2V0RGF0ZSgpO2lmKFxcXCJsZWZ0XFxcIj09PWEpYy09MTtlbHNlIGlmKFxcXCJ1cFxcXCI9PT1hKWMtPTc7ZWxzZSBpZihcXFwicmlnaHRcXFwiPT09YSljKz0xO2Vsc2UgaWYoXFxcImRvd25cXFwiPT09YSljKz03O2Vsc2UgaWYoXFxcInBhZ2V1cFxcXCI9PT1hfHxcXFwicGFnZWRvd25cXFwiPT09YSl7dmFyIGU9dGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkrKFxcXCJwYWdldXBcXFwiPT09YT8tMToxKTt0aGlzLmFjdGl2ZURhdGUuc2V0TW9udGgoZSwxKSxjPU1hdGgubWluKGQodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkpLGMpfWVsc2VcXFwiaG9tZVxcXCI9PT1hP2M9MTpcXFwiZW5kXFxcIj09PWEmJihjPWQodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksdGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCkpKTt0aGlzLmFjdGl2ZURhdGUuc2V0RGF0ZShjKX19XSkuY29udHJvbGxlcihcXFwiVWliTW9udGhwaWNrZXJDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRlbGVtZW50XFxcIixcXFwiZGF0ZUZpbHRlclxcXCIsZnVuY3Rpb24oYSxiLGMpe3RoaXMuc3RlcD17eWVhcnM6MX0sdGhpcy5lbGVtZW50PWIsdGhpcy5pbml0PWZ1bmN0aW9uKGEpe2FuZ3VsYXIuZXh0ZW5kKGEsdGhpcyksYS5yZWZyZXNoVmlldygpfSx0aGlzLl9yZWZyZXNoVmlldz1mdW5jdGlvbigpe2Zvcih2YXIgYixkPW5ldyBBcnJheSgxMiksZT10aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSxmPTA7MTI+ZjtmKyspYj1uZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpLGIuc2V0RnVsbFllYXIoZSxmLDEpLGRbZl09YW5ndWxhci5leHRlbmQodGhpcy5jcmVhdGVEYXRlT2JqZWN0KGIsdGhpcy5mb3JtYXRNb250aCkse3VpZDphLnVuaXF1ZUlkK1xcXCItXFxcIitmfSk7YS50aXRsZT1jKHRoaXMuYWN0aXZlRGF0ZSx0aGlzLmZvcm1hdE1vbnRoVGl0bGUpLGEucm93cz10aGlzLnNwbGl0KGQsMyl9LHRoaXMuY29tcGFyZT1mdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBEYXRlKGEuZ2V0RnVsbFllYXIoKSxhLmdldE1vbnRoKCkpLGQ9bmV3IERhdGUoYi5nZXRGdWxsWWVhcigpLGIuZ2V0TW9udGgoKSk7cmV0dXJuIGMuc2V0RnVsbFllYXIoYS5nZXRGdWxsWWVhcigpKSxkLnNldEZ1bGxZZWFyKGIuZ2V0RnVsbFllYXIoKSksYy1kfSx0aGlzLmhhbmRsZUtleURvd249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKTtpZihcXFwibGVmdFxcXCI9PT1hKWMtPTE7ZWxzZSBpZihcXFwidXBcXFwiPT09YSljLT0zO2Vsc2UgaWYoXFxcInJpZ2h0XFxcIj09PWEpYys9MTtlbHNlIGlmKFxcXCJkb3duXFxcIj09PWEpYys9MztlbHNlIGlmKFxcXCJwYWdldXBcXFwiPT09YXx8XFxcInBhZ2Vkb3duXFxcIj09PWEpe3ZhciBkPXRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpKyhcXFwicGFnZXVwXFxcIj09PWE/LTE6MSk7dGhpcy5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKGQpfWVsc2VcXFwiaG9tZVxcXCI9PT1hP2M9MDpcXFwiZW5kXFxcIj09PWEmJihjPTExKTt0aGlzLmFjdGl2ZURhdGUuc2V0TW9udGgoYyl9fV0pLmNvbnRyb2xsZXIoXFxcIlVpYlllYXJwaWNrZXJDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRlbGVtZW50XFxcIixcXFwiZGF0ZUZpbHRlclxcXCIsZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7cmV0dXJuIHBhcnNlSW50KChhLTEpL2YsMTApKmYrMX12YXIgZSxmO3RoaXMuZWxlbWVudD1iLHRoaXMueWVhcnBpY2tlckluaXQ9ZnVuY3Rpb24oKXtlPXRoaXMueWVhckNvbHVtbnMsZj10aGlzLnllYXJSb3dzKmUsdGhpcy5zdGVwPXt5ZWFyczpmfX0sdGhpcy5fcmVmcmVzaFZpZXc9ZnVuY3Rpb24oKXtmb3IodmFyIGIsYz1uZXcgQXJyYXkoZiksZz0wLGg9ZCh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSk7Zj5nO2crKyliPW5ldyBEYXRlKHRoaXMuYWN0aXZlRGF0ZSksYi5zZXRGdWxsWWVhcihoK2csMCwxKSxjW2ddPWFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChiLHRoaXMuZm9ybWF0WWVhcikse3VpZDphLnVuaXF1ZUlkK1xcXCItXFxcIitnfSk7YS50aXRsZT1bY1swXS5sYWJlbCxjW2YtMV0ubGFiZWxdLmpvaW4oXFxcIiAtIFxcXCIpLGEucm93cz10aGlzLnNwbGl0KGMsZSksYS5jb2x1bW5zPWV9LHRoaXMuY29tcGFyZT1mdW5jdGlvbihhLGIpe3JldHVybiBhLmdldEZ1bGxZZWFyKCktYi5nZXRGdWxsWWVhcigpfSx0aGlzLmhhbmRsZUtleURvd249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcXFwibGVmdFxcXCI9PT1hP2MtPTE6XFxcInVwXFxcIj09PWE/Yy09ZTpcXFwicmlnaHRcXFwiPT09YT9jKz0xOlxcXCJkb3duXFxcIj09PWE/Yys9ZTpcXFwicGFnZXVwXFxcIj09PWF8fFxcXCJwYWdlZG93blxcXCI9PT1hP2MrPShcXFwicGFnZXVwXFxcIj09PWE/LTE6MSkqZjpcXFwiaG9tZVxcXCI9PT1hP2M9ZCh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSk6XFxcImVuZFxcXCI9PT1hJiYoYz1kKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpKStmLTEpLHRoaXMuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcihjKX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJEYXRlcGlja2VyXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcXFwifSxzY29wZTp7ZGF0ZXBpY2tlck1vZGU6XFxcIj0/XFxcIixkYXRlRGlzYWJsZWQ6XFxcIiZcXFwiLGN1c3RvbUNsYXNzOlxcXCImXFxcIixzaG9ydGN1dFByb3BhZ2F0aW9uOlxcXCImP1xcXCJ9LHJlcXVpcmU6W1xcXCJ1aWJEYXRlcGlja2VyXFxcIixcXFwiXm5nTW9kZWxcXFwiXSxjb250cm9sbGVyOlxcXCJVaWJEYXRlcGlja2VyQ29udHJvbGxlclxcXCIsY29udHJvbGxlckFzOlxcXCJkYXRlcGlja2VyXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF0sZj1kWzFdO2UuaW5pdChmKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJEYXlwaWNrZXJcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXFxcIn0scmVxdWlyZTpbXFxcIl51aWJEYXRlcGlja2VyXFxcIixcXFwidWliRGF5cGlja2VyXFxcIl0sY29udHJvbGxlcjpcXFwiVWliRGF5cGlja2VyQ29udHJvbGxlclxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kWzBdLGY9ZFsxXTtmLmluaXQoZSl9fX0pLmRpcmVjdGl2ZShcXFwidWliTW9udGhwaWNrZXJcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcXFwifSxyZXF1aXJlOltcXFwiXnVpYkRhdGVwaWNrZXJcXFwiLFxcXCJ1aWJNb250aHBpY2tlclxcXCJdLGNvbnRyb2xsZXI6XFxcIlVpYk1vbnRocGlja2VyQ29udHJvbGxlclxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kWzBdLGY9ZFsxXTtmLmluaXQoZSl9fX0pLmRpcmVjdGl2ZShcXFwidWliWWVhcnBpY2tlclxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXFxcIn0scmVxdWlyZTpbXFxcIl51aWJEYXRlcGlja2VyXFxcIixcXFwidWliWWVhcnBpY2tlclxcXCJdLGNvbnRyb2xsZXI6XFxcIlVpYlllYXJwaWNrZXJDb250cm9sbGVyXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF07YW5ndWxhci5leHRlbmQoZSxkWzFdKSxlLnllYXJwaWNrZXJJbml0KCksZS5yZWZyZXNoVmlldygpfX19KS5jb25zdGFudChcXFwidWliRGF0ZXBpY2tlclBvcHVwQ29uZmlnXFxcIix7YWx0SW5wdXRGb3JtYXRzOltdLGFwcGVuZFRvQm9keTohMSxjbGVhclRleHQ6XFxcIkNsZWFyXFxcIixjbG9zZU9uRGF0ZVNlbGVjdGlvbjohMCxjbG9zZVRleHQ6XFxcIkRvbmVcXFwiLGN1cnJlbnRUZXh0OlxcXCJUb2RheVxcXCIsZGF0ZXBpY2tlclBvcHVwOlxcXCJ5eXl5LU1NLWRkXFxcIixkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFxcXCIsZGF0ZXBpY2tlclRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcXFwiLGh0bWw1VHlwZXM6e2RhdGU6XFxcInl5eXktTU0tZGRcXFwiLFxcXCJkYXRldGltZS1sb2NhbFxcXCI6XFxcInl5eXktTU0tZGRUSEg6bW06c3Muc3NzXFxcIixtb250aDpcXFwieXl5eS1NTVxcXCJ9LG9uT3BlbkZvY3VzOiEwLHNob3dCdXR0b25CYXI6ITBcXG59KS5jb250cm9sbGVyKFxcXCJVaWJEYXRlcGlja2VyUG9wdXBDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRlbGVtZW50XFxcIixcXFwiJGF0dHJzXFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkZG9jdW1lbnRcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixcXFwiJHVpYlBvc2l0aW9uXFxcIixcXFwiZGF0ZUZpbHRlclxcXCIsXFxcInVpYkRhdGVQYXJzZXJcXFwiLFxcXCJ1aWJEYXRlcGlja2VyUG9wdXBDb25maWdcXFwiLFxcXCIkdGltZW91dFxcXCIsXFxcInVpYkRhdGVwaWNrZXJDb25maWdcXFwiLGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpLGosayxsLG0pe2Z1bmN0aW9uIG4oYSl7cmV0dXJuIGEucmVwbGFjZSgvKFtBLVpdKS9nLGZ1bmN0aW9uKGEpe3JldHVyblxcXCItXFxcIithLnRvTG93ZXJDYXNlKCl9KX1mdW5jdGlvbiBvKGIpe3ZhciBjPWoucGFyc2UoYix0LGEuZGF0ZSk7aWYoaXNOYU4oYykpZm9yKHZhciBkPTA7ZDxFLmxlbmd0aDtkKyspaWYoYz1qLnBhcnNlKGIsRVtkXSxhLmRhdGUpLCFpc05hTihjKSlyZXR1cm4gYztyZXR1cm4gY31mdW5jdGlvbiBwKGEpe2lmKGFuZ3VsYXIuaXNOdW1iZXIoYSkmJihhPW5ldyBEYXRlKGEpKSwhYSlyZXR1cm4gbnVsbDtpZihhbmd1bGFyLmlzRGF0ZShhKSYmIWlzTmFOKGEpKXJldHVybiBhO2lmKGFuZ3VsYXIuaXNTdHJpbmcoYSkpe3ZhciBiPW8oYSk7aWYoIWlzTmFOKGIpKXJldHVybiBqLnRvVGltZXpvbmUoYixDLnRpbWV6b25lKX1yZXR1cm4gQi4kb3B0aW9ucyYmQi4kb3B0aW9ucy5hbGxvd0ludmFsaWQ/YTp2b2lkIDB9ZnVuY3Rpb24gcShhLGIpe3ZhciBkPWF8fGI7cmV0dXJuIGMubmdSZXF1aXJlZHx8ZD8oYW5ndWxhci5pc051bWJlcihkKSYmKGQ9bmV3IERhdGUoZCkpLGQ/YW5ndWxhci5pc0RhdGUoZCkmJiFpc05hTihkKT8hMDphbmd1bGFyLmlzU3RyaW5nKGQpPyFpc05hTihvKGIpKTohMTohMCk6ITB9ZnVuY3Rpb24gcihjKXtpZihhLmlzT3Blbnx8IWEuZGlzYWJsZWQpe3ZhciBkPURbMF0sZT1iWzBdLmNvbnRhaW5zKGMudGFyZ2V0KSxmPXZvaWQgMCE9PWQuY29udGFpbnMmJmQuY29udGFpbnMoYy50YXJnZXQpOyFhLmlzT3Blbnx8ZXx8Znx8YS4kYXBwbHkoZnVuY3Rpb24oKXthLmlzT3Blbj0hMX0pfX1mdW5jdGlvbiBzKGMpezI3PT09Yy53aGljaCYmYS5pc09wZW4/KGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGEuJGFwcGx5KGZ1bmN0aW9uKCl7YS5pc09wZW49ITF9KSxiWzBdLmZvY3VzKCkpOjQwIT09Yy53aGljaHx8YS5pc09wZW58fChjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSxhLiRhcHBseShmdW5jdGlvbigpe2EuaXNPcGVuPSEwfSkpfXZhciB0LHUsdix3LHgseSx6LEEsQixDLEQsRSxGPXt9LEc9ITEsSD1bXTthLndhdGNoRGF0YT17fSx0aGlzLmluaXQ9ZnVuY3Rpb24oaCl7aWYoQj1oLEM9aC4kb3B0aW9uc3x8bS5uZ01vZGVsT3B0aW9ucyx1PWFuZ3VsYXIuaXNEZWZpbmVkKGMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pP2EuJHBhcmVudC4kZXZhbChjLmNsb3NlT25EYXRlU2VsZWN0aW9uKTprLmNsb3NlT25EYXRlU2VsZWN0aW9uLHY9YW5ndWxhci5pc0RlZmluZWQoYy5kYXRlcGlja2VyQXBwZW5kVG9Cb2R5KT9hLiRwYXJlbnQuJGV2YWwoYy5kYXRlcGlja2VyQXBwZW5kVG9Cb2R5KTprLmFwcGVuZFRvQm9keSx3PWFuZ3VsYXIuaXNEZWZpbmVkKGMub25PcGVuRm9jdXMpP2EuJHBhcmVudC4kZXZhbChjLm9uT3BlbkZvY3VzKTprLm9uT3BlbkZvY3VzLHg9YW5ndWxhci5pc0RlZmluZWQoYy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCk/Yy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybDprLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsLHk9YW5ndWxhci5pc0RlZmluZWQoYy5kYXRlcGlja2VyVGVtcGxhdGVVcmwpP2MuZGF0ZXBpY2tlclRlbXBsYXRlVXJsOmsuZGF0ZXBpY2tlclRlbXBsYXRlVXJsLEU9YW5ndWxhci5pc0RlZmluZWQoYy5hbHRJbnB1dEZvcm1hdHMpP2EuJHBhcmVudC4kZXZhbChjLmFsdElucHV0Rm9ybWF0cyk6ay5hbHRJbnB1dEZvcm1hdHMsYS5zaG93QnV0dG9uQmFyPWFuZ3VsYXIuaXNEZWZpbmVkKGMuc2hvd0J1dHRvbkJhcik/YS4kcGFyZW50LiRldmFsKGMuc2hvd0J1dHRvbkJhcik6ay5zaG93QnV0dG9uQmFyLGsuaHRtbDVUeXBlc1tjLnR5cGVdPyh0PWsuaHRtbDVUeXBlc1tjLnR5cGVdLEc9ITApOih0PWMudWliRGF0ZXBpY2tlclBvcHVwfHxrLmRhdGVwaWNrZXJQb3B1cCxjLiRvYnNlcnZlKFxcXCJ1aWJEYXRlcGlja2VyUG9wdXBcXFwiLGZ1bmN0aW9uKGEsYil7dmFyIGM9YXx8ay5kYXRlcGlja2VyUG9wdXA7aWYoYyE9PXQmJih0PWMsQi4kbW9kZWxWYWx1ZT1udWxsLCF0KSl0aHJvdyBuZXcgRXJyb3IoXFxcInVpYkRhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuXFxcIil9KSksIXQpdGhyb3cgbmV3IEVycm9yKFxcXCJ1aWJEYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLlxcXCIpO2lmKEcmJmMudWliRGF0ZXBpY2tlclBvcHVwKXRocm93IG5ldyBFcnJvcihcXFwiSFRNTDUgZGF0ZSBpbnB1dCB0eXBlcyBkbyBub3Qgc3VwcG9ydCBjdXN0b20gZm9ybWF0cy5cXFwiKTt6PWFuZ3VsYXIuZWxlbWVudChcXFwiPGRpdiB1aWItZGF0ZXBpY2tlci1wb3B1cC13cmFwPjxkaXYgdWliLWRhdGVwaWNrZXI+PC9kaXY+PC9kaXY+XFxcIiksYS5uZ01vZGVsT3B0aW9ucz1hbmd1bGFyLmNvcHkoQyksYS5uZ01vZGVsT3B0aW9ucy50aW1lem9uZT1udWxsLHouYXR0cih7XFxcIm5nLW1vZGVsXFxcIjpcXFwiZGF0ZVxcXCIsXFxcIm5nLW1vZGVsLW9wdGlvbnNcXFwiOlxcXCJuZ01vZGVsT3B0aW9uc1xcXCIsXFxcIm5nLWNoYW5nZVxcXCI6XFxcImRhdGVTZWxlY3Rpb24oZGF0ZSlcXFwiLFxcXCJ0ZW1wbGF0ZS11cmxcXFwiOnh9KSxBPWFuZ3VsYXIuZWxlbWVudCh6LmNoaWxkcmVuKClbMF0pLEEuYXR0cihcXFwidGVtcGxhdGUtdXJsXFxcIix5KSxHJiZcXFwibW9udGhcXFwiPT09Yy50eXBlJiYoQS5hdHRyKFxcXCJkYXRlcGlja2VyLW1vZGVcXFwiLCdcXFwibW9udGhcXFwiJyksQS5hdHRyKFxcXCJtaW4tbW9kZVxcXCIsXFxcIm1vbnRoXFxcIikpLGEuZGF0ZXBpY2tlck9wdGlvbnMmJmFuZ3VsYXIuZm9yRWFjaChhLmRhdGVwaWNrZXJPcHRpb25zLGZ1bmN0aW9uKGEsYil7LTE9PT1bXFxcIm1pbkRhdGVcXFwiLFxcXCJtYXhEYXRlXFxcIixcXFwibWluTW9kZVxcXCIsXFxcIm1heE1vZGVcXFwiLFxcXCJpbml0RGF0ZVxcXCIsXFxcImRhdGVwaWNrZXJNb2RlXFxcIl0uaW5kZXhPZihiKT9BLmF0dHIobihiKSxhKTpBLmF0dHIobihiKSxcXFwiZGF0ZXBpY2tlck9wdGlvbnMuXFxcIitiKX0pLGFuZ3VsYXIuZm9yRWFjaChbXFxcIm1pbk1vZGVcXFwiLFxcXCJtYXhNb2RlXFxcIixcXFwiZGF0ZXBpY2tlck1vZGVcXFwiLFxcXCJzaG9ydGN1dFByb3BhZ2F0aW9uXFxcIl0sZnVuY3Rpb24oYil7aWYoY1tiXSl7dmFyIGQ9ZShjW2JdKSxmPXtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZChhLiRwYXJlbnQpfX07aWYoQS5hdHRyKG4oYiksXFxcIndhdGNoRGF0YS5cXFwiK2IpLFxcXCJkYXRlcGlja2VyTW9kZVxcXCI9PT1iKXt2YXIgZz1kLmFzc2lnbjtmLnNldD1mdW5jdGlvbihiKXtnKGEuJHBhcmVudCxiKX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGEud2F0Y2hEYXRhLGIsZil9fSksYW5ndWxhci5mb3JFYWNoKFtcXFwibWluRGF0ZVxcXCIsXFxcIm1heERhdGVcXFwiLFxcXCJpbml0RGF0ZVxcXCJdLGZ1bmN0aW9uKGIpe2lmKGNbYl0pe3ZhciBkPWUoY1tiXSk7SC5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZCxmdW5jdGlvbihjKXtcXFwibWluRGF0ZVxcXCI9PT1ifHxcXFwibWF4RGF0ZVxcXCI9PT1iPyhudWxsPT09Yz9GW2JdPW51bGw6YW5ndWxhci5pc0RhdGUoYyk/RltiXT1qLmZyb21UaW1lem9uZShuZXcgRGF0ZShjKSxDLnRpbWV6b25lKTpGW2JdPW5ldyBEYXRlKGkoYyxcXFwibWVkaXVtXFxcIikpLGEud2F0Y2hEYXRhW2JdPW51bGw9PT1jP251bGw6RltiXSk6YS53YXRjaERhdGFbYl09ai5mcm9tVGltZXpvbmUobmV3IERhdGUoYyksQy50aW1lem9uZSl9KSksQS5hdHRyKG4oYiksXFxcIndhdGNoRGF0YS5cXFwiK2IpfX0pLGMuZGF0ZURpc2FibGVkJiZBLmF0dHIoXFxcImRhdGUtZGlzYWJsZWRcXFwiLFxcXCJkYXRlRGlzYWJsZWQoeyBkYXRlOiBkYXRlLCBtb2RlOiBtb2RlIH0pXFxcIiksYW5ndWxhci5mb3JFYWNoKFtcXFwiZm9ybWF0RGF5XFxcIixcXFwiZm9ybWF0TW9udGhcXFwiLFxcXCJmb3JtYXRZZWFyXFxcIixcXFwiZm9ybWF0RGF5SGVhZGVyXFxcIixcXFwiZm9ybWF0RGF5VGl0bGVcXFwiLFxcXCJmb3JtYXRNb250aFRpdGxlXFxcIixcXFwic2hvd1dlZWtzXFxcIixcXFwic3RhcnRpbmdEYXlcXFwiLFxcXCJ5ZWFyUm93c1xcXCIsXFxcInllYXJDb2x1bW5zXFxcIl0sZnVuY3Rpb24oYSl7YW5ndWxhci5pc0RlZmluZWQoY1thXSkmJkEuYXR0cihuKGEpLGNbYV0pfSksYy5jdXN0b21DbGFzcyYmQS5hdHRyKFxcXCJjdXN0b20tY2xhc3NcXFwiLFxcXCJjdXN0b21DbGFzcyh7IGRhdGU6IGRhdGUsIG1vZGU6IG1vZGUgfSlcXFwiKSxHP0IuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihiKXtyZXR1cm4gYS5kYXRlPWouZnJvbVRpbWV6b25lKGIsQy50aW1lem9uZSksYn0pOihCLiQkcGFyc2VyTmFtZT1cXFwiZGF0ZVxcXCIsQi4kdmFsaWRhdG9ycy5kYXRlPXEsQi4kcGFyc2Vycy51bnNoaWZ0KHApLEIuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihiKXtyZXR1cm4gQi4kaXNFbXB0eShiKT8oYS5kYXRlPWIsYik6KGEuZGF0ZT1qLmZyb21UaW1lem9uZShiLEMudGltZXpvbmUpLHQ9dC5yZXBsYWNlKC9NIS8sXFxcIk1NXFxcIikucmVwbGFjZSgvZCEvLFxcXCJkZFxcXCIpLGkoYS5kYXRlLHQpKX0pKSxCLiR2aWV3Q2hhbmdlTGlzdGVuZXJzLnB1c2goZnVuY3Rpb24oKXthLmRhdGU9byhCLiR2aWV3VmFsdWUpfSksYi5vbihcXFwia2V5ZG93blxcXCIscyksRD1kKHopKGEpLHoucmVtb3ZlKCksdj9mLmZpbmQoXFxcImJvZHlcXFwiKS5hcHBlbmQoRCk6Yi5hZnRlcihEKSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Zm9yKGEuaXNPcGVuPT09ITAmJihnLiQkcGhhc2V8fGEuJGFwcGx5KGZ1bmN0aW9uKCl7YS5pc09wZW49ITF9KSksRC5yZW1vdmUoKSxiLm9mZihcXFwia2V5ZG93blxcXCIscyksZi5vZmYoXFxcImNsaWNrXFxcIixyKTtILmxlbmd0aDspSC5zaGlmdCgpKCl9KX0sYS5nZXRUZXh0PWZ1bmN0aW9uKGIpe3JldHVybiBhW2IrXFxcIlRleHRcXFwiXXx8a1tiK1xcXCJUZXh0XFxcIl19LGEuaXNEaXNhYmxlZD1mdW5jdGlvbihiKXtyZXR1cm5cXFwidG9kYXlcXFwiPT09YiYmKGI9bmV3IERhdGUpLGEud2F0Y2hEYXRhLm1pbkRhdGUmJmEuY29tcGFyZShiLEYubWluRGF0ZSk8MHx8YS53YXRjaERhdGEubWF4RGF0ZSYmYS5jb21wYXJlKGIsRi5tYXhEYXRlKT4wfSxhLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IERhdGUoYS5nZXRGdWxsWWVhcigpLGEuZ2V0TW9udGgoKSxhLmdldERhdGUoKSktbmV3IERhdGUoYi5nZXRGdWxsWWVhcigpLGIuZ2V0TW9udGgoKSxiLmdldERhdGUoKSl9LGEuZGF0ZVNlbGVjdGlvbj1mdW5jdGlvbihjKXthbmd1bGFyLmlzRGVmaW5lZChjKSYmKGEuZGF0ZT1jKTt2YXIgZD1hLmRhdGU/aShhLmRhdGUsdCk6bnVsbDtiLnZhbChkKSxCLiRzZXRWaWV3VmFsdWUoZCksdSYmKGEuaXNPcGVuPSExLGJbMF0uZm9jdXMoKSl9LGEua2V5ZG93bj1mdW5jdGlvbihjKXsyNz09PWMud2hpY2gmJihjLnN0b3BQcm9wYWdhdGlvbigpLGEuaXNPcGVuPSExLGJbMF0uZm9jdXMoKSl9LGEuc2VsZWN0PWZ1bmN0aW9uKGIpe2lmKFxcXCJ0b2RheVxcXCI9PT1iKXt2YXIgYz1uZXcgRGF0ZTthbmd1bGFyLmlzRGF0ZShhLmRhdGUpPyhiPW5ldyBEYXRlKGEuZGF0ZSksYi5zZXRGdWxsWWVhcihjLmdldEZ1bGxZZWFyKCksYy5nZXRNb250aCgpLGMuZ2V0RGF0ZSgpKSk6Yj1uZXcgRGF0ZShjLnNldEhvdXJzKDAsMCwwLDApKX1hLmRhdGVTZWxlY3Rpb24oYil9LGEuY2xvc2U9ZnVuY3Rpb24oKXthLmlzT3Blbj0hMSxiWzBdLmZvY3VzKCl9LGEuZGlzYWJsZWQ9YW5ndWxhci5pc0RlZmluZWQoYy5kaXNhYmxlZCl8fCExLGMubmdEaXNhYmxlZCYmSC5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZShjLm5nRGlzYWJsZWQpLGZ1bmN0aW9uKGIpe2EuZGlzYWJsZWQ9Yn0pKSxhLiR3YXRjaChcXFwiaXNPcGVuXFxcIixmdW5jdGlvbihjKXtjP2EuZGlzYWJsZWQ/YS5pc09wZW49ITE6KGEucG9zaXRpb249dj9oLm9mZnNldChiKTpoLnBvc2l0aW9uKGIpLGEucG9zaXRpb24udG9wPWEucG9zaXRpb24udG9wK2IucHJvcChcXFwib2Zmc2V0SGVpZ2h0XFxcIiksbChmdW5jdGlvbigpe3cmJmEuJGJyb2FkY2FzdChcXFwidWliOmRhdGVwaWNrZXIuZm9jdXNcXFwiKSxmLm9uKFxcXCJjbGlja1xcXCIscil9LDAsITEpKTpmLm9mZihcXFwiY2xpY2tcXFwiLHIpfSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJEYXRlcGlja2VyUG9wdXBcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcXVpcmU6W1xcXCJuZ01vZGVsXFxcIixcXFwidWliRGF0ZXBpY2tlclBvcHVwXFxcIl0sY29udHJvbGxlcjpcXFwiVWliRGF0ZXBpY2tlclBvcHVwQ29udHJvbGxlclxcXCIsc2NvcGU6e2RhdGVwaWNrZXJPcHRpb25zOlxcXCI9P1xcXCIsaXNPcGVuOlxcXCI9P1xcXCIsY3VycmVudFRleHQ6XFxcIkBcXFwiLGNsZWFyVGV4dDpcXFwiQFxcXCIsY2xvc2VUZXh0OlxcXCJAXFxcIixkYXRlRGlzYWJsZWQ6XFxcIiZcXFwiLGN1c3RvbUNsYXNzOlxcXCImXFxcIn0sbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kWzBdLGY9ZFsxXTtmLmluaXQoZSl9fX0pLmRpcmVjdGl2ZShcXFwidWliRGF0ZXBpY2tlclBvcHVwV3JhcFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCx0cmFuc2NsdWRlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXFxcIn19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5kZWJvdW5jZVxcXCIsW10pLmZhY3RvcnkoXFxcIiQkZGVib3VuY2VcXFwiLFtcXFwiJHRpbWVvdXRcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe3ZhciBkO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXRoaXMsZj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO2QmJmEuY2FuY2VsKGQpLGQ9YShmdW5jdGlvbigpe2IuYXBwbHkoZSxmKX0sYyl9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmRyb3Bkb3duXFxcIixbXFxcInVpLmJvb3RzdHJhcC5wb3NpdGlvblxcXCJdKS5jb25zdGFudChcXFwidWliRHJvcGRvd25Db25maWdcXFwiLHthcHBlbmRUb09wZW5DbGFzczpcXFwidWliLWRyb3Bkb3duLW9wZW5cXFwiLG9wZW5DbGFzczpcXFwib3BlblxcXCJ9KS5zZXJ2aWNlKFxcXCJ1aWJEcm9wZG93blNlcnZpY2VcXFwiLFtcXFwiJGRvY3VtZW50XFxcIixcXFwiJHJvb3RTY29wZVxcXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsO3RoaXMub3Blbj1mdW5jdGlvbihiKXtjfHwoYS5vbihcXFwiY2xpY2tcXFwiLGQpLGEub24oXFxcImtleWRvd25cXFwiLGUpKSxjJiZjIT09YiYmKGMuaXNPcGVuPSExKSxjPWJ9LHRoaXMuY2xvc2U9ZnVuY3Rpb24oYil7Yz09PWImJihjPW51bGwsYS5vZmYoXFxcImNsaWNrXFxcIixkKSxhLm9mZihcXFwia2V5ZG93blxcXCIsZSkpfTt2YXIgZD1mdW5jdGlvbihhKXtpZihjJiYhKGEmJlxcXCJkaXNhYmxlZFxcXCI9PT1jLmdldEF1dG9DbG9zZSgpfHxhJiYzPT09YS53aGljaCkpe3ZhciBkPWMuZ2V0VG9nZ2xlRWxlbWVudCgpO2lmKCEoYSYmZCYmZFswXS5jb250YWlucyhhLnRhcmdldCkpKXt2YXIgZT1jLmdldERyb3Bkb3duRWxlbWVudCgpO2EmJlxcXCJvdXRzaWRlQ2xpY2tcXFwiPT09Yy5nZXRBdXRvQ2xvc2UoKSYmZSYmZVswXS5jb250YWlucyhhLnRhcmdldCl8fChjLmlzT3Blbj0hMSxiLiQkcGhhc2V8fGMuJGFwcGx5KCkpfX19LGU9ZnVuY3Rpb24oYSl7Mjc9PT1hLndoaWNoPyhjLmZvY3VzVG9nZ2xlRWxlbWVudCgpLGQoKSk6Yy5pc0tleW5hdkVuYWJsZWQoKSYmLTEhPT1bMzgsNDBdLmluZGV4T2YoYS53aGljaCkmJmMuaXNPcGVuJiYoYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYy5mb2N1c0Ryb3Bkb3duRW50cnkoYS53aGljaCkpfX1dKS5jb250cm9sbGVyKFxcXCJVaWJEcm9wZG93bkNvbnRyb2xsZXJcXFwiLFtcXFwiJHNjb3BlXFxcIixcXFwiJGVsZW1lbnRcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCJ1aWJEcm9wZG93bkNvbmZpZ1xcXCIsXFxcInVpYkRyb3Bkb3duU2VydmljZVxcXCIsXFxcIiRhbmltYXRlXFxcIixcXFwiJHVpYlBvc2l0aW9uXFxcIixcXFwiJGRvY3VtZW50XFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkdGVtcGxhdGVSZXF1ZXN0XFxcIixmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSxqLGspe3ZhciBsLG0sbj10aGlzLG89YS4kbmV3KCkscD1lLmFwcGVuZFRvT3BlbkNsYXNzLHE9ZS5vcGVuQ2xhc3Mscj1hbmd1bGFyLm5vb3Ascz1jLm9uVG9nZ2xlP2QoYy5vblRvZ2dsZSk6YW5ndWxhci5ub29wLHQ9ITEsdT1udWxsLHY9ITEsdz1pLmZpbmQoXFxcImJvZHlcXFwiKTtiLmFkZENsYXNzKFxcXCJkcm9wZG93blxcXCIpLHRoaXMuaW5pdD1mdW5jdGlvbigpe2lmKGMuaXNPcGVuJiYobT1kKGMuaXNPcGVuKSxyPW0uYXNzaWduLGEuJHdhdGNoKG0sZnVuY3Rpb24oYSl7by5pc09wZW49ISFhfSkpLGFuZ3VsYXIuaXNEZWZpbmVkKGMuZHJvcGRvd25BcHBlbmRUbykpe3ZhciBlPWQoYy5kcm9wZG93bkFwcGVuZFRvKShvKTtlJiYodT1hbmd1bGFyLmVsZW1lbnQoZSkpfXQ9YW5ndWxhci5pc0RlZmluZWQoYy5kcm9wZG93bkFwcGVuZFRvQm9keSksdj1hbmd1bGFyLmlzRGVmaW5lZChjLmtleWJvYXJkTmF2KSx0JiYhdSYmKHU9dyksdSYmbi5kcm9wZG93bk1lbnUmJih1LmFwcGVuZChuLmRyb3Bkb3duTWVudSksYi5vbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7bi5kcm9wZG93bk1lbnUucmVtb3ZlKCl9KSl9LHRoaXMudG9nZ2xlPWZ1bmN0aW9uKGEpe3JldHVybiBvLmlzT3Blbj1hcmd1bWVudHMubGVuZ3RoPyEhYTohby5pc09wZW59LHRoaXMuaXNPcGVuPWZ1bmN0aW9uKCl7cmV0dXJuIG8uaXNPcGVufSxvLmdldFRvZ2dsZUVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbi50b2dnbGVFbGVtZW50fSxvLmdldEF1dG9DbG9zZT1mdW5jdGlvbigpe3JldHVybiBjLmF1dG9DbG9zZXx8XFxcImFsd2F5c1xcXCJ9LG8uZ2V0RWxlbWVudD1mdW5jdGlvbigpe3JldHVybiBifSxvLmlzS2V5bmF2RW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB2fSxvLmZvY3VzRHJvcGRvd25FbnRyeT1mdW5jdGlvbihhKXt2YXIgYz1uLmRyb3Bkb3duTWVudT9hbmd1bGFyLmVsZW1lbnQobi5kcm9wZG93bk1lbnUpLmZpbmQoXFxcImFcXFwiKTpiLmZpbmQoXFxcInVsXFxcIikuZXEoMCkuZmluZChcXFwiYVxcXCIpO3N3aXRjaChhKXtjYXNlIDQwOmFuZ3VsYXIuaXNOdW1iZXIobi5zZWxlY3RlZE9wdGlvbik/bi5zZWxlY3RlZE9wdGlvbj1uLnNlbGVjdGVkT3B0aW9uPT09Yy5sZW5ndGgtMT9uLnNlbGVjdGVkT3B0aW9uOm4uc2VsZWN0ZWRPcHRpb24rMTpuLnNlbGVjdGVkT3B0aW9uPTA7YnJlYWs7Y2FzZSAzODphbmd1bGFyLmlzTnVtYmVyKG4uc2VsZWN0ZWRPcHRpb24pP24uc2VsZWN0ZWRPcHRpb249MD09PW4uc2VsZWN0ZWRPcHRpb24/MDpuLnNlbGVjdGVkT3B0aW9uLTE6bi5zZWxlY3RlZE9wdGlvbj1jLmxlbmd0aC0xfWNbbi5zZWxlY3RlZE9wdGlvbl0uZm9jdXMoKX0sby5nZXREcm9wZG93bkVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbi5kcm9wZG93bk1lbnV9LG8uZm9jdXNUb2dnbGVFbGVtZW50PWZ1bmN0aW9uKCl7bi50b2dnbGVFbGVtZW50JiZuLnRvZ2dsZUVsZW1lbnRbMF0uZm9jdXMoKX0sby4kd2F0Y2goXFxcImlzT3BlblxcXCIsZnVuY3Rpb24oYyxkKXtpZih1JiZuLmRyb3Bkb3duTWVudSl7dmFyIGUsaSxtPWgucG9zaXRpb25FbGVtZW50cyhiLG4uZHJvcGRvd25NZW51LFxcXCJib3R0b20tbGVmdFxcXCIsITApO2lmKGU9e3RvcDptLnRvcCtcXFwicHhcXFwiLGRpc3BsYXk6Yz9cXFwiYmxvY2tcXFwiOlxcXCJub25lXFxcIn0saT1uLmRyb3Bkb3duTWVudS5oYXNDbGFzcyhcXFwiZHJvcGRvd24tbWVudS1yaWdodFxcXCIpLGk/KGUubGVmdD1cXFwiYXV0b1xcXCIsZS5yaWdodD13aW5kb3cuaW5uZXJXaWR0aC0obS5sZWZ0K2IucHJvcChcXFwib2Zmc2V0V2lkdGhcXFwiKSkrXFxcInB4XFxcIik6KGUubGVmdD1tLmxlZnQrXFxcInB4XFxcIixlLnJpZ2h0PVxcXCJhdXRvXFxcIiksIXQpe3ZhciB2PWgub2Zmc2V0KHUpO2UudG9wPW0udG9wLXYudG9wK1xcXCJweFxcXCIsaT9lLnJpZ2h0PXdpbmRvdy5pbm5lcldpZHRoLShtLmxlZnQtdi5sZWZ0K2IucHJvcChcXFwib2Zmc2V0V2lkdGhcXFwiKSkrXFxcInB4XFxcIjplLmxlZnQ9bS5sZWZ0LXYubGVmdCtcXFwicHhcXFwifW4uZHJvcGRvd25NZW51LmNzcyhlKX12YXIgdz11P3U6YjtpZihnW2M/XFxcImFkZENsYXNzXFxcIjpcXFwicmVtb3ZlQ2xhc3NcXFwiXSh3LHU/cDpxKS50aGVuKGZ1bmN0aW9uKCl7YW5ndWxhci5pc0RlZmluZWQoYykmJmMhPT1kJiZzKGEse29wZW46ISFjfSl9KSxjKW4uZHJvcGRvd25NZW51VGVtcGxhdGVVcmwmJmsobi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCkudGhlbihmdW5jdGlvbihhKXtsPW8uJG5ldygpLGooYS50cmltKCkpKGwsZnVuY3Rpb24oYSl7dmFyIGI9YTtuLmRyb3Bkb3duTWVudS5yZXBsYWNlV2l0aChiKSxuLmRyb3Bkb3duTWVudT1ifSl9KSxvLmZvY3VzVG9nZ2xlRWxlbWVudCgpLGYub3BlbihvKTtlbHNle2lmKG4uZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpe2wmJmwuJGRlc3Ryb3koKTt2YXIgeD1hbmd1bGFyLmVsZW1lbnQoJzx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCI+PC91bD4nKTtuLmRyb3Bkb3duTWVudS5yZXBsYWNlV2l0aCh4KSxuLmRyb3Bkb3duTWVudT14fWYuY2xvc2Uobyksbi5zZWxlY3RlZE9wdGlvbj1udWxsfWFuZ3VsYXIuaXNGdW5jdGlvbihyKSYmcihhLGMpfSksYS4kb24oXFxcIiRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3NcXFwiLGZ1bmN0aW9uKCl7XFxcImRpc2FibGVkXFxcIiE9PW8uZ2V0QXV0b0Nsb3NlKCkmJihvLmlzT3Blbj0hMSl9KX1dKS5kaXJlY3RpdmUoXFxcInVpYkRyb3Bkb3duXFxcIixmdW5jdGlvbigpe3JldHVybntjb250cm9sbGVyOlxcXCJVaWJEcm9wZG93bkNvbnRyb2xsZXJcXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7ZC5pbml0KCl9fX0pLmRpcmVjdGl2ZShcXFwidWliRHJvcGRvd25NZW51XFxcIixmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIscmVxdWlyZTpcXFwiP151aWJEcm9wZG93blxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXtpZihkJiYhYW5ndWxhci5pc0RlZmluZWQoYy5kcm9wZG93bk5lc3RlZCkpe2IuYWRkQ2xhc3MoXFxcImRyb3Bkb3duLW1lbnVcXFwiKTt2YXIgZT1jLnRlbXBsYXRlVXJsO2UmJihkLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsPWUpLGQuZHJvcGRvd25NZW51fHwoZC5kcm9wZG93bk1lbnU9Yil9fX19KS5kaXJlY3RpdmUoXFxcInVpYkRyb3Bkb3duVG9nZ2xlXFxcIixmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOlxcXCI/XnVpYkRyb3Bkb3duXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2lmKGQpe2IuYWRkQ2xhc3MoXFxcImRyb3Bkb3duLXRvZ2dsZVxcXCIpLGQudG9nZ2xlRWxlbWVudD1iO3ZhciBlPWZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxiLmhhc0NsYXNzKFxcXCJkaXNhYmxlZFxcXCIpfHxjLmRpc2FibGVkfHxhLiRhcHBseShmdW5jdGlvbigpe2QudG9nZ2xlKCl9KX07Yi5iaW5kKFxcXCJjbGlja1xcXCIsZSksYi5hdHRyKHtcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ITAsXFxcImFyaWEtZXhwYW5kZWRcXFwiOiExfSksYS4kd2F0Y2goZC5pc09wZW4sZnVuY3Rpb24oYSl7Yi5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhIWEpfSksYS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe2IudW5iaW5kKFxcXCJjbGlja1xcXCIsZSl9KX19fX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFxcXCIsW10pLmZhY3RvcnkoXFxcIiQkc3RhY2tlZE1hcFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57Y3JlYXRlTmV3OmZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJue2FkZDpmdW5jdGlvbihiLGMpe2EucHVzaCh7a2V5OmIsdmFsdWU6Y30pfSxnZXQ6ZnVuY3Rpb24oYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYoYj09PWFbY10ua2V5KXJldHVybiBhW2NdfSxrZXlzOmZ1bmN0aW9uKCl7Zm9yKHZhciBiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyliLnB1c2goYVtjXS5rZXkpO3JldHVybiBifSx0b3A6ZnVuY3Rpb24oKXtyZXR1cm4gYVthLmxlbmd0aC0xXX0scmVtb3ZlOmZ1bmN0aW9uKGIpe2Zvcih2YXIgYz0tMSxkPTA7ZDxhLmxlbmd0aDtkKyspaWYoYj09PWFbZF0ua2V5KXtjPWQ7YnJlYWt9cmV0dXJuIGEuc3BsaWNlKGMsMSlbMF19LHJlbW92ZVRvcDpmdW5jdGlvbigpe3JldHVybiBhLnNwbGljZShhLmxlbmd0aC0xLDEpWzBdfSxsZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gYS5sZW5ndGh9fX19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5tb2RhbFxcXCIsW1xcXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFxcXCJdKS5mYWN0b3J5KFxcXCIkJG11bHRpTWFwXFxcIixmdW5jdGlvbigpe3JldHVybntjcmVhdGVOZXc6ZnVuY3Rpb24oKXt2YXIgYT17fTtyZXR1cm57ZW50cmllczpmdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyhhKS5tYXAoZnVuY3Rpb24oYil7cmV0dXJue2tleTpiLHZhbHVlOmFbYl19fSl9LGdldDpmdW5jdGlvbihiKXtyZXR1cm4gYVtiXX0saGFzS2V5OmZ1bmN0aW9uKGIpe3JldHVybiEhYVtiXX0sa2V5czpmdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyhhKX0scHV0OmZ1bmN0aW9uKGIsYyl7YVtiXXx8KGFbYl09W10pLGFbYl0ucHVzaChjKX0scmVtb3ZlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YVtiXTtpZihkKXt2YXIgZT1kLmluZGV4T2YoYyk7LTEhPT1lJiZkLnNwbGljZShlLDEpLGQubGVuZ3RofHxkZWxldGUgYVtiXX19fX19fSkucHJvdmlkZXIoXFxcIiR1aWJSZXNvbHZlXFxcIixmdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy5yZXNvbHZlcj1udWxsLHRoaXMuc2V0UmVzb2x2ZXI9ZnVuY3Rpb24oYSl7dGhpcy5yZXNvbHZlcj1hfSx0aGlzLiRnZXQ9W1xcXCIkaW5qZWN0b3JcXFwiLFxcXCIkcVxcXCIsZnVuY3Rpb24oYixjKXt2YXIgZD1hLnJlc29sdmVyP2IuZ2V0KGEucmVzb2x2ZXIpOm51bGw7cmV0dXJue3Jlc29sdmU6ZnVuY3Rpb24oYSxlLGYsZyl7aWYoZClyZXR1cm4gZC5yZXNvbHZlKGEsZSxmLGcpO3ZhciBoPVtdO3JldHVybiBhbmd1bGFyLmZvckVhY2goYSxmdW5jdGlvbihhKXthbmd1bGFyLmlzRnVuY3Rpb24oYSl8fGFuZ3VsYXIuaXNBcnJheShhKT9oLnB1c2goYy5yZXNvbHZlKGIuaW52b2tlKGEpKSk6YW5ndWxhci5pc1N0cmluZyhhKT9oLnB1c2goYy5yZXNvbHZlKGIuZ2V0KGEpKSk6aC5wdXNoKGMucmVzb2x2ZShhKSl9KSxjLmFsbChoKS50aGVuKGZ1bmN0aW9uKGIpe3ZhciBjPXt9LGQ9MDtyZXR1cm4gYW5ndWxhci5mb3JFYWNoKGEsZnVuY3Rpb24oYSxlKXtjW2VdPWJbZCsrXX0pLGN9KX19fV19KS5kaXJlY3RpdmUoXFxcInVpYk1vZGFsQmFja2Ryb3BcXFwiLFtcXFwiJGFuaW1hdGVDc3NcXFwiLFxcXCIkaW5qZWN0b3JcXFwiLFxcXCIkdWliTW9kYWxTdGFja1xcXCIsZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYixkLGUpe2UubW9kYWxJbkNsYXNzJiYoYShkLHthZGRDbGFzczplLm1vZGFsSW5DbGFzc30pLnN0YXJ0KCksYi4kb24oYy5OT1dfQ0xPU0lOR19FVkVOVCxmdW5jdGlvbihjLGYpe3ZhciBnPWYoKTtiLm1vZGFsT3B0aW9ucy5hbmltYXRpb24/YShkLHtyZW1vdmVDbGFzczplLm1vZGFsSW5DbGFzc30pLnN0YXJ0KCkudGhlbihnKTpnKCl9KSl9cmV0dXJue3JlcGxhY2U6ITAsdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXFxcIixjb21waWxlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuYWRkQ2xhc3MoYi5iYWNrZHJvcENsYXNzKSxkfX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJNb2RhbFdpbmRvd1xcXCIsW1xcXCIkdWliTW9kYWxTdGFja1xcXCIsXFxcIiRxXFxcIixcXFwiJGFuaW1hdGVcXFwiLFxcXCIkYW5pbWF0ZUNzc1xcXCIsXFxcIiRkb2N1bWVudFxcXCIsZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm57c2NvcGU6e2luZGV4OlxcXCJAXFxcIn0scmVwbGFjZTohMCx0cmFuc2NsdWRlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcXFwifSxsaW5rOmZ1bmN0aW9uKGYsZyxoKXtnLmFkZENsYXNzKGgud2luZG93Q2xhc3N8fFxcXCJcXFwiKSxnLmFkZENsYXNzKGgud2luZG93VG9wQ2xhc3N8fFxcXCJcXFwiKSxmLnNpemU9aC5zaXplLGYuY2xvc2U9ZnVuY3Rpb24oYil7dmFyIGM9YS5nZXRUb3AoKTtjJiZjLnZhbHVlLmJhY2tkcm9wJiZcXFwic3RhdGljXFxcIiE9PWMudmFsdWUuYmFja2Ryb3AmJmIudGFyZ2V0PT09Yi5jdXJyZW50VGFyZ2V0JiYoYi5wcmV2ZW50RGVmYXVsdCgpLGIuc3RvcFByb3BhZ2F0aW9uKCksYS5kaXNtaXNzKGMua2V5LFxcXCJiYWNrZHJvcCBjbGlja1xcXCIpKX0sZy5vbihcXFwiY2xpY2tcXFwiLGYuY2xvc2UpLGYuJGlzUmVuZGVyZWQ9ITA7dmFyIGk9Yi5kZWZlcigpO2guJG9ic2VydmUoXFxcIm1vZGFsUmVuZGVyXFxcIixmdW5jdGlvbihhKXtcXFwidHJ1ZVxcXCI9PT1hJiZpLnJlc29sdmUoKX0pLGkucHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7dmFyIGk9bnVsbDtoLm1vZGFsSW5DbGFzcyYmKGk9ZChnLHthZGRDbGFzczpoLm1vZGFsSW5DbGFzc30pLnN0YXJ0KCksZi4kb24oYS5OT1dfQ0xPU0lOR19FVkVOVCxmdW5jdGlvbihhLGIpe3ZhciBlPWIoKTtkP2QoZyx7cmVtb3ZlQ2xhc3M6aC5tb2RhbEluQ2xhc3N9KS5zdGFydCgpLnRoZW4oZSk6Yy5yZW1vdmVDbGFzcyhnLGgubW9kYWxJbkNsYXNzKS50aGVuKGUpfSkpLGIud2hlbihpKS50aGVuKGZ1bmN0aW9uKCl7aWYoIWVbMF0uYWN0aXZlRWxlbWVudHx8IWdbMF0uY29udGFpbnMoZVswXS5hY3RpdmVFbGVtZW50KSl7dmFyIGE9Z1swXS5xdWVyeVNlbGVjdG9yKFxcXCJbYXV0b2ZvY3VzXVxcXCIpO2E/YS5mb2N1cygpOmdbMF0uZm9jdXMoKX19KTt2YXIgaj1hLmdldFRvcCgpO2omJmEubW9kYWxSZW5kZXJlZChqLmtleSl9KX19fV0pLmRpcmVjdGl2ZShcXFwidWliTW9kYWxBbmltYXRpb25DbGFzc1xcXCIsZnVuY3Rpb24oKXtyZXR1cm57Y29tcGlsZTpmdW5jdGlvbihhLGIpe2IubW9kYWxBbmltYXRpb24mJmEuYWRkQ2xhc3MoYi51aWJNb2RhbEFuaW1hdGlvbkNsYXNzKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJNb2RhbFRyYW5zY2x1ZGVcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue2xpbms6ZnVuY3Rpb24oYSxiLGMsZCxlKXtlKGEuJHBhcmVudCxmdW5jdGlvbihhKXtiLmVtcHR5KCksYi5hcHBlbmQoYSl9KX19fSkuZmFjdG9yeShcXFwiJHVpYk1vZGFsU3RhY2tcXFwiLFtcXFwiJGFuaW1hdGVcXFwiLFxcXCIkYW5pbWF0ZUNzc1xcXCIsXFxcIiRkb2N1bWVudFxcXCIsXFxcIiRjb21waWxlXFxcIixcXFwiJHJvb3RTY29wZVxcXCIsXFxcIiRxXFxcIixcXFwiJCRtdWx0aU1hcFxcXCIsXFxcIiQkc3RhY2tlZE1hcFxcXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXtmdW5jdGlvbiBpKCl7Zm9yKHZhciBhPS0xLGI9dC5rZXlzKCksYz0wO2M8Yi5sZW5ndGg7YysrKXQuZ2V0KGJbY10pLnZhbHVlLmJhY2tkcm9wJiYoYT1jKTtyZXR1cm4gYX1mdW5jdGlvbiBqKGEsYil7dmFyIGM9dC5nZXQoYSkudmFsdWUsZD1jLmFwcGVuZFRvO3QucmVtb3ZlKGEpLG0oYy5tb2RhbERvbUVsLGMubW9kYWxTY29wZSxmdW5jdGlvbigpe3ZhciBiPWMub3BlbmVkQ2xhc3N8fHM7dS5yZW1vdmUoYixhKSxkLnRvZ2dsZUNsYXNzKGIsdS5oYXNLZXkoYikpLGsoITApfSxjLmNsb3NlZERlZmVycmVkKSxsKCksYiYmYi5mb2N1cz9iLmZvY3VzKCk6ZC5mb2N1cyYmZC5mb2N1cygpfWZ1bmN0aW9uIGsoYSl7dmFyIGI7dC5sZW5ndGgoKT4wJiYoYj10LnRvcCgpLnZhbHVlLGIubW9kYWxEb21FbC50b2dnbGVDbGFzcyhiLndpbmRvd1RvcENsYXNzfHxcXFwiXFxcIixhKSl9ZnVuY3Rpb24gbCgpe2lmKHAmJi0xPT09aSgpKXt2YXIgYT1xO20ocCxxLGZ1bmN0aW9uKCl7YT1udWxsfSkscD12b2lkIDAscT12b2lkIDB9fWZ1bmN0aW9uIG0oYSxjLGQsZSl7ZnVuY3Rpb24gZygpe2cuZG9uZXx8KGcuZG9uZT0hMCxiKGEse2V2ZW50OlxcXCJsZWF2ZVxcXCJ9KS5zdGFydCgpLnRoZW4oZnVuY3Rpb24oKXthLnJlbW92ZSgpLGUmJmUucmVzb2x2ZSgpfSksYy4kZGVzdHJveSgpLGQmJmQoKSl9dmFyIGgsaT1udWxsLGo9ZnVuY3Rpb24oKXtyZXR1cm4gaHx8KGg9Zi5kZWZlcigpLGk9aC5wcm9taXNlKSxmdW5jdGlvbigpe2gucmVzb2x2ZSgpfX07cmV0dXJuIGMuJGJyb2FkY2FzdCh2Lk5PV19DTE9TSU5HX0VWRU5ULGopLGYud2hlbihpKS50aGVuKGcpfWZ1bmN0aW9uIG4oYSl7aWYoYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSlyZXR1cm4gYTt2YXIgYj10LnRvcCgpO2lmKGIpc3dpdGNoKGEud2hpY2gpe2Nhc2UgMjc6Yi52YWx1ZS5rZXlib2FyZCYmKGEucHJldmVudERlZmF1bHQoKSxlLiRhcHBseShmdW5jdGlvbigpe3YuZGlzbWlzcyhiLmtleSxcXFwiZXNjYXBlIGtleSBwcmVzc1xcXCIpfSkpO2JyZWFrO2Nhc2UgOTp2LmxvYWRGb2N1c0VsZW1lbnRMaXN0KGIpO3ZhciBjPSExO2Euc2hpZnRLZXk/di5pc0ZvY3VzSW5GaXJzdEl0ZW0oYSkmJihjPXYuZm9jdXNMYXN0Rm9jdXNhYmxlRWxlbWVudCgpKTp2LmlzRm9jdXNJbkxhc3RJdGVtKGEpJiYoYz12LmZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50KCkpLGMmJihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSl9fWZ1bmN0aW9uIG8oYSxiLGMpe3JldHVybiFhLnZhbHVlLm1vZGFsU2NvcGUuJGJyb2FkY2FzdChcXFwibW9kYWwuY2xvc2luZ1xcXCIsYixjKS5kZWZhdWx0UHJldmVudGVkfXZhciBwLHEscixzPVxcXCJtb2RhbC1vcGVuXFxcIix0PWguY3JlYXRlTmV3KCksdT1nLmNyZWF0ZU5ldygpLHY9e05PV19DTE9TSU5HX0VWRU5UOlxcXCJtb2RhbC5zdGFjay5ub3ctY2xvc2luZ1xcXCJ9LHc9MCx4PVxcXCJhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZT10cnVlXVxcXCI7cmV0dXJuIGUuJHdhdGNoKGksZnVuY3Rpb24oYSl7cSYmKHEuaW5kZXg9YSl9KSxjLm9uKFxcXCJrZXlkb3duXFxcIixuKSxlLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yy5vZmYoXFxcImtleWRvd25cXFwiLG4pfSksdi5vcGVuPWZ1bmN0aW9uKGIsZil7dmFyIGc9Y1swXS5hY3RpdmVFbGVtZW50LGg9Zi5vcGVuZWRDbGFzc3x8cztrKCExKSx0LmFkZChiLHtkZWZlcnJlZDpmLmRlZmVycmVkLHJlbmRlckRlZmVycmVkOmYucmVuZGVyRGVmZXJyZWQsY2xvc2VkRGVmZXJyZWQ6Zi5jbG9zZWREZWZlcnJlZCxtb2RhbFNjb3BlOmYuc2NvcGUsYmFja2Ryb3A6Zi5iYWNrZHJvcCxrZXlib2FyZDpmLmtleWJvYXJkLG9wZW5lZENsYXNzOmYub3BlbmVkQ2xhc3Msd2luZG93VG9wQ2xhc3M6Zi53aW5kb3dUb3BDbGFzcyxhbmltYXRpb246Zi5hbmltYXRpb24sYXBwZW5kVG86Zi5hcHBlbmRUb30pLHUucHV0KGgsYik7dmFyIGo9Zi5hcHBlbmRUbyxsPWkoKTtpZighai5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFxcXCJhcHBlbmRUbyBlbGVtZW50IG5vdCBmb3VuZC4gTWFrZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgcGFzc2VkIGlzIGluIERPTS5cXFwiKTtsPj0wJiYhcCYmKHE9ZS4kbmV3KCEwKSxxLm1vZGFsT3B0aW9ucz1mLHEuaW5kZXg9bCxwPWFuZ3VsYXIuZWxlbWVudCgnPGRpdiB1aWItbW9kYWwtYmFja2Ryb3A9XFxcIm1vZGFsLWJhY2tkcm9wXFxcIj48L2Rpdj4nKSxwLmF0dHIoXFxcImJhY2tkcm9wLWNsYXNzXFxcIixmLmJhY2tkcm9wQ2xhc3MpLGYuYW5pbWF0aW9uJiZwLmF0dHIoXFxcIm1vZGFsLWFuaW1hdGlvblxcXCIsXFxcInRydWVcXFwiKSxkKHApKHEpLGEuZW50ZXIocCxqKSk7dmFyIG09YW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1tb2RhbC13aW5kb3c9XFxcIm1vZGFsLXdpbmRvd1xcXCI+PC9kaXY+Jyk7bS5hdHRyKHtcXFwidGVtcGxhdGUtdXJsXFxcIjpmLndpbmRvd1RlbXBsYXRlVXJsLFxcXCJ3aW5kb3ctY2xhc3NcXFwiOmYud2luZG93Q2xhc3MsXFxcIndpbmRvdy10b3AtY2xhc3NcXFwiOmYud2luZG93VG9wQ2xhc3Msc2l6ZTpmLnNpemUsaW5kZXg6dC5sZW5ndGgoKS0xLGFuaW1hdGU6XFxcImFuaW1hdGVcXFwifSkuaHRtbChmLmNvbnRlbnQpLGYuYW5pbWF0aW9uJiZtLmF0dHIoXFxcIm1vZGFsLWFuaW1hdGlvblxcXCIsXFxcInRydWVcXFwiKSxhLmVudGVyKGQobSkoZi5zY29wZSksaikudGhlbihmdW5jdGlvbigpe2EuYWRkQ2xhc3MoaixoKX0pLHQudG9wKCkudmFsdWUubW9kYWxEb21FbD1tLHQudG9wKCkudmFsdWUubW9kYWxPcGVuZXI9Zyx2LmNsZWFyRm9jdXNMaXN0Q2FjaGUoKX0sdi5jbG9zZT1mdW5jdGlvbihhLGIpe3ZhciBjPXQuZ2V0KGEpO3JldHVybiBjJiZvKGMsYiwhMCk/KGMudmFsdWUubW9kYWxTY29wZS4kJHVpYkRlc3RydWN0aW9uU2NoZWR1bGVkPSEwLGMudmFsdWUuZGVmZXJyZWQucmVzb2x2ZShiKSxqKGEsYy52YWx1ZS5tb2RhbE9wZW5lciksITApOiFjfSx2LmRpc21pc3M9ZnVuY3Rpb24oYSxiKXt2YXIgYz10LmdldChhKTtyZXR1cm4gYyYmbyhjLGIsITEpPyhjLnZhbHVlLm1vZGFsU2NvcGUuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZD0hMCxjLnZhbHVlLmRlZmVycmVkLnJlamVjdChiKSxqKGEsYy52YWx1ZS5tb2RhbE9wZW5lciksITApOiFjfSx2LmRpc21pc3NBbGw9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMuZ2V0VG9wKCk7YiYmdGhpcy5kaXNtaXNzKGIua2V5LGEpOyliPXRoaXMuZ2V0VG9wKCl9LHYuZ2V0VG9wPWZ1bmN0aW9uKCl7cmV0dXJuIHQudG9wKCl9LHYubW9kYWxSZW5kZXJlZD1mdW5jdGlvbihhKXt2YXIgYj10LmdldChhKTtiJiZiLnZhbHVlLnJlbmRlckRlZmVycmVkLnJlc29sdmUoKX0sdi5mb2N1c0ZpcnN0Rm9jdXNhYmxlRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiByLmxlbmd0aD4wPyhyWzBdLmZvY3VzKCksITApOiExfSx2LmZvY3VzTGFzdEZvY3VzYWJsZUVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gci5sZW5ndGg+MD8ocltyLmxlbmd0aC0xXS5mb2N1cygpLCEwKTohMX0sdi5pc0ZvY3VzSW5GaXJzdEl0ZW09ZnVuY3Rpb24oYSl7cmV0dXJuIHIubGVuZ3RoPjA/KGEudGFyZ2V0fHxhLnNyY0VsZW1lbnQpPT09clswXTohMX0sdi5pc0ZvY3VzSW5MYXN0SXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gci5sZW5ndGg+MD8oYS50YXJnZXR8fGEuc3JjRWxlbWVudCk9PT1yW3IubGVuZ3RoLTFdOiExfSx2LmNsZWFyRm9jdXNMaXN0Q2FjaGU9ZnVuY3Rpb24oKXtyPVtdLHc9MH0sdi5sb2FkRm9jdXNFbGVtZW50TGlzdD1mdW5jdGlvbihhKXtpZigodm9pZCAwPT09cnx8IXIubGVuZ3RoKSYmYSl7dmFyIGI9YS52YWx1ZS5tb2RhbERvbUVsO2ImJmIubGVuZ3RoJiYocj1iWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoeCkpfX0sdn1dKS5wcm92aWRlcihcXFwiJHVpYk1vZGFsXFxcIixmdW5jdGlvbigpe3ZhciBhPXtvcHRpb25zOnthbmltYXRpb246ITAsYmFja2Ryb3A6ITAsa2V5Ym9hcmQ6ITB9LCRnZXQ6W1xcXCIkcm9vdFNjb3BlXFxcIixcXFwiJHFcXFwiLFxcXCIkZG9jdW1lbnRcXFwiLFxcXCIkdGVtcGxhdGVSZXF1ZXN0XFxcIixcXFwiJGNvbnRyb2xsZXJcXFwiLFxcXCIkdWliUmVzb2x2ZVxcXCIsXFxcIiR1aWJNb2RhbFN0YWNrXFxcIixmdW5jdGlvbihiLGMsZCxlLGYsZyxoKXtmdW5jdGlvbiBpKGEpe3JldHVybiBhLnRlbXBsYXRlP2Mud2hlbihhLnRlbXBsYXRlKTplKGFuZ3VsYXIuaXNGdW5jdGlvbihhLnRlbXBsYXRlVXJsKT9hLnRlbXBsYXRlVXJsKCk6YS50ZW1wbGF0ZVVybCl9dmFyIGo9e30saz1udWxsO3JldHVybiBqLmdldFByb21pc2VDaGFpbj1mdW5jdGlvbigpe3JldHVybiBrfSxqLm9wZW49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gaigpe3JldHVybiByfXZhciBsPWMuZGVmZXIoKSxtPWMuZGVmZXIoKSxuPWMuZGVmZXIoKSxvPWMuZGVmZXIoKSxwPXtyZXN1bHQ6bC5wcm9taXNlLG9wZW5lZDptLnByb21pc2UsY2xvc2VkOm4ucHJvbWlzZSxyZW5kZXJlZDpvLnByb21pc2UsY2xvc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGguY2xvc2UocCxhKX0sZGlzbWlzczpmdW5jdGlvbihhKXtyZXR1cm4gaC5kaXNtaXNzKHAsYSl9fTtpZihlPWFuZ3VsYXIuZXh0ZW5kKHt9LGEub3B0aW9ucyxlKSxlLnJlc29sdmU9ZS5yZXNvbHZlfHx7fSxlLmFwcGVuZFRvPWUuYXBwZW5kVG98fGQuZmluZChcXFwiYm9keVxcXCIpLmVxKDApLCFlLnRlbXBsYXRlJiYhZS50ZW1wbGF0ZVVybCl0aHJvdyBuZXcgRXJyb3IoXFxcIk9uZSBvZiB0ZW1wbGF0ZSBvciB0ZW1wbGF0ZVVybCBvcHRpb25zIGlzIHJlcXVpcmVkLlxcXCIpO3ZhciBxLHI9Yy5hbGwoW2koZSksZy5yZXNvbHZlKGUucmVzb2x2ZSx7fSxudWxsLG51bGwpXSk7cmV0dXJuIHE9az1jLmFsbChba10pLnRoZW4oaixqKS50aGVuKGZ1bmN0aW9uKGEpe3ZhciBjPWUuc2NvcGV8fGIsZD1jLiRuZXcoKTtkLiRjbG9zZT1wLmNsb3NlLGQuJGRpc21pc3M9cC5kaXNtaXNzLGQuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtkLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWR8fGQuJGRpc21pc3MoXFxcIiR1aWJVbnNjaGVkdWxlZERlc3RydWN0aW9uXFxcIil9KTt2YXIgZyxpPXt9O2UuY29udHJvbGxlciYmKGkuJHNjb3BlPWQsaS4kdWliTW9kYWxJbnN0YW5jZT1wLGFuZ3VsYXIuZm9yRWFjaChhWzFdLGZ1bmN0aW9uKGEsYil7aVtiXT1hfSksZz1mKGUuY29udHJvbGxlcixpKSxlLmNvbnRyb2xsZXJBcyYmKGUuYmluZFRvQ29udHJvbGxlciYmKGcuJGNsb3NlPWQuJGNsb3NlLGcuJGRpc21pc3M9ZC4kZGlzbWlzcyxhbmd1bGFyLmV4dGVuZChnLGMpKSxkW2UuY29udHJvbGxlckFzXT1nKSksaC5vcGVuKHAse3Njb3BlOmQsZGVmZXJyZWQ6bCxyZW5kZXJEZWZlcnJlZDpvLGNsb3NlZERlZmVycmVkOm4sY29udGVudDphWzBdLGFuaW1hdGlvbjplLmFuaW1hdGlvbixiYWNrZHJvcDplLmJhY2tkcm9wLGtleWJvYXJkOmUua2V5Ym9hcmQsYmFja2Ryb3BDbGFzczplLmJhY2tkcm9wQ2xhc3Msd2luZG93VG9wQ2xhc3M6ZS53aW5kb3dUb3BDbGFzcyx3aW5kb3dDbGFzczplLndpbmRvd0NsYXNzLHdpbmRvd1RlbXBsYXRlVXJsOmUud2luZG93VGVtcGxhdGVVcmwsc2l6ZTplLnNpemUsb3BlbmVkQ2xhc3M6ZS5vcGVuZWRDbGFzcyxhcHBlbmRUbzplLmFwcGVuZFRvfSksbS5yZXNvbHZlKCEwKX0sZnVuY3Rpb24oYSl7bS5yZWplY3QoYSksbC5yZWplY3QoYSl9KVtcXFwiZmluYWxseVxcXCJdKGZ1bmN0aW9uKCl7az09PXEmJihrPW51bGwpfSkscH0san1dfTtyZXR1cm4gYX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAucGFnaW5nXFxcIixbXSkuZmFjdG9yeShcXFwidWliUGFnaW5nXFxcIixbXFxcIiRwYXJzZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue2NyZWF0ZTpmdW5jdGlvbihiLGMsZCl7Yi5zZXROdW1QYWdlcz1kLm51bVBhZ2VzP2EoZC5udW1QYWdlcykuYXNzaWduOmFuZ3VsYXIubm9vcCxiLm5nTW9kZWxDdHJsPXskc2V0Vmlld1ZhbHVlOmFuZ3VsYXIubm9vcH0sYi5fd2F0Y2hlcnM9W10sYi5pbml0PWZ1bmN0aW9uKGUsZil7Yi5uZ01vZGVsQ3RybD1lLGIuY29uZmlnPWYsZS4kcmVuZGVyPWZ1bmN0aW9uKCl7Yi5yZW5kZXIoKX0sZC5pdGVtc1BlclBhZ2U/Yi5fd2F0Y2hlcnMucHVzaChjLiRwYXJlbnQuJHdhdGNoKGEoZC5pdGVtc1BlclBhZ2UpLGZ1bmN0aW9uKGEpe2IuaXRlbXNQZXJQYWdlPXBhcnNlSW50KGEsMTApLGMudG90YWxQYWdlcz1iLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKSxiLnVwZGF0ZVBhZ2UoKX0pKTpiLml0ZW1zUGVyUGFnZT1mLml0ZW1zUGVyUGFnZSxjLiR3YXRjaChcXFwidG90YWxJdGVtc1xcXCIsZnVuY3Rpb24oYSxkKXsoYW5ndWxhci5pc0RlZmluZWQoYSl8fGEhPT1kKSYmKGMudG90YWxQYWdlcz1iLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKSxiLnVwZGF0ZVBhZ2UoKSl9KX0sYi5jYWxjdWxhdGVUb3RhbFBhZ2VzPWZ1bmN0aW9uKCl7dmFyIGE9Yi5pdGVtc1BlclBhZ2U8MT8xOk1hdGguY2VpbChjLnRvdGFsSXRlbXMvYi5pdGVtc1BlclBhZ2UpO3JldHVybiBNYXRoLm1heChhfHwwLDEpfSxiLnJlbmRlcj1mdW5jdGlvbigpe2MucGFnZT1wYXJzZUludChiLm5nTW9kZWxDdHJsLiR2aWV3VmFsdWUsMTApfHwxfSxjLnNlbGVjdFBhZ2U9ZnVuY3Rpb24oYSxkKXtkJiZkLnByZXZlbnREZWZhdWx0KCk7dmFyIGU9IWMubmdEaXNhYmxlZHx8IWQ7ZSYmYy5wYWdlIT09YSYmYT4wJiZhPD1jLnRvdGFsUGFnZXMmJihkJiZkLnRhcmdldCYmZC50YXJnZXQuYmx1cigpLGIubmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShhKSxiLm5nTW9kZWxDdHJsLiRyZW5kZXIoKSl9LGMuZ2V0VGV4dD1mdW5jdGlvbihhKXtyZXR1cm4gY1thK1xcXCJUZXh0XFxcIl18fGIuY29uZmlnW2ErXFxcIlRleHRcXFwiXX0sYy5ub1ByZXZpb3VzPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1jLnBhZ2V9LGMubm9OZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIGMucGFnZT09PWMudG90YWxQYWdlc30sYi51cGRhdGVQYWdlPWZ1bmN0aW9uKCl7Yi5zZXROdW1QYWdlcyhjLiRwYXJlbnQsYy50b3RhbFBhZ2VzKSxjLnBhZ2U+Yy50b3RhbFBhZ2VzP2Muc2VsZWN0UGFnZShjLnRvdGFsUGFnZXMpOmIubmdNb2RlbEN0cmwuJHJlbmRlcigpfSxjLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Zm9yKDtiLl93YXRjaGVycy5sZW5ndGg7KWIuX3dhdGNoZXJzLnNoaWZ0KCkoKX0pfX19XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5wYWdlclxcXCIsW1xcXCJ1aS5ib290c3RyYXAucGFnaW5nXFxcIl0pLmNvbnRyb2xsZXIoXFxcIlVpYlBhZ2VyQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCJ1aWJQYWdpbmdcXFwiLFxcXCJ1aWJQYWdlckNvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiLGMsZCl7YS5hbGlnbj1hbmd1bGFyLmlzRGVmaW5lZChiLmFsaWduKT9hLiRwYXJlbnQuJGV2YWwoYi5hbGlnbik6ZC5hbGlnbixjLmNyZWF0ZSh0aGlzLGEsYil9XSkuY29uc3RhbnQoXFxcInVpYlBhZ2VyQ29uZmlnXFxcIix7aXRlbXNQZXJQYWdlOjEwLHByZXZpb3VzVGV4dDpcXFwiwqsgUHJldmlvdXNcXFwiLG5leHRUZXh0OlxcXCJOZXh0IMK7XFxcIixhbGlnbjohMH0pLmRpcmVjdGl2ZShcXFwidWliUGFnZXJcXFwiLFtcXFwidWliUGFnZXJDb25maWdcXFwiLGZ1bmN0aW9uKGEpe3JldHVybntzY29wZTp7dG90YWxJdGVtczpcXFwiPVxcXCIscHJldmlvdXNUZXh0OlxcXCJAXFxcIixuZXh0VGV4dDpcXFwiQFxcXCIsbmdEaXNhYmxlZDpcXFwiPVxcXCJ9LHJlcXVpcmU6W1xcXCJ1aWJQYWdlclxcXCIsXFxcIj9uZ01vZGVsXFxcIl0sY29udHJvbGxlcjpcXFwiVWliUGFnZXJDb250cm9sbGVyXFxcIixjb250cm9sbGVyQXM6XFxcInBhZ2VyXFxcIix0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcXFwifSxyZXBsYWNlOiEwLGxpbms6ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9ZVswXSxnPWVbMV07ZyYmZi5pbml0KGcsYSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnBhZ2luYXRpb25cXFwiLFtcXFwidWkuYm9vdHN0cmFwLnBhZ2luZ1xcXCJdKS5jb250cm9sbGVyKFxcXCJVaWJQYWdpbmF0aW9uQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCJ1aWJQYWdpbmdcXFwiLFxcXCJ1aWJQYWdpbmF0aW9uQ29uZmlnXFxcIixmdW5jdGlvbihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3JldHVybntudW1iZXI6YSx0ZXh0OmIsYWN0aXZlOmN9fWZ1bmN0aW9uIGcoYSxiKXt2YXIgYz1bXSxkPTEsZT1iLGc9YW5ndWxhci5pc0RlZmluZWQoaSkmJmI+aTtnJiYoaj8oZD1NYXRoLm1heChhLU1hdGguZmxvb3IoaS8yKSwxKSxlPWQraS0xLGU+YiYmKGU9YixkPWUtaSsxKSk6KGQ9KE1hdGguY2VpbChhL2kpLTEpKmkrMSxlPU1hdGgubWluKGQraS0xLGIpKSk7Zm9yKHZhciBoPWQ7ZT49aDtoKyspe3ZhciBtPWYoaCxoLGg9PT1hKTtjLnB1c2gobSl9aWYoZyYmaT4wJiYoIWp8fGt8fGwpKXtpZihkPjEpe2lmKCFsfHxkPjMpe3ZhciBuPWYoZC0xLFxcXCIuLi5cXFwiLCExKTtjLnVuc2hpZnQobil9aWYobCl7aWYoMz09PWQpe3ZhciBvPWYoMixcXFwiMlxcXCIsITEpO2MudW5zaGlmdChvKX12YXIgcD1mKDEsXFxcIjFcXFwiLCExKTtjLnVuc2hpZnQocCl9fWlmKGI+ZSl7aWYoIWx8fGItMj5lKXt2YXIgcT1mKGUrMSxcXFwiLi4uXFxcIiwhMSk7Yy5wdXNoKHEpfWlmKGwpe2lmKGU9PT1iLTIpe3ZhciByPWYoYi0xLGItMSwhMSk7Yy5wdXNoKHIpfXZhciBzPWYoYixiLCExKTtjLnB1c2gocyl9fX1yZXR1cm4gY312YXIgaD10aGlzLGk9YW5ndWxhci5pc0RlZmluZWQoYi5tYXhTaXplKT9hLiRwYXJlbnQuJGV2YWwoYi5tYXhTaXplKTplLm1heFNpemUsaj1hbmd1bGFyLmlzRGVmaW5lZChiLnJvdGF0ZSk/YS4kcGFyZW50LiRldmFsKGIucm90YXRlKTplLnJvdGF0ZSxrPWFuZ3VsYXIuaXNEZWZpbmVkKGIuZm9yY2VFbGxpcHNlcyk/YS4kcGFyZW50LiRldmFsKGIuZm9yY2VFbGxpcHNlcyk6ZS5mb3JjZUVsbGlwc2VzLGw9YW5ndWxhci5pc0RlZmluZWQoYi5ib3VuZGFyeUxpbmtOdW1iZXJzKT9hLiRwYXJlbnQuJGV2YWwoYi5ib3VuZGFyeUxpbmtOdW1iZXJzKTplLmJvdW5kYXJ5TGlua051bWJlcnM7YS5ib3VuZGFyeUxpbmtzPWFuZ3VsYXIuaXNEZWZpbmVkKGIuYm91bmRhcnlMaW5rcyk/YS4kcGFyZW50LiRldmFsKGIuYm91bmRhcnlMaW5rcyk6ZS5ib3VuZGFyeUxpbmtzLGEuZGlyZWN0aW9uTGlua3M9YW5ndWxhci5pc0RlZmluZWQoYi5kaXJlY3Rpb25MaW5rcyk/YS4kcGFyZW50LiRldmFsKGIuZGlyZWN0aW9uTGlua3MpOmUuZGlyZWN0aW9uTGlua3MsZC5jcmVhdGUodGhpcyxhLGIpLGIubWF4U2l6ZSYmaC5fd2F0Y2hlcnMucHVzaChhLiRwYXJlbnQuJHdhdGNoKGMoYi5tYXhTaXplKSxmdW5jdGlvbihhKXtpPXBhcnNlSW50KGEsMTApLGgucmVuZGVyKCl9KSk7dmFyIG09dGhpcy5yZW5kZXI7dGhpcy5yZW5kZXI9ZnVuY3Rpb24oKXttKCksYS5wYWdlPjAmJmEucGFnZTw9YS50b3RhbFBhZ2VzJiYoYS5wYWdlcz1nKGEucGFnZSxhLnRvdGFsUGFnZXMpKX19XSkuY29uc3RhbnQoXFxcInVpYlBhZ2luYXRpb25Db25maWdcXFwiLHtpdGVtc1BlclBhZ2U6MTAsYm91bmRhcnlMaW5rczohMSxib3VuZGFyeUxpbmtOdW1iZXJzOiExLGRpcmVjdGlvbkxpbmtzOiEwLGZpcnN0VGV4dDpcXFwiRmlyc3RcXFwiLHByZXZpb3VzVGV4dDpcXFwiUHJldmlvdXNcXFwiLG5leHRUZXh0OlxcXCJOZXh0XFxcIixsYXN0VGV4dDpcXFwiTGFzdFxcXCIscm90YXRlOiEwLGZvcmNlRWxsaXBzZXM6ITF9KS5kaXJlY3RpdmUoXFxcInVpYlBhZ2luYXRpb25cXFwiLFtcXFwiJHBhcnNlXFxcIixcXFwidWliUGFnaW5hdGlvbkNvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm57c2NvcGU6e3RvdGFsSXRlbXM6XFxcIj1cXFwiLGZpcnN0VGV4dDpcXFwiQFxcXCIscHJldmlvdXNUZXh0OlxcXCJAXFxcIixuZXh0VGV4dDpcXFwiQFxcXCIsbGFzdFRleHQ6XFxcIkBcXFwiLG5nRGlzYWJsZWQ6XFxcIj1cXFwifSxyZXF1aXJlOltcXFwidWliUGFnaW5hdGlvblxcXCIsXFxcIj9uZ01vZGVsXFxcIl0sY29udHJvbGxlcjpcXFwiVWliUGFnaW5hdGlvbkNvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwicGFnaW5hdGlvblxcXCIsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFxcXCJ9LHJlcGxhY2U6ITAsbGluazpmdW5jdGlvbihhLGMsZCxlKXt2YXIgZj1lWzBdLGc9ZVsxXTtnJiZmLmluaXQoZyxiKX19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAudG9vbHRpcFxcXCIsW1xcXCJ1aS5ib290c3RyYXAucG9zaXRpb25cXFwiLFxcXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFxcXCJdKS5wcm92aWRlcihcXFwiJHVpYlRvb2x0aXBcXFwiLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt2YXIgYj0vW0EtWl0vZyxjPVxcXCItXFxcIjtyZXR1cm4gYS5yZXBsYWNlKGIsZnVuY3Rpb24oYSxiKXtyZXR1cm4oYj9jOlxcXCJcXFwiKSthLnRvTG93ZXJDYXNlKCl9KX12YXIgYj17cGxhY2VtZW50OlxcXCJ0b3BcXFwiLHBsYWNlbWVudENsYXNzUHJlZml4OlxcXCJcXFwiLGFuaW1hdGlvbjohMCxwb3B1cERlbGF5OjAscG9wdXBDbG9zZURlbGF5OjAsdXNlQ29udGVudEV4cDohMX0sYz17bW91c2VlbnRlcjpcXFwibW91c2VsZWF2ZVxcXCIsY2xpY2s6XFxcImNsaWNrXFxcIixvdXRzaWRlQ2xpY2s6XFxcIm91dHNpZGVDbGlja1xcXCIsZm9jdXM6XFxcImJsdXJcXFwiLG5vbmU6XFxcIlxcXCJ9LGQ9e307dGhpcy5vcHRpb25zPWZ1bmN0aW9uKGEpe2FuZ3VsYXIuZXh0ZW5kKGQsYSl9LHRoaXMuc2V0VHJpZ2dlcnM9ZnVuY3Rpb24oYSl7YW5ndWxhci5leHRlbmQoYyxhKX0sdGhpcy4kZ2V0PVtcXFwiJHdpbmRvd1xcXCIsXFxcIiRjb21waWxlXFxcIixcXFwiJHRpbWVvdXRcXFwiLFxcXCIkZG9jdW1lbnRcXFwiLFxcXCIkdWliUG9zaXRpb25cXFwiLFxcXCIkaW50ZXJwb2xhdGVcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixcXFwiJHBhcnNlXFxcIixcXFwiJCRzdGFja2VkTWFwXFxcIixmdW5jdGlvbihlLGYsZyxoLGksaixrLGwsbSl7ZnVuY3Rpb24gbihhKXtpZigyNz09PWEud2hpY2gpe3ZhciBiPW8udG9wKCk7YiYmKGIudmFsdWUuY2xvc2UoKSxvLnJlbW92ZVRvcCgpLGI9bnVsbCl9fXZhciBvPW0uY3JlYXRlTmV3KCk7cmV0dXJuIGgub24oXFxcImtleXByZXNzXFxcIixuKSxrLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7aC5vZmYoXFxcImtleXByZXNzXFxcIixuKX0pLGZ1bmN0aW9uKGUsayxtLG4pe2Z1bmN0aW9uIHAoYSl7dmFyIGI9KGF8fG4udHJpZ2dlcnx8bSkuc3BsaXQoXFxcIiBcXFwiKSxkPWIubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBjW2FdfHxhfSk7cmV0dXJue3Nob3c6YixoaWRlOmR9fW49YW5ndWxhci5leHRlbmQoe30sYixkLG4pO3ZhciBxPWEoZSkscj1qLnN0YXJ0U3ltYm9sKCkscz1qLmVuZFN5bWJvbCgpLHQ9XFxcIjxkaXYgXFxcIitxKyctcG9wdXAgdGl0bGU9XFxcIicrcitcXFwidGl0bGVcXFwiK3MrJ1xcXCIgJysobi51c2VDb250ZW50RXhwPydjb250ZW50LWV4cD1cXFwiY29udGVudEV4cCgpXFxcIiAnOidjb250ZW50PVxcXCInK3IrXFxcImNvbnRlbnRcXFwiK3MrJ1xcXCIgJykrJ3BsYWNlbWVudD1cXFwiJytyK1xcXCJwbGFjZW1lbnRcXFwiK3MrJ1xcXCIgcG9wdXAtY2xhc3M9XFxcIicrcitcXFwicG9wdXBDbGFzc1xcXCIrcysnXFxcIiBhbmltYXRpb249XFxcImFuaW1hdGlvblxcXCIgaXMtb3Blbj1cXFwiaXNPcGVuXFxcIm9yaWdpbi1zY29wZT1cXFwib3JpZ1Njb3BlXFxcIiBzdHlsZT1cXFwidmlzaWJpbGl0eTogaGlkZGVuOyBkaXNwbGF5OiBibG9jazsgdG9wOiAtOTk5OXB4OyBsZWZ0OiAtOTk5OXB4O1xcXCI+PC9kaXY+JztyZXR1cm57Y29tcGlsZTpmdW5jdGlvbihhLGIpe3ZhciBjPWYodCk7cmV0dXJuIGZ1bmN0aW9uKGEsYixkLGYpe2Z1bmN0aW9uIGooKXtNLmlzT3Blbj9xKCk6bSgpfWZ1bmN0aW9uIG0oKXsoIUx8fGEuJGV2YWwoZFtrK1xcXCJFbmFibGVcXFwiXSkpJiYodSgpLHgoKSxNLnBvcHVwRGVsYXk/R3x8KEc9ZyhyLE0ucG9wdXBEZWxheSwhMSkpOnIoKSl9ZnVuY3Rpb24gcSgpe3MoKSxNLnBvcHVwQ2xvc2VEZWxheT9IfHwoSD1nKHQsTS5wb3B1cENsb3NlRGVsYXksITEpKTp0KCl9ZnVuY3Rpb24gcigpe3JldHVybiBzKCksdSgpLE0uY29udGVudD8odigpLHZvaWQgTS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7TS5pc09wZW49ITAseSghMCksUigpfSkpOmFuZ3VsYXIubm9vcH1mdW5jdGlvbiBzKCl7RyYmKGcuY2FuY2VsKEcpLEc9bnVsbCksSSYmKGcuY2FuY2VsKEkpLEk9bnVsbCl9ZnVuY3Rpb24gdCgpe00mJk0uJGV2YWxBc3luYyhmdW5jdGlvbigpe00mJihNLmlzT3Blbj0hMSx5KCExKSxNLmFuaW1hdGlvbj9GfHwoRj1nKHcsMTUwLCExKSk6dygpKX0pfWZ1bmN0aW9uIHUoKXtIJiYoZy5jYW5jZWwoSCksSD1udWxsKSxGJiYoZy5jYW5jZWwoRiksRj1udWxsKX1mdW5jdGlvbiB2KCl7RHx8KEU9TS4kbmV3KCksRD1jKEUsZnVuY3Rpb24oYSl7Sj9oLmZpbmQoXFxcImJvZHlcXFwiKS5hcHBlbmQoYSk6Yi5hZnRlcihhKX0pLHooKSl9ZnVuY3Rpb24gdygpe3MoKSx1KCksQSgpLEQmJihELnJlbW92ZSgpLEQ9bnVsbCksRSYmKEUuJGRlc3Ryb3koKSxFPW51bGwpfWZ1bmN0aW9uIHgoKXtNLnRpdGxlPWRbaytcXFwiVGl0bGVcXFwiXSxQP00uY29udGVudD1QKGEpOk0uY29udGVudD1kW2VdLE0ucG9wdXBDbGFzcz1kW2srXFxcIkNsYXNzXFxcIl0sTS5wbGFjZW1lbnQ9YW5ndWxhci5pc0RlZmluZWQoZFtrK1xcXCJQbGFjZW1lbnRcXFwiXSk/ZFtrK1xcXCJQbGFjZW1lbnRcXFwiXTpuLnBsYWNlbWVudDt2YXIgYj1wYXJzZUludChkW2srXFxcIlBvcHVwRGVsYXlcXFwiXSwxMCksYz1wYXJzZUludChkW2srXFxcIlBvcHVwQ2xvc2VEZWxheVxcXCJdLDEwKTtNLnBvcHVwRGVsYXk9aXNOYU4oYik/bi5wb3B1cERlbGF5OmIsTS5wb3B1cENsb3NlRGVsYXk9aXNOYU4oYyk/bi5wb3B1cENsb3NlRGVsYXk6Y31mdW5jdGlvbiB5KGIpe08mJmFuZ3VsYXIuaXNGdW5jdGlvbihPLmFzc2lnbikmJk8uYXNzaWduKGEsYil9ZnVuY3Rpb24geigpe1EubGVuZ3RoPTAsUD8oUS5wdXNoKGEuJHdhdGNoKFAsZnVuY3Rpb24oYSl7TS5jb250ZW50PWEsIWEmJk0uaXNPcGVuJiZ0KCl9KSksUS5wdXNoKEUuJHdhdGNoKGZ1bmN0aW9uKCl7Tnx8KE49ITAsRS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKXtOPSExLE0mJk0uaXNPcGVuJiZSKCl9KSl9KSkpOlEucHVzaChkLiRvYnNlcnZlKGUsZnVuY3Rpb24oYSl7TS5jb250ZW50PWEsIWEmJk0uaXNPcGVuP3QoKTpSKCl9KSksUS5wdXNoKGQuJG9ic2VydmUoaytcXFwiVGl0bGVcXFwiLGZ1bmN0aW9uKGEpe00udGl0bGU9YSxNLmlzT3BlbiYmUigpfSkpLFEucHVzaChkLiRvYnNlcnZlKGsrXFxcIlBsYWNlbWVudFxcXCIsZnVuY3Rpb24oYSl7TS5wbGFjZW1lbnQ9YT9hOm4ucGxhY2VtZW50LE0uaXNPcGVuJiZSKCl9KSl9ZnVuY3Rpb24gQSgpe1EubGVuZ3RoJiYoYW5ndWxhci5mb3JFYWNoKFEsZnVuY3Rpb24oYSl7YSgpfSksUS5sZW5ndGg9MCl9ZnVuY3Rpb24gQihhKXtNJiZNLmlzT3BlbiYmRCYmKGJbMF0uY29udGFpbnMoYS50YXJnZXQpfHxEWzBdLmNvbnRhaW5zKGEudGFyZ2V0KXx8cSgpKX1mdW5jdGlvbiBDKCl7dmFyIGE9ZFtrK1xcXCJUcmlnZ2VyXFxcIl07UygpLEs9cChhKSxcXFwibm9uZVxcXCIhPT1LLnNob3cmJksuc2hvdy5mb3JFYWNoKGZ1bmN0aW9uKGEsYyl7XFxcIm91dHNpZGVDbGlja1xcXCI9PT1hPyhiLm9uKFxcXCJjbGlja1xcXCIsaiksaC5vbihcXFwiY2xpY2tcXFwiLEIpKTphPT09Sy5oaWRlW2NdP2Iub24oYSxqKTphJiYoYi5vbihhLG0pLGIub24oSy5oaWRlW2NdLHEpKSxiLm9uKFxcXCJrZXlwcmVzc1xcXCIsZnVuY3Rpb24oYSl7Mjc9PT1hLndoaWNoJiZxKCl9KX0pfXZhciBELEUsRixHLEgsSSxKPWFuZ3VsYXIuaXNEZWZpbmVkKG4uYXBwZW5kVG9Cb2R5KT9uLmFwcGVuZFRvQm9keTohMSxLPXAodm9pZCAwKSxMPWFuZ3VsYXIuaXNEZWZpbmVkKGRbaytcXFwiRW5hYmxlXFxcIl0pLE09YS4kbmV3KCEwKSxOPSExLE89YW5ndWxhci5pc0RlZmluZWQoZFtrK1xcXCJJc09wZW5cXFwiXSk/bChkW2srXFxcIklzT3BlblxcXCJdKTohMSxQPW4udXNlQ29udGVudEV4cD9sKGRbZV0pOiExLFE9W10sUj1mdW5jdGlvbigpe0QmJkQuaHRtbCgpJiYoSXx8KEk9ZyhmdW5jdGlvbigpe0QuY3NzKHt0b3A6MCxsZWZ0OjB9KTt2YXIgYT1pLnBvc2l0aW9uRWxlbWVudHMoYixELE0ucGxhY2VtZW50LEopO0QuY3NzKHt0b3A6YS50b3ArXFxcInB4XFxcIixsZWZ0OmEubGVmdCtcXFwicHhcXFwiLHZpc2liaWxpdHk6XFxcInZpc2libGVcXFwifSksbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCYmRC5yZW1vdmVDbGFzcyhcXFwidG9wIGJvdHRvbSBsZWZ0IHJpZ2h0XFxcIiksRC5yZW1vdmVDbGFzcyhuLnBsYWNlbWVudENsYXNzUHJlZml4K1xcXCJ0b3AgXFxcIituLnBsYWNlbWVudENsYXNzUHJlZml4K1xcXCJ0b3AtbGVmdCBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcInRvcC1yaWdodCBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcImJvdHRvbSBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcImJvdHRvbS1sZWZ0IFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwiYm90dG9tLXJpZ2h0IFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwibGVmdCBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcImxlZnQtdG9wIFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwibGVmdC1ib3R0b20gXFxcIituLnBsYWNlbWVudENsYXNzUHJlZml4K1xcXCJyaWdodCBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcInJpZ2h0LXRvcCBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcInJpZ2h0LWJvdHRvbVxcXCIpO3ZhciBjPWEucGxhY2VtZW50LnNwbGl0KFxcXCItXFxcIik7RC5hZGRDbGFzcyhjWzBdK1xcXCIgXFxcIituLnBsYWNlbWVudENsYXNzUHJlZml4K2EucGxhY2VtZW50KSxpLnBvc2l0aW9uQXJyb3coRCxhLnBsYWNlbWVudCksST1udWxsfSwwLCExKSkpfTtNLm9yaWdTY29wZT1hLE0uaXNPcGVuPSExLG8uYWRkKE0se2Nsb3NlOnR9KSxNLmNvbnRlbnRFeHA9ZnVuY3Rpb24oKXtyZXR1cm4gTS5jb250ZW50fSxkLiRvYnNlcnZlKFxcXCJkaXNhYmxlZFxcXCIsZnVuY3Rpb24oYSl7YSYmcygpLGEmJk0uaXNPcGVuJiZ0KCl9KSxPJiZhLiR3YXRjaChPLGZ1bmN0aW9uKGEpe00mJiFhPT09TS5pc09wZW4mJmooKX0pO3ZhciBTPWZ1bmN0aW9uKCl7Sy5zaG93LmZvckVhY2goZnVuY3Rpb24oYSl7XFxcIm91dHNpZGVDbGlja1xcXCI9PT1hP2Iub2ZmKFxcXCJjbGlja1xcXCIsaik6KGIub2ZmKGEsbSksYi5vZmYoYSxqKSl9KSxLLmhpZGUuZm9yRWFjaChmdW5jdGlvbihhKXtcXFwib3V0c2lkZUNsaWNrXFxcIj09PWE/aC5vZmYoXFxcImNsaWNrXFxcIixCKTpiLm9mZihhLHEpfSl9O0MoKTt2YXIgVD1hLiRldmFsKGRbaytcXFwiQW5pbWF0aW9uXFxcIl0pO00uYW5pbWF0aW9uPWFuZ3VsYXIuaXNEZWZpbmVkKFQpPyEhVDpuLmFuaW1hdGlvbjt2YXIgVSxWPWsrXFxcIkFwcGVuZFRvQm9keVxcXCI7VT1WIGluIGQmJnZvaWQgMD09PWRbVl0/ITA6YS4kZXZhbChkW1ZdKSxKPWFuZ3VsYXIuaXNEZWZpbmVkKFUpP1U6SixKJiZhLiRvbihcXFwiJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc1xcXCIsZnVuY3Rpb24oKXtNLmlzT3BlbiYmdCgpfSksYS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe1MoKSx3KCksby5yZW1vdmUoTSksTT1udWxsfSl9fX19fV19KS5kaXJlY3RpdmUoXFxcInVpYlRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGVcXFwiLFtcXFwiJGFuaW1hdGVcXFwiLFxcXCIkc2NlXFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkdGVtcGxhdGVSZXF1ZXN0XFxcIixmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm57bGluazpmdW5jdGlvbihlLGYsZyl7dmFyIGgsaSxqLGs9ZS4kZXZhbChnLnRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGVTY29wZSksbD0wLG09ZnVuY3Rpb24oKXtpJiYoaS5yZW1vdmUoKSxpPW51bGwpLGgmJihoLiRkZXN0cm95KCksaD1udWxsKSxqJiYoYS5sZWF2ZShqKS50aGVuKGZ1bmN0aW9uKCl7aT1udWxsfSksaT1qLGo9bnVsbCl9O2UuJHdhdGNoKGIucGFyc2VBc1Jlc291cmNlVXJsKGcudWliVG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZSksZnVuY3Rpb24oYil7dmFyIGc9KytsO2I/KGQoYiwhMCkudGhlbihmdW5jdGlvbihkKXtpZihnPT09bCl7dmFyIGU9ay4kbmV3KCksaT1kLG49YyhpKShlLGZ1bmN0aW9uKGIpe20oKSxhLmVudGVyKGIsZil9KTtoPWUsaj1uLGguJGVtaXQoXFxcIiRpbmNsdWRlQ29udGVudExvYWRlZFxcXCIsYil9fSxmdW5jdGlvbigpe2c9PT1sJiYobSgpLGUuJGVtaXQoXFxcIiRpbmNsdWRlQ29udGVudEVycm9yXFxcIixiKSl9KSxlLiRlbWl0KFxcXCIkaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWRcXFwiLGIpKTptKCl9KSxlLiRvbihcXFwiJGRlc3Ryb3lcXFwiLG0pfX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJUb29sdGlwQ2xhc3Nlc1xcXCIsW1xcXCIkdWliUG9zaXRpb25cXFwiLGZ1bmN0aW9uKGEpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIsbGluazpmdW5jdGlvbihiLGMsZCl7aWYoYi5wbGFjZW1lbnQpe3ZhciBlPWEucGFyc2VQbGFjZW1lbnQoYi5wbGFjZW1lbnQpO2MuYWRkQ2xhc3MoZVswXSl9ZWxzZSBjLmFkZENsYXNzKFxcXCJ0b3BcXFwiKTtiLnBvcHVwQ2xhc3MmJmMuYWRkQ2xhc3MoYi5wb3B1cENsYXNzKSxiLmFuaW1hdGlvbigpJiZjLmFkZENsYXNzKGQudG9vbHRpcEFuaW1hdGlvbkNsYXNzKX19fV0pLmRpcmVjdGl2ZShcXFwidWliVG9vbHRpcFBvcHVwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHNjb3BlOntjb250ZW50OlxcXCJAXFxcIixwbGFjZW1lbnQ6XFxcIkBcXFwiLHBvcHVwQ2xhc3M6XFxcIkBcXFwiLGFuaW1hdGlvbjpcXFwiJlxcXCIsaXNPcGVuOlxcXCImXFxcIn0sdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFxcXCJ9fSkuZGlyZWN0aXZlKFxcXCJ1aWJUb29sdGlwXFxcIixbXFxcIiR1aWJUb29sdGlwXFxcIixmdW5jdGlvbihhKXtyZXR1cm4gYShcXFwidWliVG9vbHRpcFxcXCIsXFxcInRvb2x0aXBcXFwiLFxcXCJtb3VzZWVudGVyXFxcIil9XSkuZGlyZWN0aXZlKFxcXCJ1aWJUb29sdGlwVGVtcGxhdGVQb3B1cFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCxzY29wZTp7Y29udGVudEV4cDpcXFwiJlxcXCIscGxhY2VtZW50OlxcXCJAXFxcIixwb3B1cENsYXNzOlxcXCJAXFxcIixhbmltYXRpb246XFxcIiZcXFwiLGlzT3BlbjpcXFwiJlxcXCIsb3JpZ2luU2NvcGU6XFxcIiZcXFwifSx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXFxcIn19KS5kaXJlY3RpdmUoXFxcInVpYlRvb2x0aXBUZW1wbGF0ZVxcXCIsW1xcXCIkdWliVG9vbHRpcFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEoXFxcInVpYlRvb2x0aXBUZW1wbGF0ZVxcXCIsXFxcInRvb2x0aXBcXFwiLFxcXCJtb3VzZWVudGVyXFxcIix7dXNlQ29udGVudEV4cDohMH0pfV0pLmRpcmVjdGl2ZShcXFwidWliVG9vbHRpcEh0bWxQb3B1cFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCxzY29wZTp7Y29udGVudEV4cDpcXFwiJlxcXCIscGxhY2VtZW50OlxcXCJAXFxcIixwb3B1cENsYXNzOlxcXCJAXFxcIixhbmltYXRpb246XFxcIiZcXFwiLGlzT3BlbjpcXFwiJlxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFxcXCJ9fSkuZGlyZWN0aXZlKFxcXCJ1aWJUb29sdGlwSHRtbFxcXCIsW1xcXCIkdWliVG9vbHRpcFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEoXFxcInVpYlRvb2x0aXBIdG1sXFxcIixcXFwidG9vbHRpcFxcXCIsXFxcIm1vdXNlZW50ZXJcXFwiLHt1c2VDb250ZW50RXhwOiEwfSl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5wb3BvdmVyXFxcIixbXFxcInVpLmJvb3RzdHJhcC50b29sdGlwXFxcIl0pLmRpcmVjdGl2ZShcXFwidWliUG9wb3ZlclRlbXBsYXRlUG9wdXBcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsc2NvcGU6e3RpdGxlOlxcXCJAXFxcIixjb250ZW50RXhwOlxcXCImXFxcIixwbGFjZW1lbnQ6XFxcIkBcXFwiLHBvcHVwQ2xhc3M6XFxcIkBcXFwiLGFuaW1hdGlvbjpcXFwiJlxcXCIsaXNPcGVuOlxcXCImXFxcIixvcmlnaW5TY29wZTpcXFwiJlxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcXFwifX0pLmRpcmVjdGl2ZShcXFwidWliUG9wb3ZlclRlbXBsYXRlXFxcIixbXFxcIiR1aWJUb29sdGlwXFxcIixmdW5jdGlvbihhKXtcXG5yZXR1cm4gYShcXFwidWliUG9wb3ZlclRlbXBsYXRlXFxcIixcXFwicG9wb3ZlclxcXCIsXFxcImNsaWNrXFxcIix7dXNlQ29udGVudEV4cDohMH0pfV0pLmRpcmVjdGl2ZShcXFwidWliUG9wb3Zlckh0bWxQb3B1cFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCxzY29wZTp7Y29udGVudEV4cDpcXFwiJlxcXCIsdGl0bGU6XFxcIkBcXFwiLHBsYWNlbWVudDpcXFwiQFxcXCIscG9wdXBDbGFzczpcXFwiQFxcXCIsYW5pbWF0aW9uOlxcXCImXFxcIixpc09wZW46XFxcIiZcXFwifSx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWxcXFwifX0pLmRpcmVjdGl2ZShcXFwidWliUG9wb3Zlckh0bWxcXFwiLFtcXFwiJHVpYlRvb2x0aXBcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhKFxcXCJ1aWJQb3BvdmVySHRtbFxcXCIsXFxcInBvcG92ZXJcXFwiLFxcXCJjbGlja1xcXCIse3VzZUNvbnRlbnRFeHA6ITB9KX1dKS5kaXJlY3RpdmUoXFxcInVpYlBvcG92ZXJQb3B1cFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCxzY29wZTp7dGl0bGU6XFxcIkBcXFwiLGNvbnRlbnQ6XFxcIkBcXFwiLHBsYWNlbWVudDpcXFwiQFxcXCIscG9wdXBDbGFzczpcXFwiQFxcXCIsYW5pbWF0aW9uOlxcXCImXFxcIixpc09wZW46XFxcIiZcXFwifSx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXFxcIn19KS5kaXJlY3RpdmUoXFxcInVpYlBvcG92ZXJcXFwiLFtcXFwiJHVpYlRvb2x0aXBcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhKFxcXCJ1aWJQb3BvdmVyXFxcIixcXFwicG9wb3ZlclxcXCIsXFxcImNsaWNrXFxcIil9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5wcm9ncmVzc2JhclxcXCIsW10pLmNvbnN0YW50KFxcXCJ1aWJQcm9ncmVzc0NvbmZpZ1xcXCIse2FuaW1hdGU6ITAsbWF4OjEwMH0pLmNvbnRyb2xsZXIoXFxcIlVpYlByb2dyZXNzQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCJ1aWJQcm9ncmVzc0NvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMsZT1hbmd1bGFyLmlzRGVmaW5lZChiLmFuaW1hdGUpP2EuJHBhcmVudC4kZXZhbChiLmFuaW1hdGUpOmMuYW5pbWF0ZTt0aGlzLmJhcnM9W10sYS5tYXg9YW5ndWxhci5pc0RlZmluZWQoYS5tYXgpP2EubWF4OmMubWF4LHRoaXMuYWRkQmFyPWZ1bmN0aW9uKGIsYyxmKXtlfHxjLmNzcyh7dHJhbnNpdGlvbjpcXFwibm9uZVxcXCJ9KSx0aGlzLmJhcnMucHVzaChiKSxiLm1heD1hLm1heCxiLnRpdGxlPWYmJmFuZ3VsYXIuaXNEZWZpbmVkKGYudGl0bGUpP2YudGl0bGU6XFxcInByb2dyZXNzYmFyXFxcIixiLiR3YXRjaChcXFwidmFsdWVcXFwiLGZ1bmN0aW9uKGEpe2IucmVjYWxjdWxhdGVQZXJjZW50YWdlKCl9KSxiLnJlY2FsY3VsYXRlUGVyY2VudGFnZT1mdW5jdGlvbigpe3ZhciBhPWQuYmFycy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5wZXJjZW50PSsoMTAwKmIudmFsdWUvYi5tYXgpLnRvRml4ZWQoMiksYStiLnBlcmNlbnR9LDApO2E+MTAwJiYoYi5wZXJjZW50LT1hLTEwMCl9LGIuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtjPW51bGwsZC5yZW1vdmVCYXIoYil9KX0sdGhpcy5yZW1vdmVCYXI9ZnVuY3Rpb24oYSl7dGhpcy5iYXJzLnNwbGljZSh0aGlzLmJhcnMuaW5kZXhPZihhKSwxKSx0aGlzLmJhcnMuZm9yRWFjaChmdW5jdGlvbihhKXthLnJlY2FsY3VsYXRlUGVyY2VudGFnZSgpfSl9LGEuJHdhdGNoKFxcXCJtYXhcXFwiLGZ1bmN0aW9uKGIpe2QuYmFycy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IubWF4PWEubWF4LGIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCl9KX0pfV0pLmRpcmVjdGl2ZShcXFwidWliUHJvZ3Jlc3NcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsdHJhbnNjbHVkZTohMCxjb250cm9sbGVyOlxcXCJVaWJQcm9ncmVzc0NvbnRyb2xsZXJcXFwiLHJlcXVpcmU6XFxcInVpYlByb2dyZXNzXFxcIixzY29wZTp7bWF4OlxcXCI9P1xcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFxcXCJ9fSkuZGlyZWN0aXZlKFxcXCJ1aWJCYXJcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsdHJhbnNjbHVkZTohMCxyZXF1aXJlOlxcXCJedWliUHJvZ3Jlc3NcXFwiLHNjb3BlOnt2YWx1ZTpcXFwiPVxcXCIsdHlwZTpcXFwiQFxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7ZC5hZGRCYXIoYSxiLGMpfX19KS5kaXJlY3RpdmUoXFxcInVpYlByb2dyZXNzYmFyXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHRyYW5zY2x1ZGU6ITAsY29udHJvbGxlcjpcXFwiVWliUHJvZ3Jlc3NDb250cm9sbGVyXFxcIixzY29wZTp7dmFsdWU6XFxcIj1cXFwiLG1heDpcXFwiPT9cXFwiLHR5cGU6XFxcIkBcXFwifSx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7ZC5hZGRCYXIoYSxhbmd1bGFyLmVsZW1lbnQoYi5jaGlsZHJlbigpWzBdKSx7dGl0bGU6Yy50aXRsZX0pfX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnJhdGluZ1xcXCIsW10pLmNvbnN0YW50KFxcXCJ1aWJSYXRpbmdDb25maWdcXFwiLHttYXg6NSxzdGF0ZU9uOm51bGwsc3RhdGVPZmY6bnVsbCx0aXRsZXM6W1xcXCJvbmVcXFwiLFxcXCJ0d29cXFwiLFxcXCJ0aHJlZVxcXCIsXFxcImZvdXJcXFwiLFxcXCJmaXZlXFxcIl19KS5jb250cm9sbGVyKFxcXCJVaWJSYXRpbmdDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcInVpYlJhdGluZ0NvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXskc2V0Vmlld1ZhbHVlOmFuZ3VsYXIubm9vcH07dGhpcy5pbml0PWZ1bmN0aW9uKGUpe2Q9ZSxkLiRyZW5kZXI9dGhpcy5yZW5kZXIsZC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGEpe3JldHVybiBhbmd1bGFyLmlzTnVtYmVyKGEpJiZhPDwwIT09YSYmKGE9TWF0aC5yb3VuZChhKSksYX0pLHRoaXMuc3RhdGVPbj1hbmd1bGFyLmlzRGVmaW5lZChiLnN0YXRlT24pP2EuJHBhcmVudC4kZXZhbChiLnN0YXRlT24pOmMuc3RhdGVPbix0aGlzLnN0YXRlT2ZmPWFuZ3VsYXIuaXNEZWZpbmVkKGIuc3RhdGVPZmYpP2EuJHBhcmVudC4kZXZhbChiLnN0YXRlT2ZmKTpjLnN0YXRlT2ZmO3ZhciBmPWFuZ3VsYXIuaXNEZWZpbmVkKGIudGl0bGVzKT9hLiRwYXJlbnQuJGV2YWwoYi50aXRsZXMpOmMudGl0bGVzO3RoaXMudGl0bGVzPWFuZ3VsYXIuaXNBcnJheShmKSYmZi5sZW5ndGg+MD9mOmMudGl0bGVzO3ZhciBnPWFuZ3VsYXIuaXNEZWZpbmVkKGIucmF0aW5nU3RhdGVzKT9hLiRwYXJlbnQuJGV2YWwoYi5yYXRpbmdTdGF0ZXMpOm5ldyBBcnJheShhbmd1bGFyLmlzRGVmaW5lZChiLm1heCk/YS4kcGFyZW50LiRldmFsKGIubWF4KTpjLm1heCk7YS5yYW5nZT10aGlzLmJ1aWxkVGVtcGxhdGVPYmplY3RzKGcpfSx0aGlzLmJ1aWxkVGVtcGxhdGVPYmplY3RzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9YS5sZW5ndGg7Yz5iO2IrKylhW2JdPWFuZ3VsYXIuZXh0ZW5kKHtpbmRleDpifSx7c3RhdGVPbjp0aGlzLnN0YXRlT24sc3RhdGVPZmY6dGhpcy5zdGF0ZU9mZix0aXRsZTp0aGlzLmdldFRpdGxlKGIpfSxhW2JdKTtyZXR1cm4gYX0sdGhpcy5nZXRUaXRsZT1mdW5jdGlvbihhKXtyZXR1cm4gYT49dGhpcy50aXRsZXMubGVuZ3RoP2ErMTp0aGlzLnRpdGxlc1thXX0sYS5yYXRlPWZ1bmN0aW9uKGIpeyFhLnJlYWRvbmx5JiZiPj0wJiZiPD1hLnJhbmdlLmxlbmd0aCYmKGQuJHNldFZpZXdWYWx1ZShkLiR2aWV3VmFsdWU9PT1iPzA6YiksZC4kcmVuZGVyKCkpfSxhLmVudGVyPWZ1bmN0aW9uKGIpe2EucmVhZG9ubHl8fChhLnZhbHVlPWIpLGEub25Ib3Zlcih7dmFsdWU6Yn0pfSxhLnJlc2V0PWZ1bmN0aW9uKCl7YS52YWx1ZT1kLiR2aWV3VmFsdWUsYS5vbkxlYXZlKCl9LGEub25LZXlkb3duPWZ1bmN0aW9uKGIpey8oMzd8Mzh8Mzl8NDApLy50ZXN0KGIud2hpY2gpJiYoYi5wcmV2ZW50RGVmYXVsdCgpLGIuc3RvcFByb3BhZ2F0aW9uKCksYS5yYXRlKGEudmFsdWUrKDM4PT09Yi53aGljaHx8Mzk9PT1iLndoaWNoPzE6LTEpKSl9LHRoaXMucmVuZGVyPWZ1bmN0aW9uKCl7YS52YWx1ZT1kLiR2aWV3VmFsdWV9fV0pLmRpcmVjdGl2ZShcXFwidWliUmF0aW5nXFxcIixmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOltcXFwidWliUmF0aW5nXFxcIixcXFwibmdNb2RlbFxcXCJdLHNjb3BlOntyZWFkb25seTpcXFwiPT9cXFwiLG9uSG92ZXI6XFxcIiZcXFwiLG9uTGVhdmU6XFxcIiZcXFwifSxjb250cm9sbGVyOlxcXCJVaWJSYXRpbmdDb250cm9sbGVyXFxcIix0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFxcXCIscmVwbGFjZTohMCxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF0sZj1kWzFdO2UuaW5pdChmKX19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC50YWJzXFxcIixbXSkuY29udHJvbGxlcihcXFwiVWliVGFic2V0Q29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLnRhYnM9YS50YWJzPVtdO2Iuc2VsZWN0PWZ1bmN0aW9uKGEpe2FuZ3VsYXIuZm9yRWFjaChjLGZ1bmN0aW9uKGIpe2IuYWN0aXZlJiZiIT09YSYmKGIuYWN0aXZlPSExLGIub25EZXNlbGVjdCgpLGEuc2VsZWN0Q2FsbGVkPSExKX0pLGEuYWN0aXZlPSEwLGEuc2VsZWN0Q2FsbGVkfHwoYS5vblNlbGVjdCgpLGEuc2VsZWN0Q2FsbGVkPSEwKX0sYi5hZGRUYWI9ZnVuY3Rpb24oYSl7Yy5wdXNoKGEpLDE9PT1jLmxlbmd0aCYmYS5hY3RpdmUhPT0hMT9hLmFjdGl2ZT0hMDphLmFjdGl2ZT9iLnNlbGVjdChhKTphLmFjdGl2ZT0hMX0sYi5yZW1vdmVUYWI9ZnVuY3Rpb24oYSl7dmFyIGU9Yy5pbmRleE9mKGEpO2lmKGEuYWN0aXZlJiZjLmxlbmd0aD4xJiYhZCl7dmFyIGY9ZT09PWMubGVuZ3RoLTE/ZS0xOmUrMTtiLnNlbGVjdChjW2ZdKX1jLnNwbGljZShlLDEpfTt2YXIgZDthLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7ZD0hMH0pfV0pLmRpcmVjdGl2ZShcXFwidWliVGFic2V0XFxcIixmdW5jdGlvbigpe3JldHVybnt0cmFuc2NsdWRlOiEwLHJlcGxhY2U6ITAsc2NvcGU6e3R5cGU6XFxcIkBcXFwifSxjb250cm9sbGVyOlxcXCJVaWJUYWJzZXRDb250cm9sbGVyXFxcIix0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMpe2EudmVydGljYWw9YW5ndWxhci5pc0RlZmluZWQoYy52ZXJ0aWNhbCk/YS4kcGFyZW50LiRldmFsKGMudmVydGljYWwpOiExLGEuanVzdGlmaWVkPWFuZ3VsYXIuaXNEZWZpbmVkKGMuanVzdGlmaWVkKT9hLiRwYXJlbnQuJGV2YWwoYy5qdXN0aWZpZWQpOiExfX19KS5kaXJlY3RpdmUoXFxcInVpYlRhYlxcXCIsW1xcXCIkcGFyc2VcXFwiLGZ1bmN0aW9uKGEpe3JldHVybntyZXF1aXJlOlxcXCJedWliVGFic2V0XFxcIixyZXBsYWNlOiEwLHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFxcXCIsdHJhbnNjbHVkZTohMCxzY29wZTp7YWN0aXZlOlxcXCI9P1xcXCIsaGVhZGluZzpcXFwiQFxcXCIsb25TZWxlY3Q6XFxcIiZzZWxlY3RcXFwiLG9uRGVzZWxlY3Q6XFxcIiZkZXNlbGVjdFxcXCJ9LGNvbnRyb2xsZXI6ZnVuY3Rpb24oKXt9LGNvbnRyb2xsZXJBczpcXFwidGFiXFxcIixsaW5rOmZ1bmN0aW9uKGIsYyxkLGUsZil7Yi4kd2F0Y2goXFxcImFjdGl2ZVxcXCIsZnVuY3Rpb24oYSl7YSYmZS5zZWxlY3QoYil9KSxiLmRpc2FibGVkPSExLGQuZGlzYWJsZSYmYi4kcGFyZW50LiR3YXRjaChhKGQuZGlzYWJsZSksZnVuY3Rpb24oYSl7Yi5kaXNhYmxlZD0hIWF9KSxiLnNlbGVjdD1mdW5jdGlvbigpe2IuZGlzYWJsZWR8fChiLmFjdGl2ZT0hMCl9LGUuYWRkVGFiKGIpLGIuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtlLnJlbW92ZVRhYihiKX0pLGIuJHRyYW5zY2x1ZGVGbj1mfX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJUYWJIZWFkaW5nVHJhbnNjbHVkZVxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVzdHJpY3Q6XFxcIkFcXFwiLHJlcXVpcmU6XFxcIl51aWJUYWJcXFwiLGxpbms6ZnVuY3Rpb24oYSxiKXthLiR3YXRjaChcXFwiaGVhZGluZ0VsZW1lbnRcXFwiLGZ1bmN0aW9uKGEpe2EmJihiLmh0bWwoXFxcIlxcXCIpLGIuYXBwZW5kKGEpKX0pfX19KS5kaXJlY3RpdmUoXFxcInVpYlRhYkNvbnRlbnRUcmFuc2NsdWRlXFxcIixmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7cmV0dXJuIGEudGFnTmFtZSYmKGEuaGFzQXR0cmlidXRlKFxcXCJ1aWItdGFiLWhlYWRpbmdcXFwiKXx8YS5oYXNBdHRyaWJ1dGUoXFxcImRhdGEtdWliLXRhYi1oZWFkaW5nXFxcIil8fGEuaGFzQXR0cmlidXRlKFxcXCJ4LXVpYi10YWItaGVhZGluZ1xcXCIpfHxcXFwidWliLXRhYi1oZWFkaW5nXFxcIj09PWEudGFnTmFtZS50b0xvd2VyQ2FzZSgpfHxcXFwiZGF0YS11aWItdGFiLWhlYWRpbmdcXFwiPT09YS50YWdOYW1lLnRvTG93ZXJDYXNlKCl8fFxcXCJ4LXVpYi10YWItaGVhZGluZ1xcXCI9PT1hLnRhZ05hbWUudG9Mb3dlckNhc2UoKSl9cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixyZXF1aXJlOlxcXCJedWliVGFic2V0XFxcIixsaW5rOmZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1iLiRldmFsKGQudWliVGFiQ29udGVudFRyYW5zY2x1ZGUpO2UuJHRyYW5zY2x1ZGVGbihlLiRwYXJlbnQsZnVuY3Rpb24oYil7YW5ndWxhci5mb3JFYWNoKGIsZnVuY3Rpb24oYil7YShiKT9lLmhlYWRpbmdFbGVtZW50PWI6Yy5hcHBlbmQoYil9KX0pfX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnRpbWVwaWNrZXJcXFwiLFtdKS5jb25zdGFudChcXFwidWliVGltZXBpY2tlckNvbmZpZ1xcXCIse2hvdXJTdGVwOjEsbWludXRlU3RlcDoxLHNlY29uZFN0ZXA6MSxzaG93TWVyaWRpYW46ITAsc2hvd1NlY29uZHM6ITEsbWVyaWRpYW5zOm51bGwscmVhZG9ubHlJbnB1dDohMSxtb3VzZXdoZWVsOiEwLGFycm93a2V5czohMCxzaG93U3Bpbm5lcnM6ITAsdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFxcXCJ9KS5jb250cm9sbGVyKFxcXCJVaWJUaW1lcGlja2VyQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkZWxlbWVudFxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcIiRwYXJzZVxcXCIsXFxcIiRsb2dcXFwiLFxcXCIkbG9jYWxlXFxcIixcXFwidWliVGltZXBpY2tlckNvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7ZnVuY3Rpb24gaCgpe3ZhciBiPSthLmhvdXJzLGM9YS5zaG93TWVyaWRpYW4/Yj4wJiYxMz5iOmI+PTAmJjI0PmI7cmV0dXJuIGM/KGEuc2hvd01lcmlkaWFuJiYoMTI9PT1iJiYoYj0wKSxhLm1lcmlkaWFuPT09dVsxXSYmKGIrPTEyKSksYik6dm9pZCAwfWZ1bmN0aW9uIGkoKXt2YXIgYj0rYS5taW51dGVzO3JldHVybiBiPj0wJiY2MD5iP2I6dm9pZCAwfWZ1bmN0aW9uIGooKXt2YXIgYj0rYS5zZWNvbmRzO3JldHVybiBiPj0wJiY2MD5iP2I6dm9pZCAwfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIG51bGw9PT1hP1xcXCJcXFwiOmFuZ3VsYXIuaXNEZWZpbmVkKGEpJiZhLnRvU3RyaW5nKCkubGVuZ3RoPDI/XFxcIjBcXFwiK2E6YS50b1N0cmluZygpfWZ1bmN0aW9uIGwoYSl7bSgpLHQuJHNldFZpZXdWYWx1ZShuZXcgRGF0ZShyKSksbihhKX1mdW5jdGlvbiBtKCl7dC4kc2V0VmFsaWRpdHkoXFxcInRpbWVcXFwiLCEwKSxhLmludmFsaWRIb3Vycz0hMSxhLmludmFsaWRNaW51dGVzPSExLGEuaW52YWxpZFNlY29uZHM9ITF9ZnVuY3Rpb24gbihiKXtpZih0LiRtb2RlbFZhbHVlKXt2YXIgYz1yLmdldEhvdXJzKCksZD1yLmdldE1pbnV0ZXMoKSxlPXIuZ2V0U2Vjb25kcygpO2Euc2hvd01lcmlkaWFuJiYoYz0wPT09Y3x8MTI9PT1jPzEyOmMlMTIpLGEuaG91cnM9XFxcImhcXFwiPT09Yj9jOmsoYyksXFxcIm1cXFwiIT09YiYmKGEubWludXRlcz1rKGQpKSxhLm1lcmlkaWFuPXIuZ2V0SG91cnMoKTwxMj91WzBdOnVbMV0sXFxcInNcXFwiIT09YiYmKGEuc2Vjb25kcz1rKGUpKSxhLm1lcmlkaWFuPXIuZ2V0SG91cnMoKTwxMj91WzBdOnVbMV19ZWxzZSBhLmhvdXJzPW51bGwsYS5taW51dGVzPW51bGwsYS5zZWNvbmRzPW51bGwsYS5tZXJpZGlhbj11WzBdfWZ1bmN0aW9uIG8oYSl7cj1xKHIsYSksbCgpfWZ1bmN0aW9uIHAoYSxiKXtyZXR1cm4gcShhLDYwKmIpfWZ1bmN0aW9uIHEoYSxiKXt2YXIgYz1uZXcgRGF0ZShhLmdldFRpbWUoKSsxZTMqYiksZD1uZXcgRGF0ZShhKTtyZXR1cm4gZC5zZXRIb3VycyhjLmdldEhvdXJzKCksYy5nZXRNaW51dGVzKCksYy5nZXRTZWNvbmRzKCkpLGR9dmFyIHI9bmV3IERhdGUscz1bXSx0PXskc2V0Vmlld1ZhbHVlOmFuZ3VsYXIubm9vcH0sdT1hbmd1bGFyLmlzRGVmaW5lZChjLm1lcmlkaWFucyk/YS4kcGFyZW50LiRldmFsKGMubWVyaWRpYW5zKTpnLm1lcmlkaWFuc3x8Zi5EQVRFVElNRV9GT1JNQVRTLkFNUE1TO2EudGFiaW5kZXg9YW5ndWxhci5pc0RlZmluZWQoYy50YWJpbmRleCk/Yy50YWJpbmRleDowLGIucmVtb3ZlQXR0cihcXFwidGFiaW5kZXhcXFwiKSx0aGlzLmluaXQ9ZnVuY3Rpb24oYixkKXt0PWIsdC4kcmVuZGVyPXRoaXMucmVuZGVyLHQuJGZvcm1hdHRlcnMudW5zaGlmdChmdW5jdGlvbihhKXtyZXR1cm4gYT9uZXcgRGF0ZShhKTpudWxsfSk7dmFyIGU9ZC5lcSgwKSxmPWQuZXEoMSksaD1kLmVxKDIpLGk9YW5ndWxhci5pc0RlZmluZWQoYy5tb3VzZXdoZWVsKT9hLiRwYXJlbnQuJGV2YWwoYy5tb3VzZXdoZWVsKTpnLm1vdXNld2hlZWw7aSYmdGhpcy5zZXR1cE1vdXNld2hlZWxFdmVudHMoZSxmLGgpO3ZhciBqPWFuZ3VsYXIuaXNEZWZpbmVkKGMuYXJyb3drZXlzKT9hLiRwYXJlbnQuJGV2YWwoYy5hcnJvd2tleXMpOmcuYXJyb3drZXlzO2omJnRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cyhlLGYsaCksYS5yZWFkb25seUlucHV0PWFuZ3VsYXIuaXNEZWZpbmVkKGMucmVhZG9ubHlJbnB1dCk/YS4kcGFyZW50LiRldmFsKGMucmVhZG9ubHlJbnB1dCk6Zy5yZWFkb25seUlucHV0LHRoaXMuc2V0dXBJbnB1dEV2ZW50cyhlLGYsaCl9O3ZhciB2PWcuaG91clN0ZXA7Yy5ob3VyU3RlcCYmcy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZChjLmhvdXJTdGVwKSxmdW5jdGlvbihhKXt2PSthfSkpO3ZhciB3PWcubWludXRlU3RlcDtjLm1pbnV0ZVN0ZXAmJnMucHVzaChhLiRwYXJlbnQuJHdhdGNoKGQoYy5taW51dGVTdGVwKSxmdW5jdGlvbihhKXt3PSthfSkpO3ZhciB4O3MucHVzaChhLiRwYXJlbnQuJHdhdGNoKGQoYy5taW4pLGZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBEYXRlKGEpO3g9aXNOYU4oYik/dm9pZCAwOmJ9KSk7dmFyIHk7cy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZChjLm1heCksZnVuY3Rpb24oYSl7dmFyIGI9bmV3IERhdGUoYSk7eT1pc05hTihiKT92b2lkIDA6Yn0pKTt2YXIgej0hMTtjLm5nRGlzYWJsZWQmJnMucHVzaChhLiRwYXJlbnQuJHdhdGNoKGQoYy5uZ0Rpc2FibGVkKSxmdW5jdGlvbihhKXt6PWF9KSksYS5ub0luY3JlbWVudEhvdXJzPWZ1bmN0aW9uKCl7dmFyIGE9cChyLDYwKnYpO3JldHVybiB6fHxhPnl8fHI+YSYmeD5hfSxhLm5vRGVjcmVtZW50SG91cnM9ZnVuY3Rpb24oKXt2YXIgYT1wKHIsNjAqLXYpO3JldHVybiB6fHx4PmF8fGE+ciYmYT55fSxhLm5vSW5jcmVtZW50TWludXRlcz1mdW5jdGlvbigpe3ZhciBhPXAocix3KTtyZXR1cm4genx8YT55fHxyPmEmJng+YX0sYS5ub0RlY3JlbWVudE1pbnV0ZXM9ZnVuY3Rpb24oKXt2YXIgYT1wKHIsLXcpO3JldHVybiB6fHx4PmF8fGE+ciYmYT55fSxhLm5vSW5jcmVtZW50U2Vjb25kcz1mdW5jdGlvbigpe3ZhciBhPXEocixBKTtyZXR1cm4genx8YT55fHxyPmEmJng+YX0sYS5ub0RlY3JlbWVudFNlY29uZHM9ZnVuY3Rpb24oKXt2YXIgYT1xKHIsLUEpO3JldHVybiB6fHx4PmF8fGE+ciYmYT55fSxhLm5vVG9nZ2xlTWVyaWRpYW49ZnVuY3Rpb24oKXtyZXR1cm4gci5nZXRIb3VycygpPDEyP3p8fHAociw3MjApPnk6enx8cChyLC03MjApPHh9O3ZhciBBPWcuc2Vjb25kU3RlcDtjLnNlY29uZFN0ZXAmJnMucHVzaChhLiRwYXJlbnQuJHdhdGNoKGQoYy5zZWNvbmRTdGVwKSxmdW5jdGlvbihhKXtBPSthfSkpLGEuc2hvd1NlY29uZHM9Zy5zaG93U2Vjb25kcyxjLnNob3dTZWNvbmRzJiZzLnB1c2goYS4kcGFyZW50LiR3YXRjaChkKGMuc2hvd1NlY29uZHMpLGZ1bmN0aW9uKGIpe2Euc2hvd1NlY29uZHM9ISFifSkpLGEuc2hvd01lcmlkaWFuPWcuc2hvd01lcmlkaWFuLGMuc2hvd01lcmlkaWFuJiZzLnB1c2goYS4kcGFyZW50LiR3YXRjaChkKGMuc2hvd01lcmlkaWFuKSxmdW5jdGlvbihiKXtpZihhLnNob3dNZXJpZGlhbj0hIWIsdC4kZXJyb3IudGltZSl7dmFyIGM9aCgpLGQ9aSgpO2FuZ3VsYXIuaXNEZWZpbmVkKGMpJiZhbmd1bGFyLmlzRGVmaW5lZChkKSYmKHIuc2V0SG91cnMoYyksbCgpKX1lbHNlIG4oKX0pKSx0aGlzLnNldHVwTW91c2V3aGVlbEV2ZW50cz1mdW5jdGlvbihiLGMsZCl7dmFyIGU9ZnVuY3Rpb24oYSl7YS5vcmlnaW5hbEV2ZW50JiYoYT1hLm9yaWdpbmFsRXZlbnQpO3ZhciBiPWEud2hlZWxEZWx0YT9hLndoZWVsRGVsdGE6LWEuZGVsdGFZO3JldHVybiBhLmRldGFpbHx8Yj4wfTtiLmJpbmQoXFxcIm1vdXNld2hlZWwgd2hlZWxcXFwiLGZ1bmN0aW9uKGIpe3p8fGEuJGFwcGx5KGUoYik/YS5pbmNyZW1lbnRIb3VycygpOmEuZGVjcmVtZW50SG91cnMoKSksYi5wcmV2ZW50RGVmYXVsdCgpfSksYy5iaW5kKFxcXCJtb3VzZXdoZWVsIHdoZWVsXFxcIixmdW5jdGlvbihiKXt6fHxhLiRhcHBseShlKGIpP2EuaW5jcmVtZW50TWludXRlcygpOmEuZGVjcmVtZW50TWludXRlcygpKSxiLnByZXZlbnREZWZhdWx0KCl9KSxkLmJpbmQoXFxcIm1vdXNld2hlZWwgd2hlZWxcXFwiLGZ1bmN0aW9uKGIpe3p8fGEuJGFwcGx5KGUoYik/YS5pbmNyZW1lbnRTZWNvbmRzKCk6YS5kZWNyZW1lbnRTZWNvbmRzKCkpLGIucHJldmVudERlZmF1bHQoKX0pfSx0aGlzLnNldHVwQXJyb3drZXlFdmVudHM9ZnVuY3Rpb24oYixjLGQpe2IuYmluZChcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYil7enx8KDM4PT09Yi53aGljaD8oYi5wcmV2ZW50RGVmYXVsdCgpLGEuaW5jcmVtZW50SG91cnMoKSxhLiRhcHBseSgpKTo0MD09PWIud2hpY2gmJihiLnByZXZlbnREZWZhdWx0KCksYS5kZWNyZW1lbnRIb3VycygpLGEuJGFwcGx5KCkpKX0pLGMuYmluZChcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYil7enx8KDM4PT09Yi53aGljaD8oYi5wcmV2ZW50RGVmYXVsdCgpLGEuaW5jcmVtZW50TWludXRlcygpLGEuJGFwcGx5KCkpOjQwPT09Yi53aGljaCYmKGIucHJldmVudERlZmF1bHQoKSxhLmRlY3JlbWVudE1pbnV0ZXMoKSxhLiRhcHBseSgpKSl9KSxkLmJpbmQoXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGIpe3p8fCgzOD09PWIud2hpY2g/KGIucHJldmVudERlZmF1bHQoKSxhLmluY3JlbWVudFNlY29uZHMoKSxhLiRhcHBseSgpKTo0MD09PWIud2hpY2gmJihiLnByZXZlbnREZWZhdWx0KCksYS5kZWNyZW1lbnRTZWNvbmRzKCksYS4kYXBwbHkoKSkpfSl9LHRoaXMuc2V0dXBJbnB1dEV2ZW50cz1mdW5jdGlvbihiLGMsZCl7aWYoYS5yZWFkb25seUlucHV0KXJldHVybiBhLnVwZGF0ZUhvdXJzPWFuZ3VsYXIubm9vcCxhLnVwZGF0ZU1pbnV0ZXM9YW5ndWxhci5ub29wLHZvaWQoYS51cGRhdGVTZWNvbmRzPWFuZ3VsYXIubm9vcCk7dmFyIGU9ZnVuY3Rpb24oYixjLGQpe3QuJHNldFZpZXdWYWx1ZShudWxsKSx0LiRzZXRWYWxpZGl0eShcXFwidGltZVxcXCIsITEpLGFuZ3VsYXIuaXNEZWZpbmVkKGIpJiYoYS5pbnZhbGlkSG91cnM9YiksYW5ndWxhci5pc0RlZmluZWQoYykmJihhLmludmFsaWRNaW51dGVzPWMpLGFuZ3VsYXIuaXNEZWZpbmVkKGQpJiYoYS5pbnZhbGlkU2Vjb25kcz1kKX07YS51cGRhdGVIb3Vycz1mdW5jdGlvbigpe3ZhciBhPWgoKSxiPWkoKTt0LiRzZXREaXJ0eSgpLGFuZ3VsYXIuaXNEZWZpbmVkKGEpJiZhbmd1bGFyLmlzRGVmaW5lZChiKT8oci5zZXRIb3VycyhhKSxyLnNldE1pbnV0ZXMoYikseD5yfHxyPnk/ZSghMCk6bChcXFwiaFxcXCIpKTplKCEwKX0sYi5iaW5kKFxcXCJibHVyXFxcIixmdW5jdGlvbihiKXt0LiRzZXRUb3VjaGVkKCksbnVsbD09PWEuaG91cnN8fFxcXCJcXFwiPT09YS5ob3Vycz9lKCEwKTohYS5pbnZhbGlkSG91cnMmJmEuaG91cnM8MTAmJmEuJGFwcGx5KGZ1bmN0aW9uKCl7YS5ob3Vycz1rKGEuaG91cnMpfSl9KSxhLnVwZGF0ZU1pbnV0ZXM9ZnVuY3Rpb24oKXt2YXIgYT1pKCksYj1oKCk7dC4kc2V0RGlydHkoKSxhbmd1bGFyLmlzRGVmaW5lZChhKSYmYW5ndWxhci5pc0RlZmluZWQoYik/KHIuc2V0SG91cnMoYiksci5zZXRNaW51dGVzKGEpLHg+cnx8cj55P2Uodm9pZCAwLCEwKTpsKFxcXCJtXFxcIikpOmUodm9pZCAwLCEwKX0sYy5iaW5kKFxcXCJibHVyXFxcIixmdW5jdGlvbihiKXt0LiRzZXRUb3VjaGVkKCksbnVsbD09PWEubWludXRlcz9lKHZvaWQgMCwhMCk6IWEuaW52YWxpZE1pbnV0ZXMmJmEubWludXRlczwxMCYmYS4kYXBwbHkoZnVuY3Rpb24oKXthLm1pbnV0ZXM9ayhhLm1pbnV0ZXMpfSl9KSxhLnVwZGF0ZVNlY29uZHM9ZnVuY3Rpb24oKXt2YXIgYT1qKCk7dC4kc2V0RGlydHkoKSxhbmd1bGFyLmlzRGVmaW5lZChhKT8oci5zZXRTZWNvbmRzKGEpLGwoXFxcInNcXFwiKSk6ZSh2b2lkIDAsdm9pZCAwLCEwKX0sZC5iaW5kKFxcXCJibHVyXFxcIixmdW5jdGlvbihiKXshYS5pbnZhbGlkU2Vjb25kcyYmYS5zZWNvbmRzPDEwJiZhLiRhcHBseShmdW5jdGlvbigpe2Euc2Vjb25kcz1rKGEuc2Vjb25kcyl9KX0pfSx0aGlzLnJlbmRlcj1mdW5jdGlvbigpe3ZhciBiPXQuJHZpZXdWYWx1ZTtpc05hTihiKT8odC4kc2V0VmFsaWRpdHkoXFxcInRpbWVcXFwiLCExKSxlLmVycm9yKCdUaW1lcGlja2VyIGRpcmVjdGl2ZTogXFxcIm5nLW1vZGVsXFxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAwMS4wMS4xOTcwIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBSRkMyODIyIG9yIElTTyA4NjAxIGRhdGUuJykpOihiJiYocj1iKSx4PnJ8fHI+eT8odC4kc2V0VmFsaWRpdHkoXFxcInRpbWVcXFwiLCExKSxhLmludmFsaWRIb3Vycz0hMCxhLmludmFsaWRNaW51dGVzPSEwKTptKCksbigpKX0sYS5zaG93U3Bpbm5lcnM9YW5ndWxhci5pc0RlZmluZWQoYy5zaG93U3Bpbm5lcnMpP2EuJHBhcmVudC4kZXZhbChjLnNob3dTcGlubmVycyk6Zy5zaG93U3Bpbm5lcnMsYS5pbmNyZW1lbnRIb3Vycz1mdW5jdGlvbigpe2Eubm9JbmNyZW1lbnRIb3VycygpfHxvKDYwKnYqNjApfSxhLmRlY3JlbWVudEhvdXJzPWZ1bmN0aW9uKCl7YS5ub0RlY3JlbWVudEhvdXJzKCl8fG8oNjAqLXYqNjApfSxhLmluY3JlbWVudE1pbnV0ZXM9ZnVuY3Rpb24oKXthLm5vSW5jcmVtZW50TWludXRlcygpfHxvKDYwKncpfSxhLmRlY3JlbWVudE1pbnV0ZXM9ZnVuY3Rpb24oKXthLm5vRGVjcmVtZW50TWludXRlcygpfHxvKDYwKi13KX0sYS5pbmNyZW1lbnRTZWNvbmRzPWZ1bmN0aW9uKCl7YS5ub0luY3JlbWVudFNlY29uZHMoKXx8byhBKX0sYS5kZWNyZW1lbnRTZWNvbmRzPWZ1bmN0aW9uKCl7YS5ub0RlY3JlbWVudFNlY29uZHMoKXx8bygtQSl9LGEudG9nZ2xlTWVyaWRpYW49ZnVuY3Rpb24oKXt2YXIgYj1pKCksYz1oKCk7YS5ub1RvZ2dsZU1lcmlkaWFuKCl8fChhbmd1bGFyLmlzRGVmaW5lZChiKSYmYW5ndWxhci5pc0RlZmluZWQoYyk/byg3MjAqKHIuZ2V0SG91cnMoKTwxMj82MDotNjApKTphLm1lcmlkaWFuPWEubWVyaWRpYW49PT11WzBdP3VbMV06dVswXSl9LGEuYmx1cj1mdW5jdGlvbigpe3QuJHNldFRvdWNoZWQoKX0sYS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe2Zvcig7cy5sZW5ndGg7KXMuc2hpZnQoKSgpfSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJUaW1lcGlja2VyXFxcIixbXFxcInVpYlRpbWVwaWNrZXJDb25maWdcXFwiLGZ1bmN0aW9uKGEpe3JldHVybntyZXF1aXJlOltcXFwidWliVGltZXBpY2tlclxcXCIsXFxcIj9ebmdNb2RlbFxcXCJdLGNvbnRyb2xsZXI6XFxcIlVpYlRpbWVwaWNrZXJDb250cm9sbGVyXFxcIixjb250cm9sbGVyQXM6XFxcInRpbWVwaWNrZXJcXFwiLHJlcGxhY2U6ITAsc2NvcGU6e30sdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYixjKXtyZXR1cm4gYy50ZW1wbGF0ZVVybHx8YS50ZW1wbGF0ZVVybH0sbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kWzBdLGY9ZFsxXTtmJiZlLmluaXQoZixiLmZpbmQoXFxcImlucHV0XFxcIikpfX19XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC50eXBlYWhlYWRcXFwiLFtcXFwidWkuYm9vdHN0cmFwLmRlYm91bmNlXFxcIixcXFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXFxcIl0pLmZhY3RvcnkoXFxcInVpYlR5cGVhaGVhZFBhcnNlclxcXCIsW1xcXCIkcGFyc2VcXFwiLGZ1bmN0aW9uKGEpe3ZhciBiPS9eXFxcXHMqKFtcXFxcc1xcXFxTXSs/KSg/OlxcXFxzK2FzXFxcXHMrKFtcXFxcc1xcXFxTXSs/KSk/XFxcXHMrZm9yXFxcXHMrKD86KFtcXFxcJFxcXFx3XVtcXFxcJFxcXFx3XFxcXGRdKikpXFxcXHMraW5cXFxccysoW1xcXFxzXFxcXFNdKz8pJC87cmV0dXJue3BhcnNlOmZ1bmN0aW9uKGMpe3ZhciBkPWMubWF0Y2goYik7aWYoIWQpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0eXBlYWhlYWQgc3BlY2lmaWNhdGlvbiBpbiBmb3JtIG9mIFxcXCJfbW9kZWxWYWx1ZV8gKGFzIF9sYWJlbF8pPyBmb3IgX2l0ZW1fIGluIF9jb2xsZWN0aW9uX1xcXCIgYnV0IGdvdCBcXFwiJytjKydcXFwiLicpO3JldHVybntpdGVtTmFtZTpkWzNdLHNvdXJjZTphKGRbNF0pLHZpZXdNYXBwZXI6YShkWzJdfHxkWzFdKSxtb2RlbE1hcHBlcjphKGRbMV0pfX19fV0pLmNvbnRyb2xsZXIoXFxcIlVpYlR5cGVhaGVhZENvbnRyb2xsZXJcXFwiLFtcXFwiJHNjb3BlXFxcIixcXFwiJGVsZW1lbnRcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCIkY29tcGlsZVxcXCIsXFxcIiRwYXJzZVxcXCIsXFxcIiRxXFxcIixcXFwiJHRpbWVvdXRcXFwiLFxcXCIkZG9jdW1lbnRcXFwiLFxcXCIkd2luZG93XFxcIixcXFwiJHJvb3RTY29wZVxcXCIsXFxcIiQkZGVib3VuY2VcXFwiLFxcXCIkdWliUG9zaXRpb25cXFwiLFxcXCJ1aWJUeXBlYWhlYWRQYXJzZXJcXFwiLGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpLGosayxsLG0pe2Z1bmN0aW9uIG4oKXtOLm1vdmVJblByb2dyZXNzfHwoTi5tb3ZlSW5Qcm9ncmVzcz0hMCxOLiRkaWdlc3QoKSksWSgpfWZ1bmN0aW9uIG8oKXtOLnBvc2l0aW9uPUQ/bC5vZmZzZXQoYik6bC5wb3NpdGlvbihiKSxOLnBvc2l0aW9uLnRvcCs9Yi5wcm9wKFxcXCJvZmZzZXRIZWlnaHRcXFwiKX12YXIgcCxxLHI9WzksMTMsMjcsMzgsNDBdLHM9MjAwLHQ9YS4kZXZhbChjLnR5cGVhaGVhZE1pbkxlbmd0aCk7dHx8MD09PXR8fCh0PTEpO3ZhciB1PWEuJGV2YWwoYy50eXBlYWhlYWRXYWl0TXMpfHwwLHY9YS4kZXZhbChjLnR5cGVhaGVhZEVkaXRhYmxlKSE9PSExO2EuJHdhdGNoKGMudHlwZWFoZWFkRWRpdGFibGUsZnVuY3Rpb24oYSl7dj1hIT09ITF9KTt2YXIgdyx4LHk9ZShjLnR5cGVhaGVhZExvYWRpbmcpLmFzc2lnbnx8YW5ndWxhci5ub29wLHo9ZShjLnR5cGVhaGVhZE9uU2VsZWN0KSxBPWFuZ3VsYXIuaXNEZWZpbmVkKGMudHlwZWFoZWFkU2VsZWN0T25CbHVyKT9hLiRldmFsKGMudHlwZWFoZWFkU2VsZWN0T25CbHVyKTohMSxCPWUoYy50eXBlYWhlYWROb1Jlc3VsdHMpLmFzc2lnbnx8YW5ndWxhci5ub29wLEM9Yy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlcj9lKGMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIpOnZvaWQgMCxEPWMudHlwZWFoZWFkQXBwZW5kVG9Cb2R5P2EuJGV2YWwoYy50eXBlYWhlYWRBcHBlbmRUb0JvZHkpOiExLEU9Yy50eXBlYWhlYWRBcHBlbmRUbz9hLiRldmFsKGMudHlwZWFoZWFkQXBwZW5kVG8pOm51bGwsRj1hLiRldmFsKGMudHlwZWFoZWFkRm9jdXNGaXJzdCkhPT0hMSxHPWMudHlwZWFoZWFkU2VsZWN0T25FeGFjdD9hLiRldmFsKGMudHlwZWFoZWFkU2VsZWN0T25FeGFjdCk6ITEsSD1lKGMudHlwZWFoZWFkSXNPcGVuKS5hc3NpZ258fGFuZ3VsYXIubm9vcCxJPWEuJGV2YWwoYy50eXBlYWhlYWRTaG93SGludCl8fCExLEo9ZShjLm5nTW9kZWwpLEs9ZShjLm5nTW9kZWwrXFxcIigkJCRwKVxcXCIpLEw9ZnVuY3Rpb24oYixjKXtyZXR1cm4gYW5ndWxhci5pc0Z1bmN0aW9uKEooYSkpJiZxJiZxLiRvcHRpb25zJiZxLiRvcHRpb25zLmdldHRlclNldHRlcj9LKGIseyQkJHA6Y30pOkouYXNzaWduKGIsYyl9LE09bS5wYXJzZShjLnVpYlR5cGVhaGVhZCksTj1hLiRuZXcoKSxPPWEuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtOLiRkZXN0cm95KCl9KTtOLiRvbihcXFwiJGRlc3Ryb3lcXFwiLE8pO3ZhciBQPVxcXCJ0eXBlYWhlYWQtXFxcIitOLiRpZCtcXFwiLVxcXCIrTWF0aC5mbG9vcigxZTQqTWF0aC5yYW5kb20oKSk7Yi5hdHRyKHtcXFwiYXJpYS1hdXRvY29tcGxldGVcXFwiOlxcXCJsaXN0XFxcIixcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITEsXFxcImFyaWEtb3duc1xcXCI6UH0pO3ZhciBRLFI7SSYmKFE9YW5ndWxhci5lbGVtZW50KFxcXCI8ZGl2PjwvZGl2PlxcXCIpLFEuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcInJlbGF0aXZlXFxcIiksYi5hZnRlcihRKSxSPWIuY2xvbmUoKSxSLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIixcXFwiXFxcIiksUi52YWwoXFxcIlxcXCIpLFIuY3NzKHtwb3NpdGlvbjpcXFwiYWJzb2x1dGVcXFwiLHRvcDpcXFwiMHB4XFxcIixsZWZ0OlxcXCIwcHhcXFwiLFxcXCJib3JkZXItY29sb3JcXFwiOlxcXCJ0cmFuc3BhcmVudFxcXCIsXFxcImJveC1zaGFkb3dcXFwiOlxcXCJub25lXFxcIixvcGFjaXR5OjEsYmFja2dyb3VuZDpcXFwibm9uZSAwJSAwJSAvIGF1dG8gcmVwZWF0IHNjcm9sbCBwYWRkaW5nLWJveCBib3JkZXItYm94IHJnYigyNTUsIDI1NSwgMjU1KVxcXCIsY29sb3I6XFxcIiM5OTlcXFwifSksYi5jc3Moe3Bvc2l0aW9uOlxcXCJyZWxhdGl2ZVxcXCIsXFxcInZlcnRpY2FsLWFsaWduXFxcIjpcXFwidG9wXFxcIixcXFwiYmFja2dyb3VuZC1jb2xvclxcXCI6XFxcInRyYW5zcGFyZW50XFxcIn0pLFEuYXBwZW5kKFIpLFIuYWZ0ZXIoYikpO3ZhciBTPWFuZ3VsYXIuZWxlbWVudChcXFwiPGRpdiB1aWItdHlwZWFoZWFkLXBvcHVwPjwvZGl2PlxcXCIpO1MuYXR0cih7aWQ6UCxtYXRjaGVzOlxcXCJtYXRjaGVzXFxcIixhY3RpdmU6XFxcImFjdGl2ZUlkeFxcXCIsc2VsZWN0OlxcXCJzZWxlY3QoYWN0aXZlSWR4LCBldnQpXFxcIixcXFwibW92ZS1pbi1wcm9ncmVzc1xcXCI6XFxcIm1vdmVJblByb2dyZXNzXFxcIixxdWVyeTpcXFwicXVlcnlcXFwiLHBvc2l0aW9uOlxcXCJwb3NpdGlvblxcXCIsXFxcImFzc2lnbi1pcy1vcGVuXFxcIjpcXFwiYXNzaWduSXNPcGVuKGlzT3BlbilcXFwiLGRlYm91bmNlOlxcXCJkZWJvdW5jZVVwZGF0ZVxcXCJ9KSxhbmd1bGFyLmlzRGVmaW5lZChjLnR5cGVhaGVhZFRlbXBsYXRlVXJsKSYmUy5hdHRyKFxcXCJ0ZW1wbGF0ZS11cmxcXFwiLGMudHlwZWFoZWFkVGVtcGxhdGVVcmwpLGFuZ3VsYXIuaXNEZWZpbmVkKGMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCkmJlMuYXR0cihcXFwicG9wdXAtdGVtcGxhdGUtdXJsXFxcIixjLnR5cGVhaGVhZFBvcHVwVGVtcGxhdGVVcmwpO3ZhciBUPWZ1bmN0aW9uKCl7SSYmUi52YWwoXFxcIlxcXCIpfSxVPWZ1bmN0aW9uKCl7Ti5tYXRjaGVzPVtdLE4uYWN0aXZlSWR4PS0xLGIuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpLFQoKX0sVj1mdW5jdGlvbihhKXtyZXR1cm4gUCtcXFwiLW9wdGlvbi1cXFwiK2F9O04uJHdhdGNoKFxcXCJhY3RpdmVJZHhcXFwiLGZ1bmN0aW9uKGEpezA+YT9iLnJlbW92ZUF0dHIoXFxcImFyaWEtYWN0aXZlZGVzY2VuZGFudFxcXCIpOmIuYXR0cihcXFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XFxcIixWKGEpKX0pO3ZhciBXPWZ1bmN0aW9uKGEsYil7cmV0dXJuIE4ubWF0Y2hlcy5sZW5ndGg+YiYmYT9hLnRvVXBwZXJDYXNlKCk9PT1OLm1hdGNoZXNbYl0ubGFiZWwudG9VcHBlckNhc2UoKTohMX0sWD1mdW5jdGlvbihjLGQpe3ZhciBlPXskdmlld1ZhbHVlOmN9O3koYSwhMCksQihhLCExKSxmLndoZW4oTS5zb3VyY2UoYSxlKSkudGhlbihmdW5jdGlvbihmKXt2YXIgZz1jPT09cC4kdmlld1ZhbHVlO2lmKGcmJncpaWYoZiYmZi5sZW5ndGg+MCl7Ti5hY3RpdmVJZHg9Rj8wOi0xLEIoYSwhMSksTi5tYXRjaGVzLmxlbmd0aD0wO2Zvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKWVbTS5pdGVtTmFtZV09ZltoXSxOLm1hdGNoZXMucHVzaCh7aWQ6VihoKSxsYWJlbDpNLnZpZXdNYXBwZXIoTixlKSxtb2RlbDpmW2hdfSk7aWYoTi5xdWVyeT1jLG8oKSxiLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEwKSxHJiYxPT09Ti5tYXRjaGVzLmxlbmd0aCYmVyhjLDApJiYoYW5ndWxhci5pc051bWJlcihOLmRlYm91bmNlVXBkYXRlKXx8YW5ndWxhci5pc09iamVjdChOLmRlYm91bmNlVXBkYXRlKT9rKGZ1bmN0aW9uKCl7Ti5zZWxlY3QoMCxkKX0sYW5ndWxhci5pc051bWJlcihOLmRlYm91bmNlVXBkYXRlKT9OLmRlYm91bmNlVXBkYXRlOk4uZGVib3VuY2VVcGRhdGVbXFxcImRlZmF1bHRcXFwiXSk6Ti5zZWxlY3QoMCxkKSksSSl7dmFyIGk9Ti5tYXRjaGVzWzBdLmxhYmVsO2MubGVuZ3RoPjAmJmkuc2xpY2UoMCxjLmxlbmd0aCkudG9VcHBlckNhc2UoKT09PWMudG9VcHBlckNhc2UoKT9SLnZhbChjK2kuc2xpY2UoYy5sZW5ndGgpKTpSLnZhbChcXFwiXFxcIil9fWVsc2UgVSgpLEIoYSwhMCk7ZyYmeShhLCExKX0sZnVuY3Rpb24oKXtVKCkseShhLCExKSxCKGEsITApfSl9O0QmJihhbmd1bGFyLmVsZW1lbnQoaSkub24oXFxcInJlc2l6ZVxcXCIsbiksaC5maW5kKFxcXCJib2R5XFxcIikub24oXFxcInNjcm9sbFxcXCIsbikpO3ZhciBZPWsoZnVuY3Rpb24oKXtOLm1hdGNoZXMubGVuZ3RoJiZvKCksTi5tb3ZlSW5Qcm9ncmVzcz0hMX0scyk7Ti5tb3ZlSW5Qcm9ncmVzcz0hMSxOLnF1ZXJ5PXZvaWQgMDt2YXIgWiwkPWZ1bmN0aW9uKGEpe1o9ZyhmdW5jdGlvbigpe1goYSl9LHUpfSxfPWZ1bmN0aW9uKCl7WiYmZy5jYW5jZWwoWil9O1UoKSxOLmFzc2lnbklzT3Blbj1mdW5jdGlvbihiKXtIKGEsYil9LE4uc2VsZWN0PWZ1bmN0aW9uKGQsZSl7dmFyIGYsaCxpPXt9O3g9ITAsaVtNLml0ZW1OYW1lXT1oPU4ubWF0Y2hlc1tkXS5tb2RlbCxmPU0ubW9kZWxNYXBwZXIoYSxpKSxMKGEsZikscC4kc2V0VmFsaWRpdHkoXFxcImVkaXRhYmxlXFxcIiwhMCkscC4kc2V0VmFsaWRpdHkoXFxcInBhcnNlXFxcIiwhMCkseihhLHskaXRlbTpoLCRtb2RlbDpmLCRsYWJlbDpNLnZpZXdNYXBwZXIoYSxpKSwkZXZlbnQ6ZX0pLFUoKSxOLiRldmFsKGMudHlwZWFoZWFkRm9jdXNPblNlbGVjdCkhPT0hMSYmZyhmdW5jdGlvbigpe2JbMF0uZm9jdXMoKX0sMCwhMSl9LGIub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGEpe2lmKDAhPT1OLm1hdGNoZXMubGVuZ3RoJiYtMSE9PXIuaW5kZXhPZihhLndoaWNoKSl7aWYoLTE9PT1OLmFjdGl2ZUlkeCYmKDk9PT1hLndoaWNofHwxMz09PWEud2hpY2gpKXJldHVybiBVKCksdm9pZCBOLiRkaWdlc3QoKTthLnByZXZlbnREZWZhdWx0KCk7dmFyIGI7c3dpdGNoKGEud2hpY2gpe2Nhc2UgOTpjYXNlIDEzOk4uJGFwcGx5KGZ1bmN0aW9uKCl7YW5ndWxhci5pc051bWJlcihOLmRlYm91bmNlVXBkYXRlKXx8YW5ndWxhci5pc09iamVjdChOLmRlYm91bmNlVXBkYXRlKT9rKGZ1bmN0aW9uKCl7Ti5zZWxlY3QoTi5hY3RpdmVJZHgsYSl9LGFuZ3VsYXIuaXNOdW1iZXIoTi5kZWJvdW5jZVVwZGF0ZSk/Ti5kZWJvdW5jZVVwZGF0ZTpOLmRlYm91bmNlVXBkYXRlW1xcXCJkZWZhdWx0XFxcIl0pOk4uc2VsZWN0KE4uYWN0aXZlSWR4LGEpfSk7YnJlYWs7Y2FzZSAyNzphLnN0b3BQcm9wYWdhdGlvbigpLFUoKSxOLiRkaWdlc3QoKTticmVhaztjYXNlIDM4Ok4uYWN0aXZlSWR4PShOLmFjdGl2ZUlkeD4wP04uYWN0aXZlSWR4Ok4ubWF0Y2hlcy5sZW5ndGgpLTEsTi4kZGlnZXN0KCksYj1TLmZpbmQoXFxcImxpXFxcIilbTi5hY3RpdmVJZHhdLGIucGFyZW50Tm9kZS5zY3JvbGxUb3A9Yi5vZmZzZXRUb3A7YnJlYWs7Y2FzZSA0MDpOLmFjdGl2ZUlkeD0oTi5hY3RpdmVJZHgrMSklTi5tYXRjaGVzLmxlbmd0aCxOLiRkaWdlc3QoKSxiPVMuZmluZChcXFwibGlcXFwiKVtOLmFjdGl2ZUlkeF0sYi5wYXJlbnROb2RlLnNjcm9sbFRvcD1iLm9mZnNldFRvcH19fSksYi5iaW5kKFxcXCJmb2N1c1xcXCIsZnVuY3Rpb24oYSl7dz0hMCwwIT09dHx8cC4kdmlld1ZhbHVlfHxnKGZ1bmN0aW9uKCl7WChwLiR2aWV3VmFsdWUsYSl9LDApfSksYi5iaW5kKFxcXCJibHVyXFxcIixmdW5jdGlvbihhKXtBJiZOLm1hdGNoZXMubGVuZ3RoJiYtMSE9PU4uYWN0aXZlSWR4JiYheCYmKHg9ITAsTi4kYXBwbHkoZnVuY3Rpb24oKXthbmd1bGFyLmlzT2JqZWN0KE4uZGVib3VuY2VVcGRhdGUpJiZhbmd1bGFyLmlzTnVtYmVyKE4uZGVib3VuY2VVcGRhdGUuYmx1cik/ayhmdW5jdGlvbigpe04uc2VsZWN0KE4uYWN0aXZlSWR4LGEpfSxOLmRlYm91bmNlVXBkYXRlLmJsdXIpOk4uc2VsZWN0KE4uYWN0aXZlSWR4LGEpfSkpLCF2JiZwLiRlcnJvci5lZGl0YWJsZSYmKHAuJHZpZXdWYWx1ZT1cXFwiXFxcIixiLnZhbChcXFwiXFxcIikpLHc9ITEseD0hMX0pO3ZhciBhYT1mdW5jdGlvbihhKXtiWzBdIT09YS50YXJnZXQmJjMhPT1hLndoaWNoJiYwIT09Ti5tYXRjaGVzLmxlbmd0aCYmKFUoKSxqLiQkcGhhc2V8fE4uJGRpZ2VzdCgpKX07aC5vbihcXFwiY2xpY2tcXFwiLGFhKSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7aC5vZmYoXFxcImNsaWNrXFxcIixhYSksKER8fEUpJiZiYS5yZW1vdmUoKSxEJiYoYW5ndWxhci5lbGVtZW50KGkpLm9mZihcXFwicmVzaXplXFxcIixuKSxoLmZpbmQoXFxcImJvZHlcXFwiKS5vZmYoXFxcInNjcm9sbFxcXCIsbikpLFMucmVtb3ZlKCksSSYmUS5yZW1vdmUoKX0pO3ZhciBiYT1kKFMpKE4pO0Q/aC5maW5kKFxcXCJib2R5XFxcIikuYXBwZW5kKGJhKTpFP2FuZ3VsYXIuZWxlbWVudChFKS5lcSgwKS5hcHBlbmQoYmEpOmIuYWZ0ZXIoYmEpLHRoaXMuaW5pdD1mdW5jdGlvbihiLGMpe3A9YixxPWMsTi5kZWJvdW5jZVVwZGF0ZT1wLiRvcHRpb25zJiZlKHAuJG9wdGlvbnMuZGVib3VuY2UpKGEpLHAuJHBhcnNlcnMudW5zaGlmdChmdW5jdGlvbihiKXtyZXR1cm4gdz0hMCwwPT09dHx8YiYmYi5sZW5ndGg+PXQ/dT4wPyhfKCksJChiKSk6WChiKTooeShhLCExKSxfKCksVSgpKSx2P2I6Yj92b2lkIHAuJHNldFZhbGlkaXR5KFxcXCJlZGl0YWJsZVxcXCIsITEpOihwLiRzZXRWYWxpZGl0eShcXFwiZWRpdGFibGVcXFwiLCEwKSxudWxsKX0pLHAuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbihiKXt2YXIgYyxkLGU9e307cmV0dXJuIHZ8fHAuJHNldFZhbGlkaXR5KFxcXCJlZGl0YWJsZVxcXCIsITApLEM/KGUuJG1vZGVsPWIsQyhhLGUpKTooZVtNLml0ZW1OYW1lXT1iLGM9TS52aWV3TWFwcGVyKGEsZSksZVtNLml0ZW1OYW1lXT12b2lkIDAsZD1NLnZpZXdNYXBwZXIoYSxlKSxjIT09ZD9jOmIpfSl9fV0pLmRpcmVjdGl2ZShcXFwidWliVHlwZWFoZWFkXFxcIixmdW5jdGlvbigpe3JldHVybntjb250cm9sbGVyOlxcXCJVaWJUeXBlYWhlYWRDb250cm9sbGVyXFxcIixyZXF1aXJlOltcXFwibmdNb2RlbFxcXCIsXFxcIl4/bmdNb2RlbE9wdGlvbnNcXFwiLFxcXCJ1aWJUeXBlYWhlYWRcXFwiXSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2RbMl0uaW5pdChkWzBdLGRbMV0pfX19KS5kaXJlY3RpdmUoXFxcInVpYlR5cGVhaGVhZFBvcHVwXFxcIixbXFxcIiQkZGVib3VuY2VcXFwiLGZ1bmN0aW9uKGEpe3JldHVybntzY29wZTp7bWF0Y2hlczpcXFwiPVxcXCIscXVlcnk6XFxcIj1cXFwiLGFjdGl2ZTpcXFwiPVxcXCIscG9zaXRpb246XFxcIiZcXFwiLG1vdmVJblByb2dyZXNzOlxcXCI9XFxcIixzZWxlY3Q6XFxcIiZcXFwiLGFzc2lnbklzT3BlbjpcXFwiJlxcXCIsZGVib3VuY2U6XFxcIiZcXFwifSxyZXBsYWNlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIucG9wdXBUZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcXFwifSxsaW5rOmZ1bmN0aW9uKGIsYyxkKXtiLnRlbXBsYXRlVXJsPWQudGVtcGxhdGVVcmwsYi5pc09wZW49ZnVuY3Rpb24oKXt2YXIgYT1iLm1hdGNoZXMubGVuZ3RoPjA7cmV0dXJuIGIuYXNzaWduSXNPcGVuKHtpc09wZW46YX0pLGF9LGIuaXNBY3RpdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGIuYWN0aXZlPT09YX0sYi5zZWxlY3RBY3RpdmU9ZnVuY3Rpb24oYSl7Yi5hY3RpdmU9YX0sYi5zZWxlY3RNYXRjaD1mdW5jdGlvbihjLGQpe3ZhciBlPWIuZGVib3VuY2UoKTthbmd1bGFyLmlzTnVtYmVyKGUpfHxhbmd1bGFyLmlzT2JqZWN0KGUpP2EoZnVuY3Rpb24oKXtiLnNlbGVjdCh7YWN0aXZlSWR4OmMsZXZ0OmR9KX0sYW5ndWxhci5pc051bWJlcihlKT9lOmVbXFxcImRlZmF1bHRcXFwiXSk6Yi5zZWxlY3Qoe2FjdGl2ZUlkeDpjLGV2dDpkfSl9fX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJUeXBlYWhlYWRNYXRjaFxcXCIsW1xcXCIkdGVtcGxhdGVSZXF1ZXN0XFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkcGFyc2VcXFwiLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm57c2NvcGU6e2luZGV4OlxcXCI9XFxcIixtYXRjaDpcXFwiPVxcXCIscXVlcnk6XFxcIj1cXFwifSxsaW5rOmZ1bmN0aW9uKGQsZSxmKXt2YXIgZz1jKGYudGVtcGxhdGVVcmwpKGQuJHBhcmVudCl8fFxcXCJ1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sXFxcIjthKGcpLnRoZW4oZnVuY3Rpb24oYSl7dmFyIGM9YW5ndWxhci5lbGVtZW50KGEudHJpbSgpKTtlLnJlcGxhY2VXaXRoKGMpLGIoYykoZCl9KX19fV0pLmZpbHRlcihcXFwidWliVHlwZWFoZWFkSGlnaGxpZ2h0XFxcIixbXFxcIiRzY2VcXFwiLFxcXCIkaW5qZWN0b3JcXFwiLFxcXCIkbG9nXFxcIixmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gYS5yZXBsYWNlKC8oWy4/KiteJFtcXFxcXVxcXFxcXFxcKCl7fXwtXSkvZyxcXFwiXFxcXFxcXFwkMVxcXCIpfWZ1bmN0aW9uIGUoYSl7cmV0dXJuLzwuKj4vZy50ZXN0KGEpfXZhciBmO3JldHVybiBmPWIuaGFzKFxcXCIkc2FuaXRpemVcXFwiKSxmdW5jdGlvbihiLGcpe3JldHVybiFmJiZlKGIpJiZjLndhcm4oXFxcIlVuc2FmZSB1c2Ugb2YgdHlwZWFoZWFkIHBsZWFzZSB1c2UgbmdTYW5pdGl6ZVxcXCIpLGI9Zz8oXFxcIlxcXCIrYikucmVwbGFjZShuZXcgUmVnRXhwKGQoZyksXFxcImdpXFxcIiksXFxcIjxzdHJvbmc+JCY8L3N0cm9uZz5cXFwiKTpiLGZ8fChiPWEudHJ1c3RBc0h0bWwoYikpLGJ9fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuY2Fyb3VzZWxcXFwiKS5ydW4oZnVuY3Rpb24oKXshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUmJmFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZChcXFwiaGVhZFxcXCIpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+Lm5nLWFuaW1hdGUuaXRlbTpub3QoLmxlZnQpOm5vdCgucmlnaHQpey13ZWJraXQtdHJhbnNpdGlvbjowcyBlYXNlLWluLW91dCBsZWZ0O3RyYW5zaXRpb246MHMgZWFzZS1pbi1vdXQgbGVmdH08L3N0eWxlPicpfSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5kYXRlcGlja2VyXFxcIikucnVuKGZ1bmN0aW9uKCl7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlJiZhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoXFxcImhlYWRcXFwiKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPi51aWItZGF0ZXBpY2tlciAudWliLXRpdGxle3dpZHRoOjEwMCU7fS51aWItZGF5IGJ1dHRvbiwudWliLW1vbnRoIGJ1dHRvbiwudWliLXllYXIgYnV0dG9ue21pbi13aWR0aDoxMDAlO30udWliLWRhdGVwaWNrZXItcG9wdXAuZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrO30udWliLWJ1dHRvbi1iYXJ7cGFkZGluZzoxMHB4IDlweCAycHg7fTwvc3R5bGU+Jyl9KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnRpbWVwaWNrZXJcXFwiKS5ydW4oZnVuY3Rpb24oKXshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUmJmFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZChcXFwiaGVhZFxcXCIpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+LnVpYi10aW1lIGlucHV0e3dpZHRoOjUwcHg7fTwvc3R5bGU+Jyl9KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFxcXCIpLnJ1bihmdW5jdGlvbigpeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSYmYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKFxcXCJoZWFkXFxcIikucHJlcGVuZCgnPHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5bdWliLXR5cGVhaGVhZC1wb3B1cF0uZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrO308L3N0eWxlPicpfSk7XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWJvb3RzdHJhcC91aS1ib290c3RyYXAubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsInJlcXVpcmUoXCIhIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWJvb3RzdHJhcC91aS1ib290c3RyYXAtdHBscy5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qXFxuICogYW5ndWxhci11aS1ib290c3RyYXBcXG4gKiBodHRwOi8vYW5ndWxhci11aS5naXRodWIuaW8vYm9vdHN0cmFwL1xcblxcbiAqIFZlcnNpb246IDEuMS4xIC0gMjAxNi0wMS0yNVxcbiAqIExpY2Vuc2U6IE1JVFxcbiAqL2FuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXBcXFwiLFtcXFwidWkuYm9vdHN0cmFwLnRwbHNcXFwiLFxcXCJ1aS5ib290c3RyYXAuY29sbGFwc2VcXFwiLFxcXCJ1aS5ib290c3RyYXAuYWNjb3JkaW9uXFxcIixcXFwidWkuYm9vdHN0cmFwLmFsZXJ0XFxcIixcXFwidWkuYm9vdHN0cmFwLmJ1dHRvbnNcXFwiLFxcXCJ1aS5ib290c3RyYXAuY2Fyb3VzZWxcXFwiLFxcXCJ1aS5ib290c3RyYXAuZGF0ZXBhcnNlclxcXCIsXFxcInVpLmJvb3RzdHJhcC5pc0NsYXNzXFxcIixcXFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXFxcIixcXFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJcXFwiLFxcXCJ1aS5ib290c3RyYXAuZGVib3VuY2VcXFwiLFxcXCJ1aS5ib290c3RyYXAuZHJvcGRvd25cXFwiLFxcXCJ1aS5ib290c3RyYXAuc3RhY2tlZE1hcFxcXCIsXFxcInVpLmJvb3RzdHJhcC5tb2RhbFxcXCIsXFxcInVpLmJvb3RzdHJhcC5wYWdpbmdcXFwiLFxcXCJ1aS5ib290c3RyYXAucGFnZXJcXFwiLFxcXCJ1aS5ib290c3RyYXAucGFnaW5hdGlvblxcXCIsXFxcInVpLmJvb3RzdHJhcC50b29sdGlwXFxcIixcXFwidWkuYm9vdHN0cmFwLnBvcG92ZXJcXFwiLFxcXCJ1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXJcXFwiLFxcXCJ1aS5ib290c3RyYXAucmF0aW5nXFxcIixcXFwidWkuYm9vdHN0cmFwLnRhYnNcXFwiLFxcXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclxcXCIsXFxcInVpLmJvb3RzdHJhcC50eXBlYWhlYWRcXFwiXSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC50cGxzXFxcIixbXFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcXFwiLFxcXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXFxcIixcXFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFxcXCIsXFxcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcXFwiXSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5jb2xsYXBzZVxcXCIsW10pLmRpcmVjdGl2ZShcXFwidWliQ29sbGFwc2VcXFwiLFtcXFwiJGFuaW1hdGVcXFwiLFxcXCIkcVxcXCIsXFxcIiRwYXJzZVxcXCIsXFxcIiRpbmplY3RvclxcXCIsZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZC5oYXMoXFxcIiRhbmltYXRlQ3NzXFxcIik/ZC5nZXQoXFxcIiRhbmltYXRlQ3NzXFxcIik6bnVsbDtyZXR1cm57bGluazpmdW5jdGlvbihkLGYsZyl7ZnVuY3Rpb24gaCgpe2YuaGFzQ2xhc3MoXFxcImNvbGxhcHNlXFxcIikmJmYuaGFzQ2xhc3MoXFxcImluXFxcIil8fGIucmVzb2x2ZShsKGQpKS50aGVuKGZ1bmN0aW9uKCl7Zi5yZW1vdmVDbGFzcyhcXFwiY29sbGFwc2VcXFwiKS5hZGRDbGFzcyhcXFwiY29sbGFwc2luZ1xcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEwKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITEpLGU/ZShmLHthZGRDbGFzczpcXFwiaW5cXFwiLGVhc2luZzpcXFwiZWFzZVxcXCIsdG86e2hlaWdodDpmWzBdLnNjcm9sbEhlaWdodCtcXFwicHhcXFwifX0pLnN0YXJ0KClbXFxcImZpbmFsbHlcXFwiXShpKTphLmFkZENsYXNzKGYsXFxcImluXFxcIix7dG86e2hlaWdodDpmWzBdLnNjcm9sbEhlaWdodCtcXFwicHhcXFwifX0pLnRoZW4oaSl9KX1mdW5jdGlvbiBpKCl7Zi5yZW1vdmVDbGFzcyhcXFwiY29sbGFwc2luZ1xcXCIpLmFkZENsYXNzKFxcXCJjb2xsYXBzZVxcXCIpLmNzcyh7aGVpZ2h0OlxcXCJhdXRvXFxcIn0pLG0oZCl9ZnVuY3Rpb24gaigpe3JldHVybiBmLmhhc0NsYXNzKFxcXCJjb2xsYXBzZVxcXCIpfHxmLmhhc0NsYXNzKFxcXCJpblxcXCIpP3ZvaWQgYi5yZXNvbHZlKG4oZCkpLnRoZW4oZnVuY3Rpb24oKXtmLmNzcyh7aGVpZ2h0OmZbMF0uc2Nyb2xsSGVpZ2h0K1xcXCJweFxcXCJ9KS5yZW1vdmVDbGFzcyhcXFwiY29sbGFwc2VcXFwiKS5hZGRDbGFzcyhcXFwiY29sbGFwc2luZ1xcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApLGU/ZShmLHtyZW1vdmVDbGFzczpcXFwiaW5cXFwiLHRvOntoZWlnaHQ6XFxcIjBcXFwifX0pLnN0YXJ0KClbXFxcImZpbmFsbHlcXFwiXShrKTphLnJlbW92ZUNsYXNzKGYsXFxcImluXFxcIix7dG86e2hlaWdodDpcXFwiMFxcXCJ9fSkudGhlbihrKX0pOmsoKX1mdW5jdGlvbiBrKCl7Zi5jc3Moe2hlaWdodDpcXFwiMFxcXCJ9KSxmLnJlbW92ZUNsYXNzKFxcXCJjb2xsYXBzaW5nXFxcIikuYWRkQ2xhc3MoXFxcImNvbGxhcHNlXFxcIiksbyhkKX12YXIgbD1jKGcuZXhwYW5kaW5nKSxtPWMoZy5leHBhbmRlZCksbj1jKGcuY29sbGFwc2luZyksbz1jKGcuY29sbGFwc2VkKTtkLiRldmFsKGcudWliQ29sbGFwc2UpfHxmLmFkZENsYXNzKFxcXCJpblxcXCIpLmFkZENsYXNzKFxcXCJjb2xsYXBzZVxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEwKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITEpLmNzcyh7aGVpZ2h0OlxcXCJhdXRvXFxcIn0pLGQuJHdhdGNoKGcudWliQ29sbGFwc2UsZnVuY3Rpb24oYSl7YT9qKCk6aCgpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmFjY29yZGlvblxcXCIsW1xcXCJ1aS5ib290c3RyYXAuY29sbGFwc2VcXFwiXSkuY29uc3RhbnQoXFxcInVpYkFjY29yZGlvbkNvbmZpZ1xcXCIse2Nsb3NlT3RoZXJzOiEwfSkuY29udHJvbGxlcihcXFwiVWliQWNjb3JkaW9uQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCJ1aWJBY2NvcmRpb25Db25maWdcXFwiLGZ1bmN0aW9uKGEsYixjKXt0aGlzLmdyb3Vwcz1bXSx0aGlzLmNsb3NlT3RoZXJzPWZ1bmN0aW9uKGQpe3ZhciBlPWFuZ3VsYXIuaXNEZWZpbmVkKGIuY2xvc2VPdGhlcnMpP2EuJGV2YWwoYi5jbG9zZU90aGVycyk6Yy5jbG9zZU90aGVycztlJiZhbmd1bGFyLmZvckVhY2godGhpcy5ncm91cHMsZnVuY3Rpb24oYSl7YSE9PWQmJihhLmlzT3Blbj0hMSl9KX0sdGhpcy5hZGRHcm91cD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuZ3JvdXBzLnB1c2goYSksYS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbihjKXtiLnJlbW92ZUdyb3VwKGEpfSl9LHRoaXMucmVtb3ZlR3JvdXA9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5ncm91cHMuaW5kZXhPZihhKTstMSE9PWImJnRoaXMuZ3JvdXBzLnNwbGljZShiLDEpfX1dKS5kaXJlY3RpdmUoXFxcInVpYkFjY29yZGlvblxcXCIsZnVuY3Rpb24oKXtyZXR1cm57Y29udHJvbGxlcjpcXFwiVWliQWNjb3JkaW9uQ29udHJvbGxlclxcXCIsY29udHJvbGxlckFzOlxcXCJhY2NvcmRpb25cXFwiLHRyYW5zY2x1ZGU6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcXFwifX19KS5kaXJlY3RpdmUoXFxcInVpYkFjY29yZGlvbkdyb3VwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOlxcXCJedWliQWNjb3JkaW9uXFxcIix0cmFuc2NsdWRlOiEwLHJlcGxhY2U6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcXFwifSxzY29wZTp7aGVhZGluZzpcXFwiQFxcXCIsaXNPcGVuOlxcXCI9P1xcXCIsaXNEaXNhYmxlZDpcXFwiPT9cXFwifSxjb250cm9sbGVyOmZ1bmN0aW9uKCl7dGhpcy5zZXRIZWFkaW5nPWZ1bmN0aW9uKGEpe3RoaXMuaGVhZGluZz1hfX0sbGluazpmdW5jdGlvbihhLGIsYyxkKXtkLmFkZEdyb3VwKGEpLGEub3BlbkNsYXNzPWMub3BlbkNsYXNzfHxcXFwicGFuZWwtb3BlblxcXCIsYS5wYW5lbENsYXNzPWMucGFuZWxDbGFzc3x8XFxcInBhbmVsLWRlZmF1bHRcXFwiLGEuJHdhdGNoKFxcXCJpc09wZW5cXFwiLGZ1bmN0aW9uKGMpe2IudG9nZ2xlQ2xhc3MoYS5vcGVuQ2xhc3MsISFjKSxjJiZkLmNsb3NlT3RoZXJzKGEpfSksYS50b2dnbGVPcGVuPWZ1bmN0aW9uKGIpe2EuaXNEaXNhYmxlZHx8YiYmMzIhPT1iLndoaWNofHwoYS5pc09wZW49IWEuaXNPcGVuKX19fX0pLmRpcmVjdGl2ZShcXFwidWliQWNjb3JkaW9uSGVhZGluZ1xcXCIsZnVuY3Rpb24oKXtyZXR1cm57dHJhbnNjbHVkZTohMCx0ZW1wbGF0ZTpcXFwiXFxcIixyZXBsYWNlOiEwLHJlcXVpcmU6XFxcIl51aWJBY2NvcmRpb25Hcm91cFxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkLGUpe2Quc2V0SGVhZGluZyhlKGEsYW5ndWxhci5ub29wKSl9fX0pLmRpcmVjdGl2ZShcXFwidWliQWNjb3JkaW9uVHJhbnNjbHVkZVxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVxdWlyZTpcXFwiXnVpYkFjY29yZGlvbkdyb3VwXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2EuJHdhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIGRbYy51aWJBY2NvcmRpb25UcmFuc2NsdWRlXX0sZnVuY3Rpb24oYSl7YSYmKGIuZmluZChcXFwic3BhblxcXCIpLmh0bWwoXFxcIlxcXCIpLGIuZmluZChcXFwic3BhblxcXCIpLmFwcGVuZChhKSl9KX19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5hbGVydFxcXCIsW10pLmNvbnRyb2xsZXIoXFxcIlVpYkFsZXJ0Q29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCIkaW50ZXJwb2xhdGVcXFwiLFxcXCIkdGltZW91dFxcXCIsZnVuY3Rpb24oYSxiLGMsZCl7YS5jbG9zZWFibGU9ISFiLmNsb3NlO3ZhciBlPWFuZ3VsYXIuaXNEZWZpbmVkKGIuZGlzbWlzc09uVGltZW91dCk/YyhiLmRpc21pc3NPblRpbWVvdXQpKGEuJHBhcmVudCk6bnVsbDtlJiZkKGZ1bmN0aW9uKCl7YS5jbG9zZSgpfSxwYXJzZUludChlLDEwKSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJBbGVydFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57Y29udHJvbGxlcjpcXFwiVWliQWxlcnRDb250cm9sbGVyXFxcIixjb250cm9sbGVyQXM6XFxcImFsZXJ0XFxcIix0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcXFwifSx0cmFuc2NsdWRlOiEwLHJlcGxhY2U6ITAsc2NvcGU6e3R5cGU6XFxcIkBcXFwiLGNsb3NlOlxcXCImXFxcIn19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5idXR0b25zXFxcIixbXSkuY29uc3RhbnQoXFxcInVpYkJ1dHRvbkNvbmZpZ1xcXCIse2FjdGl2ZUNsYXNzOlxcXCJhY3RpdmVcXFwiLHRvZ2dsZUV2ZW50OlxcXCJjbGlja1xcXCJ9KS5jb250cm9sbGVyKFxcXCJVaWJCdXR0b25zQ29udHJvbGxlclxcXCIsW1xcXCJ1aWJCdXR0b25Db25maWdcXFwiLGZ1bmN0aW9uKGEpe3RoaXMuYWN0aXZlQ2xhc3M9YS5hY3RpdmVDbGFzc3x8XFxcImFjdGl2ZVxcXCIsdGhpcy50b2dnbGVFdmVudD1hLnRvZ2dsZUV2ZW50fHxcXFwiY2xpY2tcXFwifV0pLmRpcmVjdGl2ZShcXFwidWliQnRuUmFkaW9cXFwiLFtcXFwiJHBhcnNlXFxcIixmdW5jdGlvbihhKXtyZXR1cm57cmVxdWlyZTpbXFxcInVpYkJ0blJhZGlvXFxcIixcXFwibmdNb2RlbFxcXCJdLGNvbnRyb2xsZXI6XFxcIlVpYkJ1dHRvbnNDb250cm9sbGVyXFxcIixjb250cm9sbGVyQXM6XFxcImJ1dHRvbnNcXFwiLGxpbms6ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9ZVswXSxnPWVbMV0saD1hKGQudWliVW5jaGVja2FibGUpO2MuZmluZChcXFwiaW5wdXRcXFwiKS5jc3Moe2Rpc3BsYXk6XFxcIm5vbmVcXFwifSksZy4kcmVuZGVyPWZ1bmN0aW9uKCl7Yy50b2dnbGVDbGFzcyhmLmFjdGl2ZUNsYXNzLGFuZ3VsYXIuZXF1YWxzKGcuJG1vZGVsVmFsdWUsYi4kZXZhbChkLnVpYkJ0blJhZGlvKSkpfSxjLm9uKGYudG9nZ2xlRXZlbnQsZnVuY3Rpb24oKXtpZighZC5kaXNhYmxlZCl7dmFyIGE9Yy5oYXNDbGFzcyhmLmFjdGl2ZUNsYXNzKTsoIWF8fGFuZ3VsYXIuaXNEZWZpbmVkKGQudW5jaGVja2FibGUpKSYmYi4kYXBwbHkoZnVuY3Rpb24oKXtnLiRzZXRWaWV3VmFsdWUoYT9udWxsOmIuJGV2YWwoZC51aWJCdG5SYWRpbykpLGcuJHJlbmRlcigpfSl9fSksZC51aWJVbmNoZWNrYWJsZSYmYi4kd2F0Y2goaCxmdW5jdGlvbihhKXtkLiRzZXQoXFxcInVuY2hlY2thYmxlXFxcIixhP1xcXCJcXFwiOm51bGwpfSl9fX1dKS5kaXJlY3RpdmUoXFxcInVpYkJ0bkNoZWNrYm94XFxcIixmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOltcXFwidWliQnRuQ2hlY2tib3hcXFwiLFxcXCJuZ01vZGVsXFxcIl0sY29udHJvbGxlcjpcXFwiVWliQnV0dG9uc0NvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwiYnV0dG9uXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZyhjLmJ0bkNoZWNrYm94VHJ1ZSwhMCl9ZnVuY3Rpb24gZigpe3JldHVybiBnKGMuYnRuQ2hlY2tib3hGYWxzZSwhMSl9ZnVuY3Rpb24gZyhiLGMpe3JldHVybiBhbmd1bGFyLmlzRGVmaW5lZChiKT9hLiRldmFsKGIpOmN9dmFyIGg9ZFswXSxpPWRbMV07Yi5maW5kKFxcXCJpbnB1dFxcXCIpLmNzcyh7ZGlzcGxheTpcXFwibm9uZVxcXCJ9KSxpLiRyZW5kZXI9ZnVuY3Rpb24oKXtiLnRvZ2dsZUNsYXNzKGguYWN0aXZlQ2xhc3MsYW5ndWxhci5lcXVhbHMoaS4kbW9kZWxWYWx1ZSxlKCkpKX0sYi5vbihoLnRvZ2dsZUV2ZW50LGZ1bmN0aW9uKCl7Yy5kaXNhYmxlZHx8YS4kYXBwbHkoZnVuY3Rpb24oKXtpLiRzZXRWaWV3VmFsdWUoYi5oYXNDbGFzcyhoLmFjdGl2ZUNsYXNzKT9mKCk6ZSgpKSxpLiRyZW5kZXIoKX0pfSl9fX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuY2Fyb3VzZWxcXFwiLFtdKS5jb250cm9sbGVyKFxcXCJVaWJDYXJvdXNlbENvbnRyb2xsZXJcXFwiLFtcXFwiJHNjb3BlXFxcIixcXFwiJGVsZW1lbnRcXFwiLFxcXCIkaW50ZXJ2YWxcXFwiLFxcXCIkdGltZW91dFxcXCIsXFxcIiRhbmltYXRlXFxcIixmdW5jdGlvbihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoKXtmb3IoO3MubGVuZ3RoOylzLnNoaWZ0KCl9ZnVuY3Rpb24gZyhhKXtpZihhbmd1bGFyLmlzVW5kZWZpbmVkKHBbYV0uaW5kZXgpKXJldHVybiBwW2FdO2Zvcih2YXIgYj0wLGM9cC5sZW5ndGg7Yz5iOysrYilpZihwW2JdLmluZGV4PT09YSlyZXR1cm4gcFtiXX1mdW5jdGlvbiBoKGMsZCxnKXt0fHwoYW5ndWxhci5leHRlbmQoYyx7ZGlyZWN0aW9uOmcsYWN0aXZlOiEwfSksYW5ndWxhci5leHRlbmQoby5jdXJyZW50U2xpZGV8fHt9LHtkaXJlY3Rpb246ZyxhY3RpdmU6ITF9KSxlLmVuYWJsZWQoYikmJiFhLiRjdXJyZW50VHJhbnNpdGlvbiYmYy4kZWxlbWVudCYmby5zbGlkZXMubGVuZ3RoPjEmJihjLiRlbGVtZW50LmRhdGEocSxjLmRpcmVjdGlvbiksby5jdXJyZW50U2xpZGUmJm8uY3VycmVudFNsaWRlLiRlbGVtZW50JiZvLmN1cnJlbnRTbGlkZS4kZWxlbWVudC5kYXRhKHEsYy5kaXJlY3Rpb24pLGEuJGN1cnJlbnRUcmFuc2l0aW9uPSEwLGUub24oXFxcImFkZENsYXNzXFxcIixjLiRlbGVtZW50LGZ1bmN0aW9uKGIsYyl7aWYoXFxcImNsb3NlXFxcIj09PWMmJihhLiRjdXJyZW50VHJhbnNpdGlvbj1udWxsLGUub2ZmKFxcXCJhZGRDbGFzc1xcXCIsYikscy5sZW5ndGgpKXt2YXIgZD1zLnBvcCgpLGc9YS5pbmRleE9mU2xpZGUoZCksaT1nPm8uZ2V0Q3VycmVudEluZGV4KCk/XFxcIm5leHRcXFwiOlxcXCJwcmV2XFxcIjtmKCksaChkLGcsaSl9fSkpLG8uY3VycmVudFNsaWRlPWMscj1kLGsoKSl9ZnVuY3Rpb24gaSgpe20mJihjLmNhbmNlbChtKSxtPW51bGwpfWZ1bmN0aW9uIGooYil7Yi5sZW5ndGh8fChhLiRjdXJyZW50VHJhbnNpdGlvbj1udWxsLGYoKSl9ZnVuY3Rpb24gaygpe2koKTt2YXIgYj0rYS5pbnRlcnZhbDshaXNOYU4oYikmJmI+MCYmKG09YyhsLGIpKX1mdW5jdGlvbiBsKCl7dmFyIGI9K2EuaW50ZXJ2YWw7biYmIWlzTmFOKGIpJiZiPjAmJnAubGVuZ3RoP2EubmV4dCgpOmEucGF1c2UoKX12YXIgbSxuLG89dGhpcyxwPW8uc2xpZGVzPWEuc2xpZGVzPVtdLHE9XFxcInVpYi1zbGlkZURpcmVjdGlvblxcXCIscj0tMSxzPVtdO28uY3VycmVudFNsaWRlPW51bGw7dmFyIHQ9ITE7by5hZGRTbGlkZT1mdW5jdGlvbihiLGMpe2IuJGVsZW1lbnQ9YyxwLnB1c2goYiksMT09PXAubGVuZ3RofHxiLmFjdGl2ZT8oYS4kY3VycmVudFRyYW5zaXRpb24mJihhLiRjdXJyZW50VHJhbnNpdGlvbj1udWxsKSxvLnNlbGVjdChwW3AubGVuZ3RoLTFdKSwxPT09cC5sZW5ndGgmJmEucGxheSgpKTpiLmFjdGl2ZT0hMX0sby5nZXRDdXJyZW50SW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gby5jdXJyZW50U2xpZGUmJmFuZ3VsYXIuaXNEZWZpbmVkKG8uY3VycmVudFNsaWRlLmluZGV4KT8rby5jdXJyZW50U2xpZGUuaW5kZXg6cn0sby5uZXh0PWEubmV4dD1mdW5jdGlvbigpe3ZhciBiPShvLmdldEN1cnJlbnRJbmRleCgpKzEpJXAubGVuZ3RoO3JldHVybiAwPT09YiYmYS5ub1dyYXAoKT92b2lkIGEucGF1c2UoKTpvLnNlbGVjdChnKGIpLFxcXCJuZXh0XFxcIil9LG8ucHJldj1hLnByZXY9ZnVuY3Rpb24oKXt2YXIgYj1vLmdldEN1cnJlbnRJbmRleCgpLTE8MD9wLmxlbmd0aC0xOm8uZ2V0Q3VycmVudEluZGV4KCktMTtyZXR1cm4gYS5ub1dyYXAoKSYmYj09PXAubGVuZ3RoLTE/dm9pZCBhLnBhdXNlKCk6by5zZWxlY3QoZyhiKSxcXFwicHJldlxcXCIpfSxvLnJlbW92ZVNsaWRlPWZ1bmN0aW9uKGEpe2FuZ3VsYXIuaXNEZWZpbmVkKGEuaW5kZXgpJiZwLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4rYS5pbmRleD4rYi5pbmRleH0pO3ZhciBiPXMuaW5kZXhPZihhKTstMSE9PWImJnMuc3BsaWNlKGIsMSk7dmFyIGM9cC5pbmRleE9mKGEpO3Auc3BsaWNlKGMsMSksZChmdW5jdGlvbigpe3AubGVuZ3RoPjAmJmEuYWN0aXZlP2M+PXAubGVuZ3RoP28uc2VsZWN0KHBbYy0xXSk6by5zZWxlY3QocFtjXSk6cj5jJiZyLS19KSwwPT09cC5sZW5ndGgmJihvLmN1cnJlbnRTbGlkZT1udWxsLGYoKSl9LG8uc2VsZWN0PWEuc2VsZWN0PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5pbmRleE9mU2xpZGUoYik7dm9pZCAwPT09YyYmKGM9ZD5vLmdldEN1cnJlbnRJbmRleCgpP1xcXCJuZXh0XFxcIjpcXFwicHJldlxcXCIpLGImJmIhPT1vLmN1cnJlbnRTbGlkZSYmIWEuJGN1cnJlbnRUcmFuc2l0aW9uP2goYixkLGMpOmImJmIhPT1vLmN1cnJlbnRTbGlkZSYmYS4kY3VycmVudFRyYW5zaXRpb24mJihzLnB1c2goYiksYi5hY3RpdmU9ITEpfSxhLmluZGV4T2ZTbGlkZT1mdW5jdGlvbihhKXtyZXR1cm4gYW5ndWxhci5pc0RlZmluZWQoYS5pbmRleCk/K2EuaW5kZXg6cC5pbmRleE9mKGEpfSxhLmlzQWN0aXZlPWZ1bmN0aW9uKGEpe3JldHVybiBvLmN1cnJlbnRTbGlkZT09PWF9LGEucGF1c2U9ZnVuY3Rpb24oKXthLm5vUGF1c2V8fChuPSExLGkoKSl9LGEucGxheT1mdW5jdGlvbigpe258fChuPSEwLGsoKSl9LGEuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXt0PSEwLGkoKX0pLGEuJHdhdGNoKFxcXCJub1RyYW5zaXRpb25cXFwiLGZ1bmN0aW9uKGEpe2UuZW5hYmxlZChiLCFhKX0pLGEuJHdhdGNoKFxcXCJpbnRlcnZhbFxcXCIsayksYS4kd2F0Y2hDb2xsZWN0aW9uKFxcXCJzbGlkZXNcXFwiLGopfV0pLmRpcmVjdGl2ZShcXFwidWliQ2Fyb3VzZWxcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3RyYW5zY2x1ZGU6ITAscmVwbGFjZTohMCxjb250cm9sbGVyOlxcXCJVaWJDYXJvdXNlbENvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwiY2Fyb3VzZWxcXFwiLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFxcXCJ9LHNjb3BlOntpbnRlcnZhbDpcXFwiPVxcXCIsbm9UcmFuc2l0aW9uOlxcXCI9XFxcIixub1BhdXNlOlxcXCI9XFxcIixub1dyYXA6XFxcIiZcXFwifX19KS5kaXJlY3RpdmUoXFxcInVpYlNsaWRlXFxcIixmdW5jdGlvbigpe3JldHVybntyZXF1aXJlOlxcXCJedWliQ2Fyb3VzZWxcXFwiLHRyYW5zY2x1ZGU6ITAscmVwbGFjZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcXFwifSxzY29wZTp7YWN0aXZlOlxcXCI9P1xcXCIsYWN0dWFsOlxcXCI9P1xcXCIsaW5kZXg6XFxcIj0/XFxcIn0sbGluazpmdW5jdGlvbihhLGIsYyxkKXtkLmFkZFNsaWRlKGEsYiksYS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe2QucmVtb3ZlU2xpZGUoYSl9KSxhLiR3YXRjaChcXFwiYWN0aXZlXFxcIixmdW5jdGlvbihiKXtiJiZkLnNlbGVjdChhKX0pfX19KS5hbmltYXRpb24oXFxcIi5pdGVtXFxcIixbXFxcIiRhbmltYXRlQ3NzXFxcIixmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYixjKXthLnJlbW92ZUNsYXNzKGIpLGMmJmMoKX12YXIgYz1cXFwidWliLXNsaWRlRGlyZWN0aW9uXFxcIjtyZXR1cm57YmVmb3JlQWRkQ2xhc3M6ZnVuY3Rpb24oZCxlLGYpe2lmKFxcXCJhY3RpdmVcXFwiPT09ZSl7dmFyIGc9ITEsaD1kLmRhdGEoYyksaT1cXFwibmV4dFxcXCI9PT1oP1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwiLGo9Yi5iaW5kKHRoaXMsZCxpK1xcXCIgXFxcIitoLGYpO3JldHVybiBkLmFkZENsYXNzKGgpLGEoZCx7YWRkQ2xhc3M6aX0pLnN0YXJ0KCkuZG9uZShqKSxmdW5jdGlvbigpe2c9ITB9fWYoKX0sYmVmb3JlUmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oZCxlLGYpe2lmKFxcXCJhY3RpdmVcXFwiPT09ZSl7dmFyIGc9ITEsaD1kLmRhdGEoYyksaT1cXFwibmV4dFxcXCI9PT1oP1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwiLGo9Yi5iaW5kKHRoaXMsZCxpLGYpO3JldHVybiBhKGQse2FkZENsYXNzOml9KS5zdGFydCgpLmRvbmUoaiksZnVuY3Rpb24oKXtnPSEwfX1mKCl9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmRhdGVwYXJzZXJcXFwiLFtdKS5zZXJ2aWNlKFxcXCJ1aWJEYXRlUGFyc2VyXFxcIixbXFxcIiRsb2dcXFwiLFxcXCIkbG9jYWxlXFxcIixcXFwib3JkZXJCeUZpbHRlclxcXCIsZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7dmFyIGI9W10sZD1hLnNwbGl0KFxcXCJcXFwiKSxlPWEuaW5kZXhPZihcXFwiJ1xcXCIpO2lmKGU+LTEpe3ZhciBmPSExO2E9YS5zcGxpdChcXFwiXFxcIik7Zm9yKHZhciBnPWU7ZzxhLmxlbmd0aDtnKyspZj8oXFxcIidcXFwiPT09YVtnXSYmKGcrMTxhLmxlbmd0aCYmXFxcIidcXFwiPT09YVtnKzFdPyhhW2crMV09XFxcIiRcXFwiLGRbZysxXT1cXFwiXFxcIik6KGRbZ109XFxcIlxcXCIsZj0hMSkpLGFbZ109XFxcIiRcXFwiKTpcXFwiJ1xcXCI9PT1hW2ddJiYoYVtnXT1cXFwiJFxcXCIsZFtnXT1cXFwiXFxcIixmPSEwKTthPWEuam9pbihcXFwiXFxcIil9cmV0dXJuIGFuZ3VsYXIuZm9yRWFjaChtLGZ1bmN0aW9uKGMpe3ZhciBlPWEuaW5kZXhPZihjLmtleSk7aWYoZT4tMSl7YT1hLnNwbGl0KFxcXCJcXFwiKSxkW2VdPVxcXCIoXFxcIitjLnJlZ2V4K1xcXCIpXFxcIixhW2VdPVxcXCIkXFxcIjtmb3IodmFyIGY9ZSsxLGc9ZStjLmtleS5sZW5ndGg7Zz5mO2YrKylkW2ZdPVxcXCJcXFwiLGFbZl09XFxcIiRcXFwiO2E9YS5qb2luKFxcXCJcXFwiKSxiLnB1c2goe2luZGV4OmUsYXBwbHk6Yy5hcHBseSxtYXRjaGVyOmMucmVnZXh9KX19KSx7cmVnZXg6bmV3IFJlZ0V4cChcXFwiXlxcXCIrZC5qb2luKFxcXCJcXFwiKStcXFwiJFxcXCIpLG1hcDpjKGIsXFxcImluZGV4XFxcIil9fWZ1bmN0aW9uIGUoYSxiLGMpe3JldHVybiAxPmM/ITE6MT09PWImJmM+Mjg/Mjk9PT1jJiYoYSU0PT09MCYmYSUxMDAhPT0wfHxhJTQwMD09PTApOjM9PT1ifHw1PT09Ynx8OD09PWJ8fDEwPT09Yj8zMT5jOiEwfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIHBhcnNlSW50KGEsMTApfWZ1bmN0aW9uIGcoYSxiKXtyZXR1cm4gYSYmYj9rKGEsYik6YX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuIGEmJmI/ayhhLGIsITApOmF9ZnVuY3Rpb24gaShhLGIpe3ZhciBjPURhdGUucGFyc2UoXFxcIkphbiAwMSwgMTk3MCAwMDowMDowMCBcXFwiK2EpLzZlNDtyZXR1cm4gaXNOYU4oYyk/YjpjfWZ1bmN0aW9uIGooYSxiKXtyZXR1cm4gYT1uZXcgRGF0ZShhLmdldFRpbWUoKSksYS5zZXRNaW51dGVzKGEuZ2V0TWludXRlcygpK2IpLGF9ZnVuY3Rpb24gayhhLGIsYyl7Yz1jPy0xOjE7dmFyIGQ9aShiLGEuZ2V0VGltZXpvbmVPZmZzZXQoKSk7cmV0dXJuIGooYSxjKihkLWEuZ2V0VGltZXpvbmVPZmZzZXQoKSkpfXZhciBsLG0sbj0vW1xcXFxcXFxcXFxcXF5cXFxcJFxcXFwqXFxcXCtcXFxcP1xcXFx8XFxcXFtcXFxcXVxcXFwoXFxcXClcXFxcLlxcXFx7XFxcXH1dL2c7dGhpcy5pbml0PWZ1bmN0aW9uKCl7bD1iLmlkLHRoaXMucGFyc2Vycz17fSxtPVt7a2V5OlxcXCJ5eXl5XFxcIixyZWdleDpcXFwiXFxcXFxcXFxkezR9XFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLnllYXI9K2F9fSx7a2V5OlxcXCJ5eVxcXCIscmVnZXg6XFxcIlxcXFxcXFxcZHsyfVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy55ZWFyPSthKzJlM319LHtrZXk6XFxcInlcXFwiLHJlZ2V4OlxcXCJcXFxcXFxcXGR7MSw0fVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy55ZWFyPSthfX0se2tleTpcXFwiTSFcXFwiLHJlZ2V4OlxcXCIwP1sxLTldfDFbMC0yXVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5tb250aD1hLTF9fSx7a2V5OlxcXCJNTU1NXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguam9pbihcXFwifFxcXCIpLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMubW9udGg9Yi5EQVRFVElNRV9GT1JNQVRTLk1PTlRILmluZGV4T2YoYSl9fSx7a2V5OlxcXCJNTU1cXFwiLHJlZ2V4OmIuREFURVRJTUVfRk9STUFUUy5TSE9SVE1PTlRILmpvaW4oXFxcInxcXFwiKSxhcHBseTpmdW5jdGlvbihhKXt0aGlzLm1vbnRoPWIuREFURVRJTUVfRk9STUFUUy5TSE9SVE1PTlRILmluZGV4T2YoYSl9fSx7a2V5OlxcXCJNTVxcXCIscmVnZXg6XFxcIjBbMS05XXwxWzAtMl1cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMubW9udGg9YS0xfX0se2tleTpcXFwiTVxcXCIscmVnZXg6XFxcIlsxLTldfDFbMC0yXVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5tb250aD1hLTF9fSx7a2V5OlxcXCJkIVxcXCIscmVnZXg6XFxcIlswLTJdP1swLTldezF9fDNbMC0xXXsxfVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5kYXRlPSthfX0se2tleTpcXFwiZGRcXFwiLHJlZ2V4OlxcXCJbMC0yXVswLTldezF9fDNbMC0xXXsxfVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5kYXRlPSthfX0se2tleTpcXFwiZFxcXCIscmVnZXg6XFxcIlsxLTJdP1swLTldezF9fDNbMC0xXXsxfVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5kYXRlPSthfX0se2tleTpcXFwiRUVFRVxcXCIscmVnZXg6Yi5EQVRFVElNRV9GT1JNQVRTLkRBWS5qb2luKFxcXCJ8XFxcIil9LHtrZXk6XFxcIkVFRVxcXCIscmVnZXg6Yi5EQVRFVElNRV9GT1JNQVRTLlNIT1JUREFZLmpvaW4oXFxcInxcXFwiKX0se2tleTpcXFwiSEhcXFwiLHJlZ2V4OlxcXCIoPzowfDEpWzAtOV18MlswLTNdXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmhvdXJzPSthfX0se2tleTpcXFwiaGhcXFwiLHJlZ2V4OlxcXCIwWzAtOV18MVswLTJdXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmhvdXJzPSthfX0se2tleTpcXFwiSFxcXCIscmVnZXg6XFxcIjE/WzAtOV18MlswLTNdXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLmhvdXJzPSthfX0se2tleTpcXFwiaFxcXCIscmVnZXg6XFxcIlswLTldfDFbMC0yXVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5ob3Vycz0rYX19LHtrZXk6XFxcIm1tXFxcIixyZWdleDpcXFwiWzAtNV1bMC05XVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5taW51dGVzPSthfX0se2tleTpcXFwibVxcXCIscmVnZXg6XFxcIlswLTldfFsxLTVdWzAtOV1cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMubWludXRlcz0rYX19LHtrZXk6XFxcInNzc1xcXCIscmVnZXg6XFxcIlswLTldWzAtOV1bMC05XVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dGhpcy5taWxsaXNlY29uZHM9K2F9fSx7a2V5OlxcXCJzc1xcXCIscmVnZXg6XFxcIlswLTVdWzAtOV1cXFwiLGFwcGx5OmZ1bmN0aW9uKGEpe3RoaXMuc2Vjb25kcz0rYX19LHtrZXk6XFxcInNcXFwiLHJlZ2V4OlxcXCJbMC05XXxbMS01XVswLTldXFxcIixhcHBseTpmdW5jdGlvbihhKXt0aGlzLnNlY29uZHM9K2F9fSx7a2V5OlxcXCJhXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuQU1QTVMuam9pbihcXFwifFxcXCIpLGFwcGx5OmZ1bmN0aW9uKGEpezEyPT09dGhpcy5ob3VycyYmKHRoaXMuaG91cnM9MCksXFxcIlBNXFxcIj09PWEmJih0aGlzLmhvdXJzKz0xMil9fSx7a2V5OlxcXCJaXFxcIixyZWdleDpcXFwiWystXVxcXFxcXFxcZHs0fVxcXCIsYXBwbHk6ZnVuY3Rpb24oYSl7dmFyIGI9YS5tYXRjaCgvKFsrLV0pKFxcXFxkezJ9KShcXFxcZHsyfSkvKSxjPWJbMV0sZD1iWzJdLGU9YlszXTt0aGlzLmhvdXJzKz1mKGMrZCksdGhpcy5taW51dGVzKz1mKGMrZSl9fSx7a2V5OlxcXCJ3d1xcXCIscmVnZXg6XFxcIlswLTRdWzAtOV18NVswLTNdXFxcIn0se2tleTpcXFwid1xcXCIscmVnZXg6XFxcIlswLTldfFsxLTRdWzAtOV18NVswLTNdXFxcIn0se2tleTpcXFwiR0dHR1xcXCIscmVnZXg6Yi5EQVRFVElNRV9GT1JNQVRTLkVSQU5BTUVTLmpvaW4oXFxcInxcXFwiKS5yZXBsYWNlKC9cXFxccy9nLFxcXCJcXFxcXFxcXHNcXFwiKX0se2tleTpcXFwiR0dHXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuRVJBUy5qb2luKFxcXCJ8XFxcIil9LHtrZXk6XFxcIkdHXFxcIixyZWdleDpiLkRBVEVUSU1FX0ZPUk1BVFMuRVJBUy5qb2luKFxcXCJ8XFxcIil9LHtrZXk6XFxcIkdcXFwiLHJlZ2V4OmIuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oXFxcInxcXFwiKX1dfSx0aGlzLmluaXQoKSx0aGlzLnBhcnNlPWZ1bmN0aW9uKGMsZixnKXtpZighYW5ndWxhci5pc1N0cmluZyhjKXx8IWYpcmV0dXJuIGM7Zj1iLkRBVEVUSU1FX0ZPUk1BVFNbZl18fGYsZj1mLnJlcGxhY2UobixcXFwiXFxcXFxcXFwkJlxcXCIpLGIuaWQhPT1sJiZ0aGlzLmluaXQoKSx0aGlzLnBhcnNlcnNbZl18fCh0aGlzLnBhcnNlcnNbZl09ZChmKSk7dmFyIGg9dGhpcy5wYXJzZXJzW2ZdLGk9aC5yZWdleCxqPWgubWFwLGs9Yy5tYXRjaChpKSxtPSExO2lmKGsmJmsubGVuZ3RoKXt2YXIgbyxwO2FuZ3VsYXIuaXNEYXRlKGcpJiYhaXNOYU4oZy5nZXRUaW1lKCkpP289e3llYXI6Zy5nZXRGdWxsWWVhcigpLG1vbnRoOmcuZ2V0TW9udGgoKSxkYXRlOmcuZ2V0RGF0ZSgpLGhvdXJzOmcuZ2V0SG91cnMoKSxtaW51dGVzOmcuZ2V0TWludXRlcygpLHNlY29uZHM6Zy5nZXRTZWNvbmRzKCksbWlsbGlzZWNvbmRzOmcuZ2V0TWlsbGlzZWNvbmRzKCl9OihnJiZhLndhcm4oXFxcImRhdGVwYXJzZXI6XFxcIixcXFwiYmFzZURhdGUgaXMgbm90IGEgdmFsaWQgZGF0ZVxcXCIpLG89e3llYXI6MTkwMCxtb250aDowLGRhdGU6MSxob3VyczowLG1pbnV0ZXM6MCxzZWNvbmRzOjAsbWlsbGlzZWNvbmRzOjB9KTtmb3IodmFyIHE9MSxyPWsubGVuZ3RoO3I+cTtxKyspe3ZhciBzPWpbcS0xXTtcXFwiWlxcXCI9PT1zLm1hdGNoZXImJihtPSEwKSxzLmFwcGx5JiZzLmFwcGx5LmNhbGwobyxrW3FdKX12YXIgdD1tP0RhdGUucHJvdG90eXBlLnNldFVUQ0Z1bGxZZWFyOkRhdGUucHJvdG90eXBlLnNldEZ1bGxZZWFyLHU9bT9EYXRlLnByb3RvdHlwZS5zZXRVVENIb3VyczpEYXRlLnByb3RvdHlwZS5zZXRIb3VycztyZXR1cm4gZShvLnllYXIsby5tb250aCxvLmRhdGUpJiYoIWFuZ3VsYXIuaXNEYXRlKGcpfHxpc05hTihnLmdldFRpbWUoKSl8fG0/KHA9bmV3IERhdGUoMCksdC5jYWxsKHAsby55ZWFyLG8ubW9udGgsby5kYXRlKSx1LmNhbGwocCxvLmhvdXJzfHwwLG8ubWludXRlc3x8MCxvLnNlY29uZHN8fDAsby5taWxsaXNlY29uZHN8fDApKToocD1uZXcgRGF0ZShnKSx0LmNhbGwocCxvLnllYXIsby5tb250aCxvLmRhdGUpLHUuY2FsbChwLG8uaG91cnMsby5taW51dGVzLG8uc2Vjb25kcyxvLm1pbGxpc2Vjb25kcykpKSxwfX0sdGhpcy50b1RpbWV6b25lPWcsdGhpcy5mcm9tVGltZXpvbmU9aCx0aGlzLnRpbWV6b25lVG9PZmZzZXQ9aSx0aGlzLmFkZERhdGVNaW51dGVzPWosdGhpcy5jb252ZXJ0VGltZXpvbmVUb0xvY2FsPWt9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5pc0NsYXNzXFxcIixbXSkuZGlyZWN0aXZlKFxcXCJ1aWJJc0NsYXNzXFxcIixbXFxcIiRhbmltYXRlXFxcIixmdW5jdGlvbihhKXt2YXIgYj0vXlxcXFxzKihbXFxcXHNcXFxcU10rPylcXFxccytvblxcXFxzKyhbXFxcXHNcXFxcU10rPylcXFxccyokLyxjPS9eXFxcXHMqKFtcXFxcc1xcXFxTXSs/KVxcXFxzK2ZvclxcXFxzKyhbXFxcXHNcXFxcU10rPylcXFxccyokLztyZXR1cm57cmVzdHJpY3Q6XFxcIkFcXFwiLGNvbXBpbGU6ZnVuY3Rpb24oZCxlKXtmdW5jdGlvbiBmKGEsYixjKXtpLnB1c2goYSksai5wdXNoKHtzY29wZTphLGVsZW1lbnQ6Yn0pLG8uZm9yRWFjaChmdW5jdGlvbihiLGMpe2coYixhKX0pLGEuJG9uKFxcXCIkZGVzdHJveVxcXCIsaCl9ZnVuY3Rpb24gZyhiLGQpe3ZhciBlPWIubWF0Y2goYyksZj1kLiRldmFsKGVbMV0pLGc9ZVsyXSxoPWtbYl07aWYoIWgpe3ZhciBpPWZ1bmN0aW9uKGIpe3ZhciBjPW51bGw7ai5zb21lKGZ1bmN0aW9uKGEpe3ZhciBkPWEuc2NvcGUuJGV2YWwobSk7cmV0dXJuIGQ9PT1iPyhjPWEsITApOnZvaWQgMH0pLGgubGFzdEFjdGl2YXRlZCE9PWMmJihoLmxhc3RBY3RpdmF0ZWQmJmEucmVtb3ZlQ2xhc3MoaC5sYXN0QWN0aXZhdGVkLmVsZW1lbnQsZiksYyYmYS5hZGRDbGFzcyhjLmVsZW1lbnQsZiksaC5sYXN0QWN0aXZhdGVkPWMpfTtrW2JdPWg9e2xhc3RBY3RpdmF0ZWQ6bnVsbCxzY29wZTpkLHdhdGNoRm46aSxjb21wYXJlV2l0aEV4cDpnLHdhdGNoZXI6ZC4kd2F0Y2goZyxpKX19aC53YXRjaEZuKGQuJGV2YWwoZykpfWZ1bmN0aW9uIGgoYSl7dmFyIGI9YS50YXJnZXRTY29wZSxjPWkuaW5kZXhPZihiKTtpZihpLnNwbGljZShjLDEpLGouc3BsaWNlKGMsMSksaS5sZW5ndGgpe3ZhciBkPWlbMF07YW5ndWxhci5mb3JFYWNoKGssZnVuY3Rpb24oYSl7YS5zY29wZT09PWImJihhLndhdGNoZXI9ZC4kd2F0Y2goYS5jb21wYXJlV2l0aEV4cCxhLndhdGNoRm4pLGEuc2NvcGU9ZCl9KX1lbHNlIGs9e319dmFyIGk9W10saj1bXSxrPXt9LGw9ZS51aWJJc0NsYXNzLm1hdGNoKGIpLG09bFsyXSxuPWxbMV0sbz1uLnNwbGl0KFxcXCIsXFxcIik7cmV0dXJuIGZ9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXFxcIixbXSkuZmFjdG9yeShcXFwiJHVpYlBvc2l0aW9uXFxcIixbXFxcIiRkb2N1bWVudFxcXCIsXFxcIiR3aW5kb3dcXFwiLGZ1bmN0aW9uKGEsYil7dmFyIGMsZD17bm9ybWFsOi8oYXV0b3xzY3JvbGwpLyxoaWRkZW46LyhhdXRvfHNjcm9sbHxoaWRkZW4pL30sZT17YXV0bzovXFxcXHM/YXV0bz9cXFxccz8vaSxwcmltYXJ5Oi9eKHRvcHxib3R0b218bGVmdHxyaWdodCkkLyxzZWNvbmRhcnk6L14odG9wfGJvdHRvbXxsZWZ0fHJpZ2h0fGNlbnRlcikkLyx2ZXJ0aWNhbDovXih0b3B8Ym90dG9tKSQvfTtyZXR1cm57Z2V0UmF3Tm9kZTpmdW5jdGlvbihhKXtyZXR1cm4gYVswXXx8YX0scGFyc2VTdHlsZTpmdW5jdGlvbihhKXtyZXR1cm4gYT1wYXJzZUZsb2F0KGEpLGlzRmluaXRlKGEpP2E6MH0sb2Zmc2V0UGFyZW50OmZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoYSl7cmV0dXJuXFxcInN0YXRpY1xcXCI9PT0oYi5nZXRDb21wdXRlZFN0eWxlKGEpLnBvc2l0aW9ufHxcXFwic3RhdGljXFxcIil9Yz10aGlzLmdldFJhd05vZGUoYyk7Zm9yKHZhciBlPWMub2Zmc2V0UGFyZW50fHxhWzBdLmRvY3VtZW50RWxlbWVudDtlJiZlIT09YVswXS5kb2N1bWVudEVsZW1lbnQmJmQoZSk7KWU9ZS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGV8fGFbMF0uZG9jdW1lbnRFbGVtZW50fSxzY3JvbGxiYXJXaWR0aDpmdW5jdGlvbigpe2lmKGFuZ3VsYXIuaXNVbmRlZmluZWQoYykpe3ZhciBiPWFuZ3VsYXIuZWxlbWVudCgnPGRpdiBzdHlsZT1cXFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IC05OTk5cHg7IHdpZHRoOiA1MHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBzY3JvbGw7XFxcIj48L2Rpdj4nKTthLmZpbmQoXFxcImJvZHlcXFwiKS5hcHBlbmQoYiksYz1iWzBdLm9mZnNldFdpZHRoLWJbMF0uY2xpZW50V2lkdGgsYz1pc0Zpbml0ZShjKT9jOjAsYi5yZW1vdmUoKX1yZXR1cm4gY30sc2Nyb2xsUGFyZW50OmZ1bmN0aW9uKGMsZSl7Yz10aGlzLmdldFJhd05vZGUoYyk7dmFyIGY9ZT9kLmhpZGRlbjpkLm5vcm1hbCxnPWFbMF0uZG9jdW1lbnRFbGVtZW50LGg9Yi5nZXRDb21wdXRlZFN0eWxlKGMpLGk9XFxcImFic29sdXRlXFxcIj09PWgucG9zaXRpb24saj1jLnBhcmVudEVsZW1lbnR8fGc7aWYoaj09PWd8fFxcXCJmaXhlZFxcXCI9PT1oLnBvc2l0aW9uKXJldHVybiBnO2Zvcig7ai5wYXJlbnRFbGVtZW50JiZqIT09Zzspe3ZhciBrPWIuZ2V0Q29tcHV0ZWRTdHlsZShqKTtpZihpJiZcXFwic3RhdGljXFxcIiE9PWsucG9zaXRpb24mJihpPSExKSwhaSYmZi50ZXN0KGsub3ZlcmZsb3cray5vdmVyZmxvd1kray5vdmVyZmxvd1gpKWJyZWFrO2o9ai5wYXJlbnRFbGVtZW50fXJldHVybiBqfSxwb3NpdGlvbjpmdW5jdGlvbihjLGQpe2M9dGhpcy5nZXRSYXdOb2RlKGMpO3ZhciBlPXRoaXMub2Zmc2V0KGMpO2lmKGQpe3ZhciBmPWIuZ2V0Q29tcHV0ZWRTdHlsZShjKTtlLnRvcC09dGhpcy5wYXJzZVN0eWxlKGYubWFyZ2luVG9wKSxlLmxlZnQtPXRoaXMucGFyc2VTdHlsZShmLm1hcmdpbkxlZnQpfXZhciBnPXRoaXMub2Zmc2V0UGFyZW50KGMpLGg9e3RvcDowLGxlZnQ6MH07cmV0dXJuIGchPT1hWzBdLmRvY3VtZW50RWxlbWVudCYmKGg9dGhpcy5vZmZzZXQoZyksaC50b3ArPWcuY2xpZW50VG9wLWcuc2Nyb2xsVG9wLGgubGVmdCs9Zy5jbGllbnRMZWZ0LWcuc2Nyb2xsTGVmdCkse3dpZHRoOk1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihlLndpZHRoKT9lLndpZHRoOmMub2Zmc2V0V2lkdGgpLGhlaWdodDpNYXRoLnJvdW5kKGFuZ3VsYXIuaXNOdW1iZXIoZS5oZWlnaHQpP2UuaGVpZ2h0OmMub2Zmc2V0SGVpZ2h0KSx0b3A6TWF0aC5yb3VuZChlLnRvcC1oLnRvcCksbGVmdDpNYXRoLnJvdW5kKGUubGVmdC1oLmxlZnQpfX0sb2Zmc2V0OmZ1bmN0aW9uKGMpe2M9dGhpcy5nZXRSYXdOb2RlKGMpO3ZhciBkPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7cmV0dXJue3dpZHRoOk1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihkLndpZHRoKT9kLndpZHRoOmMub2Zmc2V0V2lkdGgpLGhlaWdodDpNYXRoLnJvdW5kKGFuZ3VsYXIuaXNOdW1iZXIoZC5oZWlnaHQpP2QuaGVpZ2h0OmMub2Zmc2V0SGVpZ2h0KSx0b3A6TWF0aC5yb3VuZChkLnRvcCsoYi5wYWdlWU9mZnNldHx8YVswXS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSksbGVmdDpNYXRoLnJvdW5kKGQubGVmdCsoYi5wYWdlWE9mZnNldHx8YVswXS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkpfX0sdmlld3BvcnRPZmZzZXQ6ZnVuY3Rpb24oYyxkLGUpe2M9dGhpcy5nZXRSYXdOb2RlKGMpLGU9ZSE9PSExPyEwOiExO3ZhciBmPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZz17dG9wOjAsbGVmdDowLGJvdHRvbTowLHJpZ2h0OjB9LGg9ZD9hWzBdLmRvY3VtZW50RWxlbWVudDp0aGlzLnNjcm9sbFBhcmVudChjKSxpPWguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoZy50b3A9aS50b3AraC5jbGllbnRUb3AsZy5sZWZ0PWkubGVmdCtoLmNsaWVudExlZnQsaD09PWFbMF0uZG9jdW1lbnRFbGVtZW50JiYoZy50b3ArPWIucGFnZVlPZmZzZXQsZy5sZWZ0Kz1iLnBhZ2VYT2Zmc2V0KSxnLmJvdHRvbT1nLnRvcCtoLmNsaWVudEhlaWdodCxnLnJpZ2h0PWcubGVmdCtoLmNsaWVudFdpZHRoLGUpe3ZhciBqPWIuZ2V0Q29tcHV0ZWRTdHlsZShoKTtnLnRvcCs9dGhpcy5wYXJzZVN0eWxlKGoucGFkZGluZ1RvcCksZy5ib3R0b20tPXRoaXMucGFyc2VTdHlsZShqLnBhZGRpbmdCb3R0b20pLGcubGVmdCs9dGhpcy5wYXJzZVN0eWxlKGoucGFkZGluZ0xlZnQpLGcucmlnaHQtPXRoaXMucGFyc2VTdHlsZShqLnBhZGRpbmdSaWdodCl9cmV0dXJue3RvcDpNYXRoLnJvdW5kKGYudG9wLWcudG9wKSxib3R0b206TWF0aC5yb3VuZChnLmJvdHRvbS1mLmJvdHRvbSksbGVmdDpNYXRoLnJvdW5kKGYubGVmdC1nLmxlZnQpLHJpZ2h0Ok1hdGgucm91bmQoZy5yaWdodC1mLnJpZ2h0KX19LHBhcnNlUGxhY2VtZW50OmZ1bmN0aW9uKGEpe3ZhciBiPWUuYXV0by50ZXN0KGEpO3JldHVybiBiJiYoYT1hLnJlcGxhY2UoZS5hdXRvLFxcXCJcXFwiKSksYT1hLnNwbGl0KFxcXCItXFxcIiksYVswXT1hWzBdfHxcXFwidG9wXFxcIixlLnByaW1hcnkudGVzdChhWzBdKXx8KGFbMF09XFxcInRvcFxcXCIpLGFbMV09YVsxXXx8XFxcImNlbnRlclxcXCIsZS5zZWNvbmRhcnkudGVzdChhWzFdKXx8KGFbMV09XFxcImNlbnRlclxcXCIpLGI/YVsyXT0hMDphWzJdPSExLGF9LHBvc2l0aW9uRWxlbWVudHM6ZnVuY3Rpb24oYSxjLGQsZil7YT10aGlzLmdldFJhd05vZGUoYSksYz10aGlzLmdldFJhd05vZGUoYyk7dmFyIGc9YW5ndWxhci5pc0RlZmluZWQoYy5vZmZzZXRXaWR0aCk/Yy5vZmZzZXRXaWR0aDpjLnByb3AoXFxcIm9mZnNldFdpZHRoXFxcIiksaD1hbmd1bGFyLmlzRGVmaW5lZChjLm9mZnNldEhlaWdodCk/Yy5vZmZzZXRIZWlnaHQ6Yy5wcm9wKFxcXCJvZmZzZXRIZWlnaHRcXFwiKTtkPXRoaXMucGFyc2VQbGFjZW1lbnQoZCk7dmFyIGk9Zj90aGlzLm9mZnNldChhKTp0aGlzLnBvc2l0aW9uKGEpLGo9e3RvcDowLGxlZnQ6MCxwbGFjZW1lbnQ6XFxcIlxcXCJ9O2lmKGRbMl0pe3ZhciBrPXRoaXMudmlld3BvcnRPZmZzZXQoYSksbD1iLmdldENvbXB1dGVkU3R5bGUoYyksbT17d2lkdGg6ZytNYXRoLnJvdW5kKE1hdGguYWJzKHRoaXMucGFyc2VTdHlsZShsLm1hcmdpbkxlZnQpK3RoaXMucGFyc2VTdHlsZShsLm1hcmdpblJpZ2h0KSkpLGhlaWdodDpoK01hdGgucm91bmQoTWF0aC5hYnModGhpcy5wYXJzZVN0eWxlKGwubWFyZ2luVG9wKSt0aGlzLnBhcnNlU3R5bGUobC5tYXJnaW5Cb3R0b20pKSl9O2lmKGRbMF09XFxcInRvcFxcXCI9PT1kWzBdJiZtLmhlaWdodD5rLnRvcCYmbS5oZWlnaHQ8PWsuYm90dG9tP1xcXCJib3R0b21cXFwiOlxcXCJib3R0b21cXFwiPT09ZFswXSYmbS5oZWlnaHQ+ay5ib3R0b20mJm0uaGVpZ2h0PD1rLnRvcD9cXFwidG9wXFxcIjpcXFwibGVmdFxcXCI9PT1kWzBdJiZtLndpZHRoPmsubGVmdCYmbS53aWR0aDw9ay5yaWdodD9cXFwicmlnaHRcXFwiOlxcXCJyaWdodFxcXCI9PT1kWzBdJiZtLndpZHRoPmsucmlnaHQmJm0ud2lkdGg8PWsubGVmdD9cXFwibGVmdFxcXCI6ZFswXSxkWzFdPVxcXCJ0b3BcXFwiPT09ZFsxXSYmbS5oZWlnaHQtaS5oZWlnaHQ+ay5ib3R0b20mJm0uaGVpZ2h0LWkuaGVpZ2h0PD1rLnRvcD9cXFwiYm90dG9tXFxcIjpcXFwiYm90dG9tXFxcIj09PWRbMV0mJm0uaGVpZ2h0LWkuaGVpZ2h0PmsudG9wJiZtLmhlaWdodC1pLmhlaWdodDw9ay5ib3R0b20/XFxcInRvcFxcXCI6XFxcImxlZnRcXFwiPT09ZFsxXSYmbS53aWR0aC1pLndpZHRoPmsucmlnaHQmJm0ud2lkdGgtaS53aWR0aDw9ay5sZWZ0P1xcXCJyaWdodFxcXCI6XFxcInJpZ2h0XFxcIj09PWRbMV0mJm0ud2lkdGgtaS53aWR0aD5rLmxlZnQmJm0ud2lkdGgtaS53aWR0aDw9ay5yaWdodD9cXFwibGVmdFxcXCI6ZFsxXSxcXFwiY2VudGVyXFxcIj09PWRbMV0paWYoZS52ZXJ0aWNhbC50ZXN0KGRbMF0pKXt2YXIgbj1pLndpZHRoLzItZy8yO2subGVmdCtuPDAmJm0ud2lkdGgtaS53aWR0aDw9ay5yaWdodD9kWzFdPVxcXCJsZWZ0XFxcIjprLnJpZ2h0K248MCYmbS53aWR0aC1pLndpZHRoPD1rLmxlZnQmJihkWzFdPVxcXCJyaWdodFxcXCIpfWVsc2V7dmFyIG89aS5oZWlnaHQvMi1tLmhlaWdodC8yO2sudG9wK288MCYmbS5oZWlnaHQtaS5oZWlnaHQ8PWsuYm90dG9tP2RbMV09XFxcInRvcFxcXCI6ay5ib3R0b20rbzwwJiZtLmhlaWdodC1pLmhlaWdodDw9ay50b3AmJihkWzFdPVxcXCJib3R0b21cXFwiKX19c3dpdGNoKGRbMF0pe2Nhc2VcXFwidG9wXFxcIjpqLnRvcD1pLnRvcC1oO2JyZWFrO2Nhc2VcXFwiYm90dG9tXFxcIjpqLnRvcD1pLnRvcCtpLmhlaWdodDticmVhaztjYXNlXFxcImxlZnRcXFwiOmoubGVmdD1pLmxlZnQtZzticmVhaztjYXNlXFxcInJpZ2h0XFxcIjpqLmxlZnQ9aS5sZWZ0K2kud2lkdGh9c3dpdGNoKGRbMV0pe2Nhc2VcXFwidG9wXFxcIjpqLnRvcD1pLnRvcDticmVhaztjYXNlXFxcImJvdHRvbVxcXCI6ai50b3A9aS50b3AraS5oZWlnaHQtaDticmVhaztjYXNlXFxcImxlZnRcXFwiOmoubGVmdD1pLmxlZnQ7YnJlYWs7Y2FzZVxcXCJyaWdodFxcXCI6ai5sZWZ0PWkubGVmdCtpLndpZHRoLWc7YnJlYWs7Y2FzZVxcXCJjZW50ZXJcXFwiOmUudmVydGljYWwudGVzdChkWzBdKT9qLmxlZnQ9aS5sZWZ0K2kud2lkdGgvMi1nLzI6ai50b3A9aS50b3AraS5oZWlnaHQvMi1oLzJ9cmV0dXJuIGoudG9wPU1hdGgucm91bmQoai50b3ApLGoubGVmdD1NYXRoLnJvdW5kKGoubGVmdCksai5wbGFjZW1lbnQ9XFxcImNlbnRlclxcXCI9PT1kWzFdP2RbMF06ZFswXStcXFwiLVxcXCIrZFsxXSxqfSxwb3NpdGlvbkFycm93OmZ1bmN0aW9uKGEsYyl7YT10aGlzLmdldFJhd05vZGUoYSk7dmFyIGQ9YS5xdWVyeVNlbGVjdG9yKFxcXCIudG9vbHRpcC1pbm5lciwgLnBvcG92ZXItaW5uZXJcXFwiKTtpZihkKXt2YXIgZj1hbmd1bGFyLmVsZW1lbnQoZCkuaGFzQ2xhc3MoXFxcInRvb2x0aXAtaW5uZXJcXFwiKSxnPWY/YS5xdWVyeVNlbGVjdG9yKFxcXCIudG9vbHRpcC1hcnJvd1xcXCIpOmEucXVlcnlTZWxlY3RvcihcXFwiLmFycm93XFxcIik7aWYoZyl7aWYoYz10aGlzLnBhcnNlUGxhY2VtZW50KGMpLFxcXCJjZW50ZXJcXFwiPT09Y1sxXSlyZXR1cm4gdm9pZCBhbmd1bGFyLmVsZW1lbnQoZykuY3NzKHt0b3A6XFxcIlxcXCIsYm90dG9tOlxcXCJcXFwiLHJpZ2h0OlxcXCJcXFwiLGxlZnQ6XFxcIlxcXCIsbWFyZ2luOlxcXCJcXFwifSk7dmFyIGg9XFxcImJvcmRlci1cXFwiK2NbMF0rXFxcIi13aWR0aFxcXCIsaT1iLmdldENvbXB1dGVkU3R5bGUoZylbaF0saj1cXFwiYm9yZGVyLVxcXCI7ais9ZS52ZXJ0aWNhbC50ZXN0KGNbMF0pP2NbMF0rXFxcIi1cXFwiK2NbMV06Y1sxXStcXFwiLVxcXCIrY1swXSxqKz1cXFwiLXJhZGl1c1xcXCI7dmFyIGs9Yi5nZXRDb21wdXRlZFN0eWxlKGY/ZDphKVtqXSxsPXt0b3A6XFxcImF1dG9cXFwiLGJvdHRvbTpcXFwiYXV0b1xcXCIsbGVmdDpcXFwiYXV0b1xcXCIscmlnaHQ6XFxcImF1dG9cXFwiLG1hcmdpbjowfTtzd2l0Y2goY1swXSl7Y2FzZVxcXCJ0b3BcXFwiOmwuYm90dG9tPWY/XFxcIjBcXFwiOlxcXCItXFxcIitpO2JyZWFrO2Nhc2VcXFwiYm90dG9tXFxcIjpsLnRvcD1mP1xcXCIwXFxcIjpcXFwiLVxcXCIraTticmVhaztjYXNlXFxcImxlZnRcXFwiOmwucmlnaHQ9Zj9cXFwiMFxcXCI6XFxcIi1cXFwiK2k7YnJlYWs7Y2FzZVxcXCJyaWdodFxcXCI6bC5sZWZ0PWY/XFxcIjBcXFwiOlxcXCItXFxcIitpfWxbY1sxXV09ayxhbmd1bGFyLmVsZW1lbnQoZykuY3NzKGwpfX19fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJcXFwiLFtcXFwidWkuYm9vdHN0cmFwLmRhdGVwYXJzZXJcXFwiLFxcXCJ1aS5ib290c3RyYXAuaXNDbGFzc1xcXCIsXFxcInVpLmJvb3RzdHJhcC5wb3NpdGlvblxcXCJdKS52YWx1ZShcXFwiJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yXFxcIiwhMSkuY29uc3RhbnQoXFxcInVpYkRhdGVwaWNrZXJDb25maWdcXFwiLHtkYXRlcGlja2VyTW9kZTpcXFwiZGF5XFxcIixmb3JtYXREYXk6XFxcImRkXFxcIixmb3JtYXRNb250aDpcXFwiTU1NTVxcXCIsZm9ybWF0WWVhcjpcXFwieXl5eVxcXCIsZm9ybWF0RGF5SGVhZGVyOlxcXCJFRUVcXFwiLGZvcm1hdERheVRpdGxlOlxcXCJNTU1NIHl5eXlcXFwiLGZvcm1hdE1vbnRoVGl0bGU6XFxcInl5eXlcXFwiLG1heERhdGU6bnVsbCxtYXhNb2RlOlxcXCJ5ZWFyXFxcIixtaW5EYXRlOm51bGwsbWluTW9kZTpcXFwiZGF5XFxcIixuZ01vZGVsT3B0aW9uczp7fSxzaG9ydGN1dFByb3BhZ2F0aW9uOiExLHNob3dXZWVrczohMCx5ZWFyQ29sdW1uczo1LHllYXJSb3dzOjR9KS5jb250cm9sbGVyKFxcXCJVaWJEYXRlcGlja2VyQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkaW50ZXJwb2xhdGVcXFwiLFxcXCIkbG9jYWxlXFxcIixcXFwiJGxvZ1xcXCIsXFxcImRhdGVGaWx0ZXJcXFwiLFxcXCJ1aWJEYXRlcGlja2VyQ29uZmlnXFxcIixcXFwiJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yXFxcIixcXFwidWliRGF0ZVBhcnNlclxcXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksail7dmFyIGs9dGhpcyxsPXskc2V0Vmlld1ZhbHVlOmFuZ3VsYXIubm9vcH0sbT17fSxuPVtdO3RoaXMubW9kZXM9W1xcXCJkYXlcXFwiLFxcXCJtb250aFxcXCIsXFxcInllYXJcXFwiXSxhbmd1bGFyLmZvckVhY2goW1xcXCJmb3JtYXREYXlcXFwiLFxcXCJmb3JtYXRNb250aFxcXCIsXFxcImZvcm1hdFllYXJcXFwiLFxcXCJmb3JtYXREYXlIZWFkZXJcXFwiLFxcXCJmb3JtYXREYXlUaXRsZVxcXCIsXFxcImZvcm1hdE1vbnRoVGl0bGVcXFwiXSxmdW5jdGlvbihjKXtrW2NdPWFuZ3VsYXIuaXNEZWZpbmVkKGJbY10pP2QoYltjXSkoYS4kcGFyZW50KTpoW2NdfSksYW5ndWxhci5mb3JFYWNoKFtcXFwic2hvd1dlZWtzXFxcIixcXFwieWVhclJvd3NcXFwiLFxcXCJ5ZWFyQ29sdW1uc1xcXCIsXFxcInNob3J0Y3V0UHJvcGFnYXRpb25cXFwiXSxmdW5jdGlvbihjKXtrW2NdPWFuZ3VsYXIuaXNEZWZpbmVkKGJbY10pP2EuJHBhcmVudC4kZXZhbChiW2NdKTpoW2NdfSksYW5ndWxhci5pc0RlZmluZWQoYi5zdGFydGluZ0RheSk/ay5zdGFydGluZ0RheT1hLiRwYXJlbnQuJGV2YWwoYi5zdGFydGluZ0RheSk6YW5ndWxhci5pc051bWJlcihoLnN0YXJ0aW5nRGF5KT9rLnN0YXJ0aW5nRGF5PWguc3RhcnRpbmdEYXk6ay5zdGFydGluZ0RheT0oZS5EQVRFVElNRV9GT1JNQVRTLkZJUlNUREFZT0ZXRUVLKzgpJTcsYW5ndWxhci5mb3JFYWNoKFtcXFwibWluRGF0ZVxcXCIsXFxcIm1heERhdGVcXFwiXSxmdW5jdGlvbihjKXtiW2NdP24ucHVzaChhLiRwYXJlbnQuJHdhdGNoKGJbY10sZnVuY3Rpb24oYSl7a1tjXT1hP2FuZ3VsYXIuaXNEYXRlKGEpP2ouZnJvbVRpbWV6b25lKG5ldyBEYXRlKGEpLG0udGltZXpvbmUpOm5ldyBEYXRlKGcoYSxcXFwibWVkaXVtXFxcIikpOm51bGwsay5yZWZyZXNoVmlldygpfSkpOmtbY109aFtjXT9qLmZyb21UaW1lem9uZShuZXcgRGF0ZShoW2NdKSxtLnRpbWV6b25lKTpudWxsfSksYW5ndWxhci5mb3JFYWNoKFtcXFwibWluTW9kZVxcXCIsXFxcIm1heE1vZGVcXFwiXSxmdW5jdGlvbihjKXtiW2NdP24ucHVzaChhLiRwYXJlbnQuJHdhdGNoKGJbY10sZnVuY3Rpb24oZCl7a1tjXT1hW2NdPWFuZ3VsYXIuaXNEZWZpbmVkKGQpP2Q6YltjXSwoXFxcIm1pbk1vZGVcXFwiPT09YyYmay5tb2Rlcy5pbmRleE9mKGEuZGF0ZXBpY2tlck1vZGUpPGsubW9kZXMuaW5kZXhPZihrW2NdKXx8XFxcIm1heE1vZGVcXFwiPT09YyYmay5tb2Rlcy5pbmRleE9mKGEuZGF0ZXBpY2tlck1vZGUpPmsubW9kZXMuaW5kZXhPZihrW2NdKSkmJihhLmRhdGVwaWNrZXJNb2RlPWtbY10pfSkpOmtbY109YVtjXT1oW2NdfHxudWxsfSksYS5kYXRlcGlja2VyTW9kZT1hLmRhdGVwaWNrZXJNb2RlfHxoLmRhdGVwaWNrZXJNb2RlLGEudW5pcXVlSWQ9XFxcImRhdGVwaWNrZXItXFxcIithLiRpZCtcXFwiLVxcXCIrTWF0aC5mbG9vcigxZTQqTWF0aC5yYW5kb20oKSksYW5ndWxhci5pc0RlZmluZWQoYi5pbml0RGF0ZSk/KHRoaXMuYWN0aXZlRGF0ZT1qLmZyb21UaW1lem9uZShhLiRwYXJlbnQuJGV2YWwoYi5pbml0RGF0ZSksbS50aW1lem9uZSl8fG5ldyBEYXRlLG4ucHVzaChhLiRwYXJlbnQuJHdhdGNoKGIuaW5pdERhdGUsZnVuY3Rpb24oYSl7YSYmKGwuJGlzRW1wdHkobC4kbW9kZWxWYWx1ZSl8fGwuJGludmFsaWQpJiYoay5hY3RpdmVEYXRlPWouZnJvbVRpbWV6b25lKGEsbS50aW1lem9uZSksay5yZWZyZXNoVmlldygpKX0pKSk6dGhpcy5hY3RpdmVEYXRlPW5ldyBEYXRlLGEuZGlzYWJsZWQ9YW5ndWxhci5pc0RlZmluZWQoYi5kaXNhYmxlZCl8fCExLGFuZ3VsYXIuaXNEZWZpbmVkKGIubmdEaXNhYmxlZCkmJm4ucHVzaChhLiRwYXJlbnQuJHdhdGNoKGIubmdEaXNhYmxlZCxmdW5jdGlvbihiKXthLmRpc2FibGVkPWIsay5yZWZyZXNoVmlldygpfSkpLGEuaXNBY3RpdmU9ZnVuY3Rpb24oYil7cmV0dXJuIDA9PT1rLmNvbXBhcmUoYi5kYXRlLGsuYWN0aXZlRGF0ZSk/KGEuYWN0aXZlRGF0ZUlkPWIudWlkLCEwKTohMX0sdGhpcy5pbml0PWZ1bmN0aW9uKGEpe2w9YSxtPWEuJG9wdGlvbnN8fGgubmdNb2RlbE9wdGlvbnMsbC4kbW9kZWxWYWx1ZSYmKHRoaXMuYWN0aXZlRGF0ZT1sLiRtb2RlbFZhbHVlKSxsLiRyZW5kZXI9ZnVuY3Rpb24oKXtrLnJlbmRlcigpfX0sdGhpcy5yZW5kZXI9ZnVuY3Rpb24oKXtpZihsLiR2aWV3VmFsdWUpe3ZhciBhPW5ldyBEYXRlKGwuJHZpZXdWYWx1ZSksYj0haXNOYU4oYSk7Yj90aGlzLmFjdGl2ZURhdGU9ai5mcm9tVGltZXpvbmUoYSxtLnRpbWV6b25lKTppfHxmLmVycm9yKCdEYXRlcGlja2VyIGRpcmVjdGl2ZTogXFxcIm5nLW1vZGVsXFxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QnKX10aGlzLnJlZnJlc2hWaWV3KCl9LHRoaXMucmVmcmVzaFZpZXc9ZnVuY3Rpb24oKXtpZih0aGlzLmVsZW1lbnQpe2Euc2VsZWN0ZWREdD1udWxsLHRoaXMuX3JlZnJlc2hWaWV3KCksYS5hY3RpdmVEdCYmKGEuYWN0aXZlRGF0ZUlkPWEuYWN0aXZlRHQudWlkKTt2YXIgYj1sLiR2aWV3VmFsdWU/bmV3IERhdGUobC4kdmlld1ZhbHVlKTpudWxsO2I9ai5mcm9tVGltZXpvbmUoYixtLnRpbWV6b25lKSxsLiRzZXRWYWxpZGl0eShcXFwiZGF0ZURpc2FibGVkXFxcIiwhYnx8dGhpcy5lbGVtZW50JiYhdGhpcy5pc0Rpc2FibGVkKGIpKX19LHRoaXMuY3JlYXRlRGF0ZU9iamVjdD1mdW5jdGlvbihiLGMpe3ZhciBkPWwuJHZpZXdWYWx1ZT9uZXcgRGF0ZShsLiR2aWV3VmFsdWUpOm51bGw7ZD1qLmZyb21UaW1lem9uZShkLG0udGltZXpvbmUpO3ZhciBlPXtkYXRlOmIsbGFiZWw6ZyhiLGMucmVwbGFjZSgvZCEvLFxcXCJkZFxcXCIpKS5yZXBsYWNlKC9NIS8sXFxcIk1NXFxcIiksc2VsZWN0ZWQ6ZCYmMD09PXRoaXMuY29tcGFyZShiLGQpLGRpc2FibGVkOnRoaXMuaXNEaXNhYmxlZChiKSxjdXJyZW50OjA9PT10aGlzLmNvbXBhcmUoYixuZXcgRGF0ZSksY3VzdG9tQ2xhc3M6dGhpcy5jdXN0b21DbGFzcyhiKXx8bnVsbH07cmV0dXJuIGQmJjA9PT10aGlzLmNvbXBhcmUoYixkKSYmKGEuc2VsZWN0ZWREdD1lKSxrLmFjdGl2ZURhdGUmJjA9PT10aGlzLmNvbXBhcmUoZS5kYXRlLGsuYWN0aXZlRGF0ZSkmJihhLmFjdGl2ZUR0PWUpLGV9LHRoaXMuaXNEaXNhYmxlZD1mdW5jdGlvbihjKXtyZXR1cm4gYS5kaXNhYmxlZHx8dGhpcy5taW5EYXRlJiZ0aGlzLmNvbXBhcmUoYyx0aGlzLm1pbkRhdGUpPDB8fHRoaXMubWF4RGF0ZSYmdGhpcy5jb21wYXJlKGMsdGhpcy5tYXhEYXRlKT4wfHxiLmRhdGVEaXNhYmxlZCYmYS5kYXRlRGlzYWJsZWQoe2RhdGU6Yyxtb2RlOmEuZGF0ZXBpY2tlck1vZGV9KX0sdGhpcy5jdXN0b21DbGFzcz1mdW5jdGlvbihiKXtyZXR1cm4gYS5jdXN0b21DbGFzcyh7ZGF0ZTpiLG1vZGU6YS5kYXRlcGlja2VyTW9kZX0pfSx0aGlzLnNwbGl0PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2EubGVuZ3RoPjA7KWMucHVzaChhLnNwbGljZSgwLGIpKTtyZXR1cm4gY30sYS5zZWxlY3Q9ZnVuY3Rpb24oYil7aWYoYS5kYXRlcGlja2VyTW9kZT09PWsubWluTW9kZSl7dmFyIGM9bC4kdmlld1ZhbHVlP2ouZnJvbVRpbWV6b25lKG5ldyBEYXRlKGwuJHZpZXdWYWx1ZSksbS50aW1lem9uZSk6bmV3IERhdGUoMCwwLDAsMCwwLDAsMCk7Yy5zZXRGdWxsWWVhcihiLmdldEZ1bGxZZWFyKCksYi5nZXRNb250aCgpLGIuZ2V0RGF0ZSgpKSxjPWoudG9UaW1lem9uZShjLG0udGltZXpvbmUpLGwuJHNldFZpZXdWYWx1ZShjKSxsLiRyZW5kZXIoKX1lbHNlIGsuYWN0aXZlRGF0ZT1iLGEuZGF0ZXBpY2tlck1vZGU9ay5tb2Rlc1trLm1vZGVzLmluZGV4T2YoYS5kYXRlcGlja2VyTW9kZSktMV19LGEubW92ZT1mdW5jdGlvbihhKXt2YXIgYj1rLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSthKihrLnN0ZXAueWVhcnN8fDApLGM9ay5hY3RpdmVEYXRlLmdldE1vbnRoKCkrYSooay5zdGVwLm1vbnRoc3x8MCk7ay5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKGIsYywxKSxrLnJlZnJlc2hWaWV3KCl9LGEudG9nZ2xlTW9kZT1mdW5jdGlvbihiKXtiPWJ8fDEsYS5kYXRlcGlja2VyTW9kZT09PWsubWF4TW9kZSYmMT09PWJ8fGEuZGF0ZXBpY2tlck1vZGU9PT1rLm1pbk1vZGUmJi0xPT09Ynx8KGEuZGF0ZXBpY2tlck1vZGU9ay5tb2Rlc1trLm1vZGVzLmluZGV4T2YoYS5kYXRlcGlja2VyTW9kZSkrYl0pfSxhLmtleXM9ezEzOlxcXCJlbnRlclxcXCIsMzI6XFxcInNwYWNlXFxcIiwzMzpcXFwicGFnZXVwXFxcIiwzNDpcXFwicGFnZWRvd25cXFwiLDM1OlxcXCJlbmRcXFwiLDM2OlxcXCJob21lXFxcIiwzNzpcXFwibGVmdFxcXCIsMzg6XFxcInVwXFxcIiwzOTpcXFwicmlnaHRcXFwiLDQwOlxcXCJkb3duXFxcIn07dmFyIG89ZnVuY3Rpb24oKXtrLmVsZW1lbnRbMF0uZm9jdXMoKX07YS4kb24oXFxcInVpYjpkYXRlcGlja2VyLmZvY3VzXFxcIixvKSxhLmtleWRvd249ZnVuY3Rpb24oYil7dmFyIGM9YS5rZXlzW2Iud2hpY2hdO2lmKGMmJiFiLnNoaWZ0S2V5JiYhYi5hbHRLZXkmJiFhLmRpc2FibGVkKWlmKGIucHJldmVudERlZmF1bHQoKSxrLnNob3J0Y3V0UHJvcGFnYXRpb258fGIuc3RvcFByb3BhZ2F0aW9uKCksXFxcImVudGVyXFxcIj09PWN8fFxcXCJzcGFjZVxcXCI9PT1jKXtpZihrLmlzRGlzYWJsZWQoay5hY3RpdmVEYXRlKSlyZXR1cm47YS5zZWxlY3Qoay5hY3RpdmVEYXRlKX1lbHNlIWIuY3RybEtleXx8XFxcInVwXFxcIiE9PWMmJlxcXCJkb3duXFxcIiE9PWM/KGsuaGFuZGxlS2V5RG93bihjLGIpLGsucmVmcmVzaFZpZXcoKSk6YS50b2dnbGVNb2RlKFxcXCJ1cFxcXCI9PT1jPzE6LTEpfSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Zm9yKDtuLmxlbmd0aDspbi5zaGlmdCgpKCl9KX1dKS5jb250cm9sbGVyKFxcXCJVaWJEYXlwaWNrZXJDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRlbGVtZW50XFxcIixcXFwiZGF0ZUZpbHRlclxcXCIsZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSxiKXtyZXR1cm4gMSE9PWJ8fGElNCE9PTB8fGElMTAwPT09MCYmYSU0MDAhPT0wP2ZbYl06Mjl9ZnVuY3Rpb24gZShhKXt2YXIgYj1uZXcgRGF0ZShhKTtiLnNldERhdGUoYi5nZXREYXRlKCkrNC0oYi5nZXREYXkoKXx8NykpO3ZhciBjPWIuZ2V0VGltZSgpO3JldHVybiBiLnNldE1vbnRoKDApLGIuc2V0RGF0ZSgxKSxNYXRoLmZsb29yKE1hdGgucm91bmQoKGMtYikvODY0ZTUpLzcpKzF9dmFyIGY9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTt0aGlzLnN0ZXA9e21vbnRoczoxfSx0aGlzLmVsZW1lbnQ9Yix0aGlzLmluaXQ9ZnVuY3Rpb24oYil7YW5ndWxhci5leHRlbmQoYix0aGlzKSxhLnNob3dXZWVrcz1iLnNob3dXZWVrcyxiLnJlZnJlc2hWaWV3KCl9LHRoaXMuZ2V0RGF0ZXM9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD1uZXcgQXJyYXkoYiksZT1uZXcgRGF0ZShhKSxmPTA7Yj5mOyljPW5ldyBEYXRlKGUpLGRbZisrXT1jLGUuc2V0RGF0ZShlLmdldERhdGUoKSsxKTtyZXR1cm4gZH0sdGhpcy5fcmVmcmVzaFZpZXc9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSxkPXRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpLGY9bmV3IERhdGUodGhpcy5hY3RpdmVEYXRlKTtmLnNldEZ1bGxZZWFyKGIsZCwxKTt2YXIgZz10aGlzLnN0YXJ0aW5nRGF5LWYuZ2V0RGF5KCksaD1nPjA/Ny1nOi1nLGk9bmV3IERhdGUoZik7aD4wJiZpLnNldERhdGUoLWgrMSk7Zm9yKHZhciBqPXRoaXMuZ2V0RGF0ZXMoaSw0Miksaz0wOzQyPms7aysrKWpba109YW5ndWxhci5leHRlbmQodGhpcy5jcmVhdGVEYXRlT2JqZWN0KGpba10sdGhpcy5mb3JtYXREYXkpLHtzZWNvbmRhcnk6altrXS5nZXRNb250aCgpIT09ZCx1aWQ6YS51bmlxdWVJZCtcXFwiLVxcXCIra30pO2EubGFiZWxzPW5ldyBBcnJheSg3KTtmb3IodmFyIGw9MDs3Pmw7bCsrKWEubGFiZWxzW2xdPXthYmJyOmMoaltsXS5kYXRlLHRoaXMuZm9ybWF0RGF5SGVhZGVyKSxmdWxsOmMoaltsXS5kYXRlLFxcXCJFRUVFXFxcIil9O2lmKGEudGl0bGU9Yyh0aGlzLmFjdGl2ZURhdGUsdGhpcy5mb3JtYXREYXlUaXRsZSksYS5yb3dzPXRoaXMuc3BsaXQoaiw3KSxhLnNob3dXZWVrcyl7YS53ZWVrTnVtYmVycz1bXTtmb3IodmFyIG09KDExLXRoaXMuc3RhcnRpbmdEYXkpJTcsbj1hLnJvd3MubGVuZ3RoLG89MDtuPm87bysrKWEud2Vla051bWJlcnMucHVzaChlKGEucm93c1tvXVttXS5kYXRlKSl9fSx0aGlzLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRGF0ZShhLmdldEZ1bGxZZWFyKCksYS5nZXRNb250aCgpLGEuZ2V0RGF0ZSgpKSxkPW5ldyBEYXRlKGIuZ2V0RnVsbFllYXIoKSxiLmdldE1vbnRoKCksYi5nZXREYXRlKCkpO3JldHVybiBjLnNldEZ1bGxZZWFyKGEuZ2V0RnVsbFllYXIoKSksZC5zZXRGdWxsWWVhcihiLmdldEZ1bGxZZWFyKCkpLGMtZH0sdGhpcy5oYW5kbGVLZXlEb3duPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hY3RpdmVEYXRlLmdldERhdGUoKTtpZihcXFwibGVmdFxcXCI9PT1hKWMtPTE7ZWxzZSBpZihcXFwidXBcXFwiPT09YSljLT03O2Vsc2UgaWYoXFxcInJpZ2h0XFxcIj09PWEpYys9MTtlbHNlIGlmKFxcXCJkb3duXFxcIj09PWEpYys9NztlbHNlIGlmKFxcXCJwYWdldXBcXFwiPT09YXx8XFxcInBhZ2Vkb3duXFxcIj09PWEpe3ZhciBlPXRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpKyhcXFwicGFnZXVwXFxcIj09PWE/LTE6MSk7dGhpcy5hY3RpdmVEYXRlLnNldE1vbnRoKGUsMSksYz1NYXRoLm1pbihkKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpKSxjKX1lbHNlXFxcImhvbWVcXFwiPT09YT9jPTE6XFxcImVuZFxcXCI9PT1hJiYoYz1kKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpKSk7dGhpcy5hY3RpdmVEYXRlLnNldERhdGUoYyl9fV0pLmNvbnRyb2xsZXIoXFxcIlVpYk1vbnRocGlja2VyQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkZWxlbWVudFxcXCIsXFxcImRhdGVGaWx0ZXJcXFwiLGZ1bmN0aW9uKGEsYixjKXt0aGlzLnN0ZXA9e3llYXJzOjF9LHRoaXMuZWxlbWVudD1iLHRoaXMuaW5pdD1mdW5jdGlvbihhKXthbmd1bGFyLmV4dGVuZChhLHRoaXMpLGEucmVmcmVzaFZpZXcoKX0sdGhpcy5fcmVmcmVzaFZpZXc9ZnVuY3Rpb24oKXtmb3IodmFyIGIsZD1uZXcgQXJyYXkoMTIpLGU9dGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksZj0wOzEyPmY7ZisrKWI9bmV3IERhdGUodGhpcy5hY3RpdmVEYXRlKSxiLnNldEZ1bGxZZWFyKGUsZiwxKSxkW2ZdPWFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChiLHRoaXMuZm9ybWF0TW9udGgpLHt1aWQ6YS51bmlxdWVJZCtcXFwiLVxcXCIrZn0pO2EudGl0bGU9Yyh0aGlzLmFjdGl2ZURhdGUsdGhpcy5mb3JtYXRNb250aFRpdGxlKSxhLnJvd3M9dGhpcy5zcGxpdChkLDMpfSx0aGlzLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgRGF0ZShhLmdldEZ1bGxZZWFyKCksYS5nZXRNb250aCgpKSxkPW5ldyBEYXRlKGIuZ2V0RnVsbFllYXIoKSxiLmdldE1vbnRoKCkpO3JldHVybiBjLnNldEZ1bGxZZWFyKGEuZ2V0RnVsbFllYXIoKSksZC5zZXRGdWxsWWVhcihiLmdldEZ1bGxZZWFyKCkpLGMtZH0sdGhpcy5oYW5kbGVLZXlEb3duPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hY3RpdmVEYXRlLmdldE1vbnRoKCk7aWYoXFxcImxlZnRcXFwiPT09YSljLT0xO2Vsc2UgaWYoXFxcInVwXFxcIj09PWEpYy09MztlbHNlIGlmKFxcXCJyaWdodFxcXCI9PT1hKWMrPTE7ZWxzZSBpZihcXFwiZG93blxcXCI9PT1hKWMrPTM7ZWxzZSBpZihcXFwicGFnZXVwXFxcIj09PWF8fFxcXCJwYWdlZG93blxcXCI9PT1hKXt2YXIgZD10aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSsoXFxcInBhZ2V1cFxcXCI9PT1hPy0xOjEpO3RoaXMuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcihkKX1lbHNlXFxcImhvbWVcXFwiPT09YT9jPTA6XFxcImVuZFxcXCI9PT1hJiYoYz0xMSk7dGhpcy5hY3RpdmVEYXRlLnNldE1vbnRoKGMpfX1dKS5jb250cm9sbGVyKFxcXCJVaWJZZWFycGlja2VyQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkZWxlbWVudFxcXCIsXFxcImRhdGVGaWx0ZXJcXFwiLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3JldHVybiBwYXJzZUludCgoYS0xKS9mLDEwKSpmKzF9dmFyIGUsZjt0aGlzLmVsZW1lbnQ9Yix0aGlzLnllYXJwaWNrZXJJbml0PWZ1bmN0aW9uKCl7ZT10aGlzLnllYXJDb2x1bW5zLGY9dGhpcy55ZWFyUm93cyplLHRoaXMuc3RlcD17eWVhcnM6Zn19LHRoaXMuX3JlZnJlc2hWaWV3PWZ1bmN0aW9uKCl7Zm9yKHZhciBiLGM9bmV3IEFycmF5KGYpLGc9MCxoPWQodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpO2Y+ZztnKyspYj1uZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpLGIuc2V0RnVsbFllYXIoaCtnLDAsMSksY1tnXT1hbmd1bGFyLmV4dGVuZCh0aGlzLmNyZWF0ZURhdGVPYmplY3QoYix0aGlzLmZvcm1hdFllYXIpLHt1aWQ6YS51bmlxdWVJZCtcXFwiLVxcXCIrZ30pO2EudGl0bGU9W2NbMF0ubGFiZWwsY1tmLTFdLmxhYmVsXS5qb2luKFxcXCIgLSBcXFwiKSxhLnJvd3M9dGhpcy5zcGxpdChjLGUpLGEuY29sdW1ucz1lfSx0aGlzLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5nZXRGdWxsWWVhcigpLWIuZ2V0RnVsbFllYXIoKX0sdGhpcy5oYW5kbGVLZXlEb3duPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCk7XFxcImxlZnRcXFwiPT09YT9jLT0xOlxcXCJ1cFxcXCI9PT1hP2MtPWU6XFxcInJpZ2h0XFxcIj09PWE/Yys9MTpcXFwiZG93blxcXCI9PT1hP2MrPWU6XFxcInBhZ2V1cFxcXCI9PT1hfHxcXFwicGFnZWRvd25cXFwiPT09YT9jKz0oXFxcInBhZ2V1cFxcXCI9PT1hPy0xOjEpKmY6XFxcImhvbWVcXFwiPT09YT9jPWQodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpOlxcXCJlbmRcXFwiPT09YSYmKGM9ZCh0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSkrZi0xKSx0aGlzLmFjdGl2ZURhdGUuc2V0RnVsbFllYXIoYyl9fV0pLmRpcmVjdGl2ZShcXFwidWliRGF0ZXBpY2tlclxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXFxcIn0sc2NvcGU6e2RhdGVwaWNrZXJNb2RlOlxcXCI9P1xcXCIsZGF0ZURpc2FibGVkOlxcXCImXFxcIixjdXN0b21DbGFzczpcXFwiJlxcXCIsc2hvcnRjdXRQcm9wYWdhdGlvbjpcXFwiJj9cXFwifSxyZXF1aXJlOltcXFwidWliRGF0ZXBpY2tlclxcXCIsXFxcIl5uZ01vZGVsXFxcIl0sY29udHJvbGxlcjpcXFwiVWliRGF0ZXBpY2tlckNvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwiZGF0ZXBpY2tlclxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kWzBdLGY9ZFsxXTtlLmluaXQoZil9fX0pLmRpcmVjdGl2ZShcXFwidWliRGF5cGlja2VyXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFxcXCI7XFxufSxyZXF1aXJlOltcXFwiXnVpYkRhdGVwaWNrZXJcXFwiLFxcXCJ1aWJEYXlwaWNrZXJcXFwiXSxjb250cm9sbGVyOlxcXCJVaWJEYXlwaWNrZXJDb250cm9sbGVyXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF0sZj1kWzFdO2YuaW5pdChlKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJNb250aHBpY2tlclxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCx0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFxcXCJ9LHJlcXVpcmU6W1xcXCJedWliRGF0ZXBpY2tlclxcXCIsXFxcInVpYk1vbnRocGlja2VyXFxcIl0sY29udHJvbGxlcjpcXFwiVWliTW9udGhwaWNrZXJDb250cm9sbGVyXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF0sZj1kWzFdO2YuaW5pdChlKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJZZWFycGlja2VyXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci95ZWFyLmh0bWxcXFwifSxyZXF1aXJlOltcXFwiXnVpYkRhdGVwaWNrZXJcXFwiLFxcXCJ1aWJZZWFycGlja2VyXFxcIl0sY29udHJvbGxlcjpcXFwiVWliWWVhcnBpY2tlckNvbnRyb2xsZXJcXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZFswXTthbmd1bGFyLmV4dGVuZChlLGRbMV0pLGUueWVhcnBpY2tlckluaXQoKSxlLnJlZnJlc2hWaWV3KCl9fX0pLmNvbnN0YW50KFxcXCJ1aWJEYXRlcGlja2VyUG9wdXBDb25maWdcXFwiLHthbHRJbnB1dEZvcm1hdHM6W10sYXBwZW5kVG9Cb2R5OiExLGNsZWFyVGV4dDpcXFwiQ2xlYXJcXFwiLGNsb3NlT25EYXRlU2VsZWN0aW9uOiEwLGNsb3NlVGV4dDpcXFwiRG9uZVxcXCIsY3VycmVudFRleHQ6XFxcIlRvZGF5XFxcIixkYXRlcGlja2VyUG9wdXA6XFxcInl5eXktTU0tZGRcXFwiLGRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXFxcIixkYXRlcGlja2VyVGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFxcXCIsaHRtbDVUeXBlczp7ZGF0ZTpcXFwieXl5eS1NTS1kZFxcXCIsXFxcImRhdGV0aW1lLWxvY2FsXFxcIjpcXFwieXl5eS1NTS1kZFRISDptbTpzcy5zc3NcXFwiLG1vbnRoOlxcXCJ5eXl5LU1NXFxcIn0sb25PcGVuRm9jdXM6ITAsc2hvd0J1dHRvbkJhcjohMH0pLmNvbnRyb2xsZXIoXFxcIlVpYkRhdGVwaWNrZXJQb3B1cENvbnRyb2xsZXJcXFwiLFtcXFwiJHNjb3BlXFxcIixcXFwiJGVsZW1lbnRcXFwiLFxcXCIkYXR0cnNcXFwiLFxcXCIkY29tcGlsZVxcXCIsXFxcIiRwYXJzZVxcXCIsXFxcIiRkb2N1bWVudFxcXCIsXFxcIiRyb290U2NvcGVcXFwiLFxcXCIkdWliUG9zaXRpb25cXFwiLFxcXCJkYXRlRmlsdGVyXFxcIixcXFwidWliRGF0ZVBhcnNlclxcXCIsXFxcInVpYkRhdGVwaWNrZXJQb3B1cENvbmZpZ1xcXCIsXFxcIiR0aW1lb3V0XFxcIixcXFwidWliRGF0ZXBpY2tlckNvbmZpZ1xcXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSl7ZnVuY3Rpb24gbihhKXtyZXR1cm4gYS5yZXBsYWNlKC8oW0EtWl0pL2csZnVuY3Rpb24oYSl7cmV0dXJuXFxcIi1cXFwiK2EudG9Mb3dlckNhc2UoKX0pfWZ1bmN0aW9uIG8oYil7dmFyIGM9ai5wYXJzZShiLHQsYS5kYXRlKTtpZihpc05hTihjKSlmb3IodmFyIGQ9MDtkPEUubGVuZ3RoO2QrKylpZihjPWoucGFyc2UoYixFW2RdLGEuZGF0ZSksIWlzTmFOKGMpKXJldHVybiBjO3JldHVybiBjfWZ1bmN0aW9uIHAoYSl7aWYoYW5ndWxhci5pc051bWJlcihhKSYmKGE9bmV3IERhdGUoYSkpLCFhKXJldHVybiBudWxsO2lmKGFuZ3VsYXIuaXNEYXRlKGEpJiYhaXNOYU4oYSkpcmV0dXJuIGE7aWYoYW5ndWxhci5pc1N0cmluZyhhKSl7dmFyIGI9byhhKTtpZighaXNOYU4oYikpcmV0dXJuIGoudG9UaW1lem9uZShiLEMudGltZXpvbmUpfXJldHVybiBCLiRvcHRpb25zJiZCLiRvcHRpb25zLmFsbG93SW52YWxpZD9hOnZvaWQgMH1mdW5jdGlvbiBxKGEsYil7dmFyIGQ9YXx8YjtyZXR1cm4gYy5uZ1JlcXVpcmVkfHxkPyhhbmd1bGFyLmlzTnVtYmVyKGQpJiYoZD1uZXcgRGF0ZShkKSksZD9hbmd1bGFyLmlzRGF0ZShkKSYmIWlzTmFOKGQpPyEwOmFuZ3VsYXIuaXNTdHJpbmcoZCk/IWlzTmFOKG8oYikpOiExOiEwKTohMH1mdW5jdGlvbiByKGMpe2lmKGEuaXNPcGVufHwhYS5kaXNhYmxlZCl7dmFyIGQ9RFswXSxlPWJbMF0uY29udGFpbnMoYy50YXJnZXQpLGY9dm9pZCAwIT09ZC5jb250YWlucyYmZC5jb250YWlucyhjLnRhcmdldCk7IWEuaXNPcGVufHxlfHxmfHxhLiRhcHBseShmdW5jdGlvbigpe2EuaXNPcGVuPSExfSl9fWZ1bmN0aW9uIHMoYyl7Mjc9PT1jLndoaWNoJiZhLmlzT3Blbj8oYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksYS4kYXBwbHkoZnVuY3Rpb24oKXthLmlzT3Blbj0hMX0pLGJbMF0uZm9jdXMoKSk6NDAhPT1jLndoaWNofHxhLmlzT3Blbnx8KGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGEuJGFwcGx5KGZ1bmN0aW9uKCl7YS5pc09wZW49ITB9KSl9dmFyIHQsdSx2LHcseCx5LHosQSxCLEMsRCxFLEY9e30sRz0hMSxIPVtdO2Eud2F0Y2hEYXRhPXt9LHRoaXMuaW5pdD1mdW5jdGlvbihoKXtpZihCPWgsQz1oLiRvcHRpb25zfHxtLm5nTW9kZWxPcHRpb25zLHU9YW5ndWxhci5pc0RlZmluZWQoYy5jbG9zZU9uRGF0ZVNlbGVjdGlvbik/YS4kcGFyZW50LiRldmFsKGMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pOmsuY2xvc2VPbkRhdGVTZWxlY3Rpb24sdj1hbmd1bGFyLmlzRGVmaW5lZChjLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpP2EuJHBhcmVudC4kZXZhbChjLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpOmsuYXBwZW5kVG9Cb2R5LHc9YW5ndWxhci5pc0RlZmluZWQoYy5vbk9wZW5Gb2N1cyk/YS4kcGFyZW50LiRldmFsKGMub25PcGVuRm9jdXMpOmsub25PcGVuRm9jdXMseD1hbmd1bGFyLmlzRGVmaW5lZChjLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsKT9jLmRhdGVwaWNrZXJQb3B1cFRlbXBsYXRlVXJsOmsuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwseT1hbmd1bGFyLmlzRGVmaW5lZChjLmRhdGVwaWNrZXJUZW1wbGF0ZVVybCk/Yy5kYXRlcGlja2VyVGVtcGxhdGVVcmw6ay5kYXRlcGlja2VyVGVtcGxhdGVVcmwsRT1hbmd1bGFyLmlzRGVmaW5lZChjLmFsdElucHV0Rm9ybWF0cyk/YS4kcGFyZW50LiRldmFsKGMuYWx0SW5wdXRGb3JtYXRzKTprLmFsdElucHV0Rm9ybWF0cyxhLnNob3dCdXR0b25CYXI9YW5ndWxhci5pc0RlZmluZWQoYy5zaG93QnV0dG9uQmFyKT9hLiRwYXJlbnQuJGV2YWwoYy5zaG93QnV0dG9uQmFyKTprLnNob3dCdXR0b25CYXIsay5odG1sNVR5cGVzW2MudHlwZV0/KHQ9ay5odG1sNVR5cGVzW2MudHlwZV0sRz0hMCk6KHQ9Yy51aWJEYXRlcGlja2VyUG9wdXB8fGsuZGF0ZXBpY2tlclBvcHVwLGMuJG9ic2VydmUoXFxcInVpYkRhdGVwaWNrZXJQb3B1cFxcXCIsZnVuY3Rpb24oYSxiKXt2YXIgYz1hfHxrLmRhdGVwaWNrZXJQb3B1cDtpZihjIT09dCYmKHQ9YyxCLiRtb2RlbFZhbHVlPW51bGwsIXQpKXRocm93IG5ldyBFcnJvcihcXFwidWliRGF0ZXBpY2tlclBvcHVwIG11c3QgaGF2ZSBhIGRhdGUgZm9ybWF0IHNwZWNpZmllZC5cXFwiKX0pKSwhdCl0aHJvdyBuZXcgRXJyb3IoXFxcInVpYkRhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuXFxcIik7aWYoRyYmYy51aWJEYXRlcGlja2VyUG9wdXApdGhyb3cgbmV3IEVycm9yKFxcXCJIVE1MNSBkYXRlIGlucHV0IHR5cGVzIGRvIG5vdCBzdXBwb3J0IGN1c3RvbSBmb3JtYXRzLlxcXCIpO3o9YW5ndWxhci5lbGVtZW50KFxcXCI8ZGl2IHVpYi1kYXRlcGlja2VyLXBvcHVwLXdyYXA+PGRpdiB1aWItZGF0ZXBpY2tlcj48L2Rpdj48L2Rpdj5cXFwiKSxhLm5nTW9kZWxPcHRpb25zPWFuZ3VsYXIuY29weShDKSxhLm5nTW9kZWxPcHRpb25zLnRpbWV6b25lPW51bGwsei5hdHRyKHtcXFwibmctbW9kZWxcXFwiOlxcXCJkYXRlXFxcIixcXFwibmctbW9kZWwtb3B0aW9uc1xcXCI6XFxcIm5nTW9kZWxPcHRpb25zXFxcIixcXFwibmctY2hhbmdlXFxcIjpcXFwiZGF0ZVNlbGVjdGlvbihkYXRlKVxcXCIsXFxcInRlbXBsYXRlLXVybFxcXCI6eH0pLEE9YW5ndWxhci5lbGVtZW50KHouY2hpbGRyZW4oKVswXSksQS5hdHRyKFxcXCJ0ZW1wbGF0ZS11cmxcXFwiLHkpLEcmJlxcXCJtb250aFxcXCI9PT1jLnR5cGUmJihBLmF0dHIoXFxcImRhdGVwaWNrZXItbW9kZVxcXCIsJ1xcXCJtb250aFxcXCInKSxBLmF0dHIoXFxcIm1pbi1tb2RlXFxcIixcXFwibW9udGhcXFwiKSksYS5kYXRlcGlja2VyT3B0aW9ucyYmYW5ndWxhci5mb3JFYWNoKGEuZGF0ZXBpY2tlck9wdGlvbnMsZnVuY3Rpb24oYSxiKXstMT09PVtcXFwibWluRGF0ZVxcXCIsXFxcIm1heERhdGVcXFwiLFxcXCJtaW5Nb2RlXFxcIixcXFwibWF4TW9kZVxcXCIsXFxcImluaXREYXRlXFxcIixcXFwiZGF0ZXBpY2tlck1vZGVcXFwiXS5pbmRleE9mKGIpP0EuYXR0cihuKGIpLGEpOkEuYXR0cihuKGIpLFxcXCJkYXRlcGlja2VyT3B0aW9ucy5cXFwiK2IpfSksYW5ndWxhci5mb3JFYWNoKFtcXFwibWluTW9kZVxcXCIsXFxcIm1heE1vZGVcXFwiLFxcXCJkYXRlcGlja2VyTW9kZVxcXCIsXFxcInNob3J0Y3V0UHJvcGFnYXRpb25cXFwiXSxmdW5jdGlvbihiKXtpZihjW2JdKXt2YXIgZD1lKGNbYl0pLGY9e2dldDpmdW5jdGlvbigpe3JldHVybiBkKGEuJHBhcmVudCl9fTtpZihBLmF0dHIobihiKSxcXFwid2F0Y2hEYXRhLlxcXCIrYiksXFxcImRhdGVwaWNrZXJNb2RlXFxcIj09PWIpe3ZhciBnPWQuYXNzaWduO2Yuc2V0PWZ1bmN0aW9uKGIpe2coYS4kcGFyZW50LGIpfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoYS53YXRjaERhdGEsYixmKX19KSxhbmd1bGFyLmZvckVhY2goW1xcXCJtaW5EYXRlXFxcIixcXFwibWF4RGF0ZVxcXCIsXFxcImluaXREYXRlXFxcIl0sZnVuY3Rpb24oYil7aWYoY1tiXSl7dmFyIGQ9ZShjW2JdKTtILnB1c2goYS4kcGFyZW50LiR3YXRjaChkLGZ1bmN0aW9uKGMpe1xcXCJtaW5EYXRlXFxcIj09PWJ8fFxcXCJtYXhEYXRlXFxcIj09PWI/KG51bGw9PT1jP0ZbYl09bnVsbDphbmd1bGFyLmlzRGF0ZShjKT9GW2JdPWouZnJvbVRpbWV6b25lKG5ldyBEYXRlKGMpLEMudGltZXpvbmUpOkZbYl09bmV3IERhdGUoaShjLFxcXCJtZWRpdW1cXFwiKSksYS53YXRjaERhdGFbYl09bnVsbD09PWM/bnVsbDpGW2JdKTphLndhdGNoRGF0YVtiXT1qLmZyb21UaW1lem9uZShuZXcgRGF0ZShjKSxDLnRpbWV6b25lKX0pKSxBLmF0dHIobihiKSxcXFwid2F0Y2hEYXRhLlxcXCIrYil9fSksYy5kYXRlRGlzYWJsZWQmJkEuYXR0cihcXFwiZGF0ZS1kaXNhYmxlZFxcXCIsXFxcImRhdGVEaXNhYmxlZCh7IGRhdGU6IGRhdGUsIG1vZGU6IG1vZGUgfSlcXFwiKSxhbmd1bGFyLmZvckVhY2goW1xcXCJmb3JtYXREYXlcXFwiLFxcXCJmb3JtYXRNb250aFxcXCIsXFxcImZvcm1hdFllYXJcXFwiLFxcXCJmb3JtYXREYXlIZWFkZXJcXFwiLFxcXCJmb3JtYXREYXlUaXRsZVxcXCIsXFxcImZvcm1hdE1vbnRoVGl0bGVcXFwiLFxcXCJzaG93V2Vla3NcXFwiLFxcXCJzdGFydGluZ0RheVxcXCIsXFxcInllYXJSb3dzXFxcIixcXFwieWVhckNvbHVtbnNcXFwiXSxmdW5jdGlvbihhKXthbmd1bGFyLmlzRGVmaW5lZChjW2FdKSYmQS5hdHRyKG4oYSksY1thXSl9KSxjLmN1c3RvbUNsYXNzJiZBLmF0dHIoXFxcImN1c3RvbS1jbGFzc1xcXCIsXFxcImN1c3RvbUNsYXNzKHsgZGF0ZTogZGF0ZSwgbW9kZTogbW9kZSB9KVxcXCIpLEc/Qi4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGIpe3JldHVybiBhLmRhdGU9ai5mcm9tVGltZXpvbmUoYixDLnRpbWV6b25lKSxifSk6KEIuJCRwYXJzZXJOYW1lPVxcXCJkYXRlXFxcIixCLiR2YWxpZGF0b3JzLmRhdGU9cSxCLiRwYXJzZXJzLnVuc2hpZnQocCksQi4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGIpe3JldHVybiBCLiRpc0VtcHR5KGIpPyhhLmRhdGU9YixiKTooYS5kYXRlPWouZnJvbVRpbWV6b25lKGIsQy50aW1lem9uZSksdD10LnJlcGxhY2UoL00hLyxcXFwiTU1cXFwiKS5yZXBsYWNlKC9kIS8sXFxcImRkXFxcIiksaShhLmRhdGUsdCkpfSkpLEIuJHZpZXdDaGFuZ2VMaXN0ZW5lcnMucHVzaChmdW5jdGlvbigpe2EuZGF0ZT1vKEIuJHZpZXdWYWx1ZSl9KSxiLm9uKFxcXCJrZXlkb3duXFxcIixzKSxEPWQoeikoYSksei5yZW1vdmUoKSx2P2YuZmluZChcXFwiYm9keVxcXCIpLmFwcGVuZChEKTpiLmFmdGVyKEQpLGEuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtmb3IoYS5pc09wZW49PT0hMCYmKGcuJCRwaGFzZXx8YS4kYXBwbHkoZnVuY3Rpb24oKXthLmlzT3Blbj0hMX0pKSxELnJlbW92ZSgpLGIub2ZmKFxcXCJrZXlkb3duXFxcIixzKSxmLm9mZihcXFwiY2xpY2tcXFwiLHIpO0gubGVuZ3RoOylILnNoaWZ0KCkoKX0pfSxhLmdldFRleHQ9ZnVuY3Rpb24oYil7cmV0dXJuIGFbYitcXFwiVGV4dFxcXCJdfHxrW2IrXFxcIlRleHRcXFwiXX0sYS5pc0Rpc2FibGVkPWZ1bmN0aW9uKGIpe3JldHVyblxcXCJ0b2RheVxcXCI9PT1iJiYoYj1uZXcgRGF0ZSksYS53YXRjaERhdGEubWluRGF0ZSYmYS5jb21wYXJlKGIsRi5taW5EYXRlKTwwfHxhLndhdGNoRGF0YS5tYXhEYXRlJiZhLmNvbXBhcmUoYixGLm1heERhdGUpPjB9LGEuY29tcGFyZT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgRGF0ZShhLmdldEZ1bGxZZWFyKCksYS5nZXRNb250aCgpLGEuZ2V0RGF0ZSgpKS1uZXcgRGF0ZShiLmdldEZ1bGxZZWFyKCksYi5nZXRNb250aCgpLGIuZ2V0RGF0ZSgpKX0sYS5kYXRlU2VsZWN0aW9uPWZ1bmN0aW9uKGMpe2FuZ3VsYXIuaXNEZWZpbmVkKGMpJiYoYS5kYXRlPWMpO3ZhciBkPWEuZGF0ZT9pKGEuZGF0ZSx0KTpudWxsO2IudmFsKGQpLEIuJHNldFZpZXdWYWx1ZShkKSx1JiYoYS5pc09wZW49ITEsYlswXS5mb2N1cygpKX0sYS5rZXlkb3duPWZ1bmN0aW9uKGMpezI3PT09Yy53aGljaCYmKGMuc3RvcFByb3BhZ2F0aW9uKCksYS5pc09wZW49ITEsYlswXS5mb2N1cygpKX0sYS5zZWxlY3Q9ZnVuY3Rpb24oYil7aWYoXFxcInRvZGF5XFxcIj09PWIpe3ZhciBjPW5ldyBEYXRlO2FuZ3VsYXIuaXNEYXRlKGEuZGF0ZSk/KGI9bmV3IERhdGUoYS5kYXRlKSxiLnNldEZ1bGxZZWFyKGMuZ2V0RnVsbFllYXIoKSxjLmdldE1vbnRoKCksYy5nZXREYXRlKCkpKTpiPW5ldyBEYXRlKGMuc2V0SG91cnMoMCwwLDAsMCkpfWEuZGF0ZVNlbGVjdGlvbihiKX0sYS5jbG9zZT1mdW5jdGlvbigpe2EuaXNPcGVuPSExLGJbMF0uZm9jdXMoKX0sYS5kaXNhYmxlZD1hbmd1bGFyLmlzRGVmaW5lZChjLmRpc2FibGVkKXx8ITEsYy5uZ0Rpc2FibGVkJiZILnB1c2goYS4kcGFyZW50LiR3YXRjaChlKGMubmdEaXNhYmxlZCksZnVuY3Rpb24oYil7YS5kaXNhYmxlZD1ifSkpLGEuJHdhdGNoKFxcXCJpc09wZW5cXFwiLGZ1bmN0aW9uKGMpe2M/YS5kaXNhYmxlZD9hLmlzT3Blbj0hMTooYS5wb3NpdGlvbj12P2gub2Zmc2V0KGIpOmgucG9zaXRpb24oYiksYS5wb3NpdGlvbi50b3A9YS5wb3NpdGlvbi50b3ArYi5wcm9wKFxcXCJvZmZzZXRIZWlnaHRcXFwiKSxsKGZ1bmN0aW9uKCl7dyYmYS4kYnJvYWRjYXN0KFxcXCJ1aWI6ZGF0ZXBpY2tlci5mb2N1c1xcXCIpLGYub24oXFxcImNsaWNrXFxcIixyKX0sMCwhMSkpOmYub2ZmKFxcXCJjbGlja1xcXCIscil9KX1dKS5kaXJlY3RpdmUoXFxcInVpYkRhdGVwaWNrZXJQb3B1cFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVxdWlyZTpbXFxcIm5nTW9kZWxcXFwiLFxcXCJ1aWJEYXRlcGlja2VyUG9wdXBcXFwiXSxjb250cm9sbGVyOlxcXCJVaWJEYXRlcGlja2VyUG9wdXBDb250cm9sbGVyXFxcIixzY29wZTp7ZGF0ZXBpY2tlck9wdGlvbnM6XFxcIj0/XFxcIixpc09wZW46XFxcIj0/XFxcIixjdXJyZW50VGV4dDpcXFwiQFxcXCIsY2xlYXJUZXh0OlxcXCJAXFxcIixjbG9zZVRleHQ6XFxcIkBcXFwiLGRhdGVEaXNhYmxlZDpcXFwiJlxcXCIsY3VzdG9tQ2xhc3M6XFxcIiZcXFwifSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF0sZj1kWzFdO2YuaW5pdChlKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJEYXRlcGlja2VyUG9wdXBXcmFwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHRyYW5zY2x1ZGU6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcXFwifX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmRlYm91bmNlXFxcIixbXSkuZmFjdG9yeShcXFwiJCRkZWJvdW5jZVxcXCIsW1xcXCIkdGltZW91dFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dmFyIGQ7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxmPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7ZCYmYS5jYW5jZWwoZCksZD1hKGZ1bmN0aW9uKCl7Yi5hcHBseShlLGYpfSxjKX19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAuZHJvcGRvd25cXFwiLFtcXFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXFxcIl0pLmNvbnN0YW50KFxcXCJ1aWJEcm9wZG93bkNvbmZpZ1xcXCIse2FwcGVuZFRvT3BlbkNsYXNzOlxcXCJ1aWItZHJvcGRvd24tb3BlblxcXCIsb3BlbkNsYXNzOlxcXCJvcGVuXFxcIn0pLnNlcnZpY2UoXFxcInVpYkRyb3Bkb3duU2VydmljZVxcXCIsW1xcXCIkZG9jdW1lbnRcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixmdW5jdGlvbihhLGIpe3ZhciBjPW51bGw7dGhpcy5vcGVuPWZ1bmN0aW9uKGIpe2N8fChhLm9uKFxcXCJjbGlja1xcXCIsZCksYS5vbihcXFwia2V5ZG93blxcXCIsZSkpLGMmJmMhPT1iJiYoYy5pc09wZW49ITEpLGM9Yn0sdGhpcy5jbG9zZT1mdW5jdGlvbihiKXtjPT09YiYmKGM9bnVsbCxhLm9mZihcXFwiY2xpY2tcXFwiLGQpLGEub2ZmKFxcXCJrZXlkb3duXFxcIixlKSl9O3ZhciBkPWZ1bmN0aW9uKGEpe2lmKGMmJiEoYSYmXFxcImRpc2FibGVkXFxcIj09PWMuZ2V0QXV0b0Nsb3NlKCl8fGEmJjM9PT1hLndoaWNoKSl7dmFyIGQ9Yy5nZXRUb2dnbGVFbGVtZW50KCk7aWYoIShhJiZkJiZkWzBdLmNvbnRhaW5zKGEudGFyZ2V0KSkpe3ZhciBlPWMuZ2V0RHJvcGRvd25FbGVtZW50KCk7YSYmXFxcIm91dHNpZGVDbGlja1xcXCI9PT1jLmdldEF1dG9DbG9zZSgpJiZlJiZlWzBdLmNvbnRhaW5zKGEudGFyZ2V0KXx8KGMuaXNPcGVuPSExLGIuJCRwaGFzZXx8Yy4kYXBwbHkoKSl9fX0sZT1mdW5jdGlvbihhKXsyNz09PWEud2hpY2g/KGMuZm9jdXNUb2dnbGVFbGVtZW50KCksZCgpKTpjLmlzS2V5bmF2RW5hYmxlZCgpJiYtMSE9PVszOCw0MF0uaW5kZXhPZihhLndoaWNoKSYmYy5pc09wZW4mJihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxjLmZvY3VzRHJvcGRvd25FbnRyeShhLndoaWNoKSl9fV0pLmNvbnRyb2xsZXIoXFxcIlVpYkRyb3Bkb3duQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkZWxlbWVudFxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcIiRwYXJzZVxcXCIsXFxcInVpYkRyb3Bkb3duQ29uZmlnXFxcIixcXFwidWliRHJvcGRvd25TZXJ2aWNlXFxcIixcXFwiJGFuaW1hdGVcXFwiLFxcXCIkdWliUG9zaXRpb25cXFwiLFxcXCIkZG9jdW1lbnRcXFwiLFxcXCIkY29tcGlsZVxcXCIsXFxcIiR0ZW1wbGF0ZVJlcXVlc3RcXFwiLGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpLGosayl7dmFyIGwsbSxuPXRoaXMsbz1hLiRuZXcoKSxwPWUuYXBwZW5kVG9PcGVuQ2xhc3MscT1lLm9wZW5DbGFzcyxyPWFuZ3VsYXIubm9vcCxzPWMub25Ub2dnbGU/ZChjLm9uVG9nZ2xlKTphbmd1bGFyLm5vb3AsdD0hMSx1PW51bGwsdj0hMSx3PWkuZmluZChcXFwiYm9keVxcXCIpO2IuYWRkQ2xhc3MoXFxcImRyb3Bkb3duXFxcIiksdGhpcy5pbml0PWZ1bmN0aW9uKCl7aWYoYy5pc09wZW4mJihtPWQoYy5pc09wZW4pLHI9bS5hc3NpZ24sYS4kd2F0Y2gobSxmdW5jdGlvbihhKXtvLmlzT3Blbj0hIWF9KSksYW5ndWxhci5pc0RlZmluZWQoYy5kcm9wZG93bkFwcGVuZFRvKSl7dmFyIGU9ZChjLmRyb3Bkb3duQXBwZW5kVG8pKG8pO2UmJih1PWFuZ3VsYXIuZWxlbWVudChlKSl9dD1hbmd1bGFyLmlzRGVmaW5lZChjLmRyb3Bkb3duQXBwZW5kVG9Cb2R5KSx2PWFuZ3VsYXIuaXNEZWZpbmVkKGMua2V5Ym9hcmROYXYpLHQmJiF1JiYodT13KSx1JiZuLmRyb3Bkb3duTWVudSYmKHUuYXBwZW5kKG4uZHJvcGRvd25NZW51KSxiLm9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtuLmRyb3Bkb3duTWVudS5yZW1vdmUoKX0pKX0sdGhpcy50b2dnbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG8uaXNPcGVuPWFyZ3VtZW50cy5sZW5ndGg/ISFhOiFvLmlzT3Blbn0sdGhpcy5pc09wZW49ZnVuY3Rpb24oKXtyZXR1cm4gby5pc09wZW59LG8uZ2V0VG9nZ2xlRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiBuLnRvZ2dsZUVsZW1lbnR9LG8uZ2V0QXV0b0Nsb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGMuYXV0b0Nsb3NlfHxcXFwiYWx3YXlzXFxcIn0sby5nZXRFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIGJ9LG8uaXNLZXluYXZFbmFibGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHZ9LG8uZm9jdXNEcm9wZG93bkVudHJ5PWZ1bmN0aW9uKGEpe3ZhciBjPW4uZHJvcGRvd25NZW51P2FuZ3VsYXIuZWxlbWVudChuLmRyb3Bkb3duTWVudSkuZmluZChcXFwiYVxcXCIpOmIuZmluZChcXFwidWxcXFwiKS5lcSgwKS5maW5kKFxcXCJhXFxcIik7c3dpdGNoKGEpe2Nhc2UgNDA6YW5ndWxhci5pc051bWJlcihuLnNlbGVjdGVkT3B0aW9uKT9uLnNlbGVjdGVkT3B0aW9uPW4uc2VsZWN0ZWRPcHRpb249PT1jLmxlbmd0aC0xP24uc2VsZWN0ZWRPcHRpb246bi5zZWxlY3RlZE9wdGlvbisxOm4uc2VsZWN0ZWRPcHRpb249MDticmVhaztjYXNlIDM4OmFuZ3VsYXIuaXNOdW1iZXIobi5zZWxlY3RlZE9wdGlvbik/bi5zZWxlY3RlZE9wdGlvbj0wPT09bi5zZWxlY3RlZE9wdGlvbj8wOm4uc2VsZWN0ZWRPcHRpb24tMTpuLnNlbGVjdGVkT3B0aW9uPWMubGVuZ3RoLTF9Y1tuLnNlbGVjdGVkT3B0aW9uXS5mb2N1cygpfSxvLmdldERyb3Bkb3duRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiBuLmRyb3Bkb3duTWVudX0sby5mb2N1c1RvZ2dsZUVsZW1lbnQ9ZnVuY3Rpb24oKXtuLnRvZ2dsZUVsZW1lbnQmJm4udG9nZ2xlRWxlbWVudFswXS5mb2N1cygpfSxvLiR3YXRjaChcXFwiaXNPcGVuXFxcIixmdW5jdGlvbihjLGQpe2lmKHUmJm4uZHJvcGRvd25NZW51KXt2YXIgZSxpLG09aC5wb3NpdGlvbkVsZW1lbnRzKGIsbi5kcm9wZG93bk1lbnUsXFxcImJvdHRvbS1sZWZ0XFxcIiwhMCk7aWYoZT17dG9wOm0udG9wK1xcXCJweFxcXCIsZGlzcGxheTpjP1xcXCJibG9ja1xcXCI6XFxcIm5vbmVcXFwifSxpPW4uZHJvcGRvd25NZW51Lmhhc0NsYXNzKFxcXCJkcm9wZG93bi1tZW51LXJpZ2h0XFxcIiksaT8oZS5sZWZ0PVxcXCJhdXRvXFxcIixlLnJpZ2h0PXdpbmRvdy5pbm5lcldpZHRoLShtLmxlZnQrYi5wcm9wKFxcXCJvZmZzZXRXaWR0aFxcXCIpKStcXFwicHhcXFwiKTooZS5sZWZ0PW0ubGVmdCtcXFwicHhcXFwiLGUucmlnaHQ9XFxcImF1dG9cXFwiKSwhdCl7dmFyIHY9aC5vZmZzZXQodSk7ZS50b3A9bS50b3Atdi50b3ArXFxcInB4XFxcIixpP2UucmlnaHQ9d2luZG93LmlubmVyV2lkdGgtKG0ubGVmdC12LmxlZnQrYi5wcm9wKFxcXCJvZmZzZXRXaWR0aFxcXCIpKStcXFwicHhcXFwiOmUubGVmdD1tLmxlZnQtdi5sZWZ0K1xcXCJweFxcXCJ9bi5kcm9wZG93bk1lbnUuY3NzKGUpfXZhciB3PXU/dTpiO2lmKGdbYz9cXFwiYWRkQ2xhc3NcXFwiOlxcXCJyZW1vdmVDbGFzc1xcXCJdKHcsdT9wOnEpLnRoZW4oZnVuY3Rpb24oKXthbmd1bGFyLmlzRGVmaW5lZChjKSYmYyE9PWQmJnMoYSx7b3BlbjohIWN9KX0pLGMpbi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCYmayhuLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uKGEpe2w9by4kbmV3KCksaihhLnRyaW0oKSkobCxmdW5jdGlvbihhKXt2YXIgYj1hO24uZHJvcGRvd25NZW51LnJlcGxhY2VXaXRoKGIpLG4uZHJvcGRvd25NZW51PWJ9KX0pLG8uZm9jdXNUb2dnbGVFbGVtZW50KCksZi5vcGVuKG8pO2Vsc2V7aWYobi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCl7bCYmbC4kZGVzdHJveSgpO3ZhciB4PWFuZ3VsYXIuZWxlbWVudCgnPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIj48L3VsPicpO24uZHJvcGRvd25NZW51LnJlcGxhY2VXaXRoKHgpLG4uZHJvcGRvd25NZW51PXh9Zi5jbG9zZShvKSxuLnNlbGVjdGVkT3B0aW9uPW51bGx9YW5ndWxhci5pc0Z1bmN0aW9uKHIpJiZyKGEsYyl9KSxhLiRvbihcXFwiJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc1xcXCIsZnVuY3Rpb24oKXtcXFwiZGlzYWJsZWRcXFwiIT09by5nZXRBdXRvQ2xvc2UoKSYmKG8uaXNPcGVuPSExKX0pfV0pLmRpcmVjdGl2ZShcXFwidWliRHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7cmV0dXJue2NvbnRyb2xsZXI6XFxcIlVpYkRyb3Bkb3duQ29udHJvbGxlclxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXtkLmluaXQoKX19fSkuZGlyZWN0aXZlKFxcXCJ1aWJEcm9wZG93bk1lbnVcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixyZXF1aXJlOlxcXCI/XnVpYkRyb3Bkb3duXFxcIixsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe2lmKGQmJiFhbmd1bGFyLmlzRGVmaW5lZChjLmRyb3Bkb3duTmVzdGVkKSl7Yi5hZGRDbGFzcyhcXFwiZHJvcGRvd24tbWVudVxcXCIpO3ZhciBlPWMudGVtcGxhdGVVcmw7ZSYmKGQuZHJvcGRvd25NZW51VGVtcGxhdGVVcmw9ZSksZC5kcm9wZG93bk1lbnV8fChkLmRyb3Bkb3duTWVudT1iKX19fX0pLmRpcmVjdGl2ZShcXFwidWliRHJvcGRvd25Ub2dnbGVcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcXVpcmU6XFxcIj9edWliRHJvcGRvd25cXFwiLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoZCl7Yi5hZGRDbGFzcyhcXFwiZHJvcGRvd24tdG9nZ2xlXFxcIiksZC50b2dnbGVFbGVtZW50PWI7dmFyIGU9ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGIuaGFzQ2xhc3MoXFxcImRpc2FibGVkXFxcIil8fGMuZGlzYWJsZWR8fGEuJGFwcGx5KGZ1bmN0aW9uKCl7ZC50b2dnbGUoKX0pfTtiLmJpbmQoXFxcImNsaWNrXFxcIixlKSxiLmF0dHIoe1xcXCJhcmlhLWhhc3BvcHVwXFxcIjohMCxcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITF9KSxhLiR3YXRjaChkLmlzT3BlbixmdW5jdGlvbihhKXtiLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEhYSl9KSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yi51bmJpbmQoXFxcImNsaWNrXFxcIixlKX0pfX19fSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5zdGFja2VkTWFwXFxcIixbXSkuZmFjdG9yeShcXFwiJCRzdGFja2VkTWFwXFxcIixmdW5jdGlvbigpe3JldHVybntjcmVhdGVOZXc6ZnVuY3Rpb24oKXt2YXIgYT1bXTtyZXR1cm57YWRkOmZ1bmN0aW9uKGIsYyl7YS5wdXNoKHtrZXk6Yix2YWx1ZTpjfSl9LGdldDpmdW5jdGlvbihiKXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihiPT09YVtjXS5rZXkpcmV0dXJuIGFbY119LGtleXM6ZnVuY3Rpb24oKXtmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKWIucHVzaChhW2NdLmtleSk7cmV0dXJuIGJ9LHRvcDpmdW5jdGlvbigpe3JldHVybiBhW2EubGVuZ3RoLTFdfSxyZW1vdmU6ZnVuY3Rpb24oYil7Zm9yKHZhciBjPS0xLGQ9MDtkPGEubGVuZ3RoO2QrKylpZihiPT09YVtkXS5rZXkpe2M9ZDticmVha31yZXR1cm4gYS5zcGxpY2UoYywxKVswXX0scmVtb3ZlVG9wOmZ1bmN0aW9uKCl7cmV0dXJuIGEuc3BsaWNlKGEubGVuZ3RoLTEsMSlbMF19LGxlbmd0aDpmdW5jdGlvbigpe3JldHVybiBhLmxlbmd0aH19fX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLm1vZGFsXFxcIixbXFxcInVpLmJvb3RzdHJhcC5zdGFja2VkTWFwXFxcIl0pLmZhY3RvcnkoXFxcIiQkbXVsdGlNYXBcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue2NyZWF0ZU5ldzpmdW5jdGlvbigpe3ZhciBhPXt9O3JldHVybntlbnRyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKGEpLm1hcChmdW5jdGlvbihiKXtyZXR1cm57a2V5OmIsdmFsdWU6YVtiXX19KX0sZ2V0OmZ1bmN0aW9uKGIpe3JldHVybiBhW2JdfSxoYXNLZXk6ZnVuY3Rpb24oYil7cmV0dXJuISFhW2JdfSxrZXlzOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKGEpfSxwdXQ6ZnVuY3Rpb24oYixjKXthW2JdfHwoYVtiXT1bXSksYVtiXS5wdXNoKGMpfSxyZW1vdmU6ZnVuY3Rpb24oYixjKXt2YXIgZD1hW2JdO2lmKGQpe3ZhciBlPWQuaW5kZXhPZihjKTstMSE9PWUmJmQuc3BsaWNlKGUsMSksZC5sZW5ndGh8fGRlbGV0ZSBhW2JdfX19fX19KS5wcm92aWRlcihcXFwiJHVpYlJlc29sdmVcXFwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLnJlc29sdmVyPW51bGwsdGhpcy5zZXRSZXNvbHZlcj1mdW5jdGlvbihhKXt0aGlzLnJlc29sdmVyPWF9LHRoaXMuJGdldD1bXFxcIiRpbmplY3RvclxcXCIsXFxcIiRxXFxcIixmdW5jdGlvbihiLGMpe3ZhciBkPWEucmVzb2x2ZXI/Yi5nZXQoYS5yZXNvbHZlcik6bnVsbDtyZXR1cm57cmVzb2x2ZTpmdW5jdGlvbihhLGUsZixnKXtpZihkKXJldHVybiBkLnJlc29sdmUoYSxlLGYsZyk7dmFyIGg9W107cmV0dXJuIGFuZ3VsYXIuZm9yRWFjaChhLGZ1bmN0aW9uKGEpe2FuZ3VsYXIuaXNGdW5jdGlvbihhKXx8YW5ndWxhci5pc0FycmF5KGEpP2gucHVzaChjLnJlc29sdmUoYi5pbnZva2UoYSkpKTphbmd1bGFyLmlzU3RyaW5nKGEpP2gucHVzaChjLnJlc29sdmUoYi5nZXQoYSkpKTpoLnB1c2goYy5yZXNvbHZlKGEpKX0pLGMuYWxsKGgpLnRoZW4oZnVuY3Rpb24oYil7dmFyIGM9e30sZD0wO3JldHVybiBhbmd1bGFyLmZvckVhY2goYSxmdW5jdGlvbihhLGUpe2NbZV09YltkKytdfSksY30pfX19XX0pLmRpcmVjdGl2ZShcXFwidWliTW9kYWxCYWNrZHJvcFxcXCIsW1xcXCIkYW5pbWF0ZUNzc1xcXCIsXFxcIiRpbmplY3RvclxcXCIsXFxcIiR1aWJNb2RhbFN0YWNrXFxcIixmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChiLGQsZSl7ZS5tb2RhbEluQ2xhc3MmJihhKGQse2FkZENsYXNzOmUubW9kYWxJbkNsYXNzfSkuc3RhcnQoKSxiLiRvbihjLk5PV19DTE9TSU5HX0VWRU5ULGZ1bmN0aW9uKGMsZil7dmFyIGc9ZigpO2IubW9kYWxPcHRpb25zLmFuaW1hdGlvbj9hKGQse3JlbW92ZUNsYXNzOmUubW9kYWxJbkNsYXNzfSkuc3RhcnQoKS50aGVuKGcpOmcoKX0pKX1yZXR1cm57cmVwbGFjZTohMCx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcXFwiLGNvbXBpbGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5hZGRDbGFzcyhiLmJhY2tkcm9wQ2xhc3MpLGR9fX1dKS5kaXJlY3RpdmUoXFxcInVpYk1vZGFsV2luZG93XFxcIixbXFxcIiR1aWJNb2RhbFN0YWNrXFxcIixcXFwiJHFcXFwiLFxcXCIkYW5pbWF0ZVxcXCIsXFxcIiRhbmltYXRlQ3NzXFxcIixcXFwiJGRvY3VtZW50XFxcIixmdW5jdGlvbihhLGIsYyxkLGUpe3JldHVybntzY29wZTp7aW5kZXg6XFxcIkBcXFwifSxyZXBsYWNlOiEwLHRyYW5zY2x1ZGU6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50ZW1wbGF0ZVVybHx8XFxcInVpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFxcXCJ9LGxpbms6ZnVuY3Rpb24oZixnLGgpe2cuYWRkQ2xhc3MoaC53aW5kb3dDbGFzc3x8XFxcIlxcXCIpLGcuYWRkQ2xhc3MoaC53aW5kb3dUb3BDbGFzc3x8XFxcIlxcXCIpLGYuc2l6ZT1oLnNpemUsZi5jbG9zZT1mdW5jdGlvbihiKXt2YXIgYz1hLmdldFRvcCgpO2MmJmMudmFsdWUuYmFja2Ryb3AmJlxcXCJzdGF0aWNcXFwiIT09Yy52YWx1ZS5iYWNrZHJvcCYmYi50YXJnZXQ9PT1iLmN1cnJlbnRUYXJnZXQmJihiLnByZXZlbnREZWZhdWx0KCksYi5zdG9wUHJvcGFnYXRpb24oKSxhLmRpc21pc3MoYy5rZXksXFxcImJhY2tkcm9wIGNsaWNrXFxcIikpfSxnLm9uKFxcXCJjbGlja1xcXCIsZi5jbG9zZSksZi4kaXNSZW5kZXJlZD0hMDt2YXIgaT1iLmRlZmVyKCk7aC4kb2JzZXJ2ZShcXFwibW9kYWxSZW5kZXJcXFwiLGZ1bmN0aW9uKGEpe1xcXCJ0cnVlXFxcIj09PWEmJmkucmVzb2x2ZSgpfSksaS5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKXt2YXIgaT1udWxsO2gubW9kYWxJbkNsYXNzJiYoaT1kKGcse2FkZENsYXNzOmgubW9kYWxJbkNsYXNzfSkuc3RhcnQoKSxmLiRvbihhLk5PV19DTE9TSU5HX0VWRU5ULGZ1bmN0aW9uKGEsYil7dmFyIGU9YigpO2Q/ZChnLHtyZW1vdmVDbGFzczpoLm1vZGFsSW5DbGFzc30pLnN0YXJ0KCkudGhlbihlKTpjLnJlbW92ZUNsYXNzKGcsaC5tb2RhbEluQ2xhc3MpLnRoZW4oZSl9KSksYi53aGVuKGkpLnRoZW4oZnVuY3Rpb24oKXtpZighZVswXS5hY3RpdmVFbGVtZW50fHwhZ1swXS5jb250YWlucyhlWzBdLmFjdGl2ZUVsZW1lbnQpKXt2YXIgYT1nWzBdLnF1ZXJ5U2VsZWN0b3IoXFxcIlthdXRvZm9jdXNdXFxcIik7YT9hLmZvY3VzKCk6Z1swXS5mb2N1cygpfX0pO3ZhciBqPWEuZ2V0VG9wKCk7aiYmYS5tb2RhbFJlbmRlcmVkKGoua2V5KX0pfX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJNb2RhbEFuaW1hdGlvbkNsYXNzXFxcIixmdW5jdGlvbigpe3JldHVybntjb21waWxlOmZ1bmN0aW9uKGEsYil7Yi5tb2RhbEFuaW1hdGlvbiYmYS5hZGRDbGFzcyhiLnVpYk1vZGFsQW5pbWF0aW9uQ2xhc3MpfX19KS5kaXJlY3RpdmUoXFxcInVpYk1vZGFsVHJhbnNjbHVkZVxcXCIsZnVuY3Rpb24oKXtyZXR1cm57bGluazpmdW5jdGlvbihhLGIsYyxkLGUpe2UoYS4kcGFyZW50LGZ1bmN0aW9uKGEpe2IuZW1wdHkoKSxiLmFwcGVuZChhKX0pfX19KS5mYWN0b3J5KFxcXCIkdWliTW9kYWxTdGFja1xcXCIsW1xcXCIkYW5pbWF0ZVxcXCIsXFxcIiRhbmltYXRlQ3NzXFxcIixcXFwiJGRvY3VtZW50XFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixcXFwiJHFcXFwiLFxcXCIkJG11bHRpTWFwXFxcIixcXFwiJCRzdGFja2VkTWFwXFxcIixmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe2Z1bmN0aW9uIGkoKXtmb3IodmFyIGE9LTEsYj10LmtleXMoKSxjPTA7YzxiLmxlbmd0aDtjKyspdC5nZXQoYltjXSkudmFsdWUuYmFja2Ryb3AmJihhPWMpO3JldHVybiBhfWZ1bmN0aW9uIGooYSxiKXt2YXIgYz10LmdldChhKS52YWx1ZSxkPWMuYXBwZW5kVG87dC5yZW1vdmUoYSksbShjLm1vZGFsRG9tRWwsYy5tb2RhbFNjb3BlLGZ1bmN0aW9uKCl7dmFyIGI9Yy5vcGVuZWRDbGFzc3x8czt1LnJlbW92ZShiLGEpLGQudG9nZ2xlQ2xhc3MoYix1Lmhhc0tleShiKSksayghMCl9LGMuY2xvc2VkRGVmZXJyZWQpLGwoKSxiJiZiLmZvY3VzP2IuZm9jdXMoKTpkLmZvY3VzJiZkLmZvY3VzKCl9ZnVuY3Rpb24gayhhKXt2YXIgYjt0Lmxlbmd0aCgpPjAmJihiPXQudG9wKCkudmFsdWUsYi5tb2RhbERvbUVsLnRvZ2dsZUNsYXNzKGIud2luZG93VG9wQ2xhc3N8fFxcXCJcXFwiLGEpKX1mdW5jdGlvbiBsKCl7aWYocCYmLTE9PT1pKCkpe3ZhciBhPXE7bShwLHEsZnVuY3Rpb24oKXthPW51bGx9KSxwPXZvaWQgMCxxPXZvaWQgMH19ZnVuY3Rpb24gbShhLGMsZCxlKXtmdW5jdGlvbiBnKCl7Zy5kb25lfHwoZy5kb25lPSEwLGIoYSx7ZXZlbnQ6XFxcImxlYXZlXFxcIn0pLnN0YXJ0KCkudGhlbihmdW5jdGlvbigpe2EucmVtb3ZlKCksZSYmZS5yZXNvbHZlKCl9KSxjLiRkZXN0cm95KCksZCYmZCgpKX12YXIgaCxpPW51bGwsaj1mdW5jdGlvbigpe3JldHVybiBofHwoaD1mLmRlZmVyKCksaT1oLnByb21pc2UpLGZ1bmN0aW9uKCl7aC5yZXNvbHZlKCl9fTtyZXR1cm4gYy4kYnJvYWRjYXN0KHYuTk9XX0NMT1NJTkdfRVZFTlQsaiksZi53aGVuKGkpLnRoZW4oZyl9ZnVuY3Rpb24gbihhKXtpZihhLmlzRGVmYXVsdFByZXZlbnRlZCgpKXJldHVybiBhO3ZhciBiPXQudG9wKCk7aWYoYilzd2l0Y2goYS53aGljaCl7Y2FzZSAyNzpiLnZhbHVlLmtleWJvYXJkJiYoYS5wcmV2ZW50RGVmYXVsdCgpLGUuJGFwcGx5KGZ1bmN0aW9uKCl7di5kaXNtaXNzKGIua2V5LFxcXCJlc2NhcGUga2V5IHByZXNzXFxcIil9KSk7YnJlYWs7Y2FzZSA5OnYubG9hZEZvY3VzRWxlbWVudExpc3QoYik7dmFyIGM9ITE7YS5zaGlmdEtleT92LmlzRm9jdXNJbkZpcnN0SXRlbShhKSYmKGM9di5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50KCkpOnYuaXNGb2N1c0luTGFzdEl0ZW0oYSkmJihjPXYuZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQoKSksYyYmKGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpKX19ZnVuY3Rpb24gbyhhLGIsYyl7cmV0dXJuIWEudmFsdWUubW9kYWxTY29wZS4kYnJvYWRjYXN0KFxcXCJtb2RhbC5jbG9zaW5nXFxcIixiLGMpLmRlZmF1bHRQcmV2ZW50ZWR9dmFyIHAscSxyLHM9XFxcIm1vZGFsLW9wZW5cXFwiLHQ9aC5jcmVhdGVOZXcoKSx1PWcuY3JlYXRlTmV3KCksdj17Tk9XX0NMT1NJTkdfRVZFTlQ6XFxcIm1vZGFsLnN0YWNrLm5vdy1jbG9zaW5nXFxcIn0sdz0wLHg9XFxcImFbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSxzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlPXRydWVdXFxcIjtyZXR1cm4gZS4kd2F0Y2goaSxmdW5jdGlvbihhKXtxJiYocS5pbmRleD1hKX0pLGMub24oXFxcImtleWRvd25cXFwiLG4pLGUuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtjLm9mZihcXFwia2V5ZG93blxcXCIsbil9KSx2Lm9wZW49ZnVuY3Rpb24oYixmKXt2YXIgZz1jWzBdLmFjdGl2ZUVsZW1lbnQsaD1mLm9wZW5lZENsYXNzfHxzO2soITEpLHQuYWRkKGIse2RlZmVycmVkOmYuZGVmZXJyZWQscmVuZGVyRGVmZXJyZWQ6Zi5yZW5kZXJEZWZlcnJlZCxjbG9zZWREZWZlcnJlZDpmLmNsb3NlZERlZmVycmVkLG1vZGFsU2NvcGU6Zi5zY29wZSxiYWNrZHJvcDpmLmJhY2tkcm9wLGtleWJvYXJkOmYua2V5Ym9hcmQsb3BlbmVkQ2xhc3M6Zi5vcGVuZWRDbGFzcyx3aW5kb3dUb3BDbGFzczpmLndpbmRvd1RvcENsYXNzLGFuaW1hdGlvbjpmLmFuaW1hdGlvbixhcHBlbmRUbzpmLmFwcGVuZFRvfSksdS5wdXQoaCxiKTt2YXIgaj1mLmFwcGVuZFRvLGw9aSgpO2lmKCFqLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXFxcImFwcGVuZFRvIGVsZW1lbnQgbm90IGZvdW5kLiBNYWtlIHN1cmUgdGhhdCB0aGUgZWxlbWVudCBwYXNzZWQgaXMgaW4gRE9NLlxcXCIpO2w+PTAmJiFwJiYocT1lLiRuZXcoITApLHEubW9kYWxPcHRpb25zPWYscS5pbmRleD1sLHA9YW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1tb2RhbC1iYWNrZHJvcD1cXFwibW9kYWwtYmFja2Ryb3BcXFwiPjwvZGl2PicpLHAuYXR0cihcXFwiYmFja2Ryb3AtY2xhc3NcXFwiLGYuYmFja2Ryb3BDbGFzcyksZi5hbmltYXRpb24mJnAuYXR0cihcXFwibW9kYWwtYW5pbWF0aW9uXFxcIixcXFwidHJ1ZVxcXCIpLGQocCkocSksYS5lbnRlcihwLGopKTt2YXIgbT1hbmd1bGFyLmVsZW1lbnQoJzxkaXYgdWliLW1vZGFsLXdpbmRvdz1cXFwibW9kYWwtd2luZG93XFxcIj48L2Rpdj4nKTttLmF0dHIoe1xcXCJ0ZW1wbGF0ZS11cmxcXFwiOmYud2luZG93VGVtcGxhdGVVcmwsXFxcIndpbmRvdy1jbGFzc1xcXCI6Zi53aW5kb3dDbGFzcyxcXFwid2luZG93LXRvcC1jbGFzc1xcXCI6Zi53aW5kb3dUb3BDbGFzcyxzaXplOmYuc2l6ZSxpbmRleDp0Lmxlbmd0aCgpLTEsYW5pbWF0ZTpcXFwiYW5pbWF0ZVxcXCJ9KS5odG1sKGYuY29udGVudCksZi5hbmltYXRpb24mJm0uYXR0cihcXFwibW9kYWwtYW5pbWF0aW9uXFxcIixcXFwidHJ1ZVxcXCIpLGEuZW50ZXIoZChtKShmLnNjb3BlKSxqKS50aGVuKGZ1bmN0aW9uKCl7YS5hZGRDbGFzcyhqLGgpfSksdC50b3AoKS52YWx1ZS5tb2RhbERvbUVsPW0sdC50b3AoKS52YWx1ZS5tb2RhbE9wZW5lcj1nLHYuY2xlYXJGb2N1c0xpc3RDYWNoZSgpfSx2LmNsb3NlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dC5nZXQoYSk7cmV0dXJuIGMmJm8oYyxiLCEwKT8oYy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQ9ITAsYy52YWx1ZS5kZWZlcnJlZC5yZXNvbHZlKGIpLGooYSxjLnZhbHVlLm1vZGFsT3BlbmVyKSwhMCk6IWN9LHYuZGlzbWlzcz1mdW5jdGlvbihhLGIpe3ZhciBjPXQuZ2V0KGEpO3JldHVybiBjJiZvKGMsYiwhMSk/KGMudmFsdWUubW9kYWxTY29wZS4kJHVpYkRlc3RydWN0aW9uU2NoZWR1bGVkPSEwLGMudmFsdWUuZGVmZXJyZWQucmVqZWN0KGIpLGooYSxjLnZhbHVlLm1vZGFsT3BlbmVyKSwhMCk6IWN9LHYuZGlzbWlzc0FsbD1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5nZXRUb3AoKTtiJiZ0aGlzLmRpc21pc3MoYi5rZXksYSk7KWI9dGhpcy5nZXRUb3AoKX0sdi5nZXRUb3A9ZnVuY3Rpb24oKXtyZXR1cm4gdC50b3AoKX0sdi5tb2RhbFJlbmRlcmVkPWZ1bmN0aW9uKGEpe3ZhciBiPXQuZ2V0KGEpO2ImJmIudmFsdWUucmVuZGVyRGVmZXJyZWQucmVzb2x2ZSgpfSx2LmZvY3VzRmlyc3RGb2N1c2FibGVFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHIubGVuZ3RoPjA/KHJbMF0uZm9jdXMoKSwhMCk6ITF9LHYuZm9jdXNMYXN0Rm9jdXNhYmxlRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiByLmxlbmd0aD4wPyhyW3IubGVuZ3RoLTFdLmZvY3VzKCksITApOiExfSx2LmlzRm9jdXNJbkZpcnN0SXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gci5sZW5ndGg+MD8oYS50YXJnZXR8fGEuc3JjRWxlbWVudCk9PT1yWzBdOiExfSx2LmlzRm9jdXNJbkxhc3RJdGVtPWZ1bmN0aW9uKGEpe3JldHVybiByLmxlbmd0aD4wPyhhLnRhcmdldHx8YS5zcmNFbGVtZW50KT09PXJbci5sZW5ndGgtMV06ITF9LHYuY2xlYXJGb2N1c0xpc3RDYWNoZT1mdW5jdGlvbigpe3I9W10sdz0wfSx2LmxvYWRGb2N1c0VsZW1lbnRMaXN0PWZ1bmN0aW9uKGEpe2lmKCh2b2lkIDA9PT1yfHwhci5sZW5ndGgpJiZhKXt2YXIgYj1hLnZhbHVlLm1vZGFsRG9tRWw7YiYmYi5sZW5ndGgmJihyPWJbMF0ucXVlcnlTZWxlY3RvckFsbCh4KSl9fSx2fV0pLnByb3ZpZGVyKFxcXCIkdWliTW9kYWxcXFwiLGZ1bmN0aW9uKCl7dmFyIGE9e29wdGlvbnM6e2FuaW1hdGlvbjohMCxiYWNrZHJvcDohMCxrZXlib2FyZDohMH0sJGdldDpbXFxcIiRyb290U2NvcGVcXFwiLFxcXCIkcVxcXCIsXFxcIiRkb2N1bWVudFxcXCIsXFxcIiR0ZW1wbGF0ZVJlcXVlc3RcXFwiLFxcXCIkY29udHJvbGxlclxcXCIsXFxcIiR1aWJSZXNvbHZlXFxcIixcXFwiJHVpYk1vZGFsU3RhY2tcXFwiLGZ1bmN0aW9uKGIsYyxkLGUsZixnLGgpe2Z1bmN0aW9uIGkoYSl7cmV0dXJuIGEudGVtcGxhdGU/Yy53aGVuKGEudGVtcGxhdGUpOmUoYW5ndWxhci5pc0Z1bmN0aW9uKGEudGVtcGxhdGVVcmwpP2EudGVtcGxhdGVVcmwoKTphLnRlbXBsYXRlVXJsKX12YXIgaj17fSxrPW51bGw7cmV0dXJuIGouZ2V0UHJvbWlzZUNoYWluPWZ1bmN0aW9uKCl7cmV0dXJuIGt9LGoub3Blbj1mdW5jdGlvbihlKXtmdW5jdGlvbiBqKCl7cmV0dXJuIHJ9dmFyIGw9Yy5kZWZlcigpLG09Yy5kZWZlcigpLG49Yy5kZWZlcigpLG89Yy5kZWZlcigpLHA9e3Jlc3VsdDpsLnByb21pc2Usb3BlbmVkOm0ucHJvbWlzZSxjbG9zZWQ6bi5wcm9taXNlLHJlbmRlcmVkOm8ucHJvbWlzZSxjbG9zZTpmdW5jdGlvbihhKXtyZXR1cm4gaC5jbG9zZShwLGEpfSxkaXNtaXNzOmZ1bmN0aW9uKGEpe3JldHVybiBoLmRpc21pc3MocCxhKX19O2lmKGU9YW5ndWxhci5leHRlbmQoe30sYS5vcHRpb25zLGUpLGUucmVzb2x2ZT1lLnJlc29sdmV8fHt9LGUuYXBwZW5kVG89ZS5hcHBlbmRUb3x8ZC5maW5kKFxcXCJib2R5XFxcIikuZXEoMCksIWUudGVtcGxhdGUmJiFlLnRlbXBsYXRlVXJsKXRocm93IG5ldyBFcnJvcihcXFwiT25lIG9mIHRlbXBsYXRlIG9yIHRlbXBsYXRlVXJsIG9wdGlvbnMgaXMgcmVxdWlyZWQuXFxcIik7dmFyIHEscj1jLmFsbChbaShlKSxnLnJlc29sdmUoZS5yZXNvbHZlLHt9LG51bGwsbnVsbCldKTtyZXR1cm4gcT1rPWMuYWxsKFtrXSkudGhlbihqLGopLnRoZW4oZnVuY3Rpb24oYSl7dmFyIGM9ZS5zY29wZXx8YixkPWMuJG5ldygpO2QuJGNsb3NlPXAuY2xvc2UsZC4kZGlzbWlzcz1wLmRpc21pc3MsZC4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe2QuJCR1aWJEZXN0cnVjdGlvblNjaGVkdWxlZHx8ZC4kZGlzbWlzcyhcXFwiJHVpYlVuc2NoZWR1bGVkRGVzdHJ1Y3Rpb25cXFwiKX0pO3ZhciBnLGk9e307ZS5jb250cm9sbGVyJiYoaS4kc2NvcGU9ZCxpLiR1aWJNb2RhbEluc3RhbmNlPXAsYW5ndWxhci5mb3JFYWNoKGFbMV0sZnVuY3Rpb24oYSxiKXtpW2JdPWF9KSxnPWYoZS5jb250cm9sbGVyLGkpLGUuY29udHJvbGxlckFzJiYoZS5iaW5kVG9Db250cm9sbGVyJiYoZy4kY2xvc2U9ZC4kY2xvc2UsZy4kZGlzbWlzcz1kLiRkaXNtaXNzLGFuZ3VsYXIuZXh0ZW5kKGcsYykpLGRbZS5jb250cm9sbGVyQXNdPWcpKSxoLm9wZW4ocCx7c2NvcGU6ZCxkZWZlcnJlZDpsLHJlbmRlckRlZmVycmVkOm8sY2xvc2VkRGVmZXJyZWQ6bixjb250ZW50OmFbMF0sYW5pbWF0aW9uOmUuYW5pbWF0aW9uLGJhY2tkcm9wOmUuYmFja2Ryb3Asa2V5Ym9hcmQ6ZS5rZXlib2FyZCxiYWNrZHJvcENsYXNzOmUuYmFja2Ryb3BDbGFzcyx3aW5kb3dUb3BDbGFzczplLndpbmRvd1RvcENsYXNzLHdpbmRvd0NsYXNzOmUud2luZG93Q2xhc3Msd2luZG93VGVtcGxhdGVVcmw6ZS53aW5kb3dUZW1wbGF0ZVVybCxzaXplOmUuc2l6ZSxvcGVuZWRDbGFzczplLm9wZW5lZENsYXNzLGFwcGVuZFRvOmUuYXBwZW5kVG99KSxtLnJlc29sdmUoITApfSxmdW5jdGlvbihhKXttLnJlamVjdChhKSxsLnJlamVjdChhKX0pW1xcXCJmaW5hbGx5XFxcIl0oZnVuY3Rpb24oKXtrPT09cSYmKGs9bnVsbCl9KSxwfSxqfV19O3JldHVybiBhfSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5wYWdpbmdcXFwiLFtdKS5mYWN0b3J5KFxcXCJ1aWJQYWdpbmdcXFwiLFtcXFwiJHBhcnNlXFxcIixmdW5jdGlvbihhKXtyZXR1cm57Y3JlYXRlOmZ1bmN0aW9uKGIsYyxkKXtiLnNldE51bVBhZ2VzPWQubnVtUGFnZXM/YShkLm51bVBhZ2VzKS5hc3NpZ246YW5ndWxhci5ub29wLGIubmdNb2RlbEN0cmw9eyRzZXRWaWV3VmFsdWU6YW5ndWxhci5ub29wfSxiLl93YXRjaGVycz1bXSxiLmluaXQ9ZnVuY3Rpb24oZSxmKXtiLm5nTW9kZWxDdHJsPWUsYi5jb25maWc9ZixlLiRyZW5kZXI9ZnVuY3Rpb24oKXtiLnJlbmRlcigpfSxkLml0ZW1zUGVyUGFnZT9iLl93YXRjaGVycy5wdXNoKGMuJHBhcmVudC4kd2F0Y2goYShkLml0ZW1zUGVyUGFnZSksZnVuY3Rpb24oYSl7Yi5pdGVtc1BlclBhZ2U9cGFyc2VJbnQoYSwxMCksYy50b3RhbFBhZ2VzPWIuY2FsY3VsYXRlVG90YWxQYWdlcygpLGIudXBkYXRlUGFnZSgpfSkpOmIuaXRlbXNQZXJQYWdlPWYuaXRlbXNQZXJQYWdlLGMuJHdhdGNoKFxcXCJ0b3RhbEl0ZW1zXFxcIixmdW5jdGlvbihhLGQpeyhhbmd1bGFyLmlzRGVmaW5lZChhKXx8YSE9PWQpJiYoYy50b3RhbFBhZ2VzPWIuY2FsY3VsYXRlVG90YWxQYWdlcygpLGIudXBkYXRlUGFnZSgpKX0pfSxiLmNhbGN1bGF0ZVRvdGFsUGFnZXM9ZnVuY3Rpb24oKXt2YXIgYT1iLml0ZW1zUGVyUGFnZTwxPzE6TWF0aC5jZWlsKGMudG90YWxJdGVtcy9iLml0ZW1zUGVyUGFnZSk7cmV0dXJuIE1hdGgubWF4KGF8fDAsMSl9LGIucmVuZGVyPWZ1bmN0aW9uKCl7Yy5wYWdlPXBhcnNlSW50KGIubmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSwxMCl8fDF9LGMuc2VsZWN0UGFnZT1mdW5jdGlvbihhLGQpe2QmJmQucHJldmVudERlZmF1bHQoKTt2YXIgZT0hYy5uZ0Rpc2FibGVkfHwhZDtlJiZjLnBhZ2UhPT1hJiZhPjAmJmE8PWMudG90YWxQYWdlcyYmKGQmJmQudGFyZ2V0JiZkLnRhcmdldC5ibHVyKCksYi5uZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGEpLGIubmdNb2RlbEN0cmwuJHJlbmRlcigpKX0sYy5nZXRUZXh0PWZ1bmN0aW9uKGEpe3JldHVybiBjW2ErXFxcIlRleHRcXFwiXXx8Yi5jb25maWdbYStcXFwiVGV4dFxcXCJdfSxjLm5vUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4gMT09PWMucGFnZX0sYy5ub05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gYy5wYWdlPT09Yy50b3RhbFBhZ2VzfSxiLnVwZGF0ZVBhZ2U9ZnVuY3Rpb24oKXtiLnNldE51bVBhZ2VzKGMuJHBhcmVudCxjLnRvdGFsUGFnZXMpLGMucGFnZT5jLnRvdGFsUGFnZXM/Yy5zZWxlY3RQYWdlKGMudG90YWxQYWdlcyk6Yi5uZ01vZGVsQ3RybC4kcmVuZGVyKCl9LGMuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtmb3IoO2IuX3dhdGNoZXJzLmxlbmd0aDspYi5fd2F0Y2hlcnMuc2hpZnQoKSgpfSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnBhZ2VyXFxcIixbXFxcInVpLmJvb3RzdHJhcC5wYWdpbmdcXFwiXSkuY29udHJvbGxlcihcXFwiVWliUGFnZXJDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcInVpYlBhZ2luZ1xcXCIsXFxcInVpYlBhZ2VyQ29uZmlnXFxcIixmdW5jdGlvbihhLGIsYyxkKXthLmFsaWduPWFuZ3VsYXIuaXNEZWZpbmVkKGIuYWxpZ24pP2EuJHBhcmVudC4kZXZhbChiLmFsaWduKTpkLmFsaWduLGMuY3JlYXRlKHRoaXMsYSxiKX1dKS5jb25zdGFudChcXFwidWliUGFnZXJDb25maWdcXFwiLHtpdGVtc1BlclBhZ2U6MTAscHJldmlvdXNUZXh0OlxcXCLCqyBQcmV2aW91c1xcXCIsbmV4dFRleHQ6XFxcIk5leHQgwrtcXFwiLGFsaWduOiEwfSkuZGlyZWN0aXZlKFxcXCJ1aWJQYWdlclxcXCIsW1xcXCJ1aWJQYWdlckNvbmZpZ1xcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Njb3BlOnt0b3RhbEl0ZW1zOlxcXCI9XFxcIixwcmV2aW91c1RleHQ6XFxcIkBcXFwiLG5leHRUZXh0OlxcXCJAXFxcIixuZ0Rpc2FibGVkOlxcXCI9XFxcIn0scmVxdWlyZTpbXFxcInVpYlBhZ2VyXFxcIixcXFwiP25nTW9kZWxcXFwiXSxjb250cm9sbGVyOlxcXCJVaWJQYWdlckNvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwicGFnZXJcXFwiLHRlbXBsYXRlVXJsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudGVtcGxhdGVVcmx8fFxcXCJ1aWIvdGVtcGxhdGUvcGFnZXIvcGFnZXIuaHRtbFxcXCJ9LHJlcGxhY2U6ITAsbGluazpmdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1lWzBdLGc9ZVsxXTtnJiZmLmluaXQoZyxhKX19fV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAucGFnaW5hdGlvblxcXCIsW1xcXCJ1aS5ib290c3RyYXAucGFnaW5nXFxcIl0pLmNvbnRyb2xsZXIoXFxcIlVpYlBhZ2luYXRpb25Db250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcIiRwYXJzZVxcXCIsXFxcInVpYlBhZ2luZ1xcXCIsXFxcInVpYlBhZ2luYXRpb25Db25maWdcXFwiLGZ1bmN0aW9uKGEsYixjLGQsZSl7ZnVuY3Rpb24gZihhLGIsYyl7cmV0dXJue251bWJlcjphLHRleHQ6YixhY3RpdmU6Y319ZnVuY3Rpb24gZyhhLGIpe3ZhciBjPVtdLGQ9MSxlPWIsZz1hbmd1bGFyLmlzRGVmaW5lZChpKSYmYj5pO2cmJihqPyhkPU1hdGgubWF4KGEtTWF0aC5mbG9vcihpLzIpLDEpLGU9ZCtpLTEsZT5iJiYoZT1iLGQ9ZS1pKzEpKTooZD0oTWF0aC5jZWlsKGEvaSktMSkqaSsxLGU9TWF0aC5taW4oZCtpLTEsYikpKTtmb3IodmFyIGg9ZDtlPj1oO2grKyl7dmFyIG09ZihoLGgsaD09PWEpO2MucHVzaChtKX1pZihnJiZpPjAmJighanx8a3x8bCkpe2lmKGQ+MSl7aWYoIWx8fGQ+Myl7dmFyIG49ZihkLTEsXFxcIi4uLlxcXCIsITEpO2MudW5zaGlmdChuKX1pZihsKXtpZigzPT09ZCl7dmFyIG89ZigyLFxcXCIyXFxcIiwhMSk7Yy51bnNoaWZ0KG8pfXZhciBwPWYoMSxcXFwiMVxcXCIsITEpO2MudW5zaGlmdChwKX19aWYoYj5lKXtpZighbHx8Yi0yPmUpe3ZhciBxPWYoZSsxLFxcXCIuLi5cXFwiLCExKTtjLnB1c2gocSl9aWYobCl7aWYoZT09PWItMil7dmFyIHI9ZihiLTEsYi0xLCExKTtjLnB1c2gocil9dmFyIHM9ZihiLGIsITEpO2MucHVzaChzKX19fXJldHVybiBjfXZhciBoPXRoaXMsaT1hbmd1bGFyLmlzRGVmaW5lZChiLm1heFNpemUpP2EuJHBhcmVudC4kZXZhbChiLm1heFNpemUpOmUubWF4U2l6ZSxqPWFuZ3VsYXIuaXNEZWZpbmVkKGIucm90YXRlKT9hLiRwYXJlbnQuJGV2YWwoYi5yb3RhdGUpOmUucm90YXRlLGs9YW5ndWxhci5pc0RlZmluZWQoYi5mb3JjZUVsbGlwc2VzKT9hLiRwYXJlbnQuJGV2YWwoYi5mb3JjZUVsbGlwc2VzKTplLmZvcmNlRWxsaXBzZXMsbD1hbmd1bGFyLmlzRGVmaW5lZChiLmJvdW5kYXJ5TGlua051bWJlcnMpP2EuJHBhcmVudC4kZXZhbChiLmJvdW5kYXJ5TGlua051bWJlcnMpOmUuYm91bmRhcnlMaW5rTnVtYmVyczthLmJvdW5kYXJ5TGlua3M9YW5ndWxhci5pc0RlZmluZWQoYi5ib3VuZGFyeUxpbmtzKT9hLiRwYXJlbnQuJGV2YWwoYi5ib3VuZGFyeUxpbmtzKTplLmJvdW5kYXJ5TGlua3MsYS5kaXJlY3Rpb25MaW5rcz1hbmd1bGFyLmlzRGVmaW5lZChiLmRpcmVjdGlvbkxpbmtzKT9hLiRwYXJlbnQuJGV2YWwoYi5kaXJlY3Rpb25MaW5rcyk6ZS5kaXJlY3Rpb25MaW5rcyxkLmNyZWF0ZSh0aGlzLGEsYiksYi5tYXhTaXplJiZoLl93YXRjaGVycy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goYyhiLm1heFNpemUpLGZ1bmN0aW9uKGEpe2k9cGFyc2VJbnQoYSwxMCksaC5yZW5kZXIoKX0pKTt2YXIgbT10aGlzLnJlbmRlcjt0aGlzLnJlbmRlcj1mdW5jdGlvbigpe20oKSxhLnBhZ2U+MCYmYS5wYWdlPD1hLnRvdGFsUGFnZXMmJihhLnBhZ2VzPWcoYS5wYWdlLGEudG90YWxQYWdlcykpfX1dKS5jb25zdGFudChcXFwidWliUGFnaW5hdGlvbkNvbmZpZ1xcXCIse2l0ZW1zUGVyUGFnZToxMCxib3VuZGFyeUxpbmtzOiExLGJvdW5kYXJ5TGlua051bWJlcnM6ITEsZGlyZWN0aW9uTGlua3M6ITAsZmlyc3RUZXh0OlxcXCJGaXJzdFxcXCIscHJldmlvdXNUZXh0OlxcXCJQcmV2aW91c1xcXCIsbmV4dFRleHQ6XFxcIk5leHRcXFwiLGxhc3RUZXh0OlxcXCJMYXN0XFxcIixyb3RhdGU6ITAsZm9yY2VFbGxpcHNlczohMX0pLmRpcmVjdGl2ZShcXFwidWliUGFnaW5hdGlvblxcXCIsW1xcXCIkcGFyc2VcXFwiLFxcXCJ1aWJQYWdpbmF0aW9uQ29uZmlnXFxcIixmdW5jdGlvbihhLGIpe3JldHVybntzY29wZTp7dG90YWxJdGVtczpcXFwiPVxcXCIsZmlyc3RUZXh0OlxcXCJAXFxcIixwcmV2aW91c1RleHQ6XFxcIkBcXFwiLG5leHRUZXh0OlxcXCJAXFxcIixsYXN0VGV4dDpcXFwiQFxcXCIsbmdEaXNhYmxlZDpcXFwiPVxcXCJ9LHJlcXVpcmU6W1xcXCJ1aWJQYWdpbmF0aW9uXFxcIixcXFwiP25nTW9kZWxcXFwiXSxjb250cm9sbGVyOlxcXCJVaWJQYWdpbmF0aW9uQ29udHJvbGxlclxcXCIsY29udHJvbGxlckFzOlxcXCJwYWdpbmF0aW9uXFxcIix0ZW1wbGF0ZVVybDpmdW5jdGlvbihhLGIpe3JldHVybiBiLnRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXFxcIn0scmVwbGFjZTohMCxsaW5rOmZ1bmN0aW9uKGEsYyxkLGUpe3ZhciBmPWVbMF0sZz1lWzFdO2cmJmYuaW5pdChnLGIpfX19XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC50b29sdGlwXFxcIixbXFxcInVpLmJvb3RzdHJhcC5wb3NpdGlvblxcXCIsXFxcInVpLmJvb3RzdHJhcC5zdGFja2VkTWFwXFxcIl0pLnByb3ZpZGVyKFxcXCIkdWliVG9vbHRpcFxcXCIsZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe3ZhciBiPS9bQS1aXS9nLGM9XFxcIi1cXFwiO3JldHVybiBhLnJlcGxhY2UoYixmdW5jdGlvbihhLGIpe3JldHVybihiP2M6XFxcIlxcXCIpK2EudG9Mb3dlckNhc2UoKX0pfXZhciBiPXtwbGFjZW1lbnQ6XFxcInRvcFxcXCIscGxhY2VtZW50Q2xhc3NQcmVmaXg6XFxcIlxcXCIsYW5pbWF0aW9uOiEwLHBvcHVwRGVsYXk6MCxwb3B1cENsb3NlRGVsYXk6MCx1c2VDb250ZW50RXhwOiExfSxjPXttb3VzZWVudGVyOlxcXCJtb3VzZWxlYXZlXFxcIixjbGljazpcXFwiY2xpY2tcXFwiLG91dHNpZGVDbGljazpcXFwib3V0c2lkZUNsaWNrXFxcIixmb2N1czpcXFwiYmx1clxcXCIsbm9uZTpcXFwiXFxcIn0sZD17fTt0aGlzLm9wdGlvbnM9ZnVuY3Rpb24oYSl7YW5ndWxhci5leHRlbmQoZCxhKX0sdGhpcy5zZXRUcmlnZ2Vycz1mdW5jdGlvbihhKXthbmd1bGFyLmV4dGVuZChjLGEpfSx0aGlzLiRnZXQ9W1xcXCIkd2luZG93XFxcIixcXFwiJGNvbXBpbGVcXFwiLFxcXCIkdGltZW91dFxcXCIsXFxcIiRkb2N1bWVudFxcXCIsXFxcIiR1aWJQb3NpdGlvblxcXCIsXFxcIiRpbnRlcnBvbGF0ZVxcXCIsXFxcIiRyb290U2NvcGVcXFwiLFxcXCIkcGFyc2VcXFwiLFxcXCIkJHN0YWNrZWRNYXBcXFwiLGZ1bmN0aW9uKGUsZixnLGgsaSxqLGssbCxtKXtmdW5jdGlvbiBuKGEpe2lmKDI3PT09YS53aGljaCl7dmFyIGI9by50b3AoKTtiJiYoYi52YWx1ZS5jbG9zZSgpLG8ucmVtb3ZlVG9wKCksYj1udWxsKX19dmFyIG89bS5jcmVhdGVOZXcoKTtyZXR1cm4gaC5vbihcXFwia2V5cHJlc3NcXFwiLG4pLGsuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtoLm9mZihcXFwia2V5cHJlc3NcXFwiLG4pfSksZnVuY3Rpb24oZSxrLG0sbil7ZnVuY3Rpb24gcChhKXt2YXIgYj0oYXx8bi50cmlnZ2VyfHxtKS5zcGxpdChcXFwiIFxcXCIpLGQ9Yi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGNbYV18fGF9KTtyZXR1cm57c2hvdzpiLGhpZGU6ZH19bj1hbmd1bGFyLmV4dGVuZCh7fSxiLGQsbik7dmFyIHE9YShlKSxyPWouc3RhcnRTeW1ib2woKSxzPWouZW5kU3ltYm9sKCksdD1cXFwiPGRpdiBcXFwiK3ErJy1wb3B1cCB0aXRsZT1cXFwiJytyK1xcXCJ0aXRsZVxcXCIrcysnXFxcIiAnKyhuLnVzZUNvbnRlbnRFeHA/J2NvbnRlbnQtZXhwPVxcXCJjb250ZW50RXhwKClcXFwiICc6J2NvbnRlbnQ9XFxcIicrcitcXFwiY29udGVudFxcXCIrcysnXFxcIiAnKSsncGxhY2VtZW50PVxcXCInK3IrXFxcInBsYWNlbWVudFxcXCIrcysnXFxcIiBwb3B1cC1jbGFzcz1cXFwiJytyK1xcXCJwb3B1cENsYXNzXFxcIitzKydcXFwiIGFuaW1hdGlvbj1cXFwiYW5pbWF0aW9uXFxcIiBpcy1vcGVuPVxcXCJpc09wZW5cXFwib3JpZ2luLXNjb3BlPVxcXCJvcmlnU2NvcGVcXFwiIHN0eWxlPVxcXCJ2aXNpYmlsaXR5OiBoaWRkZW47IGRpc3BsYXk6IGJsb2NrOyB0b3A6IC05OTk5cHg7IGxlZnQ6IC05OTk5cHg7XFxcIj48L2Rpdj4nO3JldHVybntjb21waWxlOmZ1bmN0aW9uKGEsYil7dmFyIGM9Zih0KTtyZXR1cm4gZnVuY3Rpb24oYSxiLGQsZil7ZnVuY3Rpb24gaigpe00uaXNPcGVuP3EoKTptKCl9ZnVuY3Rpb24gbSgpeyghTHx8YS4kZXZhbChkW2srXFxcIkVuYWJsZVxcXCJdKSkmJih1KCkseCgpLE0ucG9wdXBEZWxheT9HfHwoRz1nKHIsTS5wb3B1cERlbGF5LCExKSk6cigpKX1mdW5jdGlvbiBxKCl7cygpLE0ucG9wdXBDbG9zZURlbGF5P0h8fChIPWcodCxNLnBvcHVwQ2xvc2VEZWxheSwhMSkpOnQoKX1mdW5jdGlvbiByKCl7cmV0dXJuIHMoKSx1KCksTS5jb250ZW50Pyh2KCksdm9pZCBNLiRldmFsQXN5bmMoZnVuY3Rpb24oKXtNLmlzT3Blbj0hMCx5KCEwKSxSKCl9KSk6YW5ndWxhci5ub29wfWZ1bmN0aW9uIHMoKXtHJiYoZy5jYW5jZWwoRyksRz1udWxsKSxJJiYoZy5jYW5jZWwoSSksST1udWxsKX1mdW5jdGlvbiB0KCl7TSYmTS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7TSYmKE0uaXNPcGVuPSExLHkoITEpLE0uYW5pbWF0aW9uP0Z8fChGPWcodywxNTAsITEpKTp3KCkpfSl9ZnVuY3Rpb24gdSgpe0gmJihnLmNhbmNlbChIKSxIPW51bGwpLEYmJihnLmNhbmNlbChGKSxGPW51bGwpfWZ1bmN0aW9uIHYoKXtEfHwoRT1NLiRuZXcoKSxEPWMoRSxmdW5jdGlvbihhKXtKP2guZmluZChcXFwiYm9keVxcXCIpLmFwcGVuZChhKTpiLmFmdGVyKGEpfSkseigpKX1mdW5jdGlvbiB3KCl7cygpLHUoKSxBKCksRCYmKEQucmVtb3ZlKCksRD1udWxsKSxFJiYoRS4kZGVzdHJveSgpLEU9bnVsbCl9ZnVuY3Rpb24geCgpe00udGl0bGU9ZFtrK1xcXCJUaXRsZVxcXCJdLFA/TS5jb250ZW50PVAoYSk6TS5jb250ZW50PWRbZV0sTS5wb3B1cENsYXNzPWRbaytcXFwiQ2xhc3NcXFwiXSxNLnBsYWNlbWVudD1hbmd1bGFyLmlzRGVmaW5lZChkW2srXFxcIlBsYWNlbWVudFxcXCJdKT9kW2srXFxcIlBsYWNlbWVudFxcXCJdOm4ucGxhY2VtZW50O3ZhciBiPXBhcnNlSW50KGRbaytcXFwiUG9wdXBEZWxheVxcXCJdLDEwKSxjPXBhcnNlSW50KGRbaytcXFwiUG9wdXBDbG9zZURlbGF5XFxcIl0sMTApO00ucG9wdXBEZWxheT1pc05hTihiKT9uLnBvcHVwRGVsYXk6YixNLnBvcHVwQ2xvc2VEZWxheT1pc05hTihjKT9uLnBvcHVwQ2xvc2VEZWxheTpjfWZ1bmN0aW9uIHkoYil7TyYmYW5ndWxhci5pc0Z1bmN0aW9uKE8uYXNzaWduKSYmTy5hc3NpZ24oYSxiKX1mdW5jdGlvbiB6KCl7US5sZW5ndGg9MCxQPyhRLnB1c2goYS4kd2F0Y2goUCxmdW5jdGlvbihhKXtNLmNvbnRlbnQ9YSwhYSYmTS5pc09wZW4mJnQoKX0pKSxRLnB1c2goRS4kd2F0Y2goZnVuY3Rpb24oKXtOfHwoTj0hMCxFLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpe049ITEsTSYmTS5pc09wZW4mJlIoKX0pKX0pKSk6US5wdXNoKGQuJG9ic2VydmUoZSxmdW5jdGlvbihhKXtNLmNvbnRlbnQ9YSwhYSYmTS5pc09wZW4/dCgpOlIoKX0pKSxRLnB1c2goZC4kb2JzZXJ2ZShrK1xcXCJUaXRsZVxcXCIsZnVuY3Rpb24oYSl7TS50aXRsZT1hLE0uaXNPcGVuJiZSKCl9KSksUS5wdXNoKGQuJG9ic2VydmUoaytcXFwiUGxhY2VtZW50XFxcIixmdW5jdGlvbihhKXtNLnBsYWNlbWVudD1hP2E6bi5wbGFjZW1lbnQsTS5pc09wZW4mJlIoKX0pKX1mdW5jdGlvbiBBKCl7US5sZW5ndGgmJihhbmd1bGFyLmZvckVhY2goUSxmdW5jdGlvbihhKXthKCl9KSxRLmxlbmd0aD0wKX1mdW5jdGlvbiBCKGEpe00mJk0uaXNPcGVuJiZEJiYoYlswXS5jb250YWlucyhhLnRhcmdldCl8fERbMF0uY29udGFpbnMoYS50YXJnZXQpfHxxKCkpfWZ1bmN0aW9uIEMoKXt2YXIgYT1kW2srXFxcIlRyaWdnZXJcXFwiXTtTKCksSz1wKGEpLFxcXCJub25lXFxcIiE9PUsuc2hvdyYmSy5zaG93LmZvckVhY2goZnVuY3Rpb24oYSxjKXtcXFwib3V0c2lkZUNsaWNrXFxcIj09PWE/KGIub24oXFxcImNsaWNrXFxcIixqKSxoLm9uKFxcXCJjbGlja1xcXCIsQikpOmE9PT1LLmhpZGVbY10/Yi5vbihhLGopOmEmJihiLm9uKGEsbSksYi5vbihLLmhpZGVbY10scSkpLGIub24oXFxcImtleXByZXNzXFxcIixmdW5jdGlvbihhKXsyNz09PWEud2hpY2gmJnEoKX0pfSl9dmFyIEQsRSxGLEcsSCxJLEo9YW5ndWxhci5pc0RlZmluZWQobi5hcHBlbmRUb0JvZHkpP24uYXBwZW5kVG9Cb2R5OiExLEs9cCh2b2lkIDApLEw9YW5ndWxhci5pc0RlZmluZWQoZFtrK1xcXCJFbmFibGVcXFwiXSksTT1hLiRuZXcoITApLE49ITEsTz1hbmd1bGFyLmlzRGVmaW5lZChkW2srXFxcIklzT3BlblxcXCJdKT9sKGRbaytcXFwiSXNPcGVuXFxcIl0pOiExLFA9bi51c2VDb250ZW50RXhwP2woZFtlXSk6ITEsUT1bXSxSPWZ1bmN0aW9uKCl7RCYmRC5odG1sKCkmJihJfHwoST1nKGZ1bmN0aW9uKCl7RC5jc3Moe3RvcDowLGxlZnQ6MH0pO3ZhciBhPWkucG9zaXRpb25FbGVtZW50cyhiLEQsTS5wbGFjZW1lbnQsSik7RC5jc3Moe3RvcDphLnRvcCtcXFwicHhcXFwiLGxlZnQ6YS5sZWZ0K1xcXCJweFxcXCIsdmlzaWJpbGl0eTpcXFwidmlzaWJsZVxcXCJ9KSxuLnBsYWNlbWVudENsYXNzUHJlZml4JiZELnJlbW92ZUNsYXNzKFxcXCJ0b3AgYm90dG9tIGxlZnQgcmlnaHRcXFwiKSxELnJlbW92ZUNsYXNzKG4ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcInRvcCBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcInRvcC1sZWZ0IFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwidG9wLXJpZ2h0IFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwiYm90dG9tIFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwiYm90dG9tLWxlZnQgXFxcIituLnBsYWNlbWVudENsYXNzUHJlZml4K1xcXCJib3R0b20tcmlnaHQgXFxcIituLnBsYWNlbWVudENsYXNzUHJlZml4K1xcXCJsZWZ0IFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwibGVmdC10b3AgXFxcIituLnBsYWNlbWVudENsYXNzUHJlZml4K1xcXCJsZWZ0LWJvdHRvbSBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrXFxcInJpZ2h0IFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwicmlnaHQtdG9wIFxcXCIrbi5wbGFjZW1lbnRDbGFzc1ByZWZpeCtcXFwicmlnaHQtYm90dG9tXFxcIik7dmFyIGM9YS5wbGFjZW1lbnQuc3BsaXQoXFxcIi1cXFwiKTtELmFkZENsYXNzKGNbMF0rXFxcIiBcXFwiK24ucGxhY2VtZW50Q2xhc3NQcmVmaXgrYS5wbGFjZW1lbnQpLGkucG9zaXRpb25BcnJvdyhELGEucGxhY2VtZW50KSxJPW51bGx9LDAsITEpKSl9O00ub3JpZ1Njb3BlPWEsTS5pc09wZW49ITEsby5hZGQoTSx7Y2xvc2U6dH0pLE0uY29udGVudEV4cD1mdW5jdGlvbigpe3JldHVybiBNLmNvbnRlbnR9LGQuJG9ic2VydmUoXFxcImRpc2FibGVkXFxcIixmdW5jdGlvbihhKXthJiZzKCksYSYmTS5pc09wZW4mJnQoKX0pLE8mJmEuJHdhdGNoKE8sZnVuY3Rpb24oYSl7TSYmIWE9PT1NLmlzT3BlbiYmaigpfSk7dmFyIFM9ZnVuY3Rpb24oKXtLLnNob3cuZm9yRWFjaChmdW5jdGlvbihhKXtcXFwib3V0c2lkZUNsaWNrXFxcIj09PWE/Yi5vZmYoXFxcImNsaWNrXFxcIixqKTooYi5vZmYoYSxtKSxiLm9mZihhLGopKX0pLEsuaGlkZS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xcXCJvdXRzaWRlQ2xpY2tcXFwiPT09YT9oLm9mZihcXFwiY2xpY2tcXFwiLEIpOmIub2ZmKGEscSl9KX07QygpO3ZhciBUPWEuJGV2YWwoZFtrK1xcXCJBbmltYXRpb25cXFwiXSk7TS5hbmltYXRpb249YW5ndWxhci5pc0RlZmluZWQoVCk/ISFUOm4uYW5pbWF0aW9uO3ZhciBVLFY9aytcXFwiQXBwZW5kVG9Cb2R5XFxcIjtVPVYgaW4gZCYmdm9pZCAwPT09ZFtWXT8hMDphLiRldmFsKGRbVl0pLEo9YW5ndWxhci5pc0RlZmluZWQoVSk/VTpKLEomJmEuJG9uKFxcXCIkbG9jYXRpb25DaGFuZ2VTdWNjZXNzXFxcIixmdW5jdGlvbigpe00uaXNPcGVuJiZ0KCl9KSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7UygpLHcoKSxvLnJlbW92ZShNKSxNPW51bGx9KX19fX19XX0pLmRpcmVjdGl2ZShcXFwidWliVG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZVxcXCIsW1xcXCIkYW5pbWF0ZVxcXCIsXFxcIiRzY2VcXFwiLFxcXCIkY29tcGlsZVxcXCIsXFxcIiR0ZW1wbGF0ZVJlcXVlc3RcXFwiLGZ1bmN0aW9uKGEsYixjLGQpe3JldHVybntsaW5rOmZ1bmN0aW9uKGUsZixnKXt2YXIgaCxpLGosaz1lLiRldmFsKGcudG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZVNjb3BlKSxsPTAsbT1mdW5jdGlvbigpe2kmJihpLnJlbW92ZSgpLGk9bnVsbCksaCYmKGguJGRlc3Ryb3koKSxoPW51bGwpLGomJihhLmxlYXZlKGopLnRoZW4oZnVuY3Rpb24oKXtpPW51bGx9KSxpPWosaj1udWxsKX07ZS4kd2F0Y2goYi5wYXJzZUFzUmVzb3VyY2VVcmwoZy51aWJUb29sdGlwVGVtcGxhdGVUcmFuc2NsdWRlKSxmdW5jdGlvbihiKXt2YXIgZz0rK2w7Yj8oZChiLCEwKS50aGVuKGZ1bmN0aW9uKGQpe2lmKGc9PT1sKXt2YXIgZT1rLiRuZXcoKSxpPWQsbj1jKGkpKGUsZnVuY3Rpb24oYil7bSgpLGEuZW50ZXIoYixmKX0pO2g9ZSxqPW4saC4kZW1pdChcXFwiJGluY2x1ZGVDb250ZW50TG9hZGVkXFxcIixiKX19LGZ1bmN0aW9uKCl7Zz09PWwmJihtKCksZS4kZW1pdChcXFwiJGluY2x1ZGVDb250ZW50RXJyb3JcXFwiLGIpKX0pLGUuJGVtaXQoXFxcIiRpbmNsdWRlQ29udGVudFJlcXVlc3RlZFxcXCIsYikpOm0oKX0pLGUuJG9uKFxcXCIkZGVzdHJveVxcXCIsbSl9fX1dKS5kaXJlY3RpdmUoXFxcInVpYlRvb2x0aXBDbGFzc2VzXFxcIixbXFxcIiR1aWJQb3NpdGlvblxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Jlc3RyaWN0OlxcXCJBXFxcIixsaW5rOmZ1bmN0aW9uKGIsYyxkKXtpZihiLnBsYWNlbWVudCl7dmFyIGU9YS5wYXJzZVBsYWNlbWVudChiLnBsYWNlbWVudCk7Yy5hZGRDbGFzcyhlWzBdKX1lbHNlIGMuYWRkQ2xhc3MoXFxcInRvcFxcXCIpO2IucG9wdXBDbGFzcyYmYy5hZGRDbGFzcyhiLnBvcHVwQ2xhc3MpLGIuYW5pbWF0aW9uKCkmJmMuYWRkQ2xhc3MoZC50b29sdGlwQW5pbWF0aW9uQ2xhc3MpfX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJUb29sdGlwUG9wdXBcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsc2NvcGU6e2NvbnRlbnQ6XFxcIkBcXFwiLHBsYWNlbWVudDpcXFwiQFxcXCIscG9wdXBDbGFzczpcXFwiQFxcXCIsYW5pbWF0aW9uOlxcXCImXFxcIixpc09wZW46XFxcIiZcXFwiXFxufSx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXFxcIn19KS5kaXJlY3RpdmUoXFxcInVpYlRvb2x0aXBcXFwiLFtcXFwiJHVpYlRvb2x0aXBcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhKFxcXCJ1aWJUb29sdGlwXFxcIixcXFwidG9vbHRpcFxcXCIsXFxcIm1vdXNlZW50ZXJcXFwiKX1dKS5kaXJlY3RpdmUoXFxcInVpYlRvb2x0aXBUZW1wbGF0ZVBvcHVwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHNjb3BlOntjb250ZW50RXhwOlxcXCImXFxcIixwbGFjZW1lbnQ6XFxcIkBcXFwiLHBvcHVwQ2xhc3M6XFxcIkBcXFwiLGFuaW1hdGlvbjpcXFwiJlxcXCIsaXNPcGVuOlxcXCImXFxcIixvcmlnaW5TY29wZTpcXFwiJlxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcXFwifX0pLmRpcmVjdGl2ZShcXFwidWliVG9vbHRpcFRlbXBsYXRlXFxcIixbXFxcIiR1aWJUb29sdGlwXFxcIixmdW5jdGlvbihhKXtyZXR1cm4gYShcXFwidWliVG9vbHRpcFRlbXBsYXRlXFxcIixcXFwidG9vbHRpcFxcXCIsXFxcIm1vdXNlZW50ZXJcXFwiLHt1c2VDb250ZW50RXhwOiEwfSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJUb29sdGlwSHRtbFBvcHVwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHNjb3BlOntjb250ZW50RXhwOlxcXCImXFxcIixwbGFjZW1lbnQ6XFxcIkBcXFwiLHBvcHVwQ2xhc3M6XFxcIkBcXFwiLGFuaW1hdGlvbjpcXFwiJlxcXCIsaXNPcGVuOlxcXCImXFxcIn0sdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sXFxcIn19KS5kaXJlY3RpdmUoXFxcInVpYlRvb2x0aXBIdG1sXFxcIixbXFxcIiR1aWJUb29sdGlwXFxcIixmdW5jdGlvbihhKXtyZXR1cm4gYShcXFwidWliVG9vbHRpcEh0bWxcXFwiLFxcXCJ0b29sdGlwXFxcIixcXFwibW91c2VlbnRlclxcXCIse3VzZUNvbnRlbnRFeHA6ITB9KX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnBvcG92ZXJcXFwiLFtcXFwidWkuYm9vdHN0cmFwLnRvb2x0aXBcXFwiXSkuZGlyZWN0aXZlKFxcXCJ1aWJQb3BvdmVyVGVtcGxhdGVQb3B1cFxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCxzY29wZTp7dGl0bGU6XFxcIkBcXFwiLGNvbnRlbnRFeHA6XFxcIiZcXFwiLHBsYWNlbWVudDpcXFwiQFxcXCIscG9wdXBDbGFzczpcXFwiQFxcXCIsYW5pbWF0aW9uOlxcXCImXFxcIixpc09wZW46XFxcIiZcXFwiLG9yaWdpblNjb3BlOlxcXCImXFxcIn0sdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFxcXCJ9fSkuZGlyZWN0aXZlKFxcXCJ1aWJQb3BvdmVyVGVtcGxhdGVcXFwiLFtcXFwiJHVpYlRvb2x0aXBcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhKFxcXCJ1aWJQb3BvdmVyVGVtcGxhdGVcXFwiLFxcXCJwb3BvdmVyXFxcIixcXFwiY2xpY2tcXFwiLHt1c2VDb250ZW50RXhwOiEwfSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJQb3BvdmVySHRtbFBvcHVwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHNjb3BlOntjb250ZW50RXhwOlxcXCImXFxcIix0aXRsZTpcXFwiQFxcXCIscGxhY2VtZW50OlxcXCJAXFxcIixwb3B1cENsYXNzOlxcXCJAXFxcIixhbmltYXRpb246XFxcIiZcXFwiLGlzT3BlbjpcXFwiJlxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFxcXCJ9fSkuZGlyZWN0aXZlKFxcXCJ1aWJQb3BvdmVySHRtbFxcXCIsW1xcXCIkdWliVG9vbHRpcFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEoXFxcInVpYlBvcG92ZXJIdG1sXFxcIixcXFwicG9wb3ZlclxcXCIsXFxcImNsaWNrXFxcIix7dXNlQ29udGVudEV4cDohMH0pfV0pLmRpcmVjdGl2ZShcXFwidWliUG9wb3ZlclBvcHVwXFxcIixmdW5jdGlvbigpe3JldHVybntyZXBsYWNlOiEwLHNjb3BlOnt0aXRsZTpcXFwiQFxcXCIsY29udGVudDpcXFwiQFxcXCIscGxhY2VtZW50OlxcXCJAXFxcIixwb3B1cENsYXNzOlxcXCJAXFxcIixhbmltYXRpb246XFxcIiZcXFwiLGlzT3BlbjpcXFwiJlxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcXFwifX0pLmRpcmVjdGl2ZShcXFwidWliUG9wb3ZlclxcXCIsW1xcXCIkdWliVG9vbHRpcFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEoXFxcInVpYlBvcG92ZXJcXFwiLFxcXCJwb3BvdmVyXFxcIixcXFwiY2xpY2tcXFwiKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnByb2dyZXNzYmFyXFxcIixbXSkuY29uc3RhbnQoXFxcInVpYlByb2dyZXNzQ29uZmlnXFxcIix7YW5pbWF0ZTohMCxtYXg6MTAwfSkuY29udHJvbGxlcihcXFwiVWliUHJvZ3Jlc3NDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcInVpYlByb2dyZXNzQ29uZmlnXFxcIixmdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcyxlPWFuZ3VsYXIuaXNEZWZpbmVkKGIuYW5pbWF0ZSk/YS4kcGFyZW50LiRldmFsKGIuYW5pbWF0ZSk6Yy5hbmltYXRlO3RoaXMuYmFycz1bXSxhLm1heD1hbmd1bGFyLmlzRGVmaW5lZChhLm1heCk/YS5tYXg6Yy5tYXgsdGhpcy5hZGRCYXI9ZnVuY3Rpb24oYixjLGYpe2V8fGMuY3NzKHt0cmFuc2l0aW9uOlxcXCJub25lXFxcIn0pLHRoaXMuYmFycy5wdXNoKGIpLGIubWF4PWEubWF4LGIudGl0bGU9ZiYmYW5ndWxhci5pc0RlZmluZWQoZi50aXRsZSk/Zi50aXRsZTpcXFwicHJvZ3Jlc3NiYXJcXFwiLGIuJHdhdGNoKFxcXCJ2YWx1ZVxcXCIsZnVuY3Rpb24oYSl7Yi5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKX0pLGIucmVjYWxjdWxhdGVQZXJjZW50YWdlPWZ1bmN0aW9uKCl7dmFyIGE9ZC5iYXJzLnJlZHVjZShmdW5jdGlvbihhLGIpe3JldHVybiBiLnBlcmNlbnQ9KygxMDAqYi52YWx1ZS9iLm1heCkudG9GaXhlZCgyKSxhK2IucGVyY2VudH0sMCk7YT4xMDAmJihiLnBlcmNlbnQtPWEtMTAwKX0sYi4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe2M9bnVsbCxkLnJlbW92ZUJhcihiKX0pfSx0aGlzLnJlbW92ZUJhcj1mdW5jdGlvbihhKXt0aGlzLmJhcnMuc3BsaWNlKHRoaXMuYmFycy5pbmRleE9mKGEpLDEpLHRoaXMuYmFycy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EucmVjYWxjdWxhdGVQZXJjZW50YWdlKCl9KX0sYS4kd2F0Y2goXFxcIm1heFxcXCIsZnVuY3Rpb24oYil7ZC5iYXJzLmZvckVhY2goZnVuY3Rpb24oYil7Yi5tYXg9YS5tYXgsYi5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKX0pfSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJQcm9ncmVzc1xcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCx0cmFuc2NsdWRlOiEwLGNvbnRyb2xsZXI6XFxcIlVpYlByb2dyZXNzQ29udHJvbGxlclxcXCIscmVxdWlyZTpcXFwidWliUHJvZ3Jlc3NcXFwiLHNjb3BlOnttYXg6XFxcIj0/XFxcIn0sdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXFxcIn19KS5kaXJlY3RpdmUoXFxcInVpYkJhclxcXCIsZnVuY3Rpb24oKXtyZXR1cm57cmVwbGFjZTohMCx0cmFuc2NsdWRlOiEwLHJlcXVpcmU6XFxcIl51aWJQcm9ncmVzc1xcXCIsc2NvcGU6e3ZhbHVlOlxcXCI9XFxcIix0eXBlOlxcXCJAXFxcIn0sdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXtkLmFkZEJhcihhLGIsYyl9fX0pLmRpcmVjdGl2ZShcXFwidWliUHJvZ3Jlc3NiYXJcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcGxhY2U6ITAsdHJhbnNjbHVkZTohMCxjb250cm9sbGVyOlxcXCJVaWJQcm9ncmVzc0NvbnRyb2xsZXJcXFwiLHNjb3BlOnt2YWx1ZTpcXFwiPVxcXCIsbWF4OlxcXCI9P1xcXCIsdHlwZTpcXFwiQFxcXCJ9LHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFxcXCIsbGluazpmdW5jdGlvbihhLGIsYyxkKXtkLmFkZEJhcihhLGFuZ3VsYXIuZWxlbWVudChiLmNoaWxkcmVuKClbMF0pLHt0aXRsZTpjLnRpdGxlfSl9fX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAucmF0aW5nXFxcIixbXSkuY29uc3RhbnQoXFxcInVpYlJhdGluZ0NvbmZpZ1xcXCIse21heDo1LHN0YXRlT246bnVsbCxzdGF0ZU9mZjpudWxsLHRpdGxlczpbXFxcIm9uZVxcXCIsXFxcInR3b1xcXCIsXFxcInRocmVlXFxcIixcXFwiZm91clxcXCIsXFxcImZpdmVcXFwiXX0pLmNvbnRyb2xsZXIoXFxcIlVpYlJhdGluZ0NvbnRyb2xsZXJcXFwiLFtcXFwiJHNjb3BlXFxcIixcXFwiJGF0dHJzXFxcIixcXFwidWliUmF0aW5nQ29uZmlnXFxcIixmdW5jdGlvbihhLGIsYyl7dmFyIGQ9eyRzZXRWaWV3VmFsdWU6YW5ndWxhci5ub29wfTt0aGlzLmluaXQ9ZnVuY3Rpb24oZSl7ZD1lLGQuJHJlbmRlcj10aGlzLnJlbmRlcixkLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24oYSl7cmV0dXJuIGFuZ3VsYXIuaXNOdW1iZXIoYSkmJmE8PDAhPT1hJiYoYT1NYXRoLnJvdW5kKGEpKSxhfSksdGhpcy5zdGF0ZU9uPWFuZ3VsYXIuaXNEZWZpbmVkKGIuc3RhdGVPbik/YS4kcGFyZW50LiRldmFsKGIuc3RhdGVPbik6Yy5zdGF0ZU9uLHRoaXMuc3RhdGVPZmY9YW5ndWxhci5pc0RlZmluZWQoYi5zdGF0ZU9mZik/YS4kcGFyZW50LiRldmFsKGIuc3RhdGVPZmYpOmMuc3RhdGVPZmY7dmFyIGY9YW5ndWxhci5pc0RlZmluZWQoYi50aXRsZXMpP2EuJHBhcmVudC4kZXZhbChiLnRpdGxlcyk6Yy50aXRsZXM7dGhpcy50aXRsZXM9YW5ndWxhci5pc0FycmF5KGYpJiZmLmxlbmd0aD4wP2Y6Yy50aXRsZXM7dmFyIGc9YW5ndWxhci5pc0RlZmluZWQoYi5yYXRpbmdTdGF0ZXMpP2EuJHBhcmVudC4kZXZhbChiLnJhdGluZ1N0YXRlcyk6bmV3IEFycmF5KGFuZ3VsYXIuaXNEZWZpbmVkKGIubWF4KT9hLiRwYXJlbnQuJGV2YWwoYi5tYXgpOmMubWF4KTthLnJhbmdlPXRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMoZyl9LHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aDtjPmI7YisrKWFbYl09YW5ndWxhci5leHRlbmQoe2luZGV4OmJ9LHtzdGF0ZU9uOnRoaXMuc3RhdGVPbixzdGF0ZU9mZjp0aGlzLnN0YXRlT2ZmLHRpdGxlOnRoaXMuZ2V0VGl0bGUoYil9LGFbYl0pO3JldHVybiBhfSx0aGlzLmdldFRpdGxlPWZ1bmN0aW9uKGEpe3JldHVybiBhPj10aGlzLnRpdGxlcy5sZW5ndGg/YSsxOnRoaXMudGl0bGVzW2FdfSxhLnJhdGU9ZnVuY3Rpb24oYil7IWEucmVhZG9ubHkmJmI+PTAmJmI8PWEucmFuZ2UubGVuZ3RoJiYoZC4kc2V0Vmlld1ZhbHVlKGQuJHZpZXdWYWx1ZT09PWI/MDpiKSxkLiRyZW5kZXIoKSl9LGEuZW50ZXI9ZnVuY3Rpb24oYil7YS5yZWFkb25seXx8KGEudmFsdWU9YiksYS5vbkhvdmVyKHt2YWx1ZTpifSl9LGEucmVzZXQ9ZnVuY3Rpb24oKXthLnZhbHVlPWQuJHZpZXdWYWx1ZSxhLm9uTGVhdmUoKX0sYS5vbktleWRvd249ZnVuY3Rpb24oYil7LygzN3wzOHwzOXw0MCkvLnRlc3QoYi53aGljaCkmJihiLnByZXZlbnREZWZhdWx0KCksYi5zdG9wUHJvcGFnYXRpb24oKSxhLnJhdGUoYS52YWx1ZSsoMzg9PT1iLndoaWNofHwzOT09PWIud2hpY2g/MTotMSkpKX0sdGhpcy5yZW5kZXI9ZnVuY3Rpb24oKXthLnZhbHVlPWQuJHZpZXdWYWx1ZX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJSYXRpbmdcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3JlcXVpcmU6W1xcXCJ1aWJSYXRpbmdcXFwiLFxcXCJuZ01vZGVsXFxcIl0sc2NvcGU6e3JlYWRvbmx5OlxcXCI9P1xcXCIsb25Ib3ZlcjpcXFwiJlxcXCIsb25MZWF2ZTpcXFwiJlxcXCJ9LGNvbnRyb2xsZXI6XFxcIlVpYlJhdGluZ0NvbnRyb2xsZXJcXFwiLHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXFxcIixyZXBsYWNlOiEwLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZFswXSxmPWRbMV07ZS5pbml0KGYpfX19KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnRhYnNcXFwiLFtdKS5jb250cm9sbGVyKFxcXCJVaWJUYWJzZXRDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIudGFicz1hLnRhYnM9W107Yi5zZWxlY3Q9ZnVuY3Rpb24oYSl7YW5ndWxhci5mb3JFYWNoKGMsZnVuY3Rpb24oYil7Yi5hY3RpdmUmJmIhPT1hJiYoYi5hY3RpdmU9ITEsYi5vbkRlc2VsZWN0KCksYS5zZWxlY3RDYWxsZWQ9ITEpfSksYS5hY3RpdmU9ITAsYS5zZWxlY3RDYWxsZWR8fChhLm9uU2VsZWN0KCksYS5zZWxlY3RDYWxsZWQ9ITApfSxiLmFkZFRhYj1mdW5jdGlvbihhKXtjLnB1c2goYSksMT09PWMubGVuZ3RoJiZhLmFjdGl2ZSE9PSExP2EuYWN0aXZlPSEwOmEuYWN0aXZlP2Iuc2VsZWN0KGEpOmEuYWN0aXZlPSExfSxiLnJlbW92ZVRhYj1mdW5jdGlvbihhKXt2YXIgZT1jLmluZGV4T2YoYSk7aWYoYS5hY3RpdmUmJmMubGVuZ3RoPjEmJiFkKXt2YXIgZj1lPT09Yy5sZW5ndGgtMT9lLTE6ZSsxO2Iuc2VsZWN0KGNbZl0pfWMuc3BsaWNlKGUsMSl9O3ZhciBkO2EuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtkPSEwfSl9XSkuZGlyZWN0aXZlKFxcXCJ1aWJUYWJzZXRcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue3RyYW5zY2x1ZGU6ITAscmVwbGFjZTohMCxzY29wZTp7dHlwZTpcXFwiQFxcXCJ9LGNvbnRyb2xsZXI6XFxcIlVpYlRhYnNldENvbnRyb2xsZXJcXFwiLHRlbXBsYXRlVXJsOlxcXCJ1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFxcXCIsbGluazpmdW5jdGlvbihhLGIsYyl7YS52ZXJ0aWNhbD1hbmd1bGFyLmlzRGVmaW5lZChjLnZlcnRpY2FsKT9hLiRwYXJlbnQuJGV2YWwoYy52ZXJ0aWNhbCk6ITEsYS5qdXN0aWZpZWQ9YW5ndWxhci5pc0RlZmluZWQoYy5qdXN0aWZpZWQpP2EuJHBhcmVudC4kZXZhbChjLmp1c3RpZmllZCk6ITF9fX0pLmRpcmVjdGl2ZShcXFwidWliVGFiXFxcIixbXFxcIiRwYXJzZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3JlcXVpcmU6XFxcIl51aWJUYWJzZXRcXFwiLHJlcGxhY2U6ITAsdGVtcGxhdGVVcmw6XFxcInVpYi90ZW1wbGF0ZS90YWJzL3RhYi5odG1sXFxcIix0cmFuc2NsdWRlOiEwLHNjb3BlOnthY3RpdmU6XFxcIj0/XFxcIixoZWFkaW5nOlxcXCJAXFxcIixvblNlbGVjdDpcXFwiJnNlbGVjdFxcXCIsb25EZXNlbGVjdDpcXFwiJmRlc2VsZWN0XFxcIn0sY29udHJvbGxlcjpmdW5jdGlvbigpe30sY29udHJvbGxlckFzOlxcXCJ0YWJcXFwiLGxpbms6ZnVuY3Rpb24oYixjLGQsZSxmKXtiLiR3YXRjaChcXFwiYWN0aXZlXFxcIixmdW5jdGlvbihhKXthJiZlLnNlbGVjdChiKX0pLGIuZGlzYWJsZWQ9ITEsZC5kaXNhYmxlJiZiLiRwYXJlbnQuJHdhdGNoKGEoZC5kaXNhYmxlKSxmdW5jdGlvbihhKXtiLmRpc2FibGVkPSEhYX0pLGIuc2VsZWN0PWZ1bmN0aW9uKCl7Yi5kaXNhYmxlZHx8KGIuYWN0aXZlPSEwKX0sZS5hZGRUYWIoYiksYi4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe2UucmVtb3ZlVGFiKGIpfSksYi4kdHJhbnNjbHVkZUZuPWZ9fX1dKS5kaXJlY3RpdmUoXFxcInVpYlRhYkhlYWRpbmdUcmFuc2NsdWRlXFxcIixmdW5jdGlvbigpe3JldHVybntyZXN0cmljdDpcXFwiQVxcXCIscmVxdWlyZTpcXFwiXnVpYlRhYlxcXCIsbGluazpmdW5jdGlvbihhLGIpe2EuJHdhdGNoKFxcXCJoZWFkaW5nRWxlbWVudFxcXCIsZnVuY3Rpb24oYSl7YSYmKGIuaHRtbChcXFwiXFxcIiksYi5hcHBlbmQoYSkpfSl9fX0pLmRpcmVjdGl2ZShcXFwidWliVGFiQ29udGVudFRyYW5zY2x1ZGVcXFwiLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtyZXR1cm4gYS50YWdOYW1lJiYoYS5oYXNBdHRyaWJ1dGUoXFxcInVpYi10YWItaGVhZGluZ1xcXCIpfHxhLmhhc0F0dHJpYnV0ZShcXFwiZGF0YS11aWItdGFiLWhlYWRpbmdcXFwiKXx8YS5oYXNBdHRyaWJ1dGUoXFxcIngtdWliLXRhYi1oZWFkaW5nXFxcIil8fFxcXCJ1aWItdGFiLWhlYWRpbmdcXFwiPT09YS50YWdOYW1lLnRvTG93ZXJDYXNlKCl8fFxcXCJkYXRhLXVpYi10YWItaGVhZGluZ1xcXCI9PT1hLnRhZ05hbWUudG9Mb3dlckNhc2UoKXx8XFxcIngtdWliLXRhYi1oZWFkaW5nXFxcIj09PWEudGFnTmFtZS50b0xvd2VyQ2FzZSgpKX1yZXR1cm57cmVzdHJpY3Q6XFxcIkFcXFwiLHJlcXVpcmU6XFxcIl51aWJUYWJzZXRcXFwiLGxpbms6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWIuJGV2YWwoZC51aWJUYWJDb250ZW50VHJhbnNjbHVkZSk7ZS4kdHJhbnNjbHVkZUZuKGUuJHBhcmVudCxmdW5jdGlvbihiKXthbmd1bGFyLmZvckVhY2goYixmdW5jdGlvbihiKXthKGIpP2UuaGVhZGluZ0VsZW1lbnQ9YjpjLmFwcGVuZChiKX0pfSl9fX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclxcXCIsW10pLmNvbnN0YW50KFxcXCJ1aWJUaW1lcGlja2VyQ29uZmlnXFxcIix7aG91clN0ZXA6MSxtaW51dGVTdGVwOjEsc2Vjb25kU3RlcDoxLHNob3dNZXJpZGlhbjohMCxzaG93U2Vjb25kczohMSxtZXJpZGlhbnM6bnVsbCxyZWFkb25seUlucHV0OiExLG1vdXNld2hlZWw6ITAsYXJyb3drZXlzOiEwLHNob3dTcGlubmVyczohMCx0ZW1wbGF0ZVVybDpcXFwidWliL3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXFxcIn0pLmNvbnRyb2xsZXIoXFxcIlVpYlRpbWVwaWNrZXJDb250cm9sbGVyXFxcIixbXFxcIiRzY29wZVxcXCIsXFxcIiRlbGVtZW50XFxcIixcXFwiJGF0dHJzXFxcIixcXFwiJHBhcnNlXFxcIixcXFwiJGxvZ1xcXCIsXFxcIiRsb2NhbGVcXFwiLFxcXCJ1aWJUaW1lcGlja2VyQ29uZmlnXFxcIixmdW5jdGlvbihhLGIsYyxkLGUsZixnKXtmdW5jdGlvbiBoKCl7dmFyIGI9K2EuaG91cnMsYz1hLnNob3dNZXJpZGlhbj9iPjAmJjEzPmI6Yj49MCYmMjQ+YjtyZXR1cm4gYz8oYS5zaG93TWVyaWRpYW4mJigxMj09PWImJihiPTApLGEubWVyaWRpYW49PT11WzFdJiYoYis9MTIpKSxiKTp2b2lkIDB9ZnVuY3Rpb24gaSgpe3ZhciBiPSthLm1pbnV0ZXM7cmV0dXJuIGI+PTAmJjYwPmI/Yjp2b2lkIDB9ZnVuY3Rpb24gaigpe3ZhciBiPSthLnNlY29uZHM7cmV0dXJuIGI+PTAmJjYwPmI/Yjp2b2lkIDB9ZnVuY3Rpb24gayhhKXtyZXR1cm4gbnVsbD09PWE/XFxcIlxcXCI6YW5ndWxhci5pc0RlZmluZWQoYSkmJmEudG9TdHJpbmcoKS5sZW5ndGg8Mj9cXFwiMFxcXCIrYTphLnRvU3RyaW5nKCl9ZnVuY3Rpb24gbChhKXttKCksdC4kc2V0Vmlld1ZhbHVlKG5ldyBEYXRlKHIpKSxuKGEpfWZ1bmN0aW9uIG0oKXt0LiRzZXRWYWxpZGl0eShcXFwidGltZVxcXCIsITApLGEuaW52YWxpZEhvdXJzPSExLGEuaW52YWxpZE1pbnV0ZXM9ITEsYS5pbnZhbGlkU2Vjb25kcz0hMX1mdW5jdGlvbiBuKGIpe2lmKHQuJG1vZGVsVmFsdWUpe3ZhciBjPXIuZ2V0SG91cnMoKSxkPXIuZ2V0TWludXRlcygpLGU9ci5nZXRTZWNvbmRzKCk7YS5zaG93TWVyaWRpYW4mJihjPTA9PT1jfHwxMj09PWM/MTI6YyUxMiksYS5ob3Vycz1cXFwiaFxcXCI9PT1iP2M6ayhjKSxcXFwibVxcXCIhPT1iJiYoYS5taW51dGVzPWsoZCkpLGEubWVyaWRpYW49ci5nZXRIb3VycygpPDEyP3VbMF06dVsxXSxcXFwic1xcXCIhPT1iJiYoYS5zZWNvbmRzPWsoZSkpLGEubWVyaWRpYW49ci5nZXRIb3VycygpPDEyP3VbMF06dVsxXX1lbHNlIGEuaG91cnM9bnVsbCxhLm1pbnV0ZXM9bnVsbCxhLnNlY29uZHM9bnVsbCxhLm1lcmlkaWFuPXVbMF19ZnVuY3Rpb24gbyhhKXtyPXEocixhKSxsKCl9ZnVuY3Rpb24gcChhLGIpe3JldHVybiBxKGEsNjAqYil9ZnVuY3Rpb24gcShhLGIpe3ZhciBjPW5ldyBEYXRlKGEuZ2V0VGltZSgpKzFlMypiKSxkPW5ldyBEYXRlKGEpO3JldHVybiBkLnNldEhvdXJzKGMuZ2V0SG91cnMoKSxjLmdldE1pbnV0ZXMoKSxjLmdldFNlY29uZHMoKSksZH12YXIgcj1uZXcgRGF0ZSxzPVtdLHQ9eyRzZXRWaWV3VmFsdWU6YW5ndWxhci5ub29wfSx1PWFuZ3VsYXIuaXNEZWZpbmVkKGMubWVyaWRpYW5zKT9hLiRwYXJlbnQuJGV2YWwoYy5tZXJpZGlhbnMpOmcubWVyaWRpYW5zfHxmLkRBVEVUSU1FX0ZPUk1BVFMuQU1QTVM7YS50YWJpbmRleD1hbmd1bGFyLmlzRGVmaW5lZChjLnRhYmluZGV4KT9jLnRhYmluZGV4OjAsYi5yZW1vdmVBdHRyKFxcXCJ0YWJpbmRleFxcXCIpLHRoaXMuaW5pdD1mdW5jdGlvbihiLGQpe3Q9Yix0LiRyZW5kZXI9dGhpcy5yZW5kZXIsdC4kZm9ybWF0dGVycy51bnNoaWZ0KGZ1bmN0aW9uKGEpe3JldHVybiBhP25ldyBEYXRlKGEpOm51bGx9KTt2YXIgZT1kLmVxKDApLGY9ZC5lcSgxKSxoPWQuZXEoMiksaT1hbmd1bGFyLmlzRGVmaW5lZChjLm1vdXNld2hlZWwpP2EuJHBhcmVudC4kZXZhbChjLm1vdXNld2hlZWwpOmcubW91c2V3aGVlbDtpJiZ0aGlzLnNldHVwTW91c2V3aGVlbEV2ZW50cyhlLGYsaCk7dmFyIGo9YW5ndWxhci5pc0RlZmluZWQoYy5hcnJvd2tleXMpP2EuJHBhcmVudC4kZXZhbChjLmFycm93a2V5cyk6Zy5hcnJvd2tleXM7aiYmdGhpcy5zZXR1cEFycm93a2V5RXZlbnRzKGUsZixoKSxhLnJlYWRvbmx5SW5wdXQ9YW5ndWxhci5pc0RlZmluZWQoYy5yZWFkb25seUlucHV0KT9hLiRwYXJlbnQuJGV2YWwoYy5yZWFkb25seUlucHV0KTpnLnJlYWRvbmx5SW5wdXQsdGhpcy5zZXR1cElucHV0RXZlbnRzKGUsZixoKX07dmFyIHY9Zy5ob3VyU3RlcDtjLmhvdXJTdGVwJiZzLnB1c2goYS4kcGFyZW50LiR3YXRjaChkKGMuaG91clN0ZXApLGZ1bmN0aW9uKGEpe3Y9K2F9KSk7dmFyIHc9Zy5taW51dGVTdGVwO2MubWludXRlU3RlcCYmcy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZChjLm1pbnV0ZVN0ZXApLGZ1bmN0aW9uKGEpe3c9K2F9KSk7dmFyIHg7cy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZChjLm1pbiksZnVuY3Rpb24oYSl7dmFyIGI9bmV3IERhdGUoYSk7eD1pc05hTihiKT92b2lkIDA6Yn0pKTt2YXIgeTtzLnB1c2goYS4kcGFyZW50LiR3YXRjaChkKGMubWF4KSxmdW5jdGlvbihhKXt2YXIgYj1uZXcgRGF0ZShhKTt5PWlzTmFOKGIpP3ZvaWQgMDpifSkpO3ZhciB6PSExO2MubmdEaXNhYmxlZCYmcy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZChjLm5nRGlzYWJsZWQpLGZ1bmN0aW9uKGEpe3o9YX0pKSxhLm5vSW5jcmVtZW50SG91cnM9ZnVuY3Rpb24oKXt2YXIgYT1wKHIsNjAqdik7cmV0dXJuIHp8fGE+eXx8cj5hJiZ4PmF9LGEubm9EZWNyZW1lbnRIb3Vycz1mdW5jdGlvbigpe3ZhciBhPXAociw2MCotdik7cmV0dXJuIHp8fHg+YXx8YT5yJiZhPnl9LGEubm9JbmNyZW1lbnRNaW51dGVzPWZ1bmN0aW9uKCl7dmFyIGE9cChyLHcpO3JldHVybiB6fHxhPnl8fHI+YSYmeD5hfSxhLm5vRGVjcmVtZW50TWludXRlcz1mdW5jdGlvbigpe3ZhciBhPXAociwtdyk7cmV0dXJuIHp8fHg+YXx8YT5yJiZhPnl9LGEubm9JbmNyZW1lbnRTZWNvbmRzPWZ1bmN0aW9uKCl7dmFyIGE9cShyLEEpO3JldHVybiB6fHxhPnl8fHI+YSYmeD5hfSxhLm5vRGVjcmVtZW50U2Vjb25kcz1mdW5jdGlvbigpe3ZhciBhPXEociwtQSk7cmV0dXJuIHp8fHg+YXx8YT5yJiZhPnl9LGEubm9Ub2dnbGVNZXJpZGlhbj1mdW5jdGlvbigpe3JldHVybiByLmdldEhvdXJzKCk8MTI/enx8cChyLDcyMCk+eTp6fHxwKHIsLTcyMCk8eH07dmFyIEE9Zy5zZWNvbmRTdGVwO2Muc2Vjb25kU3RlcCYmcy5wdXNoKGEuJHBhcmVudC4kd2F0Y2goZChjLnNlY29uZFN0ZXApLGZ1bmN0aW9uKGEpe0E9K2F9KSksYS5zaG93U2Vjb25kcz1nLnNob3dTZWNvbmRzLGMuc2hvd1NlY29uZHMmJnMucHVzaChhLiRwYXJlbnQuJHdhdGNoKGQoYy5zaG93U2Vjb25kcyksZnVuY3Rpb24oYil7YS5zaG93U2Vjb25kcz0hIWJ9KSksYS5zaG93TWVyaWRpYW49Zy5zaG93TWVyaWRpYW4sYy5zaG93TWVyaWRpYW4mJnMucHVzaChhLiRwYXJlbnQuJHdhdGNoKGQoYy5zaG93TWVyaWRpYW4pLGZ1bmN0aW9uKGIpe2lmKGEuc2hvd01lcmlkaWFuPSEhYix0LiRlcnJvci50aW1lKXt2YXIgYz1oKCksZD1pKCk7YW5ndWxhci5pc0RlZmluZWQoYykmJmFuZ3VsYXIuaXNEZWZpbmVkKGQpJiYoci5zZXRIb3VycyhjKSxsKCkpfWVsc2UgbigpfSkpLHRoaXMuc2V0dXBNb3VzZXdoZWVsRXZlbnRzPWZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1mdW5jdGlvbihhKXthLm9yaWdpbmFsRXZlbnQmJihhPWEub3JpZ2luYWxFdmVudCk7dmFyIGI9YS53aGVlbERlbHRhP2Eud2hlZWxEZWx0YTotYS5kZWx0YVk7cmV0dXJuIGEuZGV0YWlsfHxiPjB9O2IuYmluZChcXFwibW91c2V3aGVlbCB3aGVlbFxcXCIsZnVuY3Rpb24oYil7enx8YS4kYXBwbHkoZShiKT9hLmluY3JlbWVudEhvdXJzKCk6YS5kZWNyZW1lbnRIb3VycygpKSxiLnByZXZlbnREZWZhdWx0KCl9KSxjLmJpbmQoXFxcIm1vdXNld2hlZWwgd2hlZWxcXFwiLGZ1bmN0aW9uKGIpe3p8fGEuJGFwcGx5KGUoYik/YS5pbmNyZW1lbnRNaW51dGVzKCk6YS5kZWNyZW1lbnRNaW51dGVzKCkpLGIucHJldmVudERlZmF1bHQoKX0pLGQuYmluZChcXFwibW91c2V3aGVlbCB3aGVlbFxcXCIsZnVuY3Rpb24oYil7enx8YS4kYXBwbHkoZShiKT9hLmluY3JlbWVudFNlY29uZHMoKTphLmRlY3JlbWVudFNlY29uZHMoKSksYi5wcmV2ZW50RGVmYXVsdCgpfSl9LHRoaXMuc2V0dXBBcnJvd2tleUV2ZW50cz1mdW5jdGlvbihiLGMsZCl7Yi5iaW5kKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXt6fHwoMzg9PT1iLndoaWNoPyhiLnByZXZlbnREZWZhdWx0KCksYS5pbmNyZW1lbnRIb3VycygpLGEuJGFwcGx5KCkpOjQwPT09Yi53aGljaCYmKGIucHJldmVudERlZmF1bHQoKSxhLmRlY3JlbWVudEhvdXJzKCksYS4kYXBwbHkoKSkpfSksYy5iaW5kKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXt6fHwoMzg9PT1iLndoaWNoPyhiLnByZXZlbnREZWZhdWx0KCksYS5pbmNyZW1lbnRNaW51dGVzKCksYS4kYXBwbHkoKSk6NDA9PT1iLndoaWNoJiYoYi5wcmV2ZW50RGVmYXVsdCgpLGEuZGVjcmVtZW50TWludXRlcygpLGEuJGFwcGx5KCkpKX0pLGQuYmluZChcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYil7enx8KDM4PT09Yi53aGljaD8oYi5wcmV2ZW50RGVmYXVsdCgpLGEuaW5jcmVtZW50U2Vjb25kcygpLGEuJGFwcGx5KCkpOjQwPT09Yi53aGljaCYmKGIucHJldmVudERlZmF1bHQoKSxhLmRlY3JlbWVudFNlY29uZHMoKSxhLiRhcHBseSgpKSl9KX0sdGhpcy5zZXR1cElucHV0RXZlbnRzPWZ1bmN0aW9uKGIsYyxkKXtpZihhLnJlYWRvbmx5SW5wdXQpcmV0dXJuIGEudXBkYXRlSG91cnM9YW5ndWxhci5ub29wLGEudXBkYXRlTWludXRlcz1hbmd1bGFyLm5vb3Asdm9pZChhLnVwZGF0ZVNlY29uZHM9YW5ndWxhci5ub29wKTt2YXIgZT1mdW5jdGlvbihiLGMsZCl7dC4kc2V0Vmlld1ZhbHVlKG51bGwpLHQuJHNldFZhbGlkaXR5KFxcXCJ0aW1lXFxcIiwhMSksYW5ndWxhci5pc0RlZmluZWQoYikmJihhLmludmFsaWRIb3Vycz1iKSxhbmd1bGFyLmlzRGVmaW5lZChjKSYmKGEuaW52YWxpZE1pbnV0ZXM9YyksYW5ndWxhci5pc0RlZmluZWQoZCkmJihhLmludmFsaWRTZWNvbmRzPWQpfTthLnVwZGF0ZUhvdXJzPWZ1bmN0aW9uKCl7dmFyIGE9aCgpLGI9aSgpO3QuJHNldERpcnR5KCksYW5ndWxhci5pc0RlZmluZWQoYSkmJmFuZ3VsYXIuaXNEZWZpbmVkKGIpPyhyLnNldEhvdXJzKGEpLHIuc2V0TWludXRlcyhiKSx4PnJ8fHI+eT9lKCEwKTpsKFxcXCJoXFxcIikpOmUoITApfSxiLmJpbmQoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGIpe3QuJHNldFRvdWNoZWQoKSxudWxsPT09YS5ob3Vyc3x8XFxcIlxcXCI9PT1hLmhvdXJzP2UoITApOiFhLmludmFsaWRIb3VycyYmYS5ob3VyczwxMCYmYS4kYXBwbHkoZnVuY3Rpb24oKXthLmhvdXJzPWsoYS5ob3Vycyl9KX0pLGEudXBkYXRlTWludXRlcz1mdW5jdGlvbigpe3ZhciBhPWkoKSxiPWgoKTt0LiRzZXREaXJ0eSgpLGFuZ3VsYXIuaXNEZWZpbmVkKGEpJiZhbmd1bGFyLmlzRGVmaW5lZChiKT8oci5zZXRIb3VycyhiKSxyLnNldE1pbnV0ZXMoYSkseD5yfHxyPnk/ZSh2b2lkIDAsITApOmwoXFxcIm1cXFwiKSk6ZSh2b2lkIDAsITApfSxjLmJpbmQoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGIpe3QuJHNldFRvdWNoZWQoKSxudWxsPT09YS5taW51dGVzP2Uodm9pZCAwLCEwKTohYS5pbnZhbGlkTWludXRlcyYmYS5taW51dGVzPDEwJiZhLiRhcHBseShmdW5jdGlvbigpe2EubWludXRlcz1rKGEubWludXRlcyl9KX0pLGEudXBkYXRlU2Vjb25kcz1mdW5jdGlvbigpe3ZhciBhPWooKTt0LiRzZXREaXJ0eSgpLGFuZ3VsYXIuaXNEZWZpbmVkKGEpPyhyLnNldFNlY29uZHMoYSksbChcXFwic1xcXCIpKTplKHZvaWQgMCx2b2lkIDAsITApfSxkLmJpbmQoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGIpeyFhLmludmFsaWRTZWNvbmRzJiZhLnNlY29uZHM8MTAmJmEuJGFwcGx5KGZ1bmN0aW9uKCl7YS5zZWNvbmRzPWsoYS5zZWNvbmRzKX0pfSl9LHRoaXMucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGI9dC4kdmlld1ZhbHVlO2lzTmFOKGIpPyh0LiRzZXRWYWxpZGl0eShcXFwidGltZVxcXCIsITEpLGUuZXJyb3IoJ1RpbWVwaWNrZXIgZGlyZWN0aXZlOiBcXFwibmctbW9kZWxcXFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDAxLjAxLjE5NzAgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIFJGQzI4MjIgb3IgSVNPIDg2MDEgZGF0ZS4nKSk6KGImJihyPWIpLHg+cnx8cj55Pyh0LiRzZXRWYWxpZGl0eShcXFwidGltZVxcXCIsITEpLGEuaW52YWxpZEhvdXJzPSEwLGEuaW52YWxpZE1pbnV0ZXM9ITApOm0oKSxuKCkpfSxhLnNob3dTcGlubmVycz1hbmd1bGFyLmlzRGVmaW5lZChjLnNob3dTcGlubmVycyk/YS4kcGFyZW50LiRldmFsKGMuc2hvd1NwaW5uZXJzKTpnLnNob3dTcGlubmVycyxhLmluY3JlbWVudEhvdXJzPWZ1bmN0aW9uKCl7YS5ub0luY3JlbWVudEhvdXJzKCl8fG8oNjAqdio2MCl9LGEuZGVjcmVtZW50SG91cnM9ZnVuY3Rpb24oKXthLm5vRGVjcmVtZW50SG91cnMoKXx8byg2MCotdio2MCl9LGEuaW5jcmVtZW50TWludXRlcz1mdW5jdGlvbigpe2Eubm9JbmNyZW1lbnRNaW51dGVzKCl8fG8oNjAqdyl9LGEuZGVjcmVtZW50TWludXRlcz1mdW5jdGlvbigpe2Eubm9EZWNyZW1lbnRNaW51dGVzKCl8fG8oNjAqLXcpfSxhLmluY3JlbWVudFNlY29uZHM9ZnVuY3Rpb24oKXthLm5vSW5jcmVtZW50U2Vjb25kcygpfHxvKEEpfSxhLmRlY3JlbWVudFNlY29uZHM9ZnVuY3Rpb24oKXthLm5vRGVjcmVtZW50U2Vjb25kcygpfHxvKC1BKX0sYS50b2dnbGVNZXJpZGlhbj1mdW5jdGlvbigpe3ZhciBiPWkoKSxjPWgoKTthLm5vVG9nZ2xlTWVyaWRpYW4oKXx8KGFuZ3VsYXIuaXNEZWZpbmVkKGIpJiZhbmd1bGFyLmlzRGVmaW5lZChjKT9vKDcyMCooci5nZXRIb3VycygpPDEyPzYwOi02MCkpOmEubWVyaWRpYW49YS5tZXJpZGlhbj09PXVbMF0/dVsxXTp1WzBdKX0sYS5ibHVyPWZ1bmN0aW9uKCl7dC4kc2V0VG91Y2hlZCgpfSxhLiRvbihcXFwiJGRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Zm9yKDtzLmxlbmd0aDspcy5zaGlmdCgpKCl9KX1dKS5kaXJlY3RpdmUoXFxcInVpYlRpbWVwaWNrZXJcXFwiLFtcXFwidWliVGltZXBpY2tlckNvbmZpZ1xcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3JlcXVpcmU6W1xcXCJ1aWJUaW1lcGlja2VyXFxcIixcXFwiP15uZ01vZGVsXFxcIl0sY29udHJvbGxlcjpcXFwiVWliVGltZXBpY2tlckNvbnRyb2xsZXJcXFwiLGNvbnRyb2xsZXJBczpcXFwidGltZXBpY2tlclxcXCIscmVwbGFjZTohMCxzY29wZTp7fSx0ZW1wbGF0ZVVybDpmdW5jdGlvbihiLGMpe3JldHVybiBjLnRlbXBsYXRlVXJsfHxhLnRlbXBsYXRlVXJsfSxsaW5rOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWRbMF0sZj1kWzFdO2YmJmUuaW5pdChmLGIuZmluZChcXFwiaW5wdXRcXFwiKSl9fX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFxcXCIsW1xcXCJ1aS5ib290c3RyYXAuZGVib3VuY2VcXFwiLFxcXCJ1aS5ib290c3RyYXAucG9zaXRpb25cXFwiXSkuZmFjdG9yeShcXFwidWliVHlwZWFoZWFkUGFyc2VyXFxcIixbXFxcIiRwYXJzZVxcXCIsZnVuY3Rpb24oYSl7dmFyIGI9L15cXFxccyooW1xcXFxzXFxcXFNdKz8pKD86XFxcXHMrYXNcXFxccysoW1xcXFxzXFxcXFNdKz8pKT9cXFxccytmb3JcXFxccysoPzooW1xcXFwkXFxcXHddW1xcXFwkXFxcXHdcXFxcZF0qKSlcXFxccytpblxcXFxzKyhbXFxcXHNcXFxcU10rPykkLztyZXR1cm57cGFyc2U6ZnVuY3Rpb24oYyl7dmFyIGQ9Yy5tYXRjaChiKTtpZighZCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHR5cGVhaGVhZCBzcGVjaWZpY2F0aW9uIGluIGZvcm0gb2YgXFxcIl9tb2RlbFZhbHVlXyAoYXMgX2xhYmVsXyk/IGZvciBfaXRlbV8gaW4gX2NvbGxlY3Rpb25fXFxcIiBidXQgZ290IFxcXCInK2MrJ1xcXCIuJyk7cmV0dXJue2l0ZW1OYW1lOmRbM10sc291cmNlOmEoZFs0XSksdmlld01hcHBlcjphKGRbMl18fGRbMV0pLG1vZGVsTWFwcGVyOmEoZFsxXSl9fX19XSkuY29udHJvbGxlcihcXFwiVWliVHlwZWFoZWFkQ29udHJvbGxlclxcXCIsW1xcXCIkc2NvcGVcXFwiLFxcXCIkZWxlbWVudFxcXCIsXFxcIiRhdHRyc1xcXCIsXFxcIiRjb21waWxlXFxcIixcXFwiJHBhcnNlXFxcIixcXFwiJHFcXFwiLFxcXCIkdGltZW91dFxcXCIsXFxcIiRkb2N1bWVudFxcXCIsXFxcIiR3aW5kb3dcXFwiLFxcXCIkcm9vdFNjb3BlXFxcIixcXFwiJCRkZWJvdW5jZVxcXCIsXFxcIiR1aWJQb3NpdGlvblxcXCIsXFxcInVpYlR5cGVhaGVhZFBhcnNlclxcXCIsZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSl7ZnVuY3Rpb24gbigpe04ubW92ZUluUHJvZ3Jlc3N8fChOLm1vdmVJblByb2dyZXNzPSEwLE4uJGRpZ2VzdCgpKSxZKCl9ZnVuY3Rpb24gbygpe04ucG9zaXRpb249RD9sLm9mZnNldChiKTpsLnBvc2l0aW9uKGIpLE4ucG9zaXRpb24udG9wKz1iLnByb3AoXFxcIm9mZnNldEhlaWdodFxcXCIpfXZhciBwLHEscj1bOSwxMywyNywzOCw0MF0scz0yMDAsdD1hLiRldmFsKGMudHlwZWFoZWFkTWluTGVuZ3RoKTt0fHwwPT09dHx8KHQ9MSk7dmFyIHU9YS4kZXZhbChjLnR5cGVhaGVhZFdhaXRNcyl8fDAsdj1hLiRldmFsKGMudHlwZWFoZWFkRWRpdGFibGUpIT09ITE7YS4kd2F0Y2goYy50eXBlYWhlYWRFZGl0YWJsZSxmdW5jdGlvbihhKXt2PWEhPT0hMX0pO3ZhciB3LHgseT1lKGMudHlwZWFoZWFkTG9hZGluZykuYXNzaWdufHxhbmd1bGFyLm5vb3Asej1lKGMudHlwZWFoZWFkT25TZWxlY3QpLEE9YW5ndWxhci5pc0RlZmluZWQoYy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpP2EuJGV2YWwoYy50eXBlYWhlYWRTZWxlY3RPbkJsdXIpOiExLEI9ZShjLnR5cGVhaGVhZE5vUmVzdWx0cykuYXNzaWdufHxhbmd1bGFyLm5vb3AsQz1jLnR5cGVhaGVhZElucHV0Rm9ybWF0dGVyP2UoYy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlcik6dm9pZCAwLEQ9Yy50eXBlYWhlYWRBcHBlbmRUb0JvZHk/YS4kZXZhbChjLnR5cGVhaGVhZEFwcGVuZFRvQm9keSk6ITEsRT1jLnR5cGVhaGVhZEFwcGVuZFRvP2EuJGV2YWwoYy50eXBlYWhlYWRBcHBlbmRUbyk6bnVsbCxGPWEuJGV2YWwoYy50eXBlYWhlYWRGb2N1c0ZpcnN0KSE9PSExLEc9Yy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0P2EuJGV2YWwoYy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0KTohMSxIPWUoYy50eXBlYWhlYWRJc09wZW4pLmFzc2lnbnx8YW5ndWxhci5ub29wLEk9YS4kZXZhbChjLnR5cGVhaGVhZFNob3dIaW50KXx8ITEsSj1lKGMubmdNb2RlbCksSz1lKGMubmdNb2RlbCtcXFwiKCQkJHApXFxcIiksTD1mdW5jdGlvbihiLGMpe3JldHVybiBhbmd1bGFyLmlzRnVuY3Rpb24oSihhKSkmJnEmJnEuJG9wdGlvbnMmJnEuJG9wdGlvbnMuZ2V0dGVyU2V0dGVyP0soYix7JCQkcDpjfSk6Si5hc3NpZ24oYixjKX0sTT1tLnBhcnNlKGMudWliVHlwZWFoZWFkKSxOPWEuJG5ldygpLE89YS4kb24oXFxcIiRkZXN0cm95XFxcIixmdW5jdGlvbigpe04uJGRlc3Ryb3koKX0pO04uJG9uKFxcXCIkZGVzdHJveVxcXCIsTyk7dmFyIFA9XFxcInR5cGVhaGVhZC1cXFwiK04uJGlkK1xcXCItXFxcIitNYXRoLmZsb29yKDFlNCpNYXRoLnJhbmRvbSgpKTtiLmF0dHIoe1xcXCJhcmlhLWF1dG9jb21wbGV0ZVxcXCI6XFxcImxpc3RcXFwiLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1vd25zXFxcIjpQfSk7dmFyIFEsUjtJJiYoUT1hbmd1bGFyLmVsZW1lbnQoXFxcIjxkaXY+PC9kaXY+XFxcIiksUS5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwicmVsYXRpdmVcXFwiKSxiLmFmdGVyKFEpLFI9Yi5jbG9uZSgpLFIuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiLFxcXCJcXFwiKSxSLnZhbChcXFwiXFxcIiksUi5jc3Moe3Bvc2l0aW9uOlxcXCJhYnNvbHV0ZVxcXCIsdG9wOlxcXCIwcHhcXFwiLGxlZnQ6XFxcIjBweFxcXCIsXFxcImJvcmRlci1jb2xvclxcXCI6XFxcInRyYW5zcGFyZW50XFxcIixcXFwiYm94LXNoYWRvd1xcXCI6XFxcIm5vbmVcXFwiLG9wYWNpdHk6MSxiYWNrZ3JvdW5kOlxcXCJub25lIDAlIDAlIC8gYXV0byByZXBlYXQgc2Nyb2xsIHBhZGRpbmctYm94IGJvcmRlci1ib3ggcmdiKDI1NSwgMjU1LCAyNTUpXFxcIixjb2xvcjpcXFwiIzk5OVxcXCJ9KSxiLmNzcyh7cG9zaXRpb246XFxcInJlbGF0aXZlXFxcIixcXFwidmVydGljYWwtYWxpZ25cXFwiOlxcXCJ0b3BcXFwiLFxcXCJiYWNrZ3JvdW5kLWNvbG9yXFxcIjpcXFwidHJhbnNwYXJlbnRcXFwifSksUS5hcHBlbmQoUiksUi5hZnRlcihiKSk7dmFyIFM9YW5ndWxhci5lbGVtZW50KFxcXCI8ZGl2IHVpYi10eXBlYWhlYWQtcG9wdXA+PC9kaXY+XFxcIik7Uy5hdHRyKHtpZDpQLG1hdGNoZXM6XFxcIm1hdGNoZXNcXFwiLGFjdGl2ZTpcXFwiYWN0aXZlSWR4XFxcIixzZWxlY3Q6XFxcInNlbGVjdChhY3RpdmVJZHgsIGV2dClcXFwiLFxcXCJtb3ZlLWluLXByb2dyZXNzXFxcIjpcXFwibW92ZUluUHJvZ3Jlc3NcXFwiLHF1ZXJ5OlxcXCJxdWVyeVxcXCIscG9zaXRpb246XFxcInBvc2l0aW9uXFxcIixcXFwiYXNzaWduLWlzLW9wZW5cXFwiOlxcXCJhc3NpZ25Jc09wZW4oaXNPcGVuKVxcXCIsZGVib3VuY2U6XFxcImRlYm91bmNlVXBkYXRlXFxcIn0pLGFuZ3VsYXIuaXNEZWZpbmVkKGMudHlwZWFoZWFkVGVtcGxhdGVVcmwpJiZTLmF0dHIoXFxcInRlbXBsYXRlLXVybFxcXCIsYy50eXBlYWhlYWRUZW1wbGF0ZVVybCksYW5ndWxhci5pc0RlZmluZWQoYy50eXBlYWhlYWRQb3B1cFRlbXBsYXRlVXJsKSYmUy5hdHRyKFxcXCJwb3B1cC10ZW1wbGF0ZS11cmxcXFwiLGMudHlwZWFoZWFkUG9wdXBUZW1wbGF0ZVVybCk7dmFyIFQ9ZnVuY3Rpb24oKXtJJiZSLnZhbChcXFwiXFxcIil9LFU9ZnVuY3Rpb24oKXtOLm1hdGNoZXM9W10sTi5hY3RpdmVJZHg9LTEsYi5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSksVCgpfSxWPWZ1bmN0aW9uKGEpe3JldHVybiBQK1xcXCItb3B0aW9uLVxcXCIrYX07Ti4kd2F0Y2goXFxcImFjdGl2ZUlkeFxcXCIsZnVuY3Rpb24oYSl7MD5hP2IucmVtb3ZlQXR0cihcXFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XFxcIik6Yi5hdHRyKFxcXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcXFwiLFYoYSkpfSk7dmFyIFc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gTi5tYXRjaGVzLmxlbmd0aD5iJiZhP2EudG9VcHBlckNhc2UoKT09PU4ubWF0Y2hlc1tiXS5sYWJlbC50b1VwcGVyQ2FzZSgpOiExfSxYPWZ1bmN0aW9uKGMsZCl7dmFyIGU9eyR2aWV3VmFsdWU6Y307eShhLCEwKSxCKGEsITEpLGYud2hlbihNLnNvdXJjZShhLGUpKS50aGVuKGZ1bmN0aW9uKGYpe3ZhciBnPWM9PT1wLiR2aWV3VmFsdWU7aWYoZyYmdylpZihmJiZmLmxlbmd0aD4wKXtOLmFjdGl2ZUlkeD1GPzA6LTEsQihhLCExKSxOLm1hdGNoZXMubGVuZ3RoPTA7Zm9yKHZhciBoPTA7aDxmLmxlbmd0aDtoKyspZVtNLml0ZW1OYW1lXT1mW2hdLE4ubWF0Y2hlcy5wdXNoKHtpZDpWKGgpLGxhYmVsOk0udmlld01hcHBlcihOLGUpLG1vZGVsOmZbaF19KTtpZihOLnF1ZXJ5PWMsbygpLGIuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITApLEcmJjE9PT1OLm1hdGNoZXMubGVuZ3RoJiZXKGMsMCkmJihhbmd1bGFyLmlzTnVtYmVyKE4uZGVib3VuY2VVcGRhdGUpfHxhbmd1bGFyLmlzT2JqZWN0KE4uZGVib3VuY2VVcGRhdGUpP2soZnVuY3Rpb24oKXtOLnNlbGVjdCgwLGQpfSxhbmd1bGFyLmlzTnVtYmVyKE4uZGVib3VuY2VVcGRhdGUpP04uZGVib3VuY2VVcGRhdGU6Ti5kZWJvdW5jZVVwZGF0ZVtcXFwiZGVmYXVsdFxcXCJdKTpOLnNlbGVjdCgwLGQpKSxJKXt2YXIgaT1OLm1hdGNoZXNbMF0ubGFiZWw7Yy5sZW5ndGg+MCYmaS5zbGljZSgwLGMubGVuZ3RoKS50b1VwcGVyQ2FzZSgpPT09Yy50b1VwcGVyQ2FzZSgpP1IudmFsKGMraS5zbGljZShjLmxlbmd0aCkpOlIudmFsKFxcXCJcXFwiKX19ZWxzZSBVKCksQihhLCEwKTtnJiZ5KGEsITEpfSxmdW5jdGlvbigpe1UoKSx5KGEsITEpLEIoYSwhMCl9KX07RCYmKGFuZ3VsYXIuZWxlbWVudChpKS5vbihcXFwicmVzaXplXFxcIixuKSxoLmZpbmQoXFxcImJvZHlcXFwiKS5vbihcXFwic2Nyb2xsXFxcIixuKSk7dmFyIFk9ayhmdW5jdGlvbigpe04ubWF0Y2hlcy5sZW5ndGgmJm8oKSxOLm1vdmVJblByb2dyZXNzPSExfSxzKTtOLm1vdmVJblByb2dyZXNzPSExLE4ucXVlcnk9dm9pZCAwO3ZhciBaLCQ9ZnVuY3Rpb24oYSl7Wj1nKGZ1bmN0aW9uKCl7WChhKX0sdSl9LF89ZnVuY3Rpb24oKXtaJiZnLmNhbmNlbChaKX07VSgpLE4uYXNzaWduSXNPcGVuPWZ1bmN0aW9uKGIpe0goYSxiKX0sTi5zZWxlY3Q9ZnVuY3Rpb24oZCxlKXt2YXIgZixoLGk9e307eD0hMCxpW00uaXRlbU5hbWVdPWg9Ti5tYXRjaGVzW2RdLm1vZGVsLGY9TS5tb2RlbE1hcHBlcihhLGkpLEwoYSxmKSxwLiRzZXRWYWxpZGl0eShcXFwiZWRpdGFibGVcXFwiLCEwKSxwLiRzZXRWYWxpZGl0eShcXFwicGFyc2VcXFwiLCEwKSx6KGEseyRpdGVtOmgsJG1vZGVsOmYsJGxhYmVsOk0udmlld01hcHBlcihhLGkpLCRldmVudDplfSksVSgpLE4uJGV2YWwoYy50eXBlYWhlYWRGb2N1c09uU2VsZWN0KSE9PSExJiZnKGZ1bmN0aW9uKCl7YlswXS5mb2N1cygpfSwwLCExKX0sYi5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYSl7aWYoMCE9PU4ubWF0Y2hlcy5sZW5ndGgmJi0xIT09ci5pbmRleE9mKGEud2hpY2gpKXtpZigtMT09PU4uYWN0aXZlSWR4JiYoOT09PWEud2hpY2h8fDEzPT09YS53aGljaCkpcmV0dXJuIFUoKSx2b2lkIE4uJGRpZ2VzdCgpO2EucHJldmVudERlZmF1bHQoKTt2YXIgYjtzd2l0Y2goYS53aGljaCl7Y2FzZSA5OmNhc2UgMTM6Ti4kYXBwbHkoZnVuY3Rpb24oKXthbmd1bGFyLmlzTnVtYmVyKE4uZGVib3VuY2VVcGRhdGUpfHxhbmd1bGFyLmlzT2JqZWN0KE4uZGVib3VuY2VVcGRhdGUpP2soZnVuY3Rpb24oKXtOLnNlbGVjdChOLmFjdGl2ZUlkeCxhKX0sYW5ndWxhci5pc051bWJlcihOLmRlYm91bmNlVXBkYXRlKT9OLmRlYm91bmNlVXBkYXRlOk4uZGVib3VuY2VVcGRhdGVbXFxcImRlZmF1bHRcXFwiXSk6Ti5zZWxlY3QoTi5hY3RpdmVJZHgsYSl9KTticmVhaztjYXNlIDI3OmEuc3RvcFByb3BhZ2F0aW9uKCksVSgpLE4uJGRpZ2VzdCgpO2JyZWFrO2Nhc2UgMzg6Ti5hY3RpdmVJZHg9KE4uYWN0aXZlSWR4PjA/Ti5hY3RpdmVJZHg6Ti5tYXRjaGVzLmxlbmd0aCktMSxOLiRkaWdlc3QoKSxiPVMuZmluZChcXFwibGlcXFwiKVtOLmFjdGl2ZUlkeF0sYi5wYXJlbnROb2RlLnNjcm9sbFRvcD1iLm9mZnNldFRvcDticmVhaztjYXNlIDQwOk4uYWN0aXZlSWR4PShOLmFjdGl2ZUlkeCsxKSVOLm1hdGNoZXMubGVuZ3RoLE4uJGRpZ2VzdCgpLGI9Uy5maW5kKFxcXCJsaVxcXCIpW04uYWN0aXZlSWR4XSxiLnBhcmVudE5vZGUuc2Nyb2xsVG9wPWIub2Zmc2V0VG9wfX19KSxiLmJpbmQoXFxcImZvY3VzXFxcIixmdW5jdGlvbihhKXt3PSEwLDAhPT10fHxwLiR2aWV3VmFsdWV8fGcoZnVuY3Rpb24oKXtYKHAuJHZpZXdWYWx1ZSxhKX0sMCl9KSxiLmJpbmQoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGEpe0EmJk4ubWF0Y2hlcy5sZW5ndGgmJi0xIT09Ti5hY3RpdmVJZHgmJiF4JiYoeD0hMCxOLiRhcHBseShmdW5jdGlvbigpe2FuZ3VsYXIuaXNPYmplY3QoTi5kZWJvdW5jZVVwZGF0ZSkmJmFuZ3VsYXIuaXNOdW1iZXIoTi5kZWJvdW5jZVVwZGF0ZS5ibHVyKT9rKGZ1bmN0aW9uKCl7Ti5zZWxlY3QoTi5hY3RpdmVJZHgsYSl9LE4uZGVib3VuY2VVcGRhdGUuYmx1cik6Ti5zZWxlY3QoTi5hY3RpdmVJZHgsYSl9KSksIXYmJnAuJGVycm9yLmVkaXRhYmxlJiYocC4kdmlld1ZhbHVlPVxcXCJcXFwiLGIudmFsKFxcXCJcXFwiKSksdz0hMSx4PSExfSk7dmFyIGFhPWZ1bmN0aW9uKGEpe2JbMF0hPT1hLnRhcmdldCYmMyE9PWEud2hpY2gmJjAhPT1OLm1hdGNoZXMubGVuZ3RoJiYoVSgpLGouJCRwaGFzZXx8Ti4kZGlnZXN0KCkpfTtoLm9uKFxcXCJjbGlja1xcXCIsYWEpLGEuJG9uKFxcXCIkZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtoLm9mZihcXFwiY2xpY2tcXFwiLGFhKSwoRHx8RSkmJmJhLnJlbW92ZSgpLEQmJihhbmd1bGFyLmVsZW1lbnQoaSkub2ZmKFxcXCJyZXNpemVcXFwiLG4pLGguZmluZChcXFwiYm9keVxcXCIpLm9mZihcXFwic2Nyb2xsXFxcIixuKSksUy5yZW1vdmUoKSxJJiZRLnJlbW92ZSgpfSk7dmFyIGJhPWQoUykoTik7RD9oLmZpbmQoXFxcImJvZHlcXFwiKS5hcHBlbmQoYmEpOkU/YW5ndWxhci5lbGVtZW50KEUpLmVxKDApLmFwcGVuZChiYSk6Yi5hZnRlcihiYSksdGhpcy5pbml0PWZ1bmN0aW9uKGIsYyl7cD1iLHE9YyxOLmRlYm91bmNlVXBkYXRlPXAuJG9wdGlvbnMmJmUocC4kb3B0aW9ucy5kZWJvdW5jZSkoYSkscC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uKGIpe3JldHVybiB3PSEwLDA9PT10fHxiJiZiLmxlbmd0aD49dD91PjA/KF8oKSwkKGIpKTpYKGIpOih5KGEsITEpLF8oKSxVKCkpLHY/YjpiP3ZvaWQgcC4kc2V0VmFsaWRpdHkoXFxcImVkaXRhYmxlXFxcIiwhMSk6KHAuJHNldFZhbGlkaXR5KFxcXCJlZGl0YWJsZVxcXCIsITApLG51bGwpfSkscC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKGIpe3ZhciBjLGQsZT17fTtyZXR1cm4gdnx8cC4kc2V0VmFsaWRpdHkoXFxcImVkaXRhYmxlXFxcIiwhMCksQz8oZS4kbW9kZWw9YixDKGEsZSkpOihlW00uaXRlbU5hbWVdPWIsYz1NLnZpZXdNYXBwZXIoYSxlKSxlW00uaXRlbU5hbWVdPXZvaWQgMCxkPU0udmlld01hcHBlcihhLGUpLGMhPT1kP2M6Yil9KX19XSkuZGlyZWN0aXZlKFxcXCJ1aWJUeXBlYWhlYWRcXFwiLGZ1bmN0aW9uKCl7cmV0dXJue2NvbnRyb2xsZXI6XFxcIlVpYlR5cGVhaGVhZENvbnRyb2xsZXJcXFwiLHJlcXVpcmU6W1xcXCJuZ01vZGVsXFxcIixcXFwiXj9uZ01vZGVsT3B0aW9uc1xcXCIsXFxcInVpYlR5cGVhaGVhZFxcXCJdLGxpbms6ZnVuY3Rpb24oYSxiLGMsZCl7ZFsyXS5pbml0KGRbMF0sZFsxXSl9fX0pLmRpcmVjdGl2ZShcXFwidWliVHlwZWFoZWFkUG9wdXBcXFwiLFtcXFwiJCRkZWJvdW5jZVxcXCIsZnVuY3Rpb24oYSl7cmV0dXJue3Njb3BlOnttYXRjaGVzOlxcXCI9XFxcIixxdWVyeTpcXFwiPVxcXCIsYWN0aXZlOlxcXCI9XFxcIixwb3NpdGlvbjpcXFwiJlxcXCIsbW92ZUluUHJvZ3Jlc3M6XFxcIj1cXFwiLHNlbGVjdDpcXFwiJlxcXCIsYXNzaWduSXNPcGVuOlxcXCImXFxcIixkZWJvdW5jZTpcXFwiJlxcXCJ9LHJlcGxhY2U6ITAsdGVtcGxhdGVVcmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi5wb3B1cFRlbXBsYXRlVXJsfHxcXFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFxcXCJ9LGxpbms6ZnVuY3Rpb24oYixjLGQpe2IudGVtcGxhdGVVcmw9ZC50ZW1wbGF0ZVVybCxiLmlzT3Blbj1mdW5jdGlvbigpe3ZhciBhPWIubWF0Y2hlcy5sZW5ndGg+MDtyZXR1cm4gYi5hc3NpZ25Jc09wZW4oe2lzT3BlbjphfSksYX0sYi5pc0FjdGl2ZT1mdW5jdGlvbihhKXtyZXR1cm4gYi5hY3RpdmU9PT1hfSxiLnNlbGVjdEFjdGl2ZT1mdW5jdGlvbihhKXtiLmFjdGl2ZT1hfSxiLnNlbGVjdE1hdGNoPWZ1bmN0aW9uKGMsZCl7dmFyIGU9Yi5kZWJvdW5jZSgpO2FuZ3VsYXIuaXNOdW1iZXIoZSl8fGFuZ3VsYXIuaXNPYmplY3QoZSk/YShmdW5jdGlvbigpe2Iuc2VsZWN0KHthY3RpdmVJZHg6YyxldnQ6ZH0pfSxhbmd1bGFyLmlzTnVtYmVyKGUpP2U6ZVtcXFwiZGVmYXVsdFxcXCJdKTpiLnNlbGVjdCh7YWN0aXZlSWR4OmMsZXZ0OmR9KX19fX1dKS5kaXJlY3RpdmUoXFxcInVpYlR5cGVhaGVhZE1hdGNoXFxcIixbXFxcIiR0ZW1wbGF0ZVJlcXVlc3RcXFwiLFxcXCIkY29tcGlsZVxcXCIsXFxcIiRwYXJzZVxcXCIsZnVuY3Rpb24oYSxiLGMpe3JldHVybntzY29wZTp7aW5kZXg6XFxcIj1cXFwiLG1hdGNoOlxcXCI9XFxcIixxdWVyeTpcXFwiPVxcXCJ9LGxpbms6ZnVuY3Rpb24oZCxlLGYpe3ZhciBnPWMoZi50ZW1wbGF0ZVVybCkoZC4kcGFyZW50KXx8XFxcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcXFwiO2EoZykudGhlbihmdW5jdGlvbihhKXt2YXIgYz1hbmd1bGFyLmVsZW1lbnQoYS50cmltKCkpO2UucmVwbGFjZVdpdGgoYyksYihjKShkKX0pfX19XSkuZmlsdGVyKFxcXCJ1aWJUeXBlYWhlYWRIaWdobGlnaHRcXFwiLFtcXFwiJHNjZVxcXCIsXFxcIiRpbmplY3RvclxcXCIsXFxcIiRsb2dcXFwiLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3JldHVybiBhLnJlcGxhY2UoLyhbLj8qK14kW1xcXFxdXFxcXFxcXFwoKXt9fC1dKS9nLFxcXCJcXFxcXFxcXCQxXFxcIil9ZnVuY3Rpb24gZShhKXtyZXR1cm4vPC4qPi9nLnRlc3QoYSl9dmFyIGY7cmV0dXJuIGY9Yi5oYXMoXFxcIiRzYW5pdGl6ZVxcXCIpLGZ1bmN0aW9uKGIsZyl7cmV0dXJuIWYmJmUoYikmJmMud2FybihcXFwiVW5zYWZlIHVzZSBvZiB0eXBlYWhlYWQgcGxlYXNlIHVzZSBuZ1Nhbml0aXplXFxcIiksYj1nPyhcXFwiXFxcIitiKS5yZXBsYWNlKG5ldyBSZWdFeHAoZChnKSxcXFwiZ2lcXFwiKSxcXFwiPHN0cm9uZz4kJjwvc3Ryb25nPlxcXCIpOmIsZnx8KGI9YS50cnVzdEFzSHRtbChiKSksYn19XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJwYW5lbFxcXCIgbmctY2xhc3M9XFxcInBhbmVsQ2xhc3MgfHwgXFxcXCdwYW5lbC1kZWZhdWx0XFxcXCdcXFwiPlxcXFxuICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIiBuZy1rZXlwcmVzcz1cXFwidG9nZ2xlT3BlbigkZXZlbnQpXFxcIj5cXFxcbiAgICA8aDQgY2xhc3M9XFxcInBhbmVsLXRpdGxlXFxcIj5cXFxcbiAgICAgIDxhIGhyZWYgdGFiaW5kZXg9XFxcIjBcXFwiIGNsYXNzPVxcXCJhY2NvcmRpb24tdG9nZ2xlXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlT3BlbigpXFxcIiB1aWItYWNjb3JkaW9uLXRyYW5zY2x1ZGU9XFxcImhlYWRpbmdcXFwiPjxzcGFuIG5nLWNsYXNzPVxcXCJ7XFxcXCd0ZXh0LW11dGVkXFxcXCc6IGlzRGlzYWJsZWR9XFxcIj57e2hlYWRpbmd9fTwvc3Bhbj48L2E+XFxcXG4gICAgPC9oND5cXFxcbiAgPC9kaXY+XFxcXG4gIDxkaXYgY2xhc3M9XFxcInBhbmVsLWNvbGxhcHNlIGNvbGxhcHNlXFxcIiB1aWItY29sbGFwc2U9XFxcIiFpc09wZW5cXFwiPlxcXFxuXFx0ICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcXFxuICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ncm91cFxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXFxcIiwnPGRpdiBjbGFzcz1cXFwiYWxlcnRcXFwiIG5nLWNsYXNzPVxcXCJbXFxcXCdhbGVydC1cXFxcJyArICh0eXBlIHx8IFxcXFwnd2FybmluZ1xcXFwnKSwgY2xvc2VhYmxlID8gXFxcXCdhbGVydC1kaXNtaXNzaWJsZVxcXFwnIDogbnVsbF1cXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj5cXFxcbiAgICA8YnV0dG9uIG5nLXNob3c9XFxcImNsb3NlYWJsZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSh7JGV2ZW50OiAkZXZlbnR9KVxcXCI+XFxcXG4gICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9zcGFuPlxcXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+XFxcXG4gICAgPC9idXR0b24+XFxcXG4gICAgPGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcXFxuPC9kaXY+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXFxcIiwnPGRpdiBuZy1tb3VzZWVudGVyPVxcXCJwYXVzZSgpXFxcIiBuZy1tb3VzZWxlYXZlPVxcXCJwbGF5KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbFxcXCIgbmctc3dpcGUtcmlnaHQ9XFxcInByZXYoKVxcXCIgbmctc3dpcGUtbGVmdD1cXFwibmV4dCgpXFxcIj5cXFxcbiAgPGRpdiBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5uZXJcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxcXG4gIDxhIHJvbGU9XFxcImJ1dHRvblxcXCIgaHJlZiBjbGFzcz1cXFwibGVmdCBjYXJvdXNlbC1jb250cm9sXFxcIiBuZy1jbGljaz1cXFwicHJldigpXFxcIiBuZy1zaG93PVxcXCJzbGlkZXMubGVuZ3RoID4gMVxcXCI+XFxcXG4gICAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9zcGFuPlxcXFxuICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5wcmV2aW91czwvc3Bhbj5cXFxcbiAgPC9hPlxcXFxuICA8YSByb2xlPVxcXCJidXR0b25cXFwiIGhyZWYgY2xhc3M9XFxcInJpZ2h0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXFxcbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9zcGFuPlxcXFxuICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5uZXh0PC9zcGFuPlxcXFxuICA8L2E+XFxcXG4gIDxvbCBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5kaWNhdG9yc1xcXCIgbmctc2hvdz1cXFwic2xpZGVzLmxlbmd0aCA+IDFcXFwiPlxcXFxuICAgIDxsaSBuZy1yZXBlYXQ9XFxcInNsaWRlIGluIHNsaWRlcyB8IG9yZGVyQnk6aW5kZXhPZlNsaWRlIHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInsgYWN0aXZlOiBpc0FjdGl2ZShzbGlkZSkgfVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChzbGlkZSlcXFwiPlxcXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPnNsaWRlIHt7ICRpbmRleCArIDEgfX0gb2Yge3sgc2xpZGVzLmxlbmd0aCB9fTxzcGFuIG5nLWlmPVxcXCJpc0FjdGl2ZShzbGlkZSlcXFwiPiwgY3VycmVudGx5IGFjdGl2ZTwvc3Bhbj48L3NwYW4+XFxcXG4gICAgPC9saT5cXFxcbiAgPC9vbD5cXFxcbjwvZGl2PicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcXFwiLCc8ZGl2IG5nLWNsYXNzPVxcXCJ7XFxcXG4gICAgXFxcXCdhY3RpdmVcXFxcJzogYWN0aXZlXFxcXG4gIH1cXFwiIGNsYXNzPVxcXCJpdGVtIHRleHQtY2VudGVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXFxcIiwnPGRpdiBjbGFzcz1cXFwidWliLWRhdGVwaWNrZXJcXFwiIG5nLXN3aXRjaD1cXFwiZGF0ZXBpY2tlck1vZGVcXFwiIHJvbGU9XFxcImFwcGxpY2F0aW9uXFxcIiBuZy1rZXlkb3duPVxcXCJrZXlkb3duKCRldmVudClcXFwiPlxcXFxuICA8dWliLWRheXBpY2tlciBuZy1zd2l0Y2gtd2hlbj1cXFwiZGF5XFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+PC91aWItZGF5cGlja2VyPlxcXFxuICA8dWliLW1vbnRocGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJtb250aFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiPjwvdWliLW1vbnRocGlja2VyPlxcXFxuICA8dWliLXllYXJwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcInllYXJcXFwiIHRhYmluZGV4PVxcXCIwXFxcIj48L3VpYi15ZWFycGlja2VyPlxcXFxuPC9kaXY+Jyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXkuaHRtbFxcXCIsJzx0YWJsZSBjbGFzcz1cXFwidWliLWRheXBpY2tlclxcXCIgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXFxcbiAgPHRoZWFkPlxcXFxuICAgIDx0cj5cXFxcbiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXFxcbiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6NSArIHNob3dXZWVrc319XFxcIj48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHVpYi10aXRsZVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXFxcbiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodCB1aWItcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcXFxuICAgIDwvdHI+XFxcXG4gICAgPHRyPlxcXFxuICAgICAgPHRoIG5nLWlmPVxcXCJzaG93V2Vla3NcXFwiIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+PC90aD5cXFxcbiAgICAgIDx0aCBuZy1yZXBlYXQ9XFxcImxhYmVsIGluIDo6bGFiZWxzIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48c21hbGwgYXJpYS1sYWJlbD1cXFwie3s6OmxhYmVsLmZ1bGx9fVxcXCI+e3s6OmxhYmVsLmFiYnJ9fTwvc21hbGw+PC90aD5cXFxcbiAgICA8L3RyPlxcXFxuICA8L3RoZWFkPlxcXFxuICA8dGJvZHk+XFxcXG4gICAgPHRyIGNsYXNzPVxcXCJ1aWItd2Vla3NcXFwiIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXFxcbiAgICAgIDx0ZCBuZy1pZj1cXFwic2hvd1dlZWtzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXIgaDZcXFwiPjxlbT57eyB3ZWVrTnVtYmVyc1skaW5kZXhdIH19PC9lbT48L3RkPlxcXFxuICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiZHQgaW4gcm93XFxcIiBjbGFzcz1cXFwidWliLWRheSB0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiXFxcXG4gICAgICAgIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiXFxcXG4gICAgICAgIG5nLWNsYXNzPVxcXCI6OmR0LmN1c3RvbUNsYXNzXFxcIj5cXFxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtXFxcIlxcXFxuICAgICAgICAgIHVpYi1pcy1jbGFzcz1cXFwiXFxcXG4gICAgICAgICAgICBcXFxcJ2J0bi1pbmZvXFxcXCcgZm9yIHNlbGVjdGVkRHQsXFxcXG4gICAgICAgICAgICBcXFxcJ2FjdGl2ZVxcXFwnIGZvciBhY3RpdmVEdFxcXFxuICAgICAgICAgICAgb24gZHRcXFwiXFxcXG4gICAgICAgICAgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCJcXFxcbiAgICAgICAgICBuZy1kaXNhYmxlZD1cXFwiOjpkdC5kaXNhYmxlZFxcXCJcXFxcbiAgICAgICAgICB0YWJpbmRleD1cXFwiLTFcXFwiPjxzcGFuIG5nLWNsYXNzPVxcXCI6OntcXFxcJ3RleHQtbXV0ZWRcXFxcJzogZHQuc2Vjb25kYXJ5LCBcXFxcJ3RleHQtaW5mb1xcXFwnOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxcXG4gICAgICA8L3RkPlxcXFxuICAgIDwvdHI+XFxcXG4gIDwvdGJvZHk+XFxcXG48L3RhYmxlPlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcXFwiLCc8dGFibGUgY2xhc3M9XFxcInVpYi1tb250aHBpY2tlclxcXCIgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXFxcbiAgPHRoZWFkPlxcXFxuICAgIDx0cj5cXFxcbiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXFxcbiAgICAgIDx0aD48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHVpYi10aXRsZVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXFxcbiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodCB1aWItcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48L2J1dHRvbj48L3RoPlxcXFxuICAgIDwvdHI+XFxcXG4gIDwvdGhlYWQ+XFxcXG4gIDx0Ym9keT5cXFxcbiAgICA8dHIgY2xhc3M9XFxcInVpYi1tb250aHNcXFwiIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXFxcbiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvd1xcXCIgY2xhc3M9XFxcInVpYi1tb250aCB0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiXFxcXG4gICAgICAgIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiXFxcXG4gICAgICAgIG5nLWNsYXNzPVxcXCI6OmR0LmN1c3RvbUNsYXNzXFxcIj5cXFxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiXFxcXG4gICAgICAgICAgdWliLWlzLWNsYXNzPVxcXCJcXFxcbiAgICAgICAgICAgIFxcXFwnYnRuLWluZm9cXFxcJyBmb3Igc2VsZWN0ZWREdCxcXFxcbiAgICAgICAgICAgIFxcXFwnYWN0aXZlXFxcXCcgZm9yIGFjdGl2ZUR0XFxcXG4gICAgICAgICAgICBvbiBkdFxcXCJcXFxcbiAgICAgICAgICBuZy1jbGljaz1cXFwic2VsZWN0KGR0LmRhdGUpXFxcIlxcXFxuICAgICAgICAgIG5nLWRpc2FibGVkPVxcXCI6OmR0LmRpc2FibGVkXFxcIlxcXFxuICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6e1xcXFwndGV4dC1pbmZvXFxcXCc6IGR0LmN1cnJlbnR9XFxcIj57ezo6ZHQubGFiZWx9fTwvc3Bhbj48L2J1dHRvbj5cXFxcbiAgICAgIDwvdGQ+XFxcXG4gICAgPC90cj5cXFxcbiAgPC90Ym9keT5cXFxcbjwvdGFibGU+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFxcXCIsJzxkaXY+XFxcXG4gIDx1bCBjbGFzcz1cXFwidWliLWRhdGVwaWNrZXItcG9wdXAgZHJvcGRvd24tbWVudVxcXCIgZHJvcGRvd24tbmVzdGVkIG5nLWlmPVxcXCJpc09wZW5cXFwiIG5nLXN0eWxlPVxcXCJ7dG9wOiBwb3NpdGlvbi50b3ArXFxcXCdweFxcXFwnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0K1xcXFwncHhcXFxcJ31cXFwiIG5nLWtleWRvd249XFxcImtleWRvd24oJGV2ZW50KVxcXCIgbmctY2xpY2s9XFxcIiRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxcXCI+XFxcXG4gICAgPGxpIG5nLXRyYW5zY2x1ZGU+PC9saT5cXFxcbiAgICA8bGkgbmctaWY9XFxcInNob3dCdXR0b25CYXJcXFwiIGNsYXNzPVxcXCJ1aWItYnV0dG9uLWJhclxcXCI+XFxcXG4gICAgPHNwYW4gY2xhc3M9XFxcImJ0bi1ncm91cCBwdWxsLWxlZnRcXFwiPlxcXFxuICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1pbmZvIHVpYi1kYXRlcGlja2VyLWN1cnJlbnRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoXFxcXCd0b2RheVxcXFwnKVxcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWQoXFxcXCd0b2RheVxcXFwnKVxcXCI+e3sgZ2V0VGV4dChcXFxcJ2N1cnJlbnRcXFxcJykgfX08L2J1dHRvbj5cXFxcbiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tZGFuZ2VyIHVpYi1jbGVhclxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChudWxsKVxcXCI+e3sgZ2V0VGV4dChcXFxcJ2NsZWFyXFxcXCcpIH19PC9idXR0b24+XFxcXG4gICAgPC9zcGFuPlxcXFxuICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIHB1bGwtcmlnaHQgdWliLWNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoKVxcXCI+e3sgZ2V0VGV4dChcXFxcJ2Nsb3NlXFxcXCcpIH19PC9idXR0b24+XFxcXG4gICAgPC9saT5cXFxcbiAgPC91bD5cXFxcbjwvZGl2PlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXFxcIiwnPHRhYmxlIGNsYXNzPVxcXCJ1aWIteWVhcnBpY2tlclxcXCIgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXFxcbiAgPHRoZWFkPlxcXFxuICAgIDx0cj5cXFxcbiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXFxcbiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6Y29sdW1ucyAtIDJ9fVxcXCI+PGJ1dHRvbiBpZD1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIHJvbGU9XFxcImhlYWRpbmdcXFwiIGFyaWEtbGl2ZT1cXFwiYXNzZXJ0aXZlXFxcIiBhcmlhLWF0b21pYz1cXFwidHJ1ZVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbSB1aWItdGl0bGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJkYXRlcGlja2VyTW9kZSA9PT0gbWF4TW9kZVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxcXG4gICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtcmlnaHQgdWliLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXFxcbiAgICA8L3RyPlxcXFxuICA8L3RoZWFkPlxcXFxuICA8dGJvZHk+XFxcXG4gICAgPHRyIGNsYXNzPVxcXCJ1aWIteWVhcnNcXFwiIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIj5cXFxcbiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvd1xcXCIgY2xhc3M9XFxcInVpYi15ZWFyIHRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCJcXFxcbiAgICAgICAgaWQ9XFxcInt7OjpkdC51aWR9fVxcXCJcXFxcbiAgICAgICAgbmctY2xhc3M9XFxcIjo6ZHQuY3VzdG9tQ2xhc3NcXFwiPlxcXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCJcXFxcbiAgICAgICAgICB1aWItaXMtY2xhc3M9XFxcIlxcXFxuICAgICAgICAgICAgXFxcXCdidG4taW5mb1xcXFwnIGZvciBzZWxlY3RlZER0LFxcXFxuICAgICAgICAgICAgXFxcXCdhY3RpdmVcXFxcJyBmb3IgYWN0aXZlRHRcXFxcbiAgICAgICAgICAgIG9uIGR0XFxcIlxcXFxuICAgICAgICAgIG5nLWNsaWNrPVxcXCJzZWxlY3QoZHQuZGF0ZSlcXFwiXFxcXG4gICAgICAgICAgbmctZGlzYWJsZWQ9XFxcIjo6ZHQuZGlzYWJsZWRcXFwiXFxcXG4gICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwiOjp7XFxcXCd0ZXh0LWluZm9cXFxcJzogZHQuY3VycmVudH1cXFwiPnt7OjpkdC5sYWJlbH19PC9zcGFuPjwvYnV0dG9uPlxcXFxuICAgICAgPC90ZD5cXFxcbiAgICA8L3RyPlxcXFxuICA8L3Rib2R5PlxcXFxuPC90YWJsZT5cXFxcbicpO1xcbn1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXFxcIiwnPGRpdiBjbGFzcz1cXFwibW9kYWwtYmFja2Ryb3BcXFwiXFxcXG4gICAgIHVpYi1tb2RhbC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxcXG4gICAgIG1vZGFsLWluLWNsYXNzPVxcXCJpblxcXCJcXFxcbiAgICAgbmctc3R5bGU9XFxcIntcXFxcJ3otaW5kZXhcXFxcJzogMTA0MCArIChpbmRleCAmJiAxIHx8IDApICsgaW5kZXgqMTB9XFxcIlxcXFxuPjwvZGl2PlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXFxcIiwnPGRpdiBtb2RhbC1yZW5kZXI9XFxcInt7JGlzUmVuZGVyZWR9fVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJkaWFsb2dcXFwiIGNsYXNzPVxcXCJtb2RhbFxcXCJcXFxcbiAgICB1aWItbW9kYWwtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcXFxuICAgIG1vZGFsLWluLWNsYXNzPVxcXCJpblxcXCJcXFxcbiAgICBuZy1zdHlsZT1cXFwie1xcXFwnei1pbmRleFxcXFwnOiAxMDUwICsgaW5kZXgqMTAsIGRpc3BsYXk6IFxcXFwnYmxvY2tcXFxcJ31cXFwiPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZyB7e3NpemUgPyBcXFxcJ21vZGFsLVxcXFwnICsgc2l6ZSA6IFxcXFwnXFxcXCd9fVxcXCI+PGRpdiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCIgdWliLW1vZGFsLXRyYW5zY2x1ZGU+PC9kaXY+PC9kaXY+XFxcXG48L2Rpdj5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvcGFnZXIvcGFnZXIuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcXFwiLCc8dWwgY2xhc3M9XFxcInBhZ2VyXFxcIj5cXFxcbiAgPGxpIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZCwgcHJldmlvdXM6IGFsaWdufVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoXFxcXCdwcmV2aW91c1xcXFwnKX19PC9hPjwvbGk+XFxcXG4gIDxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZCwgbmV4dDogYWxpZ259XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgKyAxLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dChcXFxcJ25leHRcXFxcJyl9fTwvYT48L2xpPlxcXFxuPC91bD5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFxcXCIsJzx1bCBjbGFzcz1cXFwicGFnaW5hdGlvblxcXCI+XFxcXG4gIDxsaSBuZy1pZj1cXFwiOjpib3VuZGFyeUxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1maXJzdFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZSgxLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dChcXFxcJ2ZpcnN0XFxcXCcpfX08L2E+PC9saT5cXFxcbiAgPGxpIG5nLWlmPVxcXCI6OmRpcmVjdGlvbkxpbmtzXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1wcmV2XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgLSAxLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dChcXFxcJ3ByZXZpb3VzXFxcXCcpfX08L2E+PC9saT5cXFxcbiAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlcyB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBwYWdlLmFjdGl2ZSxkaXNhYmxlZDogbmdEaXNhYmxlZCYmIXBhZ2UuYWN0aXZlfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcGFnZVxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlciwgJGV2ZW50KVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcXFxuICA8bGkgbmctaWY9XFxcIjo6ZGlyZWN0aW9uTGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tbmV4dFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlICsgMSwgJGV2ZW50KVxcXCI+e3s6OmdldFRleHQoXFxcXCduZXh0XFxcXCcpfX08L2E+PC9saT5cXFxcbiAgPGxpIG5nLWlmPVxcXCI6OmJvdW5kYXJ5TGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tbGFzdFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZSh0b3RhbFBhZ2VzLCAkZXZlbnQpXFxcIj57ezo6Z2V0VGV4dChcXFxcJ2xhc3RcXFxcJyl9fTwvYT48L2xpPlxcXFxuPC91bD5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtcG9wdXAuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIlxcXFxuICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXFxcbiAgdWliLXRvb2x0aXAtY2xhc3Nlc1xcXFxuICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxcXG4gIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcXFxuICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kLWh0bWw9XFxcImNvbnRlbnRFeHAoKVxcXCI+PC9kaXY+XFxcXG48L2Rpdj5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFxcXCIsJzxkaXYgY2xhc3M9XFxcInRvb2x0aXBcXFwiXFxcXG4gIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcXFxuICB1aWItdG9vbHRpcC1jbGFzc2VzXFxcXG4gIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXFxcbiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxcXG4gIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQ9XFxcImNvbnRlbnRcXFwiPjwvZGl2PlxcXFxuPC9kaXY+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cC5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIlxcXFxuICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXFxcbiAgdWliLXRvb2x0aXAtY2xhc3Nlc1xcXFxuICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxcXG4gIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcXFxuICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIlxcXFxuICAgIHVpYi10b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRFeHAoKVxcXCJcXFxcbiAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcXFxuPC9kaXY+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItaHRtbC5odG1sXFxcIiwnPGRpdiBjbGFzcz1cXFwicG9wb3ZlclxcXCJcXFxcbiAgdG9vbHRpcC1hbmltYXRpb24tY2xhc3M9XFxcImZhZGVcXFwiXFxcXG4gIHVpYi10b29sdGlwLWNsYXNzZXNcXFxcbiAgbmctY2xhc3M9XFxcInsgaW46IGlzT3BlbigpIH1cXFwiPlxcXFxuICA8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxcXG5cXFxcbiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxcXG4gICAgICA8aDMgY2xhc3M9XFxcInBvcG92ZXItdGl0bGVcXFwiIG5nLWJpbmQ9XFxcInRpdGxlXFxcIiBuZy1pZj1cXFwidGl0bGVcXFwiPjwvaDM+XFxcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWNvbnRlbnRcXFwiIG5nLWJpbmQtaHRtbD1cXFwiY29udGVudEV4cCgpXFxcIj48L2Rpdj5cXFxcbiAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFxcXCIsJzxkaXYgY2xhc3M9XFxcInBvcG92ZXJcXFwiXFxcXG4gIHRvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcXFxuICB1aWItdG9vbHRpcC1jbGFzc2VzXFxcXG4gIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSB9XFxcIj5cXFxcbiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcXFxuXFxcXG4gIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcXFxuICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctaWY9XFxcInRpdGxlXFxcIj48L2gzPlxcXFxuICAgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIlxcXFxuICAgICAgICB1aWItdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlPVxcXCJjb250ZW50RXhwKClcXFwiXFxcXG4gICAgICAgIHRvb2x0aXAtdGVtcGxhdGUtdHJhbnNjbHVkZS1zY29wZT1cXFwib3JpZ2luU2NvcGUoKVxcXCI+PC9kaXY+XFxcXG4gIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyXFxcIlxcXFxuICB0b29sdGlwLWFuaW1hdGlvbi1jbGFzcz1cXFwiZmFkZVxcXCJcXFxcbiAgdWliLXRvb2x0aXAtY2xhc3Nlc1xcXFxuICBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCkgfVxcXCI+XFxcXG4gIDxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXFxcblxcXFxuICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXFxcbiAgICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidGl0bGVcXFwiIG5nLWlmPVxcXCJ0aXRsZVxcXCI+PC9oMz5cXFxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY29udGVudFxcXCIgbmctYmluZD1cXFwiY29udGVudFxcXCI+PC9kaXY+XFxcXG4gIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJcXFwiIG5nLWNsYXNzPVxcXCJ0eXBlICYmIFxcXFwncHJvZ3Jlc3MtYmFyLVxcXFwnICsgdHlwZVxcXCIgcm9sZT1cXFwicHJvZ3Jlc3NiYXJcXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZW1pbj1cXFwiMFxcXCIgYXJpYS12YWx1ZW1heD1cXFwie3ttYXh9fVxcXCIgbmctc3R5bGU9XFxcInt3aWR0aDogKHBlcmNlbnQgPCAxMDAgPyBwZXJjZW50IDogMTAwKSArIFxcXFwnJVxcXFwnfVxcXCIgYXJpYS12YWx1ZXRleHQ9XFxcInt7cGVyY2VudCB8IG51bWJlcjowfX0lXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp0aXRsZX19XFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFxcXCIsJzxkaXYgY2xhc3M9XFxcInByb2dyZXNzXFxcIiBuZy10cmFuc2NsdWRlIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnRpdGxlfX1cXFwiPjwvZGl2PicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmh0bWxcXFwiLCc8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+XFxcXG4gIDxkaXYgY2xhc3M9XFxcInByb2dyZXNzLWJhclxcXCIgbmctY2xhc3M9XFxcInR5cGUgJiYgXFxcXCdwcm9ncmVzcy1iYXItXFxcXCcgKyB0eXBlXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3t2YWx1ZX19XFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCJ7e21heH19XFxcIiBuZy1zdHlsZT1cXFwie3dpZHRoOiAocGVyY2VudCA8IDEwMCA/IHBlcmNlbnQgOiAxMDApICsgXFxcXCclXFxcXCd9XFxcIiBhcmlhLXZhbHVldGV4dD1cXFwie3twZXJjZW50IHwgbnVtYmVyOjB9fSVcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnRpdGxlfX1cXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxcXG48L2Rpdj5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXFxcIiwnPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCIgbmcta2V5ZG93bj1cXFwib25LZXlkb3duKCRldmVudClcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7cmFuZ2UubGVuZ3RofX1cXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCI+XFxcXG4gICAgPHNwYW4gbmctcmVwZWF0LXN0YXJ0PVxcXCJyIGluIHJhbmdlIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcInNyLW9ubHlcXFwiPih7eyAkaW5kZXggPCB2YWx1ZSA/IFxcXFwnKlxcXFwnIDogXFxcXCcgXFxcXCcgfX0pPC9zcGFuPlxcXFxuICAgIDxpIG5nLXJlcGVhdC1lbmQgbmctbW91c2VlbnRlcj1cXFwiZW50ZXIoJGluZGV4ICsgMSlcXFwiIG5nLWNsaWNrPVxcXCJyYXRlKCRpbmRleCArIDEpXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uXFxcIiBuZy1jbGFzcz1cXFwiJGluZGV4IDwgdmFsdWUgJiYgKHIuc3RhdGVPbiB8fCBcXFxcJ2dseXBoaWNvbi1zdGFyXFxcXCcpIHx8IChyLnN0YXRlT2ZmIHx8IFxcXFwnZ2x5cGhpY29uLXN0YXItZW1wdHlcXFxcJylcXFwiIG5nLWF0dHItdGl0bGU9XFxcInt7ci50aXRsZX19XFxcIiBhcmlhLXZhbHVldGV4dD1cXFwie3tyLnRpdGxlfX1cXFwiPjwvaT5cXFxcbjwvc3Bhbj5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL3RhYnMvdGFiLmh0bWxcXFwiLCc8bGkgbmctY2xhc3M9XFxcInthY3RpdmU6IGFjdGl2ZSwgZGlzYWJsZWQ6IGRpc2FibGVkfVxcXCIgY2xhc3M9XFxcInVpYi10YWJcXFwiPlxcXFxuICA8YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3QoKVxcXCIgdWliLXRhYi1oZWFkaW5nLXRyYW5zY2x1ZGU+e3toZWFkaW5nfX08L2E+XFxcXG48L2xpPlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXFxcIixbXSkucnVuKFtcXFwiJHRlbXBsYXRlQ2FjaGVcXFwiLGZ1bmN0aW9uKGEpe2EucHV0KFxcXCJ1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFxcXCIsJzxkaXY+XFxcXG4gIDx1bCBjbGFzcz1cXFwibmF2IG5hdi17e3R5cGUgfHwgXFxcXCd0YWJzXFxcXCd9fVxcXCIgbmctY2xhc3M9XFxcIntcXFxcJ25hdi1zdGFja2VkXFxcXCc6IHZlcnRpY2FsLCBcXFxcJ25hdi1qdXN0aWZpZWRcXFxcJzoganVzdGlmaWVkfVxcXCIgbmctdHJhbnNjbHVkZT48L3VsPlxcXFxuICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIFxcXFxuICAgICAgICAgbmctcmVwZWF0PVxcXCJ0YWIgaW4gdGFic1xcXCIgXFxcXG4gICAgICAgICBuZy1jbGFzcz1cXFwie2FjdGl2ZTogdGFiLmFjdGl2ZX1cXFwiXFxcXG4gICAgICAgICB1aWItdGFiLWNvbnRlbnQtdHJhbnNjbHVkZT1cXFwidGFiXFxcIj5cXFxcbiAgICA8L2Rpdj5cXFxcbiAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcbicpfV0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFxcXCIsJzx0YWJsZSBjbGFzcz1cXFwidWliLXRpbWVwaWNrZXJcXFwiPlxcXFxuICA8dGJvZHk+XFxcXG4gICAgPHRyIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgbmctc2hvdz1cXFwiOjpzaG93U3Bpbm5lcnNcXFwiPlxcXFxuICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItaW5jcmVtZW50IGhvdXJzXFxcIj48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50SG91cnMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9JbmNyZW1lbnRIb3VycygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50SG91cnMoKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxcXG4gICAgICA8dGQ+Jm5ic3A7PC90ZD5cXFxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLWluY3JlbWVudCBtaW51dGVzXFxcIj48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50TWludXRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0luY3JlbWVudE1pbnV0ZXMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudE1pbnV0ZXMoKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxcXG4gICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiPiZuYnNwOzwvdGQ+XFxcXG4gICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiIGNsYXNzPVxcXCJ1aWItaW5jcmVtZW50IHNlY29uZHNcXFwiPjxhIG5nLWNsaWNrPVxcXCJpbmNyZW1lbnRTZWNvbmRzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vSW5jcmVtZW50U2Vjb25kcygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vSW5jcmVtZW50U2Vjb25kcygpXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiPjxzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiPjwvc3Bhbj48L2E+PC90ZD5cXFxcbiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxcXG4gICAgPC90cj5cXFxcbiAgICA8dHI+XFxcXG4gICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXAgdWliLXRpbWUgaG91cnNcXFwiIG5nLWNsYXNzPVxcXCJ7XFxcXCdoYXMtZXJyb3JcXFxcJzogaW52YWxpZEhvdXJzfVxcXCI+XFxcXG4gICAgICAgIDxpbnB1dCBzdHlsZT1cXFwid2lkdGg6NTBweDtcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJISFxcXCIgbmctbW9kZWw9XFxcImhvdXJzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZUhvdXJzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCI6OnJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRIb3VycygpXFxcIiBuZy1ibHVyPVxcXCJibHVyKClcXFwiPlxcXFxuICAgICAgPC90ZD5cXFxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLXNlcGFyYXRvclxcXCI+OjwvdGQ+XFxcXG4gICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXAgdWliLXRpbWUgbWludXRlc1xcXCIgbmctY2xhc3M9XFxcIntcXFxcJ2hhcy1lcnJvclxcXFwnOiBpbnZhbGlkTWludXRlc31cXFwiPlxcXFxuICAgICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOjUwcHg7XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiTU1cXFwiIG5nLW1vZGVsPVxcXCJtaW51dGVzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZU1pbnV0ZXMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcIjo6cmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctYmx1cj1cXFwiYmx1cigpXFxcIj5cXFxcbiAgICAgIDwvdGQ+XFxcXG4gICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiIGNsYXNzPVxcXCJ1aWItc2VwYXJhdG9yXFxcIj46PC90ZD5cXFxcbiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cCB1aWItdGltZSBzZWNvbmRzXFxcIiBuZy1jbGFzcz1cXFwie1xcXFwnaGFzLWVycm9yXFxcXCc6IGludmFsaWRTZWNvbmRzfVxcXCIgbmctc2hvdz1cXFwic2hvd1NlY29uZHNcXFwiPlxcXFxuICAgICAgICA8aW5wdXQgc3R5bGU9XFxcIndpZHRoOjUwcHg7XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiU1NcXFwiIG5nLW1vZGVsPVxcXCJzZWNvbmRzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZVNlY29uZHMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcInJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRTZWNvbmRzKClcXFwiIG5nLWJsdXI9XFxcImJsdXIoKVxcXCI+XFxcXG4gICAgICA8L3RkPlxcXFxuICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCIgY2xhc3M9XFxcInVpYi10aW1lIGFtLXBtXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9Ub2dnbGVNZXJpZGlhbigpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCB0ZXh0LWNlbnRlclxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1lcmlkaWFuKClcXFwiIG5nLWRpc2FibGVkPVxcXCJub1RvZ2dsZU1lcmlkaWFuKClcXFwiIHRhYmluZGV4PVxcXCJ7ezo6dGFiaW5kZXh9fVxcXCI+e3ttZXJpZGlhbn19PC9idXR0b24+PC90ZD5cXFxcbiAgICA8L3RyPlxcXFxuICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIG5nLXNob3c9XFxcIjo6c2hvd1NwaW5uZXJzXFxcIj5cXFxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLWRlY3JlbWVudCBob3Vyc1xcXCI+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudEhvdXJzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vRGVjcmVtZW50SG91cnMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0RlY3JlbWVudEhvdXJzKClcXFwiIHRhYmluZGV4PVxcXCJ7ezo6dGFiaW5kZXh9fVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxcXG4gICAgICA8dGQ+Jm5ic3A7PC90ZD5cXFxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLWRlY3JlbWVudCBtaW51dGVzXFxcIj48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50TWludXRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0RlY3JlbWVudE1pbnV0ZXMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0RlY3JlbWVudE1pbnV0ZXMoKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXFxcbiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCI+Jm5ic3A7PC90ZD5cXFxcbiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCIgY2xhc3M9XFxcInVpYi1kZWNyZW1lbnQgc2Vjb25kc1xcXCI+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudFNlY29uZHMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9EZWNyZW1lbnRTZWNvbmRzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9EZWNyZW1lbnRTZWNvbmRzKClcXFwiIHRhYmluZGV4PVxcXCJ7ezo6dGFiaW5kZXh9fVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxcXG4gICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48L3RkPlxcXFxuICAgIDwvdHI+XFxcXG4gIDwvdGJvZHk+XFxcXG48L3RhYmxlPlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcXFwiLFtdKS5ydW4oW1xcXCIkdGVtcGxhdGVDYWNoZVxcXCIsZnVuY3Rpb24oYSl7YS5wdXQoXFxcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcXFwiLCc8YSBocmVmXFxcXG4gICB0YWJpbmRleD1cXFwiLTFcXFwiXFxcXG4gICBuZy1iaW5kLWh0bWw9XFxcIm1hdGNoLmxhYmVsIHwgdWliVHlwZWFoZWFkSGlnaGxpZ2h0OnF1ZXJ5XFxcIlxcXFxuICAgbmctYXR0ci10aXRsZT1cXFwie3ttYXRjaC5sYWJlbH19XFxcIj48L2E+XFxcXG4nKX1dKSxhbmd1bGFyLm1vZHVsZShcXFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFxcXCIsW10pLnJ1bihbXFxcIiR0ZW1wbGF0ZUNhY2hlXFxcIixmdW5jdGlvbihhKXthLnB1dChcXFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFxcXCIsJzx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgbmctc2hvdz1cXFwiaXNPcGVuKCkgJiYgIW1vdmVJblByb2dyZXNzXFxcIiBuZy1zdHlsZT1cXFwie3RvcDogcG9zaXRpb24oKS50b3ArXFxcXCdweFxcXFwnLCBsZWZ0OiBwb3NpdGlvbigpLmxlZnQrXFxcXCdweFxcXFwnfVxcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgYXJpYS1oaWRkZW49XFxcInt7IWlzT3BlbigpfX1cXFwiPlxcXFxuICAgIDxsaSBuZy1yZXBlYXQ9XFxcIm1hdGNoIGluIG1hdGNoZXMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogaXNBY3RpdmUoJGluZGV4KSB9XFxcIiBuZy1tb3VzZWVudGVyPVxcXCJzZWxlY3RBY3RpdmUoJGluZGV4KVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdE1hdGNoKCRpbmRleCwgJGV2ZW50KVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBpZD1cXFwie3s6Om1hdGNoLmlkfX1cXFwiPlxcXFxuICAgICAgICA8ZGl2IHVpYi10eXBlYWhlYWQtbWF0Y2ggaW5kZXg9XFxcIiRpbmRleFxcXCIgbWF0Y2g9XFxcIm1hdGNoXFxcIiBxdWVyeT1cXFwicXVlcnlcXFwiIHRlbXBsYXRlLXVybD1cXFwidGVtcGxhdGVVcmxcXFwiPjwvZGl2PlxcXFxuICAgIDwvbGk+XFxcXG48L3VsPlxcXFxuJyl9XSksYW5ndWxhci5tb2R1bGUoXFxcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFxcXCIpLnJ1bihmdW5jdGlvbigpeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSYmYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKFxcXCJoZWFkXFxcIikucHJlcGVuZCgnPHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj4ubmctYW5pbWF0ZS5pdGVtOm5vdCgubGVmdCk6bm90KC5yaWdodCl7LXdlYmtpdC10cmFuc2l0aW9uOjBzIGVhc2UtaW4tb3V0IGxlZnQ7dHJhbnNpdGlvbjowcyBlYXNlLWluLW91dCBsZWZ0fTwvc3R5bGU+Jyl9KSxhbmd1bGFyLm1vZHVsZShcXFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJcXFwiKS5ydW4oZnVuY3Rpb24oKXshYW5ndWxhci4kJGNzcCgpLm5vSW5saW5lU3R5bGUmJmFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZChcXFwiaGVhZFxcXCIpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+LnVpYi1kYXRlcGlja2VyIC51aWItdGl0bGV7d2lkdGg6MTAwJTt9LnVpYi1kYXkgYnV0dG9uLC51aWItbW9udGggYnV0dG9uLC51aWIteWVhciBidXR0b257bWluLXdpZHRoOjEwMCU7fS51aWItZGF0ZXBpY2tlci1wb3B1cC5kcm9wZG93bi1tZW51e2Rpc3BsYXk6YmxvY2s7fS51aWItYnV0dG9uLWJhcntwYWRkaW5nOjEwcHggOXB4IDJweDt9PC9zdHlsZT4nKX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclxcXCIpLnJ1bihmdW5jdGlvbigpeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSYmYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKFxcXCJoZWFkXFxcIikucHJlcGVuZCgnPHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj4udWliLXRpbWUgaW5wdXR7d2lkdGg6NTBweDt9PC9zdHlsZT4nKX0pLGFuZ3VsYXIubW9kdWxlKFxcXCJ1aS5ib290c3RyYXAudHlwZWFoZWFkXFxcIikucnVuKGZ1bmN0aW9uKCl7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlJiZhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoXFxcImhlYWRcXFwiKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlt1aWItdHlwZWFoZWFkLXBvcHVwXS5kcm9wZG93bi1tZW51e2Rpc3BsYXk6YmxvY2s7fTwvc3R5bGU+Jyl9KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItYm9vdHN0cmFwL3VpLWJvb3RzdHJhcC10cGxzLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJyZXF1aXJlKFwiISEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9sdWh1aWppYW4vRGVza3RvcC9jb2RlL2lyb24tbW9jay9saWIvYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWllOHByb3ZpZGVyL2FuZ3VsYXItaWU4cHJvdmlkZXIuanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1pZThwcm92aWRlci9hbmd1bGFyLWllOHByb3ZpZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJhbmd1bGFyLm1vZHVsZSgnaWU4cHJvdmlkZXInLCBbXSkucHJvdmlkZXIoJ2llOCcsIGZ1bmN0aW9uKCkge1xcbiAgdGhpcy4kZ2V0ID0gYW5ndWxhci5ub29wO1xcbiAgdmFyIGN1c3RvbVRhZ3MgPSB0aGlzLmN1c3RvbVRhZ3MgPSBbXTtcXG4gIHZhciBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudDtcXG4gIGlmKGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChkb2N1bWVudCkuY3JlYXRlRWxlbWVudCkge1xcbiAgICBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBmcmFnbWVudCA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChkb2N1bWVudCk7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXN0b21UYWdzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBmcmFnbWVudC5jcmVhdGVFbGVtZW50KGN1c3RvbVRhZ3NbaV0pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZnJhZ21lbnQ7XFxuICAgIH07XFxuICB9XFxufSk7XFxuXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWllOHByb3ZpZGVyL2FuZ3VsYXItaWU4cHJvdmlkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwicmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL2Jvd2VyX2NvbXBvbmVudHMvbmctanNvbmVkaXRvci9uZy1qc29uZWRpdG9yLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL25nLWpzb25lZGl0b3IvbmctanNvbmVkaXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCduZy5qc29uZWRpdG9yJywgW10pO1xcbiAgICBtb2R1bGUuY29uc3RhbnQoJ25nSnNvbmVkaXRvckNvbmZpZycsIHt9KTtcXG5cXG4gICAgbW9kdWxlLmRpcmVjdGl2ZSgnbmdKc29uZWRpdG9yJywgWyduZ0pzb25lZGl0b3JDb25maWcnLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAobmdKc29uZWRpdG9yQ29uZmlnLCAkdGltZW91dCkge1xcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gbmdKc29uZWRpdG9yQ29uZmlnIHx8IHt9O1xcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICByZXN0cmljdDogJ0EnLFxcbiAgICAgICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcXG4gICAgICAgICAgICBzY29wZTogeydvcHRpb25zJzogJz0nLCAnbmdKc29uZWRpdG9yJzogJz0nLCAncHJlZmVyVGV4dCc6ICc9J30sXFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKCRzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGRlYm91bmNlVG8sIGRlYm91bmNlRnJvbTtcXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvcjtcXG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsVHJpZ2dlciA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNEZWZpbmVkKHdpbmRvdy5KU09ORWRpdG9yKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJQbGVhc2UgYWRkIHRoZSBqc29uZWRpdG9yLmpzIHNjcmlwdCBmaXJzdCFcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY3JlYXRlRWRpdG9yKG9wdGlvbnMpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhlT3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBzZXR0aW5ncywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlYm91bmNlVG8gIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoZGVib3VuY2VUbyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VUbyA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGl0b3IpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRyaWdnZXIgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSgkc2NvcGUucHJlZmVyVGV4dCA9PT0gdHJ1ZSA/IGVkaXRvci5nZXRUZXh0KCkgOiBlZGl0b3IuZ2V0KCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHJpZ2dlciA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnY2hhbmdlJykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2hhbmdlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzZXR0aW5ncy50aW1lb3V0IHx8IDEwMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmh0bWwoJycpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IEpTT05FZGl0b3IoZWxlbWVudFswXSwgdGhlT3B0aW9ucyk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLm5nSnNvbmVkaXRvciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkgeyAkc2NvcGUubmdKc29uZWRpdG9yKGluc3RhbmNlKTt9KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKCdvcHRpb25zJywgZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBuZXdWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IG5ld1ZhbHVlW2tdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWVba10gIT09IG9sZFZhbHVlW2tdKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ21vZGUnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldE1vZGUodik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICduYW1lJykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXROYW1lKHYpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9vdGhlciBzZXR0aW5ncyBjYW5ub3QgYmUgY2hhbmdlZCB3aXRob3V0IHJlLWNyZWF0aW5nIHRoZSBKc29uRWRpdG9yXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yID0gX2NyZWF0ZUVkaXRvcihuZXdWYWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnVwZGF0ZUpzb25FZGl0b3IoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xcblxcbiAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGpzb25lZGl0b3I/XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAkc2NvcGUudXBkYXRlSnNvbkVkaXRvciA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsVHJpZ2dlcikgcmV0dXJuOyAvL2lnbm9yZSBpZiBjYWxsZWQgYnkgJHNldFZpZXdWYWx1ZVxcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWJvdW5jZUZyb20gIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKGRlYm91bmNlRnJvbSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZUZyb20gPSAkdGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgkc2NvcGUucHJlZmVyVGV4dCA9PT0gdHJ1ZSkgJiYgIWFuZ3VsYXIuaXNPYmplY3QobmdNb2RlbC4kdmlld1ZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0VGV4dChuZ01vZGVsLiR2aWV3VmFsdWUgfHwgJ3t9Jyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldChuZ01vZGVsLiR2aWV3VmFsdWUgfHwge30pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0sICRzY29wZS5vcHRpb25zLnRpbWVvdXQgfHwgMTAwKTtcXG4gICAgICAgICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgICAgICAgZWRpdG9yID0gX2NyZWF0ZUVkaXRvcigkc2NvcGUub3B0aW9ucyk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICgkc2NvcGUub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZXhwYW5kZWQnKSkge1xcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoJHNjb3BlLm9wdGlvbnMuZXhwYW5kZWQgPyBmdW5jdGlvbiAoKSB7ZWRpdG9yLmV4cGFuZEFsbCgpfSA6IGZ1bmN0aW9uICgpIHtlZGl0b3IuY29sbGFwc2VBbGwoKX0sICgkc2NvcGUub3B0aW9ucy50aW1lb3V0IHx8IDEwMCkgKyAxMDApO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIG5nTW9kZWwuJHJlbmRlciA9ICRzY29wZS51cGRhdGVKc29uRWRpdG9yO1xcbiAgICAgICAgICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kZWwuJG1vZGVsVmFsdWU7IH0sICRzY29wZS51cGRhdGVKc29uRWRpdG9yLCB0cnVlKTsgLy9pZiBzb21lb25lIGNoYW5nZXMgbmctbW9kZWwgZnJvbSBvdXRzaWRlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgfV0pO1xcbn0pKCk7XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vYm93ZXJfY29tcG9uZW50cy9uZy1qc29uZWRpdG9yL25nLWpzb25lZGl0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAxXG4gKiovIiwicmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2x1aHVpamlhbi9EZXNrdG9wL2NvZGUvaXJvbi1tb2NrL2xpYi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvbHVodWlqaWFuL0Rlc2t0b3AvY29kZS9pcm9uLW1vY2svbGliL2Jvd2VyX2NvbXBvbmVudHMvc3dlZXRhbGVydC9kaXN0L3N3ZWV0YWxlcnQtZGV2LmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9ib3dlcl9jb21wb25lbnRzL3N3ZWV0YWxlcnQvZGlzdC9zd2VldGFsZXJ0LWRldi5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiOyhmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4gIFxcbiAgKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cXFwiZnVuY3Rpb25cXFwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFxcXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1xcXCIrbytcXFwiJ1xcXCIpO3Rocm93IGYuY29kZT1cXFwiTU9EVUxFX05PVF9GT1VORFxcXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cXFwiZnVuY3Rpb25cXFwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8vIFN3ZWV0QWxlcnRcXG4vLyAyMDE0LTIwMTUgKGMpIC0gVHJpc3RhbiBFZHdhcmRzXFxuLy8gZ2l0aHViLmNvbS90NHQ1L3N3ZWV0YWxlcnRcXG5cXG4vKlxcbiAqIGpRdWVyeS1saWtlIGZ1bmN0aW9ucyBmb3IgbWFuaXB1bGF0aW5nIHRoZSBET01cXG4gKi9cXG5cXG52YXIgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uID0gcmVxdWlyZSgnLi9tb2R1bGVzL2hhbmRsZS1kb20nKTtcXG5cXG4vKlxcbiAqIEhhbmR5IHV0aWxpdGllc1xcbiAqL1xcblxcbnZhciBfZXh0ZW5kJGhleFRvUmdiJGlzSUU4JGxvZ1N0ciRjb2xvckx1bWluYW5jZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy91dGlscycpO1xcblxcbi8qXFxuICogIEhhbmRsZSBzd2VldEFsZXJ0J3MgRE9NIGVsZW1lbnRzXFxuICovXFxuXFxudmFyIF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbiA9IHJlcXVpcmUoJy4vbW9kdWxlcy9oYW5kbGUtc3dhbC1kb20nKTtcXG5cXG4vLyBIYW5kbGUgYnV0dG9uIGV2ZW50cyBhbmQga2V5Ym9hcmQgZXZlbnRzXFxuXFxudmFyIF9oYW5kbGVCdXR0b24kaGFuZGxlQ29uZmlybSRoYW5kbGVDYW5jZWwgPSByZXF1aXJlKCcuL21vZHVsZXMvaGFuZGxlLWNsaWNrJyk7XFxuXFxudmFyIF9oYW5kbGVLZXlEb3duID0gcmVxdWlyZSgnLi9tb2R1bGVzL2hhbmRsZS1rZXknKTtcXG5cXG52YXIgX2hhbmRsZUtleURvd24yID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZUtleURvd24pO1xcblxcbi8vIERlZmF1bHQgdmFsdWVzXFxuXFxudmFyIF9kZWZhdWx0UGFyYW1zID0gcmVxdWlyZSgnLi9tb2R1bGVzL2RlZmF1bHQtcGFyYW1zJyk7XFxuXFxudmFyIF9kZWZhdWx0UGFyYW1zMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9kZWZhdWx0UGFyYW1zKTtcXG5cXG52YXIgX3NldFBhcmFtZXRlcnMgPSByZXF1aXJlKCcuL21vZHVsZXMvc2V0LXBhcmFtcycpO1xcblxcbnZhciBfc2V0UGFyYW1ldGVyczIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfc2V0UGFyYW1ldGVycyk7XFxuXFxuLypcXG4gKiBSZW1lbWJlciBzdGF0ZSBpbiBjYXNlcyB3aGVyZSBvcGVuaW5nIGFuZCBoYW5kbGluZyBhIG1vZGFsIHdpbGwgZmlkZGxlIHdpdGggaXQuXFxuICogKFdlIGFsc28gdXNlIHdpbmRvdy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgYXMgYSBnbG9iYWwgdmFyaWFibGUpXFxuICovXFxudmFyIHByZXZpb3VzV2luZG93S2V5RG93bjtcXG52YXIgbGFzdEZvY3VzZWRCdXR0b247XFxuXFxuLypcXG4gKiBHbG9iYWwgc3dlZXRBbGVydCBmdW5jdGlvblxcbiAqICh0aGlzIGlzIHdoYXQgdGhlIHVzZXIgY2FsbHMpXFxuICovXFxudmFyIHN3ZWV0QWxlcnQsIHN3YWw7XFxuXFxuZXhwb3J0c1snZGVmYXVsdCddID0gc3dlZXRBbGVydCA9IHN3YWwgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgY3VzdG9taXphdGlvbnMgPSBhcmd1bWVudHNbMF07XFxuXFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24uYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3N0b3Atc2Nyb2xsaW5nJyk7XFxuICBfc3dlZXRBbGVydEluaXRpYWxpemUkZ2V0TW9kYWwkZ2V0T3ZlcmxheSRnZXRJbnB1dCRzZXRGb2N1c1N0eWxlJG9wZW5Nb2RhbCRyZXNldElucHV0JGZpeFZlcnRpY2FsUG9zaXRpb24ucmVzZXRJbnB1dCgpO1xcblxcbiAgLypcXG4gICAqIFVzZSBhcmd1bWVudCBpZiBkZWZpbmVkIG9yIGRlZmF1bHQgdmFsdWUgZnJvbSBwYXJhbXMgb2JqZWN0IG90aGVyd2lzZS5cXG4gICAqIFN1cHBvcnRzIHRoZSBjYXNlIHdoZXJlIGEgZGVmYXVsdCB2YWx1ZSBpcyBib29sZWFuIHRydWUgYW5kIHNob3VsZCBiZVxcbiAgICogb3ZlcnJpZGRlbiBieSBhIGNvcnJlc3BvbmRpbmcgZXhwbGljaXQgYXJndW1lbnQgd2hpY2ggaXMgYm9vbGVhbiBmYWxzZS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYXJndW1lbnRPckRlZmF1bHQoa2V5KSB7XFxuICAgIHZhciBhcmdzID0gY3VzdG9taXphdGlvbnM7XFxuICAgIHJldHVybiBhcmdzW2tleV0gPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0UGFyYW1zMlsnZGVmYXVsdCddW2tleV0gOiBhcmdzW2tleV07XFxuICB9XFxuXFxuICBpZiAoY3VzdG9taXphdGlvbnMgPT09IHVuZGVmaW5lZCkge1xcbiAgICBfZXh0ZW5kJGhleFRvUmdiJGlzSUU4JGxvZ1N0ciRjb2xvckx1bWluYW5jZS5sb2dTdHIoJ1N3ZWV0QWxlcnQgZXhwZWN0cyBhdCBsZWFzdCAxIGF0dHJpYnV0ZSEnKTtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIHBhcmFtcyA9IF9leHRlbmQkaGV4VG9SZ2IkaXNJRTgkbG9nU3RyJGNvbG9yTHVtaW5hbmNlLmV4dGVuZCh7fSwgX2RlZmF1bHRQYXJhbXMyWydkZWZhdWx0J10pO1xcblxcbiAgc3dpdGNoICh0eXBlb2YgY3VzdG9taXphdGlvbnMpIHtcXG5cXG4gICAgLy8gRXg6IHN3YWwoXFxcIkhlbGxvXFxcIiwgXFxcIkp1c3QgdGVzdGluZ1xcXCIsIFxcXCJpbmZvXFxcIik7XFxuICAgIGNhc2UgJ3N0cmluZyc6XFxuICAgICAgcGFyYW1zLnRpdGxlID0gY3VzdG9taXphdGlvbnM7XFxuICAgICAgcGFyYW1zLnRleHQgPSBhcmd1bWVudHNbMV0gfHwgJyc7XFxuICAgICAgcGFyYW1zLnR5cGUgPSBhcmd1bWVudHNbMl0gfHwgJyc7XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIC8vIEV4OiBzd2FsKHsgdGl0bGU6XFxcIkhlbGxvXFxcIiwgdGV4dDogXFxcIkp1c3QgdGVzdGluZ1xcXCIsIHR5cGU6IFxcXCJpbmZvXFxcIiB9KTtcXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICBpZiAoY3VzdG9taXphdGlvbnMudGl0bGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgX2V4dGVuZCRoZXhUb1JnYiRpc0lFOCRsb2dTdHIkY29sb3JMdW1pbmFuY2UubG9nU3RyKCdNaXNzaW5nIFxcXCJ0aXRsZVxcXCIgYXJndW1lbnQhJyk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHBhcmFtcy50aXRsZSA9IGN1c3RvbWl6YXRpb25zLnRpdGxlO1xcblxcbiAgICAgIGZvciAodmFyIGN1c3RvbU5hbWUgaW4gX2RlZmF1bHRQYXJhbXMyWydkZWZhdWx0J10pIHtcXG4gICAgICAgIHBhcmFtc1tjdXN0b21OYW1lXSA9IGFyZ3VtZW50T3JEZWZhdWx0KGN1c3RvbU5hbWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBTaG93IFxcXCJDb25maXJtXFxcIiBpbnN0ZWFkIG9mIFxcXCJPS1xcXCIgaWYgY2FuY2VsIGJ1dHRvbiBpcyB2aXNpYmxlXFxuICAgICAgcGFyYW1zLmNvbmZpcm1CdXR0b25UZXh0ID0gcGFyYW1zLnNob3dDYW5jZWxCdXR0b24gPyAnQ29uZmlybScgOiBfZGVmYXVsdFBhcmFtczJbJ2RlZmF1bHQnXS5jb25maXJtQnV0dG9uVGV4dDtcXG4gICAgICBwYXJhbXMuY29uZmlybUJ1dHRvblRleHQgPSBhcmd1bWVudE9yRGVmYXVsdCgnY29uZmlybUJ1dHRvblRleHQnKTtcXG5cXG4gICAgICAvLyBDYWxsYmFjayBmdW5jdGlvbiB3aGVuIGNsaWNraW5nIG9uIFxcXCJPS1xcXCIvXFxcIkNhbmNlbFxcXCJcXG4gICAgICBwYXJhbXMuZG9uZUZ1bmN0aW9uID0gYXJndW1lbnRzWzFdIHx8IG51bGw7XFxuXFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGRlZmF1bHQ6XFxuICAgICAgX2V4dGVuZCRoZXhUb1JnYiRpc0lFOCRsb2dTdHIkY29sb3JMdW1pbmFuY2UubG9nU3RyKCdVbmV4cGVjdGVkIHR5cGUgb2YgYXJndW1lbnQhIEV4cGVjdGVkIFxcXCJzdHJpbmdcXFwiIG9yIFxcXCJvYmplY3RcXFwiLCBnb3QgJyArIHR5cGVvZiBjdXN0b21pemF0aW9ucyk7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcblxcbiAgfVxcblxcbiAgX3NldFBhcmFtZXRlcnMyWydkZWZhdWx0J10ocGFyYW1zKTtcXG4gIF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbi5maXhWZXJ0aWNhbFBvc2l0aW9uKCk7XFxuICBfc3dlZXRBbGVydEluaXRpYWxpemUkZ2V0TW9kYWwkZ2V0T3ZlcmxheSRnZXRJbnB1dCRzZXRGb2N1c1N0eWxlJG9wZW5Nb2RhbCRyZXNldElucHV0JGZpeFZlcnRpY2FsUG9zaXRpb24ub3Blbk1vZGFsKGFyZ3VtZW50c1sxXSk7XFxuXFxuICAvLyBNb2RhbCBpbnRlcmFjdGlvbnNcXG4gIHZhciBtb2RhbCA9IF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbi5nZXRNb2RhbCgpO1xcblxcbiAgLypcXG4gICAqIE1ha2Ugc3VyZSBhbGwgbW9kYWwgYnV0dG9ucyByZXNwb25kIHRvIGFsbCBldmVudHNcXG4gICAqL1xcbiAgdmFyICRidXR0b25zID0gbW9kYWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJyk7XFxuICB2YXIgYnV0dG9uRXZlbnRzID0gWydvbmNsaWNrJywgJ29ubW91c2VvdmVyJywgJ29ubW91c2VvdXQnLCAnb25tb3VzZWRvd24nLCAnb25tb3VzZXVwJywgJ29uZm9jdXMnXTtcXG4gIHZhciBvbkJ1dHRvbkV2ZW50ID0gZnVuY3Rpb24gb25CdXR0b25FdmVudChlKSB7XFxuICAgIHJldHVybiBfaGFuZGxlQnV0dG9uJGhhbmRsZUNvbmZpcm0kaGFuZGxlQ2FuY2VsLmhhbmRsZUJ1dHRvbihlLCBwYXJhbXMsIG1vZGFsKTtcXG4gIH07XFxuXFxuICBmb3IgKHZhciBidG5JbmRleCA9IDA7IGJ0bkluZGV4IDwgJGJ1dHRvbnMubGVuZ3RoOyBidG5JbmRleCsrKSB7XFxuICAgIGZvciAodmFyIGV2dEluZGV4ID0gMDsgZXZ0SW5kZXggPCBidXR0b25FdmVudHMubGVuZ3RoOyBldnRJbmRleCsrKSB7XFxuICAgICAgdmFyIGJ0bkV2dCA9IGJ1dHRvbkV2ZW50c1tldnRJbmRleF07XFxuICAgICAgJGJ1dHRvbnNbYnRuSW5kZXhdW2J0bkV2dF0gPSBvbkJ1dHRvbkV2ZW50O1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBDbGlja2luZyBvdXRzaWRlIHRoZSBtb2RhbCBkaXNtaXNzZXMgaXQgKGlmIGFsbG93ZWQgYnkgdXNlcilcXG4gIF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbi5nZXRPdmVybGF5KCkub25jbGljayA9IG9uQnV0dG9uRXZlbnQ7XFxuXFxuICBwcmV2aW91c1dpbmRvd0tleURvd24gPSB3aW5kb3cub25rZXlkb3duO1xcblxcbiAgdmFyIG9uS2V5RXZlbnQgPSBmdW5jdGlvbiBvbktleUV2ZW50KGUpIHtcXG4gICAgcmV0dXJuIF9oYW5kbGVLZXlEb3duMlsnZGVmYXVsdCddKGUsIHBhcmFtcywgbW9kYWwpO1xcbiAgfTtcXG4gIHdpbmRvdy5vbmtleWRvd24gPSBvbktleUV2ZW50O1xcblxcbiAgd2luZG93Lm9uZm9jdXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIFdoZW4gdGhlIHVzZXIgaGFzIGZvY3VzZWQgYXdheSBhbmQgZm9jdXNlZCBiYWNrIGZyb20gdGhlIHdob2xlIHdpbmRvdy5cXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gUHV0IGluIGEgdGltZW91dCB0byBqdW1wIG91dCBvZiB0aGUgZXZlbnQgc2VxdWVuY2UuXFxuICAgICAgLy8gQ2FsbGluZyBmb2N1cygpIGluIHRoZSBldmVudCBzZXF1ZW5jZSBjb25mdXNlcyB0aGluZ3MuXFxuICAgICAgaWYgKGxhc3RGb2N1c2VkQnV0dG9uICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGxhc3RGb2N1c2VkQnV0dG9uLmZvY3VzKCk7XFxuICAgICAgICBsYXN0Rm9jdXNlZEJ1dHRvbiA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgIH0sIDApO1xcbiAgfTtcXG5cXG4gIC8vIFNob3cgYWxlcnQgd2l0aCBlbmFibGVkIGJ1dHRvbnMgYWx3YXlzXFxuICBzd2FsLmVuYWJsZUJ1dHRvbnMoKTtcXG59O1xcblxcbi8qXFxuICogU2V0IGRlZmF1bHQgcGFyYW1zIGZvciBlYWNoIHBvcHVwXFxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJQYXJhbXNcXG4gKi9cXG5zd2VldEFsZXJ0LnNldERlZmF1bHRzID0gc3dhbC5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uICh1c2VyUGFyYW1zKSB7XFxuICBpZiAoIXVzZXJQYXJhbXMpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFyYW1zIGlzIHJlcXVpcmVkJyk7XFxuICB9XFxuICBpZiAodHlwZW9mIHVzZXJQYXJhbXMgIT09ICdvYmplY3QnKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigndXNlclBhcmFtcyBoYXMgdG8gYmUgYSBvYmplY3QnKTtcXG4gIH1cXG5cXG4gIF9leHRlbmQkaGV4VG9SZ2IkaXNJRTgkbG9nU3RyJGNvbG9yTHVtaW5hbmNlLmV4dGVuZChfZGVmYXVsdFBhcmFtczJbJ2RlZmF1bHQnXSwgdXNlclBhcmFtcyk7XFxufTtcXG5cXG4vKlxcbiAqIEFuaW1hdGlvbiB3aGVuIGNsb3NpbmcgbW9kYWxcXG4gKi9cXG5zd2VldEFsZXJ0LmNsb3NlID0gc3dhbC5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBtb2RhbCA9IF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbi5nZXRNb2RhbCgpO1xcblxcbiAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uLmZhZGVPdXQoX3N3ZWV0QWxlcnRJbml0aWFsaXplJGdldE1vZGFsJGdldE92ZXJsYXkkZ2V0SW5wdXQkc2V0Rm9jdXNTdHlsZSRvcGVuTW9kYWwkcmVzZXRJbnB1dCRmaXhWZXJ0aWNhbFBvc2l0aW9uLmdldE92ZXJsYXkoKSwgNSk7XFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24uZmFkZU91dChtb2RhbCwgNSk7XFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24ucmVtb3ZlQ2xhc3MobW9kYWwsICdzaG93U3dlZXRBbGVydCcpO1xcbiAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uLmFkZENsYXNzKG1vZGFsLCAnaGlkZVN3ZWV0QWxlcnQnKTtcXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZSRpc0Rlc2NlbmRhbnQkZ2V0VG9wTWFyZ2luJGZhZGVJbiRmYWRlT3V0JGZpcmVDbGljayRzdG9wRXZlbnRQcm9wYWdhdGlvbi5yZW1vdmVDbGFzcyhtb2RhbCwgJ3Zpc2libGUnKTtcXG5cXG4gIC8qXFxuICAgKiBSZXNldCBpY29uIGFuaW1hdGlvbnNcXG4gICAqL1xcbiAgdmFyICRzdWNjZXNzSWNvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5zYS1pY29uLnNhLXN1Y2Nlc3MnKTtcXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZSRpc0Rlc2NlbmRhbnQkZ2V0VG9wTWFyZ2luJGZhZGVJbiRmYWRlT3V0JGZpcmVDbGljayRzdG9wRXZlbnRQcm9wYWdhdGlvbi5yZW1vdmVDbGFzcygkc3VjY2Vzc0ljb24sICdhbmltYXRlJyk7XFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24ucmVtb3ZlQ2xhc3MoJHN1Y2Nlc3NJY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS10aXAnKSwgJ2FuaW1hdGVTdWNjZXNzVGlwJyk7XFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24ucmVtb3ZlQ2xhc3MoJHN1Y2Nlc3NJY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS1sb25nJyksICdhbmltYXRlU3VjY2Vzc0xvbmcnKTtcXG5cXG4gIHZhciAkZXJyb3JJY29uID0gbW9kYWwucXVlcnlTZWxlY3RvcignLnNhLWljb24uc2EtZXJyb3InKTtcXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZSRpc0Rlc2NlbmRhbnQkZ2V0VG9wTWFyZ2luJGZhZGVJbiRmYWRlT3V0JGZpcmVDbGljayRzdG9wRXZlbnRQcm9wYWdhdGlvbi5yZW1vdmVDbGFzcygkZXJyb3JJY29uLCAnYW5pbWF0ZUVycm9ySWNvbicpO1xcbiAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uLnJlbW92ZUNsYXNzKCRlcnJvckljb24ucXVlcnlTZWxlY3RvcignLnNhLXgtbWFyaycpLCAnYW5pbWF0ZVhNYXJrJyk7XFxuXFxuICB2YXIgJHdhcm5pbmdJY29uID0gbW9kYWwucXVlcnlTZWxlY3RvcignLnNhLWljb24uc2Etd2FybmluZycpO1xcbiAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uLnJlbW92ZUNsYXNzKCR3YXJuaW5nSWNvbiwgJ3B1bHNlV2FybmluZycpO1xcbiAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uLnJlbW92ZUNsYXNzKCR3YXJuaW5nSWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtYm9keScpLCAncHVsc2VXYXJuaW5nSW5zJyk7XFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24ucmVtb3ZlQ2xhc3MoJHdhcm5pbmdJY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS1kb3QnKSwgJ3B1bHNlV2FybmluZ0lucycpO1xcblxcbiAgLy8gUmVzZXQgY3VzdG9tIGNsYXNzIChkZWxheSBzbyB0aGF0IFVJIGNoYW5nZXMgYXJlbid0IHZpc2libGUpXFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGN1c3RvbUNsYXNzID0gbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWN1c3RvbS1jbGFzcycpO1xcbiAgICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24ucmVtb3ZlQ2xhc3MobW9kYWwsIGN1c3RvbUNsYXNzKTtcXG4gIH0sIDMwMCk7XFxuXFxuICAvLyBNYWtlIHBhZ2Ugc2Nyb2xsYWJsZSBhZ2FpblxcbiAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlJGlzRGVzY2VuZGFudCRnZXRUb3BNYXJnaW4kZmFkZUluJGZhZGVPdXQkZmlyZUNsaWNrJHN0b3BFdmVudFByb3BhZ2F0aW9uLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdzdG9wLXNjcm9sbGluZycpO1xcblxcbiAgLy8gUmVzZXQgdGhlIHBhZ2UgdG8gaXRzIHByZXZpb3VzIHN0YXRlXFxuICB3aW5kb3cub25rZXlkb3duID0gcHJldmlvdXNXaW5kb3dLZXlEb3duO1xcbiAgaWYgKHdpbmRvdy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQpIHtcXG4gICAgd2luZG93LnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xcbiAgfVxcbiAgbGFzdEZvY3VzZWRCdXR0b24gPSB1bmRlZmluZWQ7XFxuICBjbGVhclRpbWVvdXQobW9kYWwudGltZW91dCk7XFxuXFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbi8qXFxuICogVmFsaWRhdGlvbiBvZiB0aGUgaW5wdXQgZmllbGQgaXMgZG9uZSBieSB1c2VyXFxuICogSWYgc29tZXRoaW5nIGlzIHdyb25nID0+IGNhbGwgc2hvd0lucHV0RXJyb3Igd2l0aCBlcnJvck1lc3NhZ2VcXG4gKi9cXG5zd2VldEFsZXJ0LnNob3dJbnB1dEVycm9yID0gc3dhbC5zaG93SW5wdXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UpIHtcXG4gIHZhciBtb2RhbCA9IF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbi5nZXRNb2RhbCgpO1xcblxcbiAgdmFyICRlcnJvckljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaW5wdXQtZXJyb3InKTtcXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZSRpc0Rlc2NlbmRhbnQkZ2V0VG9wTWFyZ2luJGZhZGVJbiRmYWRlT3V0JGZpcmVDbGljayRzdG9wRXZlbnRQcm9wYWdhdGlvbi5hZGRDbGFzcygkZXJyb3JJY29uLCAnc2hvdycpO1xcblxcbiAgdmFyICRlcnJvckNvbnRhaW5lciA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5zYS1lcnJvci1jb250YWluZXInKTtcXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZSRpc0Rlc2NlbmRhbnQkZ2V0VG9wTWFyZ2luJGZhZGVJbiRmYWRlT3V0JGZpcmVDbGljayRzdG9wRXZlbnRQcm9wYWdhdGlvbi5hZGRDbGFzcygkZXJyb3JDb250YWluZXIsICdzaG93Jyk7XFxuXFxuICAkZXJyb3JDb250YWluZXIucXVlcnlTZWxlY3RvcigncCcpLmlubmVySFRNTCA9IGVycm9yTWVzc2FnZTtcXG5cXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICBzd2VldEFsZXJ0LmVuYWJsZUJ1dHRvbnMoKTtcXG4gIH0sIDEpO1xcblxcbiAgbW9kYWwucXVlcnlTZWxlY3RvcignaW5wdXQnKS5mb2N1cygpO1xcbn07XFxuXFxuLypcXG4gKiBSZXNldCBpbnB1dCBlcnJvciBET00gZWxlbWVudHNcXG4gKi9cXG5zd2VldEFsZXJ0LnJlc2V0SW5wdXRFcnJvciA9IHN3YWwucmVzZXRJbnB1dEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAvLyBJZiBwcmVzcyBlbnRlciA9PiBpZ25vcmVcXG4gIGlmIChldmVudCAmJiBldmVudC5rZXlDb2RlID09PSAxMykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgJG1vZGFsID0gX3N3ZWV0QWxlcnRJbml0aWFsaXplJGdldE1vZGFsJGdldE92ZXJsYXkkZ2V0SW5wdXQkc2V0Rm9jdXNTdHlsZSRvcGVuTW9kYWwkcmVzZXRJbnB1dCRmaXhWZXJ0aWNhbFBvc2l0aW9uLmdldE1vZGFsKCk7XFxuXFxuICB2YXIgJGVycm9ySWNvbiA9ICRtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaW5wdXQtZXJyb3InKTtcXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZSRpc0Rlc2NlbmRhbnQkZ2V0VG9wTWFyZ2luJGZhZGVJbiRmYWRlT3V0JGZpcmVDbGljayRzdG9wRXZlbnRQcm9wYWdhdGlvbi5yZW1vdmVDbGFzcygkZXJyb3JJY29uLCAnc2hvdycpO1xcblxcbiAgdmFyICRlcnJvckNvbnRhaW5lciA9ICRtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtZXJyb3ItY29udGFpbmVyJyk7XFxuICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUkaXNEZXNjZW5kYW50JGdldFRvcE1hcmdpbiRmYWRlSW4kZmFkZU91dCRmaXJlQ2xpY2skc3RvcEV2ZW50UHJvcGFnYXRpb24ucmVtb3ZlQ2xhc3MoJGVycm9yQ29udGFpbmVyLCAnc2hvdycpO1xcbn07XFxuXFxuLypcXG4gKiBEaXNhYmxlIGNvbmZpcm0gYW5kIGNhbmNlbCBidXR0b25zXFxuICovXFxuc3dlZXRBbGVydC5kaXNhYmxlQnV0dG9ucyA9IHN3YWwuZGlzYWJsZUJ1dHRvbnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gIHZhciBtb2RhbCA9IF9zd2VldEFsZXJ0SW5pdGlhbGl6ZSRnZXRNb2RhbCRnZXRPdmVybGF5JGdldElucHV0JHNldEZvY3VzU3R5bGUkb3Blbk1vZGFsJHJlc2V0SW5wdXQkZml4VmVydGljYWxQb3NpdGlvbi5nZXRNb2RhbCgpO1xcbiAgdmFyICRjb25maXJtQnV0dG9uID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNvbmZpcm0nKTtcXG4gIHZhciAkY2FuY2VsQnV0dG9uID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNhbmNlbCcpO1xcbiAgJGNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xcbiAgJGNhbmNlbEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XFxufTtcXG5cXG4vKlxcbiAqIEVuYWJsZSBjb25maXJtIGFuZCBjYW5jZWwgYnV0dG9uc1xcbiAqL1xcbnN3ZWV0QWxlcnQuZW5hYmxlQnV0dG9ucyA9IHN3YWwuZW5hYmxlQnV0dG9ucyA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgdmFyIG1vZGFsID0gX3N3ZWV0QWxlcnRJbml0aWFsaXplJGdldE1vZGFsJGdldE92ZXJsYXkkZ2V0SW5wdXQkc2V0Rm9jdXNTdHlsZSRvcGVuTW9kYWwkcmVzZXRJbnB1dCRmaXhWZXJ0aWNhbFBvc2l0aW9uLmdldE1vZGFsKCk7XFxuICB2YXIgJGNvbmZpcm1CdXR0b24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY29uZmlybScpO1xcbiAgdmFyICRjYW5jZWxCdXR0b24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY2FuY2VsJyk7XFxuICAkY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xcbiAgJGNhbmNlbEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xcbn07XFxuXFxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XFxuICAvLyBUaGUgJ2hhbmRsZS1jbGljaycgbW9kdWxlIHJlcXVpcmVzXFxuICAvLyB0aGF0ICdzd2VldEFsZXJ0JyB3YXMgc2V0IGFzIGdsb2JhbC5cXG4gIHdpbmRvdy5zd2VldEFsZXJ0ID0gd2luZG93LnN3YWwgPSBzd2VldEFsZXJ0O1xcbn0gZWxzZSB7XFxuICBfZXh0ZW5kJGhleFRvUmdiJGlzSUU4JGxvZ1N0ciRjb2xvckx1bWluYW5jZS5sb2dTdHIoJ1N3ZWV0QWxlcnQgaXMgYSBmcm9udGVuZCBtb2R1bGUhJyk7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcblxcbn0se1xcXCIuL21vZHVsZXMvZGVmYXVsdC1wYXJhbXNcXFwiOjIsXFxcIi4vbW9kdWxlcy9oYW5kbGUtY2xpY2tcXFwiOjMsXFxcIi4vbW9kdWxlcy9oYW5kbGUtZG9tXFxcIjo0LFxcXCIuL21vZHVsZXMvaGFuZGxlLWtleVxcXCI6NSxcXFwiLi9tb2R1bGVzL2hhbmRsZS1zd2FsLWRvbVxcXCI6NixcXFwiLi9tb2R1bGVzL3NldC1wYXJhbXNcXFwiOjgsXFxcIi4vbW9kdWxlcy91dGlsc1xcXCI6OX1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbnZhciBkZWZhdWx0UGFyYW1zID0ge1xcbiAgdGl0bGU6ICcnLFxcbiAgdGV4dDogJycsXFxuICB0eXBlOiBudWxsLFxcbiAgYWxsb3dPdXRzaWRlQ2xpY2s6IGZhbHNlLFxcbiAgc2hvd0NvbmZpcm1CdXR0b246IHRydWUsXFxuICBzaG93Q2FuY2VsQnV0dG9uOiBmYWxzZSxcXG4gIGNsb3NlT25Db25maXJtOiB0cnVlLFxcbiAgY2xvc2VPbkNhbmNlbDogdHJ1ZSxcXG4gIGNvbmZpcm1CdXR0b25UZXh0OiAnT0snLFxcbiAgY29uZmlybUJ1dHRvbkNvbG9yOiAnIzhDRDRGNScsXFxuICBjYW5jZWxCdXR0b25UZXh0OiAnQ2FuY2VsJyxcXG4gIGltYWdlVXJsOiBudWxsLFxcbiAgaW1hZ2VTaXplOiBudWxsLFxcbiAgdGltZXI6IG51bGwsXFxuICBjdXN0b21DbGFzczogJycsXFxuICBodG1sOiBmYWxzZSxcXG4gIGFuaW1hdGlvbjogdHJ1ZSxcXG4gIGFsbG93RXNjYXBlS2V5OiB0cnVlLFxcbiAgaW5wdXRUeXBlOiAndGV4dCcsXFxuICBpbnB1dFBsYWNlaG9sZGVyOiAnJyxcXG4gIGlucHV0VmFsdWU6ICcnLFxcbiAgc2hvd0xvYWRlck9uQ29uZmlybTogZmFsc2VcXG59O1xcblxcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlZmF1bHRQYXJhbXM7XFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XFxuXFxufSx7fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9jb2xvckx1bWluYW5jZSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG52YXIgX2dldE1vZGFsID0gcmVxdWlyZSgnLi9oYW5kbGUtc3dhbC1kb20nKTtcXG5cXG52YXIgX2hhc0NsYXNzJGlzRGVzY2VuZGFudCA9IHJlcXVpcmUoJy4vaGFuZGxlLWRvbScpO1xcblxcbi8qXFxuICogVXNlciBjbGlja2VkIG9uIFxcXCJDb25maXJtXFxcIi9cXFwiT0tcXFwiIG9yIFxcXCJDYW5jZWxcXFwiXFxuICovXFxudmFyIGhhbmRsZUJ1dHRvbiA9IGZ1bmN0aW9uIGhhbmRsZUJ1dHRvbihldmVudCwgcGFyYW1zLCBtb2RhbCkge1xcbiAgdmFyIGUgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XFxuICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xcblxcbiAgdmFyIHRhcmdldGVkQ29uZmlybSA9IHRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignY29uZmlybScpICE9PSAtMTtcXG4gIHZhciB0YXJnZXRlZE92ZXJsYXkgPSB0YXJnZXQuY2xhc3NOYW1lLmluZGV4T2YoJ3N3ZWV0LW92ZXJsYXknKSAhPT0gLTE7XFxuICB2YXIgbW9kYWxJc1Zpc2libGUgPSBfaGFzQ2xhc3MkaXNEZXNjZW5kYW50Lmhhc0NsYXNzKG1vZGFsLCAndmlzaWJsZScpO1xcbiAgdmFyIGRvbmVGdW5jdGlvbkV4aXN0cyA9IHBhcmFtcy5kb25lRnVuY3Rpb24gJiYgbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhcy1kb25lLWZ1bmN0aW9uJykgPT09ICd0cnVlJztcXG5cXG4gIC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBjaGFuZ2UgdGhlIGJhY2tncm91bmQtY29sb3Igb2YgdGhlIGNvbmZpcm0gYnV0dG9uIHByb2dyYW1tYXRpY2FsbHksXFxuICAvLyB3ZSBtdXN0IGNhbGN1bGF0ZSB3aGF0IHRoZSBjb2xvciBzaG91bGQgYmUgb24gaG92ZXIvYWN0aXZlXFxuICB2YXIgbm9ybWFsQ29sb3IsIGhvdmVyQ29sb3IsIGFjdGl2ZUNvbG9yO1xcbiAgaWYgKHRhcmdldGVkQ29uZmlybSAmJiBwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XFxuICAgIG5vcm1hbENvbG9yID0gcGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcjtcXG4gICAgaG92ZXJDb2xvciA9IF9jb2xvckx1bWluYW5jZS5jb2xvckx1bWluYW5jZShub3JtYWxDb2xvciwgLTAuMDQpO1xcbiAgICBhY3RpdmVDb2xvciA9IF9jb2xvckx1bWluYW5jZS5jb2xvckx1bWluYW5jZShub3JtYWxDb2xvciwgLTAuMTQpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc2hvdWxkU2V0Q29uZmlybUJ1dHRvbkNvbG9yKGNvbG9yKSB7XFxuICAgIGlmICh0YXJnZXRlZENvbmZpcm0gJiYgcGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcikge1xcbiAgICAgIHRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcXG4gICAgfVxcbiAgfVxcblxcbiAgc3dpdGNoIChlLnR5cGUpIHtcXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcXG4gICAgICBzaG91bGRTZXRDb25maXJtQnV0dG9uQ29sb3IoaG92ZXJDb2xvcik7XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGNhc2UgJ21vdXNlb3V0JzpcXG4gICAgICBzaG91bGRTZXRDb25maXJtQnV0dG9uQ29sb3Iobm9ybWFsQ29sb3IpO1xcbiAgICAgIGJyZWFrO1xcblxcbiAgICBjYXNlICdtb3VzZWRvd24nOlxcbiAgICAgIHNob3VsZFNldENvbmZpcm1CdXR0b25Db2xvcihhY3RpdmVDb2xvcik7XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGNhc2UgJ21vdXNldXAnOlxcbiAgICAgIHNob3VsZFNldENvbmZpcm1CdXR0b25Db2xvcihob3ZlckNvbG9yKTtcXG4gICAgICBicmVhaztcXG5cXG4gICAgY2FzZSAnZm9jdXMnOlxcbiAgICAgIHZhciAkY29uZmlybUJ1dHRvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XFxuICAgICAgdmFyICRjYW5jZWxCdXR0b24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCdidXR0b24uY2FuY2VsJyk7XFxuXFxuICAgICAgaWYgKHRhcmdldGVkQ29uZmlybSkge1xcbiAgICAgICAgJGNhbmNlbEJ1dHRvbi5zdHlsZS5ib3hTaGFkb3cgPSAnbm9uZSc7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICRjb25maXJtQnV0dG9uLnN0eWxlLmJveFNoYWRvdyA9ICdub25lJztcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGNhc2UgJ2NsaWNrJzpcXG4gICAgICB2YXIgY2xpY2tlZE9uTW9kYWwgPSBtb2RhbCA9PT0gdGFyZ2V0O1xcbiAgICAgIHZhciBjbGlja2VkT25Nb2RhbENoaWxkID0gX2hhc0NsYXNzJGlzRGVzY2VuZGFudC5pc0Rlc2NlbmRhbnQobW9kYWwsIHRhcmdldCk7XFxuXFxuICAgICAgLy8gSWdub3JlIGNsaWNrIG91dHNpZGUgaWYgYWxsb3dPdXRzaWRlQ2xpY2sgaXMgZmFsc2VcXG4gICAgICBpZiAoIWNsaWNrZWRPbk1vZGFsICYmICFjbGlja2VkT25Nb2RhbENoaWxkICYmIG1vZGFsSXNWaXNpYmxlICYmICFwYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGFyZ2V0ZWRDb25maXJtICYmIGRvbmVGdW5jdGlvbkV4aXN0cyAmJiBtb2RhbElzVmlzaWJsZSkge1xcbiAgICAgICAgaGFuZGxlQ29uZmlybShtb2RhbCwgcGFyYW1zKTtcXG4gICAgICB9IGVsc2UgaWYgKGRvbmVGdW5jdGlvbkV4aXN0cyAmJiBtb2RhbElzVmlzaWJsZSB8fCB0YXJnZXRlZE92ZXJsYXkpIHtcXG4gICAgICAgIGhhbmRsZUNhbmNlbChtb2RhbCwgcGFyYW1zKTtcXG4gICAgICB9IGVsc2UgaWYgKF9oYXNDbGFzcyRpc0Rlc2NlbmRhbnQuaXNEZXNjZW5kYW50KG1vZGFsLCB0YXJnZXQpICYmIHRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJykge1xcbiAgICAgICAgc3dlZXRBbGVydC5jbG9zZSgpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gIH1cXG59O1xcblxcbi8qXFxuICogIFVzZXIgY2xpY2tlZCBvbiBcXFwiQ29uZmlybVxcXCIvXFxcIk9LXFxcIlxcbiAqL1xcbnZhciBoYW5kbGVDb25maXJtID0gZnVuY3Rpb24gaGFuZGxlQ29uZmlybShtb2RhbCwgcGFyYW1zKSB7XFxuICB2YXIgY2FsbGJhY2tWYWx1ZSA9IHRydWU7XFxuXFxuICBpZiAoX2hhc0NsYXNzJGlzRGVzY2VuZGFudC5oYXNDbGFzcyhtb2RhbCwgJ3Nob3ctaW5wdXQnKSkge1xcbiAgICBjYWxsYmFja1ZhbHVlID0gbW9kYWwucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZTtcXG5cXG4gICAgaWYgKCFjYWxsYmFja1ZhbHVlKSB7XFxuICAgICAgY2FsbGJhY2tWYWx1ZSA9ICcnO1xcbiAgICB9XFxuICB9XFxuXFxuICBwYXJhbXMuZG9uZUZ1bmN0aW9uKGNhbGxiYWNrVmFsdWUpO1xcblxcbiAgaWYgKHBhcmFtcy5jbG9zZU9uQ29uZmlybSkge1xcbiAgICBzd2VldEFsZXJ0LmNsb3NlKCk7XFxuICB9XFxuICAvLyBEaXNhYmxlIGNhbmNlbCBhbmQgY29uZmlybSBidXR0b24gaWYgdGhlIHBhcmFtZXRlciBpcyB0cnVlXFxuICBpZiAocGFyYW1zLnNob3dMb2FkZXJPbkNvbmZpcm0pIHtcXG4gICAgc3dlZXRBbGVydC5kaXNhYmxlQnV0dG9ucygpO1xcbiAgfVxcbn07XFxuXFxuLypcXG4gKiAgVXNlciBjbGlja2VkIG9uIFxcXCJDYW5jZWxcXFwiXFxuICovXFxudmFyIGhhbmRsZUNhbmNlbCA9IGZ1bmN0aW9uIGhhbmRsZUNhbmNlbChtb2RhbCwgcGFyYW1zKSB7XFxuICAvLyBDaGVjayBpZiBjYWxsYmFjayBmdW5jdGlvbiBleHBlY3RzIGEgcGFyYW1ldGVyICh0byB0cmFjayBjYW5jZWwgYWN0aW9ucylcXG4gIHZhciBmdW5jdGlvbkFzU3RyID0gU3RyaW5nKHBhcmFtcy5kb25lRnVuY3Rpb24pLnJlcGxhY2UoL1xcXFxzL2csICcnKTtcXG4gIHZhciBmdW5jdGlvbkhhbmRsZXNDYW5jZWwgPSBmdW5jdGlvbkFzU3RyLnN1YnN0cmluZygwLCA5KSA9PT0gJ2Z1bmN0aW9uKCcgJiYgZnVuY3Rpb25Bc1N0ci5zdWJzdHJpbmcoOSwgMTApICE9PSAnKSc7XFxuXFxuICBpZiAoZnVuY3Rpb25IYW5kbGVzQ2FuY2VsKSB7XFxuICAgIHBhcmFtcy5kb25lRnVuY3Rpb24oZmFsc2UpO1xcbiAgfVxcblxcbiAgaWYgKHBhcmFtcy5jbG9zZU9uQ2FuY2VsKSB7XFxuICAgIHN3ZWV0QWxlcnQuY2xvc2UoKTtcXG4gIH1cXG59O1xcblxcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcXG4gIGhhbmRsZUJ1dHRvbjogaGFuZGxlQnV0dG9uLFxcbiAgaGFuZGxlQ29uZmlybTogaGFuZGxlQ29uZmlybSxcXG4gIGhhbmRsZUNhbmNlbDogaGFuZGxlQ2FuY2VsXFxufTtcXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcXG5cXG59LHtcXFwiLi9oYW5kbGUtZG9tXFxcIjo0LFxcXCIuL2hhbmRsZS1zd2FsLWRvbVxcXCI6NixcXFwiLi91dGlsc1xcXCI6OX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbnZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyAnICsgY2xhc3NOYW1lICsgJyAnKS50ZXN0KCcgJyArIGVsZW0uY2xhc3NOYW1lICsgJyAnKTtcXG59O1xcblxcbnZhciBhZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xcbiAgaWYgKCFoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpKSB7XFxuICAgIGVsZW0uY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcXG4gIH1cXG59O1xcblxcbnZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSkge1xcbiAgdmFyIG5ld0NsYXNzID0gJyAnICsgZWxlbS5jbGFzc05hbWUucmVwbGFjZSgvW1xcXFx0XFxcXHJcXFxcbl0vZywgJyAnKSArICcgJztcXG4gIGlmIChoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpKSB7XFxuICAgIHdoaWxlIChuZXdDbGFzcy5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPj0gMCkge1xcbiAgICAgIG5ld0NsYXNzID0gbmV3Q2xhc3MucmVwbGFjZSgnICcgKyBjbGFzc05hbWUgKyAnICcsICcgJyk7XFxuICAgIH1cXG4gICAgZWxlbS5jbGFzc05hbWUgPSBuZXdDbGFzcy5yZXBsYWNlKC9eXFxcXHMrfFxcXFxzKyQvZywgJycpO1xcbiAgfVxcbn07XFxuXFxudmFyIGVzY2FwZUh0bWwgPSBmdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgZGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cikpO1xcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XFxufTtcXG5cXG52YXIgX3Nob3cgPSBmdW5jdGlvbiBfc2hvdyhlbGVtKSB7XFxuICBlbGVtLnN0eWxlLm9wYWNpdHkgPSAnJztcXG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XFxufTtcXG5cXG52YXIgc2hvdyA9IGZ1bmN0aW9uIHNob3coZWxlbXMpIHtcXG4gIGlmIChlbGVtcyAmJiAhZWxlbXMubGVuZ3RoKSB7XFxuICAgIHJldHVybiBfc2hvdyhlbGVtcyk7XFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XFxuICAgIF9zaG93KGVsZW1zW2ldKTtcXG4gIH1cXG59O1xcblxcbnZhciBfaGlkZSA9IGZ1bmN0aW9uIF9oaWRlKGVsZW0pIHtcXG4gIGVsZW0uc3R5bGUub3BhY2l0eSA9ICcnO1xcbiAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbn07XFxuXFxudmFyIGhpZGUgPSBmdW5jdGlvbiBoaWRlKGVsZW1zKSB7XFxuICBpZiAoZWxlbXMgJiYgIWVsZW1zLmxlbmd0aCkge1xcbiAgICByZXR1cm4gX2hpZGUoZWxlbXMpO1xcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7ICsraSkge1xcbiAgICBfaGlkZShlbGVtc1tpXSk7XFxuICB9XFxufTtcXG5cXG52YXIgaXNEZXNjZW5kYW50ID0gZnVuY3Rpb24gaXNEZXNjZW5kYW50KHBhcmVudCwgY2hpbGQpIHtcXG4gIHZhciBub2RlID0gY2hpbGQucGFyZW50Tm9kZTtcXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XFxuICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn07XFxuXFxudmFyIGdldFRvcE1hcmdpbiA9IGZ1bmN0aW9uIGdldFRvcE1hcmdpbihlbGVtKSB7XFxuICBlbGVtLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XFxuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xcblxcbiAgdmFyIGhlaWdodCA9IGVsZW0uY2xpZW50SGVpZ2h0LFxcbiAgICAgIHBhZGRpbmc7XFxuICBpZiAodHlwZW9mIGdldENvbXB1dGVkU3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgIC8vIElFIDhcXG4gICAgcGFkZGluZyA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZWxlbSkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApO1xcbiAgfSBlbHNlIHtcXG4gICAgcGFkZGluZyA9IHBhcnNlSW50KGVsZW0uY3VycmVudFN0eWxlLnBhZGRpbmcpO1xcbiAgfVxcblxcbiAgZWxlbS5zdHlsZS5sZWZ0ID0gJyc7XFxuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICByZXR1cm4gJy0nICsgcGFyc2VJbnQoKGhlaWdodCArIHBhZGRpbmcpIC8gMikgKyAncHgnO1xcbn07XFxuXFxudmFyIGZhZGVJbiA9IGZ1bmN0aW9uIGZhZGVJbihlbGVtLCBpbnRlcnZhbCkge1xcbiAgaWYgKCtlbGVtLnN0eWxlLm9wYWNpdHkgPCAxKSB7XFxuICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMTY7XFxuICAgIGVsZW0uc3R5bGUub3BhY2l0eSA9IDA7XFxuICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XFxuICAgIHZhciBsYXN0ID0gK25ldyBEYXRlKCk7XFxuICAgIHZhciB0aWNrID0gKGZ1bmN0aW9uIChfdGljaykge1xcbiAgICAgIGZ1bmN0aW9uIHRpY2soKSB7XFxuICAgICAgICByZXR1cm4gX3RpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGljay50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfdGljay50b1N0cmluZygpO1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIHRpY2s7XFxuICAgIH0pKGZ1bmN0aW9uICgpIHtcXG4gICAgICBlbGVtLnN0eWxlLm9wYWNpdHkgPSArZWxlbS5zdHlsZS5vcGFjaXR5ICsgKG5ldyBEYXRlKCkgLSBsYXN0KSAvIDEwMDtcXG4gICAgICBsYXN0ID0gK25ldyBEYXRlKCk7XFxuXFxuICAgICAgaWYgKCtlbGVtLnN0eWxlLm9wYWNpdHkgPCAxKSB7XFxuICAgICAgICBzZXRUaW1lb3V0KHRpY2ssIGludGVydmFsKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICB0aWNrKCk7XFxuICB9XFxuICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvL2ZhbGxiYWNrIElFOFxcbn07XFxuXFxudmFyIGZhZGVPdXQgPSBmdW5jdGlvbiBmYWRlT3V0KGVsZW0sIGludGVydmFsKSB7XFxuICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDE2O1xcbiAgZWxlbS5zdHlsZS5vcGFjaXR5ID0gMTtcXG4gIHZhciBsYXN0ID0gK25ldyBEYXRlKCk7XFxuICB2YXIgdGljayA9IChmdW5jdGlvbiAoX3RpY2syKSB7XFxuICAgIGZ1bmN0aW9uIHRpY2soKSB7XFxuICAgICAgcmV0dXJuIF90aWNrMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuXFxuICAgIHRpY2sudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIF90aWNrMi50b1N0cmluZygpO1xcbiAgICB9O1xcblxcbiAgICByZXR1cm4gdGljaztcXG4gIH0pKGZ1bmN0aW9uICgpIHtcXG4gICAgZWxlbS5zdHlsZS5vcGFjaXR5ID0gK2VsZW0uc3R5bGUub3BhY2l0eSAtIChuZXcgRGF0ZSgpIC0gbGFzdCkgLyAxMDA7XFxuICAgIGxhc3QgPSArbmV3IERhdGUoKTtcXG5cXG4gICAgaWYgKCtlbGVtLnN0eWxlLm9wYWNpdHkgPiAwKSB7XFxuICAgICAgc2V0VGltZW91dCh0aWNrLCBpbnRlcnZhbCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgICB9XFxuICB9KTtcXG4gIHRpY2soKTtcXG59O1xcblxcbnZhciBmaXJlQ2xpY2sgPSBmdW5jdGlvbiBmaXJlQ2xpY2sobm9kZSkge1xcbiAgLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3Lm5vbm9idHJ1c2l2ZS5jb20vMjAxMS8xMS8yOS9wcm9ncmFtYXRpY2FsbHktZmlyZS1jcm9zc2Jyb3dzZXItY2xpY2stZXZlbnQtd2l0aC1qYXZhc2NyaXB0L1xcbiAgLy8gVGhlbiBmaXhlZCBmb3IgdG9kYXkncyBDaHJvbWUgYnJvd3Nlci5cXG4gIGlmICh0eXBlb2YgTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAvLyBVcC10by1kYXRlIGFwcHJvYWNoXFxuICAgIHZhciBtZXZ0ID0gbmV3IE1vdXNlRXZlbnQoJ2NsaWNrJywge1xcbiAgICAgIHZpZXc6IHdpbmRvdyxcXG4gICAgICBidWJibGVzOiBmYWxzZSxcXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXFxuICAgIH0pO1xcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQobWV2dCk7XFxuICB9IGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XFxuICAgIC8vIEZhbGxiYWNrXFxuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcXG4gICAgZXZ0LmluaXRFdmVudCgnY2xpY2snLCBmYWxzZSwgZmFsc2UpO1xcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcXG4gICAgbm9kZS5maXJlRXZlbnQoJ29uY2xpY2snKTtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBub2RlLm9uY2xpY2soKTtcXG4gIH1cXG59O1xcblxcbnZhciBzdG9wRXZlbnRQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIHN0b3BFdmVudFByb3BhZ2F0aW9uKGUpIHtcXG4gIC8vIEluIHBhcnRpY3VsYXIsIG1ha2Ugc3VyZSB0aGUgc3BhY2UgYmFyIGRvZXNuJ3Qgc2Nyb2xsIHRoZSBtYWluIHdpbmRvdy5cXG4gIGlmICh0eXBlb2YgZS5zdG9wUHJvcGFnYXRpb24gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgfSBlbHNlIGlmICh3aW5kb3cuZXZlbnQgJiYgd2luZG93LmV2ZW50Lmhhc093blByb3BlcnR5KCdjYW5jZWxCdWJibGUnKSkge1xcbiAgICB3aW5kb3cuZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcXG4gIH1cXG59O1xcblxcbmV4cG9ydHMuaGFzQ2xhc3MgPSBoYXNDbGFzcztcXG5leHBvcnRzLmFkZENsYXNzID0gYWRkQ2xhc3M7XFxuZXhwb3J0cy5yZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzO1xcbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGVzY2FwZUh0bWw7XFxuZXhwb3J0cy5fc2hvdyA9IF9zaG93O1xcbmV4cG9ydHMuc2hvdyA9IHNob3c7XFxuZXhwb3J0cy5faGlkZSA9IF9oaWRlO1xcbmV4cG9ydHMuaGlkZSA9IGhpZGU7XFxuZXhwb3J0cy5pc0Rlc2NlbmRhbnQgPSBpc0Rlc2NlbmRhbnQ7XFxuZXhwb3J0cy5nZXRUb3BNYXJnaW4gPSBnZXRUb3BNYXJnaW47XFxuZXhwb3J0cy5mYWRlSW4gPSBmYWRlSW47XFxuZXhwb3J0cy5mYWRlT3V0ID0gZmFkZU91dDtcXG5leHBvcnRzLmZpcmVDbGljayA9IGZpcmVDbGljaztcXG5leHBvcnRzLnN0b3BFdmVudFByb3BhZ2F0aW9uID0gc3RvcEV2ZW50UHJvcGFnYXRpb247XFxuXFxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9zdG9wRXZlbnRQcm9wYWdhdGlvbiRmaXJlQ2xpY2sgPSByZXF1aXJlKCcuL2hhbmRsZS1kb20nKTtcXG5cXG52YXIgX3NldEZvY3VzU3R5bGUgPSByZXF1aXJlKCcuL2hhbmRsZS1zd2FsLWRvbScpO1xcblxcbnZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCwgcGFyYW1zLCBtb2RhbCkge1xcbiAgdmFyIGUgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XFxuICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZSB8fCBlLndoaWNoO1xcblxcbiAgdmFyICRva0J1dHRvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jb25maXJtJyk7XFxuICB2YXIgJGNhbmNlbEJ1dHRvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jYW5jZWwnKTtcXG4gIHZhciAkbW9kYWxCdXR0b25zID0gbW9kYWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uW3RhYmluZGV4XScpO1xcblxcbiAgaWYgKFs5LCAxMywgMzIsIDI3XS5pbmRleE9mKGtleUNvZGUpID09PSAtMSkge1xcbiAgICAvLyBEb24ndCBkbyB3b3JrIG9uIGtleXMgd2UgZG9uJ3QgY2FyZSBhYm91dC5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmFyICR0YXJnZXRFbGVtZW50ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xcblxcbiAgdmFyIGJ0bkluZGV4ID0gLTE7IC8vIEZpbmQgdGhlIGJ1dHRvbiAtIG5vdGUsIHRoaXMgaXMgYSBub2RlbGlzdCwgbm90IGFuIGFycmF5LlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAkbW9kYWxCdXR0b25zLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmICgkdGFyZ2V0RWxlbWVudCA9PT0gJG1vZGFsQnV0dG9uc1tpXSkge1xcbiAgICAgIGJ0bkluZGV4ID0gaTtcXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGtleUNvZGUgPT09IDkpIHtcXG4gICAgLy8gVEFCXFxuICAgIGlmIChidG5JbmRleCA9PT0gLTEpIHtcXG4gICAgICAvLyBObyBidXR0b24gZm9jdXNlZC4gSnVtcCB0byB0aGUgY29uZmlybSBidXR0b24uXFxuICAgICAgJHRhcmdldEVsZW1lbnQgPSAkb2tCdXR0b247XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQ3ljbGUgdG8gdGhlIG5leHQgYnV0dG9uXFxuICAgICAgaWYgKGJ0bkluZGV4ID09PSAkbW9kYWxCdXR0b25zLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgICR0YXJnZXRFbGVtZW50ID0gJG1vZGFsQnV0dG9uc1swXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJHRhcmdldEVsZW1lbnQgPSAkbW9kYWxCdXR0b25zW2J0bkluZGV4ICsgMV07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9zdG9wRXZlbnRQcm9wYWdhdGlvbiRmaXJlQ2xpY2suc3RvcEV2ZW50UHJvcGFnYXRpb24oZSk7XFxuICAgICR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XFxuXFxuICAgIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XFxuICAgICAgX3NldEZvY3VzU3R5bGUuc2V0Rm9jdXNTdHlsZSgkdGFyZ2V0RWxlbWVudCwgcGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcik7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChrZXlDb2RlID09PSAxMykge1xcbiAgICAgIGlmICgkdGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnKSB7XFxuICAgICAgICAkdGFyZ2V0RWxlbWVudCA9ICRva0J1dHRvbjtcXG4gICAgICAgICRva0J1dHRvbi5mb2N1cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYnRuSW5kZXggPT09IC0xKSB7XFxuICAgICAgICAvLyBFTlRFUi9TUEFDRSBjbGlja2VkIG91dHNpZGUgb2YgYSBidXR0b24uXFxuICAgICAgICAkdGFyZ2V0RWxlbWVudCA9ICRva0J1dHRvbjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gRG8gbm90aGluZyAtIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgaXQuXFxuICAgICAgICAkdGFyZ2V0RWxlbWVudCA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gMjcgJiYgcGFyYW1zLmFsbG93RXNjYXBlS2V5ID09PSB0cnVlKSB7XFxuICAgICAgJHRhcmdldEVsZW1lbnQgPSAkY2FuY2VsQnV0dG9uO1xcbiAgICAgIF9zdG9wRXZlbnRQcm9wYWdhdGlvbiRmaXJlQ2xpY2suZmlyZUNsaWNrKCR0YXJnZXRFbGVtZW50LCBlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBGYWxsYmFjayAtIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgaXQuXFxuICAgICAgJHRhcmdldEVsZW1lbnQgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGhhbmRsZUtleURvd247XFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XFxuXFxufSx7XFxcIi4vaGFuZGxlLWRvbVxcXCI6NCxcXFwiLi9oYW5kbGUtc3dhbC1kb21cXFwiOjZ9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9oZXhUb1JnYiA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG52YXIgX3JlbW92ZUNsYXNzJGdldFRvcE1hcmdpbiRmYWRlSW4kc2hvdyRhZGRDbGFzcyA9IHJlcXVpcmUoJy4vaGFuZGxlLWRvbScpO1xcblxcbnZhciBfZGVmYXVsdFBhcmFtcyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1wYXJhbXMnKTtcXG5cXG52YXIgX2RlZmF1bHRQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2RlZmF1bHRQYXJhbXMpO1xcblxcbi8qXFxuICogQWRkIG1vZGFsICsgb3ZlcmxheSB0byBET01cXG4gKi9cXG5cXG52YXIgX2luamVjdGVkSFRNTCA9IHJlcXVpcmUoJy4vaW5qZWN0ZWQtaHRtbCcpO1xcblxcbnZhciBfaW5qZWN0ZWRIVE1MMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmplY3RlZEhUTUwpO1xcblxcbnZhciBtb2RhbENsYXNzID0gJy5zd2VldC1hbGVydCc7XFxudmFyIG92ZXJsYXlDbGFzcyA9ICcuc3dlZXQtb3ZlcmxheSc7XFxuXFxudmFyIHN3ZWV0QWxlcnRJbml0aWFsaXplID0gZnVuY3Rpb24gc3dlZXRBbGVydEluaXRpYWxpemUoKSB7XFxuICB2YXIgc3dlZXRXcmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICBzd2VldFdyYXAuaW5uZXJIVE1MID0gX2luamVjdGVkSFRNTDJbJ2RlZmF1bHQnXTtcXG5cXG4gIC8vIEFwcGVuZCBlbGVtZW50cyB0byBib2R5XFxuICB3aGlsZSAoc3dlZXRXcmFwLmZpcnN0Q2hpbGQpIHtcXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzd2VldFdyYXAuZmlyc3RDaGlsZCk7XFxuICB9XFxufTtcXG5cXG4vKlxcbiAqIEdldCBET00gZWxlbWVudCBvZiBtb2RhbFxcbiAqL1xcbnZhciBnZXRNb2RhbCA9IChmdW5jdGlvbiAoX2dldE1vZGFsKSB7XFxuICBmdW5jdGlvbiBnZXRNb2RhbCgpIHtcXG4gICAgcmV0dXJuIF9nZXRNb2RhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgZ2V0TW9kYWwudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBfZ2V0TW9kYWwudG9TdHJpbmcoKTtcXG4gIH07XFxuXFxuICByZXR1cm4gZ2V0TW9kYWw7XFxufSkoZnVuY3Rpb24gKCkge1xcbiAgdmFyICRtb2RhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobW9kYWxDbGFzcyk7XFxuXFxuICBpZiAoISRtb2RhbCkge1xcbiAgICBzd2VldEFsZXJ0SW5pdGlhbGl6ZSgpO1xcbiAgICAkbW9kYWwgPSBnZXRNb2RhbCgpO1xcbiAgfVxcblxcbiAgcmV0dXJuICRtb2RhbDtcXG59KTtcXG5cXG4vKlxcbiAqIEdldCBET00gZWxlbWVudCBvZiBpbnB1dCAoaW4gbW9kYWwpXFxuICovXFxudmFyIGdldElucHV0ID0gZnVuY3Rpb24gZ2V0SW5wdXQoKSB7XFxuICB2YXIgJG1vZGFsID0gZ2V0TW9kYWwoKTtcXG4gIGlmICgkbW9kYWwpIHtcXG4gICAgcmV0dXJuICRtb2RhbC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xcbiAgfVxcbn07XFxuXFxuLypcXG4gKiBHZXQgRE9NIGVsZW1lbnQgb2Ygb3ZlcmxheVxcbiAqL1xcbnZhciBnZXRPdmVybGF5ID0gZnVuY3Rpb24gZ2V0T3ZlcmxheSgpIHtcXG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG92ZXJsYXlDbGFzcyk7XFxufTtcXG5cXG4vKlxcbiAqIEFkZCBib3gtc2hhZG93IHN0eWxlIHRvIGJ1dHRvbiAoZGVwZW5kaW5nIG9uIGl0cyBjaG9zZW4gYmctY29sb3IpXFxuICovXFxudmFyIHNldEZvY3VzU3R5bGUgPSBmdW5jdGlvbiBzZXRGb2N1c1N0eWxlKCRidXR0b24sIGJnQ29sb3IpIHtcXG4gIHZhciByZ2JDb2xvciA9IF9oZXhUb1JnYi5oZXhUb1JnYihiZ0NvbG9yKTtcXG4gICRidXR0b24uc3R5bGUuYm94U2hhZG93ID0gJzAgMCAycHggcmdiYSgnICsgcmdiQ29sb3IgKyAnLCAwLjgpLCBpbnNldCAwIDAgMCAxcHggcmdiYSgwLCAwLCAwLCAwLjA1KSc7XFxufTtcXG5cXG4vKlxcbiAqIEFuaW1hdGlvbiB3aGVuIG9wZW5pbmcgbW9kYWxcXG4gKi9cXG52YXIgb3Blbk1vZGFsID0gZnVuY3Rpb24gb3Blbk1vZGFsKGNhbGxiYWNrKSB7XFxuICB2YXIgJG1vZGFsID0gZ2V0TW9kYWwoKTtcXG4gIF9yZW1vdmVDbGFzcyRnZXRUb3BNYXJnaW4kZmFkZUluJHNob3ckYWRkQ2xhc3MuZmFkZUluKGdldE92ZXJsYXkoKSwgMTApO1xcbiAgX3JlbW92ZUNsYXNzJGdldFRvcE1hcmdpbiRmYWRlSW4kc2hvdyRhZGRDbGFzcy5zaG93KCRtb2RhbCk7XFxuICBfcmVtb3ZlQ2xhc3MkZ2V0VG9wTWFyZ2luJGZhZGVJbiRzaG93JGFkZENsYXNzLmFkZENsYXNzKCRtb2RhbCwgJ3Nob3dTd2VldEFsZXJ0Jyk7XFxuICBfcmVtb3ZlQ2xhc3MkZ2V0VG9wTWFyZ2luJGZhZGVJbiRzaG93JGFkZENsYXNzLnJlbW92ZUNsYXNzKCRtb2RhbCwgJ2hpZGVTd2VldEFsZXJ0Jyk7XFxuXFxuICB3aW5kb3cucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG4gIHZhciAkb2tCdXR0b24gPSAkbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNvbmZpcm0nKTtcXG4gICRva0J1dHRvbi5mb2N1cygpO1xcblxcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgIF9yZW1vdmVDbGFzcyRnZXRUb3BNYXJnaW4kZmFkZUluJHNob3ckYWRkQ2xhc3MuYWRkQ2xhc3MoJG1vZGFsLCAndmlzaWJsZScpO1xcbiAgfSwgNTAwKTtcXG5cXG4gIHZhciB0aW1lciA9ICRtb2RhbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZXInKTtcXG5cXG4gIGlmICh0aW1lciAhPT0gJ251bGwnICYmIHRpbWVyICE9PSAnJykge1xcbiAgICB2YXIgdGltZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xcbiAgICAkbW9kYWwudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBkb25lRnVuY3Rpb25FeGlzdHMgPSAodGltZXJDYWxsYmFjayB8fCBudWxsKSAmJiAkbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWhhcy1kb25lLWZ1bmN0aW9uJykgPT09ICd0cnVlJztcXG4gICAgICBpZiAoZG9uZUZ1bmN0aW9uRXhpc3RzKSB7XFxuICAgICAgICB0aW1lckNhbGxiYWNrKG51bGwpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzd2VldEFsZXJ0LmNsb3NlKCk7XFxuICAgICAgfVxcbiAgICB9LCB0aW1lcik7XFxuICB9XFxufTtcXG5cXG4vKlxcbiAqIFJlc2V0IHRoZSBzdHlsaW5nIG9mIHRoZSBpbnB1dFxcbiAqIChmb3IgZXhhbXBsZSBpZiBlcnJvcnMgaGF2ZSBiZWVuIHNob3duKVxcbiAqL1xcbnZhciByZXNldElucHV0ID0gZnVuY3Rpb24gcmVzZXRJbnB1dCgpIHtcXG4gIHZhciAkbW9kYWwgPSBnZXRNb2RhbCgpO1xcbiAgdmFyICRpbnB1dCA9IGdldElucHV0KCk7XFxuXFxuICBfcmVtb3ZlQ2xhc3MkZ2V0VG9wTWFyZ2luJGZhZGVJbiRzaG93JGFkZENsYXNzLnJlbW92ZUNsYXNzKCRtb2RhbCwgJ3Nob3ctaW5wdXQnKTtcXG4gICRpbnB1dC52YWx1ZSA9IF9kZWZhdWx0UGFyYW1zMlsnZGVmYXVsdCddLmlucHV0VmFsdWU7XFxuICAkaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgX2RlZmF1bHRQYXJhbXMyWydkZWZhdWx0J10uaW5wdXRUeXBlKTtcXG4gICRpbnB1dC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgX2RlZmF1bHRQYXJhbXMyWydkZWZhdWx0J10uaW5wdXRQbGFjZWhvbGRlcik7XFxuXFxuICByZXNldElucHV0RXJyb3IoKTtcXG59O1xcblxcbnZhciByZXNldElucHV0RXJyb3IgPSBmdW5jdGlvbiByZXNldElucHV0RXJyb3IoZXZlbnQpIHtcXG4gIC8vIElmIHByZXNzIGVudGVyID0+IGlnbm9yZVxcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHZhciAkbW9kYWwgPSBnZXRNb2RhbCgpO1xcblxcbiAgdmFyICRlcnJvckljb24gPSAkbW9kYWwucXVlcnlTZWxlY3RvcignLnNhLWlucHV0LWVycm9yJyk7XFxuICBfcmVtb3ZlQ2xhc3MkZ2V0VG9wTWFyZ2luJGZhZGVJbiRzaG93JGFkZENsYXNzLnJlbW92ZUNsYXNzKCRlcnJvckljb24sICdzaG93Jyk7XFxuXFxuICB2YXIgJGVycm9yQ29udGFpbmVyID0gJG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5zYS1lcnJvci1jb250YWluZXInKTtcXG4gIF9yZW1vdmVDbGFzcyRnZXRUb3BNYXJnaW4kZmFkZUluJHNob3ckYWRkQ2xhc3MucmVtb3ZlQ2xhc3MoJGVycm9yQ29udGFpbmVyLCAnc2hvdycpO1xcbn07XFxuXFxuLypcXG4gKiBTZXQgXFxcIm1hcmdpbi10b3BcXFwiLXByb3BlcnR5IG9uIG1vZGFsIGJhc2VkIG9uIGl0cyBjb21wdXRlZCBoZWlnaHRcXG4gKi9cXG52YXIgZml4VmVydGljYWxQb3NpdGlvbiA9IGZ1bmN0aW9uIGZpeFZlcnRpY2FsUG9zaXRpb24oKSB7XFxuICB2YXIgJG1vZGFsID0gZ2V0TW9kYWwoKTtcXG4gICRtb2RhbC5zdHlsZS5tYXJnaW5Ub3AgPSBfcmVtb3ZlQ2xhc3MkZ2V0VG9wTWFyZ2luJGZhZGVJbiRzaG93JGFkZENsYXNzLmdldFRvcE1hcmdpbihnZXRNb2RhbCgpKTtcXG59O1xcblxcbmV4cG9ydHMuc3dlZXRBbGVydEluaXRpYWxpemUgPSBzd2VldEFsZXJ0SW5pdGlhbGl6ZTtcXG5leHBvcnRzLmdldE1vZGFsID0gZ2V0TW9kYWw7XFxuZXhwb3J0cy5nZXRPdmVybGF5ID0gZ2V0T3ZlcmxheTtcXG5leHBvcnRzLmdldElucHV0ID0gZ2V0SW5wdXQ7XFxuZXhwb3J0cy5zZXRGb2N1c1N0eWxlID0gc2V0Rm9jdXNTdHlsZTtcXG5leHBvcnRzLm9wZW5Nb2RhbCA9IG9wZW5Nb2RhbDtcXG5leHBvcnRzLnJlc2V0SW5wdXQgPSByZXNldElucHV0O1xcbmV4cG9ydHMucmVzZXRJbnB1dEVycm9yID0gcmVzZXRJbnB1dEVycm9yO1xcbmV4cG9ydHMuZml4VmVydGljYWxQb3NpdGlvbiA9IGZpeFZlcnRpY2FsUG9zaXRpb247XFxuXFxufSx7XFxcIi4vZGVmYXVsdC1wYXJhbXNcXFwiOjIsXFxcIi4vaGFuZGxlLWRvbVxcXCI6NCxcXFwiLi9pbmplY3RlZC1odG1sXFxcIjo3LFxcXCIuL3V0aWxzXFxcIjo5fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxudmFyIGluamVjdGVkSFRNTCA9XFxuXFxuLy8gRGFyayBvdmVybGF5XFxuXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJzd2VldC1vdmVybGF5XFxcXFxcXCIgdGFiSW5kZXg9XFxcXFxcXCItMVxcXFxcXFwiPjwvZGl2PlxcXCIgK1xcblxcbi8vIE1vZGFsXFxuXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJzd2VldC1hbGVydFxcXFxcXFwiPlxcXCIgK1xcblxcbi8vIEVycm9yIGljb25cXG5cXFwiPGRpdiBjbGFzcz1cXFxcXFxcInNhLWljb24gc2EtZXJyb3JcXFxcXFxcIj5cXFxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXFxcXFwic2EteC1tYXJrXFxcXFxcXCI+XFxcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcXFwic2EtbGluZSBzYS1sZWZ0XFxcXFxcXCI+PC9zcGFuPlxcXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXFxcInNhLWxpbmUgc2EtcmlnaHRcXFxcXFxcIj48L3NwYW4+XFxcXG4gICAgICA8L3NwYW4+XFxcXG4gICAgPC9kaXY+XFxcIiArXFxuXFxuLy8gV2FybmluZyBpY29uXFxuXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJzYS1pY29uIHNhLXdhcm5pbmdcXFxcXFxcIj5cXFxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXFxcXFwic2EtYm9keVxcXFxcXFwiPjwvc3Bhbj5cXFxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXFxcXFwic2EtZG90XFxcXFxcXCI+PC9zcGFuPlxcXFxuICAgIDwvZGl2PlxcXCIgK1xcblxcbi8vIEluZm8gaWNvblxcblxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwic2EtaWNvbiBzYS1pbmZvXFxcXFxcXCI+PC9kaXY+XFxcIiArXFxuXFxuLy8gU3VjY2VzcyBpY29uXFxuXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJzYS1pY29uIHNhLXN1Y2Nlc3NcXFxcXFxcIj5cXFxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXFxcXFwic2EtbGluZSBzYS10aXBcXFxcXFxcIj48L3NwYW4+XFxcXG4gICAgICA8c3BhbiBjbGFzcz1cXFxcXFxcInNhLWxpbmUgc2EtbG9uZ1xcXFxcXFwiPjwvc3Bhbj5cXFxcblxcXFxuICAgICAgPGRpdiBjbGFzcz1cXFxcXFxcInNhLXBsYWNlaG9sZGVyXFxcXFxcXCI+PC9kaXY+XFxcXG4gICAgICA8ZGl2IGNsYXNzPVxcXFxcXFwic2EtZml4XFxcXFxcXCI+PC9kaXY+XFxcXG4gICAgPC9kaXY+XFxcIiArIFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwic2EtaWNvbiBzYS1jdXN0b21cXFxcXFxcIj48L2Rpdj5cXFwiICtcXG5cXG4vLyBUaXRsZSwgdGV4dCBhbmQgaW5wdXRcXG5cXFwiPGgyPlRpdGxlPC9oMj5cXFxcbiAgICA8cD5UZXh0PC9wPlxcXFxuICAgIDxmaWVsZHNldD5cXFxcbiAgICAgIDxpbnB1dCB0eXBlPVxcXFxcXFwidGV4dFxcXFxcXFwiIHRhYkluZGV4PVxcXFxcXFwiM1xcXFxcXFwiIC8+XFxcXG4gICAgICA8ZGl2IGNsYXNzPVxcXFxcXFwic2EtaW5wdXQtZXJyb3JcXFxcXFxcIj48L2Rpdj5cXFxcbiAgICA8L2ZpZWxkc2V0PlxcXCIgK1xcblxcbi8vIElucHV0IGVycm9yc1xcblxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwic2EtZXJyb3ItY29udGFpbmVyXFxcXFxcXCI+XFxcXG4gICAgICA8ZGl2IGNsYXNzPVxcXFxcXFwiaWNvblxcXFxcXFwiPiE8L2Rpdj5cXFxcbiAgICAgIDxwPk5vdCB2YWxpZCE8L3A+XFxcXG4gICAgPC9kaXY+XFxcIiArXFxuXFxuLy8gQ2FuY2VsIGFuZCBjb25maXJtIGJ1dHRvbnNcXG5cXFwiPGRpdiBjbGFzcz1cXFxcXFxcInNhLWJ1dHRvbi1jb250YWluZXJcXFxcXFxcIj5cXFxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcXFxcXCJjYW5jZWxcXFxcXFxcIiB0YWJJbmRleD1cXFxcXFxcIjJcXFxcXFxcIj5DYW5jZWw8L2J1dHRvbj5cXFxcbiAgICAgIDxkaXYgY2xhc3M9XFxcXFxcXCJzYS1jb25maXJtLWJ1dHRvbi1jb250YWluZXJcXFxcXFxcIj5cXFxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFxcXFxcImNvbmZpcm1cXFxcXFxcIiB0YWJJbmRleD1cXFxcXFxcIjFcXFxcXFxcIj5PSzwvYnV0dG9uPlxcXCIgK1xcblxcbi8vIExvYWRpbmcgYW5pbWF0aW9uXFxuXFxcIjxkaXYgY2xhc3M9XFxcXFxcXCJsYS1iYWxsLWZhbGxcXFxcXFxcIj5cXFxcbiAgICAgICAgICA8ZGl2PjwvZGl2PlxcXFxuICAgICAgICAgIDxkaXY+PC9kaXY+XFxcXG4gICAgICAgICAgPGRpdj48L2Rpdj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICA8L2Rpdj5cXFxcbiAgICA8L2Rpdj5cXFwiICtcXG5cXG4vLyBFbmQgb2YgbW9kYWxcXG5cXFwiPC9kaXY+XFxcIjtcXG5cXG5leHBvcnRzW1xcXCJkZWZhdWx0XFxcIl0gPSBpbmplY3RlZEhUTUw7XFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1xcXCJkZWZhdWx0XFxcIl07XFxuXFxufSx7fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9pc0lFOCA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG52YXIgX2dldE1vZGFsJGdldElucHV0JHNldEZvY3VzU3R5bGUgPSByZXF1aXJlKCcuL2hhbmRsZS1zd2FsLWRvbScpO1xcblxcbnZhciBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUgPSByZXF1aXJlKCcuL2hhbmRsZS1kb20nKTtcXG5cXG52YXIgYWxlcnRUeXBlcyA9IFsnZXJyb3InLCAnd2FybmluZycsICdpbmZvJywgJ3N1Y2Nlc3MnLCAnaW5wdXQnLCAncHJvbXB0J107XFxuXFxuLypcXG4gKiBTZXQgdHlwZSwgdGV4dCBhbmQgYWN0aW9ucyBvbiBtb2RhbFxcbiAqL1xcbnZhciBzZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gc2V0UGFyYW1ldGVycyhwYXJhbXMpIHtcXG4gIHZhciBtb2RhbCA9IF9nZXRNb2RhbCRnZXRJbnB1dCRzZXRGb2N1c1N0eWxlLmdldE1vZGFsKCk7XFxuXFxuICB2YXIgJHRpdGxlID0gbW9kYWwucXVlcnlTZWxlY3RvcignaDInKTtcXG4gIHZhciAkdGV4dCA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJ3AnKTtcXG4gIHZhciAkY2FuY2VsQnRuID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNhbmNlbCcpO1xcbiAgdmFyICRjb25maXJtQnRuID0gbW9kYWwucXVlcnlTZWxlY3RvcignYnV0dG9uLmNvbmZpcm0nKTtcXG5cXG4gIC8qXFxuICAgKiBUaXRsZVxcbiAgICovXFxuICAkdGl0bGUuaW5uZXJIVE1MID0gcGFyYW1zLmh0bWwgPyBwYXJhbXMudGl0bGUgOiBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuZXNjYXBlSHRtbChwYXJhbXMudGl0bGUpLnNwbGl0KCdcXFxcbicpLmpvaW4oJzxicj4nKTtcXG5cXG4gIC8qXFxuICAgKiBUZXh0XFxuICAgKi9cXG4gICR0ZXh0LmlubmVySFRNTCA9IHBhcmFtcy5odG1sID8gcGFyYW1zLnRleHQgOiBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuZXNjYXBlSHRtbChwYXJhbXMudGV4dCB8fCAnJykuc3BsaXQoJ1xcXFxuJykuam9pbignPGJyPicpO1xcbiAgaWYgKHBhcmFtcy50ZXh0KSBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuc2hvdygkdGV4dCk7XFxuXFxuICAvKlxcbiAgICogQ3VzdG9tIGNsYXNzXFxuICAgKi9cXG4gIGlmIChwYXJhbXMuY3VzdG9tQ2xhc3MpIHtcXG4gICAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlLmFkZENsYXNzKG1vZGFsLCBwYXJhbXMuY3VzdG9tQ2xhc3MpO1xcbiAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY3VzdG9tLWNsYXNzJywgcGFyYW1zLmN1c3RvbUNsYXNzKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEZpbmQgcHJldmlvdXNseSBzZXQgY2xhc3NlcyBhbmQgcmVtb3ZlIHRoZW1cXG4gICAgdmFyIGN1c3RvbUNsYXNzID0gbW9kYWwuZ2V0QXR0cmlidXRlKCdkYXRhLWN1c3RvbS1jbGFzcycpO1xcbiAgICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUucmVtb3ZlQ2xhc3MobW9kYWwsIGN1c3RvbUNsYXNzKTtcXG4gICAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWN1c3RvbS1jbGFzcycsICcnKTtcXG4gIH1cXG5cXG4gIC8qXFxuICAgKiBJY29uXFxuICAgKi9cXG4gIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5oaWRlKG1vZGFsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zYS1pY29uJykpO1xcblxcbiAgaWYgKHBhcmFtcy50eXBlICYmICFfaXNJRTguaXNJRTgoKSkge1xcbiAgICB2YXIgX3JldCA9IChmdW5jdGlvbiAoKSB7XFxuXFxuICAgICAgdmFyIHZhbGlkVHlwZSA9IGZhbHNlO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxlcnRUeXBlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09PSBhbGVydFR5cGVzW2ldKSB7XFxuICAgICAgICAgIHZhbGlkVHlwZSA9IHRydWU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXZhbGlkVHlwZSkge1xcbiAgICAgICAgbG9nU3RyKCdVbmtub3duIGFsZXJ0IHR5cGU6ICcgKyBwYXJhbXMudHlwZSk7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICB2OiBmYWxzZVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHR5cGVzV2l0aEljb25zID0gWydzdWNjZXNzJywgJ2Vycm9yJywgJ3dhcm5pbmcnLCAnaW5mbyddO1xcbiAgICAgIHZhciAkaWNvbiA9IHVuZGVmaW5lZDtcXG5cXG4gICAgICBpZiAodHlwZXNXaXRoSWNvbnMuaW5kZXhPZihwYXJhbXMudHlwZSkgIT09IC0xKSB7XFxuICAgICAgICAkaWNvbiA9IG1vZGFsLnF1ZXJ5U2VsZWN0b3IoJy5zYS1pY29uLicgKyAnc2EtJyArIHBhcmFtcy50eXBlKTtcXG4gICAgICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5zaG93KCRpY29uKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyICRpbnB1dCA9IF9nZXRNb2RhbCRnZXRJbnB1dCRzZXRGb2N1c1N0eWxlLmdldElucHV0KCk7XFxuXFxuICAgICAgLy8gQW5pbWF0ZSBpY29uXFxuICAgICAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xcblxcbiAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XFxuICAgICAgICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5hZGRDbGFzcygkaWNvbiwgJ2FuaW1hdGUnKTtcXG4gICAgICAgICAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlLmFkZENsYXNzKCRpY29uLnF1ZXJ5U2VsZWN0b3IoJy5zYS10aXAnKSwgJ2FuaW1hdGVTdWNjZXNzVGlwJyk7XFxuICAgICAgICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5hZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtbG9uZycpLCAnYW5pbWF0ZVN1Y2Nlc3NMb25nJyk7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAnZXJyb3InOlxcbiAgICAgICAgICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuYWRkQ2xhc3MoJGljb24sICdhbmltYXRlRXJyb3JJY29uJyk7XFxuICAgICAgICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5hZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EteC1tYXJrJyksICdhbmltYXRlWE1hcmsnKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICd3YXJuaW5nJzpcXG4gICAgICAgICAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlLmFkZENsYXNzKCRpY29uLCAncHVsc2VXYXJuaW5nJyk7XFxuICAgICAgICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5hZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtYm9keScpLCAncHVsc2VXYXJuaW5nSW5zJyk7XFxuICAgICAgICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5hZGRDbGFzcygkaWNvbi5xdWVyeVNlbGVjdG9yKCcuc2EtZG90JyksICdwdWxzZVdhcm5pbmdJbnMnKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdpbnB1dCc6XFxuICAgICAgICBjYXNlICdwcm9tcHQnOlxcbiAgICAgICAgICAkaW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgcGFyYW1zLmlucHV0VHlwZSk7XFxuICAgICAgICAgICRpbnB1dC52YWx1ZSA9IHBhcmFtcy5pbnB1dFZhbHVlO1xcbiAgICAgICAgICAkaW5wdXQuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKTtcXG4gICAgICAgICAgX2hhc0NsYXNzJGFkZENsYXNzJHJlbW92ZUNsYXNzJGVzY2FwZUh0bWwkX3Nob3ckc2hvdyRfaGlkZSRoaWRlLmFkZENsYXNzKG1vZGFsLCAnc2hvdy1pbnB1dCcpO1xcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkaW5wdXQuZm9jdXMoKTtcXG4gICAgICAgICAgICAkaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBzd2FsLnJlc2V0SW5wdXRFcnJvcik7XFxuICAgICAgICAgIH0sIDQwMCk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfSkoKTtcXG5cXG4gICAgaWYgKHR5cGVvZiBfcmV0ID09PSAnb2JqZWN0Jykge1xcbiAgICAgIHJldHVybiBfcmV0LnY7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qXFxuICAgKiBDdXN0b20gaW1hZ2VcXG4gICAqL1xcbiAgaWYgKHBhcmFtcy5pbWFnZVVybCkge1xcbiAgICB2YXIgJGN1c3RvbUljb24gPSBtb2RhbC5xdWVyeVNlbGVjdG9yKCcuc2EtaWNvbi5zYS1jdXN0b20nKTtcXG5cXG4gICAgJGN1c3RvbUljb24uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgcGFyYW1zLmltYWdlVXJsICsgJyknO1xcbiAgICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuc2hvdygkY3VzdG9tSWNvbik7XFxuXFxuICAgIHZhciBfaW1nV2lkdGggPSA4MDtcXG4gICAgdmFyIF9pbWdIZWlnaHQgPSA4MDtcXG5cXG4gICAgaWYgKHBhcmFtcy5pbWFnZVNpemUpIHtcXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHBhcmFtcy5pbWFnZVNpemUudG9TdHJpbmcoKS5zcGxpdCgneCcpO1xcbiAgICAgIHZhciBpbWdXaWR0aCA9IGRpbWVuc2lvbnNbMF07XFxuICAgICAgdmFyIGltZ0hlaWdodCA9IGRpbWVuc2lvbnNbMV07XFxuXFxuICAgICAgaWYgKCFpbWdXaWR0aCB8fCAhaW1nSGVpZ2h0KSB7XFxuICAgICAgICBsb2dTdHIoJ1BhcmFtZXRlciBpbWFnZVNpemUgZXhwZWN0cyB2YWx1ZSB3aXRoIGZvcm1hdCBXSURUSHhIRUlHSFQsIGdvdCAnICsgcGFyYW1zLmltYWdlU2l6ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIF9pbWdXaWR0aCA9IGltZ1dpZHRoO1xcbiAgICAgICAgX2ltZ0hlaWdodCA9IGltZ0hlaWdodDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgJGN1c3RvbUljb24uc2V0QXR0cmlidXRlKCdzdHlsZScsICRjdXN0b21JY29uLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSArICd3aWR0aDonICsgX2ltZ1dpZHRoICsgJ3B4OyBoZWlnaHQ6JyArIF9pbWdIZWlnaHQgKyAncHgnKTtcXG4gIH1cXG5cXG4gIC8qXFxuICAgKiBTaG93IGNhbmNlbCBidXR0b24/XFxuICAgKi9cXG4gIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1oYXMtY2FuY2VsLWJ1dHRvbicsIHBhcmFtcy5zaG93Q2FuY2VsQnV0dG9uKTtcXG4gIGlmIChwYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbikge1xcbiAgICAkY2FuY2VsQnRuLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcXG4gIH0gZWxzZSB7XFxuICAgIF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5oaWRlKCRjYW5jZWxCdG4pO1xcbiAgfVxcblxcbiAgLypcXG4gICAqIFNob3cgY29uZmlybSBidXR0b24/XFxuICAgKi9cXG4gIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1oYXMtY29uZmlybS1idXR0b24nLCBwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24pO1xcbiAgaWYgKHBhcmFtcy5zaG93Q29uZmlybUJ1dHRvbikge1xcbiAgICAkY29uZmlybUJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XFxuICB9IGVsc2Uge1xcbiAgICBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuaGlkZSgkY29uZmlybUJ0bik7XFxuICB9XFxuXFxuICAvKlxcbiAgICogQ3VzdG9tIHRleHQgb24gY2FuY2VsL2NvbmZpcm0gYnV0dG9uc1xcbiAgICovXFxuICBpZiAocGFyYW1zLmNhbmNlbEJ1dHRvblRleHQpIHtcXG4gICAgJGNhbmNlbEJ0bi5pbm5lckhUTUwgPSBfaGFzQ2xhc3MkYWRkQ2xhc3MkcmVtb3ZlQ2xhc3MkZXNjYXBlSHRtbCRfc2hvdyRzaG93JF9oaWRlJGhpZGUuZXNjYXBlSHRtbChwYXJhbXMuY2FuY2VsQnV0dG9uVGV4dCk7XFxuICB9XFxuICBpZiAocGFyYW1zLmNvbmZpcm1CdXR0b25UZXh0KSB7XFxuICAgICRjb25maXJtQnRuLmlubmVySFRNTCA9IF9oYXNDbGFzcyRhZGRDbGFzcyRyZW1vdmVDbGFzcyRlc2NhcGVIdG1sJF9zaG93JHNob3ckX2hpZGUkaGlkZS5lc2NhcGVIdG1sKHBhcmFtcy5jb25maXJtQnV0dG9uVGV4dCk7XFxuICB9XFxuXFxuICAvKlxcbiAgICogQ3VzdG9tIGNvbG9yIG9uIGNvbmZpcm0gYnV0dG9uXFxuICAgKi9cXG4gIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XFxuICAgIC8vIFNldCBjb25maXJtIGJ1dHRvbiB0byBzZWxlY3RlZCBiYWNrZ3JvdW5kIGNvbG9yXFxuICAgICRjb25maXJtQnRuLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3I7XFxuXFxuICAgIC8vIFNldCB0aGUgY29uZmlybSBidXR0b24gY29sb3IgdG8gdGhlIGxvYWRpbmcgcmluZ1xcbiAgICAkY29uZmlybUJ0bi5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBwYXJhbXMuY29uZmlybUxvYWRpbmdCdXR0b25Db2xvcjtcXG4gICAgJGNvbmZpcm1CdG4uc3R5bGUuYm9yZGVyUmlnaHRDb2xvciA9IHBhcmFtcy5jb25maXJtTG9hZGluZ0J1dHRvbkNvbG9yO1xcblxcbiAgICAvLyBTZXQgYm94LXNoYWRvdyB0byBkZWZhdWx0IGZvY3VzZWQgYnV0dG9uXFxuICAgIF9nZXRNb2RhbCRnZXRJbnB1dCRzZXRGb2N1c1N0eWxlLnNldEZvY3VzU3R5bGUoJGNvbmZpcm1CdG4sIHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3IpO1xcbiAgfVxcblxcbiAgLypcXG4gICAqIEFsbG93IG91dHNpZGUgY2xpY2tcXG4gICAqL1xcbiAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWFsbG93LW91dHNpZGUtY2xpY2snLCBwYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spO1xcblxcbiAgLypcXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uXFxuICAgKi9cXG4gIHZhciBoYXNEb25lRnVuY3Rpb24gPSBwYXJhbXMuZG9uZUZ1bmN0aW9uID8gdHJ1ZSA6IGZhbHNlO1xcbiAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWhhcy1kb25lLWZ1bmN0aW9uJywgaGFzRG9uZUZ1bmN0aW9uKTtcXG5cXG4gIC8qXFxuICAgKiBBbmltYXRpb25cXG4gICAqL1xcbiAgaWYgKCFwYXJhbXMuYW5pbWF0aW9uKSB7XFxuICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCAnbm9uZScpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcXG4gICAgbW9kYWwuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsIHBhcmFtcy5hbmltYXRpb24pOyAvLyBDdXN0b20gYW5pbWF0aW9uXFxuICB9IGVsc2Uge1xcbiAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYW5pbWF0aW9uJywgJ3BvcCcpO1xcbiAgfVxcblxcbiAgLypcXG4gICAqIFRpbWVyXFxuICAgKi9cXG4gIG1vZGFsLnNldEF0dHJpYnV0ZSgnZGF0YS10aW1lcicsIHBhcmFtcy50aW1lcik7XFxufTtcXG5cXG5leHBvcnRzWydkZWZhdWx0J10gPSBzZXRQYXJhbWV0ZXJzO1xcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcblxcbn0se1xcXCIuL2hhbmRsZS1kb21cXFwiOjQsXFxcIi4vaGFuZGxlLXN3YWwtZG9tXFxcIjo2LFxcXCIuL3V0aWxzXFxcIjo5fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLypcXG4gKiBBbGxvdyB1c2VyIHRvIHBhc3MgdGhlaXIgb3duIHBhcmFtc1xcbiAqL1xcbnZhciBleHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcXG4gICAgaWYgKGIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGE7XFxufTtcXG5cXG4vKlxcbiAqIENvbnZlcnQgSEVYIGNvZGVzIHRvIFJHQiB2YWx1ZXMgKCMwMDAwMDAgLT4gcmdiKDAsMCwwKSlcXG4gKi9cXG52YXIgaGV4VG9SZ2IgPSBmdW5jdGlvbiBoZXhUb1JnYihoZXgpIHtcXG4gIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pJC9pLmV4ZWMoaGV4KTtcXG4gIHJldHVybiByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0sIDE2KSArICcsICcgKyBwYXJzZUludChyZXN1bHRbMl0sIDE2KSArICcsICcgKyBwYXJzZUludChyZXN1bHRbM10sIDE2KSA6IG51bGw7XFxufTtcXG5cXG4vKlxcbiAqIENoZWNrIGlmIHRoZSB1c2VyIGlzIHVzaW5nIEludGVybmV0IEV4cGxvcmVyIDggKGZvciBmYWxsYmFja3MpXFxuICovXFxudmFyIGlzSUU4ID0gZnVuY3Rpb24gaXNJRTgoKSB7XFxuICByZXR1cm4gd2luZG93LmF0dGFjaEV2ZW50ICYmICF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcXG59O1xcblxcbi8qXFxuICogSUUgY29tcGF0aWJsZSBsb2dnaW5nIGZvciBkZXZlbG9wZXJzXFxuICovXFxudmFyIGxvZ1N0ciA9IGZ1bmN0aW9uIGxvZ1N0cihzdHJpbmcpIHtcXG4gIGlmICh3aW5kb3cuY29uc29sZSkge1xcbiAgICAvLyBJRS4uLlxcbiAgICB3aW5kb3cuY29uc29sZS5sb2coJ1N3ZWV0QWxlcnQ6ICcgKyBzdHJpbmcpO1xcbiAgfVxcbn07XFxuXFxuLypcXG4gKiBTZXQgaG92ZXIsIGFjdGl2ZSBhbmQgZm9jdXMtc3RhdGVzIGZvciBidXR0b25zIFxcbiAqIChzb3VyY2U6IGh0dHA6Ly93d3cuc2l0ZXBvaW50LmNvbS9qYXZhc2NyaXB0LWdlbmVyYXRlLWxpZ2h0ZXItZGFya2VyLWNvbG9yKVxcbiAqL1xcbnZhciBjb2xvckx1bWluYW5jZSA9IGZ1bmN0aW9uIGNvbG9yTHVtaW5hbmNlKGhleCwgbHVtKSB7XFxuICAvLyBWYWxpZGF0ZSBoZXggc3RyaW5nXFxuICBoZXggPSBTdHJpbmcoaGV4KS5yZXBsYWNlKC9bXjAtOWEtZl0vZ2ksICcnKTtcXG4gIGlmIChoZXgubGVuZ3RoIDwgNikge1xcbiAgICBoZXggPSBoZXhbMF0gKyBoZXhbMF0gKyBoZXhbMV0gKyBoZXhbMV0gKyBoZXhbMl0gKyBoZXhbMl07XFxuICB9XFxuICBsdW0gPSBsdW0gfHwgMDtcXG5cXG4gIC8vIENvbnZlcnQgdG8gZGVjaW1hbCBhbmQgY2hhbmdlIGx1bWlub3NpdHlcXG4gIHZhciByZ2IgPSAnIyc7XFxuICB2YXIgYztcXG4gIHZhciBpO1xcblxcbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xcbiAgICBjID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpICogMiwgMiksIDE2KTtcXG4gICAgYyA9IE1hdGgucm91bmQoTWF0aC5taW4oTWF0aC5tYXgoMCwgYyArIGMgKiBsdW0pLCAyNTUpKS50b1N0cmluZygxNik7XFxuICAgIHJnYiArPSAoJzAwJyArIGMpLnN1YnN0cihjLmxlbmd0aCk7XFxuICB9XFxuXFxuICByZXR1cm4gcmdiO1xcbn07XFxuXFxuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XFxuZXhwb3J0cy5oZXhUb1JnYiA9IGhleFRvUmdiO1xcbmV4cG9ydHMuaXNJRTggPSBpc0lFODtcXG5leHBvcnRzLmxvZ1N0ciA9IGxvZ1N0cjtcXG5leHBvcnRzLmNvbG9yTHVtaW5hbmNlID0gY29sb3JMdW1pbmFuY2U7XFxuXFxufSx7fV19LHt9LFsxXSlcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OWljbTkzYzJWeWFXWjVMMjV2WkdWZmJXOWtkV3hsY3k5aWNtOTNjMlZ5TFhCaFkyc3ZYM0J5Wld4MVpHVXVhbk1pTENJdlZYTmxjbk12VkhKcGMzUmhiaTlrWlhZdlUzZGxaWFJCYkdWeWRDOWtaWFl2YzNkbFpYUmhiR1Z5ZEM1bGN6WXVhbk1pTENJdlZYTmxjbk12VkhKcGMzUmhiaTlrWlhZdlUzZGxaWFJCYkdWeWRDOWtaWFl2Ylc5a2RXeGxjeTlrWldaaGRXeDBMWEJoY21GdGN5NXFjeUlzSWk5VmMyVnljeTlVY21semRHRnVMMlJsZGk5VGQyVmxkRUZzWlhKMEwyUmxkaTl0YjJSMWJHVnpMMmhoYm1Sc1pTMWpiR2xqYXk1cWN5SXNJaTlWYzJWeWN5OVVjbWx6ZEdGdUwyUmxkaTlUZDJWbGRFRnNaWEowTDJSbGRpOXRiMlIxYkdWekwyaGhibVJzWlMxa2IyMHVhbk1pTENJdlZYTmxjbk12VkhKcGMzUmhiaTlrWlhZdlUzZGxaWFJCYkdWeWRDOWtaWFl2Ylc5a2RXeGxjeTlvWVc1a2JHVXRhMlY1TG1weklpd2lMMVZ6WlhKekwxUnlhWE4wWVc0dlpHVjJMMU4zWldWMFFXeGxjblF2WkdWMkwyMXZaSFZzWlhNdmFHRnVaR3hsTFhOM1lXd3RaRzl0TG1weklpd2lMMVZ6WlhKekwxUnlhWE4wWVc0dlpHVjJMMU4zWldWMFFXeGxjblF2WkdWMkwyMXZaSFZzWlhNdmFXNXFaV04wWldRdGFIUnRiQzVxY3lJc0lpOVZjMlZ5Y3k5VWNtbHpkR0Z1TDJSbGRpOVRkMlZsZEVGc1pYSjBMMlJsZGk5dGIyUjFiR1Z6TDNObGRDMXdZWEpoYlhNdWFuTWlMQ0l2VlhObGNuTXZWSEpwYzNSaGJpOWtaWFl2VTNkbFpYUkJiR1Z5ZEM5a1pYWXZiVzlrZFd4bGN5OTFkR2xzY3k1cWN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaVFVRkJRVHM3T3pzN096czdPenM3T3pzN096dHpTa05uUWs4c2MwSkJRWE5DT3pzN096czdNa1JCVjNSQ0xHbENRVUZwUWpzN096czdPM2RJUVdOcVFpd3lRa0ZCTWtJN096czdkVVJCU1hkQ0xIZENRVUYzUWpzN05rSkJRM2hFTEhOQ1FVRnpRanM3T3pzN096WkNRVWwwUWl3d1FrRkJNRUk3T3pzN05rSkJRekZDTEhOQ1FVRnpRanM3T3pzN096czdRVUZOYUVRc1NVRkJTU3h4UWtGQmNVSXNRMEZCUXp0QlFVTXhRaXhKUVVGSkxHbENRVUZwUWl4RFFVRkRPenM3T3pzN1FVRlBkRUlzU1VGQlNTeFZRVUZWTEVWQlFVVXNTVUZCU1N4RFFVRkRPenR4UWtGRlRpeFZRVUZWTEVkQlFVY3NTVUZCU1N4SFFVRkhMRmxCUVZjN1FVRkROVU1zVFVGQlNTeGpRVUZqTEVkQlFVY3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE96dEJRVVZzUXl3d1NVRTVSRlVzVVVGQlVTeERRVGhFVkN4UlFVRlJMRU5CUVVNc1NVRkJTU3hGUVVGRkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNN1FVRkRNVU1zTkVkQmFFTkJMRlZCUVZVc1JVRm5RMFVzUTBGQlF6czdPenM3T3p0QlFVOWlMRmRCUVZNc2FVSkJRV2xDTEVOQlFVTXNSMEZCUnl4RlFVRkZPMEZCUXpsQ0xGRkJRVWtzU1VGQlNTeEhRVUZITEdOQlFXTXNRMEZCUXp0QlFVTXhRaXhYUVVGUExFRkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRk5CUVZNc1IwRkJTeXd5UWtGQll5eEhRVUZITEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03UjBGRGNFVTdPMEZCUlVRc1RVRkJTU3hqUVVGakxFdEJRVXNzVTBGQlV5eEZRVUZGTzBGQlEyaERMR2xFUVRORVJpeE5RVUZOTEVOQk1rUkhMREJEUVVFd1F5eERRVUZETEVOQlFVTTdRVUZEYmtRc1YwRkJUeXhMUVVGTExFTkJRVU03UjBGRFpEczdRVUZGUkN4TlFVRkpMRTFCUVUwc1IwRkJSeXcyUTBGc1JXSXNUVUZCVFN4RFFXdEZZeXhGUVVGRkxEWkNRVUZuUWl4RFFVRkRPenRCUVVWMlF5eFZRVUZSTEU5QlFVOHNZMEZCWXpzN08wRkJSek5DTEZOQlFVc3NVVUZCVVR0QlFVTllMRmxCUVUwc1EwRkJReXhMUVVGTExFZEJRVWNzWTBGQll5eERRVUZETzBGQlF6bENMRmxCUVUwc1EwRkJReXhKUVVGSkxFZEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRCUVVOc1F5eFpRVUZOTEVOQlFVTXNTVUZCU1N4SFFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdRVUZEYkVNc1dVRkJUVHM3UVVGQlFUdEJRVWRTTEZOQlFVc3NVVUZCVVR0QlFVTllMRlZCUVVrc1kwRkJZeXhEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVWQlFVVTdRVUZEZEVNc2NVUkJOMFZPTEUxQlFVMHNRMEUyUlU4c01rSkJRVEpDTEVOQlFVTXNRMEZCUXp0QlFVTndReXhsUVVGUExFdEJRVXNzUTBGQlF6dFBRVU5rT3p0QlFVVkVMRmxCUVUwc1EwRkJReXhMUVVGTExFZEJRVWNzWTBGQll5eERRVUZETEV0QlFVc3NRMEZCUXpzN1FVRkZjRU1zVjBGQlN5eEpRVUZKTEZWQlFWVXNaME5CUVcxQ08wRkJRM0JETEdOQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhwUWtGQmFVSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJRenRQUVVOd1JEczdPMEZCUjBRc1dVRkJUU3hEUVVGRExHbENRVUZwUWl4SFFVRkhMRTFCUVUwc1EwRkJReXhuUWtGQlowSXNSMEZCUnl4VFFVRlRMRWRCUVVjc01rSkJRV01zYVVKQlFXbENMRU5CUVVNN1FVRkRha2NzV1VGQlRTeERRVUZETEdsQ1FVRnBRaXhIUVVGSExHbENRVUZwUWl4RFFVRkRMRzFDUVVGdFFpeERRVUZETEVOQlFVTTdPenRCUVVkc1JTeFpRVUZOTEVOQlFVTXNXVUZCV1N4SFFVRkhMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEpRVUZKTEVOQlFVTTdPMEZCUlRORExGbEJRVTA3TzBGQlFVRXNRVUZGVWp0QlFVTkZMRzFFUVdwSFNpeE5RVUZOTEVOQmFVZExMR3RGUVVGclJTeEhRVUZITEU5QlFVOHNZMEZCWXl4RFFVRkRMRU5CUVVNN1FVRkRia2NzWVVGQlR5eExRVUZMTEVOQlFVTTdPMEZCUVVFc1IwRkZhRUk3TzBGQlJVUXNOa0pCUVdNc1RVRkJUU3hEUVVGRExFTkJRVU03UVVGRGRFSXNORWRCZUVaQkxHMUNRVUZ0UWl4RlFYZEdSU3hEUVVGRE8wRkJRM1JDTERSSFFUTkdRU3hUUVVGVExFTkJNa1pETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE96czdRVUZIZUVJc1RVRkJTU3hMUVVGTExFZEJRVWNzTUVkQmJFZGFMRkZCUVZFc1JVRnJSMk1zUTBGQlF6czdPenM3UVVGTmRrSXNUVUZCU1N4UlFVRlJMRWRCUVVjc1MwRkJTeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8wRkJRMmhFTEUxQlFVa3NXVUZCV1N4SFFVRkhMRU5CUVVNc1UwRkJVeXhGUVVGRkxHRkJRV0VzUlVGQlJTeFpRVUZaTEVWQlFVVXNZVUZCWVN4RlFVRkZMRmRCUVZjc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF6dEJRVU51Unl4TlFVRkpMR0ZCUVdFc1IwRkJSeXgxUWtGQlF5eERRVUZETzFkQlFVc3NlVU5CTDBad1FpeFpRVUZaTEVOQkswWnhRaXhEUVVGRExFVkJRVVVzVFVGQlRTeEZRVUZGTEV0QlFVc3NRMEZCUXp0SFFVRkJMRU5CUVVNN08wRkJSVEZFTEU5QlFVc3NTVUZCU1N4UlFVRlJMRWRCUVVjc1EwRkJReXhGUVVGRkxGRkJRVkVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RlFVRkZMRkZCUVZFc1JVRkJSU3hGUVVGRk8wRkJRemRFTEZOQlFVc3NTVUZCU1N4UlFVRlJMRWRCUVVjc1EwRkJReXhGUVVGRkxGRkJRVkVzUjBGQlJ5eFpRVUZaTEVOQlFVTXNUVUZCVFN4RlFVRkZMRkZCUVZFc1JVRkJSU3hGUVVGRk8wRkJRMnBGTEZWQlFVa3NUVUZCVFN4SFFVRkhMRmxCUVZrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU53UXl4alFVRlJMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NZVUZCWVN4RFFVRkRPMHRCUXpWRE8wZEJRMFk3T3p0QlFVZEVMRFJIUVc1SVFTeFZRVUZWTEVWQmJVaEZMRU5CUVVNc1QwRkJUeXhIUVVGSExHRkJRV0VzUTBGQlF6czdRVUZGY2tNc2RVSkJRWEZDTEVkQlFVY3NUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenM3UVVGRmVrTXNUVUZCU1N4VlFVRlZMRWRCUVVjc2IwSkJRVU1zUTBGQlF6dFhRVUZMTERKQ1FVRmpMRU5CUVVNc1JVRkJSU3hOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETzBkQlFVRXNRMEZCUXp0QlFVTjRSQ3hSUVVGTkxFTkJRVU1zVTBGQlV5eEhRVUZITEZWQlFWVXNRMEZCUXpzN1FVRkZPVUlzVVVGQlRTeERRVUZETEU5QlFVOHNSMEZCUnl4WlFVRlpPenRCUVVVelFpeGpRVUZWTEVOQlFVTXNXVUZCV1RzN08wRkJSM0pDTEZWQlFVa3NhVUpCUVdsQ0xFdEJRVXNzVTBGQlV5eEZRVUZGTzBGQlEyNURMSGxDUVVGcFFpeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMEZCUXpGQ0xIbENRVUZwUWl4SFFVRkhMRk5CUVZNc1EwRkJRenRQUVVNdlFqdExRVU5HTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1IwRkRVQ3hEUVVGRE96czdRVUZIUml4TlFVRkpMRU5CUVVNc1lVRkJZU3hGUVVGRkxFTkJRVU03UTBGRGRFSTdPenM3T3p0QlFWRkVMRlZCUVZVc1EwRkJReXhYUVVGWExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4VlFVRlRMRlZCUVZVc1JVRkJSVHRCUVVNdlJDeE5RVUZKTEVOQlFVTXNWVUZCVlN4RlFVRkZPMEZCUTJZc1ZVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXhEUVVGRE8wZEJRek5ETzBGQlEwUXNUVUZCU1N4UFFVRlBMRlZCUVZVc1MwRkJTeXhSUVVGUkxFVkJRVVU3UVVGRGJFTXNWVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXdyUWtGQkswSXNRMEZCUXl4RFFVRkRPMGRCUTJ4RU96dEJRVVZFTEN0RFFYSkxRU3hOUVVGTkxEWkNRWEZMWjBJc1ZVRkJWU3hEUVVGRExFTkJRVU03UTBGRGJrTXNRMEZCUXpzN096czdRVUZOUml4VlFVRlZMRU5CUVVNc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NXVUZCVnp0QlFVTjZReXhOUVVGSkxFdEJRVXNzUjBGQlJ5d3dSMEZxUzFvc1VVRkJVU3hGUVdsTFl5eERRVUZET3p0QlFVVjJRaXd3U1VGNFRGRXNUMEZCVHl4RFFYZE1VQ3d3UjBGc1MxSXNWVUZCVlN4RlFXdExWU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlEzcENMREJKUVhwTVVTeFBRVUZQTEVOQmVVeFFMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU5zUWl3d1NVRXZURzlDTEZkQlFWY3NRMEVyVEc1Q0xFdEJRVXNzUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRE8wRkJRM0pETERCSlFXaE5WU3hSUVVGUkxFTkJaMDFVTEV0QlFVc3NSVUZCUlN4blFrRkJaMElzUTBGQlF5eERRVUZETzBGQlEyeERMREJKUVdwTmIwSXNWMEZCVnl4RFFXbE5ia0lzUzBGQlN5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPenM3T3p0QlFVczVRaXhOUVVGSkxGbEJRVmtzUjBGQlJ5eExRVUZMTEVOQlFVTXNZVUZCWVN4RFFVRkRMSEZDUVVGeFFpeERRVUZETEVOQlFVTTdRVUZET1VRc01FbEJkazF2UWl4WFFVRlhMRU5CZFUxdVFpeFpRVUZaTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1FVRkRja01zTUVsQmVFMXZRaXhYUVVGWExFTkJkMDF1UWl4WlFVRlpMRU5CUVVNc1lVRkJZU3hEUVVGRExGTkJRVk1zUTBGQlF5eEZRVUZGTEcxQ1FVRnRRaXhEUVVGRExFTkJRVU03UVVGRGVFVXNNRWxCZWsxdlFpeFhRVUZYTEVOQmVVMXVRaXhaUVVGWkxFTkJRVU1zWVVGQllTeERRVUZETEZWQlFWVXNRMEZCUXl4RlFVRkZMRzlDUVVGdlFpeERRVUZETEVOQlFVTTdPMEZCUlRGRkxFMUJRVWtzVlVGQlZTeEhRVUZITEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNRMEZCUXp0QlFVTXhSQ3d3U1VFMVRXOUNMRmRCUVZjc1EwRTBUVzVDTEZWQlFWVXNSVUZCUlN4clFrRkJhMElzUTBGQlF5eERRVUZETzBGQlF6VkRMREJKUVRkTmIwSXNWMEZCVnl4RFFUWk5ia0lzVlVGQlZTeERRVUZETEdGQlFXRXNRMEZCUXl4WlFVRlpMRU5CUVVNc1JVRkJSU3hqUVVGakxFTkJRVU1zUTBGQlF6czdRVUZGY0VVc1RVRkJTU3haUVVGWkxFZEJRVWNzUzBGQlN5eERRVUZETEdGQlFXRXNRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eERRVUZETzBGQlF6bEVMREJKUVdoT2IwSXNWMEZCVnl4RFFXZE9ia0lzV1VGQldTeEZRVUZGTEdOQlFXTXNRMEZCUXl4RFFVRkRPMEZCUXpGRExEQkpRV3BPYjBJc1YwRkJWeXhEUVdsT2JrSXNXVUZCV1N4RFFVRkRMR0ZCUVdFc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJTeHBRa0ZCYVVJc1EwRkJReXhEUVVGRE8wRkJRM1pGTERCSlFXeE9iMElzVjBGQlZ5eERRV3RPYmtJc1dVRkJXU3hEUVVGRExHRkJRV0VzUTBGQlF5eFRRVUZUTEVOQlFVTXNSVUZCUlN4cFFrRkJhVUlzUTBGQlF5eERRVUZET3pzN1FVRkhkRVVzV1VGQlZTeERRVUZETEZsQlFWYzdRVUZEY0VJc1VVRkJTU3hYUVVGWExFZEJRVWNzUzBGQlN5eERRVUZETEZsQlFWa3NRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eERRVUZETzBGQlF6RkVMRFJKUVhaT2EwSXNWMEZCVnl4RFFYVk9ha0lzUzBGQlN5eEZRVUZGTEZkQlFWY3NRMEZCUXl4RFFVRkRPMGRCUTJwRExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTTdPenRCUVVkU0xEQkpRVE5PYjBJc1YwRkJWeXhEUVRKT2JrSXNVVUZCVVN4RFFVRkRMRWxCUVVrc1JVRkJSU3huUWtGQlowSXNRMEZCUXl4RFFVRkRPenM3UVVGSE4wTXNVVUZCVFN4RFFVRkRMRk5CUVZNc1IwRkJSeXh4UWtGQmNVSXNRMEZCUXp0QlFVTjZReXhOUVVGSkxFMUJRVTBzUTBGQlF5eHhRa0ZCY1VJc1JVRkJSVHRCUVVOb1F5eFZRVUZOTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdSMEZEZEVNN1FVRkRSQ3h0UWtGQmFVSXNSMEZCUnl4VFFVRlRMRU5CUVVNN1FVRkRPVUlzWTBGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenM3UVVGRk5VSXNVMEZCVHl4SlFVRkpMRU5CUVVNN1EwRkRZaXhEUVVGRE96czdPenM3UVVGUFJpeFZRVUZWTEVOQlFVTXNZMEZCWXl4SFFVRkhMRWxCUVVrc1EwRkJReXhqUVVGakxFZEJRVWNzVlVGQlV5eFpRVUZaTEVWQlFVVTdRVUZEZGtVc1RVRkJTU3hMUVVGTExFZEJRVWNzTUVkQmNFNWFMRkZCUVZFc1JVRnZUbU1zUTBGQlF6czdRVUZGZGtJc1RVRkJTU3hWUVVGVkxFZEJRVWNzUzBGQlN5eERRVUZETEdGQlFXRXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eERRVUZETzBGQlEzaEVMREJKUVdwUVZTeFJRVUZSTEVOQmFWQlVMRlZCUVZVc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6czdRVUZGTjBJc1RVRkJTU3hsUVVGbExFZEJRVWNzUzBGQlN5eERRVUZETEdGQlFXRXNRMEZCUXl4eFFrRkJjVUlzUTBGQlF5eERRVUZETzBGQlEycEZMREJKUVhCUVZTeFJRVUZSTEVOQmIxQlVMR1ZCUVdVc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6czdRVUZGYkVNc2FVSkJRV1VzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1UwRkJVeXhIUVVGSExGbEJRVmtzUTBGQlF6czdRVUZGTlVRc1dVRkJWU3hEUVVGRExGbEJRVmM3UVVGRGNFSXNZMEZCVlN4RFFVRkRMR0ZCUVdFc1JVRkJSU3hEUVVGRE8wZEJRelZDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN08wRkJSVTRzVDBGQlN5eERRVUZETEdGQlFXRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dERRVU4wUXl4RFFVRkRPenM3T3p0QlFVMUdMRlZCUVZVc1EwRkJReXhsUVVGbExFZEJRVWNzU1VGQlNTeERRVUZETEdWQlFXVXNSMEZCUnl4VlFVRlRMRXRCUVVzc1JVRkJSVHM3UVVGRmJFVXNUVUZCU1N4TFFVRkxMRWxCUVVrc1MwRkJTeXhEUVVGRExFOUJRVThzUzBGQlN5eEZRVUZGTEVWQlFVVTdRVUZEYWtNc1YwRkJUeXhMUVVGTExFTkJRVU03UjBGRFpEczdRVUZGUkN4TlFVRkpMRTFCUVUwc1IwRkJSeXd3UjBFdlQySXNVVUZCVVN4RlFTdFBaU3hEUVVGRE96dEJRVVY0UWl4TlFVRkpMRlZCUVZVc1IwRkJSeXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03UVVGRGVrUXNNRWxCTlZGdlFpeFhRVUZYTEVOQk5GRnVRaXhWUVVGVkxFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdPMEZCUldoRExFMUJRVWtzWlVGQlpTeEhRVUZITEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc2NVSkJRWEZDTEVOQlFVTXNRMEZCUXp0QlFVTnNSU3d3U1VFdlVXOUNMRmRCUVZjc1EwRXJVVzVDTEdWQlFXVXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenREUVVOMFF5eERRVUZET3pzN096dEJRVXRHTEZWQlFWVXNRMEZCUXl4alFVRmpMRWRCUVVjc1NVRkJTU3hEUVVGRExHTkJRV01zUjBGQlJ5eFZRVUZUTEV0QlFVc3NSVUZCUlR0QlFVTm9SU3hOUVVGSkxFdEJRVXNzUjBGQlJ5d3dSMEUxVUZvc1VVRkJVU3hGUVRSUVl5eERRVUZETzBGQlEzWkNMRTFCUVVrc1kwRkJZeXhIUVVGSExFdEJRVXNzUTBGQlF5eGhRVUZoTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dEJRVU16UkN4TlFVRkpMR0ZCUVdFc1IwRkJSeXhMUVVGTExFTkJRVU1zWVVGQllTeERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMEZCUTNwRUxHZENRVUZqTEVOQlFVTXNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJRenRCUVVNdlFpeGxRVUZoTEVOQlFVTXNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJRenREUVVNdlFpeERRVUZET3pzN096dEJRVXRHTEZWQlFWVXNRMEZCUXl4aFFVRmhMRWRCUVVjc1NVRkJTU3hEUVVGRExHRkJRV0VzUjBGQlJ5eFZRVUZUTEV0QlFVc3NSVUZCUlR0QlFVTTVSQ3hOUVVGSkxFdEJRVXNzUjBGQlJ5d3dSMEYyVVZvc1VVRkJVU3hGUVhWUll5eERRVUZETzBGQlEzWkNMRTFCUVVrc1kwRkJZeXhIUVVGSExFdEJRVXNzUTBGQlF5eGhRVUZoTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF6dEJRVU16UkN4TlFVRkpMR0ZCUVdFc1IwRkJSeXhMUVVGTExFTkJRVU1zWVVGQllTeERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMEZCUTNwRUxHZENRVUZqTEVOQlFVTXNVVUZCVVN4SFFVRkhMRXRCUVVzc1EwRkJRenRCUVVOb1F5eGxRVUZoTEVOQlFVTXNVVUZCVVN4SFFVRkhMRXRCUVVzc1EwRkJRenREUVVOb1F5eERRVUZET3p0QlFVVkdMRWxCUVVrc1QwRkJUeXhOUVVGTkxFdEJRVXNzVjBGQlZ5eEZRVUZGT3pzN1FVRkhha01zVVVGQlRTeERRVUZETEZWQlFWVXNSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hIUVVGSExGVkJRVlVzUTBGQlF6dERRVU01UXl4TlFVRk5PMEZCUTB3c0swTkJOVkpCTEUxQlFVMHNRMEUwVWtNc2EwTkJRV3RETEVOQlFVTXNRMEZCUXp0RFFVTTFRenM3T3pzN096czdPMEZEZEZSRUxFbEJRVWtzWVVGQllTeEhRVUZITzBGQlEyeENMRTlCUVVzc1JVRkJSU3hGUVVGRk8wRkJRMVFzVFVGQlNTeEZRVUZGTEVWQlFVVTdRVUZEVWl4TlFVRkpMRVZCUVVVc1NVRkJTVHRCUVVOV0xHMUNRVUZwUWl4RlFVRkZMRXRCUVVzN1FVRkRlRUlzYlVKQlFXbENMRVZCUVVVc1NVRkJTVHRCUVVOMlFpeHJRa0ZCWjBJc1JVRkJSU3hMUVVGTE8wRkJRM1pDTEdkQ1FVRmpMRVZCUVVVc1NVRkJTVHRCUVVOd1FpeGxRVUZoTEVWQlFVVXNTVUZCU1R0QlFVTnVRaXh0UWtGQmFVSXNSVUZCUlN4SlFVRkpPMEZCUTNaQ0xHOUNRVUZyUWl4RlFVRkZMRk5CUVZNN1FVRkROMElzYTBKQlFXZENMRVZCUVVVc1VVRkJVVHRCUVVNeFFpeFZRVUZSTEVWQlFVVXNTVUZCU1R0QlFVTmtMRmRCUVZNc1JVRkJSU3hKUVVGSk8wRkJRMllzVDBGQlN5eEZRVUZGTEVsQlFVazdRVUZEV0N4aFFVRlhMRVZCUVVVc1JVRkJSVHRCUVVObUxFMUJRVWtzUlVGQlJTeExRVUZMTzBGQlExZ3NWMEZCVXl4RlFVRkZMRWxCUVVrN1FVRkRaaXhuUWtGQll5eEZRVUZGTEVsQlFVazdRVUZEY0VJc1YwRkJVeXhGUVVGRkxFMUJRVTA3UVVGRGFrSXNhMEpCUVdkQ0xFVkJRVVVzUlVGQlJUdEJRVU53UWl4WlFVRlZMRVZCUVVVc1JVRkJSVHRCUVVOa0xIRkNRVUZ0UWl4RlFVRkZMRXRCUVVzN1EwRkRNMElzUTBGQlF6czdjVUpCUldFc1lVRkJZVHM3T3pzN096czdPenM0UWtONlFrY3NVMEZCVXpzN2QwSkJRMllzYlVKQlFXMUNPenR4UTBGRFRDeGpRVUZqT3pzN096dEJRVTF5UkN4SlFVRkpMRmxCUVZrc1IwRkJSeXh6UWtGQlV5eExRVUZMTEVWQlFVVXNUVUZCVFN4RlFVRkZMRXRCUVVzc1JVRkJSVHRCUVVOb1JDeE5RVUZKTEVOQlFVTXNSMEZCUnl4TFFVRkxMRWxCUVVrc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU01UWl4TlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zVFVGQlRTeEpRVUZKTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNN08wRkJSWFJETEUxQlFVa3NaVUZCWlN4SFFVRkhMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMnBGTEUxQlFVa3NaVUZCWlN4SFFVRkhMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEdWQlFXVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRM1pGTEUxQlFVa3NZMEZCWXl4SFFVRkpMSFZDUVZwbUxGRkJRVkVzUTBGWlowSXNTMEZCU3l4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8wRkJRMnBFTEUxQlFVa3NhMEpCUVd0Q0xFZEJRVWtzVFVGQlRTeERRVUZETEZsQlFWa3NTVUZCU1N4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExIZENRVUYzUWl4RFFVRkRMRXRCUVVzc1RVRkJUU3hCUVVGRExFTkJRVU03T3pzN1FVRkpNVWNzVFVGQlNTeFhRVUZYTEVWQlFVVXNWVUZCVlN4RlFVRkZMRmRCUVZjc1EwRkJRenRCUVVONlF5eE5RVUZKTEdWQlFXVXNTVUZCU1N4TlFVRk5MRU5CUVVNc2EwSkJRV3RDTEVWQlFVVTdRVUZEYUVRc1pVRkJWeXhIUVVGSkxFMUJRVTBzUTBGQlF5eHJRa0ZCYTBJc1EwRkJRenRCUVVONlF5eGpRVUZWTEVkQlFVc3NaMEpCZEVKV0xHTkJRV01zUTBGelFsY3NWMEZCVnl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03UVVGRGJFUXNaVUZCVnl4SFFVRkpMR2RDUVhaQ1ZpeGpRVUZqTEVOQmRVSlhMRmRCUVZjc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBkQlEyNUVPenRCUVVWRUxGZEJRVk1zTWtKQlFUSkNMRU5CUVVNc1MwRkJTeXhGUVVGRk8wRkJRekZETEZGQlFVa3NaVUZCWlN4SlFVRkpMRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNSVUZCUlR0QlFVTm9SQ3haUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEdWQlFXVXNSMEZCUnl4TFFVRkxMRU5CUVVNN1MwRkRkRU03UjBGRFJqczdRVUZGUkN4VlFVRlJMRU5CUVVNc1EwRkJReXhKUVVGSk8wRkJRMW9zVTBGQlN5eFhRVUZYTzBGQlEyUXNhVU5CUVRKQ0xFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdRVUZEZUVNc1dVRkJUVHM3UVVGQlFTeEJRVVZTTEZOQlFVc3NWVUZCVlR0QlFVTmlMR2xEUVVFeVFpeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMEZCUTNwRExGbEJRVTA3TzBGQlFVRXNRVUZGVWl4VFFVRkxMRmRCUVZjN1FVRkRaQ3hwUTBGQk1rSXNRMEZCUXl4WFFVRlhMRU5CUVVNc1EwRkJRenRCUVVONlF5eFpRVUZOT3p0QlFVRkJMRUZCUlZJc1UwRkJTeXhUUVVGVE8wRkJRMW9zYVVOQlFUSkNMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03UVVGRGVFTXNXVUZCVFRzN1FVRkJRU3hCUVVWU0xGTkJRVXNzVDBGQlR6dEJRVU5XTEZWQlFVa3NZMEZCWXl4SFFVRkhMRXRCUVVzc1EwRkJReXhoUVVGaExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1EwRkJRenRCUVVNelJDeFZRVUZKTEdGQlFXRXNSMEZCU1N4TFFVRkxMRU5CUVVNc1lVRkJZU3hEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZET3p0QlFVVXhSQ3hWUVVGSkxHVkJRV1VzUlVGQlJUdEJRVU51UWl4eFFrRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVkQlFVY3NUVUZCVFN4RFFVRkRPMDlCUTNoRExFMUJRVTA3UVVGRFRDeHpRa0ZCWXl4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFZEJRVWNzVFVGQlRTeERRVUZETzA5QlEzcERPMEZCUTBRc1dVRkJUVHM3UVVGQlFTeEJRVVZTTEZOQlFVc3NUMEZCVHp0QlFVTldMRlZCUVVrc1kwRkJZeXhIUVVGSkxFdEJRVXNzUzBGQlN5eE5RVUZOTEVGQlFVTXNRMEZCUXp0QlFVTjRReXhWUVVGSkxHMUNRVUZ0UWl4SFFVRkhMSFZDUVRWRVlpeFpRVUZaTEVOQk5FUmpMRXRCUVVzc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6czdPMEZCUjNSRUxGVkJRVWtzUTBGQlF5eGpRVUZqTEVsQlFVa3NRMEZCUXl4dFFrRkJiVUlzU1VGQlNTeGpRVUZqTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc2FVSkJRV2xDTEVWQlFVVTdRVUZETVVZc1kwRkJUVHRQUVVOUU96dEJRVVZFTEZWQlFVa3NaVUZCWlN4SlFVRkpMR3RDUVVGclFpeEpRVUZKTEdOQlFXTXNSVUZCUlR0QlFVTXpSQ3h4UWtGQllTeERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRQUVVNNVFpeE5RVUZOTEVsQlFVa3NhMEpCUVd0Q0xFbEJRVWtzWTBGQll5eEpRVUZKTEdWQlFXVXNSVUZCUlR0QlFVTnNSU3h2UWtGQldTeERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRQUVVNM1FpeE5RVUZOTEVsQlFVa3NkVUpCZGtWRkxGbEJRVmtzUTBGMVJVUXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEV0QlFVc3NVVUZCVVN4RlFVRkZPMEZCUTNKRkxHdENRVUZWTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1QwRkRjRUk3UVVGRFJDeFpRVUZOTzBGQlFVRXNSMEZEVkR0RFFVTkdMRU5CUVVNN096czdPMEZCUzBZc1NVRkJTU3hoUVVGaExFZEJRVWNzZFVKQlFWTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1JVRkJSVHRCUVVNeFF5eE5RVUZKTEdGQlFXRXNSMEZCUnl4SlFVRkpMRU5CUVVNN08wRkJSWHBDTEUxQlFVa3NkVUpCY0VaSExGRkJRVkVzUTBGdlJrWXNTMEZCU3l4RlFVRkZMRmxCUVZrc1EwRkJReXhGUVVGRk8wRkJRMnBETEdsQ1FVRmhMRWRCUVVjc1MwRkJTeXhEUVVGRExHRkJRV0VzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNN08wRkJSVzVFTEZGQlFVa3NRMEZCUXl4aFFVRmhMRVZCUVVVN1FVRkRiRUlzYlVKQlFXRXNSMEZCUnl4RlFVRkZMRU5CUVVNN1MwRkRjRUk3UjBGRFJqczdRVUZGUkN4UlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZET3p0QlFVVnVReXhOUVVGSkxFMUJRVTBzUTBGQlF5eGpRVUZqTEVWQlFVVTdRVUZEZWtJc1kwRkJWU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzBkQlEzQkNPenRCUVVWRUxFMUJRVWtzVFVGQlRTeERRVUZETEcxQ1FVRnRRaXhGUVVGRk8wRkJRemxDTEdOQlFWVXNRMEZCUXl4alFVRmpMRVZCUVVVc1EwRkJRenRIUVVNM1FqdERRVU5HTEVOQlFVTTdPenM3TzBGQlMwWXNTVUZCU1N4WlFVRlpMRWRCUVVjc2MwSkJRVk1zUzBGQlN5eEZRVUZGTEUxQlFVMHNSVUZCUlRzN1FVRkZla01zVFVGQlNTeGhRVUZoTEVkQlFVY3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8wRkJRMjVGTEUxQlFVa3NjVUpCUVhGQ0xFZEJRVWNzWVVGQllTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzVjBGQlZ5eEpRVUZKTEdGQlFXRXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF5eExRVUZMTEVkQlFVY3NRMEZCUXpzN1FVRkZjRWdzVFVGQlNTeHhRa0ZCY1VJc1JVRkJSVHRCUVVONlFpeFZRVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wZEJRelZDT3p0QlFVVkVMRTFCUVVrc1RVRkJUU3hEUVVGRExHRkJRV0VzUlVGQlJUdEJRVU40UWl4alFVRlZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03UjBGRGNFSTdRMEZEUml4RFFVRkRPenR4UWtGSFlUdEJRVU5pTEdOQlFWa3NSVUZCV2l4WlFVRlpPMEZCUTFvc1pVRkJZU3hGUVVGaUxHRkJRV0U3UVVGRFlpeGpRVUZaTEVWQlFWb3NXVUZCV1R0RFFVTmlPenM3T3pzN096czdRVU12U0VRc1NVRkJTU3hSUVVGUkxFZEJRVWNzYTBKQlFWTXNTVUZCU1N4RlFVRkZMRk5CUVZNc1JVRkJSVHRCUVVOMlF5eFRRVUZQTEVsQlFVa3NUVUZCVFN4RFFVRkRMRWRCUVVjc1IwRkJSeXhUUVVGVExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPME5CUXpORkxFTkJRVU03TzBGQlJVWXNTVUZCU1N4UlFVRlJMRWRCUVVjc2EwSkJRVk1zU1VGQlNTeEZRVUZGTEZOQlFWTXNSVUZCUlR0QlFVTjJReXhOUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NSVUZCUlN4VFFVRlRMRU5CUVVNc1JVRkJSVHRCUVVNNVFpeFJRVUZKTEVOQlFVTXNVMEZCVXl4SlFVRkpMRWRCUVVjc1IwRkJSeXhUUVVGVExFTkJRVU03UjBGRGJrTTdRMEZEUml4RFFVRkRPenRCUVVWR0xFbEJRVWtzVjBGQlZ5eEhRVUZITEhGQ1FVRlRMRWxCUVVrc1JVRkJSU3hUUVVGVExFVkJRVVU3UVVGRE1VTXNUVUZCU1N4UlFVRlJMRWRCUVVjc1IwRkJSeXhIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRmRCUVZjc1JVRkJSU3hIUVVGSExFTkJRVU1zUjBGQlJ5eEhRVUZITEVOQlFVTTdRVUZEY0VVc1RVRkJTU3hSUVVGUkxFTkJRVU1zU1VGQlNTeEZRVUZGTEZOQlFWTXNRMEZCUXl4RlFVRkZPMEZCUXpkQ0xGZEJRVThzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRWRCUVVjc1UwRkJVeXhIUVVGSExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0QlFVTnVSQ3hqUVVGUkxFZEJRVWNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRWRCUVVjc1UwRkJVeXhIUVVGSExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0TFFVTjZSRHRCUVVORUxGRkJRVWtzUTBGQlF5eFRRVUZUTEVkQlFVY3NVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhaUVVGWkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdSMEZEY2tRN1EwRkRSaXhEUVVGRE96dEJRVVZHTEVsQlFVa3NWVUZCVlN4SFFVRkhMRzlDUVVGVExFZEJRVWNzUlVGQlJUdEJRVU0zUWl4TlFVRkpMRWRCUVVjc1IwRkJSeXhSUVVGUkxFTkJRVU1zWVVGQllTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMEZCUTNoRExFdEJRVWNzUTBGQlF5eFhRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMR05CUVdNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlF6bERMRk5CUVU4c1IwRkJSeXhEUVVGRExGTkJRVk1zUTBGQlF6dERRVU4wUWl4RFFVRkRPenRCUVVWR0xFbEJRVWtzUzBGQlN5eEhRVUZITEdWQlFWTXNTVUZCU1N4RlFVRkZPMEZCUTNwQ0xFMUJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4SFFVRkhMRVZCUVVVc1EwRkJRenRCUVVONFFpeE5RVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1IwRkJSeXhQUVVGUExFTkJRVU03UTBGRE9VSXNRMEZCUXpzN1FVRkZSaXhKUVVGSkxFbEJRVWtzUjBGQlJ5eGpRVUZUTEV0QlFVc3NSVUZCUlR0QlFVTjZRaXhOUVVGSkxFdEJRVXNzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRVZCUVVVN1FVRkRNVUlzVjBGQlR5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1IwRkRja0k3UVVGRFJDeFBRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSVHRCUVVOeVF5eFRRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03UjBGRGFrSTdRMEZEUml4RFFVRkRPenRCUVVWR0xFbEJRVWtzUzBGQlN5eEhRVUZITEdWQlFWTXNTVUZCU1N4RlFVRkZPMEZCUTNwQ0xFMUJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4SFFVRkhMRVZCUVVVc1EwRkJRenRCUVVONFFpeE5RVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1IwRkJSeXhOUVVGTkxFTkJRVU03UTBGRE4wSXNRMEZCUXpzN1FVRkZSaXhKUVVGSkxFbEJRVWtzUjBGQlJ5eGpRVUZUTEV0QlFVc3NSVUZCUlR0QlFVTjZRaXhOUVVGSkxFdEJRVXNzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRVZCUVVVN1FVRkRNVUlzVjBGQlR5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1IwRkRja0k3UVVGRFJDeFBRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSVHRCUVVOeVF5eFRRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03UjBGRGFrSTdRMEZEUml4RFFVRkRPenRCUVVWR0xFbEJRVWtzV1VGQldTeEhRVUZITEhOQ1FVRlRMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVVU3UVVGRGVrTXNUVUZCU1N4SlFVRkpMRWRCUVVjc1MwRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF6dEJRVU0xUWl4VFFVRlBMRWxCUVVrc1MwRkJTeXhKUVVGSkxFVkJRVVU3UVVGRGNFSXNVVUZCU1N4SlFVRkpMRXRCUVVzc1RVRkJUU3hGUVVGRk8wRkJRMjVDTEdGQlFVOHNTVUZCU1N4RFFVRkRPMHRCUTJJN1FVRkRSQ3hSUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXp0SFFVTjRRanRCUVVORUxGTkJRVThzUzBGQlN5eERRVUZETzBOQlEyUXNRMEZCUXpzN1FVRkZSaXhKUVVGSkxGbEJRVmtzUjBGQlJ5eHpRa0ZCVXl4SlFVRkpMRVZCUVVVN1FVRkRhRU1zVFVGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRWRCUVVjc1UwRkJVeXhEUVVGRE8wRkJRelZDTEUxQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhIUVVGSExFOUJRVThzUTBGQlF6czdRVUZGTjBJc1RVRkJTU3hOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWazdUVUZETVVJc1QwRkJUeXhEUVVGRE8wRkJRMW9zVFVGQlNTeFBRVUZQTEdkQ1FVRm5RaXhMUVVGTExGZEJRVmNzUlVGQlJUczdRVUZETTBNc1YwRkJUeXhIUVVGSExGRkJRVkVzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhoUVVGaExFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0SFFVTm9SaXhOUVVGTk8wRkJRMHdzVjBGQlR5eEhRVUZITEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBkQlF5OURPenRCUVVWRUxFMUJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SFFVRkhMRVZCUVVVc1EwRkJRenRCUVVOeVFpeE5RVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1IwRkJSeXhOUVVGTkxFTkJRVU03UVVGRE5VSXNVMEZCVVN4SFFVRkhMRWRCUVVjc1VVRkJVU3hEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEU5QlFVOHNRMEZCUVN4SFFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlJUdERRVU40UkN4RFFVRkRPenRCUVVWR0xFbEJRVWtzVFVGQlRTeEhRVUZITEdkQ1FVRlRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFVkJRVVU3UVVGRGNFTXNUVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eEhRVUZITEVOQlFVTXNSVUZCUlR0QlFVTXpRaXhaUVVGUkxFZEJRVWNzVVVGQlVTeEpRVUZKTEVWQlFVVXNRMEZCUXp0QlFVTXhRaXhSUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNSMEZCUnl4RFFVRkRMRU5CUVVNN1FVRkRka0lzVVVGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRWRCUVVjc1QwRkJUeXhEUVVGRE8wRkJRemRDTEZGQlFVa3NTVUZCU1N4SFFVRkhMRU5CUVVNc1NVRkJTU3hKUVVGSkxFVkJRVVVzUTBGQlF6dEJRVU4yUWl4UlFVRkpMRWxCUVVrN096czdPenM3T3pzN1QwRkJSeXhaUVVGWE8wRkJRM0JDTEZWQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRWRCUVVjc1EwRkJReXhKUVVGSkxFbEJRVWtzUlVGQlJTeEhRVUZITEVsQlFVa3NRMEZCUVN4SFFVRkpMRWRCUVVjc1EwRkJRenRCUVVOeVJTeFZRVUZKTEVkQlFVY3NRMEZCUXl4SlFVRkpMRWxCUVVrc1JVRkJSU3hEUVVGRE96dEJRVVZ1UWl4VlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVkQlFVY3NRMEZCUXl4RlFVRkZPMEZCUXpOQ0xHdENRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8wOUJRelZDTzB0QlEwWXNRMEZCUVN4RFFVRkRPMEZCUTBZc1VVRkJTU3hGUVVGRkxFTkJRVU03UjBGRFVqdEJRVU5FTEUxQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhIUVVGSExFOUJRVThzUTBGQlF6dERRVU01UWl4RFFVRkRPenRCUVVWR0xFbEJRVWtzVDBGQlR5eEhRVUZITEdsQ1FVRlRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFVkJRVVU3UVVGRGNrTXNWVUZCVVN4SFFVRkhMRkZCUVZFc1NVRkJTU3hGUVVGRkxFTkJRVU03UVVGRE1VSXNUVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFZEJRVWNzUTBGQlF5eERRVUZETzBGQlEzWkNMRTFCUVVrc1NVRkJTU3hIUVVGSExFTkJRVU1zU1VGQlNTeEpRVUZKTEVWQlFVVXNRMEZCUXp0QlFVTjJRaXhOUVVGSkxFbEJRVWs3T3pzN096czdPenM3UzBGQlJ5eFpRVUZYTzBGQlEzQkNMRkZCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFZEJRVWNzUTBGQlF5eEpRVUZKTEVsQlFVa3NSVUZCUlN4SFFVRkhMRWxCUVVrc1EwRkJRU3hIUVVGSkxFZEJRVWNzUTBGQlF6dEJRVU55UlN4UlFVRkpMRWRCUVVjc1EwRkJReXhKUVVGSkxFbEJRVWtzUlVGQlJTeERRVUZET3p0QlFVVnVRaXhSUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRWRCUVVjc1EwRkJReXhGUVVGRk8wRkJRek5DTEdkQ1FVRlZMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzB0QlF6VkNMRTFCUVUwN1FVRkRUQ3hWUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1MwRkROMEk3UjBGRFJpeERRVUZCTEVOQlFVTTdRVUZEUml4TlFVRkpMRVZCUVVVc1EwRkJRenREUVVOU0xFTkJRVU03TzBGQlJVWXNTVUZCU1N4VFFVRlRMRWRCUVVjc2JVSkJRVk1zU1VGQlNTeEZRVUZGT3pzN1FVRkhOMElzVFVGQlNTeFBRVUZQTEZWQlFWVXNTMEZCU3l4VlFVRlZMRVZCUVVVN08wRkJSWEJETEZGQlFVa3NTVUZCU1N4SFFVRkhMRWxCUVVrc1ZVRkJWU3hEUVVGRExFOUJRVThzUlVGQlJUdEJRVU5xUXl4VlFVRkpMRVZCUVVVc1RVRkJUVHRCUVVOYUxHRkJRVThzUlVGQlJTeExRVUZMTzBGQlEyUXNaMEpCUVZVc1JVRkJSU3hKUVVGSk8wdEJRMnBDTEVOQlFVTXNRMEZCUXp0QlFVTklMRkZCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdSMEZETVVJc1RVRkJUU3hKUVVGTExGRkJRVkVzUTBGQlF5eFhRVUZYTEVWQlFVYzdPMEZCUldwRExGRkJRVWtzUjBGQlJ5eEhRVUZITEZGQlFWRXNRMEZCUXl4WFFVRlhMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03UVVGRE9VTXNUMEZCUnl4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFVkJRVVVzUzBGQlN5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMEZCUTNKRExGRkJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1IwRkRla0lzVFVGQlRTeEpRVUZKTEZGQlFWRXNRMEZCUXl4cFFrRkJhVUlzUlVGQlJUdEJRVU55UXl4UlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZGTzBkQlF6VkNMRTFCUVUwc1NVRkJTU3hQUVVGUExFbEJRVWtzUTBGQlF5eFBRVUZQTEV0QlFVc3NWVUZCVlN4RlFVRkhPMEZCUXpsRExGRkJRVWtzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0SFFVTm9RanREUVVOR0xFTkJRVU03TzBGQlJVWXNTVUZCU1N4dlFrRkJiMElzUjBGQlJ5dzRRa0ZCVXl4RFFVRkRMRVZCUVVVN08wRkJSWEpETEUxQlFVa3NUMEZCVHl4RFFVRkRMRU5CUVVNc1pVRkJaU3hMUVVGTExGVkJRVlVzUlVGQlJUdEJRVU16UXl4TFFVRkRMRU5CUVVNc1pVRkJaU3hGUVVGRkxFTkJRVU03UVVGRGNFSXNTMEZCUXl4RFFVRkRMR05CUVdNc1JVRkJSU3hEUVVGRE8wZEJRM0JDTEUxQlFVMHNTVUZCU1N4TlFVRk5MRU5CUVVNc1MwRkJTeXhKUVVGSkxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNZMEZCWXl4RFFVRkRMR05CUVdNc1EwRkJReXhGUVVGRk8wRkJRM1JGTEZWQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1dVRkJXU3hIUVVGSExFbEJRVWtzUTBGQlF6dEhRVU5zUXp0RFFVTkdMRU5CUVVNN08xRkJSMEVzVVVGQlVTeEhRVUZTTEZGQlFWRTdVVUZCUlN4UlFVRlJMRWRCUVZJc1VVRkJVVHRSUVVGRkxGZEJRVmNzUjBGQldDeFhRVUZYTzFGQlF5OUNMRlZCUVZVc1IwRkJWaXhWUVVGVk8xRkJRMVlzUzBGQlN5eEhRVUZNTEV0QlFVczdVVUZCUlN4SlFVRkpMRWRCUVVvc1NVRkJTVHRSUVVGRkxFdEJRVXNzUjBGQlRDeExRVUZMTzFGQlFVVXNTVUZCU1N4SFFVRktMRWxCUVVrN1VVRkRlRUlzV1VGQldTeEhRVUZhTEZsQlFWazdVVUZEV2l4WlFVRlpMRWRCUVZvc1dVRkJXVHRSUVVOYUxFMUJRVTBzUjBGQlRpeE5RVUZOTzFGQlFVVXNUMEZCVHl4SFFVRlFMRTlCUVU4N1VVRkRaaXhUUVVGVExFZEJRVlFzVTBGQlV6dFJRVU5VTEc5Q1FVRnZRaXhIUVVGd1FpeHZRa0ZCYjBJN096czdPenM3T3pzNFEwTXZTakJDTEdOQlFXTTdPelpDUVVOb1F5eHRRa0ZCYlVJN08wRkJSMnBFTEVsQlFVa3NZVUZCWVN4SFFVRkhMSFZDUVVGVExFdEJRVXNzUlVGQlJTeE5RVUZOTEVWQlFVVXNTMEZCU3l4RlFVRkZPMEZCUTJwRUxFMUJRVWtzUTBGQlF5eEhRVUZITEV0QlFVc3NTVUZCU1N4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRemxDTEUxQlFVa3NUMEZCVHl4SFFVRkhMRU5CUVVNc1EwRkJReXhQUVVGUExFbEJRVWtzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXpzN1FVRkZia01zVFVGQlNTeFRRVUZUTEVkQlFVOHNTMEZCU3l4RFFVRkRMR0ZCUVdFc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRPMEZCUXpGRUxFMUJRVWtzWVVGQllTeEhRVUZITEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU03UVVGRGVrUXNUVUZCU1N4aFFVRmhMRWRCUVVjc1MwRkJTeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMR3RDUVVGclFpeERRVUZETEVOQlFVTTdPMEZCUnk5RUxFMUJRVWtzUTBGQlF5eERRVUZETEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFVkJRVVU3TzBGQlJUTkRMRmRCUVU4N1IwRkRVanM3UVVGRlJDeE5RVUZKTEdOQlFXTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1RVRkJUU3hKUVVGSkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTTdPMEZCUlRsRExFMUJRVWtzVVVGQlVTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTJ4Q0xFOUJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhoUVVGaExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMEZCUXpkRExGRkJRVWtzWTBGQll5eExRVUZMTEdGQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSVHRCUVVOMlF5eGpRVUZSTEVkQlFVY3NRMEZCUXl4RFFVRkRPMEZCUTJJc1dVRkJUVHRMUVVOUU8wZEJRMFk3TzBGQlJVUXNUVUZCU1N4UFFVRlBMRXRCUVVzc1EwRkJReXhGUVVGRk96dEJRVVZxUWl4UlFVRkpMRkZCUVZFc1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJUczdRVUZGYmtJc2IwSkJRV01zUjBGQlJ5eFRRVUZUTEVOQlFVTTdTMEZETlVJc1RVRkJUVHM3UVVGRlRDeFZRVUZKTEZGQlFWRXNTMEZCU3l4aFFVRmhMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdEJRVU42UXl4elFrRkJZeXhIUVVGSExHRkJRV0VzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UFFVTnVReXhOUVVGTk8wRkJRMHdzYzBKQlFXTXNSMEZCUnl4aFFVRmhMRU5CUVVNc1VVRkJVU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzA5QlF6bERPMHRCUTBZN08wRkJSVVFzYjBOQk1VTkxMRzlDUVVGdlFpeERRVEJEU2l4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVONFFpeHJRa0ZCWXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRE96dEJRVVYyUWl4UlFVRkpMRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNSVUZCUlR0QlFVTTNRaXh4UWtFM1EwY3NZVUZCWVN4RFFUWkRSaXhqUVVGakxFVkJRVVVzVFVGQlRTeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03UzBGRE1VUTdSMEZEUml4TlFVRk5PMEZCUTB3c1VVRkJTU3hQUVVGUExFdEJRVXNzUlVGQlJTeEZRVUZGTzBGQlEyeENMRlZCUVVrc1kwRkJZeXhEUVVGRExFOUJRVThzUzBGQlN5eFBRVUZQTEVWQlFVVTdRVUZEZEVNc2MwSkJRV01zUjBGQlJ5eFRRVUZUTEVOQlFVTTdRVUZETTBJc2FVSkJRVk1zUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXp0UFFVTnVRanM3UVVGRlJDeFZRVUZKTEZGQlFWRXNTMEZCU3l4RFFVRkRMRU5CUVVNc1JVRkJSVHM3UVVGRmJrSXNjMEpCUVdNc1IwRkJSeXhUUVVGVExFTkJRVU03VDBGRE5VSXNUVUZCVFRzN1FVRkZUQ3h6UWtGQll5eEhRVUZITEZOQlFWTXNRMEZCUXp0UFFVTTFRanRMUVVOR0xFMUJRVTBzU1VGQlNTeFBRVUZQTEV0QlFVc3NSVUZCUlN4SlFVRkpMRTFCUVUwc1EwRkJReXhqUVVGakxFdEJRVXNzU1VGQlNTeEZRVUZGTzBGQlF6TkVMRzlDUVVGakxFZEJRVWNzWVVGQllTeERRVUZETzBGQlF5OUNMSE5EUVdoRmVVSXNVMEZCVXl4RFFXZEZlRUlzWTBGQll5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMHRCUXpsQ0xFMUJRVTA3TzBGQlJVd3NiMEpCUVdNc1IwRkJSeXhUUVVGVExFTkJRVU03UzBGRE5VSTdSMEZEUmp0RFFVTkdMRU5CUVVNN08zRkNRVVZoTEdGQlFXRTdPenM3T3pzN096czdPenQzUWtONFJVZ3NVMEZCVXpzN05rUkJRMmRETEdOQlFXTTdPelpDUVVOMFJDeHJRa0ZCYTBJN096czdPenM3T3pSQ1FWRnVRaXhwUWtGQmFVSTdPenM3UVVGT01VTXNTVUZCU1N4VlFVRlZMRWRCUVVzc1kwRkJZeXhEUVVGRE8wRkJRMnhETEVsQlFVa3NXVUZCV1N4SFFVRkhMR2RDUVVGblFpeERRVUZET3p0QlFVOXdReXhKUVVGSkxHOUNRVUZ2UWl4SFFVRkhMR2REUVVGWE8wRkJRM0JETEUxQlFVa3NVMEZCVXl4SFFVRkhMRkZCUVZFc1EwRkJReXhoUVVGaExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdRVUZET1VNc1YwRkJVeXhEUVVGRExGTkJRVk1zTkVKQlFXVXNRMEZCUXpzN08wRkJSMjVETEZOQlFVOHNVMEZCVXl4RFFVRkRMRlZCUVZVc1JVRkJSVHRCUVVNelFpeFpRVUZSTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhUUVVGVExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdSMEZEYWtRN1EwRkRSaXhEUVVGRE96czdPenRCUVV0R0xFbEJRVWtzVVVGQlVUczdPenM3T3pzN096dEhRVUZITEZsQlFWYzdRVUZEZUVJc1RVRkJTU3hOUVVGTkxFZEJRVWNzVVVGQlVTeERRVUZETEdGQlFXRXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJRenM3UVVGRmFFUXNUVUZCU1N4RFFVRkRMRTFCUVUwc1JVRkJSVHRCUVVOWUxIZENRVUZ2UWl4RlFVRkZMRU5CUVVNN1FVRkRka0lzVlVGQlRTeEhRVUZITEZGQlFWRXNSVUZCUlN4RFFVRkRPMGRCUTNKQ096dEJRVVZFTEZOQlFVOHNUVUZCVFN4RFFVRkRPME5CUTJZc1EwRkJRU3hEUVVGRE96czdPenRCUVV0R0xFbEJRVWtzVVVGQlVTeEhRVUZITEc5Q1FVRlhPMEZCUTNoQ0xFMUJRVWtzVFVGQlRTeEhRVUZITEZGQlFWRXNSVUZCUlN4RFFVRkRPMEZCUTNoQ0xFMUJRVWtzVFVGQlRTeEZRVUZGTzBGQlExWXNWMEZCVHl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBkQlEzUkRPME5CUTBZc1EwRkJRenM3T3pzN1FVRkxSaXhKUVVGSkxGVkJRVlVzUjBGQlJ5eHpRa0ZCVnp0QlFVTXhRaXhUUVVGUExGRkJRVkVzUTBGQlF5eGhRVUZoTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNN1EwRkROME1zUTBGQlF6czdPenM3UVVGTFJpeEpRVUZKTEdGQlFXRXNSMEZCUnl4MVFrRkJVeXhQUVVGUExFVkJRVVVzVDBGQlR5eEZRVUZGTzBGQlF6ZERMRTFCUVVrc1VVRkJVU3hIUVVGSExGVkJla1JTTEZGQlFWRXNRMEY1UkZNc1QwRkJUeXhEUVVGRExFTkJRVU03UVVGRGFrTXNVMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFZEJRVWNzWlVGQlpTeEhRVUZITEZGQlFWRXNSMEZCUnl3MlEwRkJOa01zUTBGQlF6dERRVU4wUnl4RFFVRkRPenM3T3p0QlFVdEdMRWxCUVVrc1UwRkJVeXhIUVVGSExHMUNRVUZUTEZGQlFWRXNSVUZCUlR0QlFVTnFReXhOUVVGSkxFMUJRVTBzUjBGQlJ5eFJRVUZSTEVWQlFVVXNRMEZCUXp0QlFVTjRRaXhwUkVGcVJXdERMRTFCUVUwc1EwRnBSV3BETEZWQlFWVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8wRkJRM3BDTEdsRVFXeEZNRU1zU1VGQlNTeERRV3RGZWtNc1RVRkJUU3hEUVVGRExFTkJRVU03UVVGRFlpeHBSRUZ1UldkRUxGRkJRVkVzUTBGdFJTOURMRTFCUVUwc1JVRkJSU3huUWtGQlowSXNRMEZCUXl4RFFVRkRPMEZCUTI1RExHbEVRWEJGVHl4WFFVRlhMRU5CYjBWT0xFMUJRVTBzUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRE96dEJRVVYwUXl4UlFVRk5MRU5CUVVNc2NVSkJRWEZDTEVkQlFVY3NVVUZCVVN4RFFVRkRMR0ZCUVdFc1EwRkJRenRCUVVOMFJDeE5RVUZKTEZOQlFWTXNSMEZCUnl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNN1FVRkRka1FzVjBGQlV5eERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPenRCUVVWc1FpeFpRVUZWTEVOQlFVTXNXVUZCV1R0QlFVTnlRaXh0UkVFelJUaERMRkZCUVZFc1EwRXlSVGRETEUxQlFVMHNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRIUVVNM1FpeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPenRCUVVWU0xFMUJRVWtzUzBGQlN5eEhRVUZITEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU03TzBGQlJUbERMRTFCUVVrc1MwRkJTeXhMUVVGTExFMUJRVTBzU1VGQlNTeExRVUZMTEV0QlFVc3NSVUZCUlN4RlFVRkZPMEZCUTNCRExGRkJRVWtzWVVGQllTeEhRVUZITEZGQlFWRXNRMEZCUXp0QlFVTTNRaXhWUVVGTkxFTkJRVU1zVDBGQlR5eEhRVUZITEZWQlFWVXNRMEZCUXl4WlFVRlhPMEZCUTNKRExGVkJRVWtzYTBKQlFXdENMRWRCUVVrc1EwRkJReXhoUVVGaExFbEJRVWtzU1VGQlNTeERRVUZCTEVsQlFVc3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4TFFVRkxMRTFCUVUwc1FVRkJReXhEUVVGRE8wRkJReTlITEZWQlFVa3NhMEpCUVd0Q0xFVkJRVVU3UVVGRGRFSXNjVUpCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFBRVU55UWl4TlFVTkpPMEZCUTBnc2EwSkJRVlVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXp0UFFVTndRanRMUVVOR0xFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdSMEZEV0R0RFFVTkdMRU5CUVVNN096czdPenRCUVUxR0xFbEJRVWtzVlVGQlZTeEhRVUZITEhOQ1FVRlhPMEZCUXpGQ0xFMUJRVWtzVFVGQlRTeEhRVUZITEZGQlFWRXNSVUZCUlN4RFFVRkRPMEZCUTNoQ0xFMUJRVWtzVFVGQlRTeEhRVUZITEZGQlFWRXNSVUZCUlN4RFFVRkRPenRCUVVWNFFpeHBSRUYwUjA4c1YwRkJWeXhEUVhOSFRpeE5RVUZOTEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNN1FVRkRiRU1zVVVGQlRTeERRVUZETEV0QlFVc3NSMEZCUnl3eVFrRkJZeXhWUVVGVkxFTkJRVU03UVVGRGVFTXNVVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFVkJRVVVzTWtKQlFXTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1FVRkRja1FzVVVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4aFFVRmhMRVZCUVVVc01rSkJRV01zWjBKQlFXZENMRU5CUVVNc1EwRkJRenM3UVVGRmJrVXNhVUpCUVdVc1JVRkJSU3hEUVVGRE8wTkJRMjVDTEVOQlFVTTdPMEZCUjBZc1NVRkJTU3hsUVVGbExFZEJRVWNzZVVKQlFWTXNTMEZCU3l4RlFVRkZPenRCUVVWd1F5eE5RVUZKTEV0QlFVc3NTVUZCU1N4TFFVRkxMRU5CUVVNc1QwRkJUeXhMUVVGTExFVkJRVVVzUlVGQlJUdEJRVU5xUXl4WFFVRlBMRXRCUVVzc1EwRkJRenRIUVVOa096dEJRVVZFTEUxQlFVa3NUVUZCVFN4SFFVRkhMRkZCUVZFc1JVRkJSU3hEUVVGRE96dEJRVVY0UWl4TlFVRkpMRlZCUVZVc1IwRkJSeXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03UVVGRGVrUXNhVVJCZUVoUExGZEJRVmNzUTBGM1NFNHNWVUZCVlN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE96dEJRVVZvUXl4TlFVRkpMR1ZCUVdVc1IwRkJSeXhOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEhGQ1FVRnhRaXhEUVVGRExFTkJRVU03UVVGRGJFVXNhVVJCTTBoUExGZEJRVmNzUTBFeVNFNHNaVUZCWlN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8wTkJRM1JETEVOQlFVTTdPenM3TzBGQlRVWXNTVUZCU1N4dFFrRkJiVUlzUjBGQlJ5d3JRa0ZCVnp0QlFVTnVReXhOUVVGSkxFMUJRVTBzUjBGQlJ5eFJRVUZSTEVWQlFVVXNRMEZCUXp0QlFVTjRRaXhSUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNSMEZCUnl3clEwRndTVXdzV1VGQldTeERRVzlKVFN4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8wTkJRMjVFTEVOQlFVTTdPMUZCU1VFc2IwSkJRVzlDTEVkQlFYQkNMRzlDUVVGdlFqdFJRVU53UWl4UlFVRlJMRWRCUVZJc1VVRkJVVHRSUVVOU0xGVkJRVlVzUjBGQlZpeFZRVUZWTzFGQlExWXNVVUZCVVN4SFFVRlNMRkZCUVZFN1VVRkRVaXhoUVVGaExFZEJRV0lzWVVGQllUdFJRVU5pTEZOQlFWTXNSMEZCVkN4VFFVRlRPMUZCUTFRc1ZVRkJWU3hIUVVGV0xGVkJRVlU3VVVGRFZpeGxRVUZsTEVkQlFXWXNaVUZCWlR0UlFVTm1MRzFDUVVGdFFpeEhRVUZ1UWl4dFFrRkJiVUk3T3pzN096czdPMEZEYkVweVFpeEpRVUZKTEZsQlFWazdPenRCUVVka096czdOa0pCUnpKQ096czdhMDFCVVd4Q096czdOa2hCVFVFN096dDFRMEZIT0VJN096c3JUa0ZUT1VJc05FTkJSV2RET3pzN05FcEJVVE5DT3pzN05FZEJUVXc3T3p0eFRrRk5PRU03T3pzMlNVRlRPVU03T3p0UlFVZEVMRU5CUVVNN08zRkNRVVZKTEZsQlFWazdPenM3T3pzN096czdjVUpEYUVWd1FpeFRRVUZUT3pzclEwRk5WQ3h0UWtGQmJVSTdPemhGUVUxdVFpeGpRVUZqT3p0QlFXaENja0lzU1VGQlNTeFZRVUZWTEVkQlFVY3NRMEZCUXl4UFFVRlBMRVZCUVVVc1UwRkJVeXhGUVVGRkxFMUJRVTBzUlVGQlJTeFRRVUZUTEVWQlFVVXNUMEZCVHl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE96czdPenRCUVhOQ05VVXNTVUZCU1N4aFFVRmhMRWRCUVVjc2RVSkJRVk1zVFVGQlRTeEZRVUZGTzBGQlEyNURMRTFCUVVrc1MwRkJTeXhIUVVGSExHbERRV2hDV2l4UlFVRlJMRVZCWjBKakxFTkJRVU03TzBGQlJYWkNMRTFCUVVrc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eGhRVUZoTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1FVRkRka01zVFVGQlNTeExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMR0ZCUVdFc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dEJRVU55UXl4TlFVRkpMRlZCUVZVc1IwRkJSeXhMUVVGTExFTkJRVU1zWVVGQllTeERRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRPMEZCUTNSRUxFMUJRVWtzVjBGQlZ5eEhRVUZITEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXpzN096czdRVUZMZUVRc1VVRkJUU3hEUVVGRExGTkJRVk1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4SFFVRkhMRTFCUVUwc1EwRkJReXhMUVVGTExFZEJRVWNzWjBWQmJrSm9SQ3hWUVVGVkxFTkJiVUpwUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6czdPenM3UVVGTGJFY3NUMEZCU3l4RFFVRkRMRk5CUVZNc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRWRCUVVjc1owVkJlRUk1UXl4VlFVRlZMRU5CZDBJclF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03UVVGRGNrY3NUVUZCU1N4TlFVRk5MRU5CUVVNc1NVRkJTU3hGUVVGRkxHZEZRWGhDVml4SlFVRkpMRU5CZDBKWExFdEJRVXNzUTBGQlF5eERRVUZET3pzN096dEJRVXMzUWl4TlFVRkpMRTFCUVUwc1EwRkJReXhYUVVGWExFVkJRVVU3UVVGRGRFSXNiMFZCYUVOUkxGRkJRVkVzUTBGblExQXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dEJRVU53UXl4VFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExHMUNRVUZ0UWl4RlFVRkZMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF6dEhRVU0zUkN4TlFVRk5PenRCUVVWTUxGRkJRVWtzVjBGQlZ5eEhRVUZITEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNRMEZCUXp0QlFVTXhSQ3h2UlVGeVEydENMRmRCUVZjc1EwRnhRMnBDTEV0QlFVc3NSVUZCUlN4WFFVRlhMRU5CUVVNc1EwRkJRenRCUVVOb1F5eFRRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRzFDUVVGdFFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGRCUXpkRE96czdPenRCUVV0RUxHdEZRVEZEYjBJc1NVRkJTU3hEUVRCRGJrSXNTMEZCU3l4RFFVRkRMR2RDUVVGblFpeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN08wRkJSWHBETEUxQlFVa3NUVUZCVFN4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFOUJlRVJ3UWl4TFFVRkxMRVZCZDBSelFpeEZRVUZGT3pzN1FVRkZNMElzVlVGQlNTeFRRVUZUTEVkQlFVY3NTMEZCU3l4RFFVRkRPenRCUVVWMFFpeFhRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVlVGQlZTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRCUVVNeFF5eFpRVUZKTEUxQlFVMHNRMEZCUXl4SlFVRkpMRXRCUVVzc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTzBGQlEycERMRzFDUVVGVExFZEJRVWNzU1VGQlNTeERRVUZETzBGQlEycENMR2RDUVVGTk8xTkJRMUE3VDBGRFJqczdRVUZGUkN4VlFVRkpMRU5CUVVNc1UwRkJVeXhGUVVGRk8wRkJRMlFzWTBGQlRTeERRVUZETEhOQ1FVRnpRaXhIUVVGSExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0QlFVTTNRenRoUVVGUExFdEJRVXM3VlVGQlF6dFBRVU5rT3p0QlFVVkVMRlZCUVVrc1kwRkJZeXhIUVVGSExFTkJRVU1zVTBGQlV5eEZRVUZGTEU5QlFVOHNSVUZCUlN4VFFVRlRMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03UVVGRE4wUXNWVUZCU1N4TFFVRkxMRmxCUVVFc1EwRkJRenM3UVVGRlZpeFZRVUZKTEdOQlFXTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZPMEZCUXpsRExHRkJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNZVUZCWVN4RFFVRkRMRmRCUVZjc1IwRkJSeXhMUVVGTExFZEJRVWNzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMEZCUXk5RUxIZEZRV3BGUnl4SlFVRkpMRU5CYVVWR0xFdEJRVXNzUTBGQlF5eERRVUZETzA5QlEySTdPMEZCUlVRc1ZVRkJTU3hOUVVGTkxFZEJRVWNzYVVOQk0wVm1MRkZCUVZFc1JVRXlSV2xDTEVOQlFVTTdPenRCUVVkNFFpeGpRVUZSTEUxQlFVMHNRMEZCUXl4SlFVRkpPenRCUVVWcVFpeGhRVUZMTEZOQlFWTTdRVUZEV2l3d1JVRTFSVWtzVVVGQlVTeERRVFJGU0N4TFFVRkxMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03UVVGRE0wSXNNRVZCTjBWSkxGRkJRVkVzUTBFMlJVZ3NTMEZCU3l4RFFVRkRMR0ZCUVdFc1EwRkJReXhUUVVGVExFTkJRVU1zUlVGQlJTeHRRa0ZCYlVJc1EwRkJReXhEUVVGRE8wRkJRemxFTERCRlFUbEZTU3hSUVVGUkxFTkJPRVZJTEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFVkJRVVVzYjBKQlFXOUNMRU5CUVVNc1EwRkJRenRCUVVOb1JTeG5Ra0ZCVFRzN1FVRkJRU3hCUVVWU0xHRkJRVXNzVDBGQlR6dEJRVU5XTERCRlFXeEdTU3hSUVVGUkxFTkJhMFpJTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUTBGQlF5eERRVUZETzBGQlEzQkRMREJGUVc1R1NTeFJRVUZSTEVOQmJVWklMRXRCUVVzc1EwRkJReXhoUVVGaExFTkJRVU1zV1VGQldTeERRVUZETEVWQlFVVXNZMEZCWXl4RFFVRkRMRU5CUVVNN1FVRkROVVFzWjBKQlFVMDdPMEZCUVVFc1FVRkZVaXhoUVVGTExGTkJRVk03UVVGRFdpd3dSVUYyUmtrc1VVRkJVU3hEUVhWR1NDeExRVUZMTEVWQlFVVXNZMEZCWXl4RFFVRkRMRU5CUVVNN1FVRkRhRU1zTUVWQmVFWkpMRkZCUVZFc1EwRjNSa2dzUzBGQlN5eERRVUZETEdGQlFXRXNRMEZCUXl4VlFVRlZMRU5CUVVNc1JVRkJSU3hwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMEZCUXpkRUxEQkZRWHBHU1N4UlFVRlJMRU5CZVVaSUxFdEJRVXNzUTBGQlF5eGhRVUZoTEVOQlFVTXNVMEZCVXl4RFFVRkRMRVZCUVVVc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXp0QlFVTTFSQ3huUWtGQlRUczdRVUZCUVN4QlFVVlNMR0ZCUVVzc1QwRkJUeXhEUVVGRE8wRkJRMklzWVVGQlN5eFJRVUZSTzBGQlExZ3NaMEpCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRCUVVNNVF5eG5Ra0ZCVFN4RFFVRkRMRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETzBGQlEycERMR2RDUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEdGQlFXRXNSVUZCUlN4TlFVRk5MRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXp0QlFVTTFSQ3d3UlVGcVIwa3NVVUZCVVN4RFFXbEhTQ3hMUVVGTExFVkJRVVVzV1VGQldTeERRVUZETEVOQlFVTTdRVUZET1VJc2IwSkJRVlVzUTBGQlF5eFpRVUZaTzBGQlEzSkNMR3RDUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdRVUZEWml4clFrRkJUU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zWlVGQlpTeERRVUZETEVOQlFVTTdWMEZEZUVRc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF6dEJRVU5TTEdkQ1FVRk5PMEZCUVVFc1QwRkRWRHM3T3pzN08wZEJRMFk3T3pzN08wRkJTMFFzVFVGQlNTeE5RVUZOTEVOQlFVTXNVVUZCVVN4RlFVRkZPMEZCUTI1Q0xGRkJRVWtzVjBGQlZ5eEhRVUZITEV0QlFVc3NRMEZCUXl4aFFVRmhMRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNRMEZCUXpzN1FVRkZOVVFzWlVGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4bFFVRmxMRWRCUVVjc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eFJRVUZSTEVkQlFVY3NSMEZCUnl4RFFVRkRPMEZCUTI1RkxHOUZRUzlIU3l4SlFVRkpMRU5CSzBkS0xGZEJRVmNzUTBGQlF5eERRVUZET3p0QlFVVnNRaXhSUVVGSkxGTkJRVk1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdRVUZEYmtJc1VVRkJTU3hWUVVGVkxFZEJRVWNzUlVGQlJTeERRVUZET3p0QlFVVndRaXhSUVVGSkxFMUJRVTBzUTBGQlF5eFRRVUZUTEVWQlFVVTdRVUZEY0VJc1ZVRkJTU3hWUVVGVkxFZEJRVWNzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdRVUZEZUVRc1ZVRkJTU3hSUVVGUkxFZEJRVWNzVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUXpkQ0xGVkJRVWtzVTBGQlV5eEhRVUZITEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenM3UVVGRk9VSXNWVUZCU1N4RFFVRkRMRkZCUVZFc1NVRkJTU3hEUVVGRExGTkJRVk1zUlVGQlJUdEJRVU16UWl4alFVRk5MRU5CUVVNc2EwVkJRV3RGTEVkQlFVY3NUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRE8wOUJReTlHTEUxQlFVMDdRVUZEVEN4cFFrRkJVeXhIUVVGSExGRkJRVkVzUTBGQlF6dEJRVU55UWl4clFrRkJWU3hIUVVGSExGTkJRVk1zUTBGQlF6dFBRVU40UWp0TFFVTkdPenRCUVVWRUxHVkJRVmNzUTBGQlF5eFpRVUZaTEVOQlFVTXNUMEZCVHl4RlFVRkZMRmRCUVZjc1EwRkJReXhaUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NVVUZCVVN4SFFVRkhMRk5CUVZNc1IwRkJSeXhoUVVGaExFZEJRVWNzVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRPMGRCUTJwSk96czdPenRCUVV0RUxFOUJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNkMEpCUVhkQ0xFVkJRVVVzVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU03UVVGRGRFVXNUVUZCU1N4TlFVRk5MRU5CUVVNc1owSkJRV2RDTEVWQlFVVTdRVUZETTBJc1kwRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVkQlFVY3NZMEZCWXl4RFFVRkRPMGRCUXpORExFMUJRVTA3UVVGRFRDeHZSVUV6U1d0Q0xFbEJRVWtzUTBFeVNXcENMRlZCUVZVc1EwRkJReXhEUVVGRE8wZEJRMnhDT3pzN096dEJRVXRFTEU5QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc2VVSkJRWGxDTEVWQlFVVXNUVUZCVFN4RFFVRkRMR2xDUVVGcFFpeERRVUZETEVOQlFVTTdRVUZEZUVVc1RVRkJTU3hOUVVGTkxFTkJRVU1zYVVKQlFXbENMRVZCUVVVN1FVRkROVUlzWlVGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRWRCUVVjc1kwRkJZeXhEUVVGRE8wZEJRelZETEUxQlFVMDdRVUZEVEN4dlJVRnlTbXRDTEVsQlFVa3NRMEZ4U21wQ0xGZEJRVmNzUTBGQlF5eERRVUZETzBkQlEyNUNPenM3T3p0QlFVdEVMRTFCUVVrc1RVRkJUU3hEUVVGRExHZENRVUZuUWl4RlFVRkZPMEZCUXpOQ0xHTkJRVlVzUTBGQlF5eFRRVUZUTEVkQlFVY3NaMFZCTjBwNlFpeFZRVUZWTEVOQk5rb3dRaXhOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1EwRkJRenRIUVVNMVJEdEJRVU5FTEUxQlFVa3NUVUZCVFN4RFFVRkRMR2xDUVVGcFFpeEZRVUZGTzBGQlF6VkNMR1ZCUVZjc1EwRkJReXhUUVVGVExFZEJRVWNzWjBWQmFFc3hRaXhWUVVGVkxFTkJaMHN5UWl4TlFVRk5MRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXp0SFFVTTVSRHM3T3pzN1FVRkxSQ3hOUVVGSkxFMUJRVTBzUTBGQlF5eHJRa0ZCYTBJc1JVRkJSVHM3UVVGRk4wSXNaVUZCVnl4RFFVRkRMRXRCUVVzc1EwRkJReXhsUVVGbExFZEJRVWNzVFVGQlRTeERRVUZETEd0Q1FVRnJRaXhEUVVGRE96czdRVUZIT1VRc1pVRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF5eGxRVUZsTEVkQlFVY3NUVUZCVFN4RFFVRkRMSGxDUVVGNVFpeERRVUZETzBGQlEzSkZMR1ZCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zWjBKQlFXZENMRWRCUVVjc1RVRkJUU3hEUVVGRExIbENRVUY1UWl4RFFVRkRPenM3UVVGSGRFVXNjVU5CY0V4R0xHRkJRV0VzUTBGdlRFY3NWMEZCVnl4RlFVRkZMRTFCUVUwc1EwRkJReXhyUWtGQmEwSXNRMEZCUXl4RFFVRkRPMGRCUTNaRU96czdPenRCUVV0RUxFOUJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNNRUpCUVRCQ0xFVkJRVVVzVFVGQlRTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03T3pzN08wRkJTM3BGTEUxQlFVa3NaVUZCWlN4SFFVRkhMRTFCUVUwc1EwRkJReXhaUVVGWkxFZEJRVWNzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXp0QlFVTjZSQ3hQUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEhkQ1FVRjNRaXhGUVVGRkxHVkJRV1VzUTBGQlF5eERRVUZET3pzN096dEJRVXM1UkN4TlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGTkJRVk1zUlVGQlJUdEJRVU55UWl4VFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExHZENRVUZuUWl4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8wZEJRemxETEUxQlFVMHNTVUZCU1N4UFFVRlBMRTFCUVUwc1EwRkJReXhUUVVGVExFdEJRVXNzVVVGQlVTeEZRVUZGTzBGQlF5OURMRk5CUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzBkQlEzaEVMRTFCUVUwN1FVRkRUQ3hUUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzBkQlF6ZERPenM3T3p0QlFVdEVMRTlCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zV1VGQldTeEZRVUZGTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenREUVVOb1JDeERRVUZET3p0eFFrRkZZU3hoUVVGaE96czdPenM3T3pzN096czdRVU42VGpWQ0xFbEJRVWtzVFVGQlRTeEhRVUZITEdkQ1FVRlRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVU3UVVGRE1VSXNUMEZCU3l4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFVkJRVVU3UVVGRGFrSXNVVUZCU1N4RFFVRkRMRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTzBGQlEzcENMRTlCUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1MwRkRha0k3UjBGRFJqdEJRVU5FTEZOQlFVOHNRMEZCUXl4RFFVRkRPME5CUTFZc1EwRkJRenM3T3pzN1FVRkxSaXhKUVVGSkxGRkJRVkVzUjBGQlJ5eHJRa0ZCVXl4SFFVRkhMRVZCUVVVN1FVRkRNMElzVFVGQlNTeE5RVUZOTEVkQlFVY3NNa05CUVRKRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMEZCUTI1RkxGTkJRVThzVFVGQlRTeEhRVUZITEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVkQlFVY3NTVUZCU1N4SFFVRkhMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hIUVVGSExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETzBOQlEyeElMRU5CUVVNN096czdPMEZCUzBZc1NVRkJTU3hMUVVGTExFZEJRVWNzYVVKQlFWYzdRVUZEY2tJc1UwRkJVU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMR2RDUVVGblFpeERRVUZGTzBOQlEzcEVMRU5CUVVNN096czdPMEZCUzBZc1NVRkJTU3hOUVVGTkxFZEJRVWNzWjBKQlFWTXNUVUZCVFN4RlFVRkZPMEZCUXpWQ0xFMUJRVWtzVFVGQlRTeERRVUZETEU5QlFVOHNSVUZCUlRzN1FVRkZiRUlzVlVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1kwRkJZeXhIUVVGSExFMUJRVTBzUTBGQlF5eERRVUZETzBkQlF6ZERPME5CUTBZc1EwRkJRenM3T3pzN08wRkJUVVlzU1VGQlNTeGpRVUZqTEVkQlFVY3NkMEpCUVZNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJUczdRVUZGZEVNc1MwRkJSeXhIUVVGSExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1lVRkJZU3hGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzBGQlF6ZERMRTFCUVVrc1IwRkJSeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdRVUZEYkVJc1QwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBkQlF6TkVPMEZCUTBRc1MwRkJSeXhIUVVGSExFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdPenRCUVVkbUxFMUJRVWtzUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXp0QlFVTmtMRTFCUVVrc1EwRkJReXhEUVVGRE8wRkJRMDRzVFVGQlNTeERRVUZETEVOQlFVTTdPMEZCUlU0c1QwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3UVVGRGRFSXNTMEZCUXl4SFFVRkhMRkZCUVZFc1EwRkJReXhIUVVGSExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdRVUZEZGtNc1MwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzBGQlEzSkZMRTlCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eERRVUZETEVOQlFVRXNRMEZCUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzBkQlEzQkRPenRCUVVWRUxGTkJRVThzUjBGQlJ5eERRVUZETzBOQlExb3NRMEZCUXpzN1VVRkpRU3hOUVVGTkxFZEJRVTRzVFVGQlRUdFJRVU5PTEZGQlFWRXNSMEZCVWl4UlFVRlJPMUZCUTFJc1MwRkJTeXhIUVVGTUxFdEJRVXM3VVVGRFRDeE5RVUZOTEVkQlFVNHNUVUZCVFR0UlFVTk9MR05CUVdNc1IwRkJaQ3hqUVVGaklpd2labWxzWlNJNkltZGxibVZ5WVhSbFpDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUlvWm5WdVkzUnBiMjRnWlNoMExHNHNjaWw3Wm5WdVkzUnBiMjRnY3lodkxIVXBlMmxtS0NGdVcyOWRLWHRwWmlnaGRGdHZYU2w3ZG1GeUlHRTlkSGx3Wlc5bUlISmxjWFZwY21VOVBWd2lablZ1WTNScGIyNWNJaVltY21WeGRXbHlaVHRwWmlnaGRTWW1ZU2x5WlhSMWNtNGdZU2h2TENFd0tUdHBaaWhwS1hKbGRIVnliaUJwS0c4c0lUQXBPM1poY2lCbVBXNWxkeUJGY25KdmNpaGNJa05oYm01dmRDQm1hVzVrSUcxdlpIVnNaU0FuWENJcmJ5dGNJaWRjSWlrN2RHaHliM2NnWmk1amIyUmxQVndpVFU5RVZVeEZYMDVQVkY5R1QxVk9SRndpTEdaOWRtRnlJR3c5Ymx0dlhUMTdaWGh3YjNKMGN6cDdmWDA3ZEZ0dlhWc3dYUzVqWVd4c0tHd3VaWGh3YjNKMGN5eG1kVzVqZEdsdmJpaGxLWHQyWVhJZ2JqMTBXMjlkV3pGZFcyVmRPM0psZEhWeWJpQnpLRzQvYmpwbEtYMHNiQ3hzTG1WNGNHOXlkSE1zWlN4MExHNHNjaWw5Y21WMGRYSnVJRzViYjEwdVpYaHdiM0owYzMxMllYSWdhVDEwZVhCbGIyWWdjbVZ4ZFdseVpUMDlYQ0ptZFc1amRHbHZibHdpSmlaeVpYRjFhWEpsTzJadmNpaDJZWElnYnowd08yODhjaTVzWlc1bmRHZzdieXNyS1hNb2NsdHZYU2s3Y21WMGRYSnVJSE45S1NJc0lpOHZJRk4zWldWMFFXeGxjblJjYmk4dklESXdNVFF0TWpBeE5TQW9ZeWtnTFNCVWNtbHpkR0Z1SUVWa2QyRnlaSE5jYmk4dklHZHBkR2gxWWk1amIyMHZkRFIwTlM5emQyVmxkR0ZzWlhKMFhHNWNiaThxWEc0Z0tpQnFVWFZsY25rdGJHbHJaU0JtZFc1amRHbHZibk1nWm05eUlHMWhibWx3ZFd4aGRHbHVaeUIwYUdVZ1JFOU5YRzRnS2k5Y2JtbHRjRzl5ZENCN1hHNGdJR2hoYzBOc1lYTnpMQ0JoWkdSRGJHRnpjeXdnY21WdGIzWmxRMnhoYzNNc1hHNGdJR1Z6WTJGd1pVaDBiV3dzWEc0Z0lGOXphRzkzTENCemFHOTNMQ0JmYUdsa1pTd2dhR2xrWlN4Y2JpQWdhWE5FWlhOalpXNWtZVzUwTEZ4dUlDQm5aWFJVYjNCTllYSm5hVzRzWEc0Z0lHWmhaR1ZKYml3Z1ptRmtaVTkxZEN4Y2JpQWdabWx5WlVOc2FXTnJMRnh1SUNCemRHOXdSWFpsYm5SUWNtOXdZV2RoZEdsdmJseHVmU0JtY205dElDY3VMMjF2WkhWc1pYTXZhR0Z1Wkd4bExXUnZiU2M3WEc1Y2JpOHFYRzRnS2lCSVlXNWtlU0IxZEdsc2FYUnBaWE5jYmlBcUwxeHVhVzF3YjNKMElIdGNiaUFnWlhoMFpXNWtMRnh1SUNCb1pYaFViMUpuWWl4Y2JpQWdhWE5KUlRnc1hHNGdJR3h2WjFOMGNpeGNiaUFnWTI5c2IzSk1kVzFwYm1GdVkyVmNibjBnWm5KdmJTQW5MaTl0YjJSMWJHVnpMM1YwYVd4ekp6dGNibHh1THlwY2JpQXFJQ0JJWVc1a2JHVWdjM2RsWlhSQmJHVnlkQ2R6SUVSUFRTQmxiR1Z0Wlc1MGMxeHVJQ292WEc1cGJYQnZjblFnZTF4dUlDQnpkMlZsZEVGc1pYSjBTVzVwZEdsaGJHbDZaU3hjYmlBZ1oyVjBUVzlrWVd3c1hHNGdJR2RsZEU5MlpYSnNZWGtzWEc0Z0lHZGxkRWx1Y0hWMExGeHVJQ0J6WlhSR2IyTjFjMU4wZVd4bExGeHVJQ0J2Y0dWdVRXOWtZV3dzWEc0Z0lISmxjMlYwU1c1d2RYUXNYRzRnSUdacGVGWmxjblJwWTJGc1VHOXphWFJwYjI1Y2JuMGdabkp2YlNBbkxpOXRiMlIxYkdWekwyaGhibVJzWlMxemQyRnNMV1J2YlNjN1hHNWNibHh1THk4Z1NHRnVaR3hsSUdKMWRIUnZiaUJsZG1WdWRITWdZVzVrSUd0bGVXSnZZWEprSUdWMlpXNTBjMXh1YVcxd2IzSjBJSHNnYUdGdVpHeGxRblYwZEc5dUxDQm9ZVzVrYkdWRGIyNW1hWEp0TENCb1lXNWtiR1ZEWVc1alpXd2dmU0JtY205dElDY3VMMjF2WkhWc1pYTXZhR0Z1Wkd4bExXTnNhV05ySnp0Y2JtbHRjRzl5ZENCb1lXNWtiR1ZMWlhsRWIzZHVJR1p5YjIwZ0p5NHZiVzlrZFd4bGN5OW9ZVzVrYkdVdGEyVjVKenRjYmx4dVhHNHZMeUJFWldaaGRXeDBJSFpoYkhWbGMxeHVhVzF3YjNKMElHUmxabUYxYkhSUVlYSmhiWE1nWm5KdmJTQW5MaTl0YjJSMWJHVnpMMlJsWm1GMWJIUXRjR0Z5WVcxekp6dGNibWx0Y0c5eWRDQnpaWFJRWVhKaGJXVjBaWEp6SUdaeWIyMGdKeTR2Ylc5a2RXeGxjeTl6WlhRdGNHRnlZVzF6Snp0Y2JseHVMeXBjYmlBcUlGSmxiV1Z0WW1WeUlITjBZWFJsSUdsdUlHTmhjMlZ6SUhkb1pYSmxJRzl3Wlc1cGJtY2dZVzVrSUdoaGJtUnNhVzVuSUdFZ2JXOWtZV3dnZDJsc2JDQm1hV1JrYkdVZ2QybDBhQ0JwZEM1Y2JpQXFJQ2hYWlNCaGJITnZJSFZ6WlNCM2FXNWtiM2N1Y0hKbGRtbHZkWE5CWTNScGRtVkZiR1Z0Wlc1MElHRnpJR0VnWjJ4dlltRnNJSFpoY21saFlteGxLVnh1SUNvdlhHNTJZWElnY0hKbGRtbHZkWE5YYVc1a2IzZExaWGxFYjNkdU8xeHVkbUZ5SUd4aGMzUkdiMk4xYzJWa1FuVjBkRzl1TzF4dVhHNWNiaThxWEc0Z0tpQkhiRzlpWVd3Z2MzZGxaWFJCYkdWeWRDQm1kVzVqZEdsdmJseHVJQ29nS0hSb2FYTWdhWE1nZDJoaGRDQjBhR1VnZFhObGNpQmpZV3hzY3lsY2JpQXFMMXh1ZG1GeUlITjNaV1YwUVd4bGNuUXNJSE4zWVd3N1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElITjNaV1YwUVd4bGNuUWdQU0J6ZDJGc0lEMGdablZ1WTNScGIyNG9LU0I3WEc0Z0lIWmhjaUJqZFhOMGIyMXBlbUYwYVc5dWN5QTlJR0Z5WjNWdFpXNTBjMXN3WFR0Y2JseHVJQ0JoWkdSRGJHRnpjeWhrYjJOMWJXVnVkQzVpYjJSNUxDQW5jM1J2Y0MxelkzSnZiR3hwYm1jbktUdGNiaUFnY21WelpYUkpibkIxZENncE8xeHVYRzRnSUM4cVhHNGdJQ0FxSUZWelpTQmhjbWQxYldWdWRDQnBaaUJrWldacGJtVmtJRzl5SUdSbFptRjFiSFFnZG1Gc2RXVWdabkp2YlNCd1lYSmhiWE1nYjJKcVpXTjBJRzkwYUdWeWQybHpaUzVjYmlBZ0lDb2dVM1Z3Y0c5eWRITWdkR2hsSUdOaGMyVWdkMmhsY21VZ1lTQmtaV1poZFd4MElIWmhiSFZsSUdseklHSnZiMnhsWVc0Z2RISjFaU0JoYm1RZ2MyaHZkV3hrSUdKbFhHNGdJQ0FxSUc5MlpYSnlhV1JrWlc0Z1lua2dZU0JqYjNKeVpYTndiMjVrYVc1bklHVjRjR3hwWTJsMElHRnlaM1Z0Wlc1MElIZG9hV05vSUdseklHSnZiMnhsWVc0Z1ptRnNjMlV1WEc0Z0lDQXFMMXh1SUNCbWRXNWpkR2x2YmlCaGNtZDFiV1Z1ZEU5eVJHVm1ZWFZzZENoclpYa3BJSHRjYmlBZ0lDQjJZWElnWVhKbmN5QTlJR04xYzNSdmJXbDZZWFJwYjI1ek8xeHVJQ0FnSUhKbGRIVnliaUFvWVhKbmMxdHJaWGxkSUQwOVBTQjFibVJsWm1sdVpXUXBJRDhnSUdSbFptRjFiSFJRWVhKaGJYTmJhMlY1WFNBNklHRnlaM05iYTJWNVhUdGNiaUFnZlZ4dVhHNGdJR2xtSUNoamRYTjBiMjFwZW1GMGFXOXVjeUE5UFQwZ2RXNWtaV1pwYm1Wa0tTQjdYRzRnSUNBZ2JHOW5VM1J5S0NkVGQyVmxkRUZzWlhKMElHVjRjR1ZqZEhNZ1lYUWdiR1ZoYzNRZ01TQmhkSFJ5YVdKMWRHVWhKeWs3WEc0Z0lDQWdjbVYwZFhKdUlHWmhiSE5sTzF4dUlDQjlYRzVjYmlBZ2RtRnlJSEJoY21GdGN5QTlJR1Y0ZEdWdVpDaDdmU3dnWkdWbVlYVnNkRkJoY21GdGN5azdYRzVjYmlBZ2MzZHBkR05vSUNoMGVYQmxiMllnWTNWemRHOXRhWHBoZEdsdmJuTXBJSHRjYmx4dUlDQWdJQzh2SUVWNE9pQnpkMkZzS0Z3aVNHVnNiRzljSWl3Z1hDSktkWE4wSUhSbGMzUnBibWRjSWl3Z1hDSnBibVp2WENJcE8xeHVJQ0FnSUdOaGMyVWdKM04wY21sdVp5YzZYRzRnSUNBZ0lDQndZWEpoYlhNdWRHbDBiR1VnUFNCamRYTjBiMjFwZW1GMGFXOXVjenRjYmlBZ0lDQWdJSEJoY21GdGN5NTBaWGgwSUNBOUlHRnlaM1Z0Wlc1MGMxc3hYU0I4ZkNBbkp6dGNiaUFnSUNBZ0lIQmhjbUZ0Y3k1MGVYQmxJQ0E5SUdGeVozVnRaVzUwYzFzeVhTQjhmQ0FuSnp0Y2JpQWdJQ0FnSUdKeVpXRnJPMXh1WEc0Z0lDQWdMeThnUlhnNklITjNZV3dvZXlCMGFYUnNaVHBjSWtobGJHeHZYQ0lzSUhSbGVIUTZJRndpU25WemRDQjBaWE4wYVc1blhDSXNJSFI1Y0dVNklGd2lhVzVtYjF3aUlIMHBPMXh1SUNBZ0lHTmhjMlVnSjI5aWFtVmpkQ2M2WEc0Z0lDQWdJQ0JwWmlBb1kzVnpkRzl0YVhwaGRHbHZibk11ZEdsMGJHVWdQVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUNBZ0lDQnNiMmRUZEhJb0owMXBjM05wYm1jZ1hDSjBhWFJzWlZ3aUlHRnlaM1Z0Wlc1MElTY3BPMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lIQmhjbUZ0Y3k1MGFYUnNaU0E5SUdOMWMzUnZiV2w2WVhScGIyNXpMblJwZEd4bE8xeHVYRzRnSUNBZ0lDQm1iM0lnS0d4bGRDQmpkWE4wYjIxT1lXMWxJR2x1SUdSbFptRjFiSFJRWVhKaGJYTXBJSHRjYmlBZ0lDQWdJQ0FnY0dGeVlXMXpXMk4xYzNSdmJVNWhiV1ZkSUQwZ1lYSm5kVzFsYm5SUGNrUmxabUYxYkhRb1kzVnpkRzl0VG1GdFpTazdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUZOb2IzY2dYQ0pEYjI1bWFYSnRYQ0lnYVc1emRHVmhaQ0J2WmlCY0lrOUxYQ0lnYVdZZ1kyRnVZMlZzSUdKMWRIUnZiaUJwY3lCMmFYTnBZbXhsWEc0Z0lDQWdJQ0J3WVhKaGJYTXVZMjl1Wm1seWJVSjFkSFJ2YmxSbGVIUWdQU0J3WVhKaGJYTXVjMmh2ZDBOaGJtTmxiRUoxZEhSdmJpQS9JQ2REYjI1bWFYSnRKeUE2SUdSbFptRjFiSFJRWVhKaGJYTXVZMjl1Wm1seWJVSjFkSFJ2YmxSbGVIUTdYRzRnSUNBZ0lDQndZWEpoYlhNdVkyOXVabWx5YlVKMWRIUnZibFJsZUhRZ1BTQmhjbWQxYldWdWRFOXlSR1ZtWVhWc2RDZ25ZMjl1Wm1seWJVSjFkSFJ2YmxSbGVIUW5LVHRjYmx4dUlDQWdJQ0FnTHk4Z1EyRnNiR0poWTJzZ1puVnVZM1JwYjI0Z2QyaGxiaUJqYkdsamEybHVaeUJ2YmlCY0lrOUxYQ0l2WENKRFlXNWpaV3hjSWx4dUlDQWdJQ0FnY0dGeVlXMXpMbVJ2Ym1WR2RXNWpkR2x2YmlBOUlHRnlaM1Z0Wlc1MGMxc3hYU0I4ZkNCdWRXeHNPMXh1WEc0Z0lDQWdJQ0JpY21WaGF6dGNibHh1SUNBZ0lHUmxabUYxYkhRNlhHNGdJQ0FnSUNCc2IyZFRkSElvSjFWdVpYaHdaV04wWldRZ2RIbHdaU0J2WmlCaGNtZDFiV1Z1ZENFZ1JYaHdaV04wWldRZ1hDSnpkSEpwYm1kY0lpQnZjaUJjSW05aWFtVmpkRndpTENCbmIzUWdKeUFySUhSNWNHVnZaaUJqZFhOMGIyMXBlbUYwYVc5dWN5azdYRzRnSUNBZ0lDQnlaWFIxY200Z1ptRnNjMlU3WEc1Y2JpQWdmVnh1WEc0Z0lITmxkRkJoY21GdFpYUmxjbk1vY0dGeVlXMXpLVHRjYmlBZ1ptbDRWbVZ5ZEdsallXeFFiM05wZEdsdmJpZ3BPMXh1SUNCdmNHVnVUVzlrWVd3b1lYSm5kVzFsYm5Seld6RmRLVHRjYmx4dUlDQXZMeUJOYjJSaGJDQnBiblJsY21GamRHbHZibk5jYmlBZ2RtRnlJRzF2WkdGc0lEMGdaMlYwVFc5a1lXd29LVHRjYmx4dVhHNGdJQzhxWEc0Z0lDQXFJRTFoYTJVZ2MzVnlaU0JoYkd3Z2JXOWtZV3dnWW5WMGRHOXVjeUJ5WlhOd2IyNWtJSFJ2SUdGc2JDQmxkbVZ1ZEhOY2JpQWdJQ292WEc0Z0lIWmhjaUFrWW5WMGRHOXVjeUE5SUcxdlpHRnNMbkYxWlhKNVUyVnNaV04wYjNKQmJHd29KMkoxZEhSdmJpY3BPMXh1SUNCMllYSWdZblYwZEc5dVJYWmxiblJ6SUQwZ1d5ZHZibU5zYVdOckp5d2dKMjl1Ylc5MWMyVnZkbVZ5Snl3Z0oyOXViVzkxYzJWdmRYUW5MQ0FuYjI1dGIzVnpaV1J2ZDI0bkxDQW5iMjV0YjNWelpYVndKeXdnSjI5dVptOWpkWE1uWFR0Y2JpQWdkbUZ5SUc5dVFuVjBkRzl1UlhabGJuUWdQU0FvWlNrZ1BUNGdhR0Z1Wkd4bFFuVjBkRzl1S0dVc0lIQmhjbUZ0Y3l3Z2JXOWtZV3dwTzF4dVhHNGdJR1p2Y2lBb2JHVjBJR0owYmtsdVpHVjRJRDBnTURzZ1luUnVTVzVrWlhnZ1BDQWtZblYwZEc5dWN5NXNaVzVuZEdnN0lHSjBia2x1WkdWNEt5c3BJSHRjYmlBZ0lDQm1iM0lnS0d4bGRDQmxkblJKYm1SbGVDQTlJREE3SUdWMmRFbHVaR1Y0SUR3Z1luVjBkRzl1UlhabGJuUnpMbXhsYm1kMGFEc2daWFowU1c1a1pYZ3JLeWtnZTF4dUlDQWdJQ0FnYkdWMElHSjBia1YyZENBOUlHSjFkSFJ2YmtWMlpXNTBjMXRsZG5SSmJtUmxlRjA3WEc0Z0lDQWdJQ0FrWW5WMGRHOXVjMXRpZEc1SmJtUmxlRjFiWW5SdVJYWjBYU0E5SUc5dVFuVjBkRzl1UlhabGJuUTdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdMeThnUTJ4cFkydHBibWNnYjNWMGMybGtaU0IwYUdVZ2JXOWtZV3dnWkdsemJXbHpjMlZ6SUdsMElDaHBaaUJoYkd4dmQyVmtJR0o1SUhWelpYSXBYRzRnSUdkbGRFOTJaWEpzWVhrb0tTNXZibU5zYVdOcklEMGdiMjVDZFhSMGIyNUZkbVZ1ZER0Y2JseHVJQ0J3Y21WMmFXOTFjMWRwYm1SdmQwdGxlVVJ2ZDI0Z1BTQjNhVzVrYjNjdWIyNXJaWGxrYjNkdU8xeHVYRzRnSUhaaGNpQnZia3RsZVVWMlpXNTBJRDBnS0dVcElEMCtJR2hoYm1Sc1pVdGxlVVJ2ZDI0b1pTd2djR0Z5WVcxekxDQnRiMlJoYkNrN1hHNGdJSGRwYm1SdmR5NXZibXRsZVdSdmQyNGdQU0J2Ymt0bGVVVjJaVzUwTzF4dVhHNGdJSGRwYm1SdmR5NXZibVp2WTNWeklEMGdablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJQzh2SUZkb1pXNGdkR2hsSUhWelpYSWdhR0Z6SUdadlkzVnpaV1FnWVhkaGVTQmhibVFnWm05amRYTmxaQ0JpWVdOcklHWnliMjBnZEdobElIZG9iMnhsSUhkcGJtUnZkeTVjYmlBZ0lDQnpaWFJVYVcxbGIzVjBLR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0FnSUM4dklGQjFkQ0JwYmlCaElIUnBiV1Z2ZFhRZ2RHOGdhblZ0Y0NCdmRYUWdiMllnZEdobElHVjJaVzUwSUhObGNYVmxibU5sTGx4dUlDQWdJQ0FnTHk4Z1EyRnNiR2x1WnlCbWIyTjFjeWdwSUdsdUlIUm9aU0JsZG1WdWRDQnpaWEYxWlc1alpTQmpiMjVtZFhObGN5QjBhR2x1WjNNdVhHNGdJQ0FnSUNCcFppQW9iR0Z6ZEVadlkzVnpaV1JDZFhSMGIyNGdJVDA5SUhWdVpHVm1hVzVsWkNrZ2UxeHVJQ0FnSUNBZ0lDQnNZWE4wUm05amRYTmxaRUoxZEhSdmJpNW1iMk4xY3lncE8xeHVJQ0FnSUNBZ0lDQnNZWE4wUm05amRYTmxaRUoxZEhSdmJpQTlJSFZ1WkdWbWFXNWxaRHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlMQ0F3S1R0Y2JpQWdmVHRjYmlBZ1hHNGdJQzh2SUZOb2IzY2dZV3hsY25RZ2QybDBhQ0JsYm1GaWJHVmtJR0oxZEhSdmJuTWdZV3gzWVhselhHNGdJSE4zWVd3dVpXNWhZbXhsUW5WMGRHOXVjeWdwTzF4dWZUdGNibHh1WEc1Y2JpOHFYRzRnS2lCVFpYUWdaR1ZtWVhWc2RDQndZWEpoYlhNZ1ptOXlJR1ZoWTJnZ2NHOXdkWEJjYmlBcUlFQndZWEpoYlNCN1QySnFaV04wZlNCMWMyVnlVR0Z5WVcxelhHNGdLaTljYm5OM1pXVjBRV3hsY25RdWMyVjBSR1ZtWVhWc2RITWdQU0J6ZDJGc0xuTmxkRVJsWm1GMWJIUnpJRDBnWm5WdVkzUnBiMjRvZFhObGNsQmhjbUZ0Y3lrZ2UxeHVJQ0JwWmlBb0lYVnpaWEpRWVhKaGJYTXBJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0ozVnpaWEpRWVhKaGJYTWdhWE1nY21WeGRXbHlaV1FuS1R0Y2JpQWdmVnh1SUNCcFppQW9kSGx3Wlc5bUlIVnpaWEpRWVhKaGJYTWdJVDA5SUNkdlltcGxZM1FuS1NCN1hHNGdJQ0FnZEdoeWIzY2dibVYzSUVWeWNtOXlLQ2QxYzJWeVVHRnlZVzF6SUdoaGN5QjBieUJpWlNCaElHOWlhbVZqZENjcE8xeHVJQ0I5WEc1Y2JpQWdaWGgwWlc1a0tHUmxabUYxYkhSUVlYSmhiWE1zSUhWelpYSlFZWEpoYlhNcE8xeHVmVHRjYmx4dVhHNHZLbHh1SUNvZ1FXNXBiV0YwYVc5dUlIZG9aVzRnWTJ4dmMybHVaeUJ0YjJSaGJGeHVJQ292WEc1emQyVmxkRUZzWlhKMExtTnNiM05sSUQwZ2MzZGhiQzVqYkc5elpTQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQjJZWElnYlc5a1lXd2dQU0JuWlhSTmIyUmhiQ2dwTzF4dVhHNGdJR1poWkdWUGRYUW9aMlYwVDNabGNteGhlU2dwTENBMUtUdGNiaUFnWm1Ga1pVOTFkQ2h0YjJSaGJDd2dOU2s3WEc0Z0lISmxiVzkyWlVOc1lYTnpLRzF2WkdGc0xDQW5jMmh2ZDFOM1pXVjBRV3hsY25RbktUdGNiaUFnWVdSa1EyeGhjM01vYlc5a1lXd3NJQ2RvYVdSbFUzZGxaWFJCYkdWeWRDY3BPMXh1SUNCeVpXMXZkbVZEYkdGemN5aHRiMlJoYkN3Z0ozWnBjMmxpYkdVbktUdGNibHh1SUNBdktseHVJQ0FnS2lCU1pYTmxkQ0JwWTI5dUlHRnVhVzFoZEdsdmJuTmNiaUFnSUNvdlhHNGdJSFpoY2lBa2MzVmpZMlZ6YzBsamIyNGdQU0J0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5S0NjdWMyRXRhV052Ymk1ellTMXpkV05qWlhOekp5azdYRzRnSUhKbGJXOTJaVU5zWVhOektDUnpkV05qWlhOelNXTnZiaXdnSjJGdWFXMWhkR1VuS1R0Y2JpQWdjbVZ0YjNabFEyeGhjM01vSkhOMVkyTmxjM05KWTI5dUxuRjFaWEo1VTJWc1pXTjBiM0lvSnk1ellTMTBhWEFuS1N3Z0oyRnVhVzFoZEdWVGRXTmpaWE56Vkdsd0p5azdYRzRnSUhKbGJXOTJaVU5zWVhOektDUnpkV05qWlhOelNXTnZiaTV4ZFdWeWVWTmxiR1ZqZEc5eUtDY3VjMkV0Ykc5dVp5Y3BMQ0FuWVc1cGJXRjBaVk4xWTJObGMzTk1iMjVuSnlrN1hHNWNiaUFnZG1GeUlDUmxjbkp2Y2tsamIyNGdQU0J0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5S0NjdWMyRXRhV052Ymk1ellTMWxjbkp2Y2ljcE8xeHVJQ0J5WlcxdmRtVkRiR0Z6Y3lna1pYSnliM0pKWTI5dUxDQW5ZVzVwYldGMFpVVnljbTl5U1dOdmJpY3BPMXh1SUNCeVpXMXZkbVZEYkdGemN5Z2taWEp5YjNKSlkyOXVMbkYxWlhKNVUyVnNaV04wYjNJb0p5NXpZUzE0TFcxaGNtc25LU3dnSjJGdWFXMWhkR1ZZVFdGeWF5Y3BPMXh1WEc0Z0lIWmhjaUFrZDJGeWJtbHVaMGxqYjI0Z1BTQnRiMlJoYkM1eGRXVnllVk5sYkdWamRHOXlLQ2N1YzJFdGFXTnZiaTV6WVMxM1lYSnVhVzVuSnlrN1hHNGdJSEpsYlc5MlpVTnNZWE56S0NSM1lYSnVhVzVuU1dOdmJpd2dKM0IxYkhObFYyRnlibWx1WnljcE8xeHVJQ0J5WlcxdmRtVkRiR0Z6Y3lna2QyRnlibWx1WjBsamIyNHVjWFZsY25sVFpXeGxZM1J2Y2lnbkxuTmhMV0p2WkhrbktTd2dKM0IxYkhObFYyRnlibWx1WjBsdWN5Y3BPMXh1SUNCeVpXMXZkbVZEYkdGemN5Z2tkMkZ5Ym1sdVowbGpiMjR1Y1hWbGNubFRaV3hsWTNSdmNpZ25Mbk5oTFdSdmRDY3BMQ0FuY0hWc2MyVlhZWEp1YVc1blNXNXpKeWs3WEc1Y2JpQWdMeThnVW1WelpYUWdZM1Z6ZEc5dElHTnNZWE56SUNoa1pXeGhlU0J6YnlCMGFHRjBJRlZKSUdOb1lXNW5aWE1nWVhKbGJpZDBJSFpwYzJsaWJHVXBYRzRnSUhObGRGUnBiV1Z2ZFhRb1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ2RtRnlJR04xYzNSdmJVTnNZWE56SUQwZ2JXOWtZV3d1WjJWMFFYUjBjbWxpZFhSbEtDZGtZWFJoTFdOMWMzUnZiUzFqYkdGemN5Y3BPMXh1SUNBZ0lISmxiVzkyWlVOc1lYTnpLRzF2WkdGc0xDQmpkWE4wYjIxRGJHRnpjeWs3WEc0Z0lIMHNJRE13TUNrN1hHNWNiaUFnTHk4Z1RXRnJaU0J3WVdkbElITmpjbTlzYkdGaWJHVWdZV2RoYVc1Y2JpQWdjbVZ0YjNabFEyeGhjM01vWkc5amRXMWxiblF1WW05a2VTd2dKM04wYjNBdGMyTnliMnhzYVc1bkp5azdYRzVjYmlBZ0x5OGdVbVZ6WlhRZ2RHaGxJSEJoWjJVZ2RHOGdhWFJ6SUhCeVpYWnBiM1Z6SUhOMFlYUmxYRzRnSUhkcGJtUnZkeTV2Ym10bGVXUnZkMjRnUFNCd2NtVjJhVzkxYzFkcGJtUnZkMHRsZVVSdmQyNDdYRzRnSUdsbUlDaDNhVzVrYjNjdWNISmxkbWx2ZFhOQlkzUnBkbVZGYkdWdFpXNTBLU0I3WEc0Z0lDQWdkMmx1Wkc5M0xuQnlaWFpwYjNWelFXTjBhWFpsUld4bGJXVnVkQzVtYjJOMWN5Z3BPMXh1SUNCOVhHNGdJR3hoYzNSR2IyTjFjMlZrUW5WMGRHOXVJRDBnZFc1a1pXWnBibVZrTzF4dUlDQmpiR1ZoY2xScGJXVnZkWFFvYlc5a1lXd3VkR2x0Wlc5MWRDazdYRzVjYmlBZ2NtVjBkWEp1SUhSeWRXVTdYRzU5TzF4dVhHNWNiaThxWEc0Z0tpQldZV3hwWkdGMGFXOXVJRzltSUhSb1pTQnBibkIxZENCbWFXVnNaQ0JwY3lCa2IyNWxJR0o1SUhWelpYSmNiaUFxSUVsbUlITnZiV1YwYUdsdVp5QnBjeUIzY205dVp5QTlQaUJqWVd4c0lITm9iM2RKYm5CMWRFVnljbTl5SUhkcGRHZ2daWEp5YjNKTlpYTnpZV2RsWEc0Z0tpOWNibk4zWldWMFFXeGxjblF1YzJodmQwbHVjSFYwUlhKeWIzSWdQU0J6ZDJGc0xuTm9iM2RKYm5CMWRFVnljbTl5SUQwZ1puVnVZM1JwYjI0b1pYSnliM0pOWlhOellXZGxLU0I3WEc0Z0lIWmhjaUJ0YjJSaGJDQTlJR2RsZEUxdlpHRnNLQ2s3WEc1Y2JpQWdkbUZ5SUNSbGNuSnZja2xqYjI0Z1BTQnRiMlJoYkM1eGRXVnllVk5sYkdWamRHOXlLQ2N1YzJFdGFXNXdkWFF0WlhKeWIzSW5LVHRjYmlBZ1lXUmtRMnhoYzNNb0pHVnljbTl5U1dOdmJpd2dKM05vYjNjbktUdGNibHh1SUNCMllYSWdKR1Z5Y205eVEyOXVkR0ZwYm1WeUlEMGdiVzlrWVd3dWNYVmxjbmxUWld4bFkzUnZjaWduTG5OaExXVnljbTl5TFdOdmJuUmhhVzVsY2ljcE8xeHVJQ0JoWkdSRGJHRnpjeWdrWlhKeWIzSkRiMjUwWVdsdVpYSXNJQ2R6YUc5M0p5azdYRzVjYmlBZ0pHVnljbTl5UTI5dWRHRnBibVZ5TG5GMVpYSjVVMlZzWldOMGIzSW9KM0FuS1M1cGJtNWxja2hVVFV3Z1BTQmxjbkp2Y2sxbGMzTmhaMlU3WEc1Y2JpQWdjMlYwVkdsdFpXOTFkQ2htZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0J6ZDJWbGRFRnNaWEowTG1WdVlXSnNaVUoxZEhSdmJuTW9LVHRjYmlBZ2ZTd2dNU2s3WEc1Y2JpQWdiVzlrWVd3dWNYVmxjbmxUWld4bFkzUnZjaWduYVc1d2RYUW5LUzVtYjJOMWN5Z3BPMXh1ZlR0Y2JseHVYRzR2S2x4dUlDb2dVbVZ6WlhRZ2FXNXdkWFFnWlhKeWIzSWdSRTlOSUdWc1pXMWxiblJ6WEc0Z0tpOWNibk4zWldWMFFXeGxjblF1Y21WelpYUkpibkIxZEVWeWNtOXlJRDBnYzNkaGJDNXlaWE5sZEVsdWNIVjBSWEp5YjNJZ1BTQm1kVzVqZEdsdmJpaGxkbVZ1ZENrZ2UxeHVJQ0F2THlCSlppQndjbVZ6Y3lCbGJuUmxjaUE5UGlCcFoyNXZjbVZjYmlBZ2FXWWdLR1YyWlc1MElDWW1JR1YyWlc1MExtdGxlVU52WkdVZ1BUMDlJREV6S1NCN1hHNGdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0I5WEc1Y2JpQWdkbUZ5SUNSdGIyUmhiQ0E5SUdkbGRFMXZaR0ZzS0NrN1hHNWNiaUFnZG1GeUlDUmxjbkp2Y2tsamIyNGdQU0FrYlc5a1lXd3VjWFZsY25sVFpXeGxZM1J2Y2lnbkxuTmhMV2x1Y0hWMExXVnljbTl5SnlrN1hHNGdJSEpsYlc5MlpVTnNZWE56S0NSbGNuSnZja2xqYjI0c0lDZHphRzkzSnlrN1hHNWNiaUFnZG1GeUlDUmxjbkp2Y2tOdmJuUmhhVzVsY2lBOUlDUnRiMlJoYkM1eGRXVnllVk5sYkdWamRHOXlLQ2N1YzJFdFpYSnliM0l0WTI5dWRHRnBibVZ5SnlrN1hHNGdJSEpsYlc5MlpVTnNZWE56S0NSbGNuSnZja052Ym5SaGFXNWxjaXdnSjNOb2IzY25LVHRjYm4wN1hHNWNiaThxWEc0Z0tpQkVhWE5oWW14bElHTnZibVpwY20wZ1lXNWtJR05oYm1ObGJDQmlkWFIwYjI1elhHNGdLaTljYm5OM1pXVjBRV3hsY25RdVpHbHpZV0pzWlVKMWRIUnZibk1nUFNCemQyRnNMbVJwYzJGaWJHVkNkWFIwYjI1eklEMGdablZ1WTNScGIyNG9aWFpsYm5RcElIdGNiaUFnZG1GeUlHMXZaR0ZzSUQwZ1oyVjBUVzlrWVd3b0tUdGNiaUFnZG1GeUlDUmpiMjVtYVhKdFFuVjBkRzl1SUQwZ2JXOWtZV3d1Y1hWbGNubFRaV3hsWTNSdmNpZ25ZblYwZEc5dUxtTnZibVpwY20wbktUdGNiaUFnZG1GeUlDUmpZVzVqWld4Q2RYUjBiMjRnUFNCdGIyUmhiQzV4ZFdWeWVWTmxiR1ZqZEc5eUtDZGlkWFIwYjI0dVkyRnVZMlZzSnlrN1hHNGdJQ1JqYjI1bWFYSnRRblYwZEc5dUxtUnBjMkZpYkdWa0lEMGdkSEoxWlR0Y2JpQWdKR05oYm1ObGJFSjFkSFJ2Ymk1a2FYTmhZbXhsWkNBOUlIUnlkV1U3WEc1OU8xeHVYRzR2S2x4dUlDb2dSVzVoWW14bElHTnZibVpwY20wZ1lXNWtJR05oYm1ObGJDQmlkWFIwYjI1elhHNGdLaTljYm5OM1pXVjBRV3hsY25RdVpXNWhZbXhsUW5WMGRHOXVjeUE5SUhOM1lXd3VaVzVoWW14bFFuVjBkRzl1Y3lBOUlHWjFibU4wYVc5dUtHVjJaVzUwS1NCN1hHNGdJSFpoY2lCdGIyUmhiQ0E5SUdkbGRFMXZaR0ZzS0NrN1hHNGdJSFpoY2lBa1kyOXVabWx5YlVKMWRIUnZiaUE5SUcxdlpHRnNMbkYxWlhKNVUyVnNaV04wYjNJb0oySjFkSFJ2Ymk1amIyNW1hWEp0SnlrN1hHNGdJSFpoY2lBa1kyRnVZMlZzUW5WMGRHOXVJRDBnYlc5a1lXd3VjWFZsY25sVFpXeGxZM1J2Y2lnblluVjBkRzl1TG1OaGJtTmxiQ2NwTzF4dUlDQWtZMjl1Wm1seWJVSjFkSFJ2Ymk1a2FYTmhZbXhsWkNBOUlHWmhiSE5sTzF4dUlDQWtZMkZ1WTJWc1FuVjBkRzl1TG1ScGMyRmliR1ZrSUQwZ1ptRnNjMlU3WEc1OU8xeHVYRzVwWmlBb2RIbHdaVzltSUhkcGJtUnZkeUFoUFQwZ0ozVnVaR1ZtYVc1bFpDY3BJSHRjYmlBZ0x5OGdWR2hsSUNkb1lXNWtiR1V0WTJ4cFkyc25JRzF2WkhWc1pTQnlaWEYxYVhKbGMxeHVJQ0F2THlCMGFHRjBJQ2R6ZDJWbGRFRnNaWEowSnlCM1lYTWdjMlYwSUdGeklHZHNiMkpoYkM1Y2JpQWdkMmx1Wkc5M0xuTjNaV1YwUVd4bGNuUWdQU0IzYVc1a2IzY3VjM2RoYkNBOUlITjNaV1YwUVd4bGNuUTdYRzU5SUdWc2MyVWdlMXh1SUNCc2IyZFRkSElvSjFOM1pXVjBRV3hsY25RZ2FYTWdZU0JtY205dWRHVnVaQ0J0YjJSMWJHVWhKeWs3WEc1OVhHNGlMQ0oyWVhJZ1pHVm1ZWFZzZEZCaGNtRnRjeUE5SUh0Y2JpQWdkR2wwYkdVNklDY25MRnh1SUNCMFpYaDBPaUFuSnl4Y2JpQWdkSGx3WlRvZ2JuVnNiQ3hjYmlBZ1lXeHNiM2RQZFhSemFXUmxRMnhwWTJzNklHWmhiSE5sTEZ4dUlDQnphRzkzUTI5dVptbHliVUoxZEhSdmJqb2dkSEoxWlN4Y2JpQWdjMmh2ZDBOaGJtTmxiRUoxZEhSdmJqb2dabUZzYzJVc1hHNGdJR05zYjNObFQyNURiMjVtYVhKdE9pQjBjblZsTEZ4dUlDQmpiRzl6WlU5dVEyRnVZMlZzT2lCMGNuVmxMRnh1SUNCamIyNW1hWEp0UW5WMGRHOXVWR1Y0ZERvZ0owOUxKeXhjYmlBZ1kyOXVabWx5YlVKMWRIUnZia052Ykc5eU9pQW5JemhEUkRSR05TY3NYRzRnSUdOaGJtTmxiRUoxZEhSdmJsUmxlSFE2SUNkRFlXNWpaV3duTEZ4dUlDQnBiV0ZuWlZWeWJEb2diblZzYkN4Y2JpQWdhVzFoWjJWVGFYcGxPaUJ1ZFd4c0xGeHVJQ0IwYVcxbGNqb2diblZzYkN4Y2JpQWdZM1Z6ZEc5dFEyeGhjM002SUNjbkxGeHVJQ0JvZEcxc09pQm1ZV3h6WlN4Y2JpQWdZVzVwYldGMGFXOXVPaUIwY25WbExGeHVJQ0JoYkd4dmQwVnpZMkZ3WlV0bGVUb2dkSEoxWlN4Y2JpQWdhVzV3ZFhSVWVYQmxPaUFuZEdWNGRDY3NYRzRnSUdsdWNIVjBVR3hoWTJWb2IyeGtaWEk2SUNjbkxGeHVJQ0JwYm5CMWRGWmhiSFZsT2lBbkp5eGNiaUFnYzJodmQweHZZV1JsY2s5dVEyOXVabWx5YlRvZ1ptRnNjMlZjYm4wN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElHUmxabUYxYkhSUVlYSmhiWE03WEc0aUxDSnBiWEJ2Y25RZ2V5QmpiMnh2Y2t4MWJXbHVZVzVqWlNCOUlHWnliMjBnSnk0dmRYUnBiSE1uTzF4dWFXMXdiM0owSUhzZ1oyVjBUVzlrWVd3Z2ZTQm1jbTl0SUNjdUwyaGhibVJzWlMxemQyRnNMV1J2YlNjN1hHNXBiWEJ2Y25RZ2V5Qm9ZWE5EYkdGemN5d2dhWE5FWlhOalpXNWtZVzUwSUgwZ1puSnZiU0FuTGk5b1lXNWtiR1V0Wkc5dEp6dGNibHh1WEc0dktseHVJQ29nVlhObGNpQmpiR2xqYTJWa0lHOXVJRndpUTI5dVptbHliVndpTDF3aVQwdGNJaUJ2Y2lCY0lrTmhibU5sYkZ3aVhHNGdLaTljYm5aaGNpQm9ZVzVrYkdWQ2RYUjBiMjRnUFNCbWRXNWpkR2x2YmlobGRtVnVkQ3dnY0dGeVlXMXpMQ0J0YjJSaGJDa2dlMXh1SUNCMllYSWdaU0E5SUdWMlpXNTBJSHg4SUhkcGJtUnZkeTVsZG1WdWREdGNiaUFnZG1GeUlIUmhjbWRsZENBOUlHVXVkR0Z5WjJWMElIeDhJR1V1YzNKalJXeGxiV1Z1ZER0Y2JseHVJQ0IyWVhJZ2RHRnlaMlYwWldSRGIyNW1hWEp0SUQwZ2RHRnlaMlYwTG1Oc1lYTnpUbUZ0WlM1cGJtUmxlRTltS0NkamIyNW1hWEp0SnlrZ0lUMDlJQzB4TzF4dUlDQjJZWElnZEdGeVoyVjBaV1JQZG1WeWJHRjVJRDBnZEdGeVoyVjBMbU5zWVhOelRtRnRaUzVwYm1SbGVFOW1LQ2R6ZDJWbGRDMXZkbVZ5YkdGNUp5a2dJVDA5SUMweE8xeHVJQ0IyWVhJZ2JXOWtZV3hKYzFacGMybGliR1VnSUQwZ2FHRnpRMnhoYzNNb2JXOWtZV3dzSUNkMmFYTnBZbXhsSnlrN1hHNGdJSFpoY2lCa2IyNWxSblZ1WTNScGIyNUZlR2x6ZEhNZ1BTQW9jR0Z5WVcxekxtUnZibVZHZFc1amRHbHZiaUFtSmlCdGIyUmhiQzVuWlhSQmRIUnlhV0oxZEdVb0oyUmhkR0V0YUdGekxXUnZibVV0Wm5WdVkzUnBiMjRuS1NBOVBUMGdKM1J5ZFdVbktUdGNibHh1SUNBdkx5QlRhVzVqWlNCMGFHVWdkWE5sY2lCallXNGdZMmhoYm1kbElIUm9aU0JpWVdOclozSnZkVzVrTFdOdmJHOXlJRzltSUhSb1pTQmpiMjVtYVhKdElHSjFkSFJ2YmlCd2NtOW5jbUZ0YldGMGFXTmhiR3g1TEZ4dUlDQXZMeUIzWlNCdGRYTjBJR05oYkdOMWJHRjBaU0IzYUdGMElIUm9aU0JqYjJ4dmNpQnphRzkxYkdRZ1ltVWdiMjRnYUc5MlpYSXZZV04wYVhabFhHNGdJSFpoY2lCdWIzSnRZV3hEYjJ4dmNpd2dhRzkyWlhKRGIyeHZjaXdnWVdOMGFYWmxRMjlzYjNJN1hHNGdJR2xtSUNoMFlYSm5aWFJsWkVOdmJtWnBjbTBnSmlZZ2NHRnlZVzF6TG1OdmJtWnBjbTFDZFhSMGIyNURiMnh2Y2lrZ2UxeHVJQ0FnSUc1dmNtMWhiRU52Ykc5eUlDQTlJSEJoY21GdGN5NWpiMjVtYVhKdFFuVjBkRzl1UTI5c2IzSTdYRzRnSUNBZ2FHOTJaWEpEYjJ4dmNpQWdJRDBnWTI5c2IzSk1kVzFwYm1GdVkyVW9ibTl5YldGc1EyOXNiM0lzSUMwd0xqQTBLVHRjYmlBZ0lDQmhZM1JwZG1WRGIyeHZjaUFnUFNCamIyeHZja3gxYldsdVlXNWpaU2h1YjNKdFlXeERiMnh2Y2l3Z0xUQXVNVFFwTzF4dUlDQjlYRzVjYmlBZ1puVnVZM1JwYjI0Z2MyaHZkV3hrVTJWMFEyOXVabWx5YlVKMWRIUnZia052Ykc5eUtHTnZiRzl5S1NCN1hHNGdJQ0FnYVdZZ0tIUmhjbWRsZEdWa1EyOXVabWx5YlNBbUppQndZWEpoYlhNdVkyOXVabWx5YlVKMWRIUnZia052Ykc5eUtTQjdYRzRnSUNBZ0lDQjBZWEpuWlhRdWMzUjViR1V1WW1GamEyZHliM1Z1WkVOdmJHOXlJRDBnWTI5c2IzSTdYRzRnSUNBZ2ZWeHVJQ0I5WEc1Y2JpQWdjM2RwZEdOb0lDaGxMblI1Y0dVcElIdGNiaUFnSUNCallYTmxJQ2R0YjNWelpXOTJaWEluT2x4dUlDQWdJQ0FnYzJodmRXeGtVMlYwUTI5dVptbHliVUoxZEhSdmJrTnZiRzl5S0dodmRtVnlRMjlzYjNJcE8xeHVJQ0FnSUNBZ1luSmxZV3M3WEc1Y2JpQWdJQ0JqWVhObElDZHRiM1Z6Wlc5MWRDYzZYRzRnSUNBZ0lDQnphRzkxYkdSVFpYUkRiMjVtYVhKdFFuVjBkRzl1UTI5c2IzSW9ibTl5YldGc1EyOXNiM0lwTzF4dUlDQWdJQ0FnWW5KbFlXczdYRzVjYmlBZ0lDQmpZWE5sSUNkdGIzVnpaV1J2ZDI0bk9seHVJQ0FnSUNBZ2MyaHZkV3hrVTJWMFEyOXVabWx5YlVKMWRIUnZia052Ykc5eUtHRmpkR2wyWlVOdmJHOXlLVHRjYmlBZ0lDQWdJR0p5WldGck8xeHVYRzRnSUNBZ1kyRnpaU0FuYlc5MWMyVjFjQ2M2WEc0Z0lDQWdJQ0J6YUc5MWJHUlRaWFJEYjI1bWFYSnRRblYwZEc5dVEyOXNiM0lvYUc5MlpYSkRiMnh2Y2lrN1hHNGdJQ0FnSUNCaWNtVmhhenRjYmx4dUlDQWdJR05oYzJVZ0oyWnZZM1Z6SnpwY2JpQWdJQ0FnSUd4bGRDQWtZMjl1Wm1seWJVSjFkSFJ2YmlBOUlHMXZaR0ZzTG5GMVpYSjVVMlZzWldOMGIzSW9KMkoxZEhSdmJpNWpiMjVtYVhKdEp5azdYRzRnSUNBZ0lDQnNaWFFnSkdOaGJtTmxiRUoxZEhSdmJpQWdQU0J0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5S0NkaWRYUjBiMjR1WTJGdVkyVnNKeWs3WEc1Y2JpQWdJQ0FnSUdsbUlDaDBZWEpuWlhSbFpFTnZibVpwY20wcElIdGNiaUFnSUNBZ0lDQWdKR05oYm1ObGJFSjFkSFJ2Ymk1emRIbHNaUzVpYjNoVGFHRmtiM2NnUFNBbmJtOXVaU2M3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0FrWTI5dVptbHliVUoxZEhSdmJpNXpkSGxzWlM1aWIzaFRhR0ZrYjNjZ1BTQW5ibTl1WlNjN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCaWNtVmhhenRjYmx4dUlDQWdJR05oYzJVZ0oyTnNhV05ySnpwY2JpQWdJQ0FnSUd4bGRDQmpiR2xqYTJWa1QyNU5iMlJoYkNBOUlDaHRiMlJoYkNBOVBUMGdkR0Z5WjJWMEtUdGNiaUFnSUNBZ0lHeGxkQ0JqYkdsamEyVmtUMjVOYjJSaGJFTm9hV3hrSUQwZ2FYTkVaWE5qWlc1a1lXNTBLRzF2WkdGc0xDQjBZWEpuWlhRcE8xeHVYRzRnSUNBZ0lDQXZMeUJKWjI1dmNtVWdZMnhwWTJzZ2IzVjBjMmxrWlNCcFppQmhiR3h2ZDA5MWRITnBaR1ZEYkdsamF5QnBjeUJtWVd4elpWeHVJQ0FnSUNBZ2FXWWdLQ0ZqYkdsamEyVmtUMjVOYjJSaGJDQW1KaUFoWTJ4cFkydGxaRTl1VFc5a1lXeERhR2xzWkNBbUppQnRiMlJoYkVselZtbHphV0pzWlNBbUppQWhjR0Z5WVcxekxtRnNiRzkzVDNWMGMybGtaVU5zYVdOcktTQjdYRzRnSUNBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQnBaaUFvZEdGeVoyVjBaV1JEYjI1bWFYSnRJQ1ltSUdSdmJtVkdkVzVqZEdsdmJrVjRhWE4wY3lBbUppQnRiMlJoYkVselZtbHphV0pzWlNrZ2UxeHVJQ0FnSUNBZ0lDQm9ZVzVrYkdWRGIyNW1hWEp0S0cxdlpHRnNMQ0J3WVhKaGJYTXBPMXh1SUNBZ0lDQWdmU0JsYkhObElHbG1JQ2hrYjI1bFJuVnVZM1JwYjI1RmVHbHpkSE1nSmlZZ2JXOWtZV3hKYzFacGMybGliR1VnZkh3Z2RHRnlaMlYwWldSUGRtVnliR0Y1S1NCN1hHNGdJQ0FnSUNBZ0lHaGhibVJzWlVOaGJtTmxiQ2h0YjJSaGJDd2djR0Z5WVcxektUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCcFppQW9hWE5FWlhOalpXNWtZVzUwS0cxdlpHRnNMQ0IwWVhKblpYUXBJQ1ltSUhSaGNtZGxkQzUwWVdkT1lXMWxJRDA5UFNBblFsVlVWRTlPSnlrZ2UxeHVJQ0FnSUNBZ0lDQnpkMlZsZEVGc1pYSjBMbU5zYjNObEtDazdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQmljbVZoYXp0Y2JpQWdmVnh1ZlR0Y2JseHVMeXBjYmlBcUlDQlZjMlZ5SUdOc2FXTnJaV1FnYjI0Z1hDSkRiMjVtYVhKdFhDSXZYQ0pQUzF3aVhHNGdLaTljYm5aaGNpQm9ZVzVrYkdWRGIyNW1hWEp0SUQwZ1puVnVZM1JwYjI0b2JXOWtZV3dzSUhCaGNtRnRjeWtnZTF4dUlDQjJZWElnWTJGc2JHSmhZMnRXWVd4MVpTQTlJSFJ5ZFdVN1hHNWNiaUFnYVdZZ0tHaGhjME5zWVhOektHMXZaR0ZzTENBbmMyaHZkeTFwYm5CMWRDY3BLU0I3WEc0Z0lDQWdZMkZzYkdKaFkydFdZV3gxWlNBOUlHMXZaR0ZzTG5GMVpYSjVVMlZzWldOMGIzSW9KMmx1Y0hWMEp5a3VkbUZzZFdVN1hHNWNiaUFnSUNCcFppQW9JV05oYkd4aVlXTnJWbUZzZFdVcElIdGNiaUFnSUNBZ0lHTmhiR3hpWVdOclZtRnNkV1VnUFNBbkp6dGNiaUFnSUNCOVhHNGdJSDFjYmx4dUlDQndZWEpoYlhNdVpHOXVaVVoxYm1OMGFXOXVLR05oYkd4aVlXTnJWbUZzZFdVcE8xeHVYRzRnSUdsbUlDaHdZWEpoYlhNdVkyeHZjMlZQYmtOdmJtWnBjbTBwSUh0Y2JpQWdJQ0J6ZDJWbGRFRnNaWEowTG1Oc2IzTmxLQ2s3WEc0Z0lIMWNiaUFnTHk4Z1JHbHpZV0pzWlNCallXNWpaV3dnWVc1a0lHTnZibVpwY20wZ1luVjBkRzl1SUdsbUlIUm9aU0J3WVhKaGJXVjBaWElnYVhNZ2RISjFaVnh1SUNCcFppQW9jR0Z5WVcxekxuTm9iM2RNYjJGa1pYSlBia052Ym1acGNtMHBJSHRjYmlBZ0lDQnpkMlZsZEVGc1pYSjBMbVJwYzJGaWJHVkNkWFIwYjI1ektDazdYRzRnSUgxY2JuMDdYRzVjYmk4cVhHNGdLaUFnVlhObGNpQmpiR2xqYTJWa0lHOXVJRndpUTJGdVkyVnNYQ0pjYmlBcUwxeHVkbUZ5SUdoaGJtUnNaVU5oYm1ObGJDQTlJR1oxYm1OMGFXOXVLRzF2WkdGc0xDQndZWEpoYlhNcElIdGNiaUFnTHk4Z1EyaGxZMnNnYVdZZ1kyRnNiR0poWTJzZ1puVnVZM1JwYjI0Z1pYaHdaV04wY3lCaElIQmhjbUZ0WlhSbGNpQW9kRzhnZEhKaFkyc2dZMkZ1WTJWc0lHRmpkR2x2Ym5NcFhHNGdJSFpoY2lCbWRXNWpkR2x2YmtGelUzUnlJRDBnVTNSeWFXNW5LSEJoY21GdGN5NWtiMjVsUm5WdVkzUnBiMjRwTG5KbGNHeGhZMlVvTDF4Y2N5OW5MQ0FuSnlrN1hHNGdJSFpoY2lCbWRXNWpkR2x2YmtoaGJtUnNaWE5EWVc1alpXd2dQU0JtZFc1amRHbHZia0Z6VTNSeUxuTjFZbk4wY21sdVp5Z3dMQ0E1S1NBOVBUMGdKMloxYm1OMGFXOXVLQ2NnSmlZZ1puVnVZM1JwYjI1QmMxTjBjaTV6ZFdKemRISnBibWNvT1N3Z01UQXBJQ0U5UFNBbktTYzdYRzVjYmlBZ2FXWWdLR1oxYm1OMGFXOXVTR0Z1Wkd4bGMwTmhibU5sYkNrZ2UxeHVJQ0FnSUhCaGNtRnRjeTVrYjI1bFJuVnVZM1JwYjI0b1ptRnNjMlVwTzF4dUlDQjlYRzVjYmlBZ2FXWWdLSEJoY21GdGN5NWpiRzl6WlU5dVEyRnVZMlZzS1NCN1hHNGdJQ0FnYzNkbFpYUkJiR1Z5ZEM1amJHOXpaU2dwTzF4dUlDQjlYRzU5TzF4dVhHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElIdGNiaUFnYUdGdVpHeGxRblYwZEc5dUxGeHVJQ0JvWVc1a2JHVkRiMjVtYVhKdExGeHVJQ0JvWVc1a2JHVkRZVzVqWld4Y2JuMDdYRzRpTENKMllYSWdhR0Z6UTJ4aGMzTWdQU0JtZFc1amRHbHZiaWhsYkdWdExDQmpiR0Z6YzA1aGJXVXBJSHRjYmlBZ2NtVjBkWEp1SUc1bGR5QlNaV2RGZUhBb0p5QW5JQ3NnWTJ4aGMzTk9ZVzFsSUNzZ0p5QW5LUzUwWlhOMEtDY2dKeUFySUdWc1pXMHVZMnhoYzNOT1lXMWxJQ3NnSnlBbktUdGNibjA3WEc1Y2JuWmhjaUJoWkdSRGJHRnpjeUE5SUdaMWJtTjBhVzl1S0dWc1pXMHNJR05zWVhOelRtRnRaU2tnZTF4dUlDQnBaaUFvSVdoaGMwTnNZWE56S0dWc1pXMHNJR05zWVhOelRtRnRaU2twSUh0Y2JpQWdJQ0JsYkdWdExtTnNZWE56VG1GdFpTQXJQU0FuSUNjZ0t5QmpiR0Z6YzA1aGJXVTdYRzRnSUgxY2JuMDdYRzVjYm5aaGNpQnlaVzF2ZG1WRGJHRnpjeUE5SUdaMWJtTjBhVzl1S0dWc1pXMHNJR05zWVhOelRtRnRaU2tnZTF4dUlDQjJZWElnYm1WM1EyeGhjM01nUFNBbklDY2dLeUJsYkdWdExtTnNZWE56VG1GdFpTNXlaWEJzWVdObEtDOWJYRngwWEZ4eVhGeHVYUzluTENBbklDY3BJQ3NnSnlBbk8xeHVJQ0JwWmlBb2FHRnpRMnhoYzNNb1pXeGxiU3dnWTJ4aGMzTk9ZVzFsS1NrZ2UxeHVJQ0FnSUhkb2FXeGxJQ2h1WlhkRGJHRnpjeTVwYm1SbGVFOW1LQ2NnSnlBcklHTnNZWE56VG1GdFpTQXJJQ2NnSnlrZ1BqMGdNQ2tnZTF4dUlDQWdJQ0FnYm1WM1EyeGhjM01nUFNCdVpYZERiR0Z6Y3k1eVpYQnNZV05sS0NjZ0p5QXJJR05zWVhOelRtRnRaU0FySUNjZ0p5d2dKeUFuS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdaV3hsYlM1amJHRnpjMDVoYldVZ1BTQnVaWGREYkdGemN5NXlaWEJzWVdObEtDOWVYRnh6SzN4Y1hITXJKQzluTENBbkp5azdYRzRnSUgxY2JuMDdYRzVjYm5aaGNpQmxjMk5oY0dWSWRHMXNJRDBnWm5WdVkzUnBiMjRvYzNSeUtTQjdYRzRnSUhaaGNpQmthWFlnUFNCa2IyTjFiV1Z1ZEM1amNtVmhkR1ZGYkdWdFpXNTBLQ2RrYVhZbktUdGNiaUFnWkdsMkxtRndjR1Z1WkVOb2FXeGtLR1J2WTNWdFpXNTBMbU55WldGMFpWUmxlSFJPYjJSbEtITjBjaWtwTzF4dUlDQnlaWFIxY200Z1pHbDJMbWx1Ym1WeVNGUk5URHRjYm4wN1hHNWNiblpoY2lCZmMyaHZkeUE5SUdaMWJtTjBhVzl1S0dWc1pXMHBJSHRjYmlBZ1pXeGxiUzV6ZEhsc1pTNXZjR0ZqYVhSNUlEMGdKeWM3WEc0Z0lHVnNaVzB1YzNSNWJHVXVaR2x6Y0d4aGVTQTlJQ2RpYkc5amF5YzdYRzU5TzF4dVhHNTJZWElnYzJodmR5QTlJR1oxYm1OMGFXOXVLR1ZzWlcxektTQjdYRzRnSUdsbUlDaGxiR1Z0Y3lBbUppQWhaV3hsYlhNdWJHVnVaM1JvS1NCN1hHNGdJQ0FnY21WMGRYSnVJRjl6YUc5M0tHVnNaVzF6S1R0Y2JpQWdmVnh1SUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHVnNaVzF6TG14bGJtZDBhRHNnS3l0cEtTQjdYRzRnSUNBZ1gzTm9iM2NvWld4bGJYTmJhVjBwTzF4dUlDQjlYRzU5TzF4dVhHNTJZWElnWDJocFpHVWdQU0JtZFc1amRHbHZiaWhsYkdWdEtTQjdYRzRnSUdWc1pXMHVjM1I1YkdVdWIzQmhZMmwwZVNBOUlDY25PMXh1SUNCbGJHVnRMbk4wZVd4bExtUnBjM0JzWVhrZ1BTQW5ibTl1WlNjN1hHNTlPMXh1WEc1MllYSWdhR2xrWlNBOUlHWjFibU4wYVc5dUtHVnNaVzF6S1NCN1hHNGdJR2xtSUNobGJHVnRjeUFtSmlBaFpXeGxiWE11YkdWdVozUm9LU0I3WEc0Z0lDQWdjbVYwZFhKdUlGOW9hV1JsS0dWc1pXMXpLVHRjYmlBZ2ZWeHVJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdWc1pXMXpMbXhsYm1kMGFEc2dLeXRwS1NCN1hHNGdJQ0FnWDJocFpHVW9aV3hsYlhOYmFWMHBPMXh1SUNCOVhHNTlPMXh1WEc1MllYSWdhWE5FWlhOalpXNWtZVzUwSUQwZ1puVnVZM1JwYjI0b2NHRnlaVzUwTENCamFHbHNaQ2tnZTF4dUlDQjJZWElnYm05a1pTQTlJR05vYVd4a0xuQmhjbVZ1ZEU1dlpHVTdYRzRnSUhkb2FXeGxJQ2h1YjJSbElDRTlQU0J1ZFd4c0tTQjdYRzRnSUNBZ2FXWWdLRzV2WkdVZ1BUMDlJSEJoY21WdWRDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdmVnh1SUNBZ0lHNXZaR1VnUFNCdWIyUmxMbkJoY21WdWRFNXZaR1U3WEc0Z0lIMWNiaUFnY21WMGRYSnVJR1poYkhObE8xeHVmVHRjYmx4dWRtRnlJR2RsZEZSdmNFMWhjbWRwYmlBOUlHWjFibU4wYVc5dUtHVnNaVzBwSUh0Y2JpQWdaV3hsYlM1emRIbHNaUzVzWldaMElEMGdKeTA1T1RrNWNIZ25PMXh1SUNCbGJHVnRMbk4wZVd4bExtUnBjM0JzWVhrZ1BTQW5ZbXh2WTJzbk8xeHVYRzRnSUhaaGNpQm9aV2xuYUhRZ1BTQmxiR1Z0TG1Oc2FXVnVkRWhsYVdkb2RDeGNiaUFnSUNBZ0lIQmhaR1JwYm1jN1hHNGdJR2xtSUNoMGVYQmxiMllnWjJWMFEyOXRjSFYwWldSVGRIbHNaU0FoUFQwZ1hDSjFibVJsWm1sdVpXUmNJaWtnZXlBdkx5QkpSU0E0WEc0Z0lDQWdjR0ZrWkdsdVp5QTlJSEJoY25ObFNXNTBLR2RsZEVOdmJYQjFkR1ZrVTNSNWJHVW9aV3hsYlNrdVoyVjBVSEp2Y0dWeWRIbFdZV3gxWlNnbmNHRmtaR2x1WnkxMGIzQW5LU3dnTVRBcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lIQmhaR1JwYm1jZ1BTQndZWEp6WlVsdWRDaGxiR1Z0TG1OMWNuSmxiblJUZEhsc1pTNXdZV1JrYVc1bktUdGNiaUFnZlZ4dVhHNGdJR1ZzWlcwdWMzUjViR1V1YkdWbWRDQTlJQ2NuTzF4dUlDQmxiR1Z0TG5OMGVXeGxMbVJwYzNCc1lYa2dQU0FuYm05dVpTYzdYRzRnSUhKbGRIVnliaUFvSnkwbklDc2djR0Z5YzJWSmJuUW9LR2hsYVdkb2RDQXJJSEJoWkdScGJtY3BJQzhnTWlrZ0t5QW5jSGduS1R0Y2JuMDdYRzVjYm5aaGNpQm1ZV1JsU1c0Z1BTQm1kVzVqZEdsdmJpaGxiR1Z0TENCcGJuUmxjblpoYkNrZ2UxeHVJQ0JwWmlBb0syVnNaVzB1YzNSNWJHVXViM0JoWTJsMGVTQThJREVwSUh0Y2JpQWdJQ0JwYm5SbGNuWmhiQ0E5SUdsdWRHVnlkbUZzSUh4OElERTJPMXh1SUNBZ0lHVnNaVzB1YzNSNWJHVXViM0JoWTJsMGVTQTlJREE3WEc0Z0lDQWdaV3hsYlM1emRIbHNaUzVrYVhOd2JHRjVJRDBnSjJKc2IyTnJKenRjYmlBZ0lDQjJZWElnYkdGemRDQTlJQ3R1WlhjZ1JHRjBaU2dwTzF4dUlDQWdJSFpoY2lCMGFXTnJJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCbGJHVnRMbk4wZVd4bExtOXdZV05wZEhrZ1BTQXJaV3hsYlM1emRIbHNaUzV2Y0dGamFYUjVJQ3NnS0c1bGR5QkVZWFJsS0NrZ0xTQnNZWE4wS1NBdklERXdNRHRjYmlBZ0lDQWdJR3hoYzNRZ1BTQXJibVYzSUVSaGRHVW9LVHRjYmx4dUlDQWdJQ0FnYVdZZ0tDdGxiR1Z0TG5OMGVXeGxMbTl3WVdOcGRIa2dQQ0F4S1NCN1hHNGdJQ0FnSUNBZ0lITmxkRlJwYldWdmRYUW9kR2xqYXl3Z2FXNTBaWEoyWVd3cE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgwN1hHNGdJQ0FnZEdsamF5Z3BPMXh1SUNCOVhHNGdJR1ZzWlcwdWMzUjViR1V1WkdsemNHeGhlU0E5SUNkaWJHOWpheWM3SUM4dlptRnNiR0poWTJzZ1NVVTRYRzU5TzF4dVhHNTJZWElnWm1Ga1pVOTFkQ0E5SUdaMWJtTjBhVzl1S0dWc1pXMHNJR2x1ZEdWeWRtRnNLU0I3WEc0Z0lHbHVkR1Z5ZG1Gc0lEMGdhVzUwWlhKMllXd2dmSHdnTVRZN1hHNGdJR1ZzWlcwdWMzUjViR1V1YjNCaFkybDBlU0E5SURFN1hHNGdJSFpoY2lCc1lYTjBJRDBnSzI1bGR5QkVZWFJsS0NrN1hHNGdJSFpoY2lCMGFXTnJJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnWld4bGJTNXpkSGxzWlM1dmNHRmphWFI1SUQwZ0syVnNaVzB1YzNSNWJHVXViM0JoWTJsMGVTQXRJQ2h1WlhjZ1JHRjBaU2dwSUMwZ2JHRnpkQ2tnTHlBeE1EQTdYRzRnSUNBZ2JHRnpkQ0E5SUN0dVpYY2dSR0YwWlNncE8xeHVYRzRnSUNBZ2FXWWdLQ3RsYkdWdExuTjBlV3hsTG05d1lXTnBkSGtnUGlBd0tTQjdYRzRnSUNBZ0lDQnpaWFJVYVcxbGIzVjBLSFJwWTJzc0lHbHVkR1Z5ZG1Gc0tUdGNiaUFnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnWld4bGJTNXpkSGxzWlM1a2FYTndiR0Y1SUQwZ0oyNXZibVVuTzF4dUlDQWdJSDFjYmlBZ2ZUdGNiaUFnZEdsamF5Z3BPMXh1ZlR0Y2JseHVkbUZ5SUdacGNtVkRiR2xqYXlBOUlHWjFibU4wYVc5dUtHNXZaR1VwSUh0Y2JpQWdMeThnVkdGclpXNGdabkp2YlNCb2RIUndPaTh2ZDNkM0xtNXZibTlpZEhKMWMybDJaUzVqYjIwdk1qQXhNUzh4TVM4eU9TOXdjbTluY21GdFlYUnBZMkZzYkhrdFptbHlaUzFqY205emMySnliM2R6WlhJdFkyeHBZMnN0WlhabGJuUXRkMmwwYUMxcVlYWmhjMk55YVhCMEwxeHVJQ0F2THlCVWFHVnVJR1pwZUdWa0lHWnZjaUIwYjJSaGVTZHpJRU5vY205dFpTQmljbTkzYzJWeUxseHVJQ0JwWmlBb2RIbHdaVzltSUUxdmRYTmxSWFpsYm5RZ1BUMDlJQ2RtZFc1amRHbHZiaWNwSUh0Y2JpQWdJQ0F2THlCVmNDMTBieTFrWVhSbElHRndjSEp2WVdOb1hHNGdJQ0FnZG1GeUlHMWxkblFnUFNCdVpYY2dUVzkxYzJWRmRtVnVkQ2duWTJ4cFkyc25MQ0I3WEc0Z0lDQWdJQ0IyYVdWM09pQjNhVzVrYjNjc1hHNGdJQ0FnSUNCaWRXSmliR1Z6T2lCbVlXeHpaU3hjYmlBZ0lDQWdJR05oYm1ObGJHRmliR1U2SUhSeWRXVmNiaUFnSUNCOUtUdGNiaUFnSUNCdWIyUmxMbVJwYzNCaGRHTm9SWFpsYm5Rb2JXVjJkQ2s3WEc0Z0lIMGdaV3h6WlNCcFppQW9JR1J2WTNWdFpXNTBMbU55WldGMFpVVjJaVzUwSUNrZ2UxeHVJQ0FnSUM4dklFWmhiR3hpWVdOclhHNGdJQ0FnZG1GeUlHVjJkQ0E5SUdSdlkzVnRaVzUwTG1OeVpXRjBaVVYyWlc1MEtDZE5iM1Z6WlVWMlpXNTBjeWNwTzF4dUlDQWdJR1YyZEM1cGJtbDBSWFpsYm5Rb0oyTnNhV05ySnl3Z1ptRnNjMlVzSUdaaGJITmxLVHRjYmlBZ0lDQnViMlJsTG1ScGMzQmhkR05vUlhabGJuUW9aWFowS1R0Y2JpQWdmU0JsYkhObElHbG1JQ2hrYjJOMWJXVnVkQzVqY21WaGRHVkZkbVZ1ZEU5aWFtVmpkQ2tnZTF4dUlDQWdJRzV2WkdVdVptbHlaVVYyWlc1MEtDZHZibU5zYVdOckp5a2dPMXh1SUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1Z2WmlCdWIyUmxMbTl1WTJ4cFkyc2dQVDA5SUNkbWRXNWpkR2x2YmljZ0tTQjdYRzRnSUNBZ2JtOWtaUzV2Ym1Oc2FXTnJLQ2s3WEc0Z0lIMWNibjA3WEc1Y2JuWmhjaUJ6ZEc5d1JYWmxiblJRY205d1lXZGhkR2x2YmlBOUlHWjFibU4wYVc5dUtHVXBJSHRjYmlBZ0x5OGdTVzRnY0dGeWRHbGpkV3hoY2l3Z2JXRnJaU0J6ZFhKbElIUm9aU0J6Y0dGalpTQmlZWElnWkc5bGMyNG5kQ0J6WTNKdmJHd2dkR2hsSUcxaGFXNGdkMmx1Wkc5M0xseHVJQ0JwWmlBb2RIbHdaVzltSUdVdWMzUnZjRkJ5YjNCaFoyRjBhVzl1SUQwOVBTQW5ablZ1WTNScGIyNG5LU0I3WEc0Z0lDQWdaUzV6ZEc5d1VISnZjR0ZuWVhScGIyNG9LVHRjYmlBZ0lDQmxMbkJ5WlhabGJuUkVaV1poZFd4MEtDazdYRzRnSUgwZ1pXeHpaU0JwWmlBb2QybHVaRzkzTG1WMlpXNTBJQ1ltSUhkcGJtUnZkeTVsZG1WdWRDNW9ZWE5QZDI1UWNtOXdaWEowZVNnblkyRnVZMlZzUW5WaVlteGxKeWtwSUh0Y2JpQWdJQ0IzYVc1a2IzY3VaWFpsYm5RdVkyRnVZMlZzUW5WaVlteGxJRDBnZEhKMVpUdGNiaUFnZlZ4dWZUdGNibHh1Wlhod2IzSjBJSHNnWEc0Z0lHaGhjME5zWVhOekxDQmhaR1JEYkdGemN5d2djbVZ0YjNabFEyeGhjM01zSUZ4dUlDQmxjMk5oY0dWSWRHMXNMQ0JjYmlBZ1gzTm9iM2NzSUhOb2IzY3NJRjlvYVdSbExDQm9hV1JsTENCY2JpQWdhWE5FWlhOalpXNWtZVzUwTENCY2JpQWdaMlYwVkc5d1RXRnlaMmx1TEZ4dUlDQm1ZV1JsU1c0c0lHWmhaR1ZQZFhRc1hHNGdJR1pwY21WRGJHbGpheXhjYmlBZ2MzUnZjRVYyWlc1MFVISnZjR0ZuWVhScGIyNWNibjA3WEc0aUxDSnBiWEJ2Y25RZ2V5QnpkRzl3UlhabGJuUlFjbTl3WVdkaGRHbHZiaXdnWm1seVpVTnNhV05ySUgwZ1puSnZiU0FuTGk5b1lXNWtiR1V0Wkc5dEp6dGNibWx0Y0c5eWRDQjdJSE5sZEVadlkzVnpVM1I1YkdVZ2ZTQm1jbTl0SUNjdUwyaGhibVJzWlMxemQyRnNMV1J2YlNjN1hHNWNibHh1ZG1GeUlHaGhibVJzWlV0bGVVUnZkMjRnUFNCbWRXNWpkR2x2YmlobGRtVnVkQ3dnY0dGeVlXMXpMQ0J0YjJSaGJDa2dlMXh1SUNCMllYSWdaU0E5SUdWMlpXNTBJSHg4SUhkcGJtUnZkeTVsZG1WdWREdGNiaUFnZG1GeUlHdGxlVU52WkdVZ1BTQmxMbXRsZVVOdlpHVWdmSHdnWlM1M2FHbGphRHRjYmx4dUlDQjJZWElnSkc5clFuVjBkRzl1SUNBZ0lDQTlJRzF2WkdGc0xuRjFaWEo1VTJWc1pXTjBiM0lvSjJKMWRIUnZiaTVqYjI1bWFYSnRKeWs3WEc0Z0lIWmhjaUFrWTJGdVkyVnNRblYwZEc5dUlEMGdiVzlrWVd3dWNYVmxjbmxUWld4bFkzUnZjaWduWW5WMGRHOXVMbU5oYm1ObGJDY3BPMXh1SUNCMllYSWdKRzF2WkdGc1FuVjBkRzl1Y3lBOUlHMXZaR0ZzTG5GMVpYSjVVMlZzWldOMGIzSkJiR3dvSjJKMWRIUnZibHQwWVdKcGJtUmxlRjBuS1R0Y2JseHVYRzRnSUdsbUlDaGJPU3dnTVRNc0lETXlMQ0F5TjEwdWFXNWtaWGhQWmloclpYbERiMlJsS1NBOVBUMGdMVEVwSUh0Y2JpQWdJQ0F2THlCRWIyNG5kQ0JrYnlCM2IzSnJJRzl1SUd0bGVYTWdkMlVnWkc5dUozUWdZMkZ5WlNCaFltOTFkQzVjYmlBZ0lDQnlaWFIxY200N1hHNGdJSDFjYmx4dUlDQjJZWElnSkhSaGNtZGxkRVZzWlcxbGJuUWdQU0JsTG5SaGNtZGxkQ0I4ZkNCbExuTnlZMFZzWlcxbGJuUTdYRzVjYmlBZ2RtRnlJR0owYmtsdVpHVjRJRDBnTFRFN0lDOHZJRVpwYm1RZ2RHaGxJR0oxZEhSdmJpQXRJRzV2ZEdVc0lIUm9hWE1nYVhNZ1lTQnViMlJsYkdsemRDd2dibTkwSUdGdUlHRnljbUY1TGx4dUlDQm1iM0lnS0haaGNpQnBJRDBnTURzZ2FTQThJQ1J0YjJSaGJFSjFkSFJ2Ym5NdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQnBaaUFvSkhSaGNtZGxkRVZzWlcxbGJuUWdQVDA5SUNSdGIyUmhiRUoxZEhSdmJuTmJhVjBwSUh0Y2JpQWdJQ0FnSUdKMGJrbHVaR1Y0SUQwZ2FUdGNiaUFnSUNBZ0lHSnlaV0ZyTzF4dUlDQWdJSDFjYmlBZ2ZWeHVYRzRnSUdsbUlDaHJaWGxEYjJSbElEMDlQU0E1S1NCN1hHNGdJQ0FnTHk4Z1ZFRkNYRzRnSUNBZ2FXWWdLR0owYmtsdVpHVjRJRDA5UFNBdE1Ta2dlMXh1SUNBZ0lDQWdMeThnVG04Z1luVjBkRzl1SUdadlkzVnpaV1F1SUVwMWJYQWdkRzhnZEdobElHTnZibVpwY20wZ1luVjBkRzl1TGx4dUlDQWdJQ0FnSkhSaGNtZGxkRVZzWlcxbGJuUWdQU0FrYjJ0Q2RYUjBiMjQ3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDOHZJRU41WTJ4bElIUnZJSFJvWlNCdVpYaDBJR0oxZEhSdmJseHVJQ0FnSUNBZ2FXWWdLR0owYmtsdVpHVjRJRDA5UFNBa2JXOWtZV3hDZFhSMGIyNXpMbXhsYm1kMGFDQXRJREVwSUh0Y2JpQWdJQ0FnSUNBZ0pIUmhjbWRsZEVWc1pXMWxiblFnUFNBa2JXOWtZV3hDZFhSMGIyNXpXekJkTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnSkhSaGNtZGxkRVZzWlcxbGJuUWdQU0FrYlc5a1lXeENkWFIwYjI1elcySjBia2x1WkdWNElDc2dNVjA3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjM1J2Y0VWMlpXNTBVSEp2Y0dGbllYUnBiMjRvWlNrN1hHNGdJQ0FnSkhSaGNtZGxkRVZzWlcxbGJuUXVabTlqZFhNb0tUdGNibHh1SUNBZ0lHbG1JQ2h3WVhKaGJYTXVZMjl1Wm1seWJVSjFkSFJ2YmtOdmJHOXlLU0I3WEc0Z0lDQWdJQ0J6WlhSR2IyTjFjMU4wZVd4bEtDUjBZWEpuWlhSRmJHVnRaVzUwTENCd1lYSmhiWE11WTI5dVptbHliVUoxZEhSdmJrTnZiRzl5S1R0Y2JpQWdJQ0I5WEc0Z0lIMGdaV3h6WlNCN1hHNGdJQ0FnYVdZZ0tHdGxlVU52WkdVZ1BUMDlJREV6S1NCN1hHNGdJQ0FnSUNCcFppQW9KSFJoY21kbGRFVnNaVzFsYm5RdWRHRm5UbUZ0WlNBOVBUMGdKMGxPVUZWVUp5a2dlMXh1SUNBZ0lDQWdJQ0FrZEdGeVoyVjBSV3hsYldWdWRDQTlJQ1J2YTBKMWRIUnZianRjYmlBZ0lDQWdJQ0FnSkc5clFuVjBkRzl1TG1adlkzVnpLQ2s3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdsbUlDaGlkRzVKYm1SbGVDQTlQVDBnTFRFcElIdGNiaUFnSUNBZ0lDQWdMeThnUlU1VVJWSXZVMUJCUTBVZ1kyeHBZMnRsWkNCdmRYUnphV1JsSUc5bUlHRWdZblYwZEc5dUxseHVJQ0FnSUNBZ0lDQWtkR0Z5WjJWMFJXeGxiV1Z1ZENBOUlDUnZhMEoxZEhSdmJqdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDOHZJRVJ2SUc1dmRHaHBibWNnTFNCc1pYUWdkR2hsSUdKeWIzZHpaWElnYUdGdVpHeGxJR2wwTGx4dUlDQWdJQ0FnSUNBa2RHRnlaMlYwUld4bGJXVnVkQ0E5SUhWdVpHVm1hVzVsWkR0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5SUdWc2MyVWdhV1lnS0d0bGVVTnZaR1VnUFQwOUlESTNJQ1ltSUhCaGNtRnRjeTVoYkd4dmQwVnpZMkZ3WlV0bGVTQTlQVDBnZEhKMVpTa2dlMXh1SUNBZ0lDQWdKSFJoY21kbGRFVnNaVzFsYm5RZ1BTQWtZMkZ1WTJWc1FuVjBkRzl1TzF4dUlDQWdJQ0FnWm1seVpVTnNhV05yS0NSMFlYSm5aWFJGYkdWdFpXNTBMQ0JsS1R0Y2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdMeThnUm1Gc2JHSmhZMnNnTFNCc1pYUWdkR2hsSUdKeWIzZHpaWElnYUdGdVpHeGxJR2wwTGx4dUlDQWdJQ0FnSkhSaGNtZGxkRVZzWlcxbGJuUWdQU0IxYm1SbFptbHVaV1E3WEc0Z0lDQWdmVnh1SUNCOVhHNTlPMXh1WEc1bGVIQnZjblFnWkdWbVlYVnNkQ0JvWVc1a2JHVkxaWGxFYjNkdU8xeHVJaXdpYVcxd2IzSjBJSHNnYUdWNFZHOVNaMklnZlNCbWNtOXRJQ2N1TDNWMGFXeHpKenRjYm1sdGNHOXlkQ0I3SUhKbGJXOTJaVU5zWVhOekxDQm5aWFJVYjNCTllYSm5hVzRzSUdaaFpHVkpiaXdnYzJodmR5d2dZV1JrUTJ4aGMzTWdmU0JtY205dElDY3VMMmhoYm1Sc1pTMWtiMjBuTzF4dWFXMXdiM0owSUdSbFptRjFiSFJRWVhKaGJYTWdabkp2YlNBbkxpOWtaV1poZFd4MExYQmhjbUZ0Y3ljN1hHNWNiblpoY2lCdGIyUmhiRU5zWVhOeklDQWdQU0FuTG5OM1pXVjBMV0ZzWlhKMEp6dGNiblpoY2lCdmRtVnliR0Y1UTJ4aGMzTWdQU0FuTG5OM1pXVjBMVzkyWlhKc1lYa25PMXh1WEc0dktseHVJQ29nUVdSa0lHMXZaR0ZzSUNzZ2IzWmxjbXhoZVNCMGJ5QkVUMDFjYmlBcUwxeHVhVzF3YjNKMElHbHVhbVZqZEdWa1NGUk5UQ0JtY205dElDY3VMMmx1YW1WamRHVmtMV2gwYld3bk8xeHVYRzUyWVhJZ2MzZGxaWFJCYkdWeWRFbHVhWFJwWVd4cGVtVWdQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdkbUZ5SUhOM1pXVjBWM0poY0NBOUlHUnZZM1Z0Wlc1MExtTnlaV0YwWlVWc1pXMWxiblFvSjJScGRpY3BPMXh1SUNCemQyVmxkRmR5WVhBdWFXNXVaWEpJVkUxTUlEMGdhVzVxWldOMFpXUklWRTFNTzF4dVhHNGdJQzh2SUVGd2NHVnVaQ0JsYkdWdFpXNTBjeUIwYnlCaWIyUjVYRzRnSUhkb2FXeGxJQ2h6ZDJWbGRGZHlZWEF1Wm1seWMzUkRhR2xzWkNrZ2UxeHVJQ0FnSUdSdlkzVnRaVzUwTG1KdlpIa3VZWEJ3Wlc1a1EyaHBiR1FvYzNkbFpYUlhjbUZ3TG1acGNuTjBRMmhwYkdRcE8xeHVJQ0I5WEc1OU8xeHVYRzR2S2x4dUlDb2dSMlYwSUVSUFRTQmxiR1Z0Wlc1MElHOW1JRzF2WkdGc1hHNGdLaTljYm5aaGNpQm5aWFJOYjJSaGJDQTlJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQjJZWElnSkcxdlpHRnNJRDBnWkc5amRXMWxiblF1Y1hWbGNubFRaV3hsWTNSdmNpaHRiMlJoYkVOc1lYTnpLVHRjYmx4dUlDQnBaaUFvSVNSdGIyUmhiQ2tnZTF4dUlDQWdJSE4zWldWMFFXeGxjblJKYm1sMGFXRnNhWHBsS0NrN1hHNGdJQ0FnSkcxdlpHRnNJRDBnWjJWMFRXOWtZV3dvS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlBa2JXOWtZV3c3WEc1OU8xeHVYRzR2S2x4dUlDb2dSMlYwSUVSUFRTQmxiR1Z0Wlc1MElHOW1JR2x1Y0hWMElDaHBiaUJ0YjJSaGJDbGNiaUFxTDF4dWRtRnlJR2RsZEVsdWNIVjBJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSFpoY2lBa2JXOWtZV3dnUFNCblpYUk5iMlJoYkNncE8xeHVJQ0JwWmlBb0pHMXZaR0ZzS1NCN1hHNGdJQ0FnY21WMGRYSnVJQ1J0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5S0NkcGJuQjFkQ2NwTzF4dUlDQjlYRzU5TzF4dVhHNHZLbHh1SUNvZ1IyVjBJRVJQVFNCbGJHVnRaVzUwSUc5bUlHOTJaWEpzWVhsY2JpQXFMMXh1ZG1GeUlHZGxkRTkyWlhKc1lYa2dQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdjbVYwZFhKdUlHUnZZM1Z0Wlc1MExuRjFaWEo1VTJWc1pXTjBiM0lvYjNabGNteGhlVU5zWVhOektUdGNibjA3WEc1Y2JpOHFYRzRnS2lCQlpHUWdZbTk0TFhOb1lXUnZkeUJ6ZEhsc1pTQjBieUJpZFhSMGIyNGdLR1JsY0dWdVpHbHVaeUJ2YmlCcGRITWdZMmh2YzJWdUlHSm5MV052Ykc5eUtWeHVJQ292WEc1MllYSWdjMlYwUm05amRYTlRkSGxzWlNBOUlHWjFibU4wYVc5dUtDUmlkWFIwYjI0c0lHSm5RMjlzYjNJcElIdGNiaUFnZG1GeUlISm5Za052Ykc5eUlEMGdhR1Y0Vkc5U1oySW9ZbWREYjJ4dmNpazdYRzRnSUNSaWRYUjBiMjR1YzNSNWJHVXVZbTk0VTJoaFpHOTNJRDBnSnpBZ01DQXljSGdnY21kaVlTZ25JQ3NnY21kaVEyOXNiM0lnS3lBbkxDQXdMamdwTENCcGJuTmxkQ0F3SURBZ01DQXhjSGdnY21kaVlTZ3dMQ0F3TENBd0xDQXdMakExS1NjN1hHNTlPMXh1WEc0dktseHVJQ29nUVc1cGJXRjBhVzl1SUhkb1pXNGdiM0JsYm1sdVp5QnRiMlJoYkZ4dUlDb3ZYRzUyWVhJZ2IzQmxiazF2WkdGc0lEMGdablZ1WTNScGIyNG9ZMkZzYkdKaFkyc3BJSHRjYmlBZ2RtRnlJQ1J0YjJSaGJDQTlJR2RsZEUxdlpHRnNLQ2s3WEc0Z0lHWmhaR1ZKYmloblpYUlBkbVZ5YkdGNUtDa3NJREV3S1R0Y2JpQWdjMmh2ZHlna2JXOWtZV3dwTzF4dUlDQmhaR1JEYkdGemN5Z2tiVzlrWVd3c0lDZHphRzkzVTNkbFpYUkJiR1Z5ZENjcE8xeHVJQ0J5WlcxdmRtVkRiR0Z6Y3lna2JXOWtZV3dzSUNkb2FXUmxVM2RsWlhSQmJHVnlkQ2NwTzF4dVhHNGdJSGRwYm1SdmR5NXdjbVYyYVc5MWMwRmpkR2wyWlVWc1pXMWxiblFnUFNCa2IyTjFiV1Z1ZEM1aFkzUnBkbVZGYkdWdFpXNTBPMXh1SUNCMllYSWdKRzlyUW5WMGRHOXVJRDBnSkcxdlpHRnNMbkYxWlhKNVUyVnNaV04wYjNJb0oySjFkSFJ2Ymk1amIyNW1hWEp0SnlrN1hHNGdJQ1J2YTBKMWRIUnZiaTVtYjJOMWN5Z3BPMXh1WEc0Z0lITmxkRlJwYldWdmRYUW9ablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJR0ZrWkVOc1lYTnpLQ1J0YjJSaGJDd2dKM1pwYzJsaWJHVW5LVHRjYmlBZ2ZTd2dOVEF3S1R0Y2JseHVJQ0IyWVhJZ2RHbHRaWElnUFNBa2JXOWtZV3d1WjJWMFFYUjBjbWxpZFhSbEtDZGtZWFJoTFhScGJXVnlKeWs3WEc1Y2JpQWdhV1lnS0hScGJXVnlJQ0U5UFNBbmJuVnNiQ2NnSmlZZ2RHbHRaWElnSVQwOUlDY25LU0I3WEc0Z0lDQWdkbUZ5SUhScGJXVnlRMkZzYkdKaFkyc2dQU0JqWVd4c1ltRmphenRjYmlBZ0lDQWtiVzlrWVd3dWRHbHRaVzkxZENBOUlITmxkRlJwYldWdmRYUW9ablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0IyWVhJZ1pHOXVaVVoxYm1OMGFXOXVSWGhwYzNSeklEMGdLQ2gwYVcxbGNrTmhiR3hpWVdOcklIeDhJRzUxYkd3cElDWW1JQ1J0YjJSaGJDNW5aWFJCZEhSeWFXSjFkR1VvSjJSaGRHRXRhR0Z6TFdSdmJtVXRablZ1WTNScGIyNG5LU0E5UFQwZ0ozUnlkV1VuS1R0Y2JpQWdJQ0FnSUdsbUlDaGtiMjVsUm5WdVkzUnBiMjVGZUdsemRITXBJSHNnWEc0Z0lDQWdJQ0FnSUhScGJXVnlRMkZzYkdKaFkyc29iblZzYkNrN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnYzNkbFpYUkJiR1Z5ZEM1amJHOXpaU2dwTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBzSUhScGJXVnlLVHRjYmlBZ2ZWeHVmVHRjYmx4dUx5cGNiaUFxSUZKbGMyVjBJSFJvWlNCemRIbHNhVzVuSUc5bUlIUm9aU0JwYm5CMWRGeHVJQ29nS0dadmNpQmxlR0Z0Y0d4bElHbG1JR1Z5Y205eWN5Qm9ZWFpsSUdKbFpXNGdjMmh2ZDI0cFhHNGdLaTljYm5aaGNpQnlaWE5sZEVsdWNIVjBJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJSFpoY2lBa2JXOWtZV3dnUFNCblpYUk5iMlJoYkNncE8xeHVJQ0IyWVhJZ0pHbHVjSFYwSUQwZ1oyVjBTVzV3ZFhRb0tUdGNibHh1SUNCeVpXMXZkbVZEYkdGemN5Z2tiVzlrWVd3c0lDZHphRzkzTFdsdWNIVjBKeWs3WEc0Z0lDUnBibkIxZEM1MllXeDFaU0E5SUdSbFptRjFiSFJRWVhKaGJYTXVhVzV3ZFhSV1lXeDFaVHRjYmlBZ0pHbHVjSFYwTG5ObGRFRjBkSEpwWW5WMFpTZ25kSGx3WlNjc0lHUmxabUYxYkhSUVlYSmhiWE11YVc1d2RYUlVlWEJsS1R0Y2JpQWdKR2x1Y0hWMExuTmxkRUYwZEhKcFluVjBaU2duY0d4aFkyVm9iMnhrWlhJbkxDQmtaV1poZFd4MFVHRnlZVzF6TG1sdWNIVjBVR3hoWTJWb2IyeGtaWElwTzF4dVhHNGdJSEpsYzJWMFNXNXdkWFJGY25KdmNpZ3BPMXh1ZlR0Y2JseHVYRzUyWVhJZ2NtVnpaWFJKYm5CMWRFVnljbTl5SUQwZ1puVnVZM1JwYjI0b1pYWmxiblFwSUh0Y2JpQWdMeThnU1dZZ2NISmxjM01nWlc1MFpYSWdQVDRnYVdkdWIzSmxYRzRnSUdsbUlDaGxkbVZ1ZENBbUppQmxkbVZ1ZEM1clpYbERiMlJsSUQwOVBTQXhNeWtnZTF4dUlDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdmVnh1WEc0Z0lIWmhjaUFrYlc5a1lXd2dQU0JuWlhSTmIyUmhiQ2dwTzF4dVhHNGdJSFpoY2lBa1pYSnliM0pKWTI5dUlEMGdKRzF2WkdGc0xuRjFaWEo1VTJWc1pXTjBiM0lvSnk1ellTMXBibkIxZEMxbGNuSnZjaWNwTzF4dUlDQnlaVzF2ZG1WRGJHRnpjeWdrWlhKeWIzSkpZMjl1TENBbmMyaHZkeWNwTzF4dVhHNGdJSFpoY2lBa1pYSnliM0pEYjI1MFlXbHVaWElnUFNBa2JXOWtZV3d1Y1hWbGNubFRaV3hsWTNSdmNpZ25Mbk5oTFdWeWNtOXlMV052Ym5SaGFXNWxjaWNwTzF4dUlDQnlaVzF2ZG1WRGJHRnpjeWdrWlhKeWIzSkRiMjUwWVdsdVpYSXNJQ2R6YUc5M0p5azdYRzU5TzF4dVhHNWNiaThxWEc0Z0tpQlRaWFFnWENKdFlYSm5hVzR0ZEc5d1hDSXRjSEp2Y0dWeWRIa2diMjRnYlc5a1lXd2dZbUZ6WldRZ2IyNGdhWFJ6SUdOdmJYQjFkR1ZrSUdobGFXZG9kRnh1SUNvdlhHNTJZWElnWm1sNFZtVnlkR2xqWVd4UWIzTnBkR2x2YmlBOUlHWjFibU4wYVc5dUtDa2dlMXh1SUNCMllYSWdKRzF2WkdGc0lEMGdaMlYwVFc5a1lXd29LVHRjYmlBZ0pHMXZaR0ZzTG5OMGVXeGxMbTFoY21kcGJsUnZjQ0E5SUdkbGRGUnZjRTFoY21kcGJpaG5aWFJOYjJSaGJDZ3BLVHRjYm4wN1hHNWNibHh1Wlhod2IzSjBJSHNnWEc0Z0lITjNaV1YwUVd4bGNuUkpibWwwYVdGc2FYcGxMRnh1SUNCblpYUk5iMlJoYkN4Y2JpQWdaMlYwVDNabGNteGhlU3hjYmlBZ1oyVjBTVzV3ZFhRc1hHNGdJSE5sZEVadlkzVnpVM1I1YkdVc1hHNGdJRzl3Wlc1TmIyUmhiQ3hjYmlBZ2NtVnpaWFJKYm5CMWRDeGNiaUFnY21WelpYUkpibkIxZEVWeWNtOXlMRnh1SUNCbWFYaFdaWEowYVdOaGJGQnZjMmwwYVc5dVhHNTlPMXh1SWl3aWRtRnlJR2x1YW1WamRHVmtTRlJOVENBOUlGeHVYRzRnSUM4dklFUmhjbXNnYjNabGNteGhlVnh1SUNCZ1BHUnBkaUJqYkdGemN6MWNJbk4zWldWMExXOTJaWEpzWVhsY0lpQjBZV0pKYm1SbGVEMWNJaTB4WENJK1BDOWthWFkrWUNBclhHNWNiaUFnTHk4Z1RXOWtZV3hjYmlBZ1lEeGthWFlnWTJ4aGMzTTlYQ0p6ZDJWbGRDMWhiR1Z5ZEZ3aVBtQWdLMXh1WEc0Z0lDQWdMeThnUlhKeWIzSWdhV052Ymx4dUlDQWdJR0E4WkdsMklHTnNZWE56UFZ3aWMyRXRhV052YmlCellTMWxjbkp2Y2x3aVBseHVJQ0FnSUNBZ1BITndZVzRnWTJ4aGMzTTlYQ0p6WVMxNExXMWhjbXRjSWo1Y2JpQWdJQ0FnSUNBZ1BITndZVzRnWTJ4aGMzTTlYQ0p6WVMxc2FXNWxJSE5oTFd4bFpuUmNJajQ4TDNOd1lXNCtYRzRnSUNBZ0lDQWdJRHh6Y0dGdUlHTnNZWE56UFZ3aWMyRXRiR2x1WlNCellTMXlhV2RvZEZ3aVBqd3ZjM0JoYmo1Y2JpQWdJQ0FnSUR3dmMzQmhiajVjYmlBZ0lDQThMMlJwZGo1Z0lDdGNibHh1SUNBZ0lDOHZJRmRoY201cGJtY2dhV052Ymx4dUlDQWdJR0E4WkdsMklHTnNZWE56UFZ3aWMyRXRhV052YmlCellTMTNZWEp1YVc1blhDSStYRzRnSUNBZ0lDQThjM0JoYmlCamJHRnpjejFjSW5OaExXSnZaSGxjSWo0OEwzTndZVzQrWEc0Z0lDQWdJQ0E4YzNCaGJpQmpiR0Z6Y3oxY0luTmhMV1J2ZEZ3aVBqd3ZjM0JoYmo1Y2JpQWdJQ0E4TDJScGRqNWdJQ3RjYmx4dUlDQWdJQzh2SUVsdVptOGdhV052Ymx4dUlDQWdJR0E4WkdsMklHTnNZWE56UFZ3aWMyRXRhV052YmlCellTMXBibVp2WENJK1BDOWthWFkrWUNBclhHNWNiaUFnSUNBdkx5QlRkV05qWlhOeklHbGpiMjVjYmlBZ0lDQmdQR1JwZGlCamJHRnpjejFjSW5OaExXbGpiMjRnYzJFdGMzVmpZMlZ6YzF3aVBseHVJQ0FnSUNBZ1BITndZVzRnWTJ4aGMzTTlYQ0p6WVMxc2FXNWxJSE5oTFhScGNGd2lQand2YzNCaGJqNWNiaUFnSUNBZ0lEeHpjR0Z1SUdOc1lYTnpQVndpYzJFdGJHbHVaU0J6WVMxc2IyNW5YQ0krUEM5emNHRnVQbHh1WEc0Z0lDQWdJQ0E4WkdsMklHTnNZWE56UFZ3aWMyRXRjR3hoWTJWb2IyeGtaWEpjSWo0OEwyUnBkajVjYmlBZ0lDQWdJRHhrYVhZZ1kyeGhjM005WENKellTMW1hWGhjSWo0OEwyUnBkajVjYmlBZ0lDQThMMlJwZGo1Z0lDdGNibHh1SUNBZ0lHQThaR2wySUdOc1lYTnpQVndpYzJFdGFXTnZiaUJ6WVMxamRYTjBiMjFjSWo0OEwyUnBkajVnSUN0Y2JseHVJQ0FnSUM4dklGUnBkR3hsTENCMFpYaDBJR0Z1WkNCcGJuQjFkRnh1SUNBZ0lHQThhREkrVkdsMGJHVThMMmd5UGx4dUlDQWdJRHh3UGxSbGVIUThMM0ErWEc0Z0lDQWdQR1pwWld4a2MyVjBQbHh1SUNBZ0lDQWdQR2x1Y0hWMElIUjVjR1U5WENKMFpYaDBYQ0lnZEdGaVNXNWtaWGc5WENJelhDSWdMejVjYmlBZ0lDQWdJRHhrYVhZZ1kyeGhjM005WENKellTMXBibkIxZEMxbGNuSnZjbHdpUGp3dlpHbDJQbHh1SUNBZ0lEd3ZabWxsYkdSelpYUStZQ0FyWEc1Y2JpQWdJQ0F2THlCSmJuQjFkQ0JsY25KdmNuTmNiaUFnSUNCZ1BHUnBkaUJqYkdGemN6MWNJbk5oTFdWeWNtOXlMV052Ym5SaGFXNWxjbHdpUGx4dUlDQWdJQ0FnUEdScGRpQmpiR0Z6Y3oxY0ltbGpiMjVjSWo0aFBDOWthWFkrWEc0Z0lDQWdJQ0E4Y0Q1T2IzUWdkbUZzYVdRaFBDOXdQbHh1SUNBZ0lEd3ZaR2wyUG1BZ0sxeHVYRzRnSUNBZ0x5OGdRMkZ1WTJWc0lHRnVaQ0JqYjI1bWFYSnRJR0oxZEhSdmJuTmNiaUFnSUNCZ1BHUnBkaUJqYkdGemN6MWNJbk5oTFdKMWRIUnZiaTFqYjI1MFlXbHVaWEpjSWo1Y2JpQWdJQ0FnSUR4aWRYUjBiMjRnWTJ4aGMzTTlYQ0pqWVc1alpXeGNJaUIwWVdKSmJtUmxlRDFjSWpKY0lqNURZVzVqWld3OEwySjFkSFJ2Ymo1Y2JpQWdJQ0FnSUR4a2FYWWdZMnhoYzNNOVhDSnpZUzFqYjI1bWFYSnRMV0oxZEhSdmJpMWpiMjUwWVdsdVpYSmNJajVjYmlBZ0lDQWdJQ0FnUEdKMWRIUnZiaUJqYkdGemN6MWNJbU52Ym1acGNtMWNJaUIwWVdKSmJtUmxlRDFjSWpGY0lqNVBTend2WW5WMGRHOXVQbUFnS3lCY2JseHVJQ0FnSUNBZ0lDQXZMeUJNYjJGa2FXNW5JR0Z1YVcxaGRHbHZibHh1SUNBZ0lDQWdJQ0JnUEdScGRpQmpiR0Z6Y3oxY0lteGhMV0poYkd3dFptRnNiRndpUGx4dUlDQWdJQ0FnSUNBZ0lEeGthWFkrUEM5a2FYWStYRzRnSUNBZ0lDQWdJQ0FnUEdScGRqNDhMMlJwZGo1Y2JpQWdJQ0FnSUNBZ0lDQThaR2wyUGp3dlpHbDJQbHh1SUNBZ0lDQWdJQ0E4TDJScGRqNWNiaUFnSUNBZ0lEd3ZaR2wyUGx4dUlDQWdJRHd2WkdsMlBtQWdLMXh1WEc0Z0lDOHZJRVZ1WkNCdlppQnRiMlJoYkZ4dUlDQmdQQzlrYVhZK1lEdGNibHh1Wlhod2IzSjBJR1JsWm1GMWJIUWdhVzVxWldOMFpXUklWRTFNTzF4dUlpd2lkbUZ5SUdGc1pYSjBWSGx3WlhNZ1BTQmJKMlZ5Y205eUp5d2dKM2RoY201cGJtY25MQ0FuYVc1bWJ5Y3NJQ2R6ZFdOalpYTnpKeXdnSjJsdWNIVjBKeXdnSjNCeWIyMXdkQ2RkTzF4dVhHNXBiWEJ2Y25RZ2UxeHVJQ0JwYzBsRk9GeHVmU0JtY205dElDY3VMM1YwYVd4ekp6dGNibHh1YVcxd2IzSjBJSHRjYmlBZ1oyVjBUVzlrWVd3c1hHNGdJR2RsZEVsdWNIVjBMRnh1SUNCelpYUkdiMk4xYzFOMGVXeGxYRzU5SUdaeWIyMGdKeTR2YUdGdVpHeGxMWE4zWVd3dFpHOXRKenRjYmx4dWFXMXdiM0owSUh0Y2JpQWdhR0Z6UTJ4aGMzTXNJR0ZrWkVOc1lYTnpMQ0J5WlcxdmRtVkRiR0Z6Y3l4Y2JpQWdaWE5qWVhCbFNIUnRiQ3hjYmlBZ1gzTm9iM2NzSUhOb2IzY3NJRjlvYVdSbExDQm9hV1JsWEc1OUlHWnliMjBnSnk0dmFHRnVaR3hsTFdSdmJTYzdYRzVjYmx4dUx5cGNiaUFxSUZObGRDQjBlWEJsTENCMFpYaDBJR0Z1WkNCaFkzUnBiMjV6SUc5dUlHMXZaR0ZzWEc0Z0tpOWNiblpoY2lCelpYUlFZWEpoYldWMFpYSnpJRDBnWm5WdVkzUnBiMjRvY0dGeVlXMXpLU0I3WEc0Z0lIWmhjaUJ0YjJSaGJDQTlJR2RsZEUxdlpHRnNLQ2s3WEc1Y2JpQWdkbUZ5SUNSMGFYUnNaU0E5SUcxdlpHRnNMbkYxWlhKNVUyVnNaV04wYjNJb0oyZ3lKeWs3WEc0Z0lIWmhjaUFrZEdWNGRDQTlJRzF2WkdGc0xuRjFaWEo1VTJWc1pXTjBiM0lvSjNBbktUdGNiaUFnZG1GeUlDUmpZVzVqWld4Q2RHNGdQU0J0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5S0NkaWRYUjBiMjR1WTJGdVkyVnNKeWs3WEc0Z0lIWmhjaUFrWTI5dVptbHliVUowYmlBOUlHMXZaR0ZzTG5GMVpYSjVVMlZzWldOMGIzSW9KMkoxZEhSdmJpNWpiMjVtYVhKdEp5azdYRzVjYmlBZ0x5cGNiaUFnSUNvZ1ZHbDBiR1ZjYmlBZ0lDb3ZYRzRnSUNSMGFYUnNaUzVwYm01bGNraFVUVXdnUFNCd1lYSmhiWE11YUhSdGJDQS9JSEJoY21GdGN5NTBhWFJzWlNBNklHVnpZMkZ3WlVoMGJXd29jR0Z5WVcxekxuUnBkR3hsS1M1emNHeHBkQ2duWEZ4dUp5a3VhbTlwYmlnblBHSnlQaWNwTzF4dVhHNGdJQzhxWEc0Z0lDQXFJRlJsZUhSY2JpQWdJQ292WEc0Z0lDUjBaWGgwTG1sdWJtVnlTRlJOVENBOUlIQmhjbUZ0Y3k1b2RHMXNJRDhnY0dGeVlXMXpMblJsZUhRZ09pQmxjMk5oY0dWSWRHMXNLSEJoY21GdGN5NTBaWGgwSUh4OElDY25LUzV6Y0d4cGRDZ25YRnh1SnlrdWFtOXBiaWduUEdKeVBpY3BPMXh1SUNCcFppQW9jR0Z5WVcxekxuUmxlSFFwSUhOb2IzY29KSFJsZUhRcE8xeHVYRzRnSUM4cVhHNGdJQ0FxSUVOMWMzUnZiU0JqYkdGemMxeHVJQ0FnS2k5Y2JpQWdhV1lnS0hCaGNtRnRjeTVqZFhOMGIyMURiR0Z6Y3lrZ2UxeHVJQ0FnSUdGa1pFTnNZWE56S0cxdlpHRnNMQ0J3WVhKaGJYTXVZM1Z6ZEc5dFEyeGhjM01wTzF4dUlDQWdJRzF2WkdGc0xuTmxkRUYwZEhKcFluVjBaU2duWkdGMFlTMWpkWE4wYjIwdFkyeGhjM01uTENCd1lYSmhiWE11WTNWemRHOXRRMnhoYzNNcE8xeHVJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDOHZJRVpwYm1RZ2NISmxkbWx2ZFhOc2VTQnpaWFFnWTJ4aGMzTmxjeUJoYm1RZ2NtVnRiM1psSUhSb1pXMWNiaUFnSUNCc1pYUWdZM1Z6ZEc5dFEyeGhjM01nUFNCdGIyUmhiQzVuWlhSQmRIUnlhV0oxZEdVb0oyUmhkR0V0WTNWemRHOXRMV05zWVhOekp5azdYRzRnSUNBZ2NtVnRiM1psUTJ4aGMzTW9iVzlrWVd3c0lHTjFjM1J2YlVOc1lYTnpLVHRjYmlBZ0lDQnRiMlJoYkM1elpYUkJkSFJ5YVdKMWRHVW9KMlJoZEdFdFkzVnpkRzl0TFdOc1lYTnpKeXdnSnljcE8xeHVJQ0I5WEc1Y2JpQWdMeXBjYmlBZ0lDb2dTV052Ymx4dUlDQWdLaTljYmlBZ2FHbGtaU2h0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5UVd4c0tDY3VjMkV0YVdOdmJpY3BLVHRjYmx4dUlDQnBaaUFvY0dGeVlXMXpMblI1Y0dVZ0ppWWdJV2x6U1VVNEtDa3BJSHRjYmx4dUlDQWdJR3hsZENCMllXeHBaRlI1Y0dVZ1BTQm1ZV3h6WlR0Y2JseHVJQ0FnSUdadmNpQW9iR1YwSUdrZ1BTQXdPeUJwSUR3Z1lXeGxjblJVZVhCbGN5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnYVdZZ0tIQmhjbUZ0Y3k1MGVYQmxJRDA5UFNCaGJHVnlkRlI1Y0dWelcybGRLU0I3WEc0Z0lDQWdJQ0FnSUhaaGJHbGtWSGx3WlNBOUlIUnlkV1U3WEc0Z0lDQWdJQ0FnSUdKeVpXRnJPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2doZG1Gc2FXUlVlWEJsS1NCN1hHNGdJQ0FnSUNCc2IyZFRkSElvSjFWdWEyNXZkMjRnWVd4bGNuUWdkSGx3WlRvZ0p5QXJJSEJoY21GdGN5NTBlWEJsS1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUJtWVd4elpUdGNiaUFnSUNCOVhHNWNiaUFnSUNCc1pYUWdkSGx3WlhOWGFYUm9TV052Ym5NZ1BTQmJKM04xWTJObGMzTW5MQ0FuWlhKeWIzSW5MQ0FuZDJGeWJtbHVaeWNzSUNkcGJtWnZKMTA3WEc0Z0lDQWdiR1YwSUNScFkyOXVPMXh1WEc0Z0lDQWdhV1lnS0hSNWNHVnpWMmwwYUVsamIyNXpMbWx1WkdWNFQyWW9jR0Z5WVcxekxuUjVjR1VwSUNFOVBTQXRNU2tnZTF4dUlDQWdJQ0FnSkdsamIyNGdQU0J0YjJSaGJDNXhkV1Z5ZVZObGJHVmpkRzl5S0NjdWMyRXRhV052Ymk0bklDc2dKM05oTFNjZ0t5QndZWEpoYlhNdWRIbHdaU2s3WEc0Z0lDQWdJQ0J6YUc5M0tDUnBZMjl1S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzWlhRZ0pHbHVjSFYwSUQwZ1oyVjBTVzV3ZFhRb0tUdGNibHh1SUNBZ0lDOHZJRUZ1YVcxaGRHVWdhV052Ymx4dUlDQWdJSE4zYVhSamFDQW9jR0Z5WVcxekxuUjVjR1VwSUh0Y2JseHVJQ0FnSUNBZ1kyRnpaU0FuYzNWalkyVnpjeWM2WEc0Z0lDQWdJQ0FnSUdGa1pFTnNZWE56S0NScFkyOXVMQ0FuWVc1cGJXRjBaU2NwTzF4dUlDQWdJQ0FnSUNCaFpHUkRiR0Z6Y3lna2FXTnZiaTV4ZFdWeWVWTmxiR1ZqZEc5eUtDY3VjMkV0ZEdsd0p5a3NJQ2RoYm1sdFlYUmxVM1ZqWTJWemMxUnBjQ2NwTzF4dUlDQWdJQ0FnSUNCaFpHUkRiR0Z6Y3lna2FXTnZiaTV4ZFdWeWVWTmxiR1ZqZEc5eUtDY3VjMkV0Ykc5dVp5Y3BMQ0FuWVc1cGJXRjBaVk4xWTJObGMzTk1iMjVuSnlrN1hHNGdJQ0FnSUNBZ0lHSnlaV0ZyTzF4dVhHNGdJQ0FnSUNCallYTmxJQ2RsY25KdmNpYzZYRzRnSUNBZ0lDQWdJR0ZrWkVOc1lYTnpLQ1JwWTI5dUxDQW5ZVzVwYldGMFpVVnljbTl5U1dOdmJpY3BPMXh1SUNBZ0lDQWdJQ0JoWkdSRGJHRnpjeWdrYVdOdmJpNXhkV1Z5ZVZObGJHVmpkRzl5S0NjdWMyRXRlQzF0WVhKckp5a3NJQ2RoYm1sdFlYUmxXRTFoY21zbktUdGNiaUFnSUNBZ0lDQWdZbkpsWVdzN1hHNWNiaUFnSUNBZ0lHTmhjMlVnSjNkaGNtNXBibWNuT2x4dUlDQWdJQ0FnSUNCaFpHUkRiR0Z6Y3lna2FXTnZiaXdnSjNCMWJITmxWMkZ5Ym1sdVp5Y3BPMXh1SUNBZ0lDQWdJQ0JoWkdSRGJHRnpjeWdrYVdOdmJpNXhkV1Z5ZVZObGJHVmpkRzl5S0NjdWMyRXRZbTlrZVNjcExDQW5jSFZzYzJWWFlYSnVhVzVuU1c1ekp5azdYRzRnSUNBZ0lDQWdJR0ZrWkVOc1lYTnpLQ1JwWTI5dUxuRjFaWEo1VTJWc1pXTjBiM0lvSnk1ellTMWtiM1FuS1N3Z0ozQjFiSE5sVjJGeWJtbHVaMGx1Y3ljcE8xeHVJQ0FnSUNBZ0lDQmljbVZoYXp0Y2JseHVJQ0FnSUNBZ1kyRnpaU0FuYVc1d2RYUW5PbHh1SUNBZ0lDQWdZMkZ6WlNBbmNISnZiWEIwSnpwY2JpQWdJQ0FnSUNBZ0pHbHVjSFYwTG5ObGRFRjBkSEpwWW5WMFpTZ25kSGx3WlNjc0lIQmhjbUZ0Y3k1cGJuQjFkRlI1Y0dVcE8xeHVJQ0FnSUNBZ0lDQWthVzV3ZFhRdWRtRnNkV1VnUFNCd1lYSmhiWE11YVc1d2RYUldZV3gxWlR0Y2JpQWdJQ0FnSUNBZ0pHbHVjSFYwTG5ObGRFRjBkSEpwWW5WMFpTZ25jR3hoWTJWb2IyeGtaWEluTENCd1lYSmhiWE11YVc1d2RYUlFiR0ZqWldodmJHUmxjaWs3WEc0Z0lDQWdJQ0FnSUdGa1pFTnNZWE56S0cxdlpHRnNMQ0FuYzJodmR5MXBibkIxZENjcE8xeHVJQ0FnSUNBZ0lDQnpaWFJVYVcxbGIzVjBLR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWthVzV3ZFhRdVptOWpkWE1vS1R0Y2JpQWdJQ0FnSUNBZ0lDQWthVzV3ZFhRdVlXUmtSWFpsYm5STWFYTjBaVzVsY2lnbmEyVjVkWEFuTENCemQyRnNMbkpsYzJWMFNXNXdkWFJGY25KdmNpazdYRzRnSUNBZ0lDQWdJSDBzSURRd01DazdYRzRnSUNBZ0lDQWdJR0p5WldGck8xeHVJQ0FnSUgxY2JpQWdmVnh1WEc0Z0lDOHFYRzRnSUNBcUlFTjFjM1J2YlNCcGJXRm5aVnh1SUNBZ0tpOWNiaUFnYVdZZ0tIQmhjbUZ0Y3k1cGJXRm5aVlZ5YkNrZ2UxeHVJQ0FnSUd4bGRDQWtZM1Z6ZEc5dFNXTnZiaUE5SUcxdlpHRnNMbkYxWlhKNVUyVnNaV04wYjNJb0p5NXpZUzFwWTI5dUxuTmhMV04xYzNSdmJTY3BPMXh1WEc0Z0lDQWdKR04xYzNSdmJVbGpiMjR1YzNSNWJHVXVZbUZqYTJkeWIzVnVaRWx0WVdkbElEMGdKM1Z5YkNnbklDc2djR0Z5WVcxekxtbHRZV2RsVlhKc0lDc2dKeWtuTzF4dUlDQWdJSE5vYjNjb0pHTjFjM1J2YlVsamIyNHBPMXh1WEc0Z0lDQWdiR1YwSUY5cGJXZFhhV1IwYUNBOUlEZ3dPMXh1SUNBZ0lHeGxkQ0JmYVcxblNHVnBaMmgwSUQwZ09EQTdYRzVjYmlBZ0lDQnBaaUFvY0dGeVlXMXpMbWx0WVdkbFUybDZaU2tnZTF4dUlDQWdJQ0FnYkdWMElHUnBiV1Z1YzJsdmJuTWdQU0J3WVhKaGJYTXVhVzFoWjJWVGFYcGxMblJ2VTNSeWFXNW5LQ2t1YzNCc2FYUW9KM2duS1R0Y2JpQWdJQ0FnSUd4bGRDQnBiV2RYYVdSMGFDQTlJR1JwYldWdWMybHZibk5iTUYwN1hHNGdJQ0FnSUNCc1pYUWdhVzFuU0dWcFoyaDBJRDBnWkdsdFpXNXphVzl1YzFzeFhUdGNibHh1SUNBZ0lDQWdhV1lnS0NGcGJXZFhhV1IwYUNCOGZDQWhhVzFuU0dWcFoyaDBLU0I3WEc0Z0lDQWdJQ0FnSUd4dloxTjBjaWduVUdGeVlXMWxkR1Z5SUdsdFlXZGxVMmw2WlNCbGVIQmxZM1J6SUhaaGJIVmxJSGRwZEdnZ1ptOXliV0YwSUZkSlJGUkllRWhGU1VkSVZDd2daMjkwSUNjZ0t5QndZWEpoYlhNdWFXMWhaMlZUYVhwbEtUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lGOXBiV2RYYVdSMGFDQTlJR2x0WjFkcFpIUm9PMXh1SUNBZ0lDQWdJQ0JmYVcxblNHVnBaMmgwSUQwZ2FXMW5TR1ZwWjJoME8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUNSamRYTjBiMjFKWTI5dUxuTmxkRUYwZEhKcFluVjBaU2duYzNSNWJHVW5MQ0FrWTNWemRHOXRTV052Ymk1blpYUkJkSFJ5YVdKMWRHVW9KM04wZVd4bEp5a2dLeUFuZDJsa2RHZzZKeUFySUY5cGJXZFhhV1IwYUNBcklDZHdlRHNnYUdWcFoyaDBPaWNnS3lCZmFXMW5TR1ZwWjJoMElDc2dKM0I0SnlrN1hHNGdJSDFjYmx4dUlDQXZLbHh1SUNBZ0tpQlRhRzkzSUdOaGJtTmxiQ0JpZFhSMGIyNC9YRzRnSUNBcUwxeHVJQ0J0YjJSaGJDNXpaWFJCZEhSeWFXSjFkR1VvSjJSaGRHRXRhR0Z6TFdOaGJtTmxiQzFpZFhSMGIyNG5MQ0J3WVhKaGJYTXVjMmh2ZDBOaGJtTmxiRUoxZEhSdmJpazdYRzRnSUdsbUlDaHdZWEpoYlhNdWMyaHZkME5oYm1ObGJFSjFkSFJ2YmlrZ2UxeHVJQ0FnSUNSallXNWpaV3hDZEc0dWMzUjViR1V1WkdsemNHeGhlU0E5SUNkcGJteHBibVV0WW14dlkyc25PMXh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJR2hwWkdVb0pHTmhibU5sYkVKMGJpazdYRzRnSUgxY2JseHVJQ0F2S2x4dUlDQWdLaUJUYUc5M0lHTnZibVpwY20wZ1luVjBkRzl1UDF4dUlDQWdLaTljYmlBZ2JXOWtZV3d1YzJWMFFYUjBjbWxpZFhSbEtDZGtZWFJoTFdoaGN5MWpiMjVtYVhKdExXSjFkSFJ2Ymljc0lIQmhjbUZ0Y3k1emFHOTNRMjl1Wm1seWJVSjFkSFJ2YmlrN1hHNGdJR2xtSUNod1lYSmhiWE11YzJodmQwTnZibVpwY20xQ2RYUjBiMjRwSUh0Y2JpQWdJQ0FrWTI5dVptbHliVUowYmk1emRIbHNaUzVrYVhOd2JHRjVJRDBnSjJsdWJHbHVaUzFpYkc5amF5YzdYRzRnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdhR2xrWlNna1kyOXVabWx5YlVKMGJpazdYRzRnSUgxY2JseHVJQ0F2S2x4dUlDQWdLaUJEZFhOMGIyMGdkR1Y0ZENCdmJpQmpZVzVqWld3dlkyOXVabWx5YlNCaWRYUjBiMjV6WEc0Z0lDQXFMMXh1SUNCcFppQW9jR0Z5WVcxekxtTmhibU5sYkVKMWRIUnZibFJsZUhRcElIdGNiaUFnSUNBa1kyRnVZMlZzUW5SdUxtbHVibVZ5U0ZSTlRDQTlJR1Z6WTJGd1pVaDBiV3dvY0dGeVlXMXpMbU5oYm1ObGJFSjFkSFJ2YmxSbGVIUXBPMXh1SUNCOVhHNGdJR2xtSUNod1lYSmhiWE11WTI5dVptbHliVUoxZEhSdmJsUmxlSFFwSUh0Y2JpQWdJQ0FrWTI5dVptbHliVUowYmk1cGJtNWxja2hVVFV3Z1BTQmxjMk5oY0dWSWRHMXNLSEJoY21GdGN5NWpiMjVtYVhKdFFuVjBkRzl1VkdWNGRDazdYRzRnSUgxY2JseHVJQ0F2S2x4dUlDQWdLaUJEZFhOMGIyMGdZMjlzYjNJZ2IyNGdZMjl1Wm1seWJTQmlkWFIwYjI1Y2JpQWdJQ292WEc0Z0lHbG1JQ2h3WVhKaGJYTXVZMjl1Wm1seWJVSjFkSFJ2YmtOdmJHOXlLU0I3WEc0Z0lDQWdMeThnVTJWMElHTnZibVpwY20wZ1luVjBkRzl1SUhSdklITmxiR1ZqZEdWa0lHSmhZMnRuY205MWJtUWdZMjlzYjNKY2JpQWdJQ0FrWTI5dVptbHliVUowYmk1emRIbHNaUzVpWVdOclozSnZkVzVrUTI5c2IzSWdQU0J3WVhKaGJYTXVZMjl1Wm1seWJVSjFkSFJ2YmtOdmJHOXlPMXh1WEc0Z0lDQWdMeThnVTJWMElIUm9aU0JqYjI1bWFYSnRJR0oxZEhSdmJpQmpiMnh2Y2lCMGJ5QjBhR1VnYkc5aFpHbHVaeUJ5YVc1blhHNGdJQ0FnSkdOdmJtWnBjbTFDZEc0dWMzUjViR1V1WW05eVpHVnlUR1ZtZEVOdmJHOXlJRDBnY0dGeVlXMXpMbU52Ym1acGNtMU1iMkZrYVc1blFuVjBkRzl1UTI5c2IzSTdYRzRnSUNBZ0pHTnZibVpwY20xQ2RHNHVjM1I1YkdVdVltOXlaR1Z5VW1sbmFIUkRiMnh2Y2lBOUlIQmhjbUZ0Y3k1amIyNW1hWEp0VEc5aFpHbHVaMEoxZEhSdmJrTnZiRzl5TzF4dVhHNGdJQ0FnTHk4Z1UyVjBJR0p2ZUMxemFHRmtiM2NnZEc4Z1pHVm1ZWFZzZENCbWIyTjFjMlZrSUdKMWRIUnZibHh1SUNBZ0lITmxkRVp2WTNWelUzUjViR1VvSkdOdmJtWnBjbTFDZEc0c0lIQmhjbUZ0Y3k1amIyNW1hWEp0UW5WMGRHOXVRMjlzYjNJcE8xeHVJQ0I5WEc1Y2JpQWdMeXBjYmlBZ0lDb2dRV3hzYjNjZ2IzVjBjMmxrWlNCamJHbGphMXh1SUNBZ0tpOWNiaUFnYlc5a1lXd3VjMlYwUVhSMGNtbGlkWFJsS0Nka1lYUmhMV0ZzYkc5M0xXOTFkSE5wWkdVdFkyeHBZMnNuTENCd1lYSmhiWE11WVd4c2IzZFBkWFJ6YVdSbFEyeHBZMnNwTzF4dVhHNGdJQzhxWEc0Z0lDQXFJRU5oYkd4aVlXTnJJR1oxYm1OMGFXOXVYRzRnSUNBcUwxeHVJQ0IyWVhJZ2FHRnpSRzl1WlVaMWJtTjBhVzl1SUQwZ2NHRnlZVzF6TG1SdmJtVkdkVzVqZEdsdmJpQS9JSFJ5ZFdVZ09pQm1ZV3h6WlR0Y2JpQWdiVzlrWVd3dWMyVjBRWFIwY21saWRYUmxLQ2RrWVhSaExXaGhjeTFrYjI1bExXWjFibU4wYVc5dUp5d2dhR0Z6Ukc5dVpVWjFibU4wYVc5dUtUdGNibHh1SUNBdktseHVJQ0FnS2lCQmJtbHRZWFJwYjI1Y2JpQWdJQ292WEc0Z0lHbG1JQ2doY0dGeVlXMXpMbUZ1YVcxaGRHbHZiaWtnZTF4dUlDQWdJRzF2WkdGc0xuTmxkRUYwZEhKcFluVjBaU2duWkdGMFlTMWhibWx0WVhScGIyNG5MQ0FuYm05dVpTY3BPMXh1SUNCOUlHVnNjMlVnYVdZZ0tIUjVjR1Z2WmlCd1lYSmhiWE11WVc1cGJXRjBhVzl1SUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lHMXZaR0ZzTG5ObGRFRjBkSEpwWW5WMFpTZ25aR0YwWVMxaGJtbHRZWFJwYjI0bkxDQndZWEpoYlhNdVlXNXBiV0YwYVc5dUtUc2dMeThnUTNWemRHOXRJR0Z1YVcxaGRHbHZibHh1SUNCOUlHVnNjMlVnZTF4dUlDQWdJRzF2WkdGc0xuTmxkRUYwZEhKcFluVjBaU2duWkdGMFlTMWhibWx0WVhScGIyNG5MQ0FuY0c5d0p5azdYRzRnSUgxY2JseHVJQ0F2S2x4dUlDQWdLaUJVYVcxbGNseHVJQ0FnS2k5Y2JpQWdiVzlrWVd3dWMyVjBRWFIwY21saWRYUmxLQ2RrWVhSaExYUnBiV1Z5Snl3Z2NHRnlZVzF6TG5ScGJXVnlLVHRjYm4wN1hHNWNibVY0Y0c5eWRDQmtaV1poZFd4MElITmxkRkJoY21GdFpYUmxjbk03WEc0aUxDSXZLbHh1SUNvZ1FXeHNiM2NnZFhObGNpQjBieUJ3WVhOeklIUm9aV2x5SUc5M2JpQndZWEpoYlhOY2JpQXFMMXh1ZG1GeUlHVjRkR1Z1WkNBOUlHWjFibU4wYVc5dUtHRXNJR0lwSUh0Y2JpQWdabTl5SUNoMllYSWdhMlY1SUdsdUlHSXBJSHRjYmlBZ0lDQnBaaUFvWWk1b1lYTlBkMjVRY205d1pYSjBlU2hyWlhrcEtTQjdYRzRnSUNBZ0lDQmhXMnRsZVYwZ1BTQmlXMnRsZVYwN1hHNGdJQ0FnZlZ4dUlDQjlYRzRnSUhKbGRIVnliaUJoTzF4dWZUdGNibHh1THlwY2JpQXFJRU52Ym5abGNuUWdTRVZZSUdOdlpHVnpJSFJ2SUZKSFFpQjJZV3gxWlhNZ0tDTXdNREF3TURBZ0xUNGdjbWRpS0RBc01Dd3dLU2xjYmlBcUwxeHVkbUZ5SUdobGVGUnZVbWRpSUQwZ1puVnVZM1JwYjI0b2FHVjRLU0I3WEc0Z0lIWmhjaUJ5WlhOMWJIUWdQU0F2WGlNL0tGdGhMV1pjWEdSZGV6SjlLU2hiWVMxbVhGeGtYWHN5ZlNrb1cyRXRabHhjWkYxN01uMHBKQzlwTG1WNFpXTW9hR1Y0S1R0Y2JpQWdjbVYwZFhKdUlISmxjM1ZzZENBL0lIQmhjbk5sU1c1MEtISmxjM1ZzZEZzeFhTd2dNVFlwSUNzZ0p5d2dKeUFySUhCaGNuTmxTVzUwS0hKbGMzVnNkRnN5WFN3Z01UWXBJQ3NnSnl3Z0p5QXJJSEJoY25ObFNXNTBLSEpsYzNWc2RGc3pYU3dnTVRZcElEb2diblZzYkR0Y2JuMDdYRzVjYmk4cVhHNGdLaUJEYUdWamF5QnBaaUIwYUdVZ2RYTmxjaUJwY3lCMWMybHVaeUJKYm5SbGNtNWxkQ0JGZUhCc2IzSmxjaUE0SUNobWIzSWdabUZzYkdKaFkydHpLVnh1SUNvdlhHNTJZWElnYVhOSlJUZ2dQU0JtZFc1amRHbHZiaWdwSUh0Y2JpQWdjbVYwZFhKdUlDaDNhVzVrYjNjdVlYUjBZV05vUlhabGJuUWdKaVlnSVhkcGJtUnZkeTVoWkdSRmRtVnVkRXhwYzNSbGJtVnlLVHRjYm4wN1hHNWNiaThxWEc0Z0tpQkpSU0JqYjIxd1lYUnBZbXhsSUd4dloyZHBibWNnWm05eUlHUmxkbVZzYjNCbGNuTmNiaUFxTDF4dWRtRnlJR3h2WjFOMGNpQTlJR1oxYm1OMGFXOXVLSE4wY21sdVp5a2dlMXh1SUNCcFppQW9kMmx1Wkc5M0xtTnZibk52YkdVcElIdGNiaUFnSUNBdkx5QkpSUzR1TGx4dUlDQWdJSGRwYm1SdmR5NWpiMjV6YjJ4bExteHZaeWduVTNkbFpYUkJiR1Z5ZERvZ0p5QXJJSE4wY21sdVp5azdYRzRnSUgxY2JuMDdYRzVjYmk4cVhHNGdLaUJUWlhRZ2FHOTJaWElzSUdGamRHbDJaU0JoYm1RZ1ptOWpkWE10YzNSaGRHVnpJR1p2Y2lCaWRYUjBiMjV6SUZ4dUlDb2dLSE52ZFhKalpUb2dhSFIwY0RvdkwzZDNkeTV6YVhSbGNHOXBiblF1WTI5dEwycGhkbUZ6WTNKcGNIUXRaMlZ1WlhKaGRHVXRiR2xuYUhSbGNpMWtZWEpyWlhJdFkyOXNiM0lwWEc0Z0tpOWNiblpoY2lCamIyeHZja3gxYldsdVlXNWpaU0E5SUdaMWJtTjBhVzl1S0dobGVDd2diSFZ0S1NCN1hHNGdJQzh2SUZaaGJHbGtZWFJsSUdobGVDQnpkSEpwYm1kY2JpQWdhR1Y0SUQwZ1UzUnlhVzVuS0dobGVDa3VjbVZ3YkdGalpTZ3ZXMTR3TFRsaExXWmRMMmRwTENBbkp5azdYRzRnSUdsbUlDaG9aWGd1YkdWdVozUm9JRHdnTmlrZ2UxeHVJQ0FnSUdobGVDQTlJR2hsZUZzd1hTQXJJR2hsZUZzd1hTQXJJR2hsZUZzeFhTQXJJR2hsZUZzeFhTQXJJR2hsZUZzeVhTQXJJR2hsZUZzeVhUdGNiaUFnZlZ4dUlDQnNkVzBnUFNCc2RXMGdmSHdnTUR0Y2JseHVJQ0F2THlCRGIyNTJaWEowSUhSdklHUmxZMmx0WVd3Z1lXNWtJR05vWVc1blpTQnNkVzFwYm05emFYUjVYRzRnSUhaaGNpQnlaMklnUFNBbkl5YzdYRzRnSUhaaGNpQmpPMXh1SUNCMllYSWdhVHRjYmx4dUlDQm1iM0lnS0drZ1BTQXdPeUJwSUR3Z016c2dhU3NyS1NCN1hHNGdJQ0FnWXlBOUlIQmhjbk5sU1c1MEtHaGxlQzV6ZFdKemRISW9hU0FxSURJc0lESXBMQ0F4TmlrN1hHNGdJQ0FnWXlBOUlFMWhkR2d1Y205MWJtUW9UV0YwYUM1dGFXNG9UV0YwYUM1dFlYZ29NQ3dnWXlBcklHTWdLaUJzZFcwcExDQXlOVFVwS1M1MGIxTjBjbWx1WnlneE5pazdYRzRnSUNBZ2NtZGlJQ3M5SUNnbk1EQW5JQ3NnWXlrdWMzVmljM1J5S0dNdWJHVnVaM1JvS1R0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCeVoySTdYRzU5TzF4dVhHNWNibVY0Y0c5eWRDQjdYRzRnSUdWNGRHVnVaQ3hjYmlBZ2FHVjRWRzlTWjJJc1hHNGdJR2x6U1VVNExGeHVJQ0JzYjJkVGRISXNYRzRnSUdOdmJHOXlUSFZ0YVc1aGJtTmxYRzU5TzF4dUlsMTlcXG5cXG4gIFxcbiAgLypcXG4gICAqIFVzZSBTd2VldEFsZXJ0IHdpdGggUmVxdWlyZUpTXFxuICAgKi9cXG4gIFxcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBzd2VldEFsZXJ0O1xcbiAgICB9KTtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzd2VldEFsZXJ0O1xcbiAgfVxcblxcbn0pKHdpbmRvdywgZG9jdW1lbnQpO1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL2Jvd2VyX2NvbXBvbmVudHMvc3dlZXRhbGVydC9kaXN0L3N3ZWV0YWxlcnQtZGV2LmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=